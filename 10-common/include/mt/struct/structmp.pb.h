// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structmp.proto

#ifndef PROTOBUF_structmp_2eproto__INCLUDED
#define PROTOBUF_structmp_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "enum.pb.h"
#include "structcommon.pb.h"
#include "structcfg.pb.h"
// @@protoc_insertion_point(includes)

namespace mt {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_structmp_2eproto();
void protobuf_AssignDesc_structmp_2eproto();
void protobuf_ShutdownFile_structmp_2eproto();

class TRtpRtcpPair;
class TNetRcvParam;
class TNetSndParam;
class TVidEncParam;
class TAudEncDecParam;
class TAudEncStatistic;
class TAudDecStatistic;
class TVidEncStatistic;
class TVidDecStatistic;
class TAudMixStatistic;
class TVidMixStatistic;
class TMtBweReceiver;
class TVidBweStatus;
class TCodecBweStatus;
class TCodecStatistic;
class TDevInfo;
class TDevInfoList;
class TVMPMemParam;
class TMultiVMPMemParam;
class TMixerMemParam;
class TMultiMixerMemParam;
class TRecordParam;
class TRecordDiskAlarmLevel;
class TImageParam;
class TDefaultImageParam;
class TAudInputState;
class TMultiAudInputState;
class TAudOutputState;
class TMultiAudOutputState;
class TVideoResDetect;
class TMultiVideoResDetect;
class TFxoState;
class TMtVidSrcInfo;
class TMtVidSrcInfoList;
class TMtVidInPortResInfo;
class TMtVidInPortResInfoList;
class TSnapshotFileInfo;
class TSnapshotFileList;
class TMtTranspDColor;
class TMtAddLogoParam;
class TMtFullLogoParam;
class TRpMtFullLogoParam;
class TMtPIPMode;
class TMTVideoInOutPortModeList;
class TAddRecordAudioMediaInfo;
class TAddRecordVideoMediaInfo;
class TWriteRecord;
class TMtCameraVidStd;
class TMtHwChipInfo;
class TMtHwChipInfoList;
class TMtQkState;
class TVidInputState;
class TMtNtfAgentSignalInfo;

// ===================================================================

class MTMSG_API TRtpRtcpPair : public ::google::protobuf::Message {
 public:
  TRtpRtcpPair();
  virtual ~TRtpRtcpPair();

  TRtpRtcpPair(const TRtpRtcpPair& from);

  inline TRtpRtcpPair& operator=(const TRtpRtcpPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRtpRtcpPair& default_instance();

  void Swap(TRtpRtcpPair* other);

  // implements Message ----------------------------------------------

  TRtpRtcpPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRtpRtcpPair& from);
  void MergeFrom(const TRtpRtcpPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TNetAddr rtp_addr = 1;
  inline bool has_rtp_addr() const;
  inline void clear_rtp_addr();
  static const int kRtpAddrFieldNumber = 1;
  inline const ::mt::TNetAddr& rtp_addr() const;
  inline ::mt::TNetAddr* mutable_rtp_addr();
  inline ::mt::TNetAddr* release_rtp_addr();
  inline void set_allocated_rtp_addr(::mt::TNetAddr* rtp_addr);

  // optional .mt.TNetAddr rtcp_addr = 2;
  inline bool has_rtcp_addr() const;
  inline void clear_rtcp_addr();
  static const int kRtcpAddrFieldNumber = 2;
  inline const ::mt::TNetAddr& rtcp_addr() const;
  inline ::mt::TNetAddr* mutable_rtcp_addr();
  inline ::mt::TNetAddr* release_rtcp_addr();
  inline void set_allocated_rtcp_addr(::mt::TNetAddr* rtcp_addr);

  // @@protoc_insertion_point(class_scope:mt.TRtpRtcpPair)
 private:
  inline void set_has_rtp_addr();
  inline void clear_has_rtp_addr();
  inline void set_has_rtcp_addr();
  inline void clear_has_rtcp_addr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TNetAddr* rtp_addr_;
  ::mt::TNetAddr* rtcp_addr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TRtpRtcpPair* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNetRcvParam : public ::google::protobuf::Message {
 public:
  TNetRcvParam();
  virtual ~TNetRcvParam();

  TNetRcvParam(const TNetRcvParam& from);

  inline TNetRcvParam& operator=(const TNetRcvParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNetRcvParam& default_instance();

  void Swap(TNetRcvParam* other);

  // implements Message ----------------------------------------------

  TNetRcvParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNetRcvParam& from);
  void MergeFrom(const TNetRcvParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TNetAddr rtp_rcv_addr = 1;
  inline bool has_rtp_rcv_addr() const;
  inline void clear_rtp_rcv_addr();
  static const int kRtpRcvAddrFieldNumber = 1;
  inline const ::mt::TNetAddr& rtp_rcv_addr() const;
  inline ::mt::TNetAddr* mutable_rtp_rcv_addr();
  inline ::mt::TNetAddr* release_rtp_rcv_addr();
  inline void set_allocated_rtp_rcv_addr(::mt::TNetAddr* rtp_rcv_addr);

  // optional .mt.TNetAddr rtcp_rcv_addr = 2;
  inline bool has_rtcp_rcv_addr() const;
  inline void clear_rtcp_rcv_addr();
  static const int kRtcpRcvAddrFieldNumber = 2;
  inline const ::mt::TNetAddr& rtcp_rcv_addr() const;
  inline ::mt::TNetAddr* mutable_rtcp_rcv_addr();
  inline ::mt::TNetAddr* release_rtcp_rcv_addr();
  inline void set_allocated_rtcp_rcv_addr(::mt::TNetAddr* rtcp_rcv_addr);

  // optional .mt.TNetAddr pinghole_addr = 3;
  inline bool has_pinghole_addr() const;
  inline void clear_pinghole_addr();
  static const int kPingholeAddrFieldNumber = 3;
  inline const ::mt::TNetAddr& pinghole_addr() const;
  inline ::mt::TNetAddr* mutable_pinghole_addr();
  inline ::mt::TNetAddr* release_pinghole_addr();
  inline void set_allocated_pinghole_addr(::mt::TNetAddr* pinghole_addr);

  // optional .mt.TNetAddr rtcp_snd_addr = 4;
  inline bool has_rtcp_snd_addr() const;
  inline void clear_rtcp_snd_addr();
  static const int kRtcpSndAddrFieldNumber = 4;
  inline const ::mt::TNetAddr& rtcp_snd_addr() const;
  inline ::mt::TNetAddr* mutable_rtcp_snd_addr();
  inline ::mt::TNetAddr* release_rtcp_snd_addr();
  inline void set_allocated_rtcp_snd_addr(::mt::TNetAddr* rtcp_snd_addr);

  // @@protoc_insertion_point(class_scope:mt.TNetRcvParam)
 private:
  inline void set_has_rtp_rcv_addr();
  inline void clear_has_rtp_rcv_addr();
  inline void set_has_rtcp_rcv_addr();
  inline void clear_has_rtcp_rcv_addr();
  inline void set_has_pinghole_addr();
  inline void clear_has_pinghole_addr();
  inline void set_has_rtcp_snd_addr();
  inline void clear_has_rtcp_snd_addr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TNetAddr* rtp_rcv_addr_;
  ::mt::TNetAddr* rtcp_rcv_addr_;
  ::mt::TNetAddr* pinghole_addr_;
  ::mt::TNetAddr* rtcp_snd_addr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TNetRcvParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNetSndParam : public ::google::protobuf::Message {
 public:
  TNetSndParam();
  virtual ~TNetSndParam();

  TNetSndParam(const TNetSndParam& from);

  inline TNetSndParam& operator=(const TNetSndParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNetSndParam& default_instance();

  void Swap(TNetSndParam* other);

  // implements Message ----------------------------------------------

  TNetSndParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNetSndParam& from);
  void MergeFrom(const TNetSndParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TRtpRtcpPair local_addr = 1;
  inline bool has_local_addr() const;
  inline void clear_local_addr();
  static const int kLocalAddrFieldNumber = 1;
  inline const ::mt::TRtpRtcpPair& local_addr() const;
  inline ::mt::TRtpRtcpPair* mutable_local_addr();
  inline ::mt::TRtpRtcpPair* release_local_addr();
  inline void set_allocated_local_addr(::mt::TRtpRtcpPair* local_addr);

  // repeated .mt.TRtpRtcpPair remote_addrs = 2;
  inline int remote_addrs_size() const;
  inline void clear_remote_addrs();
  static const int kRemoteAddrsFieldNumber = 2;
  inline const ::mt::TRtpRtcpPair& remote_addrs(int index) const;
  inline ::mt::TRtpRtcpPair* mutable_remote_addrs(int index);
  inline ::mt::TRtpRtcpPair* add_remote_addrs();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPair >&
      remote_addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPair >*
      mutable_remote_addrs();

  // @@protoc_insertion_point(class_scope:mt.TNetSndParam)
 private:
  inline void set_has_local_addr();
  inline void clear_has_local_addr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TRtpRtcpPair* local_addr_;
  ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPair > remote_addrs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TNetSndParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidEncParam : public ::google::protobuf::Message {
 public:
  TVidEncParam();
  virtual ~TVidEncParam();

  TVidEncParam(const TVidEncParam& from);

  inline TVidEncParam& operator=(const TVidEncParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidEncParam& default_instance();

  void Swap(TVidEncParam* other);

  // implements Message ----------------------------------------------

  TVidEncParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidEncParam& from);
  void MergeFrom(const TVidEncParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmEncodeMode enc_mode = 1;
  inline bool has_enc_mode() const;
  inline void clear_enc_mode();
  static const int kEncModeFieldNumber = 1;
  inline ::mt::EmEncodeMode enc_mode() const;
  inline void set_enc_mode(::mt::EmEncodeMode value);

  // optional .mt.EmVidFormat vid_format = 2;
  inline bool has_vid_format() const;
  inline void clear_vid_format();
  static const int kVidFormatFieldNumber = 2;
  inline ::mt::EmVidFormat vid_format() const;
  inline void set_vid_format(::mt::EmVidFormat value);

  // optional uint32 max_key_frame_interval = 3;
  inline bool has_max_key_frame_interval() const;
  inline void clear_max_key_frame_interval();
  static const int kMaxKeyFrameIntervalFieldNumber = 3;
  inline ::google::protobuf::uint32 max_key_frame_interval() const;
  inline void set_max_key_frame_interval(::google::protobuf::uint32 value);

  // optional uint32 max_quant = 4;
  inline bool has_max_quant() const;
  inline void clear_max_quant();
  static const int kMaxQuantFieldNumber = 4;
  inline ::google::protobuf::uint32 max_quant() const;
  inline void set_max_quant(::google::protobuf::uint32 value);

  // optional uint32 min_quant = 5;
  inline bool has_min_quant() const;
  inline void clear_min_quant();
  static const int kMinQuantFieldNumber = 5;
  inline ::google::protobuf::uint32 min_quant() const;
  inline void set_min_quant(::google::protobuf::uint32 value);

  // optional uint32 frame_rate = 6;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 6;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 7;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 7;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional uint32 h264_profile = 8;
  inline bool has_h264_profile() const;
  inline void clear_h264_profile();
  static const int kH264ProfileFieldNumber = 8;
  inline ::google::protobuf::uint32 h264_profile() const;
  inline void set_h264_profile(::google::protobuf::uint32 value);

  // optional uint32 width = 9;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 9;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 10;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 10;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TVidEncParam)
 private:
  inline void set_has_enc_mode();
  inline void clear_has_enc_mode();
  inline void set_has_vid_format();
  inline void clear_has_vid_format();
  inline void set_has_max_key_frame_interval();
  inline void clear_has_max_key_frame_interval();
  inline void set_has_max_quant();
  inline void clear_has_max_quant();
  inline void set_has_min_quant();
  inline void clear_has_min_quant();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_h264_profile();
  inline void clear_has_h264_profile();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int enc_mode_;
  int vid_format_;
  ::google::protobuf::uint32 max_key_frame_interval_;
  ::google::protobuf::uint32 max_quant_;
  ::google::protobuf::uint32 min_quant_;
  ::google::protobuf::uint32 frame_rate_;
  ::google::protobuf::uint32 bitrate_;
  ::google::protobuf::uint32 h264_profile_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TVidEncParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudEncDecParam : public ::google::protobuf::Message {
 public:
  TAudEncDecParam();
  virtual ~TAudEncDecParam();

  TAudEncDecParam(const TAudEncDecParam& from);

  inline TAudEncDecParam& operator=(const TAudEncDecParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudEncDecParam& default_instance();

  void Swap(TAudEncDecParam* other);

  // implements Message ----------------------------------------------

  TAudEncDecParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudEncDecParam& from);
  void MergeFrom(const TAudEncDecParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmAudFormat aud_format = 1;
  inline bool has_aud_format() const;
  inline void clear_aud_format();
  static const int kAudFormatFieldNumber = 1;
  inline ::mt::EmAudFormat aud_format() const;
  inline void set_aud_format(::mt::EmAudFormat value);

  // optional .mt.EmAacChnlNum aac_channel_num = 2;
  inline bool has_aac_channel_num() const;
  inline void clear_aac_channel_num();
  static const int kAacChannelNumFieldNumber = 2;
  inline ::mt::EmAacChnlNum aac_channel_num() const;
  inline void set_aac_channel_num(::mt::EmAacChnlNum value);

  // optional .mt.EmAacSampFreq aac_sample_rate = 3;
  inline bool has_aac_sample_rate() const;
  inline void clear_aac_sample_rate();
  static const int kAacSampleRateFieldNumber = 3;
  inline ::mt::EmAacSampFreq aac_sample_rate() const;
  inline void set_aac_sample_rate(::mt::EmAacSampFreq value);

  // optional uint32 aac_rate = 4;
  inline bool has_aac_rate() const;
  inline void clear_aac_rate();
  static const int kAacRateFieldNumber = 4;
  inline ::google::protobuf::uint32 aac_rate() const;
  inline void set_aac_rate(::google::protobuf::uint32 value);

  // optional uint32 g7221_rate = 5;
  inline bool has_g7221_rate() const;
  inline void clear_g7221_rate();
  static const int kG7221RateFieldNumber = 5;
  inline ::google::protobuf::uint32 g7221_rate() const;
  inline void set_g7221_rate(::google::protobuf::uint32 value);

  // optional bytes conf_para = 6;
  inline bool has_conf_para() const;
  inline void clear_conf_para();
  static const int kConfParaFieldNumber = 6;
  inline const ::std::string& conf_para() const;
  inline void set_conf_para(const ::std::string& value);
  inline void set_conf_para(const char* value);
  inline void set_conf_para(const void* value, size_t size);
  inline ::std::string* mutable_conf_para();
  inline ::std::string* release_conf_para();
  inline void set_allocated_conf_para(::std::string* conf_para);

  // @@protoc_insertion_point(class_scope:mt.TAudEncDecParam)
 private:
  inline void set_has_aud_format();
  inline void clear_has_aud_format();
  inline void set_has_aac_channel_num();
  inline void clear_has_aac_channel_num();
  inline void set_has_aac_sample_rate();
  inline void clear_has_aac_sample_rate();
  inline void set_has_aac_rate();
  inline void clear_has_aac_rate();
  inline void set_has_g7221_rate();
  inline void clear_has_g7221_rate();
  inline void set_has_conf_para();
  inline void clear_has_conf_para();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int aud_format_;
  int aac_channel_num_;
  int aac_sample_rate_;
  ::google::protobuf::uint32 aac_rate_;
  ::std::string* conf_para_;
  ::google::protobuf::uint32 g7221_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TAudEncDecParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudEncStatistic : public ::google::protobuf::Message {
 public:
  TAudEncStatistic();
  virtual ~TAudEncStatistic();

  TAudEncStatistic(const TAudEncStatistic& from);

  inline TAudEncStatistic& operator=(const TAudEncStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudEncStatistic& default_instance();

  void Swap(TAudEncStatistic* other);

  // implements Message ----------------------------------------------

  TAudEncStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudEncStatistic& from);
  void MergeFrom(const TAudEncStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent type() const;
  inline void set_type(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex aud_enc_id = 2;
  inline bool has_aud_enc_id() const;
  inline void clear_aud_enc_id();
  static const int kAudEncIdFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex aud_enc_id() const;
  inline void set_aud_enc_id(::mt::EmCodecComponentIndex value);

  // optional uint32 enc_bitrate = 3;
  inline bool has_enc_bitrate() const;
  inline void clear_enc_bitrate();
  static const int kEncBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 enc_bitrate() const;
  inline void set_enc_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmAudFormat aud_enc_type = 4;
  inline bool has_aud_enc_type() const;
  inline void clear_aud_enc_type();
  static const int kAudEncTypeFieldNumber = 4;
  inline ::mt::EmAudFormat aud_enc_type() const;
  inline void set_aud_enc_type(::mt::EmAudFormat value);

  // optional bool Audio_Enc_Start = 5;
  inline bool has_audio_enc_start() const;
  inline void clear_audio_enc_start();
  static const int kAudioEncStartFieldNumber = 5;
  inline bool audio_enc_start() const;
  inline void set_audio_enc_start(bool value);

  // optional .mt.EmAacChnlNum aac_chnl_num = 6;
  inline bool has_aac_chnl_num() const;
  inline void clear_aac_chnl_num();
  static const int kAacChnlNumFieldNumber = 6;
  inline ::mt::EmAacChnlNum aac_chnl_num() const;
  inline void set_aac_chnl_num(::mt::EmAacChnlNum value);

  // @@protoc_insertion_point(class_scope:mt.TAudEncStatistic)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_aud_enc_id();
  inline void clear_has_aud_enc_id();
  inline void set_has_enc_bitrate();
  inline void clear_has_enc_bitrate();
  inline void set_has_aud_enc_type();
  inline void clear_has_aud_enc_type();
  inline void set_has_audio_enc_start();
  inline void clear_has_audio_enc_start();
  inline void set_has_aac_chnl_num();
  inline void clear_has_aac_chnl_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int aud_enc_id_;
  ::google::protobuf::uint32 enc_bitrate_;
  int aud_enc_type_;
  bool audio_enc_start_;
  int aac_chnl_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TAudEncStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudDecStatistic : public ::google::protobuf::Message {
 public:
  TAudDecStatistic();
  virtual ~TAudDecStatistic();

  TAudDecStatistic(const TAudDecStatistic& from);

  inline TAudDecStatistic& operator=(const TAudDecStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudDecStatistic& default_instance();

  void Swap(TAudDecStatistic* other);

  // implements Message ----------------------------------------------

  TAudDecStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudDecStatistic& from);
  void MergeFrom(const TAudDecStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent type() const;
  inline void set_type(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex aud_dec_id = 2;
  inline bool has_aud_dec_id() const;
  inline void clear_aud_dec_id();
  static const int kAudDecIdFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex aud_dec_id() const;
  inline void set_aud_dec_id(::mt::EmCodecComponentIndex value);

  // optional uint32 dec_bitrate = 3;
  inline bool has_dec_bitrate() const;
  inline void clear_dec_bitrate();
  static const int kDecBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 dec_bitrate() const;
  inline void set_dec_bitrate(::google::protobuf::uint32 value);

  // optional uint32 rcved_frames = 4;
  inline bool has_rcved_frames() const;
  inline void clear_rcved_frames();
  static const int kRcvedFramesFieldNumber = 4;
  inline ::google::protobuf::uint32 rcved_frames() const;
  inline void set_rcved_frames(::google::protobuf::uint32 value);

  // optional uint32 lost_pack_ratio = 5;
  inline bool has_lost_pack_ratio() const;
  inline void clear_lost_pack_ratio();
  static const int kLostPackRatioFieldNumber = 5;
  inline ::google::protobuf::uint32 lost_pack_ratio() const;
  inline void set_lost_pack_ratio(::google::protobuf::uint32 value);

  // optional uint32 physical_lost_pack_ratio = 6;
  inline bool has_physical_lost_pack_ratio() const;
  inline void clear_physical_lost_pack_ratio();
  static const int kPhysicalLostPackRatioFieldNumber = 6;
  inline ::google::protobuf::uint32 physical_lost_pack_ratio() const;
  inline void set_physical_lost_pack_ratio(::google::protobuf::uint32 value);

  // optional uint32 lost_packs = 7;
  inline bool has_lost_packs() const;
  inline void clear_lost_packs();
  static const int kLostPacksFieldNumber = 7;
  inline ::google::protobuf::uint32 lost_packs() const;
  inline void set_lost_packs(::google::protobuf::uint32 value);

  // optional .mt.EmAudFormat aud_dec_type = 8;
  inline bool has_aud_dec_type() const;
  inline void clear_aud_dec_type();
  static const int kAudDecTypeFieldNumber = 8;
  inline ::mt::EmAudFormat aud_dec_type() const;
  inline void set_aud_dec_type(::mt::EmAudFormat value);

  // optional bool Audio_Dec_Start = 9;
  inline bool has_audio_dec_start() const;
  inline void clear_audio_dec_start();
  static const int kAudioDecStartFieldNumber = 9;
  inline bool audio_dec_start() const;
  inline void set_audio_dec_start(bool value);

  // optional .mt.EmAudFormat audchan_dec_type = 10;
  inline bool has_audchan_dec_type() const;
  inline void clear_audchan_dec_type();
  static const int kAudchanDecTypeFieldNumber = 10;
  inline ::mt::EmAudFormat audchan_dec_type() const;
  inline void set_audchan_dec_type(::mt::EmAudFormat value);

  // optional .mt.EmAacChnlNum aac_chnl_num = 11;
  inline bool has_aac_chnl_num() const;
  inline void clear_aac_chnl_num();
  static const int kAacChnlNumFieldNumber = 11;
  inline ::mt::EmAacChnlNum aac_chnl_num() const;
  inline void set_aac_chnl_num(::mt::EmAacChnlNum value);

  // @@protoc_insertion_point(class_scope:mt.TAudDecStatistic)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_aud_dec_id();
  inline void clear_has_aud_dec_id();
  inline void set_has_dec_bitrate();
  inline void clear_has_dec_bitrate();
  inline void set_has_rcved_frames();
  inline void clear_has_rcved_frames();
  inline void set_has_lost_pack_ratio();
  inline void clear_has_lost_pack_ratio();
  inline void set_has_physical_lost_pack_ratio();
  inline void clear_has_physical_lost_pack_ratio();
  inline void set_has_lost_packs();
  inline void clear_has_lost_packs();
  inline void set_has_aud_dec_type();
  inline void clear_has_aud_dec_type();
  inline void set_has_audio_dec_start();
  inline void clear_has_audio_dec_start();
  inline void set_has_audchan_dec_type();
  inline void clear_has_audchan_dec_type();
  inline void set_has_aac_chnl_num();
  inline void clear_has_aac_chnl_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int aud_dec_id_;
  ::google::protobuf::uint32 dec_bitrate_;
  ::google::protobuf::uint32 rcved_frames_;
  ::google::protobuf::uint32 lost_pack_ratio_;
  ::google::protobuf::uint32 physical_lost_pack_ratio_;
  ::google::protobuf::uint32 lost_packs_;
  int aud_dec_type_;
  bool audio_dec_start_;
  int audchan_dec_type_;
  int aac_chnl_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TAudDecStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidEncStatistic : public ::google::protobuf::Message {
 public:
  TVidEncStatistic();
  virtual ~TVidEncStatistic();

  TVidEncStatistic(const TVidEncStatistic& from);

  inline TVidEncStatistic& operator=(const TVidEncStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidEncStatistic& default_instance();

  void Swap(TVidEncStatistic* other);

  // implements Message ----------------------------------------------

  TVidEncStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidEncStatistic& from);
  void MergeFrom(const TVidEncStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent type() const;
  inline void set_type(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex vid_enc_id = 2;
  inline bool has_vid_enc_id() const;
  inline void clear_vid_enc_id();
  static const int kVidEncIdFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex vid_enc_id() const;
  inline void set_vid_enc_id(::mt::EmCodecComponentIndex value);

  // optional uint32 enc_bitrate = 3;
  inline bool has_enc_bitrate() const;
  inline void clear_enc_bitrate();
  static const int kEncBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 enc_bitrate() const;
  inline void set_enc_bitrate(::google::protobuf::uint32 value);

  // optional uint32 frame_rate = 4;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 4;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // optional uint32 vid_width = 5;
  inline bool has_vid_width() const;
  inline void clear_vid_width();
  static const int kVidWidthFieldNumber = 5;
  inline ::google::protobuf::uint32 vid_width() const;
  inline void set_vid_width(::google::protobuf::uint32 value);

  // optional uint32 vid_height = 6;
  inline bool has_vid_height() const;
  inline void clear_vid_height();
  static const int kVidHeightFieldNumber = 6;
  inline ::google::protobuf::uint32 vid_height() const;
  inline void set_vid_height(::google::protobuf::uint32 value);

  // optional .mt.EmVidFormat vid_enc_type = 7;
  inline bool has_vid_enc_type() const;
  inline void clear_vid_enc_type();
  static const int kVidEncTypeFieldNumber = 7;
  inline ::mt::EmVidFormat vid_enc_type() const;
  inline void set_vid_enc_type(::mt::EmVidFormat value);

  // optional bool Video_Enc_Start = 8;
  inline bool has_video_enc_start() const;
  inline void clear_video_enc_start();
  static const int kVideoEncStartFieldNumber = 8;
  inline bool video_enc_start() const;
  inline void set_video_enc_start(bool value);

  // optional .mt.EmH264Profile h264_profile = 9;
  inline bool has_h264_profile() const;
  inline void clear_h264_profile();
  static const int kH264ProfileFieldNumber = 9;
  inline ::mt::EmH264Profile h264_profile() const;
  inline void set_h264_profile(::mt::EmH264Profile value);

  // optional bool video_resource_exist = 10;
  inline bool has_video_resource_exist() const;
  inline void clear_video_resource_exist();
  static const int kVideoResourceExistFieldNumber = 10;
  inline bool video_resource_exist() const;
  inline void set_video_resource_exist(bool value);

  // @@protoc_insertion_point(class_scope:mt.TVidEncStatistic)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_vid_enc_id();
  inline void clear_has_vid_enc_id();
  inline void set_has_enc_bitrate();
  inline void clear_has_enc_bitrate();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();
  inline void set_has_vid_width();
  inline void clear_has_vid_width();
  inline void set_has_vid_height();
  inline void clear_has_vid_height();
  inline void set_has_vid_enc_type();
  inline void clear_has_vid_enc_type();
  inline void set_has_video_enc_start();
  inline void clear_has_video_enc_start();
  inline void set_has_h264_profile();
  inline void clear_has_h264_profile();
  inline void set_has_video_resource_exist();
  inline void clear_has_video_resource_exist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int vid_enc_id_;
  ::google::protobuf::uint32 enc_bitrate_;
  ::google::protobuf::uint32 frame_rate_;
  ::google::protobuf::uint32 vid_width_;
  ::google::protobuf::uint32 vid_height_;
  int vid_enc_type_;
  int h264_profile_;
  bool video_enc_start_;
  bool video_resource_exist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TVidEncStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidDecStatistic : public ::google::protobuf::Message {
 public:
  TVidDecStatistic();
  virtual ~TVidDecStatistic();

  TVidDecStatistic(const TVidDecStatistic& from);

  inline TVidDecStatistic& operator=(const TVidDecStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidDecStatistic& default_instance();

  void Swap(TVidDecStatistic* other);

  // implements Message ----------------------------------------------

  TVidDecStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidDecStatistic& from);
  void MergeFrom(const TVidDecStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent type() const;
  inline void set_type(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex vid_dec_id = 2;
  inline bool has_vid_dec_id() const;
  inline void clear_vid_dec_id();
  static const int kVidDecIdFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex vid_dec_id() const;
  inline void set_vid_dec_id(::mt::EmCodecComponentIndex value);

  // optional uint32 dec_bitrate = 3;
  inline bool has_dec_bitrate() const;
  inline void clear_dec_bitrate();
  static const int kDecBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 dec_bitrate() const;
  inline void set_dec_bitrate(::google::protobuf::uint32 value);

  // optional uint32 rcved_frames = 4;
  inline bool has_rcved_frames() const;
  inline void clear_rcved_frames();
  static const int kRcvedFramesFieldNumber = 4;
  inline ::google::protobuf::uint32 rcved_frames() const;
  inline void set_rcved_frames(::google::protobuf::uint32 value);

  // optional uint32 lost_pack_ratio = 5;
  inline bool has_lost_pack_ratio() const;
  inline void clear_lost_pack_ratio();
  static const int kLostPackRatioFieldNumber = 5;
  inline ::google::protobuf::uint32 lost_pack_ratio() const;
  inline void set_lost_pack_ratio(::google::protobuf::uint32 value);

  // optional uint32 physical_lost_pack_ratio = 6;
  inline bool has_physical_lost_pack_ratio() const;
  inline void clear_physical_lost_pack_ratio();
  static const int kPhysicalLostPackRatioFieldNumber = 6;
  inline ::google::protobuf::uint32 physical_lost_pack_ratio() const;
  inline void set_physical_lost_pack_ratio(::google::protobuf::uint32 value);

  // optional uint32 lost_packs = 7;
  inline bool has_lost_packs() const;
  inline void clear_lost_packs();
  static const int kLostPacksFieldNumber = 7;
  inline ::google::protobuf::uint32 lost_packs() const;
  inline void set_lost_packs(::google::protobuf::uint32 value);

  // optional uint32 frame_rate = 8;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 8;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // optional uint32 vid_width = 9;
  inline bool has_vid_width() const;
  inline void clear_vid_width();
  static const int kVidWidthFieldNumber = 9;
  inline ::google::protobuf::uint32 vid_width() const;
  inline void set_vid_width(::google::protobuf::uint32 value);

  // optional uint32 vid_height = 10;
  inline bool has_vid_height() const;
  inline void clear_vid_height();
  static const int kVidHeightFieldNumber = 10;
  inline ::google::protobuf::uint32 vid_height() const;
  inline void set_vid_height(::google::protobuf::uint32 value);

  // optional .mt.EmVidFormat vid_dec_type = 11;
  inline bool has_vid_dec_type() const;
  inline void clear_vid_dec_type();
  static const int kVidDecTypeFieldNumber = 11;
  inline ::mt::EmVidFormat vid_dec_type() const;
  inline void set_vid_dec_type(::mt::EmVidFormat value);

  // optional bool Video_Dec_Start = 12;
  inline bool has_video_dec_start() const;
  inline void clear_video_dec_start();
  static const int kVideoDecStartFieldNumber = 12;
  inline bool video_dec_start() const;
  inline void set_video_dec_start(bool value);

  // optional .mt.EmH264Profile h264_profile = 13;
  inline bool has_h264_profile() const;
  inline void clear_h264_profile();
  static const int kH264ProfileFieldNumber = 13;
  inline ::mt::EmH264Profile h264_profile() const;
  inline void set_h264_profile(::mt::EmH264Profile value);

  // @@protoc_insertion_point(class_scope:mt.TVidDecStatistic)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_vid_dec_id();
  inline void clear_has_vid_dec_id();
  inline void set_has_dec_bitrate();
  inline void clear_has_dec_bitrate();
  inline void set_has_rcved_frames();
  inline void clear_has_rcved_frames();
  inline void set_has_lost_pack_ratio();
  inline void clear_has_lost_pack_ratio();
  inline void set_has_physical_lost_pack_ratio();
  inline void clear_has_physical_lost_pack_ratio();
  inline void set_has_lost_packs();
  inline void clear_has_lost_packs();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();
  inline void set_has_vid_width();
  inline void clear_has_vid_width();
  inline void set_has_vid_height();
  inline void clear_has_vid_height();
  inline void set_has_vid_dec_type();
  inline void clear_has_vid_dec_type();
  inline void set_has_video_dec_start();
  inline void clear_has_video_dec_start();
  inline void set_has_h264_profile();
  inline void clear_has_h264_profile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int vid_dec_id_;
  ::google::protobuf::uint32 dec_bitrate_;
  ::google::protobuf::uint32 rcved_frames_;
  ::google::protobuf::uint32 lost_pack_ratio_;
  ::google::protobuf::uint32 physical_lost_pack_ratio_;
  ::google::protobuf::uint32 lost_packs_;
  ::google::protobuf::uint32 frame_rate_;
  ::google::protobuf::uint32 vid_width_;
  ::google::protobuf::uint32 vid_height_;
  int vid_dec_type_;
  bool video_dec_start_;
  int h264_profile_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TVidDecStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudMixStatistic : public ::google::protobuf::Message {
 public:
  TAudMixStatistic();
  virtual ~TAudMixStatistic();

  TAudMixStatistic(const TAudMixStatistic& from);

  inline TAudMixStatistic& operator=(const TAudMixStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudMixStatistic& default_instance();

  void Swap(TAudMixStatistic* other);

  // implements Message ----------------------------------------------

  TAudMixStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudMixStatistic& from);
  void MergeFrom(const TAudMixStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent type() const;
  inline void set_type(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex aud_mix_id = 2;
  inline bool has_aud_mix_id() const;
  inline void clear_aud_mix_id();
  static const int kAudMixIdFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex aud_mix_id() const;
  inline void set_aud_mix_id(::mt::EmCodecComponentIndex value);

  // @@protoc_insertion_point(class_scope:mt.TAudMixStatistic)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_aud_mix_id();
  inline void clear_has_aud_mix_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int aud_mix_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TAudMixStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidMixStatistic : public ::google::protobuf::Message {
 public:
  TVidMixStatistic();
  virtual ~TVidMixStatistic();

  TVidMixStatistic(const TVidMixStatistic& from);

  inline TVidMixStatistic& operator=(const TVidMixStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidMixStatistic& default_instance();

  void Swap(TVidMixStatistic* other);

  // implements Message ----------------------------------------------

  TVidMixStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidMixStatistic& from);
  void MergeFrom(const TVidMixStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent type() const;
  inline void set_type(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex vid_mix_id = 2;
  inline bool has_vid_mix_id() const;
  inline void clear_vid_mix_id();
  static const int kVidMixIdFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex vid_mix_id() const;
  inline void set_vid_mix_id(::mt::EmCodecComponentIndex value);

  // @@protoc_insertion_point(class_scope:mt.TVidMixStatistic)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_vid_mix_id();
  inline void clear_has_vid_mix_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int vid_mix_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TVidMixStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtBweReceiver : public ::google::protobuf::Message {
 public:
  TMtBweReceiver();
  virtual ~TMtBweReceiver();

  TMtBweReceiver(const TMtBweReceiver& from);

  inline TMtBweReceiver& operator=(const TMtBweReceiver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtBweReceiver& default_instance();

  void Swap(TMtBweReceiver* other);

  // implements Message ----------------------------------------------

  TMtBweReceiver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtBweReceiver& from);
  void MergeFrom(const TMtBweReceiver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ssrc = 1;
  inline bool has_ssrc() const;
  inline void clear_ssrc();
  static const int kSsrcFieldNumber = 1;
  inline ::google::protobuf::uint32 ssrc() const;
  inline void set_ssrc(::google::protobuf::uint32 value);

  // optional bool is_enable = 2;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 2;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional uint32 qwid = 3;
  inline bool has_qwid() const;
  inline void clear_qwid();
  static const int kQwidFieldNumber = 3;
  inline ::google::protobuf::uint32 qwid() const;
  inline void set_qwid(::google::protobuf::uint32 value);

  // optional uint32 group_id = 4;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 4;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 5;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 5;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtBweReceiver)
 private:
  inline void set_has_ssrc();
  inline void clear_has_ssrc();
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_qwid();
  inline void clear_has_qwid();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ssrc_;
  bool is_enable_;
  ::google::protobuf::uint32 qwid_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 bitrate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtBweReceiver* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidBweStatus : public ::google::protobuf::Message {
 public:
  TVidBweStatus();
  virtual ~TVidBweStatus();

  TVidBweStatus(const TVidBweStatus& from);

  inline TVidBweStatus& operator=(const TVidBweStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidBweStatus& default_instance();

  void Swap(TVidBweStatus* other);

  // implements Message ----------------------------------------------

  TVidBweStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidBweStatus& from);
  void MergeFrom(const TVidBweStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent type() const;
  inline void set_type(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex vid_enc_id = 2;
  inline bool has_vid_enc_id() const;
  inline void clear_vid_enc_id();
  static const int kVidEncIdFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex vid_enc_id() const;
  inline void set_vid_enc_id(::mt::EmCodecComponentIndex value);

  // repeated .mt.TMtBweReceiver receiver = 3;
  inline int receiver_size() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 3;
  inline const ::mt::TMtBweReceiver& receiver(int index) const;
  inline ::mt::TMtBweReceiver* mutable_receiver(int index);
  inline ::mt::TMtBweReceiver* add_receiver();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtBweReceiver >&
      receiver() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtBweReceiver >*
      mutable_receiver();

  // optional uint32 revision = 4;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 4;
  inline ::google::protobuf::uint32 revision() const;
  inline void set_revision(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TVidBweStatus)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_vid_enc_id();
  inline void clear_has_vid_enc_id();
  inline void set_has_revision();
  inline void clear_has_revision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int vid_enc_id_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMtBweReceiver > receiver_;
  ::google::protobuf::uint32 revision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TVidBweStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TCodecBweStatus : public ::google::protobuf::Message {
 public:
  TCodecBweStatus();
  virtual ~TCodecBweStatus();

  TCodecBweStatus(const TCodecBweStatus& from);

  inline TCodecBweStatus& operator=(const TCodecBweStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCodecBweStatus& default_instance();

  void Swap(TCodecBweStatus* other);

  // implements Message ----------------------------------------------

  TCodecBweStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCodecBweStatus& from);
  void MergeFrom(const TCodecBweStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVidBweStatus main_vid_enc_status = 1;
  inline int main_vid_enc_status_size() const;
  inline void clear_main_vid_enc_status();
  static const int kMainVidEncStatusFieldNumber = 1;
  inline const ::mt::TVidBweStatus& main_vid_enc_status(int index) const;
  inline ::mt::TVidBweStatus* mutable_main_vid_enc_status(int index);
  inline ::mt::TVidBweStatus* add_main_vid_enc_status();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidBweStatus >&
      main_vid_enc_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidBweStatus >*
      mutable_main_vid_enc_status();

  // repeated .mt.TVidBweStatus ass_vid_enc_status = 2;
  inline int ass_vid_enc_status_size() const;
  inline void clear_ass_vid_enc_status();
  static const int kAssVidEncStatusFieldNumber = 2;
  inline const ::mt::TVidBweStatus& ass_vid_enc_status(int index) const;
  inline ::mt::TVidBweStatus* mutable_ass_vid_enc_status(int index);
  inline ::mt::TVidBweStatus* add_ass_vid_enc_status();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidBweStatus >&
      ass_vid_enc_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidBweStatus >*
      mutable_ass_vid_enc_status();

  // @@protoc_insertion_point(class_scope:mt.TCodecBweStatus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVidBweStatus > main_vid_enc_status_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidBweStatus > ass_vid_enc_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TCodecBweStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TCodecStatistic : public ::google::protobuf::Message {
 public:
  TCodecStatistic();
  virtual ~TCodecStatistic();

  TCodecStatistic(const TCodecStatistic& from);

  inline TCodecStatistic& operator=(const TCodecStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCodecStatistic& default_instance();

  void Swap(TCodecStatistic* other);

  // implements Message ----------------------------------------------

  TCodecStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCodecStatistic& from);
  void MergeFrom(const TCodecStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAudEncStatistic main_aud_enc_static = 1;
  inline int main_aud_enc_static_size() const;
  inline void clear_main_aud_enc_static();
  static const int kMainAudEncStaticFieldNumber = 1;
  inline const ::mt::TAudEncStatistic& main_aud_enc_static(int index) const;
  inline ::mt::TAudEncStatistic* mutable_main_aud_enc_static(int index);
  inline ::mt::TAudEncStatistic* add_main_aud_enc_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudEncStatistic >&
      main_aud_enc_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudEncStatistic >*
      mutable_main_aud_enc_static();

  // repeated .mt.TAudEncStatistic ass_aud_enc_static = 2;
  inline int ass_aud_enc_static_size() const;
  inline void clear_ass_aud_enc_static();
  static const int kAssAudEncStaticFieldNumber = 2;
  inline const ::mt::TAudEncStatistic& ass_aud_enc_static(int index) const;
  inline ::mt::TAudEncStatistic* mutable_ass_aud_enc_static(int index);
  inline ::mt::TAudEncStatistic* add_ass_aud_enc_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudEncStatistic >&
      ass_aud_enc_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudEncStatistic >*
      mutable_ass_aud_enc_static();

  // repeated .mt.TAudDecStatistic main_aud_dec_static = 3;
  inline int main_aud_dec_static_size() const;
  inline void clear_main_aud_dec_static();
  static const int kMainAudDecStaticFieldNumber = 3;
  inline const ::mt::TAudDecStatistic& main_aud_dec_static(int index) const;
  inline ::mt::TAudDecStatistic* mutable_main_aud_dec_static(int index);
  inline ::mt::TAudDecStatistic* add_main_aud_dec_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudDecStatistic >&
      main_aud_dec_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudDecStatistic >*
      mutable_main_aud_dec_static();

  // repeated .mt.TAudDecStatistic ass_aud_dec_static = 4;
  inline int ass_aud_dec_static_size() const;
  inline void clear_ass_aud_dec_static();
  static const int kAssAudDecStaticFieldNumber = 4;
  inline const ::mt::TAudDecStatistic& ass_aud_dec_static(int index) const;
  inline ::mt::TAudDecStatistic* mutable_ass_aud_dec_static(int index);
  inline ::mt::TAudDecStatistic* add_ass_aud_dec_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudDecStatistic >&
      ass_aud_dec_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudDecStatistic >*
      mutable_ass_aud_dec_static();

  // repeated .mt.TVidEncStatistic main_vid_enc_static = 5;
  inline int main_vid_enc_static_size() const;
  inline void clear_main_vid_enc_static();
  static const int kMainVidEncStaticFieldNumber = 5;
  inline const ::mt::TVidEncStatistic& main_vid_enc_static(int index) const;
  inline ::mt::TVidEncStatistic* mutable_main_vid_enc_static(int index);
  inline ::mt::TVidEncStatistic* add_main_vid_enc_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidEncStatistic >&
      main_vid_enc_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidEncStatistic >*
      mutable_main_vid_enc_static();

  // repeated .mt.TVidEncStatistic ass_vid_enc_static = 6;
  inline int ass_vid_enc_static_size() const;
  inline void clear_ass_vid_enc_static();
  static const int kAssVidEncStaticFieldNumber = 6;
  inline const ::mt::TVidEncStatistic& ass_vid_enc_static(int index) const;
  inline ::mt::TVidEncStatistic* mutable_ass_vid_enc_static(int index);
  inline ::mt::TVidEncStatistic* add_ass_vid_enc_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidEncStatistic >&
      ass_vid_enc_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidEncStatistic >*
      mutable_ass_vid_enc_static();

  // repeated .mt.TVidDecStatistic main_vid_dec_static = 7;
  inline int main_vid_dec_static_size() const;
  inline void clear_main_vid_dec_static();
  static const int kMainVidDecStaticFieldNumber = 7;
  inline const ::mt::TVidDecStatistic& main_vid_dec_static(int index) const;
  inline ::mt::TVidDecStatistic* mutable_main_vid_dec_static(int index);
  inline ::mt::TVidDecStatistic* add_main_vid_dec_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidDecStatistic >&
      main_vid_dec_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidDecStatistic >*
      mutable_main_vid_dec_static();

  // repeated .mt.TVidDecStatistic ass_vid_dec_static = 8;
  inline int ass_vid_dec_static_size() const;
  inline void clear_ass_vid_dec_static();
  static const int kAssVidDecStaticFieldNumber = 8;
  inline const ::mt::TVidDecStatistic& ass_vid_dec_static(int index) const;
  inline ::mt::TVidDecStatistic* mutable_ass_vid_dec_static(int index);
  inline ::mt::TVidDecStatistic* add_ass_vid_dec_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidDecStatistic >&
      ass_vid_dec_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidDecStatistic >*
      mutable_ass_vid_dec_static();

  // repeated .mt.TAudMixStatistic main_aud_mix_static = 9;
  inline int main_aud_mix_static_size() const;
  inline void clear_main_aud_mix_static();
  static const int kMainAudMixStaticFieldNumber = 9;
  inline const ::mt::TAudMixStatistic& main_aud_mix_static(int index) const;
  inline ::mt::TAudMixStatistic* mutable_main_aud_mix_static(int index);
  inline ::mt::TAudMixStatistic* add_main_aud_mix_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudMixStatistic >&
      main_aud_mix_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudMixStatistic >*
      mutable_main_aud_mix_static();

  // repeated .mt.TAudMixStatistic ass_aud_mix_static = 10;
  inline int ass_aud_mix_static_size() const;
  inline void clear_ass_aud_mix_static();
  static const int kAssAudMixStaticFieldNumber = 10;
  inline const ::mt::TAudMixStatistic& ass_aud_mix_static(int index) const;
  inline ::mt::TAudMixStatistic* mutable_ass_aud_mix_static(int index);
  inline ::mt::TAudMixStatistic* add_ass_aud_mix_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudMixStatistic >&
      ass_aud_mix_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudMixStatistic >*
      mutable_ass_aud_mix_static();

  // repeated .mt.TVidMixStatistic main_vid_mix_static = 11;
  inline int main_vid_mix_static_size() const;
  inline void clear_main_vid_mix_static();
  static const int kMainVidMixStaticFieldNumber = 11;
  inline const ::mt::TVidMixStatistic& main_vid_mix_static(int index) const;
  inline ::mt::TVidMixStatistic* mutable_main_vid_mix_static(int index);
  inline ::mt::TVidMixStatistic* add_main_vid_mix_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidMixStatistic >&
      main_vid_mix_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidMixStatistic >*
      mutable_main_vid_mix_static();

  // repeated .mt.TVidMixStatistic ass_vid_mix_static = 12;
  inline int ass_vid_mix_static_size() const;
  inline void clear_ass_vid_mix_static();
  static const int kAssVidMixStaticFieldNumber = 12;
  inline const ::mt::TVidMixStatistic& ass_vid_mix_static(int index) const;
  inline ::mt::TVidMixStatistic* mutable_ass_vid_mix_static(int index);
  inline ::mt::TVidMixStatistic* add_ass_vid_mix_static();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidMixStatistic >&
      ass_vid_mix_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidMixStatistic >*
      mutable_ass_vid_mix_static();

  // @@protoc_insertion_point(class_scope:mt.TCodecStatistic)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAudEncStatistic > main_aud_enc_static_;
  ::google::protobuf::RepeatedPtrField< ::mt::TAudEncStatistic > ass_aud_enc_static_;
  ::google::protobuf::RepeatedPtrField< ::mt::TAudDecStatistic > main_aud_dec_static_;
  ::google::protobuf::RepeatedPtrField< ::mt::TAudDecStatistic > ass_aud_dec_static_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidEncStatistic > main_vid_enc_static_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidEncStatistic > ass_vid_enc_static_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidDecStatistic > main_vid_dec_static_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidDecStatistic > ass_vid_dec_static_;
  ::google::protobuf::RepeatedPtrField< ::mt::TAudMixStatistic > main_aud_mix_static_;
  ::google::protobuf::RepeatedPtrField< ::mt::TAudMixStatistic > ass_aud_mix_static_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidMixStatistic > main_vid_mix_static_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidMixStatistic > ass_vid_mix_static_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TCodecStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDevInfo : public ::google::protobuf::Message {
 public:
  TDevInfo();
  virtual ~TDevInfo();

  TDevInfo(const TDevInfo& from);

  inline TDevInfo& operator=(const TDevInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDevInfo& default_instance();

  void Swap(TDevInfo* other);

  // implements Message ----------------------------------------------

  TDevInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDevInfo& from);
  void MergeFrom(const TDevInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dev_name = 1;
  inline bool has_dev_name() const;
  inline void clear_dev_name();
  static const int kDevNameFieldNumber = 1;
  inline const ::std::string& dev_name() const;
  inline void set_dev_name(const ::std::string& value);
  inline void set_dev_name(const char* value);
  inline void set_dev_name(const char* value, size_t size);
  inline ::std::string* mutable_dev_name();
  inline ::std::string* release_dev_name();
  inline void set_allocated_dev_name(::std::string* dev_name);

  // optional string dev_guid = 2;
  inline bool has_dev_guid() const;
  inline void clear_dev_guid();
  static const int kDevGuidFieldNumber = 2;
  inline const ::std::string& dev_guid() const;
  inline void set_dev_guid(const ::std::string& value);
  inline void set_dev_guid(const char* value);
  inline void set_dev_guid(const char* value, size_t size);
  inline ::std::string* mutable_dev_guid();
  inline ::std::string* release_dev_guid();
  inline void set_allocated_dev_guid(::std::string* dev_guid);

  // @@protoc_insertion_point(class_scope:mt.TDevInfo)
 private:
  inline void set_has_dev_name();
  inline void clear_has_dev_name();
  inline void set_has_dev_guid();
  inline void clear_has_dev_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dev_name_;
  ::std::string* dev_guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TDevInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDevInfoList : public ::google::protobuf::Message {
 public:
  TDevInfoList();
  virtual ~TDevInfoList();

  TDevInfoList(const TDevInfoList& from);

  inline TDevInfoList& operator=(const TDevInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDevInfoList& default_instance();

  void Swap(TDevInfoList* other);

  // implements Message ----------------------------------------------

  TDevInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDevInfoList& from);
  void MergeFrom(const TDevInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TDevInfo dev_list = 1;
  inline int dev_list_size() const;
  inline void clear_dev_list();
  static const int kDevListFieldNumber = 1;
  inline const ::mt::TDevInfo& dev_list(int index) const;
  inline ::mt::TDevInfo* mutable_dev_list(int index);
  inline ::mt::TDevInfo* add_dev_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TDevInfo >&
      dev_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TDevInfo >*
      mutable_dev_list();

  // @@protoc_insertion_point(class_scope:mt.TDevInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TDevInfo > dev_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TDevInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVMPMemParam : public ::google::protobuf::Message {
 public:
  TVMPMemParam();
  virtual ~TVMPMemParam();

  TVMPMemParam(const TVMPMemParam& from);

  inline TVMPMemParam& operator=(const TVMPMemParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVMPMemParam& default_instance();

  void Swap(TVMPMemParam* other);

  // implements Message ----------------------------------------------

  TVMPMemParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVMPMemParam& from);
  void MergeFrom(const TVMPMemParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 chan_index = 1;
  inline bool has_chan_index() const;
  inline void clear_chan_index();
  static const int kChanIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 chan_index() const;
  inline void set_chan_index(::google::protobuf::uint32 value);

  // optional .mt.TNetAddr rcv_rtp_addr = 2;
  inline bool has_rcv_rtp_addr() const;
  inline void clear_rcv_rtp_addr();
  static const int kRcvRtpAddrFieldNumber = 2;
  inline const ::mt::TNetAddr& rcv_rtp_addr() const;
  inline ::mt::TNetAddr* mutable_rcv_rtp_addr();
  inline ::mt::TNetAddr* release_rcv_rtp_addr();
  inline void set_allocated_rcv_rtp_addr(::mt::TNetAddr* rcv_rtp_addr);

  // optional .mt.TNetAddr rcv_backrtcp_addr = 3;
  inline bool has_rcv_backrtcp_addr() const;
  inline void clear_rcv_backrtcp_addr();
  static const int kRcvBackrtcpAddrFieldNumber = 3;
  inline const ::mt::TNetAddr& rcv_backrtcp_addr() const;
  inline ::mt::TNetAddr* mutable_rcv_backrtcp_addr();
  inline ::mt::TNetAddr* release_rcv_backrtcp_addr();
  inline void set_allocated_rcv_backrtcp_addr(::mt::TNetAddr* rcv_backrtcp_addr);

  // optional .mt.TEncryptKey encryp_key = 4;
  inline bool has_encryp_key() const;
  inline void clear_encryp_key();
  static const int kEncrypKeyFieldNumber = 4;
  inline const ::mt::TEncryptKey& encryp_key() const;
  inline ::mt::TEncryptKey* mutable_encryp_key();
  inline ::mt::TEncryptKey* release_encryp_key();
  inline void set_allocated_encryp_key(::mt::TEncryptKey* encryp_key);

  // optional uint32 payload = 5;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 5;
  inline ::google::protobuf::uint32 payload() const;
  inline void set_payload(::google::protobuf::uint32 value);

  // optional uint32 media_type = 6;
  inline bool has_media_type() const;
  inline void clear_media_type();
  static const int kMediaTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 media_type() const;
  inline void set_media_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TVMPMemParam)
 private:
  inline void set_has_chan_index();
  inline void clear_has_chan_index();
  inline void set_has_rcv_rtp_addr();
  inline void clear_has_rcv_rtp_addr();
  inline void set_has_rcv_backrtcp_addr();
  inline void clear_has_rcv_backrtcp_addr();
  inline void set_has_encryp_key();
  inline void clear_has_encryp_key();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_media_type();
  inline void clear_has_media_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TNetAddr* rcv_rtp_addr_;
  ::mt::TNetAddr* rcv_backrtcp_addr_;
  ::google::protobuf::uint32 chan_index_;
  ::google::protobuf::uint32 payload_;
  ::mt::TEncryptKey* encryp_key_;
  ::google::protobuf::uint32 media_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TVMPMemParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMultiVMPMemParam : public ::google::protobuf::Message {
 public:
  TMultiVMPMemParam();
  virtual ~TMultiVMPMemParam();

  TMultiVMPMemParam(const TMultiVMPMemParam& from);

  inline TMultiVMPMemParam& operator=(const TMultiVMPMemParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMultiVMPMemParam& default_instance();

  void Swap(TMultiVMPMemParam* other);

  // implements Message ----------------------------------------------

  TMultiVMPMemParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMultiVMPMemParam& from);
  void MergeFrom(const TMultiVMPMemParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVMPMemParam vmp_memParams = 1;
  inline int vmp_memparams_size() const;
  inline void clear_vmp_memparams();
  static const int kVmpMemParamsFieldNumber = 1;
  inline const ::mt::TVMPMemParam& vmp_memparams(int index) const;
  inline ::mt::TVMPMemParam* mutable_vmp_memparams(int index);
  inline ::mt::TVMPMemParam* add_vmp_memparams();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVMPMemParam >&
      vmp_memparams() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVMPMemParam >*
      mutable_vmp_memparams();

  // @@protoc_insertion_point(class_scope:mt.TMultiVMPMemParam)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVMPMemParam > vmp_memparams_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMultiVMPMemParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMixerMemParam : public ::google::protobuf::Message {
 public:
  TMixerMemParam();
  virtual ~TMixerMemParam();

  TMixerMemParam(const TMixerMemParam& from);

  inline TMixerMemParam& operator=(const TMixerMemParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMixerMemParam& default_instance();

  void Swap(TMixerMemParam* other);

  // implements Message ----------------------------------------------

  TMixerMemParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMixerMemParam& from);
  void MergeFrom(const TMixerMemParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 chan_index = 1;
  inline bool has_chan_index() const;
  inline void clear_chan_index();
  static const int kChanIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 chan_index() const;
  inline void set_chan_index(::google::protobuf::uint32 value);

  // optional .mt.TNetAddr rcv_rtp_addr = 2;
  inline bool has_rcv_rtp_addr() const;
  inline void clear_rcv_rtp_addr();
  static const int kRcvRtpAddrFieldNumber = 2;
  inline const ::mt::TNetAddr& rcv_rtp_addr() const;
  inline ::mt::TNetAddr* mutable_rcv_rtp_addr();
  inline ::mt::TNetAddr* release_rcv_rtp_addr();
  inline void set_allocated_rcv_rtp_addr(::mt::TNetAddr* rcv_rtp_addr);

  // optional .mt.TNetAddr rcv_backrtcp_addr = 3;
  inline bool has_rcv_backrtcp_addr() const;
  inline void clear_rcv_backrtcp_addr();
  static const int kRcvBackrtcpAddrFieldNumber = 3;
  inline const ::mt::TNetAddr& rcv_backrtcp_addr() const;
  inline ::mt::TNetAddr* mutable_rcv_backrtcp_addr();
  inline ::mt::TNetAddr* release_rcv_backrtcp_addr();
  inline void set_allocated_rcv_backrtcp_addr(::mt::TNetAddr* rcv_backrtcp_addr);

  // optional .mt.TEncryptKey encryp_key = 4;
  inline bool has_encryp_key() const;
  inline void clear_encryp_key();
  static const int kEncrypKeyFieldNumber = 4;
  inline const ::mt::TEncryptKey& encryp_key() const;
  inline ::mt::TEncryptKey* mutable_encryp_key();
  inline ::mt::TEncryptKey* release_encryp_key();
  inline void set_allocated_encryp_key(::mt::TEncryptKey* encryp_key);

  // optional uint32 payload = 5;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 5;
  inline ::google::protobuf::uint32 payload() const;
  inline void set_payload(::google::protobuf::uint32 value);

  // optional uint32 media_type = 6;
  inline bool has_media_type() const;
  inline void clear_media_type();
  static const int kMediaTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 media_type() const;
  inline void set_media_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMixerMemParam)
 private:
  inline void set_has_chan_index();
  inline void clear_has_chan_index();
  inline void set_has_rcv_rtp_addr();
  inline void clear_has_rcv_rtp_addr();
  inline void set_has_rcv_backrtcp_addr();
  inline void clear_has_rcv_backrtcp_addr();
  inline void set_has_encryp_key();
  inline void clear_has_encryp_key();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_media_type();
  inline void clear_has_media_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TNetAddr* rcv_rtp_addr_;
  ::mt::TNetAddr* rcv_backrtcp_addr_;
  ::google::protobuf::uint32 chan_index_;
  ::google::protobuf::uint32 payload_;
  ::mt::TEncryptKey* encryp_key_;
  ::google::protobuf::uint32 media_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMixerMemParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMultiMixerMemParam : public ::google::protobuf::Message {
 public:
  TMultiMixerMemParam();
  virtual ~TMultiMixerMemParam();

  TMultiMixerMemParam(const TMultiMixerMemParam& from);

  inline TMultiMixerMemParam& operator=(const TMultiMixerMemParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMultiMixerMemParam& default_instance();

  void Swap(TMultiMixerMemParam* other);

  // implements Message ----------------------------------------------

  TMultiMixerMemParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMultiMixerMemParam& from);
  void MergeFrom(const TMultiMixerMemParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMixerMemParam mixer_memParams = 1;
  inline int mixer_memparams_size() const;
  inline void clear_mixer_memparams();
  static const int kMixerMemParamsFieldNumber = 1;
  inline const ::mt::TMixerMemParam& mixer_memparams(int index) const;
  inline ::mt::TMixerMemParam* mutable_mixer_memparams(int index);
  inline ::mt::TMixerMemParam* add_mixer_memparams();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMixerMemParam >&
      mixer_memparams() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMixerMemParam >*
      mutable_mixer_memparams();

  // @@protoc_insertion_point(class_scope:mt.TMultiMixerMemParam)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMixerMemParam > mixer_memparams_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMultiMixerMemParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRecordParam : public ::google::protobuf::Message {
 public:
  TRecordParam();
  virtual ~TRecordParam();

  TRecordParam(const TRecordParam& from);

  inline TRecordParam& operator=(const TRecordParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRecordParam& default_instance();

  void Swap(TRecordParam* other);

  // implements Message ----------------------------------------------

  TRecordParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRecordParam& from);
  void MergeFrom(const TRecordParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  inline void set_allocated_file_path(::std::string* file_path);

  // optional bool is_local = 2;
  inline bool has_is_local() const;
  inline void clear_is_local();
  static const int kIsLocalFieldNumber = 2;
  inline bool is_local() const;
  inline void set_is_local(bool value);

  // optional bool has_audio = 3;
  inline bool has_has_audio() const;
  inline void clear_has_audio();
  static const int kHasAudioFieldNumber = 3;
  inline bool has_audio() const;
  inline void set_has_audio(bool value);

  // optional bool has_aux_video = 4;
  inline bool has_has_aux_video() const;
  inline void clear_has_aux_video();
  static const int kHasAuxVideoFieldNumber = 4;
  inline bool has_aux_video() const;
  inline void set_has_aux_video(bool value);

  // optional string file_name = 5;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 5;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // @@protoc_insertion_point(class_scope:mt.TRecordParam)
 private:
  inline void set_has_file_path();
  inline void clear_has_file_path();
  inline void set_has_is_local();
  inline void clear_has_is_local();
  inline void set_has_has_audio();
  inline void clear_has_has_audio();
  inline void set_has_has_aux_video();
  inline void clear_has_has_aux_video();
  inline void set_has_file_name();
  inline void clear_has_file_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_path_;
  ::std::string* file_name_;
  bool is_local_;
  bool has_audio_;
  bool has_aux_video_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TRecordParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRecordDiskAlarmLevel : public ::google::protobuf::Message {
 public:
  TRecordDiskAlarmLevel();
  virtual ~TRecordDiskAlarmLevel();

  TRecordDiskAlarmLevel(const TRecordDiskAlarmLevel& from);

  inline TRecordDiskAlarmLevel& operator=(const TRecordDiskAlarmLevel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRecordDiskAlarmLevel& default_instance();

  void Swap(TRecordDiskAlarmLevel* other);

  // implements Message ----------------------------------------------

  TRecordDiskAlarmLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRecordDiskAlarmLevel& from);
  void MergeFrom(const TRecordDiskAlarmLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string partition_name = 1;
  inline bool has_partition_name() const;
  inline void clear_partition_name();
  static const int kPartitionNameFieldNumber = 1;
  inline const ::std::string& partition_name() const;
  inline void set_partition_name(const ::std::string& value);
  inline void set_partition_name(const char* value);
  inline void set_partition_name(const char* value, size_t size);
  inline ::std::string* mutable_partition_name();
  inline ::std::string* release_partition_name();
  inline void set_allocated_partition_name(::std::string* partition_name);

  // optional uint32 alarm_level1 = 2;
  inline bool has_alarm_level1() const;
  inline void clear_alarm_level1();
  static const int kAlarmLevel1FieldNumber = 2;
  inline ::google::protobuf::uint32 alarm_level1() const;
  inline void set_alarm_level1(::google::protobuf::uint32 value);

  // optional uint32 alarm_level2 = 3;
  inline bool has_alarm_level2() const;
  inline void clear_alarm_level2();
  static const int kAlarmLevel2FieldNumber = 3;
  inline ::google::protobuf::uint32 alarm_level2() const;
  inline void set_alarm_level2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TRecordDiskAlarmLevel)
 private:
  inline void set_has_partition_name();
  inline void clear_has_partition_name();
  inline void set_has_alarm_level1();
  inline void clear_has_alarm_level1();
  inline void set_has_alarm_level2();
  inline void clear_has_alarm_level2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* partition_name_;
  ::google::protobuf::uint32 alarm_level1_;
  ::google::protobuf::uint32 alarm_level2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TRecordDiskAlarmLevel* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImageParam : public ::google::protobuf::Message {
 public:
  TImageParam();
  virtual ~TImageParam();

  TImageParam(const TImageParam& from);

  inline TImageParam& operator=(const TImageParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImageParam& default_instance();

  void Swap(TImageParam* other);

  // implements Message ----------------------------------------------

  TImageParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImageParam& from);
  void MergeFrom(const TImageParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmImgParam img_param_type = 1;
  inline bool has_img_param_type() const;
  inline void clear_img_param_type();
  static const int kImgParamTypeFieldNumber = 1;
  inline ::mt::EmImgParam img_param_type() const;
  inline void set_img_param_type(::mt::EmImgParam value);

  // optional uint32 val = 2;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 2;
  inline ::google::protobuf::uint32 val() const;
  inline void set_val(::google::protobuf::uint32 value);

  // optional bool is_auto = 3;
  inline bool has_is_auto() const;
  inline void clear_is_auto();
  static const int kIsAutoFieldNumber = 3;
  inline bool is_auto() const;
  inline void set_is_auto(bool value);

  // @@protoc_insertion_point(class_scope:mt.TImageParam)
 private:
  inline void set_has_img_param_type();
  inline void clear_has_img_param_type();
  inline void set_has_val();
  inline void clear_has_val();
  inline void set_has_is_auto();
  inline void clear_has_is_auto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int img_param_type_;
  ::google::protobuf::uint32 val_;
  bool is_auto_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TImageParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDefaultImageParam : public ::google::protobuf::Message {
 public:
  TDefaultImageParam();
  virtual ~TDefaultImageParam();

  TDefaultImageParam(const TDefaultImageParam& from);

  inline TDefaultImageParam& operator=(const TDefaultImageParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDefaultImageParam& default_instance();

  void Swap(TDefaultImageParam* other);

  // implements Message ----------------------------------------------

  TDefaultImageParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDefaultImageParam& from);
  void MergeFrom(const TDefaultImageParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmImgParam img_param_type = 1;
  inline bool has_img_param_type() const;
  inline void clear_img_param_type();
  static const int kImgParamTypeFieldNumber = 1;
  inline ::mt::EmImgParam img_param_type() const;
  inline void set_img_param_type(::mt::EmImgParam value);

  // optional uint32 min_val = 2;
  inline bool has_min_val() const;
  inline void clear_min_val();
  static const int kMinValFieldNumber = 2;
  inline ::google::protobuf::uint32 min_val() const;
  inline void set_min_val(::google::protobuf::uint32 value);

  // optional uint32 max_val = 3;
  inline bool has_max_val() const;
  inline void clear_max_val();
  static const int kMaxValFieldNumber = 3;
  inline ::google::protobuf::uint32 max_val() const;
  inline void set_max_val(::google::protobuf::uint32 value);

  // optional uint32 def_val = 4;
  inline bool has_def_val() const;
  inline void clear_def_val();
  static const int kDefValFieldNumber = 4;
  inline ::google::protobuf::uint32 def_val() const;
  inline void set_def_val(::google::protobuf::uint32 value);

  // optional uint32 step = 5;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 5;
  inline ::google::protobuf::uint32 step() const;
  inline void set_step(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TDefaultImageParam)
 private:
  inline void set_has_img_param_type();
  inline void clear_has_img_param_type();
  inline void set_has_min_val();
  inline void clear_has_min_val();
  inline void set_has_max_val();
  inline void clear_has_max_val();
  inline void set_has_def_val();
  inline void clear_has_def_val();
  inline void set_has_step();
  inline void clear_has_step();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int img_param_type_;
  ::google::protobuf::uint32 min_val_;
  ::google::protobuf::uint32 max_val_;
  ::google::protobuf::uint32 def_val_;
  ::google::protobuf::uint32 step_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TDefaultImageParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudInputState : public ::google::protobuf::Message {
 public:
  TAudInputState();
  virtual ~TAudInputState();

  TAudInputState(const TAudInputState& from);

  inline TAudInputState& operator=(const TAudInputState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudInputState& default_instance();

  void Swap(TAudInputState* other);

  // implements Message ----------------------------------------------

  TAudInputState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudInputState& from);
  void MergeFrom(const TAudInputState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmHDAudPortIn emAudInputType = 1;
  inline bool has_emaudinputtype() const;
  inline void clear_emaudinputtype();
  static const int kEmAudInputTypeFieldNumber = 1;
  inline ::mt::EmHDAudPortIn emaudinputtype() const;
  inline void set_emaudinputtype(::mt::EmHDAudPortIn value);

  // optional bool bUsed = 2;
  inline bool has_bused() const;
  inline void clear_bused();
  static const int kBUsedFieldNumber = 2;
  inline bool bused() const;
  inline void set_bused(bool value);

  // @@protoc_insertion_point(class_scope:mt.TAudInputState)
 private:
  inline void set_has_emaudinputtype();
  inline void clear_has_emaudinputtype();
  inline void set_has_bused();
  inline void clear_has_bused();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emaudinputtype_;
  bool bused_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TAudInputState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMultiAudInputState : public ::google::protobuf::Message {
 public:
  TMultiAudInputState();
  virtual ~TMultiAudInputState();

  TMultiAudInputState(const TMultiAudInputState& from);

  inline TMultiAudInputState& operator=(const TMultiAudInputState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMultiAudInputState& default_instance();

  void Swap(TMultiAudInputState* other);

  // implements Message ----------------------------------------------

  TMultiAudInputState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMultiAudInputState& from);
  void MergeFrom(const TMultiAudInputState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAudInputState audio_input_state = 1;
  inline int audio_input_state_size() const;
  inline void clear_audio_input_state();
  static const int kAudioInputStateFieldNumber = 1;
  inline const ::mt::TAudInputState& audio_input_state(int index) const;
  inline ::mt::TAudInputState* mutable_audio_input_state(int index);
  inline ::mt::TAudInputState* add_audio_input_state();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudInputState >&
      audio_input_state() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudInputState >*
      mutable_audio_input_state();

  // @@protoc_insertion_point(class_scope:mt.TMultiAudInputState)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAudInputState > audio_input_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMultiAudInputState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudOutputState : public ::google::protobuf::Message {
 public:
  TAudOutputState();
  virtual ~TAudOutputState();

  TAudOutputState(const TAudOutputState& from);

  inline TAudOutputState& operator=(const TAudOutputState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudOutputState& default_instance();

  void Swap(TAudOutputState* other);

  // implements Message ----------------------------------------------

  TAudOutputState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudOutputState& from);
  void MergeFrom(const TAudOutputState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmHDAudPortOut emAudOutputType = 1;
  inline bool has_emaudoutputtype() const;
  inline void clear_emaudoutputtype();
  static const int kEmAudOutputTypeFieldNumber = 1;
  inline ::mt::EmHDAudPortOut emaudoutputtype() const;
  inline void set_emaudoutputtype(::mt::EmHDAudPortOut value);

  // optional bool bUsed = 2;
  inline bool has_bused() const;
  inline void clear_bused();
  static const int kBUsedFieldNumber = 2;
  inline bool bused() const;
  inline void set_bused(bool value);

  // @@protoc_insertion_point(class_scope:mt.TAudOutputState)
 private:
  inline void set_has_emaudoutputtype();
  inline void clear_has_emaudoutputtype();
  inline void set_has_bused();
  inline void clear_has_bused();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emaudoutputtype_;
  bool bused_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TAudOutputState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMultiAudOutputState : public ::google::protobuf::Message {
 public:
  TMultiAudOutputState();
  virtual ~TMultiAudOutputState();

  TMultiAudOutputState(const TMultiAudOutputState& from);

  inline TMultiAudOutputState& operator=(const TMultiAudOutputState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMultiAudOutputState& default_instance();

  void Swap(TMultiAudOutputState* other);

  // implements Message ----------------------------------------------

  TMultiAudOutputState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMultiAudOutputState& from);
  void MergeFrom(const TMultiAudOutputState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAudOutputState audio_output_state = 1;
  inline int audio_output_state_size() const;
  inline void clear_audio_output_state();
  static const int kAudioOutputStateFieldNumber = 1;
  inline const ::mt::TAudOutputState& audio_output_state(int index) const;
  inline ::mt::TAudOutputState* mutable_audio_output_state(int index);
  inline ::mt::TAudOutputState* add_audio_output_state();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudOutputState >&
      audio_output_state() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudOutputState >*
      mutable_audio_output_state();

  // @@protoc_insertion_point(class_scope:mt.TMultiAudOutputState)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAudOutputState > audio_output_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMultiAudOutputState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVideoResDetect : public ::google::protobuf::Message {
 public:
  TVideoResDetect();
  virtual ~TVideoResDetect();

  TVideoResDetect(const TVideoResDetect& from);

  inline TVideoResDetect& operator=(const TVideoResDetect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVideoResDetect& default_instance();

  void Swap(TVideoResDetect* other);

  // implements Message ----------------------------------------------

  TVideoResDetect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVideoResDetect& from);
  void MergeFrom(const TVideoResDetect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVideoType video_type = 1;
  inline bool has_video_type() const;
  inline void clear_video_type();
  static const int kVideoTypeFieldNumber = 1;
  inline ::mt::EmVideoType video_type() const;
  inline void set_video_type(::mt::EmVideoType value);

  // optional .mt.EmMtVideoPort video_port = 2;
  inline bool has_video_port() const;
  inline void clear_video_port();
  static const int kVideoPortFieldNumber = 2;
  inline ::mt::EmMtVideoPort video_port() const;
  inline void set_video_port(::mt::EmMtVideoPort value);

  // optional .mt.EmMtResolution video_res = 3;
  inline bool has_video_res() const;
  inline void clear_video_res();
  static const int kVideoResFieldNumber = 3;
  inline ::mt::EmMtResolution video_res() const;
  inline void set_video_res(::mt::EmMtResolution value);

  // optional uint32 framerate = 4;
  inline bool has_framerate() const;
  inline void clear_framerate();
  static const int kFramerateFieldNumber = 4;
  inline ::google::protobuf::uint32 framerate() const;
  inline void set_framerate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TVideoResDetect)
 private:
  inline void set_has_video_type();
  inline void clear_has_video_type();
  inline void set_has_video_port();
  inline void clear_has_video_port();
  inline void set_has_video_res();
  inline void clear_has_video_res();
  inline void set_has_framerate();
  inline void clear_has_framerate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_type_;
  int video_port_;
  int video_res_;
  ::google::protobuf::uint32 framerate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TVideoResDetect* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMultiVideoResDetect : public ::google::protobuf::Message {
 public:
  TMultiVideoResDetect();
  virtual ~TMultiVideoResDetect();

  TMultiVideoResDetect(const TMultiVideoResDetect& from);

  inline TMultiVideoResDetect& operator=(const TMultiVideoResDetect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMultiVideoResDetect& default_instance();

  void Swap(TMultiVideoResDetect* other);

  // implements Message ----------------------------------------------

  TMultiVideoResDetect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMultiVideoResDetect& from);
  void MergeFrom(const TMultiVideoResDetect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVideoResDetect video_state = 1;
  inline int video_state_size() const;
  inline void clear_video_state();
  static const int kVideoStateFieldNumber = 1;
  inline const ::mt::TVideoResDetect& video_state(int index) const;
  inline ::mt::TVideoResDetect* mutable_video_state(int index);
  inline ::mt::TVideoResDetect* add_video_state();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVideoResDetect >&
      video_state() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVideoResDetect >*
      mutable_video_state();

  // @@protoc_insertion_point(class_scope:mt.TMultiVideoResDetect)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVideoResDetect > video_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMultiVideoResDetect* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TFxoState : public ::google::protobuf::Message {
 public:
  TFxoState();
  virtual ~TFxoState();

  TFxoState(const TFxoState& from);

  inline TFxoState& operator=(const TFxoState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFxoState& default_instance();

  void Swap(TFxoState* other);

  // implements Message ----------------------------------------------

  TFxoState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFxoState& from);
  void MergeFrom(const TFxoState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmFxoState emFxo_state = 1;
  inline bool has_emfxo_state() const;
  inline void clear_emfxo_state();
  static const int kEmFxoStateFieldNumber = 1;
  inline ::mt::EmFxoState emfxo_state() const;
  inline void set_emfxo_state(::mt::EmFxoState value);

  // @@protoc_insertion_point(class_scope:mt.TFxoState)
 private:
  inline void set_has_emfxo_state();
  inline void clear_has_emfxo_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emfxo_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TFxoState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVidSrcInfo : public ::google::protobuf::Message {
 public:
  TMtVidSrcInfo();
  virtual ~TMtVidSrcInfo();

  TMtVidSrcInfo(const TMtVidSrcInfo& from);

  inline TMtVidSrcInfo& operator=(const TMtVidSrcInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVidSrcInfo& default_instance();

  void Swap(TMtVidSrcInfo* other);

  // implements Message ----------------------------------------------

  TMtVidSrcInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVidSrcInfo& from);
  void MergeFrom(const TMtVidSrcInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent codec_type = 1;
  inline bool has_codec_type() const;
  inline void clear_codec_type();
  static const int kCodecTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent codec_type() const;
  inline void set_codec_type(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex codec_id = 2;
  inline bool has_codec_id() const;
  inline void clear_codec_id();
  static const int kCodecIdFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex codec_id() const;
  inline void set_codec_id(::mt::EmCodecComponentIndex value);

  // optional uint32 video_width = 3;
  inline bool has_video_width() const;
  inline void clear_video_width();
  static const int kVideoWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 video_width() const;
  inline void set_video_width(::google::protobuf::uint32 value);

  // optional uint32 video_height = 4;
  inline bool has_video_height() const;
  inline void clear_video_height();
  static const int kVideoHeightFieldNumber = 4;
  inline ::google::protobuf::uint32 video_height() const;
  inline void set_video_height(::google::protobuf::uint32 value);

  // optional bool video_progressive = 5;
  inline bool has_video_progressive() const;
  inline void clear_video_progressive();
  static const int kVideoProgressiveFieldNumber = 5;
  inline bool video_progressive() const;
  inline void set_video_progressive(bool value);

  // optional uint32 frame_rate = 6;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 6;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtVidSrcInfo)
 private:
  inline void set_has_codec_type();
  inline void clear_has_codec_type();
  inline void set_has_codec_id();
  inline void clear_has_codec_id();
  inline void set_has_video_width();
  inline void clear_has_video_width();
  inline void set_has_video_height();
  inline void clear_has_video_height();
  inline void set_has_video_progressive();
  inline void clear_has_video_progressive();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int codec_type_;
  int codec_id_;
  ::google::protobuf::uint32 video_width_;
  ::google::protobuf::uint32 video_height_;
  bool video_progressive_;
  ::google::protobuf::uint32 frame_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtVidSrcInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVidSrcInfoList : public ::google::protobuf::Message {
 public:
  TMtVidSrcInfoList();
  virtual ~TMtVidSrcInfoList();

  TMtVidSrcInfoList(const TMtVidSrcInfoList& from);

  inline TMtVidSrcInfoList& operator=(const TMtVidSrcInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVidSrcInfoList& default_instance();

  void Swap(TMtVidSrcInfoList* other);

  // implements Message ----------------------------------------------

  TMtVidSrcInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVidSrcInfoList& from);
  void MergeFrom(const TMtVidSrcInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtVidSrcInfo video_src_status = 1;
  inline int video_src_status_size() const;
  inline void clear_video_src_status();
  static const int kVideoSrcStatusFieldNumber = 1;
  inline const ::mt::TMtVidSrcInfo& video_src_status(int index) const;
  inline ::mt::TMtVidSrcInfo* mutable_video_src_status(int index);
  inline ::mt::TMtVidSrcInfo* add_video_src_status();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtVidSrcInfo >&
      video_src_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtVidSrcInfo >*
      mutable_video_src_status();

  // @@protoc_insertion_point(class_scope:mt.TMtVidSrcInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtVidSrcInfo > video_src_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtVidSrcInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVidInPortResInfo : public ::google::protobuf::Message {
 public:
  TMtVidInPortResInfo();
  virtual ~TMtVidInPortResInfo();

  TMtVidInPortResInfo(const TMtVidInPortResInfo& from);

  inline TMtVidInPortResInfo& operator=(const TMtVidInPortResInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVidInPortResInfo& default_instance();

  void Swap(TMtVidInPortResInfo* other);

  // implements Message ----------------------------------------------

  TMtVidInPortResInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVidInPortResInfo& from);
  void MergeFrom(const TMtVidInPortResInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtVideoPort video_port = 1;
  inline bool has_video_port() const;
  inline void clear_video_port();
  static const int kVideoPortFieldNumber = 1;
  inline ::mt::EmMtVideoPort video_port() const;
  inline void set_video_port(::mt::EmMtVideoPort value);

  // optional uint32 video_width = 2;
  inline bool has_video_width() const;
  inline void clear_video_width();
  static const int kVideoWidthFieldNumber = 2;
  inline ::google::protobuf::uint32 video_width() const;
  inline void set_video_width(::google::protobuf::uint32 value);

  // optional uint32 video_height = 3;
  inline bool has_video_height() const;
  inline void clear_video_height();
  static const int kVideoHeightFieldNumber = 3;
  inline ::google::protobuf::uint32 video_height() const;
  inline void set_video_height(::google::protobuf::uint32 value);

  // optional bool video_progressive = 4;
  inline bool has_video_progressive() const;
  inline void clear_video_progressive();
  static const int kVideoProgressiveFieldNumber = 4;
  inline bool video_progressive() const;
  inline void set_video_progressive(bool value);

  // optional uint32 frame_rate = 5;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 5;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtVidInPortResInfo)
 private:
  inline void set_has_video_port();
  inline void clear_has_video_port();
  inline void set_has_video_width();
  inline void clear_has_video_width();
  inline void set_has_video_height();
  inline void clear_has_video_height();
  inline void set_has_video_progressive();
  inline void clear_has_video_progressive();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_port_;
  ::google::protobuf::uint32 video_width_;
  ::google::protobuf::uint32 video_height_;
  bool video_progressive_;
  ::google::protobuf::uint32 frame_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtVidInPortResInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVidInPortResInfoList : public ::google::protobuf::Message {
 public:
  TMtVidInPortResInfoList();
  virtual ~TMtVidInPortResInfoList();

  TMtVidInPortResInfoList(const TMtVidInPortResInfoList& from);

  inline TMtVidInPortResInfoList& operator=(const TMtVidInPortResInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVidInPortResInfoList& default_instance();

  void Swap(TMtVidInPortResInfoList* other);

  // implements Message ----------------------------------------------

  TMtVidInPortResInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVidInPortResInfoList& from);
  void MergeFrom(const TMtVidInPortResInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtVidInPortResInfo video_inport_status = 1;
  inline int video_inport_status_size() const;
  inline void clear_video_inport_status();
  static const int kVideoInportStatusFieldNumber = 1;
  inline const ::mt::TMtVidInPortResInfo& video_inport_status(int index) const;
  inline ::mt::TMtVidInPortResInfo* mutable_video_inport_status(int index);
  inline ::mt::TMtVidInPortResInfo* add_video_inport_status();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtVidInPortResInfo >&
      video_inport_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtVidInPortResInfo >*
      mutable_video_inport_status();

  // @@protoc_insertion_point(class_scope:mt.TMtVidInPortResInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtVidInPortResInfo > video_inport_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtVidInPortResInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TSnapshotFileInfo : public ::google::protobuf::Message {
 public:
  TSnapshotFileInfo();
  virtual ~TSnapshotFileInfo();

  TSnapshotFileInfo(const TSnapshotFileInfo& from);

  inline TSnapshotFileInfo& operator=(const TSnapshotFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSnapshotFileInfo& default_instance();

  void Swap(TSnapshotFileInfo* other);

  // implements Message ----------------------------------------------

  TSnapshotFileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSnapshotFileInfo& from);
  void MergeFrom(const TSnapshotFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  inline void set_allocated_file_path(::std::string* file_path);

  // optional string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional .mt.TMTTime file_create_time = 3;
  inline bool has_file_create_time() const;
  inline void clear_file_create_time();
  static const int kFileCreateTimeFieldNumber = 3;
  inline const ::mt::TMTTime& file_create_time() const;
  inline ::mt::TMTTime* mutable_file_create_time();
  inline ::mt::TMTTime* release_file_create_time();
  inline void set_allocated_file_create_time(::mt::TMTTime* file_create_time);

  // @@protoc_insertion_point(class_scope:mt.TSnapshotFileInfo)
 private:
  inline void set_has_file_path();
  inline void clear_has_file_path();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_create_time();
  inline void clear_has_file_create_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_path_;
  ::std::string* file_name_;
  ::mt::TMTTime* file_create_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TSnapshotFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TSnapshotFileList : public ::google::protobuf::Message {
 public:
  TSnapshotFileList();
  virtual ~TSnapshotFileList();

  TSnapshotFileList(const TSnapshotFileList& from);

  inline TSnapshotFileList& operator=(const TSnapshotFileList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSnapshotFileList& default_instance();

  void Swap(TSnapshotFileList* other);

  // implements Message ----------------------------------------------

  TSnapshotFileList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSnapshotFileList& from);
  void MergeFrom(const TSnapshotFileList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TSnapshotFileInfo file_list = 1;
  inline int file_list_size() const;
  inline void clear_file_list();
  static const int kFileListFieldNumber = 1;
  inline const ::mt::TSnapshotFileInfo& file_list(int index) const;
  inline ::mt::TSnapshotFileInfo* mutable_file_list(int index);
  inline ::mt::TSnapshotFileInfo* add_file_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TSnapshotFileInfo >&
      file_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TSnapshotFileInfo >*
      mutable_file_list();

  // @@protoc_insertion_point(class_scope:mt.TSnapshotFileList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TSnapshotFileInfo > file_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TSnapshotFileList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtTranspDColor : public ::google::protobuf::Message {
 public:
  TMtTranspDColor();
  virtual ~TMtTranspDColor();

  TMtTranspDColor(const TMtTranspDColor& from);

  inline TMtTranspDColor& operator=(const TMtTranspDColor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtTranspDColor& default_instance();

  void Swap(TMtTranspDColor* other);

  // implements Message ----------------------------------------------

  TMtTranspDColor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtTranspDColor& from);
  void MergeFrom(const TMtTranspDColor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rcolor = 1;
  inline bool has_rcolor() const;
  inline void clear_rcolor();
  static const int kRcolorFieldNumber = 1;
  inline ::google::protobuf::uint32 rcolor() const;
  inline void set_rcolor(::google::protobuf::uint32 value);

  // optional uint32 gcolor = 2;
  inline bool has_gcolor() const;
  inline void clear_gcolor();
  static const int kGcolorFieldNumber = 2;
  inline ::google::protobuf::uint32 gcolor() const;
  inline void set_gcolor(::google::protobuf::uint32 value);

  // optional uint32 bcolor = 3;
  inline bool has_bcolor() const;
  inline void clear_bcolor();
  static const int kBcolorFieldNumber = 3;
  inline ::google::protobuf::uint32 bcolor() const;
  inline void set_bcolor(::google::protobuf::uint32 value);

  // optional uint32 transparency = 4;
  inline bool has_transparency() const;
  inline void clear_transparency();
  static const int kTransparencyFieldNumber = 4;
  inline ::google::protobuf::uint32 transparency() const;
  inline void set_transparency(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtTranspDColor)
 private:
  inline void set_has_rcolor();
  inline void clear_has_rcolor();
  inline void set_has_gcolor();
  inline void clear_has_gcolor();
  inline void set_has_bcolor();
  inline void clear_has_bcolor();
  inline void set_has_transparency();
  inline void clear_has_transparency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 rcolor_;
  ::google::protobuf::uint32 gcolor_;
  ::google::protobuf::uint32 bcolor_;
  ::google::protobuf::uint32 transparency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtTranspDColor* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAddLogoParam : public ::google::protobuf::Message {
 public:
  TMtAddLogoParam();
  virtual ~TMtAddLogoParam();

  TMtAddLogoParam(const TMtAddLogoParam& from);

  inline TMtAddLogoParam& operator=(const TMtAddLogoParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAddLogoParam& default_instance();

  void Swap(TMtAddLogoParam* other);

  // implements Message ----------------------------------------------

  TMtAddLogoParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAddLogoParam& from);
  void MergeFrom(const TMtAddLogoParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float xposrate = 1;
  inline bool has_xposrate() const;
  inline void clear_xposrate();
  static const int kXposrateFieldNumber = 1;
  inline float xposrate() const;
  inline void set_xposrate(float value);

  // optional float yposrate = 2;
  inline bool has_yposrate() const;
  inline void clear_yposrate();
  static const int kYposrateFieldNumber = 2;
  inline float yposrate() const;
  inline void set_yposrate(float value);

  // optional uint32 logobgwidth = 3;
  inline bool has_logobgwidth() const;
  inline void clear_logobgwidth();
  static const int kLogobgwidthFieldNumber = 3;
  inline ::google::protobuf::uint32 logobgwidth() const;
  inline void set_logobgwidth(::google::protobuf::uint32 value);

  // optional uint32 logobgheigh = 4;
  inline bool has_logobgheigh() const;
  inline void clear_logobgheigh();
  static const int kLogobgheighFieldNumber = 4;
  inline ::google::protobuf::uint32 logobgheigh() const;
  inline void set_logobgheigh(::google::protobuf::uint32 value);

  // optional .mt.TMtTranspDColor backbgdcolor = 5;
  inline bool has_backbgdcolor() const;
  inline void clear_backbgdcolor();
  static const int kBackbgdcolorFieldNumber = 5;
  inline const ::mt::TMtTranspDColor& backbgdcolor() const;
  inline ::mt::TMtTranspDColor* mutable_backbgdcolor();
  inline ::mt::TMtTranspDColor* release_backbgdcolor();
  inline void set_allocated_backbgdcolor(::mt::TMtTranspDColor* backbgdcolor);

  // @@protoc_insertion_point(class_scope:mt.TMtAddLogoParam)
 private:
  inline void set_has_xposrate();
  inline void clear_has_xposrate();
  inline void set_has_yposrate();
  inline void clear_has_yposrate();
  inline void set_has_logobgwidth();
  inline void clear_has_logobgwidth();
  inline void set_has_logobgheigh();
  inline void clear_has_logobgheigh();
  inline void set_has_backbgdcolor();
  inline void clear_has_backbgdcolor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float xposrate_;
  float yposrate_;
  ::google::protobuf::uint32 logobgwidth_;
  ::google::protobuf::uint32 logobgheigh_;
  ::mt::TMtTranspDColor* backbgdcolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtAddLogoParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtFullLogoParam : public ::google::protobuf::Message {
 public:
  TMtFullLogoParam();
  virtual ~TMtFullLogoParam();

  TMtFullLogoParam(const TMtFullLogoParam& from);

  inline TMtFullLogoParam& operator=(const TMtFullLogoParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtFullLogoParam& default_instance();

  void Swap(TMtFullLogoParam* other);

  // implements Message ----------------------------------------------

  TMtFullLogoParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtFullLogoParam& from);
  void MergeFrom(const TMtFullLogoParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bmp_path = 1;
  inline bool has_bmp_path() const;
  inline void clear_bmp_path();
  static const int kBmpPathFieldNumber = 1;
  inline const ::std::string& bmp_path() const;
  inline void set_bmp_path(const ::std::string& value);
  inline void set_bmp_path(const char* value);
  inline void set_bmp_path(const char* value, size_t size);
  inline ::std::string* mutable_bmp_path();
  inline ::std::string* release_bmp_path();
  inline void set_allocated_bmp_path(::std::string* bmp_path);

  // optional .mt.TMtAddLogoParam logoparam = 3;
  inline bool has_logoparam() const;
  inline void clear_logoparam();
  static const int kLogoparamFieldNumber = 3;
  inline const ::mt::TMtAddLogoParam& logoparam() const;
  inline ::mt::TMtAddLogoParam* mutable_logoparam();
  inline ::mt::TMtAddLogoParam* release_logoparam();
  inline void set_allocated_logoparam(::mt::TMtAddLogoParam* logoparam);

  // @@protoc_insertion_point(class_scope:mt.TMtFullLogoParam)
 private:
  inline void set_has_bmp_path();
  inline void clear_has_bmp_path();
  inline void set_has_logoparam();
  inline void clear_has_logoparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bmp_path_;
  ::mt::TMtAddLogoParam* logoparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtFullLogoParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtFullLogoParam : public ::google::protobuf::Message {
 public:
  TRpMtFullLogoParam();
  virtual ~TRpMtFullLogoParam();

  TRpMtFullLogoParam(const TRpMtFullLogoParam& from);

  inline TRpMtFullLogoParam& operator=(const TRpMtFullLogoParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtFullLogoParam& default_instance();

  void Swap(TRpMtFullLogoParam* other);

  // implements Message ----------------------------------------------

  TRpMtFullLogoParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtFullLogoParam& from);
  void MergeFrom(const TRpMtFullLogoParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtFullLogoParam fulllogoparam = 1;
  inline int fulllogoparam_size() const;
  inline void clear_fulllogoparam();
  static const int kFulllogoparamFieldNumber = 1;
  inline const ::mt::TMtFullLogoParam& fulllogoparam(int index) const;
  inline ::mt::TMtFullLogoParam* mutable_fulllogoparam(int index);
  inline ::mt::TMtFullLogoParam* add_fulllogoparam();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtFullLogoParam >&
      fulllogoparam() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtFullLogoParam >*
      mutable_fulllogoparam();

  // @@protoc_insertion_point(class_scope:mt.TRpMtFullLogoParam)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtFullLogoParam > fulllogoparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TRpMtFullLogoParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtPIPMode : public ::google::protobuf::Message {
 public:
  TMtPIPMode();
  virtual ~TMtPIPMode();

  TMtPIPMode(const TMtPIPMode& from);

  inline TMtPIPMode& operator=(const TMtPIPMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtPIPMode& default_instance();

  void Swap(TMtPIPMode* other);

  // implements Message ----------------------------------------------

  TMtPIPMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtPIPMode& from);
  void MergeFrom(const TMtPIPMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmPiPMode pip_mode = 1;
  inline bool has_pip_mode() const;
  inline void clear_pip_mode();
  static const int kPipModeFieldNumber = 1;
  inline ::mt::EmPiPMode pip_mode() const;
  inline void set_pip_mode(::mt::EmPiPMode value);

  // @@protoc_insertion_point(class_scope:mt.TMtPIPMode)
 private:
  inline void set_has_pip_mode();
  inline void clear_has_pip_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int pip_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtPIPMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoInOutPortModeList : public ::google::protobuf::Message {
 public:
  TMTVideoInOutPortModeList();
  virtual ~TMTVideoInOutPortModeList();

  TMTVideoInOutPortModeList(const TMTVideoInOutPortModeList& from);

  inline TMTVideoInOutPortModeList& operator=(const TMTVideoInOutPortModeList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoInOutPortModeList& default_instance();

  void Swap(TMTVideoInOutPortModeList* other);

  // implements Message ----------------------------------------------

  TMTVideoInOutPortModeList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoInOutPortModeList& from);
  void MergeFrom(const TMTVideoInOutPortModeList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTVidInPortMode tInPortMode = 1;
  inline int tinportmode_size() const;
  inline void clear_tinportmode();
  static const int kTInPortModeFieldNumber = 1;
  inline const ::mt::TMTVidInPortMode& tinportmode(int index) const;
  inline ::mt::TMTVidInPortMode* mutable_tinportmode(int index);
  inline ::mt::TMTVidInPortMode* add_tinportmode();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidInPortMode >&
      tinportmode() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidInPortMode >*
      mutable_tinportmode();

  // repeated .mt.TMTVidOutPortMode tOutPortMode = 2;
  inline int toutportmode_size() const;
  inline void clear_toutportmode();
  static const int kTOutPortModeFieldNumber = 2;
  inline const ::mt::TMTVidOutPortMode& toutportmode(int index) const;
  inline ::mt::TMTVidOutPortMode* mutable_toutportmode(int index);
  inline ::mt::TMTVidOutPortMode* add_toutportmode();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidOutPortMode >&
      toutportmode() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidOutPortMode >*
      mutable_toutportmode();

  // @@protoc_insertion_point(class_scope:mt.TMTVideoInOutPortModeList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTVidInPortMode > tinportmode_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVidOutPortMode > toutportmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoInOutPortModeList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAddRecordAudioMediaInfo : public ::google::protobuf::Message {
 public:
  TAddRecordAudioMediaInfo();
  virtual ~TAddRecordAudioMediaInfo();

  TAddRecordAudioMediaInfo(const TAddRecordAudioMediaInfo& from);

  inline TAddRecordAudioMediaInfo& operator=(const TAddRecordAudioMediaInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAddRecordAudioMediaInfo& default_instance();

  void Swap(TAddRecordAudioMediaInfo* other);

  // implements Message ----------------------------------------------

  TAddRecordAudioMediaInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAddRecordAudioMediaInfo& from);
  void MergeFrom(const TAddRecordAudioMediaInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 StreamType = 1;
  inline bool has_streamtype() const;
  inline void clear_streamtype();
  static const int kStreamTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 streamtype() const;
  inline void set_streamtype(::google::protobuf::uint32 value);

  // optional uint32 StreamNumber = 2;
  inline bool has_streamnumber() const;
  inline void clear_streamnumber();
  static const int kStreamNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 streamnumber() const;
  inline void set_streamnumber(::google::protobuf::uint32 value);

  // optional uint32 AverageBitrate = 3;
  inline bool has_averagebitrate() const;
  inline void clear_averagebitrate();
  static const int kAverageBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 averagebitrate() const;
  inline void set_averagebitrate(::google::protobuf::uint32 value);

  // optional uint32 CodecID_FormatTag = 4;
  inline bool has_codecid_formattag() const;
  inline void clear_codecid_formattag();
  static const int kCodecIDFormatTagFieldNumber = 4;
  inline ::google::protobuf::uint32 codecid_formattag() const;
  inline void set_codecid_formattag(::google::protobuf::uint32 value);

  // optional uint32 NumberOfChannels = 5;
  inline bool has_numberofchannels() const;
  inline void clear_numberofchannels();
  static const int kNumberOfChannelsFieldNumber = 5;
  inline ::google::protobuf::uint32 numberofchannels() const;
  inline void set_numberofchannels(::google::protobuf::uint32 value);

  // optional uint32 SamplesPerSecond = 6;
  inline bool has_samplespersecond() const;
  inline void clear_samplespersecond();
  static const int kSamplesPerSecondFieldNumber = 6;
  inline ::google::protobuf::uint32 samplespersecond() const;
  inline void set_samplespersecond(::google::protobuf::uint32 value);

  // optional uint32 AverageNumberOfBytesPerSecond = 7;
  inline bool has_averagenumberofbytespersecond() const;
  inline void clear_averagenumberofbytespersecond();
  static const int kAverageNumberOfBytesPerSecondFieldNumber = 7;
  inline ::google::protobuf::uint32 averagenumberofbytespersecond() const;
  inline void set_averagenumberofbytespersecond(::google::protobuf::uint32 value);

  // optional uint32 FrameRate = 8;
  inline bool has_framerate() const;
  inline void clear_framerate();
  static const int kFrameRateFieldNumber = 8;
  inline ::google::protobuf::uint32 framerate() const;
  inline void set_framerate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TAddRecordAudioMediaInfo)
 private:
  inline void set_has_streamtype();
  inline void clear_has_streamtype();
  inline void set_has_streamnumber();
  inline void clear_has_streamnumber();
  inline void set_has_averagebitrate();
  inline void clear_has_averagebitrate();
  inline void set_has_codecid_formattag();
  inline void clear_has_codecid_formattag();
  inline void set_has_numberofchannels();
  inline void clear_has_numberofchannels();
  inline void set_has_samplespersecond();
  inline void clear_has_samplespersecond();
  inline void set_has_averagenumberofbytespersecond();
  inline void clear_has_averagenumberofbytespersecond();
  inline void set_has_framerate();
  inline void clear_has_framerate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 streamtype_;
  ::google::protobuf::uint32 streamnumber_;
  ::google::protobuf::uint32 averagebitrate_;
  ::google::protobuf::uint32 codecid_formattag_;
  ::google::protobuf::uint32 numberofchannels_;
  ::google::protobuf::uint32 samplespersecond_;
  ::google::protobuf::uint32 averagenumberofbytespersecond_;
  ::google::protobuf::uint32 framerate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TAddRecordAudioMediaInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAddRecordVideoMediaInfo : public ::google::protobuf::Message {
 public:
  TAddRecordVideoMediaInfo();
  virtual ~TAddRecordVideoMediaInfo();

  TAddRecordVideoMediaInfo(const TAddRecordVideoMediaInfo& from);

  inline TAddRecordVideoMediaInfo& operator=(const TAddRecordVideoMediaInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAddRecordVideoMediaInfo& default_instance();

  void Swap(TAddRecordVideoMediaInfo* other);

  // implements Message ----------------------------------------------

  TAddRecordVideoMediaInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAddRecordVideoMediaInfo& from);
  void MergeFrom(const TAddRecordVideoMediaInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 StreamType = 1;
  inline bool has_streamtype() const;
  inline void clear_streamtype();
  static const int kStreamTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 streamtype() const;
  inline void set_streamtype(::google::protobuf::uint32 value);

  // optional uint32 StreamNumber = 2;
  inline bool has_streamnumber() const;
  inline void clear_streamnumber();
  static const int kStreamNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 streamnumber() const;
  inline void set_streamnumber(::google::protobuf::uint32 value);

  // optional uint32 AverageBitrate = 3;
  inline bool has_averagebitrate() const;
  inline void clear_averagebitrate();
  static const int kAverageBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 averagebitrate() const;
  inline void set_averagebitrate(::google::protobuf::uint32 value);

  // optional uint32 EncodedImageWidth = 4;
  inline bool has_encodedimagewidth() const;
  inline void clear_encodedimagewidth();
  static const int kEncodedImageWidthFieldNumber = 4;
  inline ::google::protobuf::uint32 encodedimagewidth() const;
  inline void set_encodedimagewidth(::google::protobuf::uint32 value);

  // optional uint32 EncodedImageHeight = 5;
  inline bool has_encodedimageheight() const;
  inline void clear_encodedimageheight();
  static const int kEncodedImageHeightFieldNumber = 5;
  inline ::google::protobuf::uint32 encodedimageheight() const;
  inline void set_encodedimageheight(::google::protobuf::uint32 value);

  // optional uint32 CompressionID = 6;
  inline bool has_compressionid() const;
  inline void clear_compressionid();
  static const int kCompressionIDFieldNumber = 6;
  inline ::google::protobuf::uint32 compressionid() const;
  inline void set_compressionid(::google::protobuf::uint32 value);

  // optional uint32 FrameRate = 7;
  inline bool has_framerate() const;
  inline void clear_framerate();
  static const int kFrameRateFieldNumber = 7;
  inline ::google::protobuf::uint32 framerate() const;
  inline void set_framerate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TAddRecordVideoMediaInfo)
 private:
  inline void set_has_streamtype();
  inline void clear_has_streamtype();
  inline void set_has_streamnumber();
  inline void clear_has_streamnumber();
  inline void set_has_averagebitrate();
  inline void clear_has_averagebitrate();
  inline void set_has_encodedimagewidth();
  inline void clear_has_encodedimagewidth();
  inline void set_has_encodedimageheight();
  inline void clear_has_encodedimageheight();
  inline void set_has_compressionid();
  inline void clear_has_compressionid();
  inline void set_has_framerate();
  inline void clear_has_framerate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 streamtype_;
  ::google::protobuf::uint32 streamnumber_;
  ::google::protobuf::uint32 averagebitrate_;
  ::google::protobuf::uint32 encodedimagewidth_;
  ::google::protobuf::uint32 encodedimageheight_;
  ::google::protobuf::uint32 compressionid_;
  ::google::protobuf::uint32 framerate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TAddRecordVideoMediaInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWriteRecord : public ::google::protobuf::Message {
 public:
  TWriteRecord();
  virtual ~TWriteRecord();

  TWriteRecord(const TWriteRecord& from);

  inline TWriteRecord& operator=(const TWriteRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWriteRecord& default_instance();

  void Swap(TWriteRecord* other);

  // implements Message ----------------------------------------------

  TWriteRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWriteRecord& from);
  void MergeFrom(const TWriteRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 StreamNumber = 1;
  inline bool has_streamnumber() const;
  inline void clear_streamnumber();
  static const int kStreamNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 streamnumber() const;
  inline void set_streamnumber(::google::protobuf::uint32 value);

  // optional uint32 MediaType = 2;
  inline bool has_mediatype() const;
  inline void clear_mediatype();
  static const int kMediaTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 mediatype() const;
  inline void set_mediatype(::google::protobuf::uint32 value);

  // optional bool KeyFrame = 5;
  inline bool has_keyframe() const;
  inline void clear_keyframe();
  static const int kKeyFrameFieldNumber = 5;
  inline bool keyframe() const;
  inline void set_keyframe(bool value);

  // optional uint32 BufferSize = 4;
  inline bool has_buffersize() const;
  inline void clear_buffersize();
  static const int kBufferSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 buffersize() const;
  inline void set_buffersize(::google::protobuf::uint32 value);

  // optional uint32 DataBuffer = 3;
  inline bool has_databuffer() const;
  inline void clear_databuffer();
  static const int kDataBufferFieldNumber = 3;
  inline ::google::protobuf::uint32 databuffer() const;
  inline void set_databuffer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TWriteRecord)
 private:
  inline void set_has_streamnumber();
  inline void clear_has_streamnumber();
  inline void set_has_mediatype();
  inline void clear_has_mediatype();
  inline void set_has_keyframe();
  inline void clear_has_keyframe();
  inline void set_has_buffersize();
  inline void clear_has_buffersize();
  inline void set_has_databuffer();
  inline void clear_has_databuffer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 streamnumber_;
  ::google::protobuf::uint32 mediatype_;
  bool keyframe_;
  ::google::protobuf::uint32 buffersize_;
  ::google::protobuf::uint32 databuffer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TWriteRecord* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtCameraVidStd : public ::google::protobuf::Message {
 public:
  TMtCameraVidStd();
  virtual ~TMtCameraVidStd();

  TMtCameraVidStd(const TMtCameraVidStd& from);

  inline TMtCameraVidStd& operator=(const TMtCameraVidStd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtCameraVidStd& default_instance();

  void Swap(TMtCameraVidStd* other);

  // implements Message ----------------------------------------------

  TMtCameraVidStd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtCameraVidStd& from);
  void MergeFrom(const TMtCameraVidStd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCameraVidStd camera_vid_std = 1;
  inline bool has_camera_vid_std() const;
  inline void clear_camera_vid_std();
  static const int kCameraVidStdFieldNumber = 1;
  inline ::mt::EmCameraVidStd camera_vid_std() const;
  inline void set_camera_vid_std(::mt::EmCameraVidStd value);

  // optional string vid_std_name = 2;
  inline bool has_vid_std_name() const;
  inline void clear_vid_std_name();
  static const int kVidStdNameFieldNumber = 2;
  inline const ::std::string& vid_std_name() const;
  inline void set_vid_std_name(const ::std::string& value);
  inline void set_vid_std_name(const char* value);
  inline void set_vid_std_name(const char* value, size_t size);
  inline ::std::string* mutable_vid_std_name();
  inline ::std::string* release_vid_std_name();
  inline void set_allocated_vid_std_name(::std::string* vid_std_name);

  // @@protoc_insertion_point(class_scope:mt.TMtCameraVidStd)
 private:
  inline void set_has_camera_vid_std();
  inline void clear_has_camera_vid_std();
  inline void set_has_vid_std_name();
  inline void clear_has_vid_std_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* vid_std_name_;
  int camera_vid_std_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtCameraVidStd* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtHwChipInfo : public ::google::protobuf::Message {
 public:
  TMtHwChipInfo();
  virtual ~TMtHwChipInfo();

  TMtHwChipInfo(const TMtHwChipInfo& from);

  inline TMtHwChipInfo& operator=(const TMtHwChipInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtHwChipInfo& default_instance();

  void Swap(TMtHwChipInfo* other);

  // implements Message ----------------------------------------------

  TMtHwChipInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtHwChipInfo& from);
  void MergeFrom(const TMtHwChipInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtChipType mt_chip_type = 1;
  inline bool has_mt_chip_type() const;
  inline void clear_mt_chip_type();
  static const int kMtChipTypeFieldNumber = 1;
  inline ::mt::EmMtChipType mt_chip_type() const;
  inline void set_mt_chip_type(::mt::EmMtChipType value);

  // optional uint32 chip_status = 2;
  inline bool has_chip_status() const;
  inline void clear_chip_status();
  static const int kChipStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 chip_status() const;
  inline void set_chip_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtHwChipInfo)
 private:
  inline void set_has_mt_chip_type();
  inline void clear_has_mt_chip_type();
  inline void set_has_chip_status();
  inline void clear_has_chip_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int mt_chip_type_;
  ::google::protobuf::uint32 chip_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtHwChipInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtHwChipInfoList : public ::google::protobuf::Message {
 public:
  TMtHwChipInfoList();
  virtual ~TMtHwChipInfoList();

  TMtHwChipInfoList(const TMtHwChipInfoList& from);

  inline TMtHwChipInfoList& operator=(const TMtHwChipInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtHwChipInfoList& default_instance();

  void Swap(TMtHwChipInfoList* other);

  // implements Message ----------------------------------------------

  TMtHwChipInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtHwChipInfoList& from);
  void MergeFrom(const TMtHwChipInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtHwChipInfo hw_chip_info = 1;
  inline int hw_chip_info_size() const;
  inline void clear_hw_chip_info();
  static const int kHwChipInfoFieldNumber = 1;
  inline const ::mt::TMtHwChipInfo& hw_chip_info(int index) const;
  inline ::mt::TMtHwChipInfo* mutable_hw_chip_info(int index);
  inline ::mt::TMtHwChipInfo* add_hw_chip_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtHwChipInfo >&
      hw_chip_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtHwChipInfo >*
      mutable_hw_chip_info();

  // @@protoc_insertion_point(class_scope:mt.TMtHwChipInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtHwChipInfo > hw_chip_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtHwChipInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtQkState : public ::google::protobuf::Message {
 public:
  TMtQkState();
  virtual ~TMtQkState();

  TMtQkState(const TMtQkState& from);

  inline TMtQkState& operator=(const TMtQkState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtQkState& default_instance();

  void Swap(TMtQkState* other);

  // implements Message ----------------------------------------------

  TMtQkState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtQkState& from);
  void MergeFrom(const TMtQkState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 qk_id = 1;
  inline bool has_qk_id() const;
  inline void clear_qk_id();
  static const int kQkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 qk_id() const;
  inline void set_qk_id(::google::protobuf::uint32 value);

  // optional .mt.EmQkState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::mt::EmQkState state() const;
  inline void set_state(::mt::EmQkState value);

  // optional string pc_name = 3;
  inline bool has_pc_name() const;
  inline void clear_pc_name();
  static const int kPcNameFieldNumber = 3;
  inline const ::std::string& pc_name() const;
  inline void set_pc_name(const ::std::string& value);
  inline void set_pc_name(const char* value);
  inline void set_pc_name(const char* value, size_t size);
  inline ::std::string* mutable_pc_name();
  inline ::std::string* release_pc_name();
  inline void set_allocated_pc_name(::std::string* pc_name);

  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mt.TMtQkState)
 private:
  inline void set_has_qk_id();
  inline void clear_has_qk_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_pc_name();
  inline void clear_has_pc_name();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 qk_id_;
  int state_;
  ::std::string* pc_name_;
  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtQkState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidInputState : public ::google::protobuf::Message {
 public:
  TVidInputState();
  virtual ~TVidInputState();

  TVidInputState(const TVidInputState& from);

  inline TVidInputState& operator=(const TVidInputState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidInputState& default_instance();

  void Swap(TVidInputState* other);

  // implements Message ----------------------------------------------

  TVidInputState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidInputState& from);
  void MergeFrom(const TVidInputState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtVideoPort video_port = 1;
  inline bool has_video_port() const;
  inline void clear_video_port();
  static const int kVideoPortFieldNumber = 1;
  inline ::mt::EmMtVideoPort video_port() const;
  inline void set_video_port(::mt::EmMtVideoPort value);

  // optional bool bUsed = 2;
  inline bool has_bused() const;
  inline void clear_bused();
  static const int kBUsedFieldNumber = 2;
  inline bool bused() const;
  inline void set_bused(bool value);

  // @@protoc_insertion_point(class_scope:mt.TVidInputState)
 private:
  inline void set_has_video_port();
  inline void clear_has_video_port();
  inline void set_has_bused();
  inline void clear_has_bused();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_port_;
  bool bused_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TVidInputState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtNtfAgentSignalInfo : public ::google::protobuf::Message {
 public:
  TMtNtfAgentSignalInfo();
  virtual ~TMtNtfAgentSignalInfo();

  TMtNtfAgentSignalInfo(const TMtNtfAgentSignalInfo& from);

  inline TMtNtfAgentSignalInfo& operator=(const TMtNtfAgentSignalInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtNtfAgentSignalInfo& default_instance();

  void Swap(TMtNtfAgentSignalInfo* other);

  // implements Message ----------------------------------------------

  TMtNtfAgentSignalInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtNtfAgentSignalInfo& from);
  void MergeFrom(const TMtNtfAgentSignalInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAudInputState aud_in_list = 1;
  inline int aud_in_list_size() const;
  inline void clear_aud_in_list();
  static const int kAudInListFieldNumber = 1;
  inline const ::mt::TAudInputState& aud_in_list(int index) const;
  inline ::mt::TAudInputState* mutable_aud_in_list(int index);
  inline ::mt::TAudInputState* add_aud_in_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudInputState >&
      aud_in_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudInputState >*
      mutable_aud_in_list();

  // repeated .mt.TAudOutputState aud_out_list = 2;
  inline int aud_out_list_size() const;
  inline void clear_aud_out_list();
  static const int kAudOutListFieldNumber = 2;
  inline const ::mt::TAudOutputState& aud_out_list(int index) const;
  inline ::mt::TAudOutputState* mutable_aud_out_list(int index);
  inline ::mt::TAudOutputState* add_aud_out_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudOutputState >&
      aud_out_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudOutputState >*
      mutable_aud_out_list();

  // repeated .mt.TVidInputState vid_in_list = 3;
  inline int vid_in_list_size() const;
  inline void clear_vid_in_list();
  static const int kVidInListFieldNumber = 3;
  inline const ::mt::TVidInputState& vid_in_list(int index) const;
  inline ::mt::TVidInputState* mutable_vid_in_list(int index);
  inline ::mt::TVidInputState* add_vid_in_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidInputState >&
      vid_in_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidInputState >*
      mutable_vid_in_list();

  // @@protoc_insertion_point(class_scope:mt.TMtNtfAgentSignalInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAudInputState > aud_in_list_;
  ::google::protobuf::RepeatedPtrField< ::mt::TAudOutputState > aud_out_list_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidInputState > vid_in_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structmp_2eproto();
  friend void protobuf_AssignDesc_structmp_2eproto();
  friend void protobuf_ShutdownFile_structmp_2eproto();

  void InitAsDefaultInstance();
  static TMtNtfAgentSignalInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// TRtpRtcpPair

// optional .mt.TNetAddr rtp_addr = 1;
inline bool TRtpRtcpPair::has_rtp_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRtpRtcpPair::set_has_rtp_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRtpRtcpPair::clear_has_rtp_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRtpRtcpPair::clear_rtp_addr() {
  if (rtp_addr_ != NULL) rtp_addr_->::mt::TNetAddr::Clear();
  clear_has_rtp_addr();
}
inline const ::mt::TNetAddr& TRtpRtcpPair::rtp_addr() const {
  return rtp_addr_ != NULL ? *rtp_addr_ : *default_instance_->rtp_addr_;
}
inline ::mt::TNetAddr* TRtpRtcpPair::mutable_rtp_addr() {
  set_has_rtp_addr();
  if (rtp_addr_ == NULL) rtp_addr_ = new ::mt::TNetAddr;
  return rtp_addr_;
}
inline ::mt::TNetAddr* TRtpRtcpPair::release_rtp_addr() {
  clear_has_rtp_addr();
  ::mt::TNetAddr* temp = rtp_addr_;
  rtp_addr_ = NULL;
  return temp;
}
inline void TRtpRtcpPair::set_allocated_rtp_addr(::mt::TNetAddr* rtp_addr) {
  delete rtp_addr_;
  rtp_addr_ = rtp_addr;
  if (rtp_addr) {
    set_has_rtp_addr();
  } else {
    clear_has_rtp_addr();
  }
}

// optional .mt.TNetAddr rtcp_addr = 2;
inline bool TRtpRtcpPair::has_rtcp_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRtpRtcpPair::set_has_rtcp_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRtpRtcpPair::clear_has_rtcp_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRtpRtcpPair::clear_rtcp_addr() {
  if (rtcp_addr_ != NULL) rtcp_addr_->::mt::TNetAddr::Clear();
  clear_has_rtcp_addr();
}
inline const ::mt::TNetAddr& TRtpRtcpPair::rtcp_addr() const {
  return rtcp_addr_ != NULL ? *rtcp_addr_ : *default_instance_->rtcp_addr_;
}
inline ::mt::TNetAddr* TRtpRtcpPair::mutable_rtcp_addr() {
  set_has_rtcp_addr();
  if (rtcp_addr_ == NULL) rtcp_addr_ = new ::mt::TNetAddr;
  return rtcp_addr_;
}
inline ::mt::TNetAddr* TRtpRtcpPair::release_rtcp_addr() {
  clear_has_rtcp_addr();
  ::mt::TNetAddr* temp = rtcp_addr_;
  rtcp_addr_ = NULL;
  return temp;
}
inline void TRtpRtcpPair::set_allocated_rtcp_addr(::mt::TNetAddr* rtcp_addr) {
  delete rtcp_addr_;
  rtcp_addr_ = rtcp_addr;
  if (rtcp_addr) {
    set_has_rtcp_addr();
  } else {
    clear_has_rtcp_addr();
  }
}

// -------------------------------------------------------------------

// TNetRcvParam

// optional .mt.TNetAddr rtp_rcv_addr = 1;
inline bool TNetRcvParam::has_rtp_rcv_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNetRcvParam::set_has_rtp_rcv_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNetRcvParam::clear_has_rtp_rcv_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNetRcvParam::clear_rtp_rcv_addr() {
  if (rtp_rcv_addr_ != NULL) rtp_rcv_addr_->::mt::TNetAddr::Clear();
  clear_has_rtp_rcv_addr();
}
inline const ::mt::TNetAddr& TNetRcvParam::rtp_rcv_addr() const {
  return rtp_rcv_addr_ != NULL ? *rtp_rcv_addr_ : *default_instance_->rtp_rcv_addr_;
}
inline ::mt::TNetAddr* TNetRcvParam::mutable_rtp_rcv_addr() {
  set_has_rtp_rcv_addr();
  if (rtp_rcv_addr_ == NULL) rtp_rcv_addr_ = new ::mt::TNetAddr;
  return rtp_rcv_addr_;
}
inline ::mt::TNetAddr* TNetRcvParam::release_rtp_rcv_addr() {
  clear_has_rtp_rcv_addr();
  ::mt::TNetAddr* temp = rtp_rcv_addr_;
  rtp_rcv_addr_ = NULL;
  return temp;
}
inline void TNetRcvParam::set_allocated_rtp_rcv_addr(::mt::TNetAddr* rtp_rcv_addr) {
  delete rtp_rcv_addr_;
  rtp_rcv_addr_ = rtp_rcv_addr;
  if (rtp_rcv_addr) {
    set_has_rtp_rcv_addr();
  } else {
    clear_has_rtp_rcv_addr();
  }
}

// optional .mt.TNetAddr rtcp_rcv_addr = 2;
inline bool TNetRcvParam::has_rtcp_rcv_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNetRcvParam::set_has_rtcp_rcv_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNetRcvParam::clear_has_rtcp_rcv_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNetRcvParam::clear_rtcp_rcv_addr() {
  if (rtcp_rcv_addr_ != NULL) rtcp_rcv_addr_->::mt::TNetAddr::Clear();
  clear_has_rtcp_rcv_addr();
}
inline const ::mt::TNetAddr& TNetRcvParam::rtcp_rcv_addr() const {
  return rtcp_rcv_addr_ != NULL ? *rtcp_rcv_addr_ : *default_instance_->rtcp_rcv_addr_;
}
inline ::mt::TNetAddr* TNetRcvParam::mutable_rtcp_rcv_addr() {
  set_has_rtcp_rcv_addr();
  if (rtcp_rcv_addr_ == NULL) rtcp_rcv_addr_ = new ::mt::TNetAddr;
  return rtcp_rcv_addr_;
}
inline ::mt::TNetAddr* TNetRcvParam::release_rtcp_rcv_addr() {
  clear_has_rtcp_rcv_addr();
  ::mt::TNetAddr* temp = rtcp_rcv_addr_;
  rtcp_rcv_addr_ = NULL;
  return temp;
}
inline void TNetRcvParam::set_allocated_rtcp_rcv_addr(::mt::TNetAddr* rtcp_rcv_addr) {
  delete rtcp_rcv_addr_;
  rtcp_rcv_addr_ = rtcp_rcv_addr;
  if (rtcp_rcv_addr) {
    set_has_rtcp_rcv_addr();
  } else {
    clear_has_rtcp_rcv_addr();
  }
}

// optional .mt.TNetAddr pinghole_addr = 3;
inline bool TNetRcvParam::has_pinghole_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNetRcvParam::set_has_pinghole_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNetRcvParam::clear_has_pinghole_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNetRcvParam::clear_pinghole_addr() {
  if (pinghole_addr_ != NULL) pinghole_addr_->::mt::TNetAddr::Clear();
  clear_has_pinghole_addr();
}
inline const ::mt::TNetAddr& TNetRcvParam::pinghole_addr() const {
  return pinghole_addr_ != NULL ? *pinghole_addr_ : *default_instance_->pinghole_addr_;
}
inline ::mt::TNetAddr* TNetRcvParam::mutable_pinghole_addr() {
  set_has_pinghole_addr();
  if (pinghole_addr_ == NULL) pinghole_addr_ = new ::mt::TNetAddr;
  return pinghole_addr_;
}
inline ::mt::TNetAddr* TNetRcvParam::release_pinghole_addr() {
  clear_has_pinghole_addr();
  ::mt::TNetAddr* temp = pinghole_addr_;
  pinghole_addr_ = NULL;
  return temp;
}
inline void TNetRcvParam::set_allocated_pinghole_addr(::mt::TNetAddr* pinghole_addr) {
  delete pinghole_addr_;
  pinghole_addr_ = pinghole_addr;
  if (pinghole_addr) {
    set_has_pinghole_addr();
  } else {
    clear_has_pinghole_addr();
  }
}

// optional .mt.TNetAddr rtcp_snd_addr = 4;
inline bool TNetRcvParam::has_rtcp_snd_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNetRcvParam::set_has_rtcp_snd_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNetRcvParam::clear_has_rtcp_snd_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNetRcvParam::clear_rtcp_snd_addr() {
  if (rtcp_snd_addr_ != NULL) rtcp_snd_addr_->::mt::TNetAddr::Clear();
  clear_has_rtcp_snd_addr();
}
inline const ::mt::TNetAddr& TNetRcvParam::rtcp_snd_addr() const {
  return rtcp_snd_addr_ != NULL ? *rtcp_snd_addr_ : *default_instance_->rtcp_snd_addr_;
}
inline ::mt::TNetAddr* TNetRcvParam::mutable_rtcp_snd_addr() {
  set_has_rtcp_snd_addr();
  if (rtcp_snd_addr_ == NULL) rtcp_snd_addr_ = new ::mt::TNetAddr;
  return rtcp_snd_addr_;
}
inline ::mt::TNetAddr* TNetRcvParam::release_rtcp_snd_addr() {
  clear_has_rtcp_snd_addr();
  ::mt::TNetAddr* temp = rtcp_snd_addr_;
  rtcp_snd_addr_ = NULL;
  return temp;
}
inline void TNetRcvParam::set_allocated_rtcp_snd_addr(::mt::TNetAddr* rtcp_snd_addr) {
  delete rtcp_snd_addr_;
  rtcp_snd_addr_ = rtcp_snd_addr;
  if (rtcp_snd_addr) {
    set_has_rtcp_snd_addr();
  } else {
    clear_has_rtcp_snd_addr();
  }
}

// -------------------------------------------------------------------

// TNetSndParam

// optional .mt.TRtpRtcpPair local_addr = 1;
inline bool TNetSndParam::has_local_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNetSndParam::set_has_local_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNetSndParam::clear_has_local_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNetSndParam::clear_local_addr() {
  if (local_addr_ != NULL) local_addr_->::mt::TRtpRtcpPair::Clear();
  clear_has_local_addr();
}
inline const ::mt::TRtpRtcpPair& TNetSndParam::local_addr() const {
  return local_addr_ != NULL ? *local_addr_ : *default_instance_->local_addr_;
}
inline ::mt::TRtpRtcpPair* TNetSndParam::mutable_local_addr() {
  set_has_local_addr();
  if (local_addr_ == NULL) local_addr_ = new ::mt::TRtpRtcpPair;
  return local_addr_;
}
inline ::mt::TRtpRtcpPair* TNetSndParam::release_local_addr() {
  clear_has_local_addr();
  ::mt::TRtpRtcpPair* temp = local_addr_;
  local_addr_ = NULL;
  return temp;
}
inline void TNetSndParam::set_allocated_local_addr(::mt::TRtpRtcpPair* local_addr) {
  delete local_addr_;
  local_addr_ = local_addr;
  if (local_addr) {
    set_has_local_addr();
  } else {
    clear_has_local_addr();
  }
}

// repeated .mt.TRtpRtcpPair remote_addrs = 2;
inline int TNetSndParam::remote_addrs_size() const {
  return remote_addrs_.size();
}
inline void TNetSndParam::clear_remote_addrs() {
  remote_addrs_.Clear();
}
inline const ::mt::TRtpRtcpPair& TNetSndParam::remote_addrs(int index) const {
  return remote_addrs_.Get(index);
}
inline ::mt::TRtpRtcpPair* TNetSndParam::mutable_remote_addrs(int index) {
  return remote_addrs_.Mutable(index);
}
inline ::mt::TRtpRtcpPair* TNetSndParam::add_remote_addrs() {
  return remote_addrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPair >&
TNetSndParam::remote_addrs() const {
  return remote_addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPair >*
TNetSndParam::mutable_remote_addrs() {
  return &remote_addrs_;
}

// -------------------------------------------------------------------

// TVidEncParam

// optional .mt.EmEncodeMode enc_mode = 1;
inline bool TVidEncParam::has_enc_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVidEncParam::set_has_enc_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVidEncParam::clear_has_enc_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVidEncParam::clear_enc_mode() {
  enc_mode_ = 0;
  clear_has_enc_mode();
}
inline ::mt::EmEncodeMode TVidEncParam::enc_mode() const {
  return static_cast< ::mt::EmEncodeMode >(enc_mode_);
}
inline void TVidEncParam::set_enc_mode(::mt::EmEncodeMode value) {
  assert(::mt::EmEncodeMode_IsValid(value));
  set_has_enc_mode();
  enc_mode_ = value;
}

// optional .mt.EmVidFormat vid_format = 2;
inline bool TVidEncParam::has_vid_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVidEncParam::set_has_vid_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVidEncParam::clear_has_vid_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVidEncParam::clear_vid_format() {
  vid_format_ = 0;
  clear_has_vid_format();
}
inline ::mt::EmVidFormat TVidEncParam::vid_format() const {
  return static_cast< ::mt::EmVidFormat >(vid_format_);
}
inline void TVidEncParam::set_vid_format(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_vid_format();
  vid_format_ = value;
}

// optional uint32 max_key_frame_interval = 3;
inline bool TVidEncParam::has_max_key_frame_interval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVidEncParam::set_has_max_key_frame_interval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVidEncParam::clear_has_max_key_frame_interval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVidEncParam::clear_max_key_frame_interval() {
  max_key_frame_interval_ = 0u;
  clear_has_max_key_frame_interval();
}
inline ::google::protobuf::uint32 TVidEncParam::max_key_frame_interval() const {
  return max_key_frame_interval_;
}
inline void TVidEncParam::set_max_key_frame_interval(::google::protobuf::uint32 value) {
  set_has_max_key_frame_interval();
  max_key_frame_interval_ = value;
}

// optional uint32 max_quant = 4;
inline bool TVidEncParam::has_max_quant() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVidEncParam::set_has_max_quant() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVidEncParam::clear_has_max_quant() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVidEncParam::clear_max_quant() {
  max_quant_ = 0u;
  clear_has_max_quant();
}
inline ::google::protobuf::uint32 TVidEncParam::max_quant() const {
  return max_quant_;
}
inline void TVidEncParam::set_max_quant(::google::protobuf::uint32 value) {
  set_has_max_quant();
  max_quant_ = value;
}

// optional uint32 min_quant = 5;
inline bool TVidEncParam::has_min_quant() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVidEncParam::set_has_min_quant() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVidEncParam::clear_has_min_quant() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVidEncParam::clear_min_quant() {
  min_quant_ = 0u;
  clear_has_min_quant();
}
inline ::google::protobuf::uint32 TVidEncParam::min_quant() const {
  return min_quant_;
}
inline void TVidEncParam::set_min_quant(::google::protobuf::uint32 value) {
  set_has_min_quant();
  min_quant_ = value;
}

// optional uint32 frame_rate = 6;
inline bool TVidEncParam::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVidEncParam::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVidEncParam::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVidEncParam::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TVidEncParam::frame_rate() const {
  return frame_rate_;
}
inline void TVidEncParam::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// optional uint32 bitrate = 7;
inline bool TVidEncParam::has_bitrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVidEncParam::set_has_bitrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVidEncParam::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVidEncParam::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TVidEncParam::bitrate() const {
  return bitrate_;
}
inline void TVidEncParam::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional uint32 h264_profile = 8;
inline bool TVidEncParam::has_h264_profile() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TVidEncParam::set_has_h264_profile() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TVidEncParam::clear_has_h264_profile() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TVidEncParam::clear_h264_profile() {
  h264_profile_ = 0u;
  clear_has_h264_profile();
}
inline ::google::protobuf::uint32 TVidEncParam::h264_profile() const {
  return h264_profile_;
}
inline void TVidEncParam::set_h264_profile(::google::protobuf::uint32 value) {
  set_has_h264_profile();
  h264_profile_ = value;
}

// optional uint32 width = 9;
inline bool TVidEncParam::has_width() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TVidEncParam::set_has_width() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TVidEncParam::clear_has_width() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TVidEncParam::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 TVidEncParam::width() const {
  return width_;
}
inline void TVidEncParam::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional uint32 height = 10;
inline bool TVidEncParam::has_height() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TVidEncParam::set_has_height() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TVidEncParam::clear_has_height() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TVidEncParam::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 TVidEncParam::height() const {
  return height_;
}
inline void TVidEncParam::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// TAudEncDecParam

// optional .mt.EmAudFormat aud_format = 1;
inline bool TAudEncDecParam::has_aud_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAudEncDecParam::set_has_aud_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAudEncDecParam::clear_has_aud_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAudEncDecParam::clear_aud_format() {
  aud_format_ = 0;
  clear_has_aud_format();
}
inline ::mt::EmAudFormat TAudEncDecParam::aud_format() const {
  return static_cast< ::mt::EmAudFormat >(aud_format_);
}
inline void TAudEncDecParam::set_aud_format(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_aud_format();
  aud_format_ = value;
}

// optional .mt.EmAacChnlNum aac_channel_num = 2;
inline bool TAudEncDecParam::has_aac_channel_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAudEncDecParam::set_has_aac_channel_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAudEncDecParam::clear_has_aac_channel_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAudEncDecParam::clear_aac_channel_num() {
  aac_channel_num_ = 0;
  clear_has_aac_channel_num();
}
inline ::mt::EmAacChnlNum TAudEncDecParam::aac_channel_num() const {
  return static_cast< ::mt::EmAacChnlNum >(aac_channel_num_);
}
inline void TAudEncDecParam::set_aac_channel_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_aac_channel_num();
  aac_channel_num_ = value;
}

// optional .mt.EmAacSampFreq aac_sample_rate = 3;
inline bool TAudEncDecParam::has_aac_sample_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAudEncDecParam::set_has_aac_sample_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAudEncDecParam::clear_has_aac_sample_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAudEncDecParam::clear_aac_sample_rate() {
  aac_sample_rate_ = 0;
  clear_has_aac_sample_rate();
}
inline ::mt::EmAacSampFreq TAudEncDecParam::aac_sample_rate() const {
  return static_cast< ::mt::EmAacSampFreq >(aac_sample_rate_);
}
inline void TAudEncDecParam::set_aac_sample_rate(::mt::EmAacSampFreq value) {
  assert(::mt::EmAacSampFreq_IsValid(value));
  set_has_aac_sample_rate();
  aac_sample_rate_ = value;
}

// optional uint32 aac_rate = 4;
inline bool TAudEncDecParam::has_aac_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAudEncDecParam::set_has_aac_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAudEncDecParam::clear_has_aac_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAudEncDecParam::clear_aac_rate() {
  aac_rate_ = 0u;
  clear_has_aac_rate();
}
inline ::google::protobuf::uint32 TAudEncDecParam::aac_rate() const {
  return aac_rate_;
}
inline void TAudEncDecParam::set_aac_rate(::google::protobuf::uint32 value) {
  set_has_aac_rate();
  aac_rate_ = value;
}

// optional uint32 g7221_rate = 5;
inline bool TAudEncDecParam::has_g7221_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TAudEncDecParam::set_has_g7221_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TAudEncDecParam::clear_has_g7221_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TAudEncDecParam::clear_g7221_rate() {
  g7221_rate_ = 0u;
  clear_has_g7221_rate();
}
inline ::google::protobuf::uint32 TAudEncDecParam::g7221_rate() const {
  return g7221_rate_;
}
inline void TAudEncDecParam::set_g7221_rate(::google::protobuf::uint32 value) {
  set_has_g7221_rate();
  g7221_rate_ = value;
}

// optional bytes conf_para = 6;
inline bool TAudEncDecParam::has_conf_para() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TAudEncDecParam::set_has_conf_para() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TAudEncDecParam::clear_has_conf_para() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TAudEncDecParam::clear_conf_para() {
  if (conf_para_ != &::google::protobuf::internal::kEmptyString) {
    conf_para_->clear();
  }
  clear_has_conf_para();
}
inline const ::std::string& TAudEncDecParam::conf_para() const {
  return *conf_para_;
}
inline void TAudEncDecParam::set_conf_para(const ::std::string& value) {
  set_has_conf_para();
  if (conf_para_ == &::google::protobuf::internal::kEmptyString) {
    conf_para_ = new ::std::string;
  }
  conf_para_->assign(value);
}
inline void TAudEncDecParam::set_conf_para(const char* value) {
  set_has_conf_para();
  if (conf_para_ == &::google::protobuf::internal::kEmptyString) {
    conf_para_ = new ::std::string;
  }
  conf_para_->assign(value);
}
inline void TAudEncDecParam::set_conf_para(const void* value, size_t size) {
  set_has_conf_para();
  if (conf_para_ == &::google::protobuf::internal::kEmptyString) {
    conf_para_ = new ::std::string;
  }
  conf_para_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TAudEncDecParam::mutable_conf_para() {
  set_has_conf_para();
  if (conf_para_ == &::google::protobuf::internal::kEmptyString) {
    conf_para_ = new ::std::string;
  }
  return conf_para_;
}
inline ::std::string* TAudEncDecParam::release_conf_para() {
  clear_has_conf_para();
  if (conf_para_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_para_;
    conf_para_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TAudEncDecParam::set_allocated_conf_para(::std::string* conf_para) {
  if (conf_para_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_para_;
  }
  if (conf_para) {
    set_has_conf_para();
    conf_para_ = conf_para;
  } else {
    clear_has_conf_para();
    conf_para_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TAudEncStatistic

// optional .mt.EmCodecComponent type = 1;
inline bool TAudEncStatistic::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAudEncStatistic::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAudEncStatistic::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAudEncStatistic::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmCodecComponent TAudEncStatistic::type() const {
  return static_cast< ::mt::EmCodecComponent >(type_);
}
inline void TAudEncStatistic::set_type(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mt.EmCodecComponentIndex aud_enc_id = 2;
inline bool TAudEncStatistic::has_aud_enc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAudEncStatistic::set_has_aud_enc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAudEncStatistic::clear_has_aud_enc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAudEncStatistic::clear_aud_enc_id() {
  aud_enc_id_ = 0;
  clear_has_aud_enc_id();
}
inline ::mt::EmCodecComponentIndex TAudEncStatistic::aud_enc_id() const {
  return static_cast< ::mt::EmCodecComponentIndex >(aud_enc_id_);
}
inline void TAudEncStatistic::set_aud_enc_id(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_aud_enc_id();
  aud_enc_id_ = value;
}

// optional uint32 enc_bitrate = 3;
inline bool TAudEncStatistic::has_enc_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAudEncStatistic::set_has_enc_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAudEncStatistic::clear_has_enc_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAudEncStatistic::clear_enc_bitrate() {
  enc_bitrate_ = 0u;
  clear_has_enc_bitrate();
}
inline ::google::protobuf::uint32 TAudEncStatistic::enc_bitrate() const {
  return enc_bitrate_;
}
inline void TAudEncStatistic::set_enc_bitrate(::google::protobuf::uint32 value) {
  set_has_enc_bitrate();
  enc_bitrate_ = value;
}

// optional .mt.EmAudFormat aud_enc_type = 4;
inline bool TAudEncStatistic::has_aud_enc_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAudEncStatistic::set_has_aud_enc_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAudEncStatistic::clear_has_aud_enc_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAudEncStatistic::clear_aud_enc_type() {
  aud_enc_type_ = 0;
  clear_has_aud_enc_type();
}
inline ::mt::EmAudFormat TAudEncStatistic::aud_enc_type() const {
  return static_cast< ::mt::EmAudFormat >(aud_enc_type_);
}
inline void TAudEncStatistic::set_aud_enc_type(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_aud_enc_type();
  aud_enc_type_ = value;
}

// optional bool Audio_Enc_Start = 5;
inline bool TAudEncStatistic::has_audio_enc_start() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TAudEncStatistic::set_has_audio_enc_start() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TAudEncStatistic::clear_has_audio_enc_start() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TAudEncStatistic::clear_audio_enc_start() {
  audio_enc_start_ = false;
  clear_has_audio_enc_start();
}
inline bool TAudEncStatistic::audio_enc_start() const {
  return audio_enc_start_;
}
inline void TAudEncStatistic::set_audio_enc_start(bool value) {
  set_has_audio_enc_start();
  audio_enc_start_ = value;
}

// optional .mt.EmAacChnlNum aac_chnl_num = 6;
inline bool TAudEncStatistic::has_aac_chnl_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TAudEncStatistic::set_has_aac_chnl_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TAudEncStatistic::clear_has_aac_chnl_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TAudEncStatistic::clear_aac_chnl_num() {
  aac_chnl_num_ = 0;
  clear_has_aac_chnl_num();
}
inline ::mt::EmAacChnlNum TAudEncStatistic::aac_chnl_num() const {
  return static_cast< ::mt::EmAacChnlNum >(aac_chnl_num_);
}
inline void TAudEncStatistic::set_aac_chnl_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_aac_chnl_num();
  aac_chnl_num_ = value;
}

// -------------------------------------------------------------------

// TAudDecStatistic

// optional .mt.EmCodecComponent type = 1;
inline bool TAudDecStatistic::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAudDecStatistic::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAudDecStatistic::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAudDecStatistic::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmCodecComponent TAudDecStatistic::type() const {
  return static_cast< ::mt::EmCodecComponent >(type_);
}
inline void TAudDecStatistic::set_type(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mt.EmCodecComponentIndex aud_dec_id = 2;
inline bool TAudDecStatistic::has_aud_dec_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAudDecStatistic::set_has_aud_dec_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAudDecStatistic::clear_has_aud_dec_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAudDecStatistic::clear_aud_dec_id() {
  aud_dec_id_ = 0;
  clear_has_aud_dec_id();
}
inline ::mt::EmCodecComponentIndex TAudDecStatistic::aud_dec_id() const {
  return static_cast< ::mt::EmCodecComponentIndex >(aud_dec_id_);
}
inline void TAudDecStatistic::set_aud_dec_id(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_aud_dec_id();
  aud_dec_id_ = value;
}

// optional uint32 dec_bitrate = 3;
inline bool TAudDecStatistic::has_dec_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAudDecStatistic::set_has_dec_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAudDecStatistic::clear_has_dec_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAudDecStatistic::clear_dec_bitrate() {
  dec_bitrate_ = 0u;
  clear_has_dec_bitrate();
}
inline ::google::protobuf::uint32 TAudDecStatistic::dec_bitrate() const {
  return dec_bitrate_;
}
inline void TAudDecStatistic::set_dec_bitrate(::google::protobuf::uint32 value) {
  set_has_dec_bitrate();
  dec_bitrate_ = value;
}

// optional uint32 rcved_frames = 4;
inline bool TAudDecStatistic::has_rcved_frames() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAudDecStatistic::set_has_rcved_frames() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAudDecStatistic::clear_has_rcved_frames() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAudDecStatistic::clear_rcved_frames() {
  rcved_frames_ = 0u;
  clear_has_rcved_frames();
}
inline ::google::protobuf::uint32 TAudDecStatistic::rcved_frames() const {
  return rcved_frames_;
}
inline void TAudDecStatistic::set_rcved_frames(::google::protobuf::uint32 value) {
  set_has_rcved_frames();
  rcved_frames_ = value;
}

// optional uint32 lost_pack_ratio = 5;
inline bool TAudDecStatistic::has_lost_pack_ratio() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TAudDecStatistic::set_has_lost_pack_ratio() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TAudDecStatistic::clear_has_lost_pack_ratio() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TAudDecStatistic::clear_lost_pack_ratio() {
  lost_pack_ratio_ = 0u;
  clear_has_lost_pack_ratio();
}
inline ::google::protobuf::uint32 TAudDecStatistic::lost_pack_ratio() const {
  return lost_pack_ratio_;
}
inline void TAudDecStatistic::set_lost_pack_ratio(::google::protobuf::uint32 value) {
  set_has_lost_pack_ratio();
  lost_pack_ratio_ = value;
}

// optional uint32 physical_lost_pack_ratio = 6;
inline bool TAudDecStatistic::has_physical_lost_pack_ratio() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TAudDecStatistic::set_has_physical_lost_pack_ratio() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TAudDecStatistic::clear_has_physical_lost_pack_ratio() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TAudDecStatistic::clear_physical_lost_pack_ratio() {
  physical_lost_pack_ratio_ = 0u;
  clear_has_physical_lost_pack_ratio();
}
inline ::google::protobuf::uint32 TAudDecStatistic::physical_lost_pack_ratio() const {
  return physical_lost_pack_ratio_;
}
inline void TAudDecStatistic::set_physical_lost_pack_ratio(::google::protobuf::uint32 value) {
  set_has_physical_lost_pack_ratio();
  physical_lost_pack_ratio_ = value;
}

// optional uint32 lost_packs = 7;
inline bool TAudDecStatistic::has_lost_packs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TAudDecStatistic::set_has_lost_packs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TAudDecStatistic::clear_has_lost_packs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TAudDecStatistic::clear_lost_packs() {
  lost_packs_ = 0u;
  clear_has_lost_packs();
}
inline ::google::protobuf::uint32 TAudDecStatistic::lost_packs() const {
  return lost_packs_;
}
inline void TAudDecStatistic::set_lost_packs(::google::protobuf::uint32 value) {
  set_has_lost_packs();
  lost_packs_ = value;
}

// optional .mt.EmAudFormat aud_dec_type = 8;
inline bool TAudDecStatistic::has_aud_dec_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TAudDecStatistic::set_has_aud_dec_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TAudDecStatistic::clear_has_aud_dec_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TAudDecStatistic::clear_aud_dec_type() {
  aud_dec_type_ = 0;
  clear_has_aud_dec_type();
}
inline ::mt::EmAudFormat TAudDecStatistic::aud_dec_type() const {
  return static_cast< ::mt::EmAudFormat >(aud_dec_type_);
}
inline void TAudDecStatistic::set_aud_dec_type(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_aud_dec_type();
  aud_dec_type_ = value;
}

// optional bool Audio_Dec_Start = 9;
inline bool TAudDecStatistic::has_audio_dec_start() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TAudDecStatistic::set_has_audio_dec_start() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TAudDecStatistic::clear_has_audio_dec_start() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TAudDecStatistic::clear_audio_dec_start() {
  audio_dec_start_ = false;
  clear_has_audio_dec_start();
}
inline bool TAudDecStatistic::audio_dec_start() const {
  return audio_dec_start_;
}
inline void TAudDecStatistic::set_audio_dec_start(bool value) {
  set_has_audio_dec_start();
  audio_dec_start_ = value;
}

// optional .mt.EmAudFormat audchan_dec_type = 10;
inline bool TAudDecStatistic::has_audchan_dec_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TAudDecStatistic::set_has_audchan_dec_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TAudDecStatistic::clear_has_audchan_dec_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TAudDecStatistic::clear_audchan_dec_type() {
  audchan_dec_type_ = 0;
  clear_has_audchan_dec_type();
}
inline ::mt::EmAudFormat TAudDecStatistic::audchan_dec_type() const {
  return static_cast< ::mt::EmAudFormat >(audchan_dec_type_);
}
inline void TAudDecStatistic::set_audchan_dec_type(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_audchan_dec_type();
  audchan_dec_type_ = value;
}

// optional .mt.EmAacChnlNum aac_chnl_num = 11;
inline bool TAudDecStatistic::has_aac_chnl_num() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TAudDecStatistic::set_has_aac_chnl_num() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TAudDecStatistic::clear_has_aac_chnl_num() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TAudDecStatistic::clear_aac_chnl_num() {
  aac_chnl_num_ = 0;
  clear_has_aac_chnl_num();
}
inline ::mt::EmAacChnlNum TAudDecStatistic::aac_chnl_num() const {
  return static_cast< ::mt::EmAacChnlNum >(aac_chnl_num_);
}
inline void TAudDecStatistic::set_aac_chnl_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_aac_chnl_num();
  aac_chnl_num_ = value;
}

// -------------------------------------------------------------------

// TVidEncStatistic

// optional .mt.EmCodecComponent type = 1;
inline bool TVidEncStatistic::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVidEncStatistic::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVidEncStatistic::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVidEncStatistic::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmCodecComponent TVidEncStatistic::type() const {
  return static_cast< ::mt::EmCodecComponent >(type_);
}
inline void TVidEncStatistic::set_type(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mt.EmCodecComponentIndex vid_enc_id = 2;
inline bool TVidEncStatistic::has_vid_enc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVidEncStatistic::set_has_vid_enc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVidEncStatistic::clear_has_vid_enc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVidEncStatistic::clear_vid_enc_id() {
  vid_enc_id_ = 0;
  clear_has_vid_enc_id();
}
inline ::mt::EmCodecComponentIndex TVidEncStatistic::vid_enc_id() const {
  return static_cast< ::mt::EmCodecComponentIndex >(vid_enc_id_);
}
inline void TVidEncStatistic::set_vid_enc_id(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_vid_enc_id();
  vid_enc_id_ = value;
}

// optional uint32 enc_bitrate = 3;
inline bool TVidEncStatistic::has_enc_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVidEncStatistic::set_has_enc_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVidEncStatistic::clear_has_enc_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVidEncStatistic::clear_enc_bitrate() {
  enc_bitrate_ = 0u;
  clear_has_enc_bitrate();
}
inline ::google::protobuf::uint32 TVidEncStatistic::enc_bitrate() const {
  return enc_bitrate_;
}
inline void TVidEncStatistic::set_enc_bitrate(::google::protobuf::uint32 value) {
  set_has_enc_bitrate();
  enc_bitrate_ = value;
}

// optional uint32 frame_rate = 4;
inline bool TVidEncStatistic::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVidEncStatistic::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVidEncStatistic::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVidEncStatistic::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TVidEncStatistic::frame_rate() const {
  return frame_rate_;
}
inline void TVidEncStatistic::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// optional uint32 vid_width = 5;
inline bool TVidEncStatistic::has_vid_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVidEncStatistic::set_has_vid_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVidEncStatistic::clear_has_vid_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVidEncStatistic::clear_vid_width() {
  vid_width_ = 0u;
  clear_has_vid_width();
}
inline ::google::protobuf::uint32 TVidEncStatistic::vid_width() const {
  return vid_width_;
}
inline void TVidEncStatistic::set_vid_width(::google::protobuf::uint32 value) {
  set_has_vid_width();
  vid_width_ = value;
}

// optional uint32 vid_height = 6;
inline bool TVidEncStatistic::has_vid_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVidEncStatistic::set_has_vid_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVidEncStatistic::clear_has_vid_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVidEncStatistic::clear_vid_height() {
  vid_height_ = 0u;
  clear_has_vid_height();
}
inline ::google::protobuf::uint32 TVidEncStatistic::vid_height() const {
  return vid_height_;
}
inline void TVidEncStatistic::set_vid_height(::google::protobuf::uint32 value) {
  set_has_vid_height();
  vid_height_ = value;
}

// optional .mt.EmVidFormat vid_enc_type = 7;
inline bool TVidEncStatistic::has_vid_enc_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVidEncStatistic::set_has_vid_enc_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVidEncStatistic::clear_has_vid_enc_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVidEncStatistic::clear_vid_enc_type() {
  vid_enc_type_ = 0;
  clear_has_vid_enc_type();
}
inline ::mt::EmVidFormat TVidEncStatistic::vid_enc_type() const {
  return static_cast< ::mt::EmVidFormat >(vid_enc_type_);
}
inline void TVidEncStatistic::set_vid_enc_type(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_vid_enc_type();
  vid_enc_type_ = value;
}

// optional bool Video_Enc_Start = 8;
inline bool TVidEncStatistic::has_video_enc_start() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TVidEncStatistic::set_has_video_enc_start() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TVidEncStatistic::clear_has_video_enc_start() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TVidEncStatistic::clear_video_enc_start() {
  video_enc_start_ = false;
  clear_has_video_enc_start();
}
inline bool TVidEncStatistic::video_enc_start() const {
  return video_enc_start_;
}
inline void TVidEncStatistic::set_video_enc_start(bool value) {
  set_has_video_enc_start();
  video_enc_start_ = value;
}

// optional .mt.EmH264Profile h264_profile = 9;
inline bool TVidEncStatistic::has_h264_profile() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TVidEncStatistic::set_has_h264_profile() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TVidEncStatistic::clear_has_h264_profile() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TVidEncStatistic::clear_h264_profile() {
  h264_profile_ = 0;
  clear_has_h264_profile();
}
inline ::mt::EmH264Profile TVidEncStatistic::h264_profile() const {
  return static_cast< ::mt::EmH264Profile >(h264_profile_);
}
inline void TVidEncStatistic::set_h264_profile(::mt::EmH264Profile value) {
  assert(::mt::EmH264Profile_IsValid(value));
  set_has_h264_profile();
  h264_profile_ = value;
}

// optional bool video_resource_exist = 10;
inline bool TVidEncStatistic::has_video_resource_exist() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TVidEncStatistic::set_has_video_resource_exist() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TVidEncStatistic::clear_has_video_resource_exist() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TVidEncStatistic::clear_video_resource_exist() {
  video_resource_exist_ = false;
  clear_has_video_resource_exist();
}
inline bool TVidEncStatistic::video_resource_exist() const {
  return video_resource_exist_;
}
inline void TVidEncStatistic::set_video_resource_exist(bool value) {
  set_has_video_resource_exist();
  video_resource_exist_ = value;
}

// -------------------------------------------------------------------

// TVidDecStatistic

// optional .mt.EmCodecComponent type = 1;
inline bool TVidDecStatistic::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVidDecStatistic::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVidDecStatistic::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVidDecStatistic::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmCodecComponent TVidDecStatistic::type() const {
  return static_cast< ::mt::EmCodecComponent >(type_);
}
inline void TVidDecStatistic::set_type(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mt.EmCodecComponentIndex vid_dec_id = 2;
inline bool TVidDecStatistic::has_vid_dec_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVidDecStatistic::set_has_vid_dec_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVidDecStatistic::clear_has_vid_dec_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVidDecStatistic::clear_vid_dec_id() {
  vid_dec_id_ = 0;
  clear_has_vid_dec_id();
}
inline ::mt::EmCodecComponentIndex TVidDecStatistic::vid_dec_id() const {
  return static_cast< ::mt::EmCodecComponentIndex >(vid_dec_id_);
}
inline void TVidDecStatistic::set_vid_dec_id(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_vid_dec_id();
  vid_dec_id_ = value;
}

// optional uint32 dec_bitrate = 3;
inline bool TVidDecStatistic::has_dec_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVidDecStatistic::set_has_dec_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVidDecStatistic::clear_has_dec_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVidDecStatistic::clear_dec_bitrate() {
  dec_bitrate_ = 0u;
  clear_has_dec_bitrate();
}
inline ::google::protobuf::uint32 TVidDecStatistic::dec_bitrate() const {
  return dec_bitrate_;
}
inline void TVidDecStatistic::set_dec_bitrate(::google::protobuf::uint32 value) {
  set_has_dec_bitrate();
  dec_bitrate_ = value;
}

// optional uint32 rcved_frames = 4;
inline bool TVidDecStatistic::has_rcved_frames() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVidDecStatistic::set_has_rcved_frames() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVidDecStatistic::clear_has_rcved_frames() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVidDecStatistic::clear_rcved_frames() {
  rcved_frames_ = 0u;
  clear_has_rcved_frames();
}
inline ::google::protobuf::uint32 TVidDecStatistic::rcved_frames() const {
  return rcved_frames_;
}
inline void TVidDecStatistic::set_rcved_frames(::google::protobuf::uint32 value) {
  set_has_rcved_frames();
  rcved_frames_ = value;
}

// optional uint32 lost_pack_ratio = 5;
inline bool TVidDecStatistic::has_lost_pack_ratio() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVidDecStatistic::set_has_lost_pack_ratio() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVidDecStatistic::clear_has_lost_pack_ratio() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVidDecStatistic::clear_lost_pack_ratio() {
  lost_pack_ratio_ = 0u;
  clear_has_lost_pack_ratio();
}
inline ::google::protobuf::uint32 TVidDecStatistic::lost_pack_ratio() const {
  return lost_pack_ratio_;
}
inline void TVidDecStatistic::set_lost_pack_ratio(::google::protobuf::uint32 value) {
  set_has_lost_pack_ratio();
  lost_pack_ratio_ = value;
}

// optional uint32 physical_lost_pack_ratio = 6;
inline bool TVidDecStatistic::has_physical_lost_pack_ratio() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVidDecStatistic::set_has_physical_lost_pack_ratio() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVidDecStatistic::clear_has_physical_lost_pack_ratio() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVidDecStatistic::clear_physical_lost_pack_ratio() {
  physical_lost_pack_ratio_ = 0u;
  clear_has_physical_lost_pack_ratio();
}
inline ::google::protobuf::uint32 TVidDecStatistic::physical_lost_pack_ratio() const {
  return physical_lost_pack_ratio_;
}
inline void TVidDecStatistic::set_physical_lost_pack_ratio(::google::protobuf::uint32 value) {
  set_has_physical_lost_pack_ratio();
  physical_lost_pack_ratio_ = value;
}

// optional uint32 lost_packs = 7;
inline bool TVidDecStatistic::has_lost_packs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVidDecStatistic::set_has_lost_packs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVidDecStatistic::clear_has_lost_packs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVidDecStatistic::clear_lost_packs() {
  lost_packs_ = 0u;
  clear_has_lost_packs();
}
inline ::google::protobuf::uint32 TVidDecStatistic::lost_packs() const {
  return lost_packs_;
}
inline void TVidDecStatistic::set_lost_packs(::google::protobuf::uint32 value) {
  set_has_lost_packs();
  lost_packs_ = value;
}

// optional uint32 frame_rate = 8;
inline bool TVidDecStatistic::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TVidDecStatistic::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TVidDecStatistic::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TVidDecStatistic::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TVidDecStatistic::frame_rate() const {
  return frame_rate_;
}
inline void TVidDecStatistic::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// optional uint32 vid_width = 9;
inline bool TVidDecStatistic::has_vid_width() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TVidDecStatistic::set_has_vid_width() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TVidDecStatistic::clear_has_vid_width() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TVidDecStatistic::clear_vid_width() {
  vid_width_ = 0u;
  clear_has_vid_width();
}
inline ::google::protobuf::uint32 TVidDecStatistic::vid_width() const {
  return vid_width_;
}
inline void TVidDecStatistic::set_vid_width(::google::protobuf::uint32 value) {
  set_has_vid_width();
  vid_width_ = value;
}

// optional uint32 vid_height = 10;
inline bool TVidDecStatistic::has_vid_height() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TVidDecStatistic::set_has_vid_height() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TVidDecStatistic::clear_has_vid_height() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TVidDecStatistic::clear_vid_height() {
  vid_height_ = 0u;
  clear_has_vid_height();
}
inline ::google::protobuf::uint32 TVidDecStatistic::vid_height() const {
  return vid_height_;
}
inline void TVidDecStatistic::set_vid_height(::google::protobuf::uint32 value) {
  set_has_vid_height();
  vid_height_ = value;
}

// optional .mt.EmVidFormat vid_dec_type = 11;
inline bool TVidDecStatistic::has_vid_dec_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TVidDecStatistic::set_has_vid_dec_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TVidDecStatistic::clear_has_vid_dec_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TVidDecStatistic::clear_vid_dec_type() {
  vid_dec_type_ = 0;
  clear_has_vid_dec_type();
}
inline ::mt::EmVidFormat TVidDecStatistic::vid_dec_type() const {
  return static_cast< ::mt::EmVidFormat >(vid_dec_type_);
}
inline void TVidDecStatistic::set_vid_dec_type(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_vid_dec_type();
  vid_dec_type_ = value;
}

// optional bool Video_Dec_Start = 12;
inline bool TVidDecStatistic::has_video_dec_start() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TVidDecStatistic::set_has_video_dec_start() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TVidDecStatistic::clear_has_video_dec_start() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TVidDecStatistic::clear_video_dec_start() {
  video_dec_start_ = false;
  clear_has_video_dec_start();
}
inline bool TVidDecStatistic::video_dec_start() const {
  return video_dec_start_;
}
inline void TVidDecStatistic::set_video_dec_start(bool value) {
  set_has_video_dec_start();
  video_dec_start_ = value;
}

// optional .mt.EmH264Profile h264_profile = 13;
inline bool TVidDecStatistic::has_h264_profile() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TVidDecStatistic::set_has_h264_profile() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TVidDecStatistic::clear_has_h264_profile() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TVidDecStatistic::clear_h264_profile() {
  h264_profile_ = 0;
  clear_has_h264_profile();
}
inline ::mt::EmH264Profile TVidDecStatistic::h264_profile() const {
  return static_cast< ::mt::EmH264Profile >(h264_profile_);
}
inline void TVidDecStatistic::set_h264_profile(::mt::EmH264Profile value) {
  assert(::mt::EmH264Profile_IsValid(value));
  set_has_h264_profile();
  h264_profile_ = value;
}

// -------------------------------------------------------------------

// TAudMixStatistic

// optional .mt.EmCodecComponent type = 1;
inline bool TAudMixStatistic::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAudMixStatistic::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAudMixStatistic::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAudMixStatistic::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmCodecComponent TAudMixStatistic::type() const {
  return static_cast< ::mt::EmCodecComponent >(type_);
}
inline void TAudMixStatistic::set_type(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mt.EmCodecComponentIndex aud_mix_id = 2;
inline bool TAudMixStatistic::has_aud_mix_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAudMixStatistic::set_has_aud_mix_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAudMixStatistic::clear_has_aud_mix_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAudMixStatistic::clear_aud_mix_id() {
  aud_mix_id_ = 0;
  clear_has_aud_mix_id();
}
inline ::mt::EmCodecComponentIndex TAudMixStatistic::aud_mix_id() const {
  return static_cast< ::mt::EmCodecComponentIndex >(aud_mix_id_);
}
inline void TAudMixStatistic::set_aud_mix_id(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_aud_mix_id();
  aud_mix_id_ = value;
}

// -------------------------------------------------------------------

// TVidMixStatistic

// optional .mt.EmCodecComponent type = 1;
inline bool TVidMixStatistic::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVidMixStatistic::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVidMixStatistic::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVidMixStatistic::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmCodecComponent TVidMixStatistic::type() const {
  return static_cast< ::mt::EmCodecComponent >(type_);
}
inline void TVidMixStatistic::set_type(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mt.EmCodecComponentIndex vid_mix_id = 2;
inline bool TVidMixStatistic::has_vid_mix_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVidMixStatistic::set_has_vid_mix_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVidMixStatistic::clear_has_vid_mix_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVidMixStatistic::clear_vid_mix_id() {
  vid_mix_id_ = 0;
  clear_has_vid_mix_id();
}
inline ::mt::EmCodecComponentIndex TVidMixStatistic::vid_mix_id() const {
  return static_cast< ::mt::EmCodecComponentIndex >(vid_mix_id_);
}
inline void TVidMixStatistic::set_vid_mix_id(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_vid_mix_id();
  vid_mix_id_ = value;
}

// -------------------------------------------------------------------

// TMtBweReceiver

// optional uint32 ssrc = 1;
inline bool TMtBweReceiver::has_ssrc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtBweReceiver::set_has_ssrc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtBweReceiver::clear_has_ssrc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtBweReceiver::clear_ssrc() {
  ssrc_ = 0u;
  clear_has_ssrc();
}
inline ::google::protobuf::uint32 TMtBweReceiver::ssrc() const {
  return ssrc_;
}
inline void TMtBweReceiver::set_ssrc(::google::protobuf::uint32 value) {
  set_has_ssrc();
  ssrc_ = value;
}

// optional bool is_enable = 2;
inline bool TMtBweReceiver::has_is_enable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtBweReceiver::set_has_is_enable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtBweReceiver::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtBweReceiver::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMtBweReceiver::is_enable() const {
  return is_enable_;
}
inline void TMtBweReceiver::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// optional uint32 qwid = 3;
inline bool TMtBweReceiver::has_qwid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtBweReceiver::set_has_qwid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtBweReceiver::clear_has_qwid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtBweReceiver::clear_qwid() {
  qwid_ = 0u;
  clear_has_qwid();
}
inline ::google::protobuf::uint32 TMtBweReceiver::qwid() const {
  return qwid_;
}
inline void TMtBweReceiver::set_qwid(::google::protobuf::uint32 value) {
  set_has_qwid();
  qwid_ = value;
}

// optional uint32 group_id = 4;
inline bool TMtBweReceiver::has_group_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtBweReceiver::set_has_group_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtBweReceiver::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtBweReceiver::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 TMtBweReceiver::group_id() const {
  return group_id_;
}
inline void TMtBweReceiver::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional uint32 bitrate = 5;
inline bool TMtBweReceiver::has_bitrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtBweReceiver::set_has_bitrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtBweReceiver::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtBweReceiver::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMtBweReceiver::bitrate() const {
  return bitrate_;
}
inline void TMtBweReceiver::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// -------------------------------------------------------------------

// TVidBweStatus

// optional .mt.EmCodecComponent type = 1;
inline bool TVidBweStatus::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVidBweStatus::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVidBweStatus::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVidBweStatus::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmCodecComponent TVidBweStatus::type() const {
  return static_cast< ::mt::EmCodecComponent >(type_);
}
inline void TVidBweStatus::set_type(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mt.EmCodecComponentIndex vid_enc_id = 2;
inline bool TVidBweStatus::has_vid_enc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVidBweStatus::set_has_vid_enc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVidBweStatus::clear_has_vid_enc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVidBweStatus::clear_vid_enc_id() {
  vid_enc_id_ = 0;
  clear_has_vid_enc_id();
}
inline ::mt::EmCodecComponentIndex TVidBweStatus::vid_enc_id() const {
  return static_cast< ::mt::EmCodecComponentIndex >(vid_enc_id_);
}
inline void TVidBweStatus::set_vid_enc_id(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_vid_enc_id();
  vid_enc_id_ = value;
}

// repeated .mt.TMtBweReceiver receiver = 3;
inline int TVidBweStatus::receiver_size() const {
  return receiver_.size();
}
inline void TVidBweStatus::clear_receiver() {
  receiver_.Clear();
}
inline const ::mt::TMtBweReceiver& TVidBweStatus::receiver(int index) const {
  return receiver_.Get(index);
}
inline ::mt::TMtBweReceiver* TVidBweStatus::mutable_receiver(int index) {
  return receiver_.Mutable(index);
}
inline ::mt::TMtBweReceiver* TVidBweStatus::add_receiver() {
  return receiver_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtBweReceiver >&
TVidBweStatus::receiver() const {
  return receiver_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtBweReceiver >*
TVidBweStatus::mutable_receiver() {
  return &receiver_;
}

// optional uint32 revision = 4;
inline bool TVidBweStatus::has_revision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVidBweStatus::set_has_revision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVidBweStatus::clear_has_revision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVidBweStatus::clear_revision() {
  revision_ = 0u;
  clear_has_revision();
}
inline ::google::protobuf::uint32 TVidBweStatus::revision() const {
  return revision_;
}
inline void TVidBweStatus::set_revision(::google::protobuf::uint32 value) {
  set_has_revision();
  revision_ = value;
}

// -------------------------------------------------------------------

// TCodecBweStatus

// repeated .mt.TVidBweStatus main_vid_enc_status = 1;
inline int TCodecBweStatus::main_vid_enc_status_size() const {
  return main_vid_enc_status_.size();
}
inline void TCodecBweStatus::clear_main_vid_enc_status() {
  main_vid_enc_status_.Clear();
}
inline const ::mt::TVidBweStatus& TCodecBweStatus::main_vid_enc_status(int index) const {
  return main_vid_enc_status_.Get(index);
}
inline ::mt::TVidBweStatus* TCodecBweStatus::mutable_main_vid_enc_status(int index) {
  return main_vid_enc_status_.Mutable(index);
}
inline ::mt::TVidBweStatus* TCodecBweStatus::add_main_vid_enc_status() {
  return main_vid_enc_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidBweStatus >&
TCodecBweStatus::main_vid_enc_status() const {
  return main_vid_enc_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidBweStatus >*
TCodecBweStatus::mutable_main_vid_enc_status() {
  return &main_vid_enc_status_;
}

// repeated .mt.TVidBweStatus ass_vid_enc_status = 2;
inline int TCodecBweStatus::ass_vid_enc_status_size() const {
  return ass_vid_enc_status_.size();
}
inline void TCodecBweStatus::clear_ass_vid_enc_status() {
  ass_vid_enc_status_.Clear();
}
inline const ::mt::TVidBweStatus& TCodecBweStatus::ass_vid_enc_status(int index) const {
  return ass_vid_enc_status_.Get(index);
}
inline ::mt::TVidBweStatus* TCodecBweStatus::mutable_ass_vid_enc_status(int index) {
  return ass_vid_enc_status_.Mutable(index);
}
inline ::mt::TVidBweStatus* TCodecBweStatus::add_ass_vid_enc_status() {
  return ass_vid_enc_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidBweStatus >&
TCodecBweStatus::ass_vid_enc_status() const {
  return ass_vid_enc_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidBweStatus >*
TCodecBweStatus::mutable_ass_vid_enc_status() {
  return &ass_vid_enc_status_;
}

// -------------------------------------------------------------------

// TCodecStatistic

// repeated .mt.TAudEncStatistic main_aud_enc_static = 1;
inline int TCodecStatistic::main_aud_enc_static_size() const {
  return main_aud_enc_static_.size();
}
inline void TCodecStatistic::clear_main_aud_enc_static() {
  main_aud_enc_static_.Clear();
}
inline const ::mt::TAudEncStatistic& TCodecStatistic::main_aud_enc_static(int index) const {
  return main_aud_enc_static_.Get(index);
}
inline ::mt::TAudEncStatistic* TCodecStatistic::mutable_main_aud_enc_static(int index) {
  return main_aud_enc_static_.Mutable(index);
}
inline ::mt::TAudEncStatistic* TCodecStatistic::add_main_aud_enc_static() {
  return main_aud_enc_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudEncStatistic >&
TCodecStatistic::main_aud_enc_static() const {
  return main_aud_enc_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudEncStatistic >*
TCodecStatistic::mutable_main_aud_enc_static() {
  return &main_aud_enc_static_;
}

// repeated .mt.TAudEncStatistic ass_aud_enc_static = 2;
inline int TCodecStatistic::ass_aud_enc_static_size() const {
  return ass_aud_enc_static_.size();
}
inline void TCodecStatistic::clear_ass_aud_enc_static() {
  ass_aud_enc_static_.Clear();
}
inline const ::mt::TAudEncStatistic& TCodecStatistic::ass_aud_enc_static(int index) const {
  return ass_aud_enc_static_.Get(index);
}
inline ::mt::TAudEncStatistic* TCodecStatistic::mutable_ass_aud_enc_static(int index) {
  return ass_aud_enc_static_.Mutable(index);
}
inline ::mt::TAudEncStatistic* TCodecStatistic::add_ass_aud_enc_static() {
  return ass_aud_enc_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudEncStatistic >&
TCodecStatistic::ass_aud_enc_static() const {
  return ass_aud_enc_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudEncStatistic >*
TCodecStatistic::mutable_ass_aud_enc_static() {
  return &ass_aud_enc_static_;
}

// repeated .mt.TAudDecStatistic main_aud_dec_static = 3;
inline int TCodecStatistic::main_aud_dec_static_size() const {
  return main_aud_dec_static_.size();
}
inline void TCodecStatistic::clear_main_aud_dec_static() {
  main_aud_dec_static_.Clear();
}
inline const ::mt::TAudDecStatistic& TCodecStatistic::main_aud_dec_static(int index) const {
  return main_aud_dec_static_.Get(index);
}
inline ::mt::TAudDecStatistic* TCodecStatistic::mutable_main_aud_dec_static(int index) {
  return main_aud_dec_static_.Mutable(index);
}
inline ::mt::TAudDecStatistic* TCodecStatistic::add_main_aud_dec_static() {
  return main_aud_dec_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudDecStatistic >&
TCodecStatistic::main_aud_dec_static() const {
  return main_aud_dec_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudDecStatistic >*
TCodecStatistic::mutable_main_aud_dec_static() {
  return &main_aud_dec_static_;
}

// repeated .mt.TAudDecStatistic ass_aud_dec_static = 4;
inline int TCodecStatistic::ass_aud_dec_static_size() const {
  return ass_aud_dec_static_.size();
}
inline void TCodecStatistic::clear_ass_aud_dec_static() {
  ass_aud_dec_static_.Clear();
}
inline const ::mt::TAudDecStatistic& TCodecStatistic::ass_aud_dec_static(int index) const {
  return ass_aud_dec_static_.Get(index);
}
inline ::mt::TAudDecStatistic* TCodecStatistic::mutable_ass_aud_dec_static(int index) {
  return ass_aud_dec_static_.Mutable(index);
}
inline ::mt::TAudDecStatistic* TCodecStatistic::add_ass_aud_dec_static() {
  return ass_aud_dec_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudDecStatistic >&
TCodecStatistic::ass_aud_dec_static() const {
  return ass_aud_dec_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudDecStatistic >*
TCodecStatistic::mutable_ass_aud_dec_static() {
  return &ass_aud_dec_static_;
}

// repeated .mt.TVidEncStatistic main_vid_enc_static = 5;
inline int TCodecStatistic::main_vid_enc_static_size() const {
  return main_vid_enc_static_.size();
}
inline void TCodecStatistic::clear_main_vid_enc_static() {
  main_vid_enc_static_.Clear();
}
inline const ::mt::TVidEncStatistic& TCodecStatistic::main_vid_enc_static(int index) const {
  return main_vid_enc_static_.Get(index);
}
inline ::mt::TVidEncStatistic* TCodecStatistic::mutable_main_vid_enc_static(int index) {
  return main_vid_enc_static_.Mutable(index);
}
inline ::mt::TVidEncStatistic* TCodecStatistic::add_main_vid_enc_static() {
  return main_vid_enc_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidEncStatistic >&
TCodecStatistic::main_vid_enc_static() const {
  return main_vid_enc_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidEncStatistic >*
TCodecStatistic::mutable_main_vid_enc_static() {
  return &main_vid_enc_static_;
}

// repeated .mt.TVidEncStatistic ass_vid_enc_static = 6;
inline int TCodecStatistic::ass_vid_enc_static_size() const {
  return ass_vid_enc_static_.size();
}
inline void TCodecStatistic::clear_ass_vid_enc_static() {
  ass_vid_enc_static_.Clear();
}
inline const ::mt::TVidEncStatistic& TCodecStatistic::ass_vid_enc_static(int index) const {
  return ass_vid_enc_static_.Get(index);
}
inline ::mt::TVidEncStatistic* TCodecStatistic::mutable_ass_vid_enc_static(int index) {
  return ass_vid_enc_static_.Mutable(index);
}
inline ::mt::TVidEncStatistic* TCodecStatistic::add_ass_vid_enc_static() {
  return ass_vid_enc_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidEncStatistic >&
TCodecStatistic::ass_vid_enc_static() const {
  return ass_vid_enc_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidEncStatistic >*
TCodecStatistic::mutable_ass_vid_enc_static() {
  return &ass_vid_enc_static_;
}

// repeated .mt.TVidDecStatistic main_vid_dec_static = 7;
inline int TCodecStatistic::main_vid_dec_static_size() const {
  return main_vid_dec_static_.size();
}
inline void TCodecStatistic::clear_main_vid_dec_static() {
  main_vid_dec_static_.Clear();
}
inline const ::mt::TVidDecStatistic& TCodecStatistic::main_vid_dec_static(int index) const {
  return main_vid_dec_static_.Get(index);
}
inline ::mt::TVidDecStatistic* TCodecStatistic::mutable_main_vid_dec_static(int index) {
  return main_vid_dec_static_.Mutable(index);
}
inline ::mt::TVidDecStatistic* TCodecStatistic::add_main_vid_dec_static() {
  return main_vid_dec_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidDecStatistic >&
TCodecStatistic::main_vid_dec_static() const {
  return main_vid_dec_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidDecStatistic >*
TCodecStatistic::mutable_main_vid_dec_static() {
  return &main_vid_dec_static_;
}

// repeated .mt.TVidDecStatistic ass_vid_dec_static = 8;
inline int TCodecStatistic::ass_vid_dec_static_size() const {
  return ass_vid_dec_static_.size();
}
inline void TCodecStatistic::clear_ass_vid_dec_static() {
  ass_vid_dec_static_.Clear();
}
inline const ::mt::TVidDecStatistic& TCodecStatistic::ass_vid_dec_static(int index) const {
  return ass_vid_dec_static_.Get(index);
}
inline ::mt::TVidDecStatistic* TCodecStatistic::mutable_ass_vid_dec_static(int index) {
  return ass_vid_dec_static_.Mutable(index);
}
inline ::mt::TVidDecStatistic* TCodecStatistic::add_ass_vid_dec_static() {
  return ass_vid_dec_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidDecStatistic >&
TCodecStatistic::ass_vid_dec_static() const {
  return ass_vid_dec_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidDecStatistic >*
TCodecStatistic::mutable_ass_vid_dec_static() {
  return &ass_vid_dec_static_;
}

// repeated .mt.TAudMixStatistic main_aud_mix_static = 9;
inline int TCodecStatistic::main_aud_mix_static_size() const {
  return main_aud_mix_static_.size();
}
inline void TCodecStatistic::clear_main_aud_mix_static() {
  main_aud_mix_static_.Clear();
}
inline const ::mt::TAudMixStatistic& TCodecStatistic::main_aud_mix_static(int index) const {
  return main_aud_mix_static_.Get(index);
}
inline ::mt::TAudMixStatistic* TCodecStatistic::mutable_main_aud_mix_static(int index) {
  return main_aud_mix_static_.Mutable(index);
}
inline ::mt::TAudMixStatistic* TCodecStatistic::add_main_aud_mix_static() {
  return main_aud_mix_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudMixStatistic >&
TCodecStatistic::main_aud_mix_static() const {
  return main_aud_mix_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudMixStatistic >*
TCodecStatistic::mutable_main_aud_mix_static() {
  return &main_aud_mix_static_;
}

// repeated .mt.TAudMixStatistic ass_aud_mix_static = 10;
inline int TCodecStatistic::ass_aud_mix_static_size() const {
  return ass_aud_mix_static_.size();
}
inline void TCodecStatistic::clear_ass_aud_mix_static() {
  ass_aud_mix_static_.Clear();
}
inline const ::mt::TAudMixStatistic& TCodecStatistic::ass_aud_mix_static(int index) const {
  return ass_aud_mix_static_.Get(index);
}
inline ::mt::TAudMixStatistic* TCodecStatistic::mutable_ass_aud_mix_static(int index) {
  return ass_aud_mix_static_.Mutable(index);
}
inline ::mt::TAudMixStatistic* TCodecStatistic::add_ass_aud_mix_static() {
  return ass_aud_mix_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudMixStatistic >&
TCodecStatistic::ass_aud_mix_static() const {
  return ass_aud_mix_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudMixStatistic >*
TCodecStatistic::mutable_ass_aud_mix_static() {
  return &ass_aud_mix_static_;
}

// repeated .mt.TVidMixStatistic main_vid_mix_static = 11;
inline int TCodecStatistic::main_vid_mix_static_size() const {
  return main_vid_mix_static_.size();
}
inline void TCodecStatistic::clear_main_vid_mix_static() {
  main_vid_mix_static_.Clear();
}
inline const ::mt::TVidMixStatistic& TCodecStatistic::main_vid_mix_static(int index) const {
  return main_vid_mix_static_.Get(index);
}
inline ::mt::TVidMixStatistic* TCodecStatistic::mutable_main_vid_mix_static(int index) {
  return main_vid_mix_static_.Mutable(index);
}
inline ::mt::TVidMixStatistic* TCodecStatistic::add_main_vid_mix_static() {
  return main_vid_mix_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidMixStatistic >&
TCodecStatistic::main_vid_mix_static() const {
  return main_vid_mix_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidMixStatistic >*
TCodecStatistic::mutable_main_vid_mix_static() {
  return &main_vid_mix_static_;
}

// repeated .mt.TVidMixStatistic ass_vid_mix_static = 12;
inline int TCodecStatistic::ass_vid_mix_static_size() const {
  return ass_vid_mix_static_.size();
}
inline void TCodecStatistic::clear_ass_vid_mix_static() {
  ass_vid_mix_static_.Clear();
}
inline const ::mt::TVidMixStatistic& TCodecStatistic::ass_vid_mix_static(int index) const {
  return ass_vid_mix_static_.Get(index);
}
inline ::mt::TVidMixStatistic* TCodecStatistic::mutable_ass_vid_mix_static(int index) {
  return ass_vid_mix_static_.Mutable(index);
}
inline ::mt::TVidMixStatistic* TCodecStatistic::add_ass_vid_mix_static() {
  return ass_vid_mix_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidMixStatistic >&
TCodecStatistic::ass_vid_mix_static() const {
  return ass_vid_mix_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidMixStatistic >*
TCodecStatistic::mutable_ass_vid_mix_static() {
  return &ass_vid_mix_static_;
}

// -------------------------------------------------------------------

// TDevInfo

// optional string dev_name = 1;
inline bool TDevInfo::has_dev_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDevInfo::set_has_dev_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDevInfo::clear_has_dev_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDevInfo::clear_dev_name() {
  if (dev_name_ != &::google::protobuf::internal::kEmptyString) {
    dev_name_->clear();
  }
  clear_has_dev_name();
}
inline const ::std::string& TDevInfo::dev_name() const {
  return *dev_name_;
}
inline void TDevInfo::set_dev_name(const ::std::string& value) {
  set_has_dev_name();
  if (dev_name_ == &::google::protobuf::internal::kEmptyString) {
    dev_name_ = new ::std::string;
  }
  dev_name_->assign(value);
}
inline void TDevInfo::set_dev_name(const char* value) {
  set_has_dev_name();
  if (dev_name_ == &::google::protobuf::internal::kEmptyString) {
    dev_name_ = new ::std::string;
  }
  dev_name_->assign(value);
}
inline void TDevInfo::set_dev_name(const char* value, size_t size) {
  set_has_dev_name();
  if (dev_name_ == &::google::protobuf::internal::kEmptyString) {
    dev_name_ = new ::std::string;
  }
  dev_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDevInfo::mutable_dev_name() {
  set_has_dev_name();
  if (dev_name_ == &::google::protobuf::internal::kEmptyString) {
    dev_name_ = new ::std::string;
  }
  return dev_name_;
}
inline ::std::string* TDevInfo::release_dev_name() {
  clear_has_dev_name();
  if (dev_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dev_name_;
    dev_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDevInfo::set_allocated_dev_name(::std::string* dev_name) {
  if (dev_name_ != &::google::protobuf::internal::kEmptyString) {
    delete dev_name_;
  }
  if (dev_name) {
    set_has_dev_name();
    dev_name_ = dev_name;
  } else {
    clear_has_dev_name();
    dev_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dev_guid = 2;
inline bool TDevInfo::has_dev_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDevInfo::set_has_dev_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDevInfo::clear_has_dev_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDevInfo::clear_dev_guid() {
  if (dev_guid_ != &::google::protobuf::internal::kEmptyString) {
    dev_guid_->clear();
  }
  clear_has_dev_guid();
}
inline const ::std::string& TDevInfo::dev_guid() const {
  return *dev_guid_;
}
inline void TDevInfo::set_dev_guid(const ::std::string& value) {
  set_has_dev_guid();
  if (dev_guid_ == &::google::protobuf::internal::kEmptyString) {
    dev_guid_ = new ::std::string;
  }
  dev_guid_->assign(value);
}
inline void TDevInfo::set_dev_guid(const char* value) {
  set_has_dev_guid();
  if (dev_guid_ == &::google::protobuf::internal::kEmptyString) {
    dev_guid_ = new ::std::string;
  }
  dev_guid_->assign(value);
}
inline void TDevInfo::set_dev_guid(const char* value, size_t size) {
  set_has_dev_guid();
  if (dev_guid_ == &::google::protobuf::internal::kEmptyString) {
    dev_guid_ = new ::std::string;
  }
  dev_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDevInfo::mutable_dev_guid() {
  set_has_dev_guid();
  if (dev_guid_ == &::google::protobuf::internal::kEmptyString) {
    dev_guid_ = new ::std::string;
  }
  return dev_guid_;
}
inline ::std::string* TDevInfo::release_dev_guid() {
  clear_has_dev_guid();
  if (dev_guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dev_guid_;
    dev_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDevInfo::set_allocated_dev_guid(::std::string* dev_guid) {
  if (dev_guid_ != &::google::protobuf::internal::kEmptyString) {
    delete dev_guid_;
  }
  if (dev_guid) {
    set_has_dev_guid();
    dev_guid_ = dev_guid;
  } else {
    clear_has_dev_guid();
    dev_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TDevInfoList

// repeated .mt.TDevInfo dev_list = 1;
inline int TDevInfoList::dev_list_size() const {
  return dev_list_.size();
}
inline void TDevInfoList::clear_dev_list() {
  dev_list_.Clear();
}
inline const ::mt::TDevInfo& TDevInfoList::dev_list(int index) const {
  return dev_list_.Get(index);
}
inline ::mt::TDevInfo* TDevInfoList::mutable_dev_list(int index) {
  return dev_list_.Mutable(index);
}
inline ::mt::TDevInfo* TDevInfoList::add_dev_list() {
  return dev_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TDevInfo >&
TDevInfoList::dev_list() const {
  return dev_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TDevInfo >*
TDevInfoList::mutable_dev_list() {
  return &dev_list_;
}

// -------------------------------------------------------------------

// TVMPMemParam

// optional uint32 chan_index = 1;
inline bool TVMPMemParam::has_chan_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVMPMemParam::set_has_chan_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVMPMemParam::clear_has_chan_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVMPMemParam::clear_chan_index() {
  chan_index_ = 0u;
  clear_has_chan_index();
}
inline ::google::protobuf::uint32 TVMPMemParam::chan_index() const {
  return chan_index_;
}
inline void TVMPMemParam::set_chan_index(::google::protobuf::uint32 value) {
  set_has_chan_index();
  chan_index_ = value;
}

// optional .mt.TNetAddr rcv_rtp_addr = 2;
inline bool TVMPMemParam::has_rcv_rtp_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVMPMemParam::set_has_rcv_rtp_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVMPMemParam::clear_has_rcv_rtp_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVMPMemParam::clear_rcv_rtp_addr() {
  if (rcv_rtp_addr_ != NULL) rcv_rtp_addr_->::mt::TNetAddr::Clear();
  clear_has_rcv_rtp_addr();
}
inline const ::mt::TNetAddr& TVMPMemParam::rcv_rtp_addr() const {
  return rcv_rtp_addr_ != NULL ? *rcv_rtp_addr_ : *default_instance_->rcv_rtp_addr_;
}
inline ::mt::TNetAddr* TVMPMemParam::mutable_rcv_rtp_addr() {
  set_has_rcv_rtp_addr();
  if (rcv_rtp_addr_ == NULL) rcv_rtp_addr_ = new ::mt::TNetAddr;
  return rcv_rtp_addr_;
}
inline ::mt::TNetAddr* TVMPMemParam::release_rcv_rtp_addr() {
  clear_has_rcv_rtp_addr();
  ::mt::TNetAddr* temp = rcv_rtp_addr_;
  rcv_rtp_addr_ = NULL;
  return temp;
}
inline void TVMPMemParam::set_allocated_rcv_rtp_addr(::mt::TNetAddr* rcv_rtp_addr) {
  delete rcv_rtp_addr_;
  rcv_rtp_addr_ = rcv_rtp_addr;
  if (rcv_rtp_addr) {
    set_has_rcv_rtp_addr();
  } else {
    clear_has_rcv_rtp_addr();
  }
}

// optional .mt.TNetAddr rcv_backrtcp_addr = 3;
inline bool TVMPMemParam::has_rcv_backrtcp_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVMPMemParam::set_has_rcv_backrtcp_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVMPMemParam::clear_has_rcv_backrtcp_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVMPMemParam::clear_rcv_backrtcp_addr() {
  if (rcv_backrtcp_addr_ != NULL) rcv_backrtcp_addr_->::mt::TNetAddr::Clear();
  clear_has_rcv_backrtcp_addr();
}
inline const ::mt::TNetAddr& TVMPMemParam::rcv_backrtcp_addr() const {
  return rcv_backrtcp_addr_ != NULL ? *rcv_backrtcp_addr_ : *default_instance_->rcv_backrtcp_addr_;
}
inline ::mt::TNetAddr* TVMPMemParam::mutable_rcv_backrtcp_addr() {
  set_has_rcv_backrtcp_addr();
  if (rcv_backrtcp_addr_ == NULL) rcv_backrtcp_addr_ = new ::mt::TNetAddr;
  return rcv_backrtcp_addr_;
}
inline ::mt::TNetAddr* TVMPMemParam::release_rcv_backrtcp_addr() {
  clear_has_rcv_backrtcp_addr();
  ::mt::TNetAddr* temp = rcv_backrtcp_addr_;
  rcv_backrtcp_addr_ = NULL;
  return temp;
}
inline void TVMPMemParam::set_allocated_rcv_backrtcp_addr(::mt::TNetAddr* rcv_backrtcp_addr) {
  delete rcv_backrtcp_addr_;
  rcv_backrtcp_addr_ = rcv_backrtcp_addr;
  if (rcv_backrtcp_addr) {
    set_has_rcv_backrtcp_addr();
  } else {
    clear_has_rcv_backrtcp_addr();
  }
}

// optional .mt.TEncryptKey encryp_key = 4;
inline bool TVMPMemParam::has_encryp_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVMPMemParam::set_has_encryp_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVMPMemParam::clear_has_encryp_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVMPMemParam::clear_encryp_key() {
  if (encryp_key_ != NULL) encryp_key_->::mt::TEncryptKey::Clear();
  clear_has_encryp_key();
}
inline const ::mt::TEncryptKey& TVMPMemParam::encryp_key() const {
  return encryp_key_ != NULL ? *encryp_key_ : *default_instance_->encryp_key_;
}
inline ::mt::TEncryptKey* TVMPMemParam::mutable_encryp_key() {
  set_has_encryp_key();
  if (encryp_key_ == NULL) encryp_key_ = new ::mt::TEncryptKey;
  return encryp_key_;
}
inline ::mt::TEncryptKey* TVMPMemParam::release_encryp_key() {
  clear_has_encryp_key();
  ::mt::TEncryptKey* temp = encryp_key_;
  encryp_key_ = NULL;
  return temp;
}
inline void TVMPMemParam::set_allocated_encryp_key(::mt::TEncryptKey* encryp_key) {
  delete encryp_key_;
  encryp_key_ = encryp_key;
  if (encryp_key) {
    set_has_encryp_key();
  } else {
    clear_has_encryp_key();
  }
}

// optional uint32 payload = 5;
inline bool TVMPMemParam::has_payload() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVMPMemParam::set_has_payload() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVMPMemParam::clear_has_payload() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVMPMemParam::clear_payload() {
  payload_ = 0u;
  clear_has_payload();
}
inline ::google::protobuf::uint32 TVMPMemParam::payload() const {
  return payload_;
}
inline void TVMPMemParam::set_payload(::google::protobuf::uint32 value) {
  set_has_payload();
  payload_ = value;
}

// optional uint32 media_type = 6;
inline bool TVMPMemParam::has_media_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVMPMemParam::set_has_media_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVMPMemParam::clear_has_media_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVMPMemParam::clear_media_type() {
  media_type_ = 0u;
  clear_has_media_type();
}
inline ::google::protobuf::uint32 TVMPMemParam::media_type() const {
  return media_type_;
}
inline void TVMPMemParam::set_media_type(::google::protobuf::uint32 value) {
  set_has_media_type();
  media_type_ = value;
}

// -------------------------------------------------------------------

// TMultiVMPMemParam

// repeated .mt.TVMPMemParam vmp_memParams = 1;
inline int TMultiVMPMemParam::vmp_memparams_size() const {
  return vmp_memparams_.size();
}
inline void TMultiVMPMemParam::clear_vmp_memparams() {
  vmp_memparams_.Clear();
}
inline const ::mt::TVMPMemParam& TMultiVMPMemParam::vmp_memparams(int index) const {
  return vmp_memparams_.Get(index);
}
inline ::mt::TVMPMemParam* TMultiVMPMemParam::mutable_vmp_memparams(int index) {
  return vmp_memparams_.Mutable(index);
}
inline ::mt::TVMPMemParam* TMultiVMPMemParam::add_vmp_memparams() {
  return vmp_memparams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVMPMemParam >&
TMultiVMPMemParam::vmp_memparams() const {
  return vmp_memparams_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVMPMemParam >*
TMultiVMPMemParam::mutable_vmp_memparams() {
  return &vmp_memparams_;
}

// -------------------------------------------------------------------

// TMixerMemParam

// optional uint32 chan_index = 1;
inline bool TMixerMemParam::has_chan_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMixerMemParam::set_has_chan_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMixerMemParam::clear_has_chan_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMixerMemParam::clear_chan_index() {
  chan_index_ = 0u;
  clear_has_chan_index();
}
inline ::google::protobuf::uint32 TMixerMemParam::chan_index() const {
  return chan_index_;
}
inline void TMixerMemParam::set_chan_index(::google::protobuf::uint32 value) {
  set_has_chan_index();
  chan_index_ = value;
}

// optional .mt.TNetAddr rcv_rtp_addr = 2;
inline bool TMixerMemParam::has_rcv_rtp_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMixerMemParam::set_has_rcv_rtp_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMixerMemParam::clear_has_rcv_rtp_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMixerMemParam::clear_rcv_rtp_addr() {
  if (rcv_rtp_addr_ != NULL) rcv_rtp_addr_->::mt::TNetAddr::Clear();
  clear_has_rcv_rtp_addr();
}
inline const ::mt::TNetAddr& TMixerMemParam::rcv_rtp_addr() const {
  return rcv_rtp_addr_ != NULL ? *rcv_rtp_addr_ : *default_instance_->rcv_rtp_addr_;
}
inline ::mt::TNetAddr* TMixerMemParam::mutable_rcv_rtp_addr() {
  set_has_rcv_rtp_addr();
  if (rcv_rtp_addr_ == NULL) rcv_rtp_addr_ = new ::mt::TNetAddr;
  return rcv_rtp_addr_;
}
inline ::mt::TNetAddr* TMixerMemParam::release_rcv_rtp_addr() {
  clear_has_rcv_rtp_addr();
  ::mt::TNetAddr* temp = rcv_rtp_addr_;
  rcv_rtp_addr_ = NULL;
  return temp;
}
inline void TMixerMemParam::set_allocated_rcv_rtp_addr(::mt::TNetAddr* rcv_rtp_addr) {
  delete rcv_rtp_addr_;
  rcv_rtp_addr_ = rcv_rtp_addr;
  if (rcv_rtp_addr) {
    set_has_rcv_rtp_addr();
  } else {
    clear_has_rcv_rtp_addr();
  }
}

// optional .mt.TNetAddr rcv_backrtcp_addr = 3;
inline bool TMixerMemParam::has_rcv_backrtcp_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMixerMemParam::set_has_rcv_backrtcp_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMixerMemParam::clear_has_rcv_backrtcp_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMixerMemParam::clear_rcv_backrtcp_addr() {
  if (rcv_backrtcp_addr_ != NULL) rcv_backrtcp_addr_->::mt::TNetAddr::Clear();
  clear_has_rcv_backrtcp_addr();
}
inline const ::mt::TNetAddr& TMixerMemParam::rcv_backrtcp_addr() const {
  return rcv_backrtcp_addr_ != NULL ? *rcv_backrtcp_addr_ : *default_instance_->rcv_backrtcp_addr_;
}
inline ::mt::TNetAddr* TMixerMemParam::mutable_rcv_backrtcp_addr() {
  set_has_rcv_backrtcp_addr();
  if (rcv_backrtcp_addr_ == NULL) rcv_backrtcp_addr_ = new ::mt::TNetAddr;
  return rcv_backrtcp_addr_;
}
inline ::mt::TNetAddr* TMixerMemParam::release_rcv_backrtcp_addr() {
  clear_has_rcv_backrtcp_addr();
  ::mt::TNetAddr* temp = rcv_backrtcp_addr_;
  rcv_backrtcp_addr_ = NULL;
  return temp;
}
inline void TMixerMemParam::set_allocated_rcv_backrtcp_addr(::mt::TNetAddr* rcv_backrtcp_addr) {
  delete rcv_backrtcp_addr_;
  rcv_backrtcp_addr_ = rcv_backrtcp_addr;
  if (rcv_backrtcp_addr) {
    set_has_rcv_backrtcp_addr();
  } else {
    clear_has_rcv_backrtcp_addr();
  }
}

// optional .mt.TEncryptKey encryp_key = 4;
inline bool TMixerMemParam::has_encryp_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMixerMemParam::set_has_encryp_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMixerMemParam::clear_has_encryp_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMixerMemParam::clear_encryp_key() {
  if (encryp_key_ != NULL) encryp_key_->::mt::TEncryptKey::Clear();
  clear_has_encryp_key();
}
inline const ::mt::TEncryptKey& TMixerMemParam::encryp_key() const {
  return encryp_key_ != NULL ? *encryp_key_ : *default_instance_->encryp_key_;
}
inline ::mt::TEncryptKey* TMixerMemParam::mutable_encryp_key() {
  set_has_encryp_key();
  if (encryp_key_ == NULL) encryp_key_ = new ::mt::TEncryptKey;
  return encryp_key_;
}
inline ::mt::TEncryptKey* TMixerMemParam::release_encryp_key() {
  clear_has_encryp_key();
  ::mt::TEncryptKey* temp = encryp_key_;
  encryp_key_ = NULL;
  return temp;
}
inline void TMixerMemParam::set_allocated_encryp_key(::mt::TEncryptKey* encryp_key) {
  delete encryp_key_;
  encryp_key_ = encryp_key;
  if (encryp_key) {
    set_has_encryp_key();
  } else {
    clear_has_encryp_key();
  }
}

// optional uint32 payload = 5;
inline bool TMixerMemParam::has_payload() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMixerMemParam::set_has_payload() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMixerMemParam::clear_has_payload() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMixerMemParam::clear_payload() {
  payload_ = 0u;
  clear_has_payload();
}
inline ::google::protobuf::uint32 TMixerMemParam::payload() const {
  return payload_;
}
inline void TMixerMemParam::set_payload(::google::protobuf::uint32 value) {
  set_has_payload();
  payload_ = value;
}

// optional uint32 media_type = 6;
inline bool TMixerMemParam::has_media_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMixerMemParam::set_has_media_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMixerMemParam::clear_has_media_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMixerMemParam::clear_media_type() {
  media_type_ = 0u;
  clear_has_media_type();
}
inline ::google::protobuf::uint32 TMixerMemParam::media_type() const {
  return media_type_;
}
inline void TMixerMemParam::set_media_type(::google::protobuf::uint32 value) {
  set_has_media_type();
  media_type_ = value;
}

// -------------------------------------------------------------------

// TMultiMixerMemParam

// repeated .mt.TMixerMemParam mixer_memParams = 1;
inline int TMultiMixerMemParam::mixer_memparams_size() const {
  return mixer_memparams_.size();
}
inline void TMultiMixerMemParam::clear_mixer_memparams() {
  mixer_memparams_.Clear();
}
inline const ::mt::TMixerMemParam& TMultiMixerMemParam::mixer_memparams(int index) const {
  return mixer_memparams_.Get(index);
}
inline ::mt::TMixerMemParam* TMultiMixerMemParam::mutable_mixer_memparams(int index) {
  return mixer_memparams_.Mutable(index);
}
inline ::mt::TMixerMemParam* TMultiMixerMemParam::add_mixer_memparams() {
  return mixer_memparams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMixerMemParam >&
TMultiMixerMemParam::mixer_memparams() const {
  return mixer_memparams_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMixerMemParam >*
TMultiMixerMemParam::mutable_mixer_memparams() {
  return &mixer_memparams_;
}

// -------------------------------------------------------------------

// TRecordParam

// optional string file_path = 1;
inline bool TRecordParam::has_file_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRecordParam::set_has_file_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRecordParam::clear_has_file_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRecordParam::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& TRecordParam::file_path() const {
  return *file_path_;
}
inline void TRecordParam::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void TRecordParam::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void TRecordParam::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TRecordParam::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  return file_path_;
}
inline ::std::string* TRecordParam::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TRecordParam::set_allocated_file_path(::std::string* file_path) {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    delete file_path_;
  }
  if (file_path) {
    set_has_file_path();
    file_path_ = file_path;
  } else {
    clear_has_file_path();
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_local = 2;
inline bool TRecordParam::has_is_local() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRecordParam::set_has_is_local() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRecordParam::clear_has_is_local() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRecordParam::clear_is_local() {
  is_local_ = false;
  clear_has_is_local();
}
inline bool TRecordParam::is_local() const {
  return is_local_;
}
inline void TRecordParam::set_is_local(bool value) {
  set_has_is_local();
  is_local_ = value;
}

// optional bool has_audio = 3;
inline bool TRecordParam::has_has_audio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TRecordParam::set_has_has_audio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TRecordParam::clear_has_has_audio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TRecordParam::clear_has_audio() {
  has_audio_ = false;
  clear_has_has_audio();
}
inline bool TRecordParam::has_audio() const {
  return has_audio_;
}
inline void TRecordParam::set_has_audio(bool value) {
  set_has_has_audio();
  has_audio_ = value;
}

// optional bool has_aux_video = 4;
inline bool TRecordParam::has_has_aux_video() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TRecordParam::set_has_has_aux_video() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TRecordParam::clear_has_has_aux_video() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TRecordParam::clear_has_aux_video() {
  has_aux_video_ = false;
  clear_has_has_aux_video();
}
inline bool TRecordParam::has_aux_video() const {
  return has_aux_video_;
}
inline void TRecordParam::set_has_aux_video(bool value) {
  set_has_has_aux_video();
  has_aux_video_ = value;
}

// optional string file_name = 5;
inline bool TRecordParam::has_file_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TRecordParam::set_has_file_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TRecordParam::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TRecordParam::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& TRecordParam::file_name() const {
  return *file_name_;
}
inline void TRecordParam::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TRecordParam::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TRecordParam::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TRecordParam::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* TRecordParam::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TRecordParam::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TRecordDiskAlarmLevel

// optional string partition_name = 1;
inline bool TRecordDiskAlarmLevel::has_partition_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRecordDiskAlarmLevel::set_has_partition_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRecordDiskAlarmLevel::clear_has_partition_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRecordDiskAlarmLevel::clear_partition_name() {
  if (partition_name_ != &::google::protobuf::internal::kEmptyString) {
    partition_name_->clear();
  }
  clear_has_partition_name();
}
inline const ::std::string& TRecordDiskAlarmLevel::partition_name() const {
  return *partition_name_;
}
inline void TRecordDiskAlarmLevel::set_partition_name(const ::std::string& value) {
  set_has_partition_name();
  if (partition_name_ == &::google::protobuf::internal::kEmptyString) {
    partition_name_ = new ::std::string;
  }
  partition_name_->assign(value);
}
inline void TRecordDiskAlarmLevel::set_partition_name(const char* value) {
  set_has_partition_name();
  if (partition_name_ == &::google::protobuf::internal::kEmptyString) {
    partition_name_ = new ::std::string;
  }
  partition_name_->assign(value);
}
inline void TRecordDiskAlarmLevel::set_partition_name(const char* value, size_t size) {
  set_has_partition_name();
  if (partition_name_ == &::google::protobuf::internal::kEmptyString) {
    partition_name_ = new ::std::string;
  }
  partition_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TRecordDiskAlarmLevel::mutable_partition_name() {
  set_has_partition_name();
  if (partition_name_ == &::google::protobuf::internal::kEmptyString) {
    partition_name_ = new ::std::string;
  }
  return partition_name_;
}
inline ::std::string* TRecordDiskAlarmLevel::release_partition_name() {
  clear_has_partition_name();
  if (partition_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partition_name_;
    partition_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TRecordDiskAlarmLevel::set_allocated_partition_name(::std::string* partition_name) {
  if (partition_name_ != &::google::protobuf::internal::kEmptyString) {
    delete partition_name_;
  }
  if (partition_name) {
    set_has_partition_name();
    partition_name_ = partition_name;
  } else {
    clear_has_partition_name();
    partition_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 alarm_level1 = 2;
inline bool TRecordDiskAlarmLevel::has_alarm_level1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRecordDiskAlarmLevel::set_has_alarm_level1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRecordDiskAlarmLevel::clear_has_alarm_level1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRecordDiskAlarmLevel::clear_alarm_level1() {
  alarm_level1_ = 0u;
  clear_has_alarm_level1();
}
inline ::google::protobuf::uint32 TRecordDiskAlarmLevel::alarm_level1() const {
  return alarm_level1_;
}
inline void TRecordDiskAlarmLevel::set_alarm_level1(::google::protobuf::uint32 value) {
  set_has_alarm_level1();
  alarm_level1_ = value;
}

// optional uint32 alarm_level2 = 3;
inline bool TRecordDiskAlarmLevel::has_alarm_level2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TRecordDiskAlarmLevel::set_has_alarm_level2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TRecordDiskAlarmLevel::clear_has_alarm_level2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TRecordDiskAlarmLevel::clear_alarm_level2() {
  alarm_level2_ = 0u;
  clear_has_alarm_level2();
}
inline ::google::protobuf::uint32 TRecordDiskAlarmLevel::alarm_level2() const {
  return alarm_level2_;
}
inline void TRecordDiskAlarmLevel::set_alarm_level2(::google::protobuf::uint32 value) {
  set_has_alarm_level2();
  alarm_level2_ = value;
}

// -------------------------------------------------------------------

// TImageParam

// optional .mt.EmImgParam img_param_type = 1;
inline bool TImageParam::has_img_param_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImageParam::set_has_img_param_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImageParam::clear_has_img_param_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImageParam::clear_img_param_type() {
  img_param_type_ = 0;
  clear_has_img_param_type();
}
inline ::mt::EmImgParam TImageParam::img_param_type() const {
  return static_cast< ::mt::EmImgParam >(img_param_type_);
}
inline void TImageParam::set_img_param_type(::mt::EmImgParam value) {
  assert(::mt::EmImgParam_IsValid(value));
  set_has_img_param_type();
  img_param_type_ = value;
}

// optional uint32 val = 2;
inline bool TImageParam::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImageParam::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImageParam::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImageParam::clear_val() {
  val_ = 0u;
  clear_has_val();
}
inline ::google::protobuf::uint32 TImageParam::val() const {
  return val_;
}
inline void TImageParam::set_val(::google::protobuf::uint32 value) {
  set_has_val();
  val_ = value;
}

// optional bool is_auto = 3;
inline bool TImageParam::has_is_auto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImageParam::set_has_is_auto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImageParam::clear_has_is_auto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImageParam::clear_is_auto() {
  is_auto_ = false;
  clear_has_is_auto();
}
inline bool TImageParam::is_auto() const {
  return is_auto_;
}
inline void TImageParam::set_is_auto(bool value) {
  set_has_is_auto();
  is_auto_ = value;
}

// -------------------------------------------------------------------

// TDefaultImageParam

// optional .mt.EmImgParam img_param_type = 1;
inline bool TDefaultImageParam::has_img_param_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDefaultImageParam::set_has_img_param_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDefaultImageParam::clear_has_img_param_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDefaultImageParam::clear_img_param_type() {
  img_param_type_ = 0;
  clear_has_img_param_type();
}
inline ::mt::EmImgParam TDefaultImageParam::img_param_type() const {
  return static_cast< ::mt::EmImgParam >(img_param_type_);
}
inline void TDefaultImageParam::set_img_param_type(::mt::EmImgParam value) {
  assert(::mt::EmImgParam_IsValid(value));
  set_has_img_param_type();
  img_param_type_ = value;
}

// optional uint32 min_val = 2;
inline bool TDefaultImageParam::has_min_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDefaultImageParam::set_has_min_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDefaultImageParam::clear_has_min_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDefaultImageParam::clear_min_val() {
  min_val_ = 0u;
  clear_has_min_val();
}
inline ::google::protobuf::uint32 TDefaultImageParam::min_val() const {
  return min_val_;
}
inline void TDefaultImageParam::set_min_val(::google::protobuf::uint32 value) {
  set_has_min_val();
  min_val_ = value;
}

// optional uint32 max_val = 3;
inline bool TDefaultImageParam::has_max_val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TDefaultImageParam::set_has_max_val() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TDefaultImageParam::clear_has_max_val() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TDefaultImageParam::clear_max_val() {
  max_val_ = 0u;
  clear_has_max_val();
}
inline ::google::protobuf::uint32 TDefaultImageParam::max_val() const {
  return max_val_;
}
inline void TDefaultImageParam::set_max_val(::google::protobuf::uint32 value) {
  set_has_max_val();
  max_val_ = value;
}

// optional uint32 def_val = 4;
inline bool TDefaultImageParam::has_def_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TDefaultImageParam::set_has_def_val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TDefaultImageParam::clear_has_def_val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TDefaultImageParam::clear_def_val() {
  def_val_ = 0u;
  clear_has_def_val();
}
inline ::google::protobuf::uint32 TDefaultImageParam::def_val() const {
  return def_val_;
}
inline void TDefaultImageParam::set_def_val(::google::protobuf::uint32 value) {
  set_has_def_val();
  def_val_ = value;
}

// optional uint32 step = 5;
inline bool TDefaultImageParam::has_step() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TDefaultImageParam::set_has_step() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TDefaultImageParam::clear_has_step() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TDefaultImageParam::clear_step() {
  step_ = 0u;
  clear_has_step();
}
inline ::google::protobuf::uint32 TDefaultImageParam::step() const {
  return step_;
}
inline void TDefaultImageParam::set_step(::google::protobuf::uint32 value) {
  set_has_step();
  step_ = value;
}

// -------------------------------------------------------------------

// TAudInputState

// optional .mt.EmHDAudPortIn emAudInputType = 1;
inline bool TAudInputState::has_emaudinputtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAudInputState::set_has_emaudinputtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAudInputState::clear_has_emaudinputtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAudInputState::clear_emaudinputtype() {
  emaudinputtype_ = 0;
  clear_has_emaudinputtype();
}
inline ::mt::EmHDAudPortIn TAudInputState::emaudinputtype() const {
  return static_cast< ::mt::EmHDAudPortIn >(emaudinputtype_);
}
inline void TAudInputState::set_emaudinputtype(::mt::EmHDAudPortIn value) {
  assert(::mt::EmHDAudPortIn_IsValid(value));
  set_has_emaudinputtype();
  emaudinputtype_ = value;
}

// optional bool bUsed = 2;
inline bool TAudInputState::has_bused() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAudInputState::set_has_bused() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAudInputState::clear_has_bused() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAudInputState::clear_bused() {
  bused_ = false;
  clear_has_bused();
}
inline bool TAudInputState::bused() const {
  return bused_;
}
inline void TAudInputState::set_bused(bool value) {
  set_has_bused();
  bused_ = value;
}

// -------------------------------------------------------------------

// TMultiAudInputState

// repeated .mt.TAudInputState audio_input_state = 1;
inline int TMultiAudInputState::audio_input_state_size() const {
  return audio_input_state_.size();
}
inline void TMultiAudInputState::clear_audio_input_state() {
  audio_input_state_.Clear();
}
inline const ::mt::TAudInputState& TMultiAudInputState::audio_input_state(int index) const {
  return audio_input_state_.Get(index);
}
inline ::mt::TAudInputState* TMultiAudInputState::mutable_audio_input_state(int index) {
  return audio_input_state_.Mutable(index);
}
inline ::mt::TAudInputState* TMultiAudInputState::add_audio_input_state() {
  return audio_input_state_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudInputState >&
TMultiAudInputState::audio_input_state() const {
  return audio_input_state_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudInputState >*
TMultiAudInputState::mutable_audio_input_state() {
  return &audio_input_state_;
}

// -------------------------------------------------------------------

// TAudOutputState

// optional .mt.EmHDAudPortOut emAudOutputType = 1;
inline bool TAudOutputState::has_emaudoutputtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAudOutputState::set_has_emaudoutputtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAudOutputState::clear_has_emaudoutputtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAudOutputState::clear_emaudoutputtype() {
  emaudoutputtype_ = 0;
  clear_has_emaudoutputtype();
}
inline ::mt::EmHDAudPortOut TAudOutputState::emaudoutputtype() const {
  return static_cast< ::mt::EmHDAudPortOut >(emaudoutputtype_);
}
inline void TAudOutputState::set_emaudoutputtype(::mt::EmHDAudPortOut value) {
  assert(::mt::EmHDAudPortOut_IsValid(value));
  set_has_emaudoutputtype();
  emaudoutputtype_ = value;
}

// optional bool bUsed = 2;
inline bool TAudOutputState::has_bused() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAudOutputState::set_has_bused() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAudOutputState::clear_has_bused() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAudOutputState::clear_bused() {
  bused_ = false;
  clear_has_bused();
}
inline bool TAudOutputState::bused() const {
  return bused_;
}
inline void TAudOutputState::set_bused(bool value) {
  set_has_bused();
  bused_ = value;
}

// -------------------------------------------------------------------

// TMultiAudOutputState

// repeated .mt.TAudOutputState audio_output_state = 1;
inline int TMultiAudOutputState::audio_output_state_size() const {
  return audio_output_state_.size();
}
inline void TMultiAudOutputState::clear_audio_output_state() {
  audio_output_state_.Clear();
}
inline const ::mt::TAudOutputState& TMultiAudOutputState::audio_output_state(int index) const {
  return audio_output_state_.Get(index);
}
inline ::mt::TAudOutputState* TMultiAudOutputState::mutable_audio_output_state(int index) {
  return audio_output_state_.Mutable(index);
}
inline ::mt::TAudOutputState* TMultiAudOutputState::add_audio_output_state() {
  return audio_output_state_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudOutputState >&
TMultiAudOutputState::audio_output_state() const {
  return audio_output_state_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudOutputState >*
TMultiAudOutputState::mutable_audio_output_state() {
  return &audio_output_state_;
}

// -------------------------------------------------------------------

// TVideoResDetect

// optional .mt.EmVideoType video_type = 1;
inline bool TVideoResDetect::has_video_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVideoResDetect::set_has_video_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVideoResDetect::clear_has_video_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVideoResDetect::clear_video_type() {
  video_type_ = 0;
  clear_has_video_type();
}
inline ::mt::EmVideoType TVideoResDetect::video_type() const {
  return static_cast< ::mt::EmVideoType >(video_type_);
}
inline void TVideoResDetect::set_video_type(::mt::EmVideoType value) {
  assert(::mt::EmVideoType_IsValid(value));
  set_has_video_type();
  video_type_ = value;
}

// optional .mt.EmMtVideoPort video_port = 2;
inline bool TVideoResDetect::has_video_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVideoResDetect::set_has_video_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVideoResDetect::clear_has_video_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVideoResDetect::clear_video_port() {
  video_port_ = 0;
  clear_has_video_port();
}
inline ::mt::EmMtVideoPort TVideoResDetect::video_port() const {
  return static_cast< ::mt::EmMtVideoPort >(video_port_);
}
inline void TVideoResDetect::set_video_port(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  set_has_video_port();
  video_port_ = value;
}

// optional .mt.EmMtResolution video_res = 3;
inline bool TVideoResDetect::has_video_res() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVideoResDetect::set_has_video_res() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVideoResDetect::clear_has_video_res() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVideoResDetect::clear_video_res() {
  video_res_ = 0;
  clear_has_video_res();
}
inline ::mt::EmMtResolution TVideoResDetect::video_res() const {
  return static_cast< ::mt::EmMtResolution >(video_res_);
}
inline void TVideoResDetect::set_video_res(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_video_res();
  video_res_ = value;
}

// optional uint32 framerate = 4;
inline bool TVideoResDetect::has_framerate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVideoResDetect::set_has_framerate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVideoResDetect::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVideoResDetect::clear_framerate() {
  framerate_ = 0u;
  clear_has_framerate();
}
inline ::google::protobuf::uint32 TVideoResDetect::framerate() const {
  return framerate_;
}
inline void TVideoResDetect::set_framerate(::google::protobuf::uint32 value) {
  set_has_framerate();
  framerate_ = value;
}

// -------------------------------------------------------------------

// TMultiVideoResDetect

// repeated .mt.TVideoResDetect video_state = 1;
inline int TMultiVideoResDetect::video_state_size() const {
  return video_state_.size();
}
inline void TMultiVideoResDetect::clear_video_state() {
  video_state_.Clear();
}
inline const ::mt::TVideoResDetect& TMultiVideoResDetect::video_state(int index) const {
  return video_state_.Get(index);
}
inline ::mt::TVideoResDetect* TMultiVideoResDetect::mutable_video_state(int index) {
  return video_state_.Mutable(index);
}
inline ::mt::TVideoResDetect* TMultiVideoResDetect::add_video_state() {
  return video_state_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVideoResDetect >&
TMultiVideoResDetect::video_state() const {
  return video_state_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVideoResDetect >*
TMultiVideoResDetect::mutable_video_state() {
  return &video_state_;
}

// -------------------------------------------------------------------

// TFxoState

// optional .mt.EmFxoState emFxo_state = 1;
inline bool TFxoState::has_emfxo_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TFxoState::set_has_emfxo_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TFxoState::clear_has_emfxo_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TFxoState::clear_emfxo_state() {
  emfxo_state_ = 0;
  clear_has_emfxo_state();
}
inline ::mt::EmFxoState TFxoState::emfxo_state() const {
  return static_cast< ::mt::EmFxoState >(emfxo_state_);
}
inline void TFxoState::set_emfxo_state(::mt::EmFxoState value) {
  assert(::mt::EmFxoState_IsValid(value));
  set_has_emfxo_state();
  emfxo_state_ = value;
}

// -------------------------------------------------------------------

// TMtVidSrcInfo

// optional .mt.EmCodecComponent codec_type = 1;
inline bool TMtVidSrcInfo::has_codec_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtVidSrcInfo::set_has_codec_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtVidSrcInfo::clear_has_codec_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtVidSrcInfo::clear_codec_type() {
  codec_type_ = 0;
  clear_has_codec_type();
}
inline ::mt::EmCodecComponent TMtVidSrcInfo::codec_type() const {
  return static_cast< ::mt::EmCodecComponent >(codec_type_);
}
inline void TMtVidSrcInfo::set_codec_type(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_codec_type();
  codec_type_ = value;
}

// optional .mt.EmCodecComponentIndex codec_id = 2;
inline bool TMtVidSrcInfo::has_codec_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtVidSrcInfo::set_has_codec_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtVidSrcInfo::clear_has_codec_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtVidSrcInfo::clear_codec_id() {
  codec_id_ = 0;
  clear_has_codec_id();
}
inline ::mt::EmCodecComponentIndex TMtVidSrcInfo::codec_id() const {
  return static_cast< ::mt::EmCodecComponentIndex >(codec_id_);
}
inline void TMtVidSrcInfo::set_codec_id(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_codec_id();
  codec_id_ = value;
}

// optional uint32 video_width = 3;
inline bool TMtVidSrcInfo::has_video_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtVidSrcInfo::set_has_video_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtVidSrcInfo::clear_has_video_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtVidSrcInfo::clear_video_width() {
  video_width_ = 0u;
  clear_has_video_width();
}
inline ::google::protobuf::uint32 TMtVidSrcInfo::video_width() const {
  return video_width_;
}
inline void TMtVidSrcInfo::set_video_width(::google::protobuf::uint32 value) {
  set_has_video_width();
  video_width_ = value;
}

// optional uint32 video_height = 4;
inline bool TMtVidSrcInfo::has_video_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtVidSrcInfo::set_has_video_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtVidSrcInfo::clear_has_video_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtVidSrcInfo::clear_video_height() {
  video_height_ = 0u;
  clear_has_video_height();
}
inline ::google::protobuf::uint32 TMtVidSrcInfo::video_height() const {
  return video_height_;
}
inline void TMtVidSrcInfo::set_video_height(::google::protobuf::uint32 value) {
  set_has_video_height();
  video_height_ = value;
}

// optional bool video_progressive = 5;
inline bool TMtVidSrcInfo::has_video_progressive() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtVidSrcInfo::set_has_video_progressive() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtVidSrcInfo::clear_has_video_progressive() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtVidSrcInfo::clear_video_progressive() {
  video_progressive_ = false;
  clear_has_video_progressive();
}
inline bool TMtVidSrcInfo::video_progressive() const {
  return video_progressive_;
}
inline void TMtVidSrcInfo::set_video_progressive(bool value) {
  set_has_video_progressive();
  video_progressive_ = value;
}

// optional uint32 frame_rate = 6;
inline bool TMtVidSrcInfo::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtVidSrcInfo::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtVidSrcInfo::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtVidSrcInfo::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TMtVidSrcInfo::frame_rate() const {
  return frame_rate_;
}
inline void TMtVidSrcInfo::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// -------------------------------------------------------------------

// TMtVidSrcInfoList

// repeated .mt.TMtVidSrcInfo video_src_status = 1;
inline int TMtVidSrcInfoList::video_src_status_size() const {
  return video_src_status_.size();
}
inline void TMtVidSrcInfoList::clear_video_src_status() {
  video_src_status_.Clear();
}
inline const ::mt::TMtVidSrcInfo& TMtVidSrcInfoList::video_src_status(int index) const {
  return video_src_status_.Get(index);
}
inline ::mt::TMtVidSrcInfo* TMtVidSrcInfoList::mutable_video_src_status(int index) {
  return video_src_status_.Mutable(index);
}
inline ::mt::TMtVidSrcInfo* TMtVidSrcInfoList::add_video_src_status() {
  return video_src_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtVidSrcInfo >&
TMtVidSrcInfoList::video_src_status() const {
  return video_src_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtVidSrcInfo >*
TMtVidSrcInfoList::mutable_video_src_status() {
  return &video_src_status_;
}

// -------------------------------------------------------------------

// TMtVidInPortResInfo

// optional .mt.EmMtVideoPort video_port = 1;
inline bool TMtVidInPortResInfo::has_video_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtVidInPortResInfo::set_has_video_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtVidInPortResInfo::clear_has_video_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtVidInPortResInfo::clear_video_port() {
  video_port_ = 0;
  clear_has_video_port();
}
inline ::mt::EmMtVideoPort TMtVidInPortResInfo::video_port() const {
  return static_cast< ::mt::EmMtVideoPort >(video_port_);
}
inline void TMtVidInPortResInfo::set_video_port(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  set_has_video_port();
  video_port_ = value;
}

// optional uint32 video_width = 2;
inline bool TMtVidInPortResInfo::has_video_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtVidInPortResInfo::set_has_video_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtVidInPortResInfo::clear_has_video_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtVidInPortResInfo::clear_video_width() {
  video_width_ = 0u;
  clear_has_video_width();
}
inline ::google::protobuf::uint32 TMtVidInPortResInfo::video_width() const {
  return video_width_;
}
inline void TMtVidInPortResInfo::set_video_width(::google::protobuf::uint32 value) {
  set_has_video_width();
  video_width_ = value;
}

// optional uint32 video_height = 3;
inline bool TMtVidInPortResInfo::has_video_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtVidInPortResInfo::set_has_video_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtVidInPortResInfo::clear_has_video_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtVidInPortResInfo::clear_video_height() {
  video_height_ = 0u;
  clear_has_video_height();
}
inline ::google::protobuf::uint32 TMtVidInPortResInfo::video_height() const {
  return video_height_;
}
inline void TMtVidInPortResInfo::set_video_height(::google::protobuf::uint32 value) {
  set_has_video_height();
  video_height_ = value;
}

// optional bool video_progressive = 4;
inline bool TMtVidInPortResInfo::has_video_progressive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtVidInPortResInfo::set_has_video_progressive() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtVidInPortResInfo::clear_has_video_progressive() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtVidInPortResInfo::clear_video_progressive() {
  video_progressive_ = false;
  clear_has_video_progressive();
}
inline bool TMtVidInPortResInfo::video_progressive() const {
  return video_progressive_;
}
inline void TMtVidInPortResInfo::set_video_progressive(bool value) {
  set_has_video_progressive();
  video_progressive_ = value;
}

// optional uint32 frame_rate = 5;
inline bool TMtVidInPortResInfo::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtVidInPortResInfo::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtVidInPortResInfo::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtVidInPortResInfo::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TMtVidInPortResInfo::frame_rate() const {
  return frame_rate_;
}
inline void TMtVidInPortResInfo::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// -------------------------------------------------------------------

// TMtVidInPortResInfoList

// repeated .mt.TMtVidInPortResInfo video_inport_status = 1;
inline int TMtVidInPortResInfoList::video_inport_status_size() const {
  return video_inport_status_.size();
}
inline void TMtVidInPortResInfoList::clear_video_inport_status() {
  video_inport_status_.Clear();
}
inline const ::mt::TMtVidInPortResInfo& TMtVidInPortResInfoList::video_inport_status(int index) const {
  return video_inport_status_.Get(index);
}
inline ::mt::TMtVidInPortResInfo* TMtVidInPortResInfoList::mutable_video_inport_status(int index) {
  return video_inport_status_.Mutable(index);
}
inline ::mt::TMtVidInPortResInfo* TMtVidInPortResInfoList::add_video_inport_status() {
  return video_inport_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtVidInPortResInfo >&
TMtVidInPortResInfoList::video_inport_status() const {
  return video_inport_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtVidInPortResInfo >*
TMtVidInPortResInfoList::mutable_video_inport_status() {
  return &video_inport_status_;
}

// -------------------------------------------------------------------

// TSnapshotFileInfo

// optional string file_path = 1;
inline bool TSnapshotFileInfo::has_file_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSnapshotFileInfo::set_has_file_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSnapshotFileInfo::clear_has_file_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSnapshotFileInfo::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& TSnapshotFileInfo::file_path() const {
  return *file_path_;
}
inline void TSnapshotFileInfo::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void TSnapshotFileInfo::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void TSnapshotFileInfo::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSnapshotFileInfo::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  return file_path_;
}
inline ::std::string* TSnapshotFileInfo::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSnapshotFileInfo::set_allocated_file_path(::std::string* file_path) {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    delete file_path_;
  }
  if (file_path) {
    set_has_file_path();
    file_path_ = file_path;
  } else {
    clear_has_file_path();
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string file_name = 2;
inline bool TSnapshotFileInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TSnapshotFileInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TSnapshotFileInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TSnapshotFileInfo::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& TSnapshotFileInfo::file_name() const {
  return *file_name_;
}
inline void TSnapshotFileInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TSnapshotFileInfo::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TSnapshotFileInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSnapshotFileInfo::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* TSnapshotFileInfo::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSnapshotFileInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTTime file_create_time = 3;
inline bool TSnapshotFileInfo::has_file_create_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TSnapshotFileInfo::set_has_file_create_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TSnapshotFileInfo::clear_has_file_create_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TSnapshotFileInfo::clear_file_create_time() {
  if (file_create_time_ != NULL) file_create_time_->::mt::TMTTime::Clear();
  clear_has_file_create_time();
}
inline const ::mt::TMTTime& TSnapshotFileInfo::file_create_time() const {
  return file_create_time_ != NULL ? *file_create_time_ : *default_instance_->file_create_time_;
}
inline ::mt::TMTTime* TSnapshotFileInfo::mutable_file_create_time() {
  set_has_file_create_time();
  if (file_create_time_ == NULL) file_create_time_ = new ::mt::TMTTime;
  return file_create_time_;
}
inline ::mt::TMTTime* TSnapshotFileInfo::release_file_create_time() {
  clear_has_file_create_time();
  ::mt::TMTTime* temp = file_create_time_;
  file_create_time_ = NULL;
  return temp;
}
inline void TSnapshotFileInfo::set_allocated_file_create_time(::mt::TMTTime* file_create_time) {
  delete file_create_time_;
  file_create_time_ = file_create_time;
  if (file_create_time) {
    set_has_file_create_time();
  } else {
    clear_has_file_create_time();
  }
}

// -------------------------------------------------------------------

// TSnapshotFileList

// repeated .mt.TSnapshotFileInfo file_list = 1;
inline int TSnapshotFileList::file_list_size() const {
  return file_list_.size();
}
inline void TSnapshotFileList::clear_file_list() {
  file_list_.Clear();
}
inline const ::mt::TSnapshotFileInfo& TSnapshotFileList::file_list(int index) const {
  return file_list_.Get(index);
}
inline ::mt::TSnapshotFileInfo* TSnapshotFileList::mutable_file_list(int index) {
  return file_list_.Mutable(index);
}
inline ::mt::TSnapshotFileInfo* TSnapshotFileList::add_file_list() {
  return file_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TSnapshotFileInfo >&
TSnapshotFileList::file_list() const {
  return file_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TSnapshotFileInfo >*
TSnapshotFileList::mutable_file_list() {
  return &file_list_;
}

// -------------------------------------------------------------------

// TMtTranspDColor

// optional uint32 rcolor = 1;
inline bool TMtTranspDColor::has_rcolor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtTranspDColor::set_has_rcolor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtTranspDColor::clear_has_rcolor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtTranspDColor::clear_rcolor() {
  rcolor_ = 0u;
  clear_has_rcolor();
}
inline ::google::protobuf::uint32 TMtTranspDColor::rcolor() const {
  return rcolor_;
}
inline void TMtTranspDColor::set_rcolor(::google::protobuf::uint32 value) {
  set_has_rcolor();
  rcolor_ = value;
}

// optional uint32 gcolor = 2;
inline bool TMtTranspDColor::has_gcolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtTranspDColor::set_has_gcolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtTranspDColor::clear_has_gcolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtTranspDColor::clear_gcolor() {
  gcolor_ = 0u;
  clear_has_gcolor();
}
inline ::google::protobuf::uint32 TMtTranspDColor::gcolor() const {
  return gcolor_;
}
inline void TMtTranspDColor::set_gcolor(::google::protobuf::uint32 value) {
  set_has_gcolor();
  gcolor_ = value;
}

// optional uint32 bcolor = 3;
inline bool TMtTranspDColor::has_bcolor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtTranspDColor::set_has_bcolor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtTranspDColor::clear_has_bcolor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtTranspDColor::clear_bcolor() {
  bcolor_ = 0u;
  clear_has_bcolor();
}
inline ::google::protobuf::uint32 TMtTranspDColor::bcolor() const {
  return bcolor_;
}
inline void TMtTranspDColor::set_bcolor(::google::protobuf::uint32 value) {
  set_has_bcolor();
  bcolor_ = value;
}

// optional uint32 transparency = 4;
inline bool TMtTranspDColor::has_transparency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtTranspDColor::set_has_transparency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtTranspDColor::clear_has_transparency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtTranspDColor::clear_transparency() {
  transparency_ = 0u;
  clear_has_transparency();
}
inline ::google::protobuf::uint32 TMtTranspDColor::transparency() const {
  return transparency_;
}
inline void TMtTranspDColor::set_transparency(::google::protobuf::uint32 value) {
  set_has_transparency();
  transparency_ = value;
}

// -------------------------------------------------------------------

// TMtAddLogoParam

// optional float xposrate = 1;
inline bool TMtAddLogoParam::has_xposrate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAddLogoParam::set_has_xposrate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAddLogoParam::clear_has_xposrate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAddLogoParam::clear_xposrate() {
  xposrate_ = 0;
  clear_has_xposrate();
}
inline float TMtAddLogoParam::xposrate() const {
  return xposrate_;
}
inline void TMtAddLogoParam::set_xposrate(float value) {
  set_has_xposrate();
  xposrate_ = value;
}

// optional float yposrate = 2;
inline bool TMtAddLogoParam::has_yposrate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAddLogoParam::set_has_yposrate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAddLogoParam::clear_has_yposrate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAddLogoParam::clear_yposrate() {
  yposrate_ = 0;
  clear_has_yposrate();
}
inline float TMtAddLogoParam::yposrate() const {
  return yposrate_;
}
inline void TMtAddLogoParam::set_yposrate(float value) {
  set_has_yposrate();
  yposrate_ = value;
}

// optional uint32 logobgwidth = 3;
inline bool TMtAddLogoParam::has_logobgwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtAddLogoParam::set_has_logobgwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtAddLogoParam::clear_has_logobgwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtAddLogoParam::clear_logobgwidth() {
  logobgwidth_ = 0u;
  clear_has_logobgwidth();
}
inline ::google::protobuf::uint32 TMtAddLogoParam::logobgwidth() const {
  return logobgwidth_;
}
inline void TMtAddLogoParam::set_logobgwidth(::google::protobuf::uint32 value) {
  set_has_logobgwidth();
  logobgwidth_ = value;
}

// optional uint32 logobgheigh = 4;
inline bool TMtAddLogoParam::has_logobgheigh() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtAddLogoParam::set_has_logobgheigh() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtAddLogoParam::clear_has_logobgheigh() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtAddLogoParam::clear_logobgheigh() {
  logobgheigh_ = 0u;
  clear_has_logobgheigh();
}
inline ::google::protobuf::uint32 TMtAddLogoParam::logobgheigh() const {
  return logobgheigh_;
}
inline void TMtAddLogoParam::set_logobgheigh(::google::protobuf::uint32 value) {
  set_has_logobgheigh();
  logobgheigh_ = value;
}

// optional .mt.TMtTranspDColor backbgdcolor = 5;
inline bool TMtAddLogoParam::has_backbgdcolor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtAddLogoParam::set_has_backbgdcolor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtAddLogoParam::clear_has_backbgdcolor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtAddLogoParam::clear_backbgdcolor() {
  if (backbgdcolor_ != NULL) backbgdcolor_->::mt::TMtTranspDColor::Clear();
  clear_has_backbgdcolor();
}
inline const ::mt::TMtTranspDColor& TMtAddLogoParam::backbgdcolor() const {
  return backbgdcolor_ != NULL ? *backbgdcolor_ : *default_instance_->backbgdcolor_;
}
inline ::mt::TMtTranspDColor* TMtAddLogoParam::mutable_backbgdcolor() {
  set_has_backbgdcolor();
  if (backbgdcolor_ == NULL) backbgdcolor_ = new ::mt::TMtTranspDColor;
  return backbgdcolor_;
}
inline ::mt::TMtTranspDColor* TMtAddLogoParam::release_backbgdcolor() {
  clear_has_backbgdcolor();
  ::mt::TMtTranspDColor* temp = backbgdcolor_;
  backbgdcolor_ = NULL;
  return temp;
}
inline void TMtAddLogoParam::set_allocated_backbgdcolor(::mt::TMtTranspDColor* backbgdcolor) {
  delete backbgdcolor_;
  backbgdcolor_ = backbgdcolor;
  if (backbgdcolor) {
    set_has_backbgdcolor();
  } else {
    clear_has_backbgdcolor();
  }
}

// -------------------------------------------------------------------

// TMtFullLogoParam

// optional string bmp_path = 1;
inline bool TMtFullLogoParam::has_bmp_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtFullLogoParam::set_has_bmp_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtFullLogoParam::clear_has_bmp_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtFullLogoParam::clear_bmp_path() {
  if (bmp_path_ != &::google::protobuf::internal::kEmptyString) {
    bmp_path_->clear();
  }
  clear_has_bmp_path();
}
inline const ::std::string& TMtFullLogoParam::bmp_path() const {
  return *bmp_path_;
}
inline void TMtFullLogoParam::set_bmp_path(const ::std::string& value) {
  set_has_bmp_path();
  if (bmp_path_ == &::google::protobuf::internal::kEmptyString) {
    bmp_path_ = new ::std::string;
  }
  bmp_path_->assign(value);
}
inline void TMtFullLogoParam::set_bmp_path(const char* value) {
  set_has_bmp_path();
  if (bmp_path_ == &::google::protobuf::internal::kEmptyString) {
    bmp_path_ = new ::std::string;
  }
  bmp_path_->assign(value);
}
inline void TMtFullLogoParam::set_bmp_path(const char* value, size_t size) {
  set_has_bmp_path();
  if (bmp_path_ == &::google::protobuf::internal::kEmptyString) {
    bmp_path_ = new ::std::string;
  }
  bmp_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtFullLogoParam::mutable_bmp_path() {
  set_has_bmp_path();
  if (bmp_path_ == &::google::protobuf::internal::kEmptyString) {
    bmp_path_ = new ::std::string;
  }
  return bmp_path_;
}
inline ::std::string* TMtFullLogoParam::release_bmp_path() {
  clear_has_bmp_path();
  if (bmp_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bmp_path_;
    bmp_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtFullLogoParam::set_allocated_bmp_path(::std::string* bmp_path) {
  if (bmp_path_ != &::google::protobuf::internal::kEmptyString) {
    delete bmp_path_;
  }
  if (bmp_path) {
    set_has_bmp_path();
    bmp_path_ = bmp_path;
  } else {
    clear_has_bmp_path();
    bmp_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMtAddLogoParam logoparam = 3;
inline bool TMtFullLogoParam::has_logoparam() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtFullLogoParam::set_has_logoparam() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtFullLogoParam::clear_has_logoparam() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtFullLogoParam::clear_logoparam() {
  if (logoparam_ != NULL) logoparam_->::mt::TMtAddLogoParam::Clear();
  clear_has_logoparam();
}
inline const ::mt::TMtAddLogoParam& TMtFullLogoParam::logoparam() const {
  return logoparam_ != NULL ? *logoparam_ : *default_instance_->logoparam_;
}
inline ::mt::TMtAddLogoParam* TMtFullLogoParam::mutable_logoparam() {
  set_has_logoparam();
  if (logoparam_ == NULL) logoparam_ = new ::mt::TMtAddLogoParam;
  return logoparam_;
}
inline ::mt::TMtAddLogoParam* TMtFullLogoParam::release_logoparam() {
  clear_has_logoparam();
  ::mt::TMtAddLogoParam* temp = logoparam_;
  logoparam_ = NULL;
  return temp;
}
inline void TMtFullLogoParam::set_allocated_logoparam(::mt::TMtAddLogoParam* logoparam) {
  delete logoparam_;
  logoparam_ = logoparam;
  if (logoparam) {
    set_has_logoparam();
  } else {
    clear_has_logoparam();
  }
}

// -------------------------------------------------------------------

// TRpMtFullLogoParam

// repeated .mt.TMtFullLogoParam fulllogoparam = 1;
inline int TRpMtFullLogoParam::fulllogoparam_size() const {
  return fulllogoparam_.size();
}
inline void TRpMtFullLogoParam::clear_fulllogoparam() {
  fulllogoparam_.Clear();
}
inline const ::mt::TMtFullLogoParam& TRpMtFullLogoParam::fulllogoparam(int index) const {
  return fulllogoparam_.Get(index);
}
inline ::mt::TMtFullLogoParam* TRpMtFullLogoParam::mutable_fulllogoparam(int index) {
  return fulllogoparam_.Mutable(index);
}
inline ::mt::TMtFullLogoParam* TRpMtFullLogoParam::add_fulllogoparam() {
  return fulllogoparam_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtFullLogoParam >&
TRpMtFullLogoParam::fulllogoparam() const {
  return fulllogoparam_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtFullLogoParam >*
TRpMtFullLogoParam::mutable_fulllogoparam() {
  return &fulllogoparam_;
}

// -------------------------------------------------------------------

// TMtPIPMode

// optional .mt.EmPiPMode pip_mode = 1;
inline bool TMtPIPMode::has_pip_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtPIPMode::set_has_pip_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtPIPMode::clear_has_pip_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtPIPMode::clear_pip_mode() {
  pip_mode_ = 0;
  clear_has_pip_mode();
}
inline ::mt::EmPiPMode TMtPIPMode::pip_mode() const {
  return static_cast< ::mt::EmPiPMode >(pip_mode_);
}
inline void TMtPIPMode::set_pip_mode(::mt::EmPiPMode value) {
  assert(::mt::EmPiPMode_IsValid(value));
  set_has_pip_mode();
  pip_mode_ = value;
}

// -------------------------------------------------------------------

// TMTVideoInOutPortModeList

// repeated .mt.TMTVidInPortMode tInPortMode = 1;
inline int TMTVideoInOutPortModeList::tinportmode_size() const {
  return tinportmode_.size();
}
inline void TMTVideoInOutPortModeList::clear_tinportmode() {
  tinportmode_.Clear();
}
inline const ::mt::TMTVidInPortMode& TMTVideoInOutPortModeList::tinportmode(int index) const {
  return tinportmode_.Get(index);
}
inline ::mt::TMTVidInPortMode* TMTVideoInOutPortModeList::mutable_tinportmode(int index) {
  return tinportmode_.Mutable(index);
}
inline ::mt::TMTVidInPortMode* TMTVideoInOutPortModeList::add_tinportmode() {
  return tinportmode_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidInPortMode >&
TMTVideoInOutPortModeList::tinportmode() const {
  return tinportmode_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidInPortMode >*
TMTVideoInOutPortModeList::mutable_tinportmode() {
  return &tinportmode_;
}

// repeated .mt.TMTVidOutPortMode tOutPortMode = 2;
inline int TMTVideoInOutPortModeList::toutportmode_size() const {
  return toutportmode_.size();
}
inline void TMTVideoInOutPortModeList::clear_toutportmode() {
  toutportmode_.Clear();
}
inline const ::mt::TMTVidOutPortMode& TMTVideoInOutPortModeList::toutportmode(int index) const {
  return toutportmode_.Get(index);
}
inline ::mt::TMTVidOutPortMode* TMTVideoInOutPortModeList::mutable_toutportmode(int index) {
  return toutportmode_.Mutable(index);
}
inline ::mt::TMTVidOutPortMode* TMTVideoInOutPortModeList::add_toutportmode() {
  return toutportmode_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidOutPortMode >&
TMTVideoInOutPortModeList::toutportmode() const {
  return toutportmode_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidOutPortMode >*
TMTVideoInOutPortModeList::mutable_toutportmode() {
  return &toutportmode_;
}

// -------------------------------------------------------------------

// TAddRecordAudioMediaInfo

// optional uint32 StreamType = 1;
inline bool TAddRecordAudioMediaInfo::has_streamtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAddRecordAudioMediaInfo::set_has_streamtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAddRecordAudioMediaInfo::clear_has_streamtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAddRecordAudioMediaInfo::clear_streamtype() {
  streamtype_ = 0u;
  clear_has_streamtype();
}
inline ::google::protobuf::uint32 TAddRecordAudioMediaInfo::streamtype() const {
  return streamtype_;
}
inline void TAddRecordAudioMediaInfo::set_streamtype(::google::protobuf::uint32 value) {
  set_has_streamtype();
  streamtype_ = value;
}

// optional uint32 StreamNumber = 2;
inline bool TAddRecordAudioMediaInfo::has_streamnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAddRecordAudioMediaInfo::set_has_streamnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAddRecordAudioMediaInfo::clear_has_streamnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAddRecordAudioMediaInfo::clear_streamnumber() {
  streamnumber_ = 0u;
  clear_has_streamnumber();
}
inline ::google::protobuf::uint32 TAddRecordAudioMediaInfo::streamnumber() const {
  return streamnumber_;
}
inline void TAddRecordAudioMediaInfo::set_streamnumber(::google::protobuf::uint32 value) {
  set_has_streamnumber();
  streamnumber_ = value;
}

// optional uint32 AverageBitrate = 3;
inline bool TAddRecordAudioMediaInfo::has_averagebitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAddRecordAudioMediaInfo::set_has_averagebitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAddRecordAudioMediaInfo::clear_has_averagebitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAddRecordAudioMediaInfo::clear_averagebitrate() {
  averagebitrate_ = 0u;
  clear_has_averagebitrate();
}
inline ::google::protobuf::uint32 TAddRecordAudioMediaInfo::averagebitrate() const {
  return averagebitrate_;
}
inline void TAddRecordAudioMediaInfo::set_averagebitrate(::google::protobuf::uint32 value) {
  set_has_averagebitrate();
  averagebitrate_ = value;
}

// optional uint32 CodecID_FormatTag = 4;
inline bool TAddRecordAudioMediaInfo::has_codecid_formattag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAddRecordAudioMediaInfo::set_has_codecid_formattag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAddRecordAudioMediaInfo::clear_has_codecid_formattag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAddRecordAudioMediaInfo::clear_codecid_formattag() {
  codecid_formattag_ = 0u;
  clear_has_codecid_formattag();
}
inline ::google::protobuf::uint32 TAddRecordAudioMediaInfo::codecid_formattag() const {
  return codecid_formattag_;
}
inline void TAddRecordAudioMediaInfo::set_codecid_formattag(::google::protobuf::uint32 value) {
  set_has_codecid_formattag();
  codecid_formattag_ = value;
}

// optional uint32 NumberOfChannels = 5;
inline bool TAddRecordAudioMediaInfo::has_numberofchannels() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TAddRecordAudioMediaInfo::set_has_numberofchannels() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TAddRecordAudioMediaInfo::clear_has_numberofchannels() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TAddRecordAudioMediaInfo::clear_numberofchannels() {
  numberofchannels_ = 0u;
  clear_has_numberofchannels();
}
inline ::google::protobuf::uint32 TAddRecordAudioMediaInfo::numberofchannels() const {
  return numberofchannels_;
}
inline void TAddRecordAudioMediaInfo::set_numberofchannels(::google::protobuf::uint32 value) {
  set_has_numberofchannels();
  numberofchannels_ = value;
}

// optional uint32 SamplesPerSecond = 6;
inline bool TAddRecordAudioMediaInfo::has_samplespersecond() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TAddRecordAudioMediaInfo::set_has_samplespersecond() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TAddRecordAudioMediaInfo::clear_has_samplespersecond() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TAddRecordAudioMediaInfo::clear_samplespersecond() {
  samplespersecond_ = 0u;
  clear_has_samplespersecond();
}
inline ::google::protobuf::uint32 TAddRecordAudioMediaInfo::samplespersecond() const {
  return samplespersecond_;
}
inline void TAddRecordAudioMediaInfo::set_samplespersecond(::google::protobuf::uint32 value) {
  set_has_samplespersecond();
  samplespersecond_ = value;
}

// optional uint32 AverageNumberOfBytesPerSecond = 7;
inline bool TAddRecordAudioMediaInfo::has_averagenumberofbytespersecond() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TAddRecordAudioMediaInfo::set_has_averagenumberofbytespersecond() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TAddRecordAudioMediaInfo::clear_has_averagenumberofbytespersecond() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TAddRecordAudioMediaInfo::clear_averagenumberofbytespersecond() {
  averagenumberofbytespersecond_ = 0u;
  clear_has_averagenumberofbytespersecond();
}
inline ::google::protobuf::uint32 TAddRecordAudioMediaInfo::averagenumberofbytespersecond() const {
  return averagenumberofbytespersecond_;
}
inline void TAddRecordAudioMediaInfo::set_averagenumberofbytespersecond(::google::protobuf::uint32 value) {
  set_has_averagenumberofbytespersecond();
  averagenumberofbytespersecond_ = value;
}

// optional uint32 FrameRate = 8;
inline bool TAddRecordAudioMediaInfo::has_framerate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TAddRecordAudioMediaInfo::set_has_framerate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TAddRecordAudioMediaInfo::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TAddRecordAudioMediaInfo::clear_framerate() {
  framerate_ = 0u;
  clear_has_framerate();
}
inline ::google::protobuf::uint32 TAddRecordAudioMediaInfo::framerate() const {
  return framerate_;
}
inline void TAddRecordAudioMediaInfo::set_framerate(::google::protobuf::uint32 value) {
  set_has_framerate();
  framerate_ = value;
}

// -------------------------------------------------------------------

// TAddRecordVideoMediaInfo

// optional uint32 StreamType = 1;
inline bool TAddRecordVideoMediaInfo::has_streamtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAddRecordVideoMediaInfo::set_has_streamtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAddRecordVideoMediaInfo::clear_has_streamtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAddRecordVideoMediaInfo::clear_streamtype() {
  streamtype_ = 0u;
  clear_has_streamtype();
}
inline ::google::protobuf::uint32 TAddRecordVideoMediaInfo::streamtype() const {
  return streamtype_;
}
inline void TAddRecordVideoMediaInfo::set_streamtype(::google::protobuf::uint32 value) {
  set_has_streamtype();
  streamtype_ = value;
}

// optional uint32 StreamNumber = 2;
inline bool TAddRecordVideoMediaInfo::has_streamnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAddRecordVideoMediaInfo::set_has_streamnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAddRecordVideoMediaInfo::clear_has_streamnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAddRecordVideoMediaInfo::clear_streamnumber() {
  streamnumber_ = 0u;
  clear_has_streamnumber();
}
inline ::google::protobuf::uint32 TAddRecordVideoMediaInfo::streamnumber() const {
  return streamnumber_;
}
inline void TAddRecordVideoMediaInfo::set_streamnumber(::google::protobuf::uint32 value) {
  set_has_streamnumber();
  streamnumber_ = value;
}

// optional uint32 AverageBitrate = 3;
inline bool TAddRecordVideoMediaInfo::has_averagebitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAddRecordVideoMediaInfo::set_has_averagebitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAddRecordVideoMediaInfo::clear_has_averagebitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAddRecordVideoMediaInfo::clear_averagebitrate() {
  averagebitrate_ = 0u;
  clear_has_averagebitrate();
}
inline ::google::protobuf::uint32 TAddRecordVideoMediaInfo::averagebitrate() const {
  return averagebitrate_;
}
inline void TAddRecordVideoMediaInfo::set_averagebitrate(::google::protobuf::uint32 value) {
  set_has_averagebitrate();
  averagebitrate_ = value;
}

// optional uint32 EncodedImageWidth = 4;
inline bool TAddRecordVideoMediaInfo::has_encodedimagewidth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAddRecordVideoMediaInfo::set_has_encodedimagewidth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAddRecordVideoMediaInfo::clear_has_encodedimagewidth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAddRecordVideoMediaInfo::clear_encodedimagewidth() {
  encodedimagewidth_ = 0u;
  clear_has_encodedimagewidth();
}
inline ::google::protobuf::uint32 TAddRecordVideoMediaInfo::encodedimagewidth() const {
  return encodedimagewidth_;
}
inline void TAddRecordVideoMediaInfo::set_encodedimagewidth(::google::protobuf::uint32 value) {
  set_has_encodedimagewidth();
  encodedimagewidth_ = value;
}

// optional uint32 EncodedImageHeight = 5;
inline bool TAddRecordVideoMediaInfo::has_encodedimageheight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TAddRecordVideoMediaInfo::set_has_encodedimageheight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TAddRecordVideoMediaInfo::clear_has_encodedimageheight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TAddRecordVideoMediaInfo::clear_encodedimageheight() {
  encodedimageheight_ = 0u;
  clear_has_encodedimageheight();
}
inline ::google::protobuf::uint32 TAddRecordVideoMediaInfo::encodedimageheight() const {
  return encodedimageheight_;
}
inline void TAddRecordVideoMediaInfo::set_encodedimageheight(::google::protobuf::uint32 value) {
  set_has_encodedimageheight();
  encodedimageheight_ = value;
}

// optional uint32 CompressionID = 6;
inline bool TAddRecordVideoMediaInfo::has_compressionid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TAddRecordVideoMediaInfo::set_has_compressionid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TAddRecordVideoMediaInfo::clear_has_compressionid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TAddRecordVideoMediaInfo::clear_compressionid() {
  compressionid_ = 0u;
  clear_has_compressionid();
}
inline ::google::protobuf::uint32 TAddRecordVideoMediaInfo::compressionid() const {
  return compressionid_;
}
inline void TAddRecordVideoMediaInfo::set_compressionid(::google::protobuf::uint32 value) {
  set_has_compressionid();
  compressionid_ = value;
}

// optional uint32 FrameRate = 7;
inline bool TAddRecordVideoMediaInfo::has_framerate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TAddRecordVideoMediaInfo::set_has_framerate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TAddRecordVideoMediaInfo::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TAddRecordVideoMediaInfo::clear_framerate() {
  framerate_ = 0u;
  clear_has_framerate();
}
inline ::google::protobuf::uint32 TAddRecordVideoMediaInfo::framerate() const {
  return framerate_;
}
inline void TAddRecordVideoMediaInfo::set_framerate(::google::protobuf::uint32 value) {
  set_has_framerate();
  framerate_ = value;
}

// -------------------------------------------------------------------

// TWriteRecord

// optional uint32 StreamNumber = 1;
inline bool TWriteRecord::has_streamnumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWriteRecord::set_has_streamnumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWriteRecord::clear_has_streamnumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWriteRecord::clear_streamnumber() {
  streamnumber_ = 0u;
  clear_has_streamnumber();
}
inline ::google::protobuf::uint32 TWriteRecord::streamnumber() const {
  return streamnumber_;
}
inline void TWriteRecord::set_streamnumber(::google::protobuf::uint32 value) {
  set_has_streamnumber();
  streamnumber_ = value;
}

// optional uint32 MediaType = 2;
inline bool TWriteRecord::has_mediatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWriteRecord::set_has_mediatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWriteRecord::clear_has_mediatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWriteRecord::clear_mediatype() {
  mediatype_ = 0u;
  clear_has_mediatype();
}
inline ::google::protobuf::uint32 TWriteRecord::mediatype() const {
  return mediatype_;
}
inline void TWriteRecord::set_mediatype(::google::protobuf::uint32 value) {
  set_has_mediatype();
  mediatype_ = value;
}

// optional bool KeyFrame = 5;
inline bool TWriteRecord::has_keyframe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TWriteRecord::set_has_keyframe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TWriteRecord::clear_has_keyframe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TWriteRecord::clear_keyframe() {
  keyframe_ = false;
  clear_has_keyframe();
}
inline bool TWriteRecord::keyframe() const {
  return keyframe_;
}
inline void TWriteRecord::set_keyframe(bool value) {
  set_has_keyframe();
  keyframe_ = value;
}

// optional uint32 BufferSize = 4;
inline bool TWriteRecord::has_buffersize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TWriteRecord::set_has_buffersize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TWriteRecord::clear_has_buffersize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TWriteRecord::clear_buffersize() {
  buffersize_ = 0u;
  clear_has_buffersize();
}
inline ::google::protobuf::uint32 TWriteRecord::buffersize() const {
  return buffersize_;
}
inline void TWriteRecord::set_buffersize(::google::protobuf::uint32 value) {
  set_has_buffersize();
  buffersize_ = value;
}

// optional uint32 DataBuffer = 3;
inline bool TWriteRecord::has_databuffer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TWriteRecord::set_has_databuffer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TWriteRecord::clear_has_databuffer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TWriteRecord::clear_databuffer() {
  databuffer_ = 0u;
  clear_has_databuffer();
}
inline ::google::protobuf::uint32 TWriteRecord::databuffer() const {
  return databuffer_;
}
inline void TWriteRecord::set_databuffer(::google::protobuf::uint32 value) {
  set_has_databuffer();
  databuffer_ = value;
}

// -------------------------------------------------------------------

// TMtCameraVidStd

// optional .mt.EmCameraVidStd camera_vid_std = 1;
inline bool TMtCameraVidStd::has_camera_vid_std() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtCameraVidStd::set_has_camera_vid_std() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtCameraVidStd::clear_has_camera_vid_std() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtCameraVidStd::clear_camera_vid_std() {
  camera_vid_std_ = 0;
  clear_has_camera_vid_std();
}
inline ::mt::EmCameraVidStd TMtCameraVidStd::camera_vid_std() const {
  return static_cast< ::mt::EmCameraVidStd >(camera_vid_std_);
}
inline void TMtCameraVidStd::set_camera_vid_std(::mt::EmCameraVidStd value) {
  assert(::mt::EmCameraVidStd_IsValid(value));
  set_has_camera_vid_std();
  camera_vid_std_ = value;
}

// optional string vid_std_name = 2;
inline bool TMtCameraVidStd::has_vid_std_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtCameraVidStd::set_has_vid_std_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtCameraVidStd::clear_has_vid_std_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtCameraVidStd::clear_vid_std_name() {
  if (vid_std_name_ != &::google::protobuf::internal::kEmptyString) {
    vid_std_name_->clear();
  }
  clear_has_vid_std_name();
}
inline const ::std::string& TMtCameraVidStd::vid_std_name() const {
  return *vid_std_name_;
}
inline void TMtCameraVidStd::set_vid_std_name(const ::std::string& value) {
  set_has_vid_std_name();
  if (vid_std_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_std_name_ = new ::std::string;
  }
  vid_std_name_->assign(value);
}
inline void TMtCameraVidStd::set_vid_std_name(const char* value) {
  set_has_vid_std_name();
  if (vid_std_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_std_name_ = new ::std::string;
  }
  vid_std_name_->assign(value);
}
inline void TMtCameraVidStd::set_vid_std_name(const char* value, size_t size) {
  set_has_vid_std_name();
  if (vid_std_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_std_name_ = new ::std::string;
  }
  vid_std_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCameraVidStd::mutable_vid_std_name() {
  set_has_vid_std_name();
  if (vid_std_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_std_name_ = new ::std::string;
  }
  return vid_std_name_;
}
inline ::std::string* TMtCameraVidStd::release_vid_std_name() {
  clear_has_vid_std_name();
  if (vid_std_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vid_std_name_;
    vid_std_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCameraVidStd::set_allocated_vid_std_name(::std::string* vid_std_name) {
  if (vid_std_name_ != &::google::protobuf::internal::kEmptyString) {
    delete vid_std_name_;
  }
  if (vid_std_name) {
    set_has_vid_std_name();
    vid_std_name_ = vid_std_name;
  } else {
    clear_has_vid_std_name();
    vid_std_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtHwChipInfo

// optional .mt.EmMtChipType mt_chip_type = 1;
inline bool TMtHwChipInfo::has_mt_chip_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtHwChipInfo::set_has_mt_chip_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtHwChipInfo::clear_has_mt_chip_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtHwChipInfo::clear_mt_chip_type() {
  mt_chip_type_ = 0;
  clear_has_mt_chip_type();
}
inline ::mt::EmMtChipType TMtHwChipInfo::mt_chip_type() const {
  return static_cast< ::mt::EmMtChipType >(mt_chip_type_);
}
inline void TMtHwChipInfo::set_mt_chip_type(::mt::EmMtChipType value) {
  assert(::mt::EmMtChipType_IsValid(value));
  set_has_mt_chip_type();
  mt_chip_type_ = value;
}

// optional uint32 chip_status = 2;
inline bool TMtHwChipInfo::has_chip_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtHwChipInfo::set_has_chip_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtHwChipInfo::clear_has_chip_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtHwChipInfo::clear_chip_status() {
  chip_status_ = 0u;
  clear_has_chip_status();
}
inline ::google::protobuf::uint32 TMtHwChipInfo::chip_status() const {
  return chip_status_;
}
inline void TMtHwChipInfo::set_chip_status(::google::protobuf::uint32 value) {
  set_has_chip_status();
  chip_status_ = value;
}

// -------------------------------------------------------------------

// TMtHwChipInfoList

// repeated .mt.TMtHwChipInfo hw_chip_info = 1;
inline int TMtHwChipInfoList::hw_chip_info_size() const {
  return hw_chip_info_.size();
}
inline void TMtHwChipInfoList::clear_hw_chip_info() {
  hw_chip_info_.Clear();
}
inline const ::mt::TMtHwChipInfo& TMtHwChipInfoList::hw_chip_info(int index) const {
  return hw_chip_info_.Get(index);
}
inline ::mt::TMtHwChipInfo* TMtHwChipInfoList::mutable_hw_chip_info(int index) {
  return hw_chip_info_.Mutable(index);
}
inline ::mt::TMtHwChipInfo* TMtHwChipInfoList::add_hw_chip_info() {
  return hw_chip_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtHwChipInfo >&
TMtHwChipInfoList::hw_chip_info() const {
  return hw_chip_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtHwChipInfo >*
TMtHwChipInfoList::mutable_hw_chip_info() {
  return &hw_chip_info_;
}

// -------------------------------------------------------------------

// TMtQkState

// optional uint32 qk_id = 1;
inline bool TMtQkState::has_qk_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtQkState::set_has_qk_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtQkState::clear_has_qk_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtQkState::clear_qk_id() {
  qk_id_ = 0u;
  clear_has_qk_id();
}
inline ::google::protobuf::uint32 TMtQkState::qk_id() const {
  return qk_id_;
}
inline void TMtQkState::set_qk_id(::google::protobuf::uint32 value) {
  set_has_qk_id();
  qk_id_ = value;
}

// optional .mt.EmQkState state = 2;
inline bool TMtQkState::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtQkState::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtQkState::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtQkState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::mt::EmQkState TMtQkState::state() const {
  return static_cast< ::mt::EmQkState >(state_);
}
inline void TMtQkState::set_state(::mt::EmQkState value) {
  assert(::mt::EmQkState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string pc_name = 3;
inline bool TMtQkState::has_pc_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtQkState::set_has_pc_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtQkState::clear_has_pc_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtQkState::clear_pc_name() {
  if (pc_name_ != &::google::protobuf::internal::kEmptyString) {
    pc_name_->clear();
  }
  clear_has_pc_name();
}
inline const ::std::string& TMtQkState::pc_name() const {
  return *pc_name_;
}
inline void TMtQkState::set_pc_name(const ::std::string& value) {
  set_has_pc_name();
  if (pc_name_ == &::google::protobuf::internal::kEmptyString) {
    pc_name_ = new ::std::string;
  }
  pc_name_->assign(value);
}
inline void TMtQkState::set_pc_name(const char* value) {
  set_has_pc_name();
  if (pc_name_ == &::google::protobuf::internal::kEmptyString) {
    pc_name_ = new ::std::string;
  }
  pc_name_->assign(value);
}
inline void TMtQkState::set_pc_name(const char* value, size_t size) {
  set_has_pc_name();
  if (pc_name_ == &::google::protobuf::internal::kEmptyString) {
    pc_name_ = new ::std::string;
  }
  pc_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtQkState::mutable_pc_name() {
  set_has_pc_name();
  if (pc_name_ == &::google::protobuf::internal::kEmptyString) {
    pc_name_ = new ::std::string;
  }
  return pc_name_;
}
inline ::std::string* TMtQkState::release_pc_name() {
  clear_has_pc_name();
  if (pc_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pc_name_;
    pc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtQkState::set_allocated_pc_name(::std::string* pc_name) {
  if (pc_name_ != &::google::protobuf::internal::kEmptyString) {
    delete pc_name_;
  }
  if (pc_name) {
    set_has_pc_name();
    pc_name_ = pc_name;
  } else {
    clear_has_pc_name();
    pc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 4;
inline bool TMtQkState::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtQkState::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtQkState::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtQkState::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TMtQkState::version() const {
  return *version_;
}
inline void TMtQkState::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TMtQkState::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TMtQkState::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtQkState::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* TMtQkState::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtQkState::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TVidInputState

// optional .mt.EmMtVideoPort video_port = 1;
inline bool TVidInputState::has_video_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVidInputState::set_has_video_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVidInputState::clear_has_video_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVidInputState::clear_video_port() {
  video_port_ = 0;
  clear_has_video_port();
}
inline ::mt::EmMtVideoPort TVidInputState::video_port() const {
  return static_cast< ::mt::EmMtVideoPort >(video_port_);
}
inline void TVidInputState::set_video_port(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  set_has_video_port();
  video_port_ = value;
}

// optional bool bUsed = 2;
inline bool TVidInputState::has_bused() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVidInputState::set_has_bused() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVidInputState::clear_has_bused() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVidInputState::clear_bused() {
  bused_ = false;
  clear_has_bused();
}
inline bool TVidInputState::bused() const {
  return bused_;
}
inline void TVidInputState::set_bused(bool value) {
  set_has_bused();
  bused_ = value;
}

// -------------------------------------------------------------------

// TMtNtfAgentSignalInfo

// repeated .mt.TAudInputState aud_in_list = 1;
inline int TMtNtfAgentSignalInfo::aud_in_list_size() const {
  return aud_in_list_.size();
}
inline void TMtNtfAgentSignalInfo::clear_aud_in_list() {
  aud_in_list_.Clear();
}
inline const ::mt::TAudInputState& TMtNtfAgentSignalInfo::aud_in_list(int index) const {
  return aud_in_list_.Get(index);
}
inline ::mt::TAudInputState* TMtNtfAgentSignalInfo::mutable_aud_in_list(int index) {
  return aud_in_list_.Mutable(index);
}
inline ::mt::TAudInputState* TMtNtfAgentSignalInfo::add_aud_in_list() {
  return aud_in_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudInputState >&
TMtNtfAgentSignalInfo::aud_in_list() const {
  return aud_in_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudInputState >*
TMtNtfAgentSignalInfo::mutable_aud_in_list() {
  return &aud_in_list_;
}

// repeated .mt.TAudOutputState aud_out_list = 2;
inline int TMtNtfAgentSignalInfo::aud_out_list_size() const {
  return aud_out_list_.size();
}
inline void TMtNtfAgentSignalInfo::clear_aud_out_list() {
  aud_out_list_.Clear();
}
inline const ::mt::TAudOutputState& TMtNtfAgentSignalInfo::aud_out_list(int index) const {
  return aud_out_list_.Get(index);
}
inline ::mt::TAudOutputState* TMtNtfAgentSignalInfo::mutable_aud_out_list(int index) {
  return aud_out_list_.Mutable(index);
}
inline ::mt::TAudOutputState* TMtNtfAgentSignalInfo::add_aud_out_list() {
  return aud_out_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudOutputState >&
TMtNtfAgentSignalInfo::aud_out_list() const {
  return aud_out_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudOutputState >*
TMtNtfAgentSignalInfo::mutable_aud_out_list() {
  return &aud_out_list_;
}

// repeated .mt.TVidInputState vid_in_list = 3;
inline int TMtNtfAgentSignalInfo::vid_in_list_size() const {
  return vid_in_list_.size();
}
inline void TMtNtfAgentSignalInfo::clear_vid_in_list() {
  vid_in_list_.Clear();
}
inline const ::mt::TVidInputState& TMtNtfAgentSignalInfo::vid_in_list(int index) const {
  return vid_in_list_.Get(index);
}
inline ::mt::TVidInputState* TMtNtfAgentSignalInfo::mutable_vid_in_list(int index) {
  return vid_in_list_.Mutable(index);
}
inline ::mt::TVidInputState* TMtNtfAgentSignalInfo::add_vid_in_list() {
  return vid_in_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidInputState >&
TMtNtfAgentSignalInfo::vid_in_list() const {
  return vid_in_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidInputState >*
TMtNtfAgentSignalInfo::mutable_vid_in_list() {
  return &vid_in_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mt

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_structmp_2eproto__INCLUDED
