// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structdevice.proto

#ifndef PROTOBUF_structdevice_2eproto__INCLUDED
#define PROTOBUF_structdevice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "enum.pb.h"
// @@protoc_insertion_point(includes)

namespace mt {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
void protobuf_AssignDesc_structdevice_2eproto();
void protobuf_ShutdownFile_structdevice_2eproto();

class TMTCameraUpgrade;
class TMTCameraTypeInfo;
class TMTCameraTypeList;
class TMTCpuAndMemState;
class TMTCameraPresetPicList;
class TMTVidSrc2FarCtrlId;
class TMTVidSrc2FarCtrlIdGroup;
class TMTVidSrc2FarCtrlIdList;
class TMTUsbPartition;
class TMTUsbInfo;
class TMTUsbStatus;
class TMTPathStructureUnit;
class TMTPathStructureDetail;
class TMTBrdInfo;
class TMTMicStatus;
class TMTMicInfo;
class TMicUpgradeState;
class TMicUpgradeStateList;
class TMicInstall;
class TMicInstallList;
class TMTRfMatchState;
class TMTRfMatchStateList;
class TMTMicDecibel;
class TMicVersionInfo;
class TMicVersionList;
class TNetCapFileInfo;
class TNetCapFileList;
class TFpgaVersionList;
class TCameraImageParam;
class TCameraIspParam;
class TSerialOptParam;
class TCameraSceneModeCapList;
class TMTMicTag;
class TMTMicTagList;

// ===================================================================

class MTMSG_API TMTCameraUpgrade : public ::google::protobuf::Message {
 public:
  TMTCameraUpgrade();
  virtual ~TMTCameraUpgrade();

  TMTCameraUpgrade(const TMTCameraUpgrade& from);

  inline TMTCameraUpgrade& operator=(const TMTCameraUpgrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCameraUpgrade& default_instance();

  void Swap(TMTCameraUpgrade* other);

  // implements Message ----------------------------------------------

  TMTCameraUpgrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCameraUpgrade& from);
  void MergeFrom(const TMTCameraUpgrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmEquipmentUpgrading camera_type = 1;
  inline bool has_camera_type() const;
  inline void clear_camera_type();
  static const int kCameraTypeFieldNumber = 1;
  inline ::mt::EmEquipmentUpgrading camera_type() const;
  inline void set_camera_type(::mt::EmEquipmentUpgrading value);

  // optional bool action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline bool action() const;
  inline void set_action(bool value);

  // optional string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // @@protoc_insertion_point(class_scope:mt.TMTCameraUpgrade)
 private:
  inline void set_has_camera_type();
  inline void clear_has_camera_type();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_file_name();
  inline void clear_has_file_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int camera_type_;
  bool action_;
  ::std::string* file_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTCameraUpgrade* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCameraTypeInfo : public ::google::protobuf::Message {
 public:
  TMTCameraTypeInfo();
  virtual ~TMTCameraTypeInfo();

  TMTCameraTypeInfo(const TMTCameraTypeInfo& from);

  inline TMTCameraTypeInfo& operator=(const TMTCameraTypeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCameraTypeInfo& default_instance();

  void Swap(TMTCameraTypeInfo* other);

  // implements Message ----------------------------------------------

  TMTCameraTypeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCameraTypeInfo& from);
  void MergeFrom(const TMTCameraTypeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 max_addr = 2;
  inline bool has_max_addr() const;
  inline void clear_max_addr();
  static const int kMaxAddrFieldNumber = 2;
  inline ::google::protobuf::uint32 max_addr() const;
  inline void set_max_addr(::google::protobuf::uint32 value);

  // optional uint32 max_speed_level = 3;
  inline bool has_max_speed_level() const;
  inline void clear_max_speed_level();
  static const int kMaxSpeedLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 max_speed_level() const;
  inline void set_max_speed_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTCameraTypeInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_max_addr();
  inline void clear_has_max_addr();
  inline void set_has_max_speed_level();
  inline void clear_has_max_speed_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 max_addr_;
  ::google::protobuf::uint32 max_speed_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTCameraTypeInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCameraTypeList : public ::google::protobuf::Message {
 public:
  TMTCameraTypeList();
  virtual ~TMTCameraTypeList();

  TMTCameraTypeList(const TMTCameraTypeList& from);

  inline TMTCameraTypeList& operator=(const TMTCameraTypeList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCameraTypeList& default_instance();

  void Swap(TMTCameraTypeList* other);

  // implements Message ----------------------------------------------

  TMTCameraTypeList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCameraTypeList& from);
  void MergeFrom(const TMTCameraTypeList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTCameraTypeInfo camera_type_list = 1;
  inline int camera_type_list_size() const;
  inline void clear_camera_type_list();
  static const int kCameraTypeListFieldNumber = 1;
  inline const ::mt::TMTCameraTypeInfo& camera_type_list(int index) const;
  inline ::mt::TMTCameraTypeInfo* mutable_camera_type_list(int index);
  inline ::mt::TMTCameraTypeInfo* add_camera_type_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTCameraTypeInfo >&
      camera_type_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTCameraTypeInfo >*
      mutable_camera_type_list();

  // @@protoc_insertion_point(class_scope:mt.TMTCameraTypeList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTCameraTypeInfo > camera_type_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTCameraTypeList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCpuAndMemState : public ::google::protobuf::Message {
 public:
  TMTCpuAndMemState();
  virtual ~TMTCpuAndMemState();

  TMTCpuAndMemState(const TMTCpuAndMemState& from);

  inline TMTCpuAndMemState& operator=(const TMTCpuAndMemState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCpuAndMemState& default_instance();

  void Swap(TMTCpuAndMemState* other);

  // implements Message ----------------------------------------------

  TMTCpuAndMemState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCpuAndMemState& from);
  void MergeFrom(const TMTCpuAndMemState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cpu_idle_percent = 1;
  inline bool has_cpu_idle_percent() const;
  inline void clear_cpu_idle_percent();
  static const int kCpuIdlePercentFieldNumber = 1;
  inline ::google::protobuf::uint32 cpu_idle_percent() const;
  inline void set_cpu_idle_percent(::google::protobuf::uint32 value);

  // optional uint32 mem_total_size = 2;
  inline bool has_mem_total_size() const;
  inline void clear_mem_total_size();
  static const int kMemTotalSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 mem_total_size() const;
  inline void set_mem_total_size(::google::protobuf::uint32 value);

  // optional uint32 mem_alloc_size = 3;
  inline bool has_mem_alloc_size() const;
  inline void clear_mem_alloc_size();
  static const int kMemAllocSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 mem_alloc_size() const;
  inline void set_mem_alloc_size(::google::protobuf::uint32 value);

  // optional uint32 mem_free_size = 4;
  inline bool has_mem_free_size() const;
  inline void clear_mem_free_size();
  static const int kMemFreeSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 mem_free_size() const;
  inline void set_mem_free_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTCpuAndMemState)
 private:
  inline void set_has_cpu_idle_percent();
  inline void clear_has_cpu_idle_percent();
  inline void set_has_mem_total_size();
  inline void clear_has_mem_total_size();
  inline void set_has_mem_alloc_size();
  inline void clear_has_mem_alloc_size();
  inline void set_has_mem_free_size();
  inline void clear_has_mem_free_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cpu_idle_percent_;
  ::google::protobuf::uint32 mem_total_size_;
  ::google::protobuf::uint32 mem_alloc_size_;
  ::google::protobuf::uint32 mem_free_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTCpuAndMemState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCameraPresetPicList : public ::google::protobuf::Message {
 public:
  TMTCameraPresetPicList();
  virtual ~TMTCameraPresetPicList();

  TMTCameraPresetPicList(const TMTCameraPresetPicList& from);

  inline TMTCameraPresetPicList& operator=(const TMTCameraPresetPicList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCameraPresetPicList& default_instance();

  void Swap(TMTCameraPresetPicList* other);

  // implements Message ----------------------------------------------

  TMTCameraPresetPicList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCameraPresetPicList& from);
  void MergeFrom(const TMTCameraPresetPicList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string pic_name = 1;
  inline int pic_name_size() const;
  inline void clear_pic_name();
  static const int kPicNameFieldNumber = 1;
  inline const ::std::string& pic_name(int index) const;
  inline ::std::string* mutable_pic_name(int index);
  inline void set_pic_name(int index, const ::std::string& value);
  inline void set_pic_name(int index, const char* value);
  inline void set_pic_name(int index, const char* value, size_t size);
  inline ::std::string* add_pic_name();
  inline void add_pic_name(const ::std::string& value);
  inline void add_pic_name(const char* value);
  inline void add_pic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pic_name();

  // @@protoc_insertion_point(class_scope:mt.TMTCameraPresetPicList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> pic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTCameraPresetPicList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVidSrc2FarCtrlId : public ::google::protobuf::Message {
 public:
  TMTVidSrc2FarCtrlId();
  virtual ~TMTVidSrc2FarCtrlId();

  TMTVidSrc2FarCtrlId(const TMTVidSrc2FarCtrlId& from);

  inline TMTVidSrc2FarCtrlId& operator=(const TMTVidSrc2FarCtrlId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVidSrc2FarCtrlId& default_instance();

  void Swap(TMTVidSrc2FarCtrlId* other);

  // implements Message ----------------------------------------------

  TMTVidSrc2FarCtrlId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVidSrc2FarCtrlId& from);
  void MergeFrom(const TMTVidSrc2FarCtrlId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtVideoPort inner_video_src = 1;
  inline bool has_inner_video_src() const;
  inline void clear_inner_video_src();
  static const int kInnerVideoSrcFieldNumber = 1;
  inline ::mt::EmMtVideoPort inner_video_src() const;
  inline void set_inner_video_src(::mt::EmMtVideoPort value);

  // optional uint32 video_src_id = 2;
  inline bool has_video_src_id() const;
  inline void clear_video_src_id();
  static const int kVideoSrcIdFieldNumber = 2;
  inline ::google::protobuf::uint32 video_src_id() const;
  inline void set_video_src_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTVidSrc2FarCtrlId)
 private:
  inline void set_has_inner_video_src();
  inline void clear_has_inner_video_src();
  inline void set_has_video_src_id();
  inline void clear_has_video_src_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int inner_video_src_;
  ::google::protobuf::uint32 video_src_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTVidSrc2FarCtrlId* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVidSrc2FarCtrlIdGroup : public ::google::protobuf::Message {
 public:
  TMTVidSrc2FarCtrlIdGroup();
  virtual ~TMTVidSrc2FarCtrlIdGroup();

  TMTVidSrc2FarCtrlIdGroup(const TMTVidSrc2FarCtrlIdGroup& from);

  inline TMTVidSrc2FarCtrlIdGroup& operator=(const TMTVidSrc2FarCtrlIdGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVidSrc2FarCtrlIdGroup& default_instance();

  void Swap(TMTVidSrc2FarCtrlIdGroup* other);

  // implements Message ----------------------------------------------

  TMTVidSrc2FarCtrlIdGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVidSrc2FarCtrlIdGroup& from);
  void MergeFrom(const TMTVidSrc2FarCtrlIdGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent video_type = 1;
  inline bool has_video_type() const;
  inline void clear_video_type();
  static const int kVideoTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent video_type() const;
  inline void set_video_type(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex video_id = 2;
  inline bool has_video_id() const;
  inline void clear_video_id();
  static const int kVideoIdFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex video_id() const;
  inline void set_video_id(::mt::EmCodecComponentIndex value);

  // repeated .mt.TMTVidSrc2FarCtrlId video_list = 3;
  inline int video_list_size() const;
  inline void clear_video_list();
  static const int kVideoListFieldNumber = 3;
  inline const ::mt::TMTVidSrc2FarCtrlId& video_list(int index) const;
  inline ::mt::TMTVidSrc2FarCtrlId* mutable_video_list(int index);
  inline ::mt::TMTVidSrc2FarCtrlId* add_video_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidSrc2FarCtrlId >&
      video_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidSrc2FarCtrlId >*
      mutable_video_list();

  // @@protoc_insertion_point(class_scope:mt.TMTVidSrc2FarCtrlIdGroup)
 private:
  inline void set_has_video_type();
  inline void clear_has_video_type();
  inline void set_has_video_id();
  inline void clear_has_video_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_type_;
  int video_id_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVidSrc2FarCtrlId > video_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTVidSrc2FarCtrlIdGroup* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVidSrc2FarCtrlIdList : public ::google::protobuf::Message {
 public:
  TMTVidSrc2FarCtrlIdList();
  virtual ~TMTVidSrc2FarCtrlIdList();

  TMTVidSrc2FarCtrlIdList(const TMTVidSrc2FarCtrlIdList& from);

  inline TMTVidSrc2FarCtrlIdList& operator=(const TMTVidSrc2FarCtrlIdList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVidSrc2FarCtrlIdList& default_instance();

  void Swap(TMTVidSrc2FarCtrlIdList* other);

  // implements Message ----------------------------------------------

  TMTVidSrc2FarCtrlIdList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVidSrc2FarCtrlIdList& from);
  void MergeFrom(const TMTVidSrc2FarCtrlIdList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTVidSrc2FarCtrlIdGroup video_list = 1;
  inline int video_list_size() const;
  inline void clear_video_list();
  static const int kVideoListFieldNumber = 1;
  inline const ::mt::TMTVidSrc2FarCtrlIdGroup& video_list(int index) const;
  inline ::mt::TMTVidSrc2FarCtrlIdGroup* mutable_video_list(int index);
  inline ::mt::TMTVidSrc2FarCtrlIdGroup* add_video_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidSrc2FarCtrlIdGroup >&
      video_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidSrc2FarCtrlIdGroup >*
      mutable_video_list();

  // @@protoc_insertion_point(class_scope:mt.TMTVidSrc2FarCtrlIdList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTVidSrc2FarCtrlIdGroup > video_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTVidSrc2FarCtrlIdList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUsbPartition : public ::google::protobuf::Message {
 public:
  TMTUsbPartition();
  virtual ~TMTUsbPartition();

  TMTUsbPartition(const TMTUsbPartition& from);

  inline TMTUsbPartition& operator=(const TMTUsbPartition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUsbPartition& default_instance();

  void Swap(TMTUsbPartition* other);

  // implements Message ----------------------------------------------

  TMTUsbPartition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUsbPartition& from);
  void MergeFrom(const TMTUsbPartition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 total_space = 3;
  inline bool has_total_space() const;
  inline void clear_total_space();
  static const int kTotalSpaceFieldNumber = 3;
  inline ::google::protobuf::uint32 total_space() const;
  inline void set_total_space(::google::protobuf::uint32 value);

  // optional uint32 free_space = 4;
  inline bool has_free_space() const;
  inline void clear_free_space();
  static const int kFreeSpaceFieldNumber = 4;
  inline ::google::protobuf::uint32 free_space() const;
  inline void set_free_space(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTUsbPartition)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_total_space();
  inline void clear_has_total_space();
  inline void set_has_free_space();
  inline void clear_has_free_space();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  ::std::string* name_;
  ::google::protobuf::uint32 total_space_;
  ::google::protobuf::uint32 free_space_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTUsbPartition* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUsbInfo : public ::google::protobuf::Message {
 public:
  TMTUsbInfo();
  virtual ~TMTUsbInfo();

  TMTUsbInfo(const TMTUsbInfo& from);

  inline TMTUsbInfo& operator=(const TMTUsbInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUsbInfo& default_instance();

  void Swap(TMTUsbInfo* other);

  // implements Message ----------------------------------------------

  TMTUsbInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUsbInfo& from);
  void MergeFrom(const TMTUsbInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 usb_id = 1;
  inline bool has_usb_id() const;
  inline void clear_usb_id();
  static const int kUsbIdFieldNumber = 1;
  inline ::google::protobuf::uint32 usb_id() const;
  inline void set_usb_id(::google::protobuf::uint32 value);

  // optional bool is_used = 2;
  inline bool has_is_used() const;
  inline void clear_is_used();
  static const int kIsUsedFieldNumber = 2;
  inline bool is_used() const;
  inline void set_is_used(bool value);

  // repeated .mt.TMTUsbPartition usb_partition = 3;
  inline int usb_partition_size() const;
  inline void clear_usb_partition();
  static const int kUsbPartitionFieldNumber = 3;
  inline const ::mt::TMTUsbPartition& usb_partition(int index) const;
  inline ::mt::TMTUsbPartition* mutable_usb_partition(int index);
  inline ::mt::TMTUsbPartition* add_usb_partition();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUsbPartition >&
      usb_partition() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUsbPartition >*
      mutable_usb_partition();

  // @@protoc_insertion_point(class_scope:mt.TMTUsbInfo)
 private:
  inline void set_has_usb_id();
  inline void clear_has_usb_id();
  inline void set_has_is_used();
  inline void clear_has_is_used();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 usb_id_;
  bool is_used_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTUsbPartition > usb_partition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTUsbInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUsbStatus : public ::google::protobuf::Message {
 public:
  TMTUsbStatus();
  virtual ~TMTUsbStatus();

  TMTUsbStatus(const TMTUsbStatus& from);

  inline TMTUsbStatus& operator=(const TMTUsbStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUsbStatus& default_instance();

  void Swap(TMTUsbStatus* other);

  // implements Message ----------------------------------------------

  TMTUsbStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUsbStatus& from);
  void MergeFrom(const TMTUsbStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTUsbInfo usb_info = 1;
  inline int usb_info_size() const;
  inline void clear_usb_info();
  static const int kUsbInfoFieldNumber = 1;
  inline const ::mt::TMTUsbInfo& usb_info(int index) const;
  inline ::mt::TMTUsbInfo* mutable_usb_info(int index);
  inline ::mt::TMTUsbInfo* add_usb_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUsbInfo >&
      usb_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUsbInfo >*
      mutable_usb_info();

  // @@protoc_insertion_point(class_scope:mt.TMTUsbStatus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTUsbInfo > usb_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTUsbStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPathStructureUnit : public ::google::protobuf::Message {
 public:
  TMTPathStructureUnit();
  virtual ~TMTPathStructureUnit();

  TMTPathStructureUnit(const TMTPathStructureUnit& from);

  inline TMTPathStructureUnit& operator=(const TMTPathStructureUnit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPathStructureUnit& default_instance();

  void Swap(TMTPathStructureUnit* other);

  // implements Message ----------------------------------------------

  TMTPathStructureUnit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPathStructureUnit& from);
  void MergeFrom(const TMTPathStructureUnit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmSystemFileType file_type = 1;
  inline bool has_file_type() const;
  inline void clear_file_type();
  static const int kFileTypeFieldNumber = 1;
  inline ::mt::EmSystemFileType file_type() const;
  inline void set_file_type(::mt::EmSystemFileType value);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:mt.TMTPathStructureUnit)
 private:
  inline void set_has_file_type();
  inline void clear_has_file_type();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  int file_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTPathStructureUnit* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPathStructureDetail : public ::google::protobuf::Message {
 public:
  TMTPathStructureDetail();
  virtual ~TMTPathStructureDetail();

  TMTPathStructureDetail(const TMTPathStructureDetail& from);

  inline TMTPathStructureDetail& operator=(const TMTPathStructureDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPathStructureDetail& default_instance();

  void Swap(TMTPathStructureDetail* other);

  // implements Message ----------------------------------------------

  TMTPathStructureDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPathStructureDetail& from);
  void MergeFrom(const TMTPathStructureDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTPathStructureUnit path_unit_list = 1;
  inline int path_unit_list_size() const;
  inline void clear_path_unit_list();
  static const int kPathUnitListFieldNumber = 1;
  inline const ::mt::TMTPathStructureUnit& path_unit_list(int index) const;
  inline ::mt::TMTPathStructureUnit* mutable_path_unit_list(int index);
  inline ::mt::TMTPathStructureUnit* add_path_unit_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPathStructureUnit >&
      path_unit_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPathStructureUnit >*
      mutable_path_unit_list();

  // @@protoc_insertion_point(class_scope:mt.TMTPathStructureDetail)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTPathStructureUnit > path_unit_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTPathStructureDetail* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTBrdInfo : public ::google::protobuf::Message {
 public:
  TMTBrdInfo();
  virtual ~TMTBrdInfo();

  TMTBrdInfo(const TMTBrdInfo& from);

  inline TMTBrdInfo& operator=(const TMTBrdInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTBrdInfo& default_instance();

  void Swap(TMTBrdInfo* other);

  // implements Message ----------------------------------------------

  TMTBrdInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTBrdInfo& from);
  void MergeFrom(const TMTBrdInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 brd_id = 2;
  inline bool has_brd_id() const;
  inline void clear_brd_id();
  static const int kBrdIdFieldNumber = 2;
  inline ::google::protobuf::uint32 brd_id() const;
  inline void set_brd_id(::google::protobuf::uint32 value);

  // optional uint32 brd_version = 3;
  inline bool has_brd_version() const;
  inline void clear_brd_version();
  static const int kBrdVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 brd_version() const;
  inline void set_brd_version(::google::protobuf::uint32 value);

  // optional uint32 pld_version = 4;
  inline bool has_pld_version() const;
  inline void clear_pld_version();
  static const int kPldVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 pld_version() const;
  inline void set_pld_version(::google::protobuf::uint32 value);

  // optional uint32 fpga_version = 5;
  inline bool has_fpga_version() const;
  inline void clear_fpga_version();
  static const int kFpgaVersionFieldNumber = 5;
  inline ::google::protobuf::uint32 fpga_version() const;
  inline void set_fpga_version(::google::protobuf::uint32 value);

  // optional int32 layer = 6;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 6;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // optional int32 slot = 7;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 7;
  inline ::google::protobuf::int32 slot() const;
  inline void set_slot(::google::protobuf::int32 value);

  // optional uint32 CpuNum = 8;
  inline bool has_cpunum() const;
  inline void clear_cpunum();
  static const int kCpuNumFieldNumber = 8;
  inline ::google::protobuf::uint32 cpunum() const;
  inline void set_cpunum(::google::protobuf::uint32 value);

  // optional uint32 CpuSelfNo = 9;
  inline bool has_cpuselfno() const;
  inline void clear_cpuselfno();
  static const int kCpuSelfNoFieldNumber = 9;
  inline ::google::protobuf::uint32 cpuselfno() const;
  inline void set_cpuselfno(::google::protobuf::uint32 value);

  // optional uint32 PldNum = 10;
  inline bool has_pldnum() const;
  inline void clear_pldnum();
  static const int kPldNumFieldNumber = 10;
  inline ::google::protobuf::uint32 pldnum() const;
  inline void set_pldnum(::google::protobuf::uint32 value);

  // optional uint32 FpgaNum = 11;
  inline bool has_fpganum() const;
  inline void clear_fpganum();
  static const int kFpgaNumFieldNumber = 11;
  inline ::google::protobuf::uint32 fpganum() const;
  inline void set_fpganum(::google::protobuf::uint32 value);

  // optional uint32 RtcNum = 12;
  inline bool has_rtcnum() const;
  inline void clear_rtcnum();
  static const int kRtcNumFieldNumber = 12;
  inline ::google::protobuf::uint32 rtcnum() const;
  inline void set_rtcnum(::google::protobuf::uint32 value);

  // optional uint32 EthNum = 13;
  inline bool has_ethnum() const;
  inline void clear_ethnum();
  static const int kEthNumFieldNumber = 13;
  inline ::google::protobuf::uint32 ethnum() const;
  inline void set_ethnum(::google::protobuf::uint32 value);

  // optional uint32 E1Num = 14;
  inline bool has_e1num() const;
  inline void clear_e1num();
  static const int kE1NumFieldNumber = 14;
  inline ::google::protobuf::uint32 e1num() const;
  inline void set_e1num(::google::protobuf::uint32 value);

  // optional uint32 V35Num = 15;
  inline bool has_v35num() const;
  inline void clear_v35num();
  static const int kV35NumFieldNumber = 15;
  inline ::google::protobuf::uint32 v35num() const;
  inline void set_v35num(::google::protobuf::uint32 value);

  // optional uint32 SerialNum = 16;
  inline bool has_serialnum() const;
  inline void clear_serialnum();
  static const int kSerialNumFieldNumber = 16;
  inline ::google::protobuf::uint32 serialnum() const;
  inline void set_serialnum(::google::protobuf::uint32 value);

  // optional uint32 FanNum = 17;
  inline bool has_fannum() const;
  inline void clear_fannum();
  static const int kFanNumFieldNumber = 17;
  inline ::google::protobuf::uint32 fannum() const;
  inline void set_fannum(::google::protobuf::uint32 value);

  // optional uint32 LedNum = 18;
  inline bool has_lednum() const;
  inline void clear_lednum();
  static const int kLedNumFieldNumber = 18;
  inline ::google::protobuf::uint32 lednum() const;
  inline void set_lednum(::google::protobuf::uint32 value);

  // optional uint32 ButtonNum = 19;
  inline bool has_buttonnum() const;
  inline void clear_buttonnum();
  static const int kButtonNumFieldNumber = 19;
  inline ::google::protobuf::uint32 buttonnum() const;
  inline void set_buttonnum(::google::protobuf::uint32 value);

  // optional uint32 HwmonNum = 20;
  inline bool has_hwmonnum() const;
  inline void clear_hwmonnum();
  static const int kHwmonNumFieldNumber = 20;
  inline ::google::protobuf::uint32 hwmonnum() const;
  inline void set_hwmonnum(::google::protobuf::uint32 value);

  // optional uint32 OledNum = 21;
  inline bool has_olednum() const;
  inline void clear_olednum();
  static const int kOledNumFieldNumber = 21;
  inline ::google::protobuf::uint32 olednum() const;
  inline void set_olednum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTBrdInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_brd_id();
  inline void clear_has_brd_id();
  inline void set_has_brd_version();
  inline void clear_has_brd_version();
  inline void set_has_pld_version();
  inline void clear_has_pld_version();
  inline void set_has_fpga_version();
  inline void clear_has_fpga_version();
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_slot();
  inline void clear_has_slot();
  inline void set_has_cpunum();
  inline void clear_has_cpunum();
  inline void set_has_cpuselfno();
  inline void clear_has_cpuselfno();
  inline void set_has_pldnum();
  inline void clear_has_pldnum();
  inline void set_has_fpganum();
  inline void clear_has_fpganum();
  inline void set_has_rtcnum();
  inline void clear_has_rtcnum();
  inline void set_has_ethnum();
  inline void clear_has_ethnum();
  inline void set_has_e1num();
  inline void clear_has_e1num();
  inline void set_has_v35num();
  inline void clear_has_v35num();
  inline void set_has_serialnum();
  inline void clear_has_serialnum();
  inline void set_has_fannum();
  inline void clear_has_fannum();
  inline void set_has_lednum();
  inline void clear_has_lednum();
  inline void set_has_buttonnum();
  inline void clear_has_buttonnum();
  inline void set_has_hwmonnum();
  inline void clear_has_hwmonnum();
  inline void set_has_olednum();
  inline void clear_has_olednum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 brd_id_;
  ::google::protobuf::uint32 brd_version_;
  ::google::protobuf::uint32 pld_version_;
  ::google::protobuf::uint32 fpga_version_;
  ::google::protobuf::int32 layer_;
  ::google::protobuf::int32 slot_;
  ::google::protobuf::uint32 cpunum_;
  ::google::protobuf::uint32 cpuselfno_;
  ::google::protobuf::uint32 pldnum_;
  ::google::protobuf::uint32 fpganum_;
  ::google::protobuf::uint32 rtcnum_;
  ::google::protobuf::uint32 ethnum_;
  ::google::protobuf::uint32 e1num_;
  ::google::protobuf::uint32 v35num_;
  ::google::protobuf::uint32 serialnum_;
  ::google::protobuf::uint32 fannum_;
  ::google::protobuf::uint32 lednum_;
  ::google::protobuf::uint32 buttonnum_;
  ::google::protobuf::uint32 hwmonnum_;
  ::google::protobuf::uint32 olednum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTBrdInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMicStatus : public ::google::protobuf::Message {
 public:
  TMTMicStatus();
  virtual ~TMTMicStatus();

  TMTMicStatus(const TMTMicStatus& from);

  inline TMTMicStatus& operator=(const TMTMicStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMicStatus& default_instance();

  void Swap(TMTMicStatus* other);

  // implements Message ----------------------------------------------

  TMTMicStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMicStatus& from);
  void MergeFrom(const TMTMicStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 MicId = 1;
  inline bool has_micid() const;
  inline void clear_micid();
  static const int kMicIdFieldNumber = 1;
  inline ::google::protobuf::uint32 micid() const;
  inline void set_micid(::google::protobuf::uint32 value);

  // optional uint32 Status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTMicStatus)
 private:
  inline void set_has_micid();
  inline void clear_has_micid();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 micid_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTMicStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMicInfo : public ::google::protobuf::Message {
 public:
  TMTMicInfo();
  virtual ~TMTMicInfo();

  TMTMicInfo(const TMTMicInfo& from);

  inline TMTMicInfo& operator=(const TMTMicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMicInfo& default_instance();

  void Swap(TMTMicInfo* other);

  // implements Message ----------------------------------------------

  TMTMicInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMicInfo& from);
  void MergeFrom(const TMTMicInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTMicStatus MicStatus = 1;
  inline int micstatus_size() const;
  inline void clear_micstatus();
  static const int kMicStatusFieldNumber = 1;
  inline const ::mt::TMTMicStatus& micstatus(int index) const;
  inline ::mt::TMTMicStatus* mutable_micstatus(int index);
  inline ::mt::TMTMicStatus* add_micstatus();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTMicStatus >&
      micstatus() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTMicStatus >*
      mutable_micstatus();

  // @@protoc_insertion_point(class_scope:mt.TMTMicInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTMicStatus > micstatus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTMicInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMicUpgradeState : public ::google::protobuf::Message {
 public:
  TMicUpgradeState();
  virtual ~TMicUpgradeState();

  TMicUpgradeState(const TMicUpgradeState& from);

  inline TMicUpgradeState& operator=(const TMicUpgradeState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMicUpgradeState& default_instance();

  void Swap(TMicUpgradeState* other);

  // implements Message ----------------------------------------------

  TMicUpgradeState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMicUpgradeState& from);
  void MergeFrom(const TMicUpgradeState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 MicId = 1;
  inline bool has_micid() const;
  inline void clear_micid();
  static const int kMicIdFieldNumber = 1;
  inline ::google::protobuf::uint32 micid() const;
  inline void set_micid(::google::protobuf::uint32 value);

  // optional uint32 State = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional uint32 Progress = 3;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 3;
  inline ::google::protobuf::uint32 progress() const;
  inline void set_progress(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMicUpgradeState)
 private:
  inline void set_has_micid();
  inline void clear_has_micid();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_progress();
  inline void clear_has_progress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 micid_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 progress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMicUpgradeState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMicUpgradeStateList : public ::google::protobuf::Message {
 public:
  TMicUpgradeStateList();
  virtual ~TMicUpgradeStateList();

  TMicUpgradeStateList(const TMicUpgradeStateList& from);

  inline TMicUpgradeStateList& operator=(const TMicUpgradeStateList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMicUpgradeStateList& default_instance();

  void Swap(TMicUpgradeStateList* other);

  // implements Message ----------------------------------------------

  TMicUpgradeStateList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMicUpgradeStateList& from);
  void MergeFrom(const TMicUpgradeStateList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMicUpgradeState MicUpgradeState = 1;
  inline int micupgradestate_size() const;
  inline void clear_micupgradestate();
  static const int kMicUpgradeStateFieldNumber = 1;
  inline const ::mt::TMicUpgradeState& micupgradestate(int index) const;
  inline ::mt::TMicUpgradeState* mutable_micupgradestate(int index);
  inline ::mt::TMicUpgradeState* add_micupgradestate();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMicUpgradeState >&
      micupgradestate() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMicUpgradeState >*
      mutable_micupgradestate();

  // @@protoc_insertion_point(class_scope:mt.TMicUpgradeStateList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMicUpgradeState > micupgradestate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMicUpgradeStateList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMicInstall : public ::google::protobuf::Message {
 public:
  TMicInstall();
  virtual ~TMicInstall();

  TMicInstall(const TMicInstall& from);

  inline TMicInstall& operator=(const TMicInstall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMicInstall& default_instance();

  void Swap(TMicInstall* other);

  // implements Message ----------------------------------------------

  TMicInstall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMicInstall& from);
  void MergeFrom(const TMicInstall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 MicId = 1;
  inline bool has_micid() const;
  inline void clear_micid();
  static const int kMicIdFieldNumber = 1;
  inline ::google::protobuf::uint32 micid() const;
  inline void set_micid(::google::protobuf::uint32 value);

  // optional uint32 State = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMicInstall)
 private:
  inline void set_has_micid();
  inline void clear_has_micid();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 micid_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMicInstall* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMicInstallList : public ::google::protobuf::Message {
 public:
  TMicInstallList();
  virtual ~TMicInstallList();

  TMicInstallList(const TMicInstallList& from);

  inline TMicInstallList& operator=(const TMicInstallList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMicInstallList& default_instance();

  void Swap(TMicInstallList* other);

  // implements Message ----------------------------------------------

  TMicInstallList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMicInstallList& from);
  void MergeFrom(const TMicInstallList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMicInstall MicInstall = 1;
  inline int micinstall_size() const;
  inline void clear_micinstall();
  static const int kMicInstallFieldNumber = 1;
  inline const ::mt::TMicInstall& micinstall(int index) const;
  inline ::mt::TMicInstall* mutable_micinstall(int index);
  inline ::mt::TMicInstall* add_micinstall();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMicInstall >&
      micinstall() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMicInstall >*
      mutable_micinstall();

  // @@protoc_insertion_point(class_scope:mt.TMicInstallList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMicInstall > micinstall_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMicInstallList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRfMatchState : public ::google::protobuf::Message {
 public:
  TMTRfMatchState();
  virtual ~TMTRfMatchState();

  TMTRfMatchState(const TMTRfMatchState& from);

  inline TMTRfMatchState& operator=(const TMTRfMatchState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRfMatchState& default_instance();

  void Swap(TMTRfMatchState* other);

  // implements Message ----------------------------------------------

  TMTRfMatchState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRfMatchState& from);
  void MergeFrom(const TMTRfMatchState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMicDevId dev_id = 1;
  inline bool has_dev_id() const;
  inline void clear_dev_id();
  static const int kDevIdFieldNumber = 1;
  inline ::mt::EmMicDevId dev_id() const;
  inline void set_dev_id(::mt::EmMicDevId value);

  // optional bool is_matched = 2;
  inline bool has_is_matched() const;
  inline void clear_is_matched();
  static const int kIsMatchedFieldNumber = 2;
  inline bool is_matched() const;
  inline void set_is_matched(bool value);

  // optional uint32 matched_id = 3;
  inline bool has_matched_id() const;
  inline void clear_matched_id();
  static const int kMatchedIdFieldNumber = 3;
  inline ::google::protobuf::uint32 matched_id() const;
  inline void set_matched_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTRfMatchState)
 private:
  inline void set_has_dev_id();
  inline void clear_has_dev_id();
  inline void set_has_is_matched();
  inline void clear_has_is_matched();
  inline void set_has_matched_id();
  inline void clear_has_matched_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int dev_id_;
  bool is_matched_;
  ::google::protobuf::uint32 matched_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTRfMatchState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRfMatchStateList : public ::google::protobuf::Message {
 public:
  TMTRfMatchStateList();
  virtual ~TMTRfMatchStateList();

  TMTRfMatchStateList(const TMTRfMatchStateList& from);

  inline TMTRfMatchStateList& operator=(const TMTRfMatchStateList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRfMatchStateList& default_instance();

  void Swap(TMTRfMatchStateList* other);

  // implements Message ----------------------------------------------

  TMTRfMatchStateList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRfMatchStateList& from);
  void MergeFrom(const TMTRfMatchStateList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTRfMatchState rf_match_status = 1;
  inline int rf_match_status_size() const;
  inline void clear_rf_match_status();
  static const int kRfMatchStatusFieldNumber = 1;
  inline const ::mt::TMTRfMatchState& rf_match_status(int index) const;
  inline ::mt::TMTRfMatchState* mutable_rf_match_status(int index);
  inline ::mt::TMTRfMatchState* add_rf_match_status();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRfMatchState >&
      rf_match_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRfMatchState >*
      mutable_rf_match_status();

  // @@protoc_insertion_point(class_scope:mt.TMTRfMatchStateList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTRfMatchState > rf_match_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTRfMatchStateList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMicDecibel : public ::google::protobuf::Message {
 public:
  TMTMicDecibel();
  virtual ~TMTMicDecibel();

  TMTMicDecibel(const TMTMicDecibel& from);

  inline TMTMicDecibel& operator=(const TMTMicDecibel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMicDecibel& default_instance();

  void Swap(TMTMicDecibel* other);

  // implements Message ----------------------------------------------

  TMTMicDecibel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMicDecibel& from);
  void MergeFrom(const TMTMicDecibel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 MicId = 1;
  inline bool has_micid() const;
  inline void clear_micid();
  static const int kMicIdFieldNumber = 1;
  inline ::google::protobuf::uint32 micid() const;
  inline void set_micid(::google::protobuf::uint32 value);

  // optional uint32 MiTouId = 2;
  inline bool has_mitouid() const;
  inline void clear_mitouid();
  static const int kMiTouIdFieldNumber = 2;
  inline ::google::protobuf::uint32 mitouid() const;
  inline void set_mitouid(::google::protobuf::uint32 value);

  // optional uint32 Value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTMicDecibel)
 private:
  inline void set_has_micid();
  inline void clear_has_micid();
  inline void set_has_mitouid();
  inline void clear_has_mitouid();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 micid_;
  ::google::protobuf::uint32 mitouid_;
  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTMicDecibel* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMicVersionInfo : public ::google::protobuf::Message {
 public:
  TMicVersionInfo();
  virtual ~TMicVersionInfo();

  TMicVersionInfo(const TMicVersionInfo& from);

  inline TMicVersionInfo& operator=(const TMicVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMicVersionInfo& default_instance();

  void Swap(TMicVersionInfo* other);

  // implements Message ----------------------------------------------

  TMicVersionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMicVersionInfo& from);
  void MergeFrom(const TMicVersionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 MicId = 1;
  inline bool has_micid() const;
  inline void clear_micid();
  static const int kMicIdFieldNumber = 1;
  inline ::google::protobuf::uint32 micid() const;
  inline void set_micid(::google::protobuf::uint32 value);

  // optional string Version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mt.TMicVersionInfo)
 private:
  inline void set_has_micid();
  inline void clear_has_micid();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  ::google::protobuf::uint32 micid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMicVersionInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMicVersionList : public ::google::protobuf::Message {
 public:
  TMicVersionList();
  virtual ~TMicVersionList();

  TMicVersionList(const TMicVersionList& from);

  inline TMicVersionList& operator=(const TMicVersionList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMicVersionList& default_instance();

  void Swap(TMicVersionList* other);

  // implements Message ----------------------------------------------

  TMicVersionList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMicVersionList& from);
  void MergeFrom(const TMicVersionList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMicVersionInfo MicVer = 1;
  inline int micver_size() const;
  inline void clear_micver();
  static const int kMicVerFieldNumber = 1;
  inline const ::mt::TMicVersionInfo& micver(int index) const;
  inline ::mt::TMicVersionInfo* mutable_micver(int index);
  inline ::mt::TMicVersionInfo* add_micver();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMicVersionInfo >&
      micver() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMicVersionInfo >*
      mutable_micver();

  // @@protoc_insertion_point(class_scope:mt.TMicVersionList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMicVersionInfo > micver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMicVersionList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNetCapFileInfo : public ::google::protobuf::Message {
 public:
  TNetCapFileInfo();
  virtual ~TNetCapFileInfo();

  TNetCapFileInfo(const TNetCapFileInfo& from);

  inline TNetCapFileInfo& operator=(const TNetCapFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNetCapFileInfo& default_instance();

  void Swap(TNetCapFileInfo* other);

  // implements Message ----------------------------------------------

  TNetCapFileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNetCapFileInfo& from);
  void MergeFrom(const TNetCapFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional uint32 file_size = 2;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TNetCapFileInfo)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_name_;
  ::google::protobuf::uint32 file_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TNetCapFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNetCapFileList : public ::google::protobuf::Message {
 public:
  TNetCapFileList();
  virtual ~TNetCapFileList();

  TNetCapFileList(const TNetCapFileList& from);

  inline TNetCapFileList& operator=(const TNetCapFileList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNetCapFileList& default_instance();

  void Swap(TNetCapFileList* other);

  // implements Message ----------------------------------------------

  TNetCapFileList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNetCapFileList& from);
  void MergeFrom(const TNetCapFileList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  inline void set_allocated_file_path(::std::string* file_path);

  // repeated .mt.TNetCapFileInfo file_list = 2;
  inline int file_list_size() const;
  inline void clear_file_list();
  static const int kFileListFieldNumber = 2;
  inline const ::mt::TNetCapFileInfo& file_list(int index) const;
  inline ::mt::TNetCapFileInfo* mutable_file_list(int index);
  inline ::mt::TNetCapFileInfo* add_file_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TNetCapFileInfo >&
      file_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TNetCapFileInfo >*
      mutable_file_list();

  // @@protoc_insertion_point(class_scope:mt.TNetCapFileList)
 private:
  inline void set_has_file_path();
  inline void clear_has_file_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_path_;
  ::google::protobuf::RepeatedPtrField< ::mt::TNetCapFileInfo > file_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TNetCapFileList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TFpgaVersionList : public ::google::protobuf::Message {
 public:
  TFpgaVersionList();
  virtual ~TFpgaVersionList();

  TFpgaVersionList(const TFpgaVersionList& from);

  inline TFpgaVersionList& operator=(const TFpgaVersionList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFpgaVersionList& default_instance();

  void Swap(TFpgaVersionList* other);

  // implements Message ----------------------------------------------

  TFpgaVersionList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFpgaVersionList& from);
  void MergeFrom(const TFpgaVersionList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 FpgaVersion = 1;
  inline int fpgaversion_size() const;
  inline void clear_fpgaversion();
  static const int kFpgaVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 fpgaversion(int index) const;
  inline void set_fpgaversion(int index, ::google::protobuf::uint32 value);
  inline void add_fpgaversion(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      fpgaversion() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_fpgaversion();

  // @@protoc_insertion_point(class_scope:mt.TFpgaVersionList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > fpgaversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TFpgaVersionList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TCameraImageParam : public ::google::protobuf::Message {
 public:
  TCameraImageParam();
  virtual ~TCameraImageParam();

  TCameraImageParam(const TCameraImageParam& from);

  inline TCameraImageParam& operator=(const TCameraImageParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCameraImageParam& default_instance();

  void Swap(TCameraImageParam* other);

  // implements Message ----------------------------------------------

  TCameraImageParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCameraImageParam& from);
  void MergeFrom(const TCameraImageParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmImgParam type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmImgParam type() const;
  inline void set_type(::mt::EmImgParam value);

  // optional uint32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional uint32 min_val = 3;
  inline bool has_min_val() const;
  inline void clear_min_val();
  static const int kMinValFieldNumber = 3;
  inline ::google::protobuf::uint32 min_val() const;
  inline void set_min_val(::google::protobuf::uint32 value);

  // optional uint32 max_val = 4;
  inline bool has_max_val() const;
  inline void clear_max_val();
  static const int kMaxValFieldNumber = 4;
  inline ::google::protobuf::uint32 max_val() const;
  inline void set_max_val(::google::protobuf::uint32 value);

  // optional uint32 step = 5;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 5;
  inline ::google::protobuf::uint32 step() const;
  inline void set_step(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TCameraImageParam)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_min_val();
  inline void clear_has_min_val();
  inline void set_has_max_val();
  inline void clear_has_max_val();
  inline void set_has_step();
  inline void clear_has_step();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 value_;
  ::google::protobuf::uint32 min_val_;
  ::google::protobuf::uint32 max_val_;
  ::google::protobuf::uint32 step_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TCameraImageParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TCameraIspParam : public ::google::protobuf::Message {
 public:
  TCameraIspParam();
  virtual ~TCameraIspParam();

  TCameraIspParam(const TCameraIspParam& from);

  inline TCameraIspParam& operator=(const TCameraIspParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCameraIspParam& default_instance();

  void Swap(TCameraIspParam* other);

  // implements Message ----------------------------------------------

  TCameraIspParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCameraIspParam& from);
  void MergeFrom(const TCameraIspParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmIspImgInf type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmIspImgInf type() const;
  inline void set_type(::mt::EmIspImgInf value);

  // optional uint32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional uint32 min_val = 3;
  inline bool has_min_val() const;
  inline void clear_min_val();
  static const int kMinValFieldNumber = 3;
  inline ::google::protobuf::uint32 min_val() const;
  inline void set_min_val(::google::protobuf::uint32 value);

  // optional uint32 max_val = 4;
  inline bool has_max_val() const;
  inline void clear_max_val();
  static const int kMaxValFieldNumber = 4;
  inline ::google::protobuf::uint32 max_val() const;
  inline void set_max_val(::google::protobuf::uint32 value);

  // optional uint32 step = 5;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 5;
  inline ::google::protobuf::uint32 step() const;
  inline void set_step(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TCameraIspParam)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_min_val();
  inline void clear_has_min_val();
  inline void set_has_max_val();
  inline void clear_has_max_val();
  inline void set_has_step();
  inline void clear_has_step();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 value_;
  ::google::protobuf::uint32 min_val_;
  ::google::protobuf::uint32 max_val_;
  ::google::protobuf::uint32 step_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TCameraIspParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TSerialOptParam : public ::google::protobuf::Message {
 public:
  TSerialOptParam();
  virtual ~TSerialOptParam();

  TSerialOptParam(const TSerialOptParam& from);

  inline TSerialOptParam& operator=(const TSerialOptParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSerialOptParam& default_instance();

  void Swap(TSerialOptParam* other);

  // implements Message ----------------------------------------------

  TSerialOptParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSerialOptParam& from);
  void MergeFrom(const TSerialOptParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 serialtype = 1;
  inline bool has_serialtype() const;
  inline void clear_serialtype();
  static const int kSerialtypeFieldNumber = 1;
  inline ::google::protobuf::int32 serialtype() const;
  inline void set_serialtype(::google::protobuf::int32 value);

  // optional int32 operatetype = 2;
  inline bool has_operatetype() const;
  inline void clear_operatetype();
  static const int kOperatetypeFieldNumber = 2;
  inline ::google::protobuf::int32 operatetype() const;
  inline void set_operatetype(::google::protobuf::int32 value);

  // optional int32 len = 3;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 3;
  inline ::google::protobuf::int32 len() const;
  inline void set_len(::google::protobuf::int32 value);

  // optional int32 listentime = 4;
  inline bool has_listentime() const;
  inline void clear_listentime();
  static const int kListentimeFieldNumber = 4;
  inline ::google::protobuf::int32 listentime() const;
  inline void set_listentime(::google::protobuf::int32 value);

  // optional bytes content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:mt.TSerialOptParam)
 private:
  inline void set_has_serialtype();
  inline void clear_has_serialtype();
  inline void set_has_operatetype();
  inline void clear_has_operatetype();
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_listentime();
  inline void clear_has_listentime();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 serialtype_;
  ::google::protobuf::int32 operatetype_;
  ::google::protobuf::int32 len_;
  ::google::protobuf::int32 listentime_;
  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TSerialOptParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TCameraSceneModeCapList : public ::google::protobuf::Message {
 public:
  TCameraSceneModeCapList();
  virtual ~TCameraSceneModeCapList();

  TCameraSceneModeCapList(const TCameraSceneModeCapList& from);

  inline TCameraSceneModeCapList& operator=(const TCameraSceneModeCapList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCameraSceneModeCapList& default_instance();

  void Swap(TCameraSceneModeCapList* other);

  // implements Message ----------------------------------------------

  TCameraSceneModeCapList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCameraSceneModeCapList& from);
  void MergeFrom(const TCameraSceneModeCapList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 SceneModeCap = 1;
  inline int scenemodecap_size() const;
  inline void clear_scenemodecap();
  static const int kSceneModeCapFieldNumber = 1;
  inline ::google::protobuf::uint32 scenemodecap(int index) const;
  inline void set_scenemodecap(int index, ::google::protobuf::uint32 value);
  inline void add_scenemodecap(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      scenemodecap() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_scenemodecap();

  // @@protoc_insertion_point(class_scope:mt.TCameraSceneModeCapList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > scenemodecap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TCameraSceneModeCapList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMicTag : public ::google::protobuf::Message {
 public:
  TMTMicTag();
  virtual ~TMTMicTag();

  TMTMicTag(const TMTMicTag& from);

  inline TMTMicTag& operator=(const TMTMicTag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMicTag& default_instance();

  void Swap(TMTMicTag* other);

  // implements Message ----------------------------------------------

  TMTMicTag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMicTag& from);
  void MergeFrom(const TMTMicTag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 MicID = 1;
  inline bool has_micid() const;
  inline void clear_micid();
  static const int kMicIDFieldNumber = 1;
  inline ::google::protobuf::uint32 micid() const;
  inline void set_micid(::google::protobuf::uint32 value);

  // optional string MicTag = 2;
  inline bool has_mictag() const;
  inline void clear_mictag();
  static const int kMicTagFieldNumber = 2;
  inline const ::std::string& mictag() const;
  inline void set_mictag(const ::std::string& value);
  inline void set_mictag(const char* value);
  inline void set_mictag(const char* value, size_t size);
  inline ::std::string* mutable_mictag();
  inline ::std::string* release_mictag();
  inline void set_allocated_mictag(::std::string* mictag);

  // @@protoc_insertion_point(class_scope:mt.TMTMicTag)
 private:
  inline void set_has_micid();
  inline void clear_has_micid();
  inline void set_has_mictag();
  inline void clear_has_mictag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mictag_;
  ::google::protobuf::uint32 micid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTMicTag* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMicTagList : public ::google::protobuf::Message {
 public:
  TMTMicTagList();
  virtual ~TMTMicTagList();

  TMTMicTagList(const TMTMicTagList& from);

  inline TMTMicTagList& operator=(const TMTMicTagList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMicTagList& default_instance();

  void Swap(TMTMicTagList* other);

  // implements Message ----------------------------------------------

  TMTMicTagList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMicTagList& from);
  void MergeFrom(const TMTMicTagList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTMicTag MicTagList = 1;
  inline int mictaglist_size() const;
  inline void clear_mictaglist();
  static const int kMicTagListFieldNumber = 1;
  inline const ::mt::TMTMicTag& mictaglist(int index) const;
  inline ::mt::TMTMicTag* mutable_mictaglist(int index);
  inline ::mt::TMTMicTag* add_mictaglist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTMicTag >&
      mictaglist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTMicTag >*
      mutable_mictaglist();

  // @@protoc_insertion_point(class_scope:mt.TMTMicTagList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTMicTag > mictaglist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structdevice_2eproto();
  friend void protobuf_AssignDesc_structdevice_2eproto();
  friend void protobuf_ShutdownFile_structdevice_2eproto();

  void InitAsDefaultInstance();
  static TMTMicTagList* default_instance_;
};
// ===================================================================


// ===================================================================

// TMTCameraUpgrade

// optional .mt.EmEquipmentUpgrading camera_type = 1;
inline bool TMTCameraUpgrade::has_camera_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCameraUpgrade::set_has_camera_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCameraUpgrade::clear_has_camera_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCameraUpgrade::clear_camera_type() {
  camera_type_ = 0;
  clear_has_camera_type();
}
inline ::mt::EmEquipmentUpgrading TMTCameraUpgrade::camera_type() const {
  return static_cast< ::mt::EmEquipmentUpgrading >(camera_type_);
}
inline void TMTCameraUpgrade::set_camera_type(::mt::EmEquipmentUpgrading value) {
  assert(::mt::EmEquipmentUpgrading_IsValid(value));
  set_has_camera_type();
  camera_type_ = value;
}

// optional bool action = 2;
inline bool TMTCameraUpgrade::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCameraUpgrade::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCameraUpgrade::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCameraUpgrade::clear_action() {
  action_ = false;
  clear_has_action();
}
inline bool TMTCameraUpgrade::action() const {
  return action_;
}
inline void TMTCameraUpgrade::set_action(bool value) {
  set_has_action();
  action_ = value;
}

// optional string file_name = 3;
inline bool TMTCameraUpgrade::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTCameraUpgrade::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTCameraUpgrade::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTCameraUpgrade::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& TMTCameraUpgrade::file_name() const {
  return *file_name_;
}
inline void TMTCameraUpgrade::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TMTCameraUpgrade::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TMTCameraUpgrade::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCameraUpgrade::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* TMTCameraUpgrade::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCameraUpgrade::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTCameraTypeInfo

// optional string name = 1;
inline bool TMTCameraTypeInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCameraTypeInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCameraTypeInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCameraTypeInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTCameraTypeInfo::name() const {
  return *name_;
}
inline void TMTCameraTypeInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTCameraTypeInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTCameraTypeInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCameraTypeInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTCameraTypeInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCameraTypeInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 max_addr = 2;
inline bool TMTCameraTypeInfo::has_max_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCameraTypeInfo::set_has_max_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCameraTypeInfo::clear_has_max_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCameraTypeInfo::clear_max_addr() {
  max_addr_ = 0u;
  clear_has_max_addr();
}
inline ::google::protobuf::uint32 TMTCameraTypeInfo::max_addr() const {
  return max_addr_;
}
inline void TMTCameraTypeInfo::set_max_addr(::google::protobuf::uint32 value) {
  set_has_max_addr();
  max_addr_ = value;
}

// optional uint32 max_speed_level = 3;
inline bool TMTCameraTypeInfo::has_max_speed_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTCameraTypeInfo::set_has_max_speed_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTCameraTypeInfo::clear_has_max_speed_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTCameraTypeInfo::clear_max_speed_level() {
  max_speed_level_ = 0u;
  clear_has_max_speed_level();
}
inline ::google::protobuf::uint32 TMTCameraTypeInfo::max_speed_level() const {
  return max_speed_level_;
}
inline void TMTCameraTypeInfo::set_max_speed_level(::google::protobuf::uint32 value) {
  set_has_max_speed_level();
  max_speed_level_ = value;
}

// -------------------------------------------------------------------

// TMTCameraTypeList

// repeated .mt.TMTCameraTypeInfo camera_type_list = 1;
inline int TMTCameraTypeList::camera_type_list_size() const {
  return camera_type_list_.size();
}
inline void TMTCameraTypeList::clear_camera_type_list() {
  camera_type_list_.Clear();
}
inline const ::mt::TMTCameraTypeInfo& TMTCameraTypeList::camera_type_list(int index) const {
  return camera_type_list_.Get(index);
}
inline ::mt::TMTCameraTypeInfo* TMTCameraTypeList::mutable_camera_type_list(int index) {
  return camera_type_list_.Mutable(index);
}
inline ::mt::TMTCameraTypeInfo* TMTCameraTypeList::add_camera_type_list() {
  return camera_type_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTCameraTypeInfo >&
TMTCameraTypeList::camera_type_list() const {
  return camera_type_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTCameraTypeInfo >*
TMTCameraTypeList::mutable_camera_type_list() {
  return &camera_type_list_;
}

// -------------------------------------------------------------------

// TMTCpuAndMemState

// optional uint32 cpu_idle_percent = 1;
inline bool TMTCpuAndMemState::has_cpu_idle_percent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCpuAndMemState::set_has_cpu_idle_percent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCpuAndMemState::clear_has_cpu_idle_percent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCpuAndMemState::clear_cpu_idle_percent() {
  cpu_idle_percent_ = 0u;
  clear_has_cpu_idle_percent();
}
inline ::google::protobuf::uint32 TMTCpuAndMemState::cpu_idle_percent() const {
  return cpu_idle_percent_;
}
inline void TMTCpuAndMemState::set_cpu_idle_percent(::google::protobuf::uint32 value) {
  set_has_cpu_idle_percent();
  cpu_idle_percent_ = value;
}

// optional uint32 mem_total_size = 2;
inline bool TMTCpuAndMemState::has_mem_total_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCpuAndMemState::set_has_mem_total_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCpuAndMemState::clear_has_mem_total_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCpuAndMemState::clear_mem_total_size() {
  mem_total_size_ = 0u;
  clear_has_mem_total_size();
}
inline ::google::protobuf::uint32 TMTCpuAndMemState::mem_total_size() const {
  return mem_total_size_;
}
inline void TMTCpuAndMemState::set_mem_total_size(::google::protobuf::uint32 value) {
  set_has_mem_total_size();
  mem_total_size_ = value;
}

// optional uint32 mem_alloc_size = 3;
inline bool TMTCpuAndMemState::has_mem_alloc_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTCpuAndMemState::set_has_mem_alloc_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTCpuAndMemState::clear_has_mem_alloc_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTCpuAndMemState::clear_mem_alloc_size() {
  mem_alloc_size_ = 0u;
  clear_has_mem_alloc_size();
}
inline ::google::protobuf::uint32 TMTCpuAndMemState::mem_alloc_size() const {
  return mem_alloc_size_;
}
inline void TMTCpuAndMemState::set_mem_alloc_size(::google::protobuf::uint32 value) {
  set_has_mem_alloc_size();
  mem_alloc_size_ = value;
}

// optional uint32 mem_free_size = 4;
inline bool TMTCpuAndMemState::has_mem_free_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTCpuAndMemState::set_has_mem_free_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTCpuAndMemState::clear_has_mem_free_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTCpuAndMemState::clear_mem_free_size() {
  mem_free_size_ = 0u;
  clear_has_mem_free_size();
}
inline ::google::protobuf::uint32 TMTCpuAndMemState::mem_free_size() const {
  return mem_free_size_;
}
inline void TMTCpuAndMemState::set_mem_free_size(::google::protobuf::uint32 value) {
  set_has_mem_free_size();
  mem_free_size_ = value;
}

// -------------------------------------------------------------------

// TMTCameraPresetPicList

// repeated string pic_name = 1;
inline int TMTCameraPresetPicList::pic_name_size() const {
  return pic_name_.size();
}
inline void TMTCameraPresetPicList::clear_pic_name() {
  pic_name_.Clear();
}
inline const ::std::string& TMTCameraPresetPicList::pic_name(int index) const {
  return pic_name_.Get(index);
}
inline ::std::string* TMTCameraPresetPicList::mutable_pic_name(int index) {
  return pic_name_.Mutable(index);
}
inline void TMTCameraPresetPicList::set_pic_name(int index, const ::std::string& value) {
  pic_name_.Mutable(index)->assign(value);
}
inline void TMTCameraPresetPicList::set_pic_name(int index, const char* value) {
  pic_name_.Mutable(index)->assign(value);
}
inline void TMTCameraPresetPicList::set_pic_name(int index, const char* value, size_t size) {
  pic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCameraPresetPicList::add_pic_name() {
  return pic_name_.Add();
}
inline void TMTCameraPresetPicList::add_pic_name(const ::std::string& value) {
  pic_name_.Add()->assign(value);
}
inline void TMTCameraPresetPicList::add_pic_name(const char* value) {
  pic_name_.Add()->assign(value);
}
inline void TMTCameraPresetPicList::add_pic_name(const char* value, size_t size) {
  pic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TMTCameraPresetPicList::pic_name() const {
  return pic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TMTCameraPresetPicList::mutable_pic_name() {
  return &pic_name_;
}

// -------------------------------------------------------------------

// TMTVidSrc2FarCtrlId

// optional .mt.EmMtVideoPort inner_video_src = 1;
inline bool TMTVidSrc2FarCtrlId::has_inner_video_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVidSrc2FarCtrlId::set_has_inner_video_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVidSrc2FarCtrlId::clear_has_inner_video_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVidSrc2FarCtrlId::clear_inner_video_src() {
  inner_video_src_ = 0;
  clear_has_inner_video_src();
}
inline ::mt::EmMtVideoPort TMTVidSrc2FarCtrlId::inner_video_src() const {
  return static_cast< ::mt::EmMtVideoPort >(inner_video_src_);
}
inline void TMTVidSrc2FarCtrlId::set_inner_video_src(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  set_has_inner_video_src();
  inner_video_src_ = value;
}

// optional uint32 video_src_id = 2;
inline bool TMTVidSrc2FarCtrlId::has_video_src_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVidSrc2FarCtrlId::set_has_video_src_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVidSrc2FarCtrlId::clear_has_video_src_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVidSrc2FarCtrlId::clear_video_src_id() {
  video_src_id_ = 0u;
  clear_has_video_src_id();
}
inline ::google::protobuf::uint32 TMTVidSrc2FarCtrlId::video_src_id() const {
  return video_src_id_;
}
inline void TMTVidSrc2FarCtrlId::set_video_src_id(::google::protobuf::uint32 value) {
  set_has_video_src_id();
  video_src_id_ = value;
}

// -------------------------------------------------------------------

// TMTVidSrc2FarCtrlIdGroup

// optional .mt.EmCodecComponent video_type = 1;
inline bool TMTVidSrc2FarCtrlIdGroup::has_video_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVidSrc2FarCtrlIdGroup::set_has_video_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVidSrc2FarCtrlIdGroup::clear_has_video_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVidSrc2FarCtrlIdGroup::clear_video_type() {
  video_type_ = 0;
  clear_has_video_type();
}
inline ::mt::EmCodecComponent TMTVidSrc2FarCtrlIdGroup::video_type() const {
  return static_cast< ::mt::EmCodecComponent >(video_type_);
}
inline void TMTVidSrc2FarCtrlIdGroup::set_video_type(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_video_type();
  video_type_ = value;
}

// optional .mt.EmCodecComponentIndex video_id = 2;
inline bool TMTVidSrc2FarCtrlIdGroup::has_video_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVidSrc2FarCtrlIdGroup::set_has_video_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVidSrc2FarCtrlIdGroup::clear_has_video_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVidSrc2FarCtrlIdGroup::clear_video_id() {
  video_id_ = 0;
  clear_has_video_id();
}
inline ::mt::EmCodecComponentIndex TMTVidSrc2FarCtrlIdGroup::video_id() const {
  return static_cast< ::mt::EmCodecComponentIndex >(video_id_);
}
inline void TMTVidSrc2FarCtrlIdGroup::set_video_id(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_video_id();
  video_id_ = value;
}

// repeated .mt.TMTVidSrc2FarCtrlId video_list = 3;
inline int TMTVidSrc2FarCtrlIdGroup::video_list_size() const {
  return video_list_.size();
}
inline void TMTVidSrc2FarCtrlIdGroup::clear_video_list() {
  video_list_.Clear();
}
inline const ::mt::TMTVidSrc2FarCtrlId& TMTVidSrc2FarCtrlIdGroup::video_list(int index) const {
  return video_list_.Get(index);
}
inline ::mt::TMTVidSrc2FarCtrlId* TMTVidSrc2FarCtrlIdGroup::mutable_video_list(int index) {
  return video_list_.Mutable(index);
}
inline ::mt::TMTVidSrc2FarCtrlId* TMTVidSrc2FarCtrlIdGroup::add_video_list() {
  return video_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidSrc2FarCtrlId >&
TMTVidSrc2FarCtrlIdGroup::video_list() const {
  return video_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidSrc2FarCtrlId >*
TMTVidSrc2FarCtrlIdGroup::mutable_video_list() {
  return &video_list_;
}

// -------------------------------------------------------------------

// TMTVidSrc2FarCtrlIdList

// repeated .mt.TMTVidSrc2FarCtrlIdGroup video_list = 1;
inline int TMTVidSrc2FarCtrlIdList::video_list_size() const {
  return video_list_.size();
}
inline void TMTVidSrc2FarCtrlIdList::clear_video_list() {
  video_list_.Clear();
}
inline const ::mt::TMTVidSrc2FarCtrlIdGroup& TMTVidSrc2FarCtrlIdList::video_list(int index) const {
  return video_list_.Get(index);
}
inline ::mt::TMTVidSrc2FarCtrlIdGroup* TMTVidSrc2FarCtrlIdList::mutable_video_list(int index) {
  return video_list_.Mutable(index);
}
inline ::mt::TMTVidSrc2FarCtrlIdGroup* TMTVidSrc2FarCtrlIdList::add_video_list() {
  return video_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidSrc2FarCtrlIdGroup >&
TMTVidSrc2FarCtrlIdList::video_list() const {
  return video_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidSrc2FarCtrlIdGroup >*
TMTVidSrc2FarCtrlIdList::mutable_video_list() {
  return &video_list_;
}

// -------------------------------------------------------------------

// TMTUsbPartition

// optional string path = 1;
inline bool TMTUsbPartition::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUsbPartition::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUsbPartition::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUsbPartition::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TMTUsbPartition::path() const {
  return *path_;
}
inline void TMTUsbPartition::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TMTUsbPartition::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TMTUsbPartition::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUsbPartition::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TMTUsbPartition::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUsbPartition::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TMTUsbPartition::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUsbPartition::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUsbPartition::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUsbPartition::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTUsbPartition::name() const {
  return *name_;
}
inline void TMTUsbPartition::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTUsbPartition::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTUsbPartition::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUsbPartition::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTUsbPartition::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUsbPartition::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 total_space = 3;
inline bool TMTUsbPartition::has_total_space() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTUsbPartition::set_has_total_space() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTUsbPartition::clear_has_total_space() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTUsbPartition::clear_total_space() {
  total_space_ = 0u;
  clear_has_total_space();
}
inline ::google::protobuf::uint32 TMTUsbPartition::total_space() const {
  return total_space_;
}
inline void TMTUsbPartition::set_total_space(::google::protobuf::uint32 value) {
  set_has_total_space();
  total_space_ = value;
}

// optional uint32 free_space = 4;
inline bool TMTUsbPartition::has_free_space() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTUsbPartition::set_has_free_space() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTUsbPartition::clear_has_free_space() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTUsbPartition::clear_free_space() {
  free_space_ = 0u;
  clear_has_free_space();
}
inline ::google::protobuf::uint32 TMTUsbPartition::free_space() const {
  return free_space_;
}
inline void TMTUsbPartition::set_free_space(::google::protobuf::uint32 value) {
  set_has_free_space();
  free_space_ = value;
}

// -------------------------------------------------------------------

// TMTUsbInfo

// optional uint32 usb_id = 1;
inline bool TMTUsbInfo::has_usb_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUsbInfo::set_has_usb_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUsbInfo::clear_has_usb_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUsbInfo::clear_usb_id() {
  usb_id_ = 0u;
  clear_has_usb_id();
}
inline ::google::protobuf::uint32 TMTUsbInfo::usb_id() const {
  return usb_id_;
}
inline void TMTUsbInfo::set_usb_id(::google::protobuf::uint32 value) {
  set_has_usb_id();
  usb_id_ = value;
}

// optional bool is_used = 2;
inline bool TMTUsbInfo::has_is_used() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUsbInfo::set_has_is_used() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUsbInfo::clear_has_is_used() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUsbInfo::clear_is_used() {
  is_used_ = false;
  clear_has_is_used();
}
inline bool TMTUsbInfo::is_used() const {
  return is_used_;
}
inline void TMTUsbInfo::set_is_used(bool value) {
  set_has_is_used();
  is_used_ = value;
}

// repeated .mt.TMTUsbPartition usb_partition = 3;
inline int TMTUsbInfo::usb_partition_size() const {
  return usb_partition_.size();
}
inline void TMTUsbInfo::clear_usb_partition() {
  usb_partition_.Clear();
}
inline const ::mt::TMTUsbPartition& TMTUsbInfo::usb_partition(int index) const {
  return usb_partition_.Get(index);
}
inline ::mt::TMTUsbPartition* TMTUsbInfo::mutable_usb_partition(int index) {
  return usb_partition_.Mutable(index);
}
inline ::mt::TMTUsbPartition* TMTUsbInfo::add_usb_partition() {
  return usb_partition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUsbPartition >&
TMTUsbInfo::usb_partition() const {
  return usb_partition_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUsbPartition >*
TMTUsbInfo::mutable_usb_partition() {
  return &usb_partition_;
}

// -------------------------------------------------------------------

// TMTUsbStatus

// repeated .mt.TMTUsbInfo usb_info = 1;
inline int TMTUsbStatus::usb_info_size() const {
  return usb_info_.size();
}
inline void TMTUsbStatus::clear_usb_info() {
  usb_info_.Clear();
}
inline const ::mt::TMTUsbInfo& TMTUsbStatus::usb_info(int index) const {
  return usb_info_.Get(index);
}
inline ::mt::TMTUsbInfo* TMTUsbStatus::mutable_usb_info(int index) {
  return usb_info_.Mutable(index);
}
inline ::mt::TMTUsbInfo* TMTUsbStatus::add_usb_info() {
  return usb_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUsbInfo >&
TMTUsbStatus::usb_info() const {
  return usb_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUsbInfo >*
TMTUsbStatus::mutable_usb_info() {
  return &usb_info_;
}

// -------------------------------------------------------------------

// TMTPathStructureUnit

// optional .mt.EmSystemFileType file_type = 1;
inline bool TMTPathStructureUnit::has_file_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPathStructureUnit::set_has_file_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPathStructureUnit::clear_has_file_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPathStructureUnit::clear_file_type() {
  file_type_ = 0;
  clear_has_file_type();
}
inline ::mt::EmSystemFileType TMTPathStructureUnit::file_type() const {
  return static_cast< ::mt::EmSystemFileType >(file_type_);
}
inline void TMTPathStructureUnit::set_file_type(::mt::EmSystemFileType value) {
  assert(::mt::EmSystemFileType_IsValid(value));
  set_has_file_type();
  file_type_ = value;
}

// optional string path = 2;
inline bool TMTPathStructureUnit::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPathStructureUnit::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPathStructureUnit::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPathStructureUnit::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TMTPathStructureUnit::path() const {
  return *path_;
}
inline void TMTPathStructureUnit::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TMTPathStructureUnit::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TMTPathStructureUnit::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPathStructureUnit::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TMTPathStructureUnit::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPathStructureUnit::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTPathStructureDetail

// repeated .mt.TMTPathStructureUnit path_unit_list = 1;
inline int TMTPathStructureDetail::path_unit_list_size() const {
  return path_unit_list_.size();
}
inline void TMTPathStructureDetail::clear_path_unit_list() {
  path_unit_list_.Clear();
}
inline const ::mt::TMTPathStructureUnit& TMTPathStructureDetail::path_unit_list(int index) const {
  return path_unit_list_.Get(index);
}
inline ::mt::TMTPathStructureUnit* TMTPathStructureDetail::mutable_path_unit_list(int index) {
  return path_unit_list_.Mutable(index);
}
inline ::mt::TMTPathStructureUnit* TMTPathStructureDetail::add_path_unit_list() {
  return path_unit_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPathStructureUnit >&
TMTPathStructureDetail::path_unit_list() const {
  return path_unit_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPathStructureUnit >*
TMTPathStructureDetail::mutable_path_unit_list() {
  return &path_unit_list_;
}

// -------------------------------------------------------------------

// TMTBrdInfo

// optional string name = 1;
inline bool TMTBrdInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTBrdInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTBrdInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTBrdInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTBrdInfo::name() const {
  return *name_;
}
inline void TMTBrdInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTBrdInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTBrdInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBrdInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTBrdInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBrdInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 brd_id = 2;
inline bool TMTBrdInfo::has_brd_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTBrdInfo::set_has_brd_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTBrdInfo::clear_has_brd_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTBrdInfo::clear_brd_id() {
  brd_id_ = 0u;
  clear_has_brd_id();
}
inline ::google::protobuf::uint32 TMTBrdInfo::brd_id() const {
  return brd_id_;
}
inline void TMTBrdInfo::set_brd_id(::google::protobuf::uint32 value) {
  set_has_brd_id();
  brd_id_ = value;
}

// optional uint32 brd_version = 3;
inline bool TMTBrdInfo::has_brd_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTBrdInfo::set_has_brd_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTBrdInfo::clear_has_brd_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTBrdInfo::clear_brd_version() {
  brd_version_ = 0u;
  clear_has_brd_version();
}
inline ::google::protobuf::uint32 TMTBrdInfo::brd_version() const {
  return brd_version_;
}
inline void TMTBrdInfo::set_brd_version(::google::protobuf::uint32 value) {
  set_has_brd_version();
  brd_version_ = value;
}

// optional uint32 pld_version = 4;
inline bool TMTBrdInfo::has_pld_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTBrdInfo::set_has_pld_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTBrdInfo::clear_has_pld_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTBrdInfo::clear_pld_version() {
  pld_version_ = 0u;
  clear_has_pld_version();
}
inline ::google::protobuf::uint32 TMTBrdInfo::pld_version() const {
  return pld_version_;
}
inline void TMTBrdInfo::set_pld_version(::google::protobuf::uint32 value) {
  set_has_pld_version();
  pld_version_ = value;
}

// optional uint32 fpga_version = 5;
inline bool TMTBrdInfo::has_fpga_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTBrdInfo::set_has_fpga_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTBrdInfo::clear_has_fpga_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTBrdInfo::clear_fpga_version() {
  fpga_version_ = 0u;
  clear_has_fpga_version();
}
inline ::google::protobuf::uint32 TMTBrdInfo::fpga_version() const {
  return fpga_version_;
}
inline void TMTBrdInfo::set_fpga_version(::google::protobuf::uint32 value) {
  set_has_fpga_version();
  fpga_version_ = value;
}

// optional int32 layer = 6;
inline bool TMTBrdInfo::has_layer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTBrdInfo::set_has_layer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTBrdInfo::clear_has_layer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTBrdInfo::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 TMTBrdInfo::layer() const {
  return layer_;
}
inline void TMTBrdInfo::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// optional int32 slot = 7;
inline bool TMTBrdInfo::has_slot() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTBrdInfo::set_has_slot() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTBrdInfo::clear_has_slot() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTBrdInfo::clear_slot() {
  slot_ = 0;
  clear_has_slot();
}
inline ::google::protobuf::int32 TMTBrdInfo::slot() const {
  return slot_;
}
inline void TMTBrdInfo::set_slot(::google::protobuf::int32 value) {
  set_has_slot();
  slot_ = value;
}

// optional uint32 CpuNum = 8;
inline bool TMTBrdInfo::has_cpunum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTBrdInfo::set_has_cpunum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTBrdInfo::clear_has_cpunum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTBrdInfo::clear_cpunum() {
  cpunum_ = 0u;
  clear_has_cpunum();
}
inline ::google::protobuf::uint32 TMTBrdInfo::cpunum() const {
  return cpunum_;
}
inline void TMTBrdInfo::set_cpunum(::google::protobuf::uint32 value) {
  set_has_cpunum();
  cpunum_ = value;
}

// optional uint32 CpuSelfNo = 9;
inline bool TMTBrdInfo::has_cpuselfno() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTBrdInfo::set_has_cpuselfno() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTBrdInfo::clear_has_cpuselfno() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTBrdInfo::clear_cpuselfno() {
  cpuselfno_ = 0u;
  clear_has_cpuselfno();
}
inline ::google::protobuf::uint32 TMTBrdInfo::cpuselfno() const {
  return cpuselfno_;
}
inline void TMTBrdInfo::set_cpuselfno(::google::protobuf::uint32 value) {
  set_has_cpuselfno();
  cpuselfno_ = value;
}

// optional uint32 PldNum = 10;
inline bool TMTBrdInfo::has_pldnum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTBrdInfo::set_has_pldnum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTBrdInfo::clear_has_pldnum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTBrdInfo::clear_pldnum() {
  pldnum_ = 0u;
  clear_has_pldnum();
}
inline ::google::protobuf::uint32 TMTBrdInfo::pldnum() const {
  return pldnum_;
}
inline void TMTBrdInfo::set_pldnum(::google::protobuf::uint32 value) {
  set_has_pldnum();
  pldnum_ = value;
}

// optional uint32 FpgaNum = 11;
inline bool TMTBrdInfo::has_fpganum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTBrdInfo::set_has_fpganum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTBrdInfo::clear_has_fpganum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTBrdInfo::clear_fpganum() {
  fpganum_ = 0u;
  clear_has_fpganum();
}
inline ::google::protobuf::uint32 TMTBrdInfo::fpganum() const {
  return fpganum_;
}
inline void TMTBrdInfo::set_fpganum(::google::protobuf::uint32 value) {
  set_has_fpganum();
  fpganum_ = value;
}

// optional uint32 RtcNum = 12;
inline bool TMTBrdInfo::has_rtcnum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTBrdInfo::set_has_rtcnum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTBrdInfo::clear_has_rtcnum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTBrdInfo::clear_rtcnum() {
  rtcnum_ = 0u;
  clear_has_rtcnum();
}
inline ::google::protobuf::uint32 TMTBrdInfo::rtcnum() const {
  return rtcnum_;
}
inline void TMTBrdInfo::set_rtcnum(::google::protobuf::uint32 value) {
  set_has_rtcnum();
  rtcnum_ = value;
}

// optional uint32 EthNum = 13;
inline bool TMTBrdInfo::has_ethnum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTBrdInfo::set_has_ethnum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTBrdInfo::clear_has_ethnum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTBrdInfo::clear_ethnum() {
  ethnum_ = 0u;
  clear_has_ethnum();
}
inline ::google::protobuf::uint32 TMTBrdInfo::ethnum() const {
  return ethnum_;
}
inline void TMTBrdInfo::set_ethnum(::google::protobuf::uint32 value) {
  set_has_ethnum();
  ethnum_ = value;
}

// optional uint32 E1Num = 14;
inline bool TMTBrdInfo::has_e1num() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTBrdInfo::set_has_e1num() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTBrdInfo::clear_has_e1num() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTBrdInfo::clear_e1num() {
  e1num_ = 0u;
  clear_has_e1num();
}
inline ::google::protobuf::uint32 TMTBrdInfo::e1num() const {
  return e1num_;
}
inline void TMTBrdInfo::set_e1num(::google::protobuf::uint32 value) {
  set_has_e1num();
  e1num_ = value;
}

// optional uint32 V35Num = 15;
inline bool TMTBrdInfo::has_v35num() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTBrdInfo::set_has_v35num() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTBrdInfo::clear_has_v35num() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTBrdInfo::clear_v35num() {
  v35num_ = 0u;
  clear_has_v35num();
}
inline ::google::protobuf::uint32 TMTBrdInfo::v35num() const {
  return v35num_;
}
inline void TMTBrdInfo::set_v35num(::google::protobuf::uint32 value) {
  set_has_v35num();
  v35num_ = value;
}

// optional uint32 SerialNum = 16;
inline bool TMTBrdInfo::has_serialnum() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTBrdInfo::set_has_serialnum() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTBrdInfo::clear_has_serialnum() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTBrdInfo::clear_serialnum() {
  serialnum_ = 0u;
  clear_has_serialnum();
}
inline ::google::protobuf::uint32 TMTBrdInfo::serialnum() const {
  return serialnum_;
}
inline void TMTBrdInfo::set_serialnum(::google::protobuf::uint32 value) {
  set_has_serialnum();
  serialnum_ = value;
}

// optional uint32 FanNum = 17;
inline bool TMTBrdInfo::has_fannum() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTBrdInfo::set_has_fannum() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTBrdInfo::clear_has_fannum() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTBrdInfo::clear_fannum() {
  fannum_ = 0u;
  clear_has_fannum();
}
inline ::google::protobuf::uint32 TMTBrdInfo::fannum() const {
  return fannum_;
}
inline void TMTBrdInfo::set_fannum(::google::protobuf::uint32 value) {
  set_has_fannum();
  fannum_ = value;
}

// optional uint32 LedNum = 18;
inline bool TMTBrdInfo::has_lednum() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTBrdInfo::set_has_lednum() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTBrdInfo::clear_has_lednum() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTBrdInfo::clear_lednum() {
  lednum_ = 0u;
  clear_has_lednum();
}
inline ::google::protobuf::uint32 TMTBrdInfo::lednum() const {
  return lednum_;
}
inline void TMTBrdInfo::set_lednum(::google::protobuf::uint32 value) {
  set_has_lednum();
  lednum_ = value;
}

// optional uint32 ButtonNum = 19;
inline bool TMTBrdInfo::has_buttonnum() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTBrdInfo::set_has_buttonnum() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTBrdInfo::clear_has_buttonnum() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTBrdInfo::clear_buttonnum() {
  buttonnum_ = 0u;
  clear_has_buttonnum();
}
inline ::google::protobuf::uint32 TMTBrdInfo::buttonnum() const {
  return buttonnum_;
}
inline void TMTBrdInfo::set_buttonnum(::google::protobuf::uint32 value) {
  set_has_buttonnum();
  buttonnum_ = value;
}

// optional uint32 HwmonNum = 20;
inline bool TMTBrdInfo::has_hwmonnum() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTBrdInfo::set_has_hwmonnum() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTBrdInfo::clear_has_hwmonnum() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTBrdInfo::clear_hwmonnum() {
  hwmonnum_ = 0u;
  clear_has_hwmonnum();
}
inline ::google::protobuf::uint32 TMTBrdInfo::hwmonnum() const {
  return hwmonnum_;
}
inline void TMTBrdInfo::set_hwmonnum(::google::protobuf::uint32 value) {
  set_has_hwmonnum();
  hwmonnum_ = value;
}

// optional uint32 OledNum = 21;
inline bool TMTBrdInfo::has_olednum() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTBrdInfo::set_has_olednum() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTBrdInfo::clear_has_olednum() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTBrdInfo::clear_olednum() {
  olednum_ = 0u;
  clear_has_olednum();
}
inline ::google::protobuf::uint32 TMTBrdInfo::olednum() const {
  return olednum_;
}
inline void TMTBrdInfo::set_olednum(::google::protobuf::uint32 value) {
  set_has_olednum();
  olednum_ = value;
}

// -------------------------------------------------------------------

// TMTMicStatus

// optional uint32 MicId = 1;
inline bool TMTMicStatus::has_micid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTMicStatus::set_has_micid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTMicStatus::clear_has_micid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTMicStatus::clear_micid() {
  micid_ = 0u;
  clear_has_micid();
}
inline ::google::protobuf::uint32 TMTMicStatus::micid() const {
  return micid_;
}
inline void TMTMicStatus::set_micid(::google::protobuf::uint32 value) {
  set_has_micid();
  micid_ = value;
}

// optional uint32 Status = 2;
inline bool TMTMicStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTMicStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTMicStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTMicStatus::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 TMTMicStatus::status() const {
  return status_;
}
inline void TMTMicStatus::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// TMTMicInfo

// repeated .mt.TMTMicStatus MicStatus = 1;
inline int TMTMicInfo::micstatus_size() const {
  return micstatus_.size();
}
inline void TMTMicInfo::clear_micstatus() {
  micstatus_.Clear();
}
inline const ::mt::TMTMicStatus& TMTMicInfo::micstatus(int index) const {
  return micstatus_.Get(index);
}
inline ::mt::TMTMicStatus* TMTMicInfo::mutable_micstatus(int index) {
  return micstatus_.Mutable(index);
}
inline ::mt::TMTMicStatus* TMTMicInfo::add_micstatus() {
  return micstatus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTMicStatus >&
TMTMicInfo::micstatus() const {
  return micstatus_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTMicStatus >*
TMTMicInfo::mutable_micstatus() {
  return &micstatus_;
}

// -------------------------------------------------------------------

// TMicUpgradeState

// optional uint32 MicId = 1;
inline bool TMicUpgradeState::has_micid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMicUpgradeState::set_has_micid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMicUpgradeState::clear_has_micid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMicUpgradeState::clear_micid() {
  micid_ = 0u;
  clear_has_micid();
}
inline ::google::protobuf::uint32 TMicUpgradeState::micid() const {
  return micid_;
}
inline void TMicUpgradeState::set_micid(::google::protobuf::uint32 value) {
  set_has_micid();
  micid_ = value;
}

// optional uint32 State = 2;
inline bool TMicUpgradeState::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMicUpgradeState::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMicUpgradeState::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMicUpgradeState::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 TMicUpgradeState::state() const {
  return state_;
}
inline void TMicUpgradeState::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 Progress = 3;
inline bool TMicUpgradeState::has_progress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMicUpgradeState::set_has_progress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMicUpgradeState::clear_has_progress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMicUpgradeState::clear_progress() {
  progress_ = 0u;
  clear_has_progress();
}
inline ::google::protobuf::uint32 TMicUpgradeState::progress() const {
  return progress_;
}
inline void TMicUpgradeState::set_progress(::google::protobuf::uint32 value) {
  set_has_progress();
  progress_ = value;
}

// -------------------------------------------------------------------

// TMicUpgradeStateList

// repeated .mt.TMicUpgradeState MicUpgradeState = 1;
inline int TMicUpgradeStateList::micupgradestate_size() const {
  return micupgradestate_.size();
}
inline void TMicUpgradeStateList::clear_micupgradestate() {
  micupgradestate_.Clear();
}
inline const ::mt::TMicUpgradeState& TMicUpgradeStateList::micupgradestate(int index) const {
  return micupgradestate_.Get(index);
}
inline ::mt::TMicUpgradeState* TMicUpgradeStateList::mutable_micupgradestate(int index) {
  return micupgradestate_.Mutable(index);
}
inline ::mt::TMicUpgradeState* TMicUpgradeStateList::add_micupgradestate() {
  return micupgradestate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMicUpgradeState >&
TMicUpgradeStateList::micupgradestate() const {
  return micupgradestate_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMicUpgradeState >*
TMicUpgradeStateList::mutable_micupgradestate() {
  return &micupgradestate_;
}

// -------------------------------------------------------------------

// TMicInstall

// optional uint32 MicId = 1;
inline bool TMicInstall::has_micid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMicInstall::set_has_micid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMicInstall::clear_has_micid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMicInstall::clear_micid() {
  micid_ = 0u;
  clear_has_micid();
}
inline ::google::protobuf::uint32 TMicInstall::micid() const {
  return micid_;
}
inline void TMicInstall::set_micid(::google::protobuf::uint32 value) {
  set_has_micid();
  micid_ = value;
}

// optional uint32 State = 2;
inline bool TMicInstall::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMicInstall::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMicInstall::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMicInstall::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 TMicInstall::state() const {
  return state_;
}
inline void TMicInstall::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// TMicInstallList

// repeated .mt.TMicInstall MicInstall = 1;
inline int TMicInstallList::micinstall_size() const {
  return micinstall_.size();
}
inline void TMicInstallList::clear_micinstall() {
  micinstall_.Clear();
}
inline const ::mt::TMicInstall& TMicInstallList::micinstall(int index) const {
  return micinstall_.Get(index);
}
inline ::mt::TMicInstall* TMicInstallList::mutable_micinstall(int index) {
  return micinstall_.Mutable(index);
}
inline ::mt::TMicInstall* TMicInstallList::add_micinstall() {
  return micinstall_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMicInstall >&
TMicInstallList::micinstall() const {
  return micinstall_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMicInstall >*
TMicInstallList::mutable_micinstall() {
  return &micinstall_;
}

// -------------------------------------------------------------------

// TMTRfMatchState

// optional .mt.EmMicDevId dev_id = 1;
inline bool TMTRfMatchState::has_dev_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRfMatchState::set_has_dev_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRfMatchState::clear_has_dev_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRfMatchState::clear_dev_id() {
  dev_id_ = 0;
  clear_has_dev_id();
}
inline ::mt::EmMicDevId TMTRfMatchState::dev_id() const {
  return static_cast< ::mt::EmMicDevId >(dev_id_);
}
inline void TMTRfMatchState::set_dev_id(::mt::EmMicDevId value) {
  assert(::mt::EmMicDevId_IsValid(value));
  set_has_dev_id();
  dev_id_ = value;
}

// optional bool is_matched = 2;
inline bool TMTRfMatchState::has_is_matched() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRfMatchState::set_has_is_matched() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRfMatchState::clear_has_is_matched() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRfMatchState::clear_is_matched() {
  is_matched_ = false;
  clear_has_is_matched();
}
inline bool TMTRfMatchState::is_matched() const {
  return is_matched_;
}
inline void TMTRfMatchState::set_is_matched(bool value) {
  set_has_is_matched();
  is_matched_ = value;
}

// optional uint32 matched_id = 3;
inline bool TMTRfMatchState::has_matched_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRfMatchState::set_has_matched_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRfMatchState::clear_has_matched_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRfMatchState::clear_matched_id() {
  matched_id_ = 0u;
  clear_has_matched_id();
}
inline ::google::protobuf::uint32 TMTRfMatchState::matched_id() const {
  return matched_id_;
}
inline void TMTRfMatchState::set_matched_id(::google::protobuf::uint32 value) {
  set_has_matched_id();
  matched_id_ = value;
}

// -------------------------------------------------------------------

// TMTRfMatchStateList

// repeated .mt.TMTRfMatchState rf_match_status = 1;
inline int TMTRfMatchStateList::rf_match_status_size() const {
  return rf_match_status_.size();
}
inline void TMTRfMatchStateList::clear_rf_match_status() {
  rf_match_status_.Clear();
}
inline const ::mt::TMTRfMatchState& TMTRfMatchStateList::rf_match_status(int index) const {
  return rf_match_status_.Get(index);
}
inline ::mt::TMTRfMatchState* TMTRfMatchStateList::mutable_rf_match_status(int index) {
  return rf_match_status_.Mutable(index);
}
inline ::mt::TMTRfMatchState* TMTRfMatchStateList::add_rf_match_status() {
  return rf_match_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRfMatchState >&
TMTRfMatchStateList::rf_match_status() const {
  return rf_match_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRfMatchState >*
TMTRfMatchStateList::mutable_rf_match_status() {
  return &rf_match_status_;
}

// -------------------------------------------------------------------

// TMTMicDecibel

// optional uint32 MicId = 1;
inline bool TMTMicDecibel::has_micid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTMicDecibel::set_has_micid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTMicDecibel::clear_has_micid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTMicDecibel::clear_micid() {
  micid_ = 0u;
  clear_has_micid();
}
inline ::google::protobuf::uint32 TMTMicDecibel::micid() const {
  return micid_;
}
inline void TMTMicDecibel::set_micid(::google::protobuf::uint32 value) {
  set_has_micid();
  micid_ = value;
}

// optional uint32 MiTouId = 2;
inline bool TMTMicDecibel::has_mitouid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTMicDecibel::set_has_mitouid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTMicDecibel::clear_has_mitouid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTMicDecibel::clear_mitouid() {
  mitouid_ = 0u;
  clear_has_mitouid();
}
inline ::google::protobuf::uint32 TMTMicDecibel::mitouid() const {
  return mitouid_;
}
inline void TMTMicDecibel::set_mitouid(::google::protobuf::uint32 value) {
  set_has_mitouid();
  mitouid_ = value;
}

// optional uint32 Value = 3;
inline bool TMTMicDecibel::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTMicDecibel::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTMicDecibel::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTMicDecibel::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 TMTMicDecibel::value() const {
  return value_;
}
inline void TMTMicDecibel::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// TMicVersionInfo

// optional uint32 MicId = 1;
inline bool TMicVersionInfo::has_micid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMicVersionInfo::set_has_micid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMicVersionInfo::clear_has_micid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMicVersionInfo::clear_micid() {
  micid_ = 0u;
  clear_has_micid();
}
inline ::google::protobuf::uint32 TMicVersionInfo::micid() const {
  return micid_;
}
inline void TMicVersionInfo::set_micid(::google::protobuf::uint32 value) {
  set_has_micid();
  micid_ = value;
}

// optional string Version = 2;
inline bool TMicVersionInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMicVersionInfo::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMicVersionInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMicVersionInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TMicVersionInfo::version() const {
  return *version_;
}
inline void TMicVersionInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TMicVersionInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TMicVersionInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMicVersionInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* TMicVersionInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMicVersionInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMicVersionList

// repeated .mt.TMicVersionInfo MicVer = 1;
inline int TMicVersionList::micver_size() const {
  return micver_.size();
}
inline void TMicVersionList::clear_micver() {
  micver_.Clear();
}
inline const ::mt::TMicVersionInfo& TMicVersionList::micver(int index) const {
  return micver_.Get(index);
}
inline ::mt::TMicVersionInfo* TMicVersionList::mutable_micver(int index) {
  return micver_.Mutable(index);
}
inline ::mt::TMicVersionInfo* TMicVersionList::add_micver() {
  return micver_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMicVersionInfo >&
TMicVersionList::micver() const {
  return micver_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMicVersionInfo >*
TMicVersionList::mutable_micver() {
  return &micver_;
}

// -------------------------------------------------------------------

// TNetCapFileInfo

// optional string file_name = 1;
inline bool TNetCapFileInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNetCapFileInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNetCapFileInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNetCapFileInfo::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& TNetCapFileInfo::file_name() const {
  return *file_name_;
}
inline void TNetCapFileInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TNetCapFileInfo::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TNetCapFileInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNetCapFileInfo::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* TNetCapFileInfo::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNetCapFileInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 file_size = 2;
inline bool TNetCapFileInfo::has_file_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNetCapFileInfo::set_has_file_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNetCapFileInfo::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNetCapFileInfo::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 TNetCapFileInfo::file_size() const {
  return file_size_;
}
inline void TNetCapFileInfo::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
}

// -------------------------------------------------------------------

// TNetCapFileList

// optional string file_path = 1;
inline bool TNetCapFileList::has_file_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNetCapFileList::set_has_file_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNetCapFileList::clear_has_file_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNetCapFileList::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& TNetCapFileList::file_path() const {
  return *file_path_;
}
inline void TNetCapFileList::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void TNetCapFileList::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void TNetCapFileList::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNetCapFileList::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  return file_path_;
}
inline ::std::string* TNetCapFileList::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNetCapFileList::set_allocated_file_path(::std::string* file_path) {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    delete file_path_;
  }
  if (file_path) {
    set_has_file_path();
    file_path_ = file_path;
  } else {
    clear_has_file_path();
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mt.TNetCapFileInfo file_list = 2;
inline int TNetCapFileList::file_list_size() const {
  return file_list_.size();
}
inline void TNetCapFileList::clear_file_list() {
  file_list_.Clear();
}
inline const ::mt::TNetCapFileInfo& TNetCapFileList::file_list(int index) const {
  return file_list_.Get(index);
}
inline ::mt::TNetCapFileInfo* TNetCapFileList::mutable_file_list(int index) {
  return file_list_.Mutable(index);
}
inline ::mt::TNetCapFileInfo* TNetCapFileList::add_file_list() {
  return file_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TNetCapFileInfo >&
TNetCapFileList::file_list() const {
  return file_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TNetCapFileInfo >*
TNetCapFileList::mutable_file_list() {
  return &file_list_;
}

// -------------------------------------------------------------------

// TFpgaVersionList

// repeated uint32 FpgaVersion = 1;
inline int TFpgaVersionList::fpgaversion_size() const {
  return fpgaversion_.size();
}
inline void TFpgaVersionList::clear_fpgaversion() {
  fpgaversion_.Clear();
}
inline ::google::protobuf::uint32 TFpgaVersionList::fpgaversion(int index) const {
  return fpgaversion_.Get(index);
}
inline void TFpgaVersionList::set_fpgaversion(int index, ::google::protobuf::uint32 value) {
  fpgaversion_.Set(index, value);
}
inline void TFpgaVersionList::add_fpgaversion(::google::protobuf::uint32 value) {
  fpgaversion_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TFpgaVersionList::fpgaversion() const {
  return fpgaversion_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TFpgaVersionList::mutable_fpgaversion() {
  return &fpgaversion_;
}

// -------------------------------------------------------------------

// TCameraImageParam

// optional .mt.EmImgParam type = 1;
inline bool TCameraImageParam::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCameraImageParam::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCameraImageParam::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCameraImageParam::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmImgParam TCameraImageParam::type() const {
  return static_cast< ::mt::EmImgParam >(type_);
}
inline void TCameraImageParam::set_type(::mt::EmImgParam value) {
  assert(::mt::EmImgParam_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 value = 2;
inline bool TCameraImageParam::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCameraImageParam::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCameraImageParam::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCameraImageParam::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 TCameraImageParam::value() const {
  return value_;
}
inline void TCameraImageParam::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// optional uint32 min_val = 3;
inline bool TCameraImageParam::has_min_val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TCameraImageParam::set_has_min_val() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TCameraImageParam::clear_has_min_val() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TCameraImageParam::clear_min_val() {
  min_val_ = 0u;
  clear_has_min_val();
}
inline ::google::protobuf::uint32 TCameraImageParam::min_val() const {
  return min_val_;
}
inline void TCameraImageParam::set_min_val(::google::protobuf::uint32 value) {
  set_has_min_val();
  min_val_ = value;
}

// optional uint32 max_val = 4;
inline bool TCameraImageParam::has_max_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TCameraImageParam::set_has_max_val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TCameraImageParam::clear_has_max_val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TCameraImageParam::clear_max_val() {
  max_val_ = 0u;
  clear_has_max_val();
}
inline ::google::protobuf::uint32 TCameraImageParam::max_val() const {
  return max_val_;
}
inline void TCameraImageParam::set_max_val(::google::protobuf::uint32 value) {
  set_has_max_val();
  max_val_ = value;
}

// optional uint32 step = 5;
inline bool TCameraImageParam::has_step() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TCameraImageParam::set_has_step() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TCameraImageParam::clear_has_step() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TCameraImageParam::clear_step() {
  step_ = 0u;
  clear_has_step();
}
inline ::google::protobuf::uint32 TCameraImageParam::step() const {
  return step_;
}
inline void TCameraImageParam::set_step(::google::protobuf::uint32 value) {
  set_has_step();
  step_ = value;
}

// -------------------------------------------------------------------

// TCameraIspParam

// optional .mt.EmIspImgInf type = 1;
inline bool TCameraIspParam::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCameraIspParam::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCameraIspParam::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCameraIspParam::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmIspImgInf TCameraIspParam::type() const {
  return static_cast< ::mt::EmIspImgInf >(type_);
}
inline void TCameraIspParam::set_type(::mt::EmIspImgInf value) {
  assert(::mt::EmIspImgInf_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 value = 2;
inline bool TCameraIspParam::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCameraIspParam::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCameraIspParam::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCameraIspParam::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 TCameraIspParam::value() const {
  return value_;
}
inline void TCameraIspParam::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// optional uint32 min_val = 3;
inline bool TCameraIspParam::has_min_val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TCameraIspParam::set_has_min_val() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TCameraIspParam::clear_has_min_val() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TCameraIspParam::clear_min_val() {
  min_val_ = 0u;
  clear_has_min_val();
}
inline ::google::protobuf::uint32 TCameraIspParam::min_val() const {
  return min_val_;
}
inline void TCameraIspParam::set_min_val(::google::protobuf::uint32 value) {
  set_has_min_val();
  min_val_ = value;
}

// optional uint32 max_val = 4;
inline bool TCameraIspParam::has_max_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TCameraIspParam::set_has_max_val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TCameraIspParam::clear_has_max_val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TCameraIspParam::clear_max_val() {
  max_val_ = 0u;
  clear_has_max_val();
}
inline ::google::protobuf::uint32 TCameraIspParam::max_val() const {
  return max_val_;
}
inline void TCameraIspParam::set_max_val(::google::protobuf::uint32 value) {
  set_has_max_val();
  max_val_ = value;
}

// optional uint32 step = 5;
inline bool TCameraIspParam::has_step() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TCameraIspParam::set_has_step() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TCameraIspParam::clear_has_step() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TCameraIspParam::clear_step() {
  step_ = 0u;
  clear_has_step();
}
inline ::google::protobuf::uint32 TCameraIspParam::step() const {
  return step_;
}
inline void TCameraIspParam::set_step(::google::protobuf::uint32 value) {
  set_has_step();
  step_ = value;
}

// -------------------------------------------------------------------

// TSerialOptParam

// optional int32 serialtype = 1;
inline bool TSerialOptParam::has_serialtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSerialOptParam::set_has_serialtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSerialOptParam::clear_has_serialtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSerialOptParam::clear_serialtype() {
  serialtype_ = 0;
  clear_has_serialtype();
}
inline ::google::protobuf::int32 TSerialOptParam::serialtype() const {
  return serialtype_;
}
inline void TSerialOptParam::set_serialtype(::google::protobuf::int32 value) {
  set_has_serialtype();
  serialtype_ = value;
}

// optional int32 operatetype = 2;
inline bool TSerialOptParam::has_operatetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TSerialOptParam::set_has_operatetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TSerialOptParam::clear_has_operatetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TSerialOptParam::clear_operatetype() {
  operatetype_ = 0;
  clear_has_operatetype();
}
inline ::google::protobuf::int32 TSerialOptParam::operatetype() const {
  return operatetype_;
}
inline void TSerialOptParam::set_operatetype(::google::protobuf::int32 value) {
  set_has_operatetype();
  operatetype_ = value;
}

// optional int32 len = 3;
inline bool TSerialOptParam::has_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TSerialOptParam::set_has_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TSerialOptParam::clear_has_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TSerialOptParam::clear_len() {
  len_ = 0;
  clear_has_len();
}
inline ::google::protobuf::int32 TSerialOptParam::len() const {
  return len_;
}
inline void TSerialOptParam::set_len(::google::protobuf::int32 value) {
  set_has_len();
  len_ = value;
}

// optional int32 listentime = 4;
inline bool TSerialOptParam::has_listentime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TSerialOptParam::set_has_listentime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TSerialOptParam::clear_has_listentime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TSerialOptParam::clear_listentime() {
  listentime_ = 0;
  clear_has_listentime();
}
inline ::google::protobuf::int32 TSerialOptParam::listentime() const {
  return listentime_;
}
inline void TSerialOptParam::set_listentime(::google::protobuf::int32 value) {
  set_has_listentime();
  listentime_ = value;
}

// optional bytes content = 5;
inline bool TSerialOptParam::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TSerialOptParam::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TSerialOptParam::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TSerialOptParam::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& TSerialOptParam::content() const {
  return *content_;
}
inline void TSerialOptParam::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void TSerialOptParam::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void TSerialOptParam::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSerialOptParam::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* TSerialOptParam::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSerialOptParam::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TCameraSceneModeCapList

// repeated uint32 SceneModeCap = 1;
inline int TCameraSceneModeCapList::scenemodecap_size() const {
  return scenemodecap_.size();
}
inline void TCameraSceneModeCapList::clear_scenemodecap() {
  scenemodecap_.Clear();
}
inline ::google::protobuf::uint32 TCameraSceneModeCapList::scenemodecap(int index) const {
  return scenemodecap_.Get(index);
}
inline void TCameraSceneModeCapList::set_scenemodecap(int index, ::google::protobuf::uint32 value) {
  scenemodecap_.Set(index, value);
}
inline void TCameraSceneModeCapList::add_scenemodecap(::google::protobuf::uint32 value) {
  scenemodecap_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TCameraSceneModeCapList::scenemodecap() const {
  return scenemodecap_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TCameraSceneModeCapList::mutable_scenemodecap() {
  return &scenemodecap_;
}

// -------------------------------------------------------------------

// TMTMicTag

// optional uint32 MicID = 1;
inline bool TMTMicTag::has_micid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTMicTag::set_has_micid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTMicTag::clear_has_micid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTMicTag::clear_micid() {
  micid_ = 0u;
  clear_has_micid();
}
inline ::google::protobuf::uint32 TMTMicTag::micid() const {
  return micid_;
}
inline void TMTMicTag::set_micid(::google::protobuf::uint32 value) {
  set_has_micid();
  micid_ = value;
}

// optional string MicTag = 2;
inline bool TMTMicTag::has_mictag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTMicTag::set_has_mictag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTMicTag::clear_has_mictag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTMicTag::clear_mictag() {
  if (mictag_ != &::google::protobuf::internal::kEmptyString) {
    mictag_->clear();
  }
  clear_has_mictag();
}
inline const ::std::string& TMTMicTag::mictag() const {
  return *mictag_;
}
inline void TMTMicTag::set_mictag(const ::std::string& value) {
  set_has_mictag();
  if (mictag_ == &::google::protobuf::internal::kEmptyString) {
    mictag_ = new ::std::string;
  }
  mictag_->assign(value);
}
inline void TMTMicTag::set_mictag(const char* value) {
  set_has_mictag();
  if (mictag_ == &::google::protobuf::internal::kEmptyString) {
    mictag_ = new ::std::string;
  }
  mictag_->assign(value);
}
inline void TMTMicTag::set_mictag(const char* value, size_t size) {
  set_has_mictag();
  if (mictag_ == &::google::protobuf::internal::kEmptyString) {
    mictag_ = new ::std::string;
  }
  mictag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMicTag::mutable_mictag() {
  set_has_mictag();
  if (mictag_ == &::google::protobuf::internal::kEmptyString) {
    mictag_ = new ::std::string;
  }
  return mictag_;
}
inline ::std::string* TMTMicTag::release_mictag() {
  clear_has_mictag();
  if (mictag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mictag_;
    mictag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMicTag::set_allocated_mictag(::std::string* mictag) {
  if (mictag_ != &::google::protobuf::internal::kEmptyString) {
    delete mictag_;
  }
  if (mictag) {
    set_has_mictag();
    mictag_ = mictag;
  } else {
    clear_has_mictag();
    mictag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTMicTagList

// repeated .mt.TMTMicTag MicTagList = 1;
inline int TMTMicTagList::mictaglist_size() const {
  return mictaglist_.size();
}
inline void TMTMicTagList::clear_mictaglist() {
  mictaglist_.Clear();
}
inline const ::mt::TMTMicTag& TMTMicTagList::mictaglist(int index) const {
  return mictaglist_.Get(index);
}
inline ::mt::TMTMicTag* TMTMicTagList::mutable_mictaglist(int index) {
  return mictaglist_.Mutable(index);
}
inline ::mt::TMTMicTag* TMTMicTagList::add_mictaglist() {
  return mictaglist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTMicTag >&
TMTMicTagList::mictaglist() const {
  return mictaglist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTMicTag >*
TMTMicTagList::mutable_mictaglist() {
  return &mictaglist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mt

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_structdevice_2eproto__INCLUDED
