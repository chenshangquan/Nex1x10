// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structim.proto

#ifndef PROTOBUF_structim_2eproto__INCLUDED
#define PROTOBUF_structim_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "enum.pb.h"
// @@protoc_insertion_point(includes)

namespace mt {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_structim_2eproto();
void protobuf_AssignDesc_structim_2eproto();
void protobuf_ShutdownFile_structim_2eproto();

class TImUserLogin;
class TImSelfDefInfo;
class TImSelfDefPic;
class TImSelfDefList;
class TImGroupInfo;
class TImGroupList;
class TImSn;
class TImMoveMember;
class TImUserState;
class TImSetUserState;
class TDeviceOnlineState;
class TImUserStateList;
class TSubState;
class TImUserStateEx;
class TImUserStateListEx;
class TImChatBuf;
class TImP2PChatMessage;
class TImNO;
class TImNOList;
class TBatchAddContactsItem;
class TBatchAddContacts;
class TBatchDelContacts;
class TBatchMoveContacts;
class TRoomId;
class TImMulitChatCreateInfo;
class TImMultiChatMemberInfo;
class TImMultiChatMemberInfoEx;
class TMultiChatMemberStateInfo;
class TImMultiChatMessage;
class TMultiChatPicId;
class TDeviceOnlineStateCacheItem;
class TDeviceOnlineStateCacheList;
class TFriendConferenceInfo;
class TModifyPwd;
class TImFileShareReq;
class TImFileShareOfferInfo;
class TImFileShareProgress;
class TImGroupChatFileShareReq;
class TImChatRoomInfo;
class TDeclineInfo;
class TImMultiChatRosterItem;
class TImMultiChatRosterItemList;
class TImMultiChatAddMembernotify;
class TImCharState;
class TImSplash;
class TImCustomCfgItem;
class TImCustomCfg;
class TImScreenChatroom;
class TImScreenedChatrooms;
class TImScreenChatroomR;
class TChatroomMemberCacheItem;
class TChatroomMemberCacheList;
class TWeiboOnlineInfo;
class TWeiboCommonInfo;
class TWeiboNewFeedInfo;
class TMeetingnotify;
class TMTWbParseKedaDept;
class TMTWbParseKedaDepts;
class TMTWbParse_Keda_EntUser;
class TImMemberInfo;
class TImMemberList;
class TMTSearchUserInfo;
class TImMemberFullInfo;
class TMTAccountManagerSystem;
class TRestErrorInfo;
class TCacheP2PMsg;
class TCacheGroupChatMsg;
class TImChatPicInfo;
class TImFont;
class TImChatContent;
class TCreateOrEnterChatroom;
class TDelayChatRoomInfo;
class TPersistentChatroomItem;
class TPersistentChatroomList;
class TImFriendInfo;

// ===================================================================

class MTMSG_API TImUserLogin : public ::google::protobuf::Message {
 public:
  TImUserLogin();
  virtual ~TImUserLogin();

  TImUserLogin(const TImUserLogin& from);

  inline TImUserLogin& operator=(const TImUserLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImUserLogin& default_instance();

  void Swap(TImUserLogin* other);

  // implements Message ----------------------------------------------

  TImUserLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImUserLogin& from);
  void MergeFrom(const TImUserLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string no = 3;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 3;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // optional string userpwd = 4;
  inline bool has_userpwd() const;
  inline void clear_userpwd();
  static const int kUserpwdFieldNumber = 4;
  inline const ::std::string& userpwd() const;
  inline void set_userpwd(const ::std::string& value);
  inline void set_userpwd(const char* value);
  inline void set_userpwd(const char* value, size_t size);
  inline ::std::string* mutable_userpwd();
  inline ::std::string* release_userpwd();
  inline void set_allocated_userpwd(::std::string* userpwd);

  // optional uint32 pwdlen = 5;
  inline bool has_pwdlen() const;
  inline void clear_pwdlen();
  static const int kPwdlenFieldNumber = 5;
  inline ::google::protobuf::uint32 pwdlen() const;
  inline void set_pwdlen(::google::protobuf::uint32 value);

  // optional bool fileshareenable = 6;
  inline bool has_fileshareenable() const;
  inline void clear_fileshareenable();
  static const int kFileshareenableFieldNumber = 6;
  inline bool fileshareenable() const;
  inline void set_fileshareenable(bool value);

  // optional string stunaddr = 7;
  inline bool has_stunaddr() const;
  inline void clear_stunaddr();
  static const int kStunaddrFieldNumber = 7;
  inline const ::std::string& stunaddr() const;
  inline void set_stunaddr(const ::std::string& value);
  inline void set_stunaddr(const char* value);
  inline void set_stunaddr(const char* value, size_t size);
  inline ::std::string* mutable_stunaddr();
  inline ::std::string* release_stunaddr();
  inline void set_allocated_stunaddr(::std::string* stunaddr);

  // optional uint32 stunport = 8;
  inline bool has_stunport() const;
  inline void clear_stunport();
  static const int kStunportFieldNumber = 8;
  inline ::google::protobuf::uint32 stunport() const;
  inline void set_stunport(::google::protobuf::uint32 value);

  // optional string defaultsavedir = 9;
  inline bool has_defaultsavedir() const;
  inline void clear_defaultsavedir();
  static const int kDefaultsavedirFieldNumber = 9;
  inline const ::std::string& defaultsavedir() const;
  inline void set_defaultsavedir(const ::std::string& value);
  inline void set_defaultsavedir(const char* value);
  inline void set_defaultsavedir(const char* value, size_t size);
  inline ::std::string* mutable_defaultsavedir();
  inline ::std::string* release_defaultsavedir();
  inline void set_allocated_defaultsavedir(::std::string* defaultsavedir);

  // optional string enterprisename = 10;
  inline bool has_enterprisename() const;
  inline void clear_enterprisename();
  static const int kEnterprisenameFieldNumber = 10;
  inline const ::std::string& enterprisename() const;
  inline void set_enterprisename(const ::std::string& value);
  inline void set_enterprisename(const char* value);
  inline void set_enterprisename(const char* value, size_t size);
  inline ::std::string* mutable_enterprisename();
  inline ::std::string* release_enterprisename();
  inline void set_allocated_enterprisename(::std::string* enterprisename);

  // optional bool audiocapability = 11;
  inline bool has_audiocapability() const;
  inline void clear_audiocapability();
  static const int kAudiocapabilityFieldNumber = 11;
  inline bool audiocapability() const;
  inline void set_audiocapability(bool value);

  // optional bool videocapability = 12;
  inline bool has_videocapability() const;
  inline void clear_videocapability();
  static const int kVideocapabilityFieldNumber = 12;
  inline bool videocapability() const;
  inline void set_videocapability(bool value);

  // optional string picsavedir = 13;
  inline bool has_picsavedir() const;
  inline void clear_picsavedir();
  static const int kPicsavedirFieldNumber = 13;
  inline const ::std::string& picsavedir() const;
  inline void set_picsavedir(const ::std::string& value);
  inline void set_picsavedir(const char* value);
  inline void set_picsavedir(const char* value, size_t size);
  inline ::std::string* mutable_picsavedir();
  inline ::std::string* release_picsavedir();
  inline void set_allocated_picsavedir(::std::string* picsavedir);

  // optional bool binstant = 14;
  inline bool has_binstant() const;
  inline void clear_binstant();
  static const int kBinstantFieldNumber = 14;
  inline bool binstant() const;
  inline void set_binstant(bool value);

  // optional string resource = 15;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 15;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional bool usesock5 = 16;
  inline bool has_usesock5() const;
  inline void clear_usesock5();
  static const int kUsesock5FieldNumber = 16;
  inline bool usesock5() const;
  inline void set_usesock5(bool value);

  // optional string sck5addr = 17;
  inline bool has_sck5addr() const;
  inline void clear_sck5addr();
  static const int kSck5AddrFieldNumber = 17;
  inline const ::std::string& sck5addr() const;
  inline void set_sck5addr(const ::std::string& value);
  inline void set_sck5addr(const char* value);
  inline void set_sck5addr(const char* value, size_t size);
  inline ::std::string* mutable_sck5addr();
  inline ::std::string* release_sck5addr();
  inline void set_allocated_sck5addr(::std::string* sck5addr);

  // optional uint32 sock5port = 18;
  inline bool has_sock5port() const;
  inline void clear_sock5port();
  static const int kSock5PortFieldNumber = 18;
  inline ::google::protobuf::uint32 sock5port() const;
  inline void set_sock5port(::google::protobuf::uint32 value);

  // optional string sock5username = 19;
  inline bool has_sock5username() const;
  inline void clear_sock5username();
  static const int kSock5UsernameFieldNumber = 19;
  inline const ::std::string& sock5username() const;
  inline void set_sock5username(const ::std::string& value);
  inline void set_sock5username(const char* value);
  inline void set_sock5username(const char* value, size_t size);
  inline ::std::string* mutable_sock5username();
  inline ::std::string* release_sock5username();
  inline void set_allocated_sock5username(::std::string* sock5username);

  // optional string sock5password = 20;
  inline bool has_sock5password() const;
  inline void clear_sock5password();
  static const int kSock5PasswordFieldNumber = 20;
  inline const ::std::string& sock5password() const;
  inline void set_sock5password(const ::std::string& value);
  inline void set_sock5password(const char* value);
  inline void set_sock5password(const char* value, size_t size);
  inline ::std::string* mutable_sock5password();
  inline ::std::string* release_sock5password();
  inline void set_allocated_sock5password(::std::string* sock5password);

  // optional string configpath = 21;
  inline bool has_configpath() const;
  inline void clear_configpath();
  static const int kConfigpathFieldNumber = 21;
  inline const ::std::string& configpath() const;
  inline void set_configpath(const ::std::string& value);
  inline void set_configpath(const char* value);
  inline void set_configpath(const char* value, size_t size);
  inline ::std::string* mutable_configpath();
  inline ::std::string* release_configpath();
  inline void set_allocated_configpath(::std::string* configpath);

  // optional bool compression = 22;
  inline bool has_compression() const;
  inline void clear_compression();
  static const int kCompressionFieldNumber = 22;
  inline bool compression() const;
  inline void set_compression(bool value);

  // @@protoc_insertion_point(class_scope:mt.TImUserLogin)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_userpwd();
  inline void clear_has_userpwd();
  inline void set_has_pwdlen();
  inline void clear_has_pwdlen();
  inline void set_has_fileshareenable();
  inline void clear_has_fileshareenable();
  inline void set_has_stunaddr();
  inline void clear_has_stunaddr();
  inline void set_has_stunport();
  inline void clear_has_stunport();
  inline void set_has_defaultsavedir();
  inline void clear_has_defaultsavedir();
  inline void set_has_enterprisename();
  inline void clear_has_enterprisename();
  inline void set_has_audiocapability();
  inline void clear_has_audiocapability();
  inline void set_has_videocapability();
  inline void clear_has_videocapability();
  inline void set_has_picsavedir();
  inline void clear_has_picsavedir();
  inline void set_has_binstant();
  inline void clear_has_binstant();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_usesock5();
  inline void clear_has_usesock5();
  inline void set_has_sck5addr();
  inline void clear_has_sck5addr();
  inline void set_has_sock5port();
  inline void clear_has_sock5port();
  inline void set_has_sock5username();
  inline void clear_has_sock5username();
  inline void set_has_sock5password();
  inline void clear_has_sock5password();
  inline void set_has_configpath();
  inline void clear_has_configpath();
  inline void set_has_compression();
  inline void clear_has_compression();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::std::string* no_;
  ::std::string* userpwd_;
  ::google::protobuf::uint32 pwdlen_;
  ::google::protobuf::uint32 stunport_;
  ::std::string* stunaddr_;
  ::std::string* defaultsavedir_;
  ::std::string* enterprisename_;
  bool fileshareenable_;
  bool audiocapability_;
  bool videocapability_;
  bool binstant_;
  ::google::protobuf::uint32 sock5port_;
  ::std::string* picsavedir_;
  ::std::string* resource_;
  ::std::string* sck5addr_;
  ::std::string* sock5username_;
  ::std::string* sock5password_;
  ::std::string* configpath_;
  bool usesock5_;
  bool compression_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImUserLogin* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImSelfDefInfo : public ::google::protobuf::Message {
 public:
  TImSelfDefInfo();
  virtual ~TImSelfDefInfo();

  TImSelfDefInfo(const TImSelfDefInfo& from);

  inline TImSelfDefInfo& operator=(const TImSelfDefInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImSelfDefInfo& default_instance();

  void Swap(TImSelfDefInfo* other);

  // implements Message ----------------------------------------------

  TImSelfDefInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImSelfDefInfo& from);
  void MergeFrom(const TImSelfDefInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string no = 1;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 1;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // optional string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional uint32 pictureindex = 3;
  inline bool has_pictureindex() const;
  inline void clear_pictureindex();
  static const int kPictureindexFieldNumber = 3;
  inline ::google::protobuf::uint32 pictureindex() const;
  inline void set_pictureindex(::google::protobuf::uint32 value);

  // optional bool customepic = 4;
  inline bool has_customepic() const;
  inline void clear_customepic();
  static const int kCustomepicFieldNumber = 4;
  inline bool customepic() const;
  inline void set_customepic(bool value);

  // @@protoc_insertion_point(class_scope:mt.TImSelfDefInfo)
 private:
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_pictureindex();
  inline void clear_has_pictureindex();
  inline void set_has_customepic();
  inline void clear_has_customepic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* no_;
  ::std::string* nickname_;
  ::google::protobuf::uint32 pictureindex_;
  bool customepic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImSelfDefInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImSelfDefPic : public ::google::protobuf::Message {
 public:
  TImSelfDefPic();
  virtual ~TImSelfDefPic();

  TImSelfDefPic(const TImSelfDefPic& from);

  inline TImSelfDefPic& operator=(const TImSelfDefPic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImSelfDefPic& default_instance();

  void Swap(TImSelfDefPic* other);

  // implements Message ----------------------------------------------

  TImSelfDefPic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImSelfDefPic& from);
  void MergeFrom(const TImSelfDefPic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 custompicsize = 1;
  inline bool has_custompicsize() const;
  inline void clear_custompicsize();
  static const int kCustompicsizeFieldNumber = 1;
  inline ::google::protobuf::uint32 custompicsize() const;
  inline void set_custompicsize(::google::protobuf::uint32 value);

  // optional string custompicdata = 2;
  inline bool has_custompicdata() const;
  inline void clear_custompicdata();
  static const int kCustompicdataFieldNumber = 2;
  inline const ::std::string& custompicdata() const;
  inline void set_custompicdata(const ::std::string& value);
  inline void set_custompicdata(const char* value);
  inline void set_custompicdata(const char* value, size_t size);
  inline ::std::string* mutable_custompicdata();
  inline ::std::string* release_custompicdata();
  inline void set_allocated_custompicdata(::std::string* custompicdata);

  // @@protoc_insertion_point(class_scope:mt.TImSelfDefPic)
 private:
  inline void set_has_custompicsize();
  inline void clear_has_custompicsize();
  inline void set_has_custompicdata();
  inline void clear_has_custompicdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* custompicdata_;
  ::google::protobuf::uint32 custompicsize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImSelfDefPic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImSelfDefList : public ::google::protobuf::Message {
 public:
  TImSelfDefList();
  virtual ~TImSelfDefList();

  TImSelfDefList(const TImSelfDefList& from);

  inline TImSelfDefList& operator=(const TImSelfDefList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImSelfDefList& default_instance();

  void Swap(TImSelfDefList* other);

  // implements Message ----------------------------------------------

  TImSelfDefList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImSelfDefList& from);
  void MergeFrom(const TImSelfDefList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 arraysize = 1;
  inline bool has_arraysize() const;
  inline void clear_arraysize();
  static const int kArraysizeFieldNumber = 1;
  inline ::google::protobuf::uint32 arraysize() const;
  inline void set_arraysize(::google::protobuf::uint32 value);

  // repeated .mt.TImSelfDefInfo array = 2;
  inline int array_size() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 2;
  inline const ::mt::TImSelfDefInfo& array(int index) const;
  inline ::mt::TImSelfDefInfo* mutable_array(int index);
  inline ::mt::TImSelfDefInfo* add_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImSelfDefInfo >&
      array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImSelfDefInfo >*
      mutable_array();

  // repeated .mt.TImSelfDefPic pic = 3;
  inline int pic_size() const;
  inline void clear_pic();
  static const int kPicFieldNumber = 3;
  inline const ::mt::TImSelfDefPic& pic(int index) const;
  inline ::mt::TImSelfDefPic* mutable_pic(int index);
  inline ::mt::TImSelfDefPic* add_pic();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImSelfDefPic >&
      pic() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImSelfDefPic >*
      mutable_pic();

  // @@protoc_insertion_point(class_scope:mt.TImSelfDefList)
 private:
  inline void set_has_arraysize();
  inline void clear_has_arraysize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TImSelfDefInfo > array_;
  ::google::protobuf::RepeatedPtrField< ::mt::TImSelfDefPic > pic_;
  ::google::protobuf::uint32 arraysize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImSelfDefList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImGroupInfo : public ::google::protobuf::Message {
 public:
  TImGroupInfo();
  virtual ~TImGroupInfo();

  TImGroupInfo(const TImGroupInfo& from);

  inline TImGroupInfo& operator=(const TImGroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImGroupInfo& default_instance();

  void Swap(TImGroupInfo* other);

  // implements Message ----------------------------------------------

  TImGroupInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImGroupInfo& from);
  void MergeFrom(const TImGroupInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string groupsn = 1;
  inline bool has_groupsn() const;
  inline void clear_groupsn();
  static const int kGroupsnFieldNumber = 1;
  inline const ::std::string& groupsn() const;
  inline void set_groupsn(const ::std::string& value);
  inline void set_groupsn(const char* value);
  inline void set_groupsn(const char* value, size_t size);
  inline ::std::string* mutable_groupsn();
  inline ::std::string* release_groupsn();
  inline void set_allocated_groupsn(::std::string* groupsn);

  // optional string groupname = 2;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupnameFieldNumber = 2;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional string parentgroupSn = 3;
  inline bool has_parentgroupsn() const;
  inline void clear_parentgroupsn();
  static const int kParentgroupSnFieldNumber = 3;
  inline const ::std::string& parentgroupsn() const;
  inline void set_parentgroupsn(const ::std::string& value);
  inline void set_parentgroupsn(const char* value);
  inline void set_parentgroupsn(const char* value, size_t size);
  inline ::std::string* mutable_parentgroupsn();
  inline ::std::string* release_parentgroupsn();
  inline void set_allocated_parentgroupsn(::std::string* parentgroupsn);

  // optional uint32 grouplevel = 4;
  inline bool has_grouplevel() const;
  inline void clear_grouplevel();
  static const int kGrouplevelFieldNumber = 4;
  inline ::google::protobuf::uint32 grouplevel() const;
  inline void set_grouplevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TImGroupInfo)
 private:
  inline void set_has_groupsn();
  inline void clear_has_groupsn();
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_parentgroupsn();
  inline void clear_has_parentgroupsn();
  inline void set_has_grouplevel();
  inline void clear_has_grouplevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* groupsn_;
  ::std::string* groupname_;
  ::std::string* parentgroupsn_;
  ::google::protobuf::uint32 grouplevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImGroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImGroupList : public ::google::protobuf::Message {
 public:
  TImGroupList();
  virtual ~TImGroupList();

  TImGroupList(const TImGroupList& from);

  inline TImGroupList& operator=(const TImGroupList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImGroupList& default_instance();

  void Swap(TImGroupList* other);

  // implements Message ----------------------------------------------

  TImGroupList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImGroupList& from);
  void MergeFrom(const TImGroupList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 arraysize = 1;
  inline bool has_arraysize() const;
  inline void clear_arraysize();
  static const int kArraysizeFieldNumber = 1;
  inline ::google::protobuf::uint32 arraysize() const;
  inline void set_arraysize(::google::protobuf::uint32 value);

  // repeated .mt.TImGroupInfo array = 2;
  inline int array_size() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 2;
  inline const ::mt::TImGroupInfo& array(int index) const;
  inline ::mt::TImGroupInfo* mutable_array(int index);
  inline ::mt::TImGroupInfo* add_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImGroupInfo >&
      array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImGroupInfo >*
      mutable_array();

  // @@protoc_insertion_point(class_scope:mt.TImGroupList)
 private:
  inline void set_has_arraysize();
  inline void clear_has_arraysize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TImGroupInfo > array_;
  ::google::protobuf::uint32 arraysize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImGroupList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImSn : public ::google::protobuf::Message {
 public:
  TImSn();
  virtual ~TImSn();

  TImSn(const TImSn& from);

  inline TImSn& operator=(const TImSn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImSn& default_instance();

  void Swap(TImSn* other);

  // implements Message ----------------------------------------------

  TImSn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImSn& from);
  void MergeFrom(const TImSn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sn = 1;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 1;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // @@protoc_insertion_point(class_scope:mt.TImSn)
 private:
  inline void set_has_sn();
  inline void clear_has_sn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sn_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImSn* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImMoveMember : public ::google::protobuf::Message {
 public:
  TImMoveMember();
  virtual ~TImMoveMember();

  TImMoveMember(const TImMoveMember& from);

  inline TImMoveMember& operator=(const TImMoveMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImMoveMember& default_instance();

  void Swap(TImMoveMember* other);

  // implements Message ----------------------------------------------

  TImMoveMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImMoveMember& from);
  void MergeFrom(const TImMoveMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string membersn = 1;
  inline bool has_membersn() const;
  inline void clear_membersn();
  static const int kMembersnFieldNumber = 1;
  inline const ::std::string& membersn() const;
  inline void set_membersn(const ::std::string& value);
  inline void set_membersn(const char* value);
  inline void set_membersn(const char* value, size_t size);
  inline ::std::string* mutable_membersn();
  inline ::std::string* release_membersn();
  inline void set_allocated_membersn(::std::string* membersn);

  // optional string oldgroupsn = 2;
  inline bool has_oldgroupsn() const;
  inline void clear_oldgroupsn();
  static const int kOldgroupsnFieldNumber = 2;
  inline const ::std::string& oldgroupsn() const;
  inline void set_oldgroupsn(const ::std::string& value);
  inline void set_oldgroupsn(const char* value);
  inline void set_oldgroupsn(const char* value, size_t size);
  inline ::std::string* mutable_oldgroupsn();
  inline ::std::string* release_oldgroupsn();
  inline void set_allocated_oldgroupsn(::std::string* oldgroupsn);

  // optional string newgroupsn = 3;
  inline bool has_newgroupsn() const;
  inline void clear_newgroupsn();
  static const int kNewgroupsnFieldNumber = 3;
  inline const ::std::string& newgroupsn() const;
  inline void set_newgroupsn(const ::std::string& value);
  inline void set_newgroupsn(const char* value);
  inline void set_newgroupsn(const char* value, size_t size);
  inline ::std::string* mutable_newgroupsn();
  inline ::std::string* release_newgroupsn();
  inline void set_allocated_newgroupsn(::std::string* newgroupsn);

  // @@protoc_insertion_point(class_scope:mt.TImMoveMember)
 private:
  inline void set_has_membersn();
  inline void clear_has_membersn();
  inline void set_has_oldgroupsn();
  inline void clear_has_oldgroupsn();
  inline void set_has_newgroupsn();
  inline void clear_has_newgroupsn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* membersn_;
  ::std::string* oldgroupsn_;
  ::std::string* newgroupsn_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImMoveMember* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImUserState : public ::google::protobuf::Message {
 public:
  TImUserState();
  virtual ~TImUserState();

  TImUserState(const TImUserState& from);

  inline TImUserState& operator=(const TImUserState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImUserState& default_instance();

  void Swap(TImUserState* other);

  // implements Message ----------------------------------------------

  TImUserState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImUserState& from);
  void MergeFrom(const TImUserState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string no = 1;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 1;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // optional .mt.EmMtOnlineState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::mt::EmMtOnlineState state() const;
  inline void set_state(::mt::EmMtOnlineState value);

  // @@protoc_insertion_point(class_scope:mt.TImUserState)
 private:
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* no_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImUserState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImSetUserState : public ::google::protobuf::Message {
 public:
  TImSetUserState();
  virtual ~TImSetUserState();

  TImSetUserState(const TImSetUserState& from);

  inline TImSetUserState& operator=(const TImSetUserState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImSetUserState& default_instance();

  void Swap(TImSetUserState* other);

  // implements Message ----------------------------------------------

  TImSetUserState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImSetUserState& from);
  void MergeFrom(const TImSetUserState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string no = 1;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 1;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // optional .mt.EmMtOnlineState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::mt::EmMtOnlineState state() const;
  inline void set_state(::mt::EmMtOnlineState value);

  // optional bool statevalid = 3;
  inline bool has_statevalid() const;
  inline void clear_statevalid();
  static const int kStatevalidFieldNumber = 3;
  inline bool statevalid() const;
  inline void set_statevalid(bool value);

  // optional bool gkconnected = 4;
  inline bool has_gkconnected() const;
  inline void clear_gkconnected();
  static const int kGkconnectedFieldNumber = 4;
  inline bool gkconnected() const;
  inline void set_gkconnected(bool value);

  // optional bool gkconnectedvalid = 5;
  inline bool has_gkconnectedvalid() const;
  inline void clear_gkconnectedvalid();
  static const int kGkconnectedvalidFieldNumber = 5;
  inline bool gkconnectedvalid() const;
  inline void set_gkconnectedvalid(bool value);

  // @@protoc_insertion_point(class_scope:mt.TImSetUserState)
 private:
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_statevalid();
  inline void clear_has_statevalid();
  inline void set_has_gkconnected();
  inline void clear_has_gkconnected();
  inline void set_has_gkconnectedvalid();
  inline void clear_has_gkconnectedvalid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* no_;
  int state_;
  bool statevalid_;
  bool gkconnected_;
  bool gkconnectedvalid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImSetUserState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDeviceOnlineState : public ::google::protobuf::Message {
 public:
  TDeviceOnlineState();
  virtual ~TDeviceOnlineState();

  TDeviceOnlineState(const TDeviceOnlineState& from);

  inline TDeviceOnlineState& operator=(const TDeviceOnlineState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDeviceOnlineState& default_instance();

  void Swap(TDeviceOnlineState* other);

  // implements Message ----------------------------------------------

  TDeviceOnlineState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDeviceOnlineState& from);
  void MergeFrom(const TDeviceOnlineState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string no = 1;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 1;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // optional .mt.EmMtImTerminalType devicetype = 2;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDevicetypeFieldNumber = 2;
  inline ::mt::EmMtImTerminalType devicetype() const;
  inline void set_devicetype(::mt::EmMtImTerminalType value);

  // optional .mt.EmMtOnlineState state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::mt::EmMtOnlineState state() const;
  inline void set_state(::mt::EmMtOnlineState value);

  // optional .mt.EmMtOnlineState maxstate = 4;
  inline bool has_maxstate() const;
  inline void clear_maxstate();
  static const int kMaxstateFieldNumber = 4;
  inline ::mt::EmMtOnlineState maxstate() const;
  inline void set_maxstate(::mt::EmMtOnlineState value);

  // optional bool self = 5;
  inline bool has_self() const;
  inline void clear_self();
  static const int kSelfFieldNumber = 5;
  inline bool self() const;
  inline void set_self(bool value);

  // optional bool first = 6;
  inline bool has_first() const;
  inline void clear_first();
  static const int kFirstFieldNumber = 6;
  inline bool first() const;
  inline void set_first(bool value);

  // optional bool fileshare = 7;
  inline bool has_fileshare() const;
  inline void clear_fileshare();
  static const int kFileshareFieldNumber = 7;
  inline bool fileshare() const;
  inline void set_fileshare(bool value);

  // optional bool audiocapability = 8;
  inline bool has_audiocapability() const;
  inline void clear_audiocapability();
  static const int kAudiocapabilityFieldNumber = 8;
  inline bool audiocapability() const;
  inline void set_audiocapability(bool value);

  // optional bool videocapability = 9;
  inline bool has_videocapability() const;
  inline void clear_videocapability();
  static const int kVideocapabilityFieldNumber = 9;
  inline bool videocapability() const;
  inline void set_videocapability(bool value);

  // optional bool gkconnected = 10;
  inline bool has_gkconnected() const;
  inline void clear_gkconnected();
  static const int kGkconnectedFieldNumber = 10;
  inline bool gkconnected() const;
  inline void set_gkconnected(bool value);

  // optional bool maxaudio = 11;
  inline bool has_maxaudio() const;
  inline void clear_maxaudio();
  static const int kMaxaudioFieldNumber = 11;
  inline bool maxaudio() const;
  inline void set_maxaudio(bool value);

  // optional bool maxvideo = 12;
  inline bool has_maxvideo() const;
  inline void clear_maxvideo();
  static const int kMaxvideoFieldNumber = 12;
  inline bool maxvideo() const;
  inline void set_maxvideo(bool value);

  // optional bool loginbeforeme = 13;
  inline bool has_loginbeforeme() const;
  inline void clear_loginbeforeme();
  static const int kLoginbeforemeFieldNumber = 13;
  inline bool loginbeforeme() const;
  inline void set_loginbeforeme(bool value);

  // @@protoc_insertion_point(class_scope:mt.TDeviceOnlineState)
 private:
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_maxstate();
  inline void clear_has_maxstate();
  inline void set_has_self();
  inline void clear_has_self();
  inline void set_has_first();
  inline void clear_has_first();
  inline void set_has_fileshare();
  inline void clear_has_fileshare();
  inline void set_has_audiocapability();
  inline void clear_has_audiocapability();
  inline void set_has_videocapability();
  inline void clear_has_videocapability();
  inline void set_has_gkconnected();
  inline void clear_has_gkconnected();
  inline void set_has_maxaudio();
  inline void clear_has_maxaudio();
  inline void set_has_maxvideo();
  inline void clear_has_maxvideo();
  inline void set_has_loginbeforeme();
  inline void clear_has_loginbeforeme();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* no_;
  int devicetype_;
  int state_;
  int maxstate_;
  bool self_;
  bool first_;
  bool fileshare_;
  bool audiocapability_;
  bool videocapability_;
  bool gkconnected_;
  bool maxaudio_;
  bool maxvideo_;
  bool loginbeforeme_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TDeviceOnlineState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImUserStateList : public ::google::protobuf::Message {
 public:
  TImUserStateList();
  virtual ~TImUserStateList();

  TImUserStateList(const TImUserStateList& from);

  inline TImUserStateList& operator=(const TImUserStateList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImUserStateList& default_instance();

  void Swap(TImUserStateList* other);

  // implements Message ----------------------------------------------

  TImUserStateList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImUserStateList& from);
  void MergeFrom(const TImUserStateList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 arraysize = 1;
  inline bool has_arraysize() const;
  inline void clear_arraysize();
  static const int kArraysizeFieldNumber = 1;
  inline ::google::protobuf::uint32 arraysize() const;
  inline void set_arraysize(::google::protobuf::uint32 value);

  // repeated .mt.TImUserState array = 2;
  inline int array_size() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 2;
  inline const ::mt::TImUserState& array(int index) const;
  inline ::mt::TImUserState* mutable_array(int index);
  inline ::mt::TImUserState* add_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImUserState >&
      array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImUserState >*
      mutable_array();

  // @@protoc_insertion_point(class_scope:mt.TImUserStateList)
 private:
  inline void set_has_arraysize();
  inline void clear_has_arraysize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TImUserState > array_;
  ::google::protobuf::uint32 arraysize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImUserStateList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TSubState : public ::google::protobuf::Message {
 public:
  TSubState();
  virtual ~TSubState();

  TSubState(const TSubState& from);

  inline TSubState& operator=(const TSubState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSubState& default_instance();

  void Swap(TSubState* other);

  // implements Message ----------------------------------------------

  TSubState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSubState& from);
  void MergeFrom(const TSubState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtImTerminalType emtype = 1;
  inline bool has_emtype() const;
  inline void clear_emtype();
  static const int kEmtypeFieldNumber = 1;
  inline ::mt::EmMtImTerminalType emtype() const;
  inline void set_emtype(::mt::EmMtImTerminalType value);

  // optional .mt.EmMtOnlineState emState = 2;
  inline bool has_emstate() const;
  inline void clear_emstate();
  static const int kEmStateFieldNumber = 2;
  inline ::mt::EmMtOnlineState emstate() const;
  inline void set_emstate(::mt::EmMtOnlineState value);

  // optional bool baudiocapability = 3;
  inline bool has_baudiocapability() const;
  inline void clear_baudiocapability();
  static const int kBaudiocapabilityFieldNumber = 3;
  inline bool baudiocapability() const;
  inline void set_baudiocapability(bool value);

  // optional bool bvideocapability = 4;
  inline bool has_bvideocapability() const;
  inline void clear_bvideocapability();
  static const int kBvideocapabilityFieldNumber = 4;
  inline bool bvideocapability() const;
  inline void set_bvideocapability(bool value);

  // optional bool bgkconnected = 5;
  inline bool has_bgkconnected() const;
  inline void clear_bgkconnected();
  static const int kBgkconnectedFieldNumber = 5;
  inline bool bgkconnected() const;
  inline void set_bgkconnected(bool value);

  // @@protoc_insertion_point(class_scope:mt.TSubState)
 private:
  inline void set_has_emtype();
  inline void clear_has_emtype();
  inline void set_has_emstate();
  inline void clear_has_emstate();
  inline void set_has_baudiocapability();
  inline void clear_has_baudiocapability();
  inline void set_has_bvideocapability();
  inline void clear_has_bvideocapability();
  inline void set_has_bgkconnected();
  inline void clear_has_bgkconnected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emtype_;
  int emstate_;
  bool baudiocapability_;
  bool bvideocapability_;
  bool bgkconnected_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TSubState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImUserStateEx : public ::google::protobuf::Message {
 public:
  TImUserStateEx();
  virtual ~TImUserStateEx();

  TImUserStateEx(const TImUserStateEx& from);

  inline TImUserStateEx& operator=(const TImUserStateEx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImUserStateEx& default_instance();

  void Swap(TImUserStateEx* other);

  // implements Message ----------------------------------------------

  TImUserStateEx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImUserStateEx& from);
  void MergeFrom(const TImUserStateEx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string no = 1;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 1;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // optional .mt.EmMtOnlineState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::mt::EmMtOnlineState state() const;
  inline void set_state(::mt::EmMtOnlineState value);

  // optional bool maxaudio = 3;
  inline bool has_maxaudio() const;
  inline void clear_maxaudio();
  static const int kMaxaudioFieldNumber = 3;
  inline bool maxaudio() const;
  inline void set_maxaudio(bool value);

  // optional bool maxvideo = 4;
  inline bool has_maxvideo() const;
  inline void clear_maxvideo();
  static const int kMaxvideoFieldNumber = 4;
  inline bool maxvideo() const;
  inline void set_maxvideo(bool value);

  // repeated .mt.TSubState mtstate = 5;
  inline int mtstate_size() const;
  inline void clear_mtstate();
  static const int kMtstateFieldNumber = 5;
  inline const ::mt::TSubState& mtstate(int index) const;
  inline ::mt::TSubState* mutable_mtstate(int index);
  inline ::mt::TSubState* add_mtstate();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TSubState >&
      mtstate() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TSubState >*
      mutable_mtstate();

  // @@protoc_insertion_point(class_scope:mt.TImUserStateEx)
 private:
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_maxaudio();
  inline void clear_has_maxaudio();
  inline void set_has_maxvideo();
  inline void clear_has_maxvideo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* no_;
  int state_;
  bool maxaudio_;
  bool maxvideo_;
  ::google::protobuf::RepeatedPtrField< ::mt::TSubState > mtstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImUserStateEx* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImUserStateListEx : public ::google::protobuf::Message {
 public:
  TImUserStateListEx();
  virtual ~TImUserStateListEx();

  TImUserStateListEx(const TImUserStateListEx& from);

  inline TImUserStateListEx& operator=(const TImUserStateListEx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImUserStateListEx& default_instance();

  void Swap(TImUserStateListEx* other);

  // implements Message ----------------------------------------------

  TImUserStateListEx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImUserStateListEx& from);
  void MergeFrom(const TImUserStateListEx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 arraysize = 1;
  inline bool has_arraysize() const;
  inline void clear_arraysize();
  static const int kArraysizeFieldNumber = 1;
  inline ::google::protobuf::uint32 arraysize() const;
  inline void set_arraysize(::google::protobuf::uint32 value);

  // repeated .mt.TImUserStateEx array = 2;
  inline int array_size() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 2;
  inline const ::mt::TImUserStateEx& array(int index) const;
  inline ::mt::TImUserStateEx* mutable_array(int index);
  inline ::mt::TImUserStateEx* add_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImUserStateEx >&
      array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImUserStateEx >*
      mutable_array();

  // @@protoc_insertion_point(class_scope:mt.TImUserStateListEx)
 private:
  inline void set_has_arraysize();
  inline void clear_has_arraysize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TImUserStateEx > array_;
  ::google::protobuf::uint32 arraysize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImUserStateListEx* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImChatBuf : public ::google::protobuf::Message {
 public:
  TImChatBuf();
  virtual ~TImChatBuf();

  TImChatBuf(const TImChatBuf& from);

  inline TImChatBuf& operator=(const TImChatBuf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImChatBuf& default_instance();

  void Swap(TImChatBuf* other);

  // implements Message ----------------------------------------------

  TImChatBuf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImChatBuf& from);
  void MergeFrom(const TImChatBuf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 msglen = 1;
  inline bool has_msglen() const;
  inline void clear_msglen();
  static const int kMsglenFieldNumber = 1;
  inline ::google::protobuf::uint32 msglen() const;
  inline void set_msglen(::google::protobuf::uint32 value);

  // optional bytes mgsbody = 2;
  inline bool has_mgsbody() const;
  inline void clear_mgsbody();
  static const int kMgsbodyFieldNumber = 2;
  inline const ::std::string& mgsbody() const;
  inline void set_mgsbody(const ::std::string& value);
  inline void set_mgsbody(const char* value);
  inline void set_mgsbody(const void* value, size_t size);
  inline ::std::string* mutable_mgsbody();
  inline ::std::string* release_mgsbody();
  inline void set_allocated_mgsbody(::std::string* mgsbody);

  // @@protoc_insertion_point(class_scope:mt.TImChatBuf)
 private:
  inline void set_has_msglen();
  inline void clear_has_msglen();
  inline void set_has_mgsbody();
  inline void clear_has_mgsbody();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mgsbody_;
  ::google::protobuf::uint32 msglen_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImChatBuf* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImP2PChatMessage : public ::google::protobuf::Message {
 public:
  TImP2PChatMessage();
  virtual ~TImP2PChatMessage();

  TImP2PChatMessage(const TImP2PChatMessage& from);

  inline TImP2PChatMessage& operator=(const TImP2PChatMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImP2PChatMessage& default_instance();

  void Swap(TImP2PChatMessage* other);

  // implements Message ----------------------------------------------

  TImP2PChatMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImP2PChatMessage& from);
  void MergeFrom(const TImP2PChatMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dstno = 1;
  inline bool has_dstno() const;
  inline void clear_dstno();
  static const int kDstnoFieldNumber = 1;
  inline const ::std::string& dstno() const;
  inline void set_dstno(const ::std::string& value);
  inline void set_dstno(const char* value);
  inline void set_dstno(const char* value, size_t size);
  inline ::std::string* mutable_dstno();
  inline ::std::string* release_dstno();
  inline void set_allocated_dstno(::std::string* dstno);

  // optional string srcno = 2;
  inline bool has_srcno() const;
  inline void clear_srcno();
  static const int kSrcnoFieldNumber = 2;
  inline const ::std::string& srcno() const;
  inline void set_srcno(const ::std::string& value);
  inline void set_srcno(const char* value);
  inline void set_srcno(const char* value, size_t size);
  inline ::std::string* mutable_srcno();
  inline ::std::string* release_srcno();
  inline void set_allocated_srcno(::std::string* srcno);

  // optional .mt.EmMtImTerminalType mttype = 3;
  inline bool has_mttype() const;
  inline void clear_mttype();
  static const int kMttypeFieldNumber = 3;
  inline ::mt::EmMtImTerminalType mttype() const;
  inline void set_mttype(::mt::EmMtImTerminalType value);

  // optional uint32 contextid = 4;
  inline bool has_contextid() const;
  inline void clear_contextid();
  static const int kContextidFieldNumber = 4;
  inline ::google::protobuf::uint32 contextid() const;
  inline void set_contextid(::google::protobuf::uint32 value);

  // optional .mt.TImChatBuf messagebuf = 5;
  inline bool has_messagebuf() const;
  inline void clear_messagebuf();
  static const int kMessagebufFieldNumber = 5;
  inline const ::mt::TImChatBuf& messagebuf() const;
  inline ::mt::TImChatBuf* mutable_messagebuf();
  inline ::mt::TImChatBuf* release_messagebuf();
  inline void set_allocated_messagebuf(::mt::TImChatBuf* messagebuf);

  // optional string msgid = 6;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgidFieldNumber = 6;
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline void set_msgid(const char* value, size_t size);
  inline ::std::string* mutable_msgid();
  inline ::std::string* release_msgid();
  inline void set_allocated_msgid(::std::string* msgid);

  // @@protoc_insertion_point(class_scope:mt.TImP2PChatMessage)
 private:
  inline void set_has_dstno();
  inline void clear_has_dstno();
  inline void set_has_srcno();
  inline void clear_has_srcno();
  inline void set_has_mttype();
  inline void clear_has_mttype();
  inline void set_has_contextid();
  inline void clear_has_contextid();
  inline void set_has_messagebuf();
  inline void clear_has_messagebuf();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dstno_;
  ::std::string* srcno_;
  int mttype_;
  ::google::protobuf::uint32 contextid_;
  ::mt::TImChatBuf* messagebuf_;
  ::std::string* msgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImP2PChatMessage* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImNO : public ::google::protobuf::Message {
 public:
  TImNO();
  virtual ~TImNO();

  TImNO(const TImNO& from);

  inline TImNO& operator=(const TImNO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImNO& default_instance();

  void Swap(TImNO* other);

  // implements Message ----------------------------------------------

  TImNO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImNO& from);
  void MergeFrom(const TImNO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string no = 1;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 1;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // @@protoc_insertion_point(class_scope:mt.TImNO)
 private:
  inline void set_has_no();
  inline void clear_has_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImNO* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImNOList : public ::google::protobuf::Message {
 public:
  TImNOList();
  virtual ~TImNOList();

  TImNOList(const TImNOList& from);

  inline TImNOList& operator=(const TImNOList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImNOList& default_instance();

  void Swap(TImNOList* other);

  // implements Message ----------------------------------------------

  TImNOList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImNOList& from);
  void MergeFrom(const TImNOList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 arraysize = 1;
  inline bool has_arraysize() const;
  inline void clear_arraysize();
  static const int kArraysizeFieldNumber = 1;
  inline ::google::protobuf::uint32 arraysize() const;
  inline void set_arraysize(::google::protobuf::uint32 value);

  // repeated .mt.TImNO array = 2;
  inline int array_size() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 2;
  inline const ::mt::TImNO& array(int index) const;
  inline ::mt::TImNO* mutable_array(int index);
  inline ::mt::TImNO* add_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImNO >&
      array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImNO >*
      mutable_array();

  // @@protoc_insertion_point(class_scope:mt.TImNOList)
 private:
  inline void set_has_arraysize();
  inline void clear_has_arraysize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TImNO > array_;
  ::google::protobuf::uint32 arraysize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImNOList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TBatchAddContactsItem : public ::google::protobuf::Message {
 public:
  TBatchAddContactsItem();
  virtual ~TBatchAddContactsItem();

  TBatchAddContactsItem(const TBatchAddContactsItem& from);

  inline TBatchAddContactsItem& operator=(const TBatchAddContactsItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TBatchAddContactsItem& default_instance();

  void Swap(TBatchAddContactsItem* other);

  // implements Message ----------------------------------------------

  TBatchAddContactsItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TBatchAddContactsItem& from);
  void MergeFrom(const TBatchAddContactsItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string memberno = 1;
  inline bool has_memberno() const;
  inline void clear_memberno();
  static const int kMembernoFieldNumber = 1;
  inline const ::std::string& memberno() const;
  inline void set_memberno(const ::std::string& value);
  inline void set_memberno(const char* value);
  inline void set_memberno(const char* value, size_t size);
  inline ::std::string* mutable_memberno();
  inline ::std::string* release_memberno();
  inline void set_allocated_memberno(::std::string* memberno);

  // optional string markname = 2;
  inline bool has_markname() const;
  inline void clear_markname();
  static const int kMarknameFieldNumber = 2;
  inline const ::std::string& markname() const;
  inline void set_markname(const ::std::string& value);
  inline void set_markname(const char* value);
  inline void set_markname(const char* value, size_t size);
  inline ::std::string* mutable_markname();
  inline ::std::string* release_markname();
  inline void set_allocated_markname(::std::string* markname);

  // optional string e164 = 3;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 3;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional .mt.EmMtMemberType membertype = 4;
  inline bool has_membertype() const;
  inline void clear_membertype();
  static const int kMembertypeFieldNumber = 4;
  inline ::mt::EmMtMemberType membertype() const;
  inline void set_membertype(::mt::EmMtMemberType value);

  // optional uint32 bitrate = 5;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 5;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TBatchAddContactsItem)
 private:
  inline void set_has_memberno();
  inline void clear_has_memberno();
  inline void set_has_markname();
  inline void clear_has_markname();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_membertype();
  inline void clear_has_membertype();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* memberno_;
  ::std::string* markname_;
  ::std::string* e164_;
  int membertype_;
  ::google::protobuf::uint32 bitrate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TBatchAddContactsItem* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TBatchAddContacts : public ::google::protobuf::Message {
 public:
  TBatchAddContacts();
  virtual ~TBatchAddContacts();

  TBatchAddContacts(const TBatchAddContacts& from);

  inline TBatchAddContacts& operator=(const TBatchAddContacts& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TBatchAddContacts& default_instance();

  void Swap(TBatchAddContacts* other);

  // implements Message ----------------------------------------------

  TBatchAddContacts* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TBatchAddContacts& from);
  void MergeFrom(const TBatchAddContacts& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TBatchAddContactsItem batchcontacts = 1;
  inline int batchcontacts_size() const;
  inline void clear_batchcontacts();
  static const int kBatchcontactsFieldNumber = 1;
  inline const ::mt::TBatchAddContactsItem& batchcontacts(int index) const;
  inline ::mt::TBatchAddContactsItem* mutable_batchcontacts(int index);
  inline ::mt::TBatchAddContactsItem* add_batchcontacts();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TBatchAddContactsItem >&
      batchcontacts() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TBatchAddContactsItem >*
      mutable_batchcontacts();

  // optional string destgroupsn = 3;
  inline bool has_destgroupsn() const;
  inline void clear_destgroupsn();
  static const int kDestgroupsnFieldNumber = 3;
  inline const ::std::string& destgroupsn() const;
  inline void set_destgroupsn(const ::std::string& value);
  inline void set_destgroupsn(const char* value);
  inline void set_destgroupsn(const char* value, size_t size);
  inline ::std::string* mutable_destgroupsn();
  inline ::std::string* release_destgroupsn();
  inline void set_allocated_destgroupsn(::std::string* destgroupsn);

  // @@protoc_insertion_point(class_scope:mt.TBatchAddContacts)
 private:
  inline void set_has_destgroupsn();
  inline void clear_has_destgroupsn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TBatchAddContactsItem > batchcontacts_;
  ::std::string* destgroupsn_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TBatchAddContacts* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TBatchDelContacts : public ::google::protobuf::Message {
 public:
  TBatchDelContacts();
  virtual ~TBatchDelContacts();

  TBatchDelContacts(const TBatchDelContacts& from);

  inline TBatchDelContacts& operator=(const TBatchDelContacts& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TBatchDelContacts& default_instance();

  void Swap(TBatchDelContacts* other);

  // implements Message ----------------------------------------------

  TBatchDelContacts* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TBatchDelContacts& from);
  void MergeFrom(const TBatchDelContacts& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TImSn batchcontacts = 1;
  inline int batchcontacts_size() const;
  inline void clear_batchcontacts();
  static const int kBatchcontactsFieldNumber = 1;
  inline const ::mt::TImSn& batchcontacts(int index) const;
  inline ::mt::TImSn* mutable_batchcontacts(int index);
  inline ::mt::TImSn* add_batchcontacts();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImSn >&
      batchcontacts() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImSn >*
      mutable_batchcontacts();

  // @@protoc_insertion_point(class_scope:mt.TBatchDelContacts)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TImSn > batchcontacts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TBatchDelContacts* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TBatchMoveContacts : public ::google::protobuf::Message {
 public:
  TBatchMoveContacts();
  virtual ~TBatchMoveContacts();

  TBatchMoveContacts(const TBatchMoveContacts& from);

  inline TBatchMoveContacts& operator=(const TBatchMoveContacts& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TBatchMoveContacts& default_instance();

  void Swap(TBatchMoveContacts* other);

  // implements Message ----------------------------------------------

  TBatchMoveContacts* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TBatchMoveContacts& from);
  void MergeFrom(const TBatchMoveContacts& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TImSn batchcontacts = 1;
  inline int batchcontacts_size() const;
  inline void clear_batchcontacts();
  static const int kBatchcontactsFieldNumber = 1;
  inline const ::mt::TImSn& batchcontacts(int index) const;
  inline ::mt::TImSn* mutable_batchcontacts(int index);
  inline ::mt::TImSn* add_batchcontacts();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImSn >&
      batchcontacts() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImSn >*
      mutable_batchcontacts();

  // optional string destgroupsn = 3;
  inline bool has_destgroupsn() const;
  inline void clear_destgroupsn();
  static const int kDestgroupsnFieldNumber = 3;
  inline const ::std::string& destgroupsn() const;
  inline void set_destgroupsn(const ::std::string& value);
  inline void set_destgroupsn(const char* value);
  inline void set_destgroupsn(const char* value, size_t size);
  inline ::std::string* mutable_destgroupsn();
  inline ::std::string* release_destgroupsn();
  inline void set_allocated_destgroupsn(::std::string* destgroupsn);

  // @@protoc_insertion_point(class_scope:mt.TBatchMoveContacts)
 private:
  inline void set_has_destgroupsn();
  inline void clear_has_destgroupsn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TImSn > batchcontacts_;
  ::std::string* destgroupsn_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TBatchMoveContacts* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRoomId : public ::google::protobuf::Message {
 public:
  TRoomId();
  virtual ~TRoomId();

  TRoomId(const TRoomId& from);

  inline TRoomId& operator=(const TRoomId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRoomId& default_instance();

  void Swap(TRoomId* other);

  // implements Message ----------------------------------------------

  TRoomId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRoomId& from);
  void MergeFrom(const TRoomId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string roomid = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:mt.TRoomId)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TRoomId* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImMulitChatCreateInfo : public ::google::protobuf::Message {
 public:
  TImMulitChatCreateInfo();
  virtual ~TImMulitChatCreateInfo();

  TImMulitChatCreateInfo(const TImMulitChatCreateInfo& from);

  inline TImMulitChatCreateInfo& operator=(const TImMulitChatCreateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImMulitChatCreateInfo& default_instance();

  void Swap(TImMulitChatCreateInfo* other);

  // implements Message ----------------------------------------------

  TImMulitChatCreateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImMulitChatCreateInfo& from);
  void MergeFrom(const TImMulitChatCreateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional uint32 clientid = 2;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 2;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string chatname = 3;
  inline bool has_chatname() const;
  inline void clear_chatname();
  static const int kChatnameFieldNumber = 3;
  inline const ::std::string& chatname() const;
  inline void set_chatname(const ::std::string& value);
  inline void set_chatname(const char* value);
  inline void set_chatname(const char* value, size_t size);
  inline ::std::string* mutable_chatname();
  inline ::std::string* release_chatname();
  inline void set_allocated_chatname(::std::string* chatname);

  // optional .mt.EmMtMultiChatType multichattype = 4;
  inline bool has_multichattype() const;
  inline void clear_multichattype();
  static const int kMultichattypeFieldNumber = 4;
  inline ::mt::EmMtMultiChatType multichattype() const;
  inline void set_multichattype(::mt::EmMtMultiChatType value);

  // optional string confe164 = 5;
  inline bool has_confe164() const;
  inline void clear_confe164();
  static const int kConfe164FieldNumber = 5;
  inline const ::std::string& confe164() const;
  inline void set_confe164(const ::std::string& value);
  inline void set_confe164(const char* value);
  inline void set_confe164(const char* value, size_t size);
  inline ::std::string* mutable_confe164();
  inline ::std::string* release_confe164();
  inline void set_allocated_confe164(::std::string* confe164);

  // optional string roomid = 6;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 6;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // optional bool persistent = 7;
  inline bool has_persistent() const;
  inline void clear_persistent();
  static const int kPersistentFieldNumber = 7;
  inline bool persistent() const;
  inline void set_persistent(bool value);

  // optional bool owner = 8;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 8;
  inline bool owner() const;
  inline void set_owner(bool value);

  // optional string inviterno = 9;
  inline bool has_inviterno() const;
  inline void clear_inviterno();
  static const int kInviternoFieldNumber = 9;
  inline const ::std::string& inviterno() const;
  inline void set_inviterno(const ::std::string& value);
  inline void set_inviterno(const char* value);
  inline void set_inviterno(const char* value, size_t size);
  inline ::std::string* mutable_inviterno();
  inline ::std::string* release_inviterno();
  inline void set_allocated_inviterno(::std::string* inviterno);

  // @@protoc_insertion_point(class_scope:mt.TImMulitChatCreateInfo)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_chatname();
  inline void clear_has_chatname();
  inline void set_has_multichattype();
  inline void clear_has_multichattype();
  inline void set_has_confe164();
  inline void clear_has_confe164();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_persistent();
  inline void clear_has_persistent();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_inviterno();
  inline void clear_has_inviterno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 sessionid_;
  ::google::protobuf::uint32 clientid_;
  ::std::string* chatname_;
  ::std::string* confe164_;
  ::std::string* roomid_;
  int multichattype_;
  bool persistent_;
  bool owner_;
  ::std::string* inviterno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImMulitChatCreateInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImMultiChatMemberInfo : public ::google::protobuf::Message {
 public:
  TImMultiChatMemberInfo();
  virtual ~TImMultiChatMemberInfo();

  TImMultiChatMemberInfo(const TImMultiChatMemberInfo& from);

  inline TImMultiChatMemberInfo& operator=(const TImMultiChatMemberInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImMultiChatMemberInfo& default_instance();

  void Swap(TImMultiChatMemberInfo* other);

  // implements Message ----------------------------------------------

  TImMultiChatMemberInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImMultiChatMemberInfo& from);
  void MergeFrom(const TImMultiChatMemberInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional .mt.TImNOList nolist = 2;
  inline bool has_nolist() const;
  inline void clear_nolist();
  static const int kNolistFieldNumber = 2;
  inline const ::mt::TImNOList& nolist() const;
  inline ::mt::TImNOList* mutable_nolist();
  inline ::mt::TImNOList* release_nolist();
  inline void set_allocated_nolist(::mt::TImNOList* nolist);

  // optional .mt.TRoomId roomid = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 3;
  inline const ::mt::TRoomId& roomid() const;
  inline ::mt::TRoomId* mutable_roomid();
  inline ::mt::TRoomId* release_roomid();
  inline void set_allocated_roomid(::mt::TRoomId* roomid);

  // @@protoc_insertion_point(class_scope:mt.TImMultiChatMemberInfo)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_nolist();
  inline void clear_has_nolist();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TImNOList* nolist_;
  ::mt::TRoomId* roomid_;
  ::google::protobuf::uint32 sessionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImMultiChatMemberInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImMultiChatMemberInfoEx : public ::google::protobuf::Message {
 public:
  TImMultiChatMemberInfoEx();
  virtual ~TImMultiChatMemberInfoEx();

  TImMultiChatMemberInfoEx(const TImMultiChatMemberInfoEx& from);

  inline TImMultiChatMemberInfoEx& operator=(const TImMultiChatMemberInfoEx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImMultiChatMemberInfoEx& default_instance();

  void Swap(TImMultiChatMemberInfoEx* other);

  // implements Message ----------------------------------------------

  TImMultiChatMemberInfoEx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImMultiChatMemberInfoEx& from);
  void MergeFrom(const TImMultiChatMemberInfoEx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional string no = 2;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 2;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // optional bool owner = 3;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 3;
  inline bool owner() const;
  inline void set_owner(bool value);

  // optional bool self = 4;
  inline bool has_self() const;
  inline void clear_self();
  static const int kSelfFieldNumber = 4;
  inline bool self() const;
  inline void set_self(bool value);

  // optional .mt.EmMtImTerminalType mttype = 5;
  inline bool has_mttype() const;
  inline void clear_mttype();
  static const int kMttypeFieldNumber = 5;
  inline ::mt::EmMtImTerminalType mttype() const;
  inline void set_mttype(::mt::EmMtImTerminalType value);

  // optional .mt.EmMtOnlineState state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::mt::EmMtOnlineState state() const;
  inline void set_state(::mt::EmMtOnlineState value);

  // optional .mt.EmMtOnlineState maxstate = 7;
  inline bool has_maxstate() const;
  inline void clear_maxstate();
  static const int kMaxstateFieldNumber = 7;
  inline ::mt::EmMtOnlineState maxstate() const;
  inline void set_maxstate(::mt::EmMtOnlineState value);

  // optional .mt.TRoomId roomid = 8;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 8;
  inline const ::mt::TRoomId& roomid() const;
  inline ::mt::TRoomId* mutable_roomid();
  inline ::mt::TRoomId* release_roomid();
  inline void set_allocated_roomid(::mt::TRoomId* roomid);

  // @@protoc_insertion_point(class_scope:mt.TImMultiChatMemberInfoEx)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_self();
  inline void clear_has_self();
  inline void set_has_mttype();
  inline void clear_has_mttype();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_maxstate();
  inline void clear_has_maxstate();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* no_;
  ::google::protobuf::uint32 sessionid_;
  bool owner_;
  bool self_;
  int mttype_;
  int state_;
  ::mt::TRoomId* roomid_;
  int maxstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImMultiChatMemberInfoEx* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMultiChatMemberStateInfo : public ::google::protobuf::Message {
 public:
  TMultiChatMemberStateInfo();
  virtual ~TMultiChatMemberStateInfo();

  TMultiChatMemberStateInfo(const TMultiChatMemberStateInfo& from);

  inline TMultiChatMemberStateInfo& operator=(const TMultiChatMemberStateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMultiChatMemberStateInfo& default_instance();

  void Swap(TMultiChatMemberStateInfo* other);

  // implements Message ----------------------------------------------

  TMultiChatMemberStateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMultiChatMemberStateInfo& from);
  void MergeFrom(const TMultiChatMemberStateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional string no = 2;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 2;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // optional bool owner = 3;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 3;
  inline bool owner() const;
  inline void set_owner(bool value);

  // optional bool self = 4;
  inline bool has_self() const;
  inline void clear_self();
  static const int kSelfFieldNumber = 4;
  inline bool self() const;
  inline void set_self(bool value);

  // optional .mt.EmMtOnlineState maxstate = 5;
  inline bool has_maxstate() const;
  inline void clear_maxstate();
  static const int kMaxstateFieldNumber = 5;
  inline ::mt::EmMtOnlineState maxstate() const;
  inline void set_maxstate(::mt::EmMtOnlineState value);

  // optional bool maxaudio = 6;
  inline bool has_maxaudio() const;
  inline void clear_maxaudio();
  static const int kMaxaudioFieldNumber = 6;
  inline bool maxaudio() const;
  inline void set_maxaudio(bool value);

  // optional bool maxvideo = 7;
  inline bool has_maxvideo() const;
  inline void clear_maxvideo();
  static const int kMaxvideoFieldNumber = 7;
  inline bool maxvideo() const;
  inline void set_maxvideo(bool value);

  // optional .mt.TSubState mtttate = 8;
  inline bool has_mtttate() const;
  inline void clear_mtttate();
  static const int kMtttateFieldNumber = 8;
  inline const ::mt::TSubState& mtttate() const;
  inline ::mt::TSubState* mutable_mtttate();
  inline ::mt::TSubState* release_mtttate();
  inline void set_allocated_mtttate(::mt::TSubState* mtttate);

  // optional .mt.TRoomId roomid = 9;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 9;
  inline const ::mt::TRoomId& roomid() const;
  inline ::mt::TRoomId* mutable_roomid();
  inline ::mt::TRoomId* release_roomid();
  inline void set_allocated_roomid(::mt::TRoomId* roomid);

  // @@protoc_insertion_point(class_scope:mt.TMultiChatMemberStateInfo)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_self();
  inline void clear_has_self();
  inline void set_has_maxstate();
  inline void clear_has_maxstate();
  inline void set_has_maxaudio();
  inline void clear_has_maxaudio();
  inline void set_has_maxvideo();
  inline void clear_has_maxvideo();
  inline void set_has_mtttate();
  inline void clear_has_mtttate();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* no_;
  ::google::protobuf::uint32 sessionid_;
  int maxstate_;
  ::mt::TSubState* mtttate_;
  ::mt::TRoomId* roomid_;
  bool owner_;
  bool self_;
  bool maxaudio_;
  bool maxvideo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TMultiChatMemberStateInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImMultiChatMessage : public ::google::protobuf::Message {
 public:
  TImMultiChatMessage();
  virtual ~TImMultiChatMessage();

  TImMultiChatMessage(const TImMultiChatMessage& from);

  inline TImMultiChatMessage& operator=(const TImMultiChatMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImMultiChatMessage& default_instance();

  void Swap(TImMultiChatMessage* other);

  // implements Message ----------------------------------------------

  TImMultiChatMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImMultiChatMessage& from);
  void MergeFrom(const TImMultiChatMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional string srcno = 2;
  inline bool has_srcno() const;
  inline void clear_srcno();
  static const int kSrcnoFieldNumber = 2;
  inline const ::std::string& srcno() const;
  inline void set_srcno(const ::std::string& value);
  inline void set_srcno(const char* value);
  inline void set_srcno(const char* value, size_t size);
  inline ::std::string* mutable_srcno();
  inline ::std::string* release_srcno();
  inline void set_allocated_srcno(::std::string* srcno);

  // optional .mt.EmMtImTerminalType mttype = 3;
  inline bool has_mttype() const;
  inline void clear_mttype();
  static const int kMttypeFieldNumber = 3;
  inline ::mt::EmMtImTerminalType mttype() const;
  inline void set_mttype(::mt::EmMtImTerminalType value);

  // optional .mt.TImChatBuf messagebuf = 4;
  inline bool has_messagebuf() const;
  inline void clear_messagebuf();
  static const int kMessagebufFieldNumber = 4;
  inline const ::mt::TImChatBuf& messagebuf() const;
  inline ::mt::TImChatBuf* mutable_messagebuf();
  inline ::mt::TImChatBuf* release_messagebuf();
  inline void set_allocated_messagebuf(::mt::TImChatBuf* messagebuf);

  // optional uint32 contextid = 5;
  inline bool has_contextid() const;
  inline void clear_contextid();
  static const int kContextidFieldNumber = 5;
  inline ::google::protobuf::uint32 contextid() const;
  inline void set_contextid(::google::protobuf::uint32 value);

  // optional .mt.TRoomId roomid = 6;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 6;
  inline const ::mt::TRoomId& roomid() const;
  inline ::mt::TRoomId* mutable_roomid();
  inline ::mt::TRoomId* release_roomid();
  inline void set_allocated_roomid(::mt::TRoomId* roomid);

  // optional string msgid = 7;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgidFieldNumber = 7;
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline void set_msgid(const char* value, size_t size);
  inline ::std::string* mutable_msgid();
  inline ::std::string* release_msgid();
  inline void set_allocated_msgid(::std::string* msgid);

  // @@protoc_insertion_point(class_scope:mt.TImMultiChatMessage)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_srcno();
  inline void clear_has_srcno();
  inline void set_has_mttype();
  inline void clear_has_mttype();
  inline void set_has_messagebuf();
  inline void clear_has_messagebuf();
  inline void set_has_contextid();
  inline void clear_has_contextid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* srcno_;
  ::google::protobuf::uint32 sessionid_;
  int mttype_;
  ::mt::TImChatBuf* messagebuf_;
  ::mt::TRoomId* roomid_;
  ::std::string* msgid_;
  ::google::protobuf::uint32 contextid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImMultiChatMessage* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMultiChatPicId : public ::google::protobuf::Message {
 public:
  TMultiChatPicId();
  virtual ~TMultiChatPicId();

  TMultiChatPicId(const TMultiChatPicId& from);

  inline TMultiChatPicId& operator=(const TMultiChatPicId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMultiChatPicId& default_instance();

  void Swap(TMultiChatPicId* other);

  // implements Message ----------------------------------------------

  TMultiChatPicId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMultiChatPicId& from);
  void MergeFrom(const TMultiChatPicId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional string no = 2;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 2;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // optional .mt.EmMtImTerminalType devicetype = 3;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDevicetypeFieldNumber = 3;
  inline ::mt::EmMtImTerminalType devicetype() const;
  inline void set_devicetype(::mt::EmMtImTerminalType value);

  // optional string sid = 4;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 4;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void set_allocated_sid(::std::string* sid);

  // optional .mt.TRoomId roomid = 5;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 5;
  inline const ::mt::TRoomId& roomid() const;
  inline ::mt::TRoomId* mutable_roomid();
  inline ::mt::TRoomId* release_roomid();
  inline void set_allocated_roomid(::mt::TRoomId* roomid);

  // @@protoc_insertion_point(class_scope:mt.TMultiChatPicId)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* no_;
  ::google::protobuf::uint32 sessionid_;
  int devicetype_;
  ::std::string* sid_;
  ::mt::TRoomId* roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TMultiChatPicId* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDeviceOnlineStateCacheItem : public ::google::protobuf::Message {
 public:
  TDeviceOnlineStateCacheItem();
  virtual ~TDeviceOnlineStateCacheItem();

  TDeviceOnlineStateCacheItem(const TDeviceOnlineStateCacheItem& from);

  inline TDeviceOnlineStateCacheItem& operator=(const TDeviceOnlineStateCacheItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDeviceOnlineStateCacheItem& default_instance();

  void Swap(TDeviceOnlineStateCacheItem* other);

  // implements Message ----------------------------------------------

  TDeviceOnlineStateCacheItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDeviceOnlineStateCacheItem& from);
  void MergeFrom(const TDeviceOnlineStateCacheItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app = 1;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 1;
  inline ::google::protobuf::uint32 app() const;
  inline void set_app(::google::protobuf::uint32 value);

  // optional .mt.TDeviceOnlineState status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::mt::TDeviceOnlineState& status() const;
  inline ::mt::TDeviceOnlineState* mutable_status();
  inline ::mt::TDeviceOnlineState* release_status();
  inline void set_allocated_status(::mt::TDeviceOnlineState* status);

  // @@protoc_insertion_point(class_scope:mt.TDeviceOnlineStateCacheItem)
 private:
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TDeviceOnlineState* status_;
  ::google::protobuf::uint32 app_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TDeviceOnlineStateCacheItem* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDeviceOnlineStateCacheList : public ::google::protobuf::Message {
 public:
  TDeviceOnlineStateCacheList();
  virtual ~TDeviceOnlineStateCacheList();

  TDeviceOnlineStateCacheList(const TDeviceOnlineStateCacheList& from);

  inline TDeviceOnlineStateCacheList& operator=(const TDeviceOnlineStateCacheList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDeviceOnlineStateCacheList& default_instance();

  void Swap(TDeviceOnlineStateCacheList* other);

  // implements Message ----------------------------------------------

  TDeviceOnlineStateCacheList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDeviceOnlineStateCacheList& from);
  void MergeFrom(const TDeviceOnlineStateCacheList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 arraysize = 1;
  inline bool has_arraysize() const;
  inline void clear_arraysize();
  static const int kArraysizeFieldNumber = 1;
  inline ::google::protobuf::uint32 arraysize() const;
  inline void set_arraysize(::google::protobuf::uint32 value);

  // repeated .mt.TDeviceOnlineStateCacheItem array = 2;
  inline int array_size() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 2;
  inline const ::mt::TDeviceOnlineStateCacheItem& array(int index) const;
  inline ::mt::TDeviceOnlineStateCacheItem* mutable_array(int index);
  inline ::mt::TDeviceOnlineStateCacheItem* add_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TDeviceOnlineStateCacheItem >&
      array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TDeviceOnlineStateCacheItem >*
      mutable_array();

  // @@protoc_insertion_point(class_scope:mt.TDeviceOnlineStateCacheList)
 private:
  inline void set_has_arraysize();
  inline void clear_has_arraysize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TDeviceOnlineStateCacheItem > array_;
  ::google::protobuf::uint32 arraysize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TDeviceOnlineStateCacheList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TFriendConferenceInfo : public ::google::protobuf::Message {
 public:
  TFriendConferenceInfo();
  virtual ~TFriendConferenceInfo();

  TFriendConferenceInfo(const TFriendConferenceInfo& from);

  inline TFriendConferenceInfo& operator=(const TFriendConferenceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFriendConferenceInfo& default_instance();

  void Swap(TFriendConferenceInfo* other);

  // implements Message ----------------------------------------------

  TFriendConferenceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFriendConferenceInfo& from);
  void MergeFrom(const TFriendConferenceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string peerid = 1;
  inline bool has_peerid() const;
  inline void clear_peerid();
  static const int kPeeridFieldNumber = 1;
  inline const ::std::string& peerid() const;
  inline void set_peerid(const ::std::string& value);
  inline void set_peerid(const char* value);
  inline void set_peerid(const char* value, size_t size);
  inline ::std::string* mutable_peerid();
  inline ::std::string* release_peerid();
  inline void set_allocated_peerid(::std::string* peerid);

  // optional .mt.EmMtImTerminalType peertype = 2;
  inline bool has_peertype() const;
  inline void clear_peertype();
  static const int kPeertypeFieldNumber = 2;
  inline ::mt::EmMtImTerminalType peertype() const;
  inline void set_peertype(::mt::EmMtImTerminalType value);

  // optional string confe164 = 3;
  inline bool has_confe164() const;
  inline void clear_confe164();
  static const int kConfe164FieldNumber = 3;
  inline const ::std::string& confe164() const;
  inline void set_confe164(const ::std::string& value);
  inline void set_confe164(const char* value);
  inline void set_confe164(const char* value, size_t size);
  inline ::std::string* mutable_confe164();
  inline ::std::string* release_confe164();
  inline void set_allocated_confe164(::std::string* confe164);

  // optional string roomid = 4;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 4;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // optional string chatname = 5;
  inline bool has_chatname() const;
  inline void clear_chatname();
  static const int kChatnameFieldNumber = 5;
  inline const ::std::string& chatname() const;
  inline void set_chatname(const ::std::string& value);
  inline void set_chatname(const char* value);
  inline void set_chatname(const char* value, size_t size);
  inline ::std::string* mutable_chatname();
  inline ::std::string* release_chatname();
  inline void set_allocated_chatname(::std::string* chatname);

  // @@protoc_insertion_point(class_scope:mt.TFriendConferenceInfo)
 private:
  inline void set_has_peerid();
  inline void clear_has_peerid();
  inline void set_has_peertype();
  inline void clear_has_peertype();
  inline void set_has_confe164();
  inline void clear_has_confe164();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_chatname();
  inline void clear_has_chatname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* peerid_;
  ::std::string* confe164_;
  ::std::string* roomid_;
  ::std::string* chatname_;
  int peertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TFriendConferenceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TModifyPwd : public ::google::protobuf::Message {
 public:
  TModifyPwd();
  virtual ~TModifyPwd();

  TModifyPwd(const TModifyPwd& from);

  inline TModifyPwd& operator=(const TModifyPwd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TModifyPwd& default_instance();

  void Swap(TModifyPwd* other);

  // implements Message ----------------------------------------------

  TModifyPwd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TModifyPwd& from);
  void MergeFrom(const TModifyPwd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string oldpwd = 2;
  inline bool has_oldpwd() const;
  inline void clear_oldpwd();
  static const int kOldpwdFieldNumber = 2;
  inline const ::std::string& oldpwd() const;
  inline void set_oldpwd(const ::std::string& value);
  inline void set_oldpwd(const char* value);
  inline void set_oldpwd(const char* value, size_t size);
  inline ::std::string* mutable_oldpwd();
  inline ::std::string* release_oldpwd();
  inline void set_allocated_oldpwd(::std::string* oldpwd);

  // optional string newpwd = 3;
  inline bool has_newpwd() const;
  inline void clear_newpwd();
  static const int kNewpwdFieldNumber = 3;
  inline const ::std::string& newpwd() const;
  inline void set_newpwd(const ::std::string& value);
  inline void set_newpwd(const char* value);
  inline void set_newpwd(const char* value, size_t size);
  inline ::std::string* mutable_newpwd();
  inline ::std::string* release_newpwd();
  inline void set_allocated_newpwd(::std::string* newpwd);

  // @@protoc_insertion_point(class_scope:mt.TModifyPwd)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_oldpwd();
  inline void clear_has_oldpwd();
  inline void set_has_newpwd();
  inline void clear_has_newpwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* oldpwd_;
  ::std::string* newpwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TModifyPwd* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImFileShareReq : public ::google::protobuf::Message {
 public:
  TImFileShareReq();
  virtual ~TImFileShareReq();

  TImFileShareReq(const TImFileShareReq& from);

  inline TImFileShareReq& operator=(const TImFileShareReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImFileShareReq& default_instance();

  void Swap(TImFileShareReq* other);

  // implements Message ----------------------------------------------

  TImFileShareReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImFileShareReq& from);
  void MergeFrom(const TImFileShareReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string destno = 1;
  inline bool has_destno() const;
  inline void clear_destno();
  static const int kDestnoFieldNumber = 1;
  inline const ::std::string& destno() const;
  inline void set_destno(const ::std::string& value);
  inline void set_destno(const char* value);
  inline void set_destno(const char* value, size_t size);
  inline ::std::string* mutable_destno();
  inline ::std::string* release_destno();
  inline void set_allocated_destno(::std::string* destno);

  // optional uint32 filetype = 2;
  inline bool has_filetype() const;
  inline void clear_filetype();
  static const int kFiletypeFieldNumber = 2;
  inline ::google::protobuf::uint32 filetype() const;
  inline void set_filetype(::google::protobuf::uint32 value);

  // optional string filepath = 3;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 3;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // optional uint32 filesize = 4;
  inline bool has_filesize() const;
  inline void clear_filesize();
  static const int kFilesizeFieldNumber = 4;
  inline ::google::protobuf::uint32 filesize() const;
  inline void set_filesize(::google::protobuf::uint32 value);

  // optional uint32 contextid = 5;
  inline bool has_contextid() const;
  inline void clear_contextid();
  static const int kContextidFieldNumber = 5;
  inline ::google::protobuf::uint32 contextid() const;
  inline void set_contextid(::google::protobuf::uint32 value);

  // optional bool overwrite = 6;
  inline bool has_overwrite() const;
  inline void clear_overwrite();
  static const int kOverwriteFieldNumber = 6;
  inline bool overwrite() const;
  inline void set_overwrite(bool value);

  // @@protoc_insertion_point(class_scope:mt.TImFileShareReq)
 private:
  inline void set_has_destno();
  inline void clear_has_destno();
  inline void set_has_filetype();
  inline void clear_has_filetype();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_filesize();
  inline void clear_has_filesize();
  inline void set_has_contextid();
  inline void clear_has_contextid();
  inline void set_has_overwrite();
  inline void clear_has_overwrite();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* destno_;
  ::std::string* filepath_;
  ::google::protobuf::uint32 filetype_;
  ::google::protobuf::uint32 filesize_;
  ::google::protobuf::uint32 contextid_;
  bool overwrite_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImFileShareReq* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImFileShareOfferInfo : public ::google::protobuf::Message {
 public:
  TImFileShareOfferInfo();
  virtual ~TImFileShareOfferInfo();

  TImFileShareOfferInfo(const TImFileShareOfferInfo& from);

  inline TImFileShareOfferInfo& operator=(const TImFileShareOfferInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImFileShareOfferInfo& default_instance();

  void Swap(TImFileShareOfferInfo* other);

  // implements Message ----------------------------------------------

  TImFileShareOfferInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImFileShareOfferInfo& from);
  void MergeFrom(const TImFileShareOfferInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string peerno = 1;
  inline bool has_peerno() const;
  inline void clear_peerno();
  static const int kPeernoFieldNumber = 1;
  inline const ::std::string& peerno() const;
  inline void set_peerno(const ::std::string& value);
  inline void set_peerno(const char* value);
  inline void set_peerno(const char* value, size_t size);
  inline ::std::string* mutable_peerno();
  inline ::std::string* release_peerno();
  inline void set_allocated_peerno(::std::string* peerno);

  // optional uint32 filetype = 2;
  inline bool has_filetype() const;
  inline void clear_filetype();
  static const int kFiletypeFieldNumber = 2;
  inline ::google::protobuf::uint32 filetype() const;
  inline void set_filetype(::google::protobuf::uint32 value);

  // optional string filename = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional uint32 filesize = 4;
  inline bool has_filesize() const;
  inline void clear_filesize();
  static const int kFilesizeFieldNumber = 4;
  inline ::google::protobuf::uint32 filesize() const;
  inline void set_filesize(::google::protobuf::uint32 value);

  // optional bool sender = 5;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 5;
  inline bool sender() const;
  inline void set_sender(bool value);

  // @@protoc_insertion_point(class_scope:mt.TImFileShareOfferInfo)
 private:
  inline void set_has_peerno();
  inline void clear_has_peerno();
  inline void set_has_filetype();
  inline void clear_has_filetype();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_filesize();
  inline void clear_has_filesize();
  inline void set_has_sender();
  inline void clear_has_sender();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* peerno_;
  ::std::string* filename_;
  ::google::protobuf::uint32 filetype_;
  ::google::protobuf::uint32 filesize_;
  bool sender_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImFileShareOfferInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImFileShareProgress : public ::google::protobuf::Message {
 public:
  TImFileShareProgress();
  virtual ~TImFileShareProgress();

  TImFileShareProgress(const TImFileShareProgress& from);

  inline TImFileShareProgress& operator=(const TImFileShareProgress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImFileShareProgress& default_instance();

  void Swap(TImFileShareProgress* other);

  // implements Message ----------------------------------------------

  TImFileShareProgress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImFileShareProgress& from);
  void MergeFrom(const TImFileShareProgress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 percent = 1;
  inline bool has_percent() const;
  inline void clear_percent();
  static const int kPercentFieldNumber = 1;
  inline ::google::protobuf::uint32 percent() const;
  inline void set_percent(::google::protobuf::uint32 value);

  // optional string curfilename = 2;
  inline bool has_curfilename() const;
  inline void clear_curfilename();
  static const int kCurfilenameFieldNumber = 2;
  inline const ::std::string& curfilename() const;
  inline void set_curfilename(const ::std::string& value);
  inline void set_curfilename(const char* value);
  inline void set_curfilename(const char* value, size_t size);
  inline ::std::string* mutable_curfilename();
  inline ::std::string* release_curfilename();
  inline void set_allocated_curfilename(::std::string* curfilename);

  // optional uint32 transfersize = 3;
  inline bool has_transfersize() const;
  inline void clear_transfersize();
  static const int kTransfersizeFieldNumber = 3;
  inline ::google::protobuf::uint32 transfersize() const;
  inline void set_transfersize(::google::protobuf::uint32 value);

  // optional uint32 trasferrate = 4;
  inline bool has_trasferrate() const;
  inline void clear_trasferrate();
  static const int kTrasferrateFieldNumber = 4;
  inline ::google::protobuf::uint32 trasferrate() const;
  inline void set_trasferrate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TImFileShareProgress)
 private:
  inline void set_has_percent();
  inline void clear_has_percent();
  inline void set_has_curfilename();
  inline void clear_has_curfilename();
  inline void set_has_transfersize();
  inline void clear_has_transfersize();
  inline void set_has_trasferrate();
  inline void clear_has_trasferrate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* curfilename_;
  ::google::protobuf::uint32 percent_;
  ::google::protobuf::uint32 transfersize_;
  ::google::protobuf::uint32 trasferrate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImFileShareProgress* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImGroupChatFileShareReq : public ::google::protobuf::Message {
 public:
  TImGroupChatFileShareReq();
  virtual ~TImGroupChatFileShareReq();

  TImGroupChatFileShareReq(const TImGroupChatFileShareReq& from);

  inline TImGroupChatFileShareReq& operator=(const TImGroupChatFileShareReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImGroupChatFileShareReq& default_instance();

  void Swap(TImGroupChatFileShareReq* other);

  // implements Message ----------------------------------------------

  TImGroupChatFileShareReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImGroupChatFileShareReq& from);
  void MergeFrom(const TImGroupChatFileShareReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional uint32 filetype = 2;
  inline bool has_filetype() const;
  inline void clear_filetype();
  static const int kFiletypeFieldNumber = 2;
  inline ::google::protobuf::uint32 filetype() const;
  inline void set_filetype(::google::protobuf::uint32 value);

  // optional string filepath = 3;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 3;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // optional uint32 filesize = 4;
  inline bool has_filesize() const;
  inline void clear_filesize();
  static const int kFilesizeFieldNumber = 4;
  inline ::google::protobuf::uint32 filesize() const;
  inline void set_filesize(::google::protobuf::uint32 value);

  // optional uint32 contextid = 5;
  inline bool has_contextid() const;
  inline void clear_contextid();
  static const int kContextidFieldNumber = 5;
  inline ::google::protobuf::uint32 contextid() const;
  inline void set_contextid(::google::protobuf::uint32 value);

  // optional string picsessionid = 6;
  inline bool has_picsessionid() const;
  inline void clear_picsessionid();
  static const int kPicsessionidFieldNumber = 6;
  inline const ::std::string& picsessionid() const;
  inline void set_picsessionid(const ::std::string& value);
  inline void set_picsessionid(const char* value);
  inline void set_picsessionid(const char* value, size_t size);
  inline ::std::string* mutable_picsessionid();
  inline ::std::string* release_picsessionid();
  inline void set_allocated_picsessionid(::std::string* picsessionid);

  // optional .mt.TRoomId roomid = 7;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 7;
  inline const ::mt::TRoomId& roomid() const;
  inline ::mt::TRoomId* mutable_roomid();
  inline ::mt::TRoomId* release_roomid();
  inline void set_allocated_roomid(::mt::TRoomId* roomid);

  // optional bool overwrite = 8;
  inline bool has_overwrite() const;
  inline void clear_overwrite();
  static const int kOverwriteFieldNumber = 8;
  inline bool overwrite() const;
  inline void set_overwrite(bool value);

  // @@protoc_insertion_point(class_scope:mt.TImGroupChatFileShareReq)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_filetype();
  inline void clear_has_filetype();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_filesize();
  inline void clear_has_filesize();
  inline void set_has_contextid();
  inline void clear_has_contextid();
  inline void set_has_picsessionid();
  inline void clear_has_picsessionid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_overwrite();
  inline void clear_has_overwrite();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 sessionid_;
  ::google::protobuf::uint32 filetype_;
  ::std::string* filepath_;
  ::google::protobuf::uint32 filesize_;
  ::google::protobuf::uint32 contextid_;
  ::std::string* picsessionid_;
  ::mt::TRoomId* roomid_;
  bool overwrite_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImGroupChatFileShareReq* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImChatRoomInfo : public ::google::protobuf::Message {
 public:
  TImChatRoomInfo();
  virtual ~TImChatRoomInfo();

  TImChatRoomInfo(const TImChatRoomInfo& from);

  inline TImChatRoomInfo& operator=(const TImChatRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImChatRoomInfo& default_instance();

  void Swap(TImChatRoomInfo* other);

  // implements Message ----------------------------------------------

  TImChatRoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImChatRoomInfo& from);
  void MergeFrom(const TImChatRoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional string chatname = 2;
  inline bool has_chatname() const;
  inline void clear_chatname();
  static const int kChatnameFieldNumber = 2;
  inline const ::std::string& chatname() const;
  inline void set_chatname(const ::std::string& value);
  inline void set_chatname(const char* value);
  inline void set_chatname(const char* value, size_t size);
  inline ::std::string* mutable_chatname();
  inline ::std::string* release_chatname();
  inline void set_allocated_chatname(::std::string* chatname);

  // optional .mt.TRoomId roomid = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 3;
  inline const ::mt::TRoomId& roomid() const;
  inline ::mt::TRoomId* mutable_roomid();
  inline ::mt::TRoomId* release_roomid();
  inline void set_allocated_roomid(::mt::TRoomId* roomid);

  // @@protoc_insertion_point(class_scope:mt.TImChatRoomInfo)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_chatname();
  inline void clear_has_chatname();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* chatname_;
  ::mt::TRoomId* roomid_;
  ::google::protobuf::uint32 sessionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImChatRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDeclineInfo : public ::google::protobuf::Message {
 public:
  TDeclineInfo();
  virtual ~TDeclineInfo();

  TDeclineInfo(const TDeclineInfo& from);

  inline TDeclineInfo& operator=(const TDeclineInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDeclineInfo& default_instance();

  void Swap(TDeclineInfo* other);

  // implements Message ----------------------------------------------

  TDeclineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDeclineInfo& from);
  void MergeFrom(const TDeclineInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string chatname = 1;
  inline bool has_chatname() const;
  inline void clear_chatname();
  static const int kChatnameFieldNumber = 1;
  inline const ::std::string& chatname() const;
  inline void set_chatname(const ::std::string& value);
  inline void set_chatname(const char* value);
  inline void set_chatname(const char* value, size_t size);
  inline ::std::string* mutable_chatname();
  inline ::std::string* release_chatname();
  inline void set_allocated_chatname(::std::string* chatname);

  // optional string roomid = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 2;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // optional string declineno = 3;
  inline bool has_declineno() const;
  inline void clear_declineno();
  static const int kDeclinenoFieldNumber = 3;
  inline const ::std::string& declineno() const;
  inline void set_declineno(const ::std::string& value);
  inline void set_declineno(const char* value);
  inline void set_declineno(const char* value, size_t size);
  inline ::std::string* mutable_declineno();
  inline ::std::string* release_declineno();
  inline void set_allocated_declineno(::std::string* declineno);

  // optional .mt.EImDeclineReason reason = 4;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 4;
  inline ::mt::EImDeclineReason reason() const;
  inline void set_reason(::mt::EImDeclineReason value);

  // @@protoc_insertion_point(class_scope:mt.TDeclineInfo)
 private:
  inline void set_has_chatname();
  inline void clear_has_chatname();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_declineno();
  inline void clear_has_declineno();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* chatname_;
  ::std::string* roomid_;
  ::std::string* declineno_;
  int reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TDeclineInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImMultiChatRosterItem : public ::google::protobuf::Message {
 public:
  TImMultiChatRosterItem();
  virtual ~TImMultiChatRosterItem();

  TImMultiChatRosterItem(const TImMultiChatRosterItem& from);

  inline TImMultiChatRosterItem& operator=(const TImMultiChatRosterItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImMultiChatRosterItem& default_instance();

  void Swap(TImMultiChatRosterItem* other);

  // implements Message ----------------------------------------------

  TImMultiChatRosterItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImMultiChatRosterItem& from);
  void MergeFrom(const TImMultiChatRosterItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string no = 1;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 1;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // optional bool owner = 2;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 2;
  inline bool owner() const;
  inline void set_owner(bool value);

  // optional bool self = 3;
  inline bool has_self() const;
  inline void clear_self();
  static const int kSelfFieldNumber = 3;
  inline bool self() const;
  inline void set_self(bool value);

  // @@protoc_insertion_point(class_scope:mt.TImMultiChatRosterItem)
 private:
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_self();
  inline void clear_has_self();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* no_;
  bool owner_;
  bool self_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImMultiChatRosterItem* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImMultiChatRosterItemList : public ::google::protobuf::Message {
 public:
  TImMultiChatRosterItemList();
  virtual ~TImMultiChatRosterItemList();

  TImMultiChatRosterItemList(const TImMultiChatRosterItemList& from);

  inline TImMultiChatRosterItemList& operator=(const TImMultiChatRosterItemList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImMultiChatRosterItemList& default_instance();

  void Swap(TImMultiChatRosterItemList* other);

  // implements Message ----------------------------------------------

  TImMultiChatRosterItemList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImMultiChatRosterItemList& from);
  void MergeFrom(const TImMultiChatRosterItemList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional uint32 arraysize = 2;
  inline bool has_arraysize() const;
  inline void clear_arraysize();
  static const int kArraysizeFieldNumber = 2;
  inline ::google::protobuf::uint32 arraysize() const;
  inline void set_arraysize(::google::protobuf::uint32 value);

  // repeated .mt.TImMultiChatRosterItem array = 3;
  inline int array_size() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 3;
  inline const ::mt::TImMultiChatRosterItem& array(int index) const;
  inline ::mt::TImMultiChatRosterItem* mutable_array(int index);
  inline ::mt::TImMultiChatRosterItem* add_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImMultiChatRosterItem >&
      array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImMultiChatRosterItem >*
      mutable_array();

  // optional .mt.TRoomId roomid = 4;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 4;
  inline const ::mt::TRoomId& roomid() const;
  inline ::mt::TRoomId* mutable_roomid();
  inline ::mt::TRoomId* release_roomid();
  inline void set_allocated_roomid(::mt::TRoomId* roomid);

  // @@protoc_insertion_point(class_scope:mt.TImMultiChatRosterItemList)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_arraysize();
  inline void clear_has_arraysize();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 sessionid_;
  ::google::protobuf::uint32 arraysize_;
  ::google::protobuf::RepeatedPtrField< ::mt::TImMultiChatRosterItem > array_;
  ::mt::TRoomId* roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImMultiChatRosterItemList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImMultiChatAddMembernotify : public ::google::protobuf::Message {
 public:
  TImMultiChatAddMembernotify();
  virtual ~TImMultiChatAddMembernotify();

  TImMultiChatAddMembernotify(const TImMultiChatAddMembernotify& from);

  inline TImMultiChatAddMembernotify& operator=(const TImMultiChatAddMembernotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImMultiChatAddMembernotify& default_instance();

  void Swap(TImMultiChatAddMembernotify* other);

  // implements Message ----------------------------------------------

  TImMultiChatAddMembernotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImMultiChatAddMembernotify& from);
  void MergeFrom(const TImMultiChatAddMembernotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional string no = 2;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 2;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // optional .mt.TRoomId roomid = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 3;
  inline const ::mt::TRoomId& roomid() const;
  inline ::mt::TRoomId* mutable_roomid();
  inline ::mt::TRoomId* release_roomid();
  inline void set_allocated_roomid(::mt::TRoomId* roomid);

  // @@protoc_insertion_point(class_scope:mt.TImMultiChatAddMembernotify)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* no_;
  ::mt::TRoomId* roomid_;
  ::google::protobuf::uint32 sessionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImMultiChatAddMembernotify* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImCharState : public ::google::protobuf::Message {
 public:
  TImCharState();
  virtual ~TImCharState();

  TImCharState(const TImCharState& from);

  inline TImCharState& operator=(const TImCharState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImCharState& default_instance();

  void Swap(TImCharState* other);

  // implements Message ----------------------------------------------

  TImCharState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImCharState& from);
  void MergeFrom(const TImCharState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string peerno = 1;
  inline bool has_peerno() const;
  inline void clear_peerno();
  static const int kPeernoFieldNumber = 1;
  inline const ::std::string& peerno() const;
  inline void set_peerno(const ::std::string& value);
  inline void set_peerno(const char* value);
  inline void set_peerno(const char* value, size_t size);
  inline ::std::string* mutable_peerno();
  inline ::std::string* release_peerno();
  inline void set_allocated_peerno(::std::string* peerno);

  // optional .mt.EmMtImTerminalType mttype = 2;
  inline bool has_mttype() const;
  inline void clear_mttype();
  static const int kMttypeFieldNumber = 2;
  inline ::mt::EmMtImTerminalType mttype() const;
  inline void set_mttype(::mt::EmMtImTerminalType value);

  // optional .mt.EImCharState charstate = 3;
  inline bool has_charstate() const;
  inline void clear_charstate();
  static const int kCharstateFieldNumber = 3;
  inline ::mt::EImCharState charstate() const;
  inline void set_charstate(::mt::EImCharState value);

  // @@protoc_insertion_point(class_scope:mt.TImCharState)
 private:
  inline void set_has_peerno();
  inline void clear_has_peerno();
  inline void set_has_mttype();
  inline void clear_has_mttype();
  inline void set_has_charstate();
  inline void clear_has_charstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* peerno_;
  int mttype_;
  int charstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImCharState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImSplash : public ::google::protobuf::Message {
 public:
  TImSplash();
  virtual ~TImSplash();

  TImSplash(const TImSplash& from);

  inline TImSplash& operator=(const TImSplash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImSplash& default_instance();

  void Swap(TImSplash* other);

  // implements Message ----------------------------------------------

  TImSplash* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImSplash& from);
  void MergeFrom(const TImSplash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string peerno = 1;
  inline bool has_peerno() const;
  inline void clear_peerno();
  static const int kPeernoFieldNumber = 1;
  inline const ::std::string& peerno() const;
  inline void set_peerno(const ::std::string& value);
  inline void set_peerno(const char* value);
  inline void set_peerno(const char* value, size_t size);
  inline ::std::string* mutable_peerno();
  inline ::std::string* release_peerno();
  inline void set_allocated_peerno(::std::string* peerno);

  // optional .mt.EmMtImTerminalType mttype = 2;
  inline bool has_mttype() const;
  inline void clear_mttype();
  static const int kMttypeFieldNumber = 2;
  inline ::mt::EmMtImTerminalType mttype() const;
  inline void set_mttype(::mt::EmMtImTerminalType value);

  // optional uint32 splashtype = 3;
  inline bool has_splashtype() const;
  inline void clear_splashtype();
  static const int kSplashtypeFieldNumber = 3;
  inline ::google::protobuf::uint32 splashtype() const;
  inline void set_splashtype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TImSplash)
 private:
  inline void set_has_peerno();
  inline void clear_has_peerno();
  inline void set_has_mttype();
  inline void clear_has_mttype();
  inline void set_has_splashtype();
  inline void clear_has_splashtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* peerno_;
  int mttype_;
  ::google::protobuf::uint32 splashtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImSplash* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImCustomCfgItem : public ::google::protobuf::Message {
 public:
  TImCustomCfgItem();
  virtual ~TImCustomCfgItem();

  TImCustomCfgItem(const TImCustomCfgItem& from);

  inline TImCustomCfgItem& operator=(const TImCustomCfgItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImCustomCfgItem& default_instance();

  void Swap(TImCustomCfgItem* other);

  // implements Message ----------------------------------------------

  TImCustomCfgItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImCustomCfgItem& from);
  void MergeFrom(const TImCustomCfgItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mt.TImCustomCfgItem)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImCustomCfgItem* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImCustomCfg : public ::google::protobuf::Message {
 public:
  TImCustomCfg();
  virtual ~TImCustomCfg();

  TImCustomCfg(const TImCustomCfg& from);

  inline TImCustomCfg& operator=(const TImCustomCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImCustomCfg& default_instance();

  void Swap(TImCustomCfg* other);

  // implements Message ----------------------------------------------

  TImCustomCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImCustomCfg& from);
  void MergeFrom(const TImCustomCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TImCustomCfgItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::mt::TImCustomCfgItem& items(int index) const;
  inline ::mt::TImCustomCfgItem* mutable_items(int index);
  inline ::mt::TImCustomCfgItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImCustomCfgItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImCustomCfgItem >*
      mutable_items();

  // optional uint32 itemscnt = 2;
  inline bool has_itemscnt() const;
  inline void clear_itemscnt();
  static const int kItemscntFieldNumber = 2;
  inline ::google::protobuf::uint32 itemscnt() const;
  inline void set_itemscnt(::google::protobuf::uint32 value);

  // optional bool get = 3;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 3;
  inline bool get() const;
  inline void set_get(bool value);

  // @@protoc_insertion_point(class_scope:mt.TImCustomCfg)
 private:
  inline void set_has_itemscnt();
  inline void clear_has_itemscnt();
  inline void set_has_get();
  inline void clear_has_get();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TImCustomCfgItem > items_;
  ::google::protobuf::uint32 itemscnt_;
  bool get_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImCustomCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImScreenChatroom : public ::google::protobuf::Message {
 public:
  TImScreenChatroom();
  virtual ~TImScreenChatroom();

  TImScreenChatroom(const TImScreenChatroom& from);

  inline TImScreenChatroom& operator=(const TImScreenChatroom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImScreenChatroom& default_instance();

  void Swap(TImScreenChatroom* other);

  // implements Message ----------------------------------------------

  TImScreenChatroom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImScreenChatroom& from);
  void MergeFrom(const TImScreenChatroom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool screen = 1;
  inline bool has_screen() const;
  inline void clear_screen();
  static const int kScreenFieldNumber = 1;
  inline bool screen() const;
  inline void set_screen(bool value);

  // optional string roomid = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 2;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:mt.TImScreenChatroom)
 private:
  inline void set_has_screen();
  inline void clear_has_screen();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  bool screen_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImScreenChatroom* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImScreenedChatrooms : public ::google::protobuf::Message {
 public:
  TImScreenedChatrooms();
  virtual ~TImScreenedChatrooms();

  TImScreenedChatrooms(const TImScreenedChatrooms& from);

  inline TImScreenedChatrooms& operator=(const TImScreenedChatrooms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImScreenedChatrooms& default_instance();

  void Swap(TImScreenedChatrooms* other);

  // implements Message ----------------------------------------------

  TImScreenedChatrooms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImScreenedChatrooms& from);
  void MergeFrom(const TImScreenedChatrooms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string roomids = 1;
  inline int roomids_size() const;
  inline void clear_roomids();
  static const int kRoomidsFieldNumber = 1;
  inline const ::std::string& roomids(int index) const;
  inline ::std::string* mutable_roomids(int index);
  inline void set_roomids(int index, const ::std::string& value);
  inline void set_roomids(int index, const char* value);
  inline void set_roomids(int index, const char* value, size_t size);
  inline ::std::string* add_roomids();
  inline void add_roomids(const ::std::string& value);
  inline void add_roomids(const char* value);
  inline void add_roomids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& roomids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_roomids();

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TImScreenedChatrooms)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> roomids_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImScreenedChatrooms* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImScreenChatroomR : public ::google::protobuf::Message {
 public:
  TImScreenChatroomR();
  virtual ~TImScreenChatroomR();

  TImScreenChatroomR(const TImScreenChatroomR& from);

  inline TImScreenChatroomR& operator=(const TImScreenChatroomR& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImScreenChatroomR& default_instance();

  void Swap(TImScreenChatroomR* other);

  // implements Message ----------------------------------------------

  TImScreenChatroomR* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImScreenChatroomR& from);
  void MergeFrom(const TImScreenChatroomR& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool screen = 1;
  inline bool has_screen() const;
  inline void clear_screen();
  static const int kScreenFieldNumber = 1;
  inline bool screen() const;
  inline void set_screen(bool value);

  // repeated string roomids = 2;
  inline int roomids_size() const;
  inline void clear_roomids();
  static const int kRoomidsFieldNumber = 2;
  inline const ::std::string& roomids(int index) const;
  inline ::std::string* mutable_roomids(int index);
  inline void set_roomids(int index, const ::std::string& value);
  inline void set_roomids(int index, const char* value);
  inline void set_roomids(int index, const char* value, size_t size);
  inline ::std::string* add_roomids();
  inline void add_roomids(const ::std::string& value);
  inline void add_roomids(const char* value);
  inline void add_roomids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& roomids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_roomids();

  // optional uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TImScreenChatroomR)
 private:
  inline void set_has_screen();
  inline void clear_has_screen();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> roomids_;
  bool screen_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImScreenChatroomR* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TChatroomMemberCacheItem : public ::google::protobuf::Message {
 public:
  TChatroomMemberCacheItem();
  virtual ~TChatroomMemberCacheItem();

  TChatroomMemberCacheItem(const TChatroomMemberCacheItem& from);

  inline TChatroomMemberCacheItem& operator=(const TChatroomMemberCacheItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TChatroomMemberCacheItem& default_instance();

  void Swap(TChatroomMemberCacheItem* other);

  // implements Message ----------------------------------------------

  TChatroomMemberCacheItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TChatroomMemberCacheItem& from);
  void MergeFrom(const TChatroomMemberCacheItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string eventid = 1;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventidFieldNumber = 1;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional uint32 app = 2;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 2;
  inline ::google::protobuf::uint32 app() const;
  inline void set_app(::google::protobuf::uint32 value);

  // optional .mt.TImMultiChatMemberInfoEx info = 3;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::mt::TImMultiChatMemberInfoEx& info() const;
  inline ::mt::TImMultiChatMemberInfoEx* mutable_info();
  inline ::mt::TImMultiChatMemberInfoEx* release_info();
  inline void set_allocated_info(::mt::TImMultiChatMemberInfoEx* info);

  // @@protoc_insertion_point(class_scope:mt.TChatroomMemberCacheItem)
 private:
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* eventid_;
  ::mt::TImMultiChatMemberInfoEx* info_;
  ::google::protobuf::uint32 app_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TChatroomMemberCacheItem* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TChatroomMemberCacheList : public ::google::protobuf::Message {
 public:
  TChatroomMemberCacheList();
  virtual ~TChatroomMemberCacheList();

  TChatroomMemberCacheList(const TChatroomMemberCacheList& from);

  inline TChatroomMemberCacheList& operator=(const TChatroomMemberCacheList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TChatroomMemberCacheList& default_instance();

  void Swap(TChatroomMemberCacheList* other);

  // implements Message ----------------------------------------------

  TChatroomMemberCacheList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TChatroomMemberCacheList& from);
  void MergeFrom(const TChatroomMemberCacheList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 arraysize = 1;
  inline bool has_arraysize() const;
  inline void clear_arraysize();
  static const int kArraysizeFieldNumber = 1;
  inline ::google::protobuf::uint32 arraysize() const;
  inline void set_arraysize(::google::protobuf::uint32 value);

  // repeated .mt.TChatroomMemberCacheItem array = 2;
  inline int array_size() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 2;
  inline const ::mt::TChatroomMemberCacheItem& array(int index) const;
  inline ::mt::TChatroomMemberCacheItem* mutable_array(int index);
  inline ::mt::TChatroomMemberCacheItem* add_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TChatroomMemberCacheItem >&
      array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TChatroomMemberCacheItem >*
      mutable_array();

  // @@protoc_insertion_point(class_scope:mt.TChatroomMemberCacheList)
 private:
  inline void set_has_arraysize();
  inline void clear_has_arraysize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TChatroomMemberCacheItem > array_;
  ::google::protobuf::uint32 arraysize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TChatroomMemberCacheList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWeiboOnlineInfo : public ::google::protobuf::Message {
 public:
  TWeiboOnlineInfo();
  virtual ~TWeiboOnlineInfo();

  TWeiboOnlineInfo(const TWeiboOnlineInfo& from);

  inline TWeiboOnlineInfo& operator=(const TWeiboOnlineInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWeiboOnlineInfo& default_instance();

  void Swap(TWeiboOnlineInfo* other);

  // implements Message ----------------------------------------------

  TWeiboOnlineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWeiboOnlineInfo& from);
  void MergeFrom(const TWeiboOnlineInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string mugshot64 = 5;
  inline bool has_mugshot64() const;
  inline void clear_mugshot64();
  static const int kMugshot64FieldNumber = 5;
  inline const ::std::string& mugshot64() const;
  inline void set_mugshot64(const ::std::string& value);
  inline void set_mugshot64(const char* value);
  inline void set_mugshot64(const char* value, size_t size);
  inline ::std::string* mutable_mugshot64();
  inline ::std::string* release_mugshot64();
  inline void set_allocated_mugshot64(::std::string* mugshot64);

  // @@protoc_insertion_point(class_scope:mt.TWeiboOnlineInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_mugshot64();
  inline void clear_has_mugshot64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* name_;
  ::std::string* email_;
  ::std::string* mugshot64_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TWeiboOnlineInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWeiboCommonInfo : public ::google::protobuf::Message {
 public:
  TWeiboCommonInfo();
  virtual ~TWeiboCommonInfo();

  TWeiboCommonInfo(const TWeiboCommonInfo& from);

  inline TWeiboCommonInfo& operator=(const TWeiboCommonInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWeiboCommonInfo& default_instance();

  void Swap(TWeiboCommonInfo* other);

  // implements Message ----------------------------------------------

  TWeiboCommonInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWeiboCommonInfo& from);
  void MergeFrom(const TWeiboCommonInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::uint32 amount() const;
  inline void set_amount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TWeiboCommonInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_amount();
  inline void clear_has_amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TWeiboCommonInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWeiboNewFeedInfo : public ::google::protobuf::Message {
 public:
  TWeiboNewFeedInfo();
  virtual ~TWeiboNewFeedInfo();

  TWeiboNewFeedInfo(const TWeiboNewFeedInfo& from);

  inline TWeiboNewFeedInfo& operator=(const TWeiboNewFeedInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWeiboNewFeedInfo& default_instance();

  void Swap(TWeiboNewFeedInfo* other);

  // implements Message ----------------------------------------------

  TWeiboNewFeedInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWeiboNewFeedInfo& from);
  void MergeFrom(const TWeiboNewFeedInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 feedid = 1;
  inline bool has_feedid() const;
  inline void clear_feedid();
  static const int kFeedidFieldNumber = 1;
  inline ::google::protobuf::uint32 feedid() const;
  inline void set_feedid(::google::protobuf::uint32 value);

  // optional uint32 groupid = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 2;
  inline ::google::protobuf::uint32 groupid() const;
  inline void set_groupid(::google::protobuf::uint32 value);

  // optional uint32 groupuid = 3;
  inline bool has_groupuid() const;
  inline void clear_groupuid();
  static const int kGroupuidFieldNumber = 3;
  inline ::google::protobuf::uint32 groupuid() const;
  inline void set_groupuid(::google::protobuf::uint32 value);

  // optional string groupname = 4;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupnameFieldNumber = 4;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional uint32 amount = 5;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 5;
  inline ::google::protobuf::uint32 amount() const;
  inline void set_amount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TWeiboNewFeedInfo)
 private:
  inline void set_has_feedid();
  inline void clear_has_feedid();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_groupuid();
  inline void clear_has_groupuid();
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_amount();
  inline void clear_has_amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 feedid_;
  ::google::protobuf::uint32 groupid_;
  ::std::string* groupname_;
  ::google::protobuf::uint32 groupuid_;
  ::google::protobuf::uint32 amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TWeiboNewFeedInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMeetingnotify : public ::google::protobuf::Message {
 public:
  TMeetingnotify();
  virtual ~TMeetingnotify();

  TMeetingnotify(const TMeetingnotify& from);

  inline TMeetingnotify& operator=(const TMeetingnotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMeetingnotify& default_instance();

  void Swap(TMeetingnotify* other);

  // implements Message ----------------------------------------------

  TMeetingnotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMeetingnotify& from);
  void MergeFrom(const TMeetingnotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmRestMeetingNotifyType notifytype = 1;
  inline bool has_notifytype() const;
  inline void clear_notifytype();
  static const int kNotifytypeFieldNumber = 1;
  inline ::mt::EmRestMeetingNotifyType notifytype() const;
  inline void set_notifytype(::mt::EmRestMeetingNotifyType value);

  // optional string moid = 2;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 2;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional uint32 nofifyid = 3;
  inline bool has_nofifyid() const;
  inline void clear_nofifyid();
  static const int kNofifyidFieldNumber = 3;
  inline ::google::protobuf::uint32 nofifyid() const;
  inline void set_nofifyid(::google::protobuf::uint32 value);

  // optional uint32 num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMeetingnotify)
 private:
  inline void set_has_notifytype();
  inline void clear_has_notifytype();
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_nofifyid();
  inline void clear_has_nofifyid();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  int notifytype_;
  ::google::protobuf::uint32 nofifyid_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TMeetingnotify* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParseKedaDept : public ::google::protobuf::Message {
 public:
  TMTWbParseKedaDept();
  virtual ~TMTWbParseKedaDept();

  TMTWbParseKedaDept(const TMTWbParseKedaDept& from);

  inline TMTWbParseKedaDept& operator=(const TMTWbParseKedaDept& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParseKedaDept& default_instance();

  void Swap(TMTWbParseKedaDept* other);

  // implements Message ----------------------------------------------

  TMTWbParseKedaDept* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParseKedaDept& from);
  void MergeFrom(const TMTWbParseKedaDept& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 departmentid = 1;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentidFieldNumber = 1;
  inline ::google::protobuf::uint32 departmentid() const;
  inline void set_departmentid(::google::protobuf::uint32 value);

  // optional string departmentname = 2;
  inline bool has_departmentname() const;
  inline void clear_departmentname();
  static const int kDepartmentnameFieldNumber = 2;
  inline const ::std::string& departmentname() const;
  inline void set_departmentname(const ::std::string& value);
  inline void set_departmentname(const char* value);
  inline void set_departmentname(const char* value, size_t size);
  inline ::std::string* mutable_departmentname();
  inline ::std::string* release_departmentname();
  inline void set_allocated_departmentname(::std::string* departmentname);

  // optional string fullPath = 3;
  inline bool has_fullpath() const;
  inline void clear_fullpath();
  static const int kFullPathFieldNumber = 3;
  inline const ::std::string& fullpath() const;
  inline void set_fullpath(const ::std::string& value);
  inline void set_fullpath(const char* value);
  inline void set_fullpath(const char* value, size_t size);
  inline ::std::string* mutable_fullpath();
  inline ::std::string* release_fullpath();
  inline void set_allocated_fullpath(::std::string* fullpath);

  // optional string deptPosition = 4;
  inline bool has_deptposition() const;
  inline void clear_deptposition();
  static const int kDeptPositionFieldNumber = 4;
  inline const ::std::string& deptposition() const;
  inline void set_deptposition(const ::std::string& value);
  inline void set_deptposition(const char* value);
  inline void set_deptposition(const char* value, size_t size);
  inline ::std::string* mutable_deptposition();
  inline ::std::string* release_deptposition();
  inline void set_allocated_deptposition(::std::string* deptposition);

  // @@protoc_insertion_point(class_scope:mt.TMTWbParseKedaDept)
 private:
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_departmentname();
  inline void clear_has_departmentname();
  inline void set_has_fullpath();
  inline void clear_has_fullpath();
  inline void set_has_deptposition();
  inline void clear_has_deptposition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* departmentname_;
  ::std::string* fullpath_;
  ::std::string* deptposition_;
  ::google::protobuf::uint32 departmentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParseKedaDept* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParseKedaDepts : public ::google::protobuf::Message {
 public:
  TMTWbParseKedaDepts();
  virtual ~TMTWbParseKedaDepts();

  TMTWbParseKedaDepts(const TMTWbParseKedaDepts& from);

  inline TMTWbParseKedaDepts& operator=(const TMTWbParseKedaDepts& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParseKedaDepts& default_instance();

  void Swap(TMTWbParseKedaDepts* other);

  // implements Message ----------------------------------------------

  TMTWbParseKedaDepts* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParseKedaDepts& from);
  void MergeFrom(const TMTWbParseKedaDepts& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 deptnum = 1;
  inline bool has_deptnum() const;
  inline void clear_deptnum();
  static const int kDeptnumFieldNumber = 1;
  inline ::google::protobuf::uint32 deptnum() const;
  inline void set_deptnum(::google::protobuf::uint32 value);

  // repeated .mt.TMTWbParseKedaDept kedadept = 2;
  inline int kedadept_size() const;
  inline void clear_kedadept();
  static const int kKedadeptFieldNumber = 2;
  inline const ::mt::TMTWbParseKedaDept& kedadept(int index) const;
  inline ::mt::TMTWbParseKedaDept* mutable_kedadept(int index);
  inline ::mt::TMTWbParseKedaDept* add_kedadept();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParseKedaDept >&
      kedadept() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParseKedaDept >*
      mutable_kedadept();

  // @@protoc_insertion_point(class_scope:mt.TMTWbParseKedaDepts)
 private:
  inline void set_has_deptnum();
  inline void clear_has_deptnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParseKedaDept > kedadept_;
  ::google::protobuf::uint32 deptnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParseKedaDepts* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParse_Keda_EntUser : public ::google::protobuf::Message {
 public:
  TMTWbParse_Keda_EntUser();
  virtual ~TMTWbParse_Keda_EntUser();

  TMTWbParse_Keda_EntUser(const TMTWbParse_Keda_EntUser& from);

  inline TMTWbParse_Keda_EntUser& operator=(const TMTWbParse_Keda_EntUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParse_Keda_EntUser& default_instance();

  void Swap(TMTWbParse_Keda_EntUser* other);

  // implements Message ----------------------------------------------

  TMTWbParse_Keda_EntUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParse_Keda_EntUser& from);
  void MergeFrom(const TMTWbParse_Keda_EntUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid = 1;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 1;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional string jid = 2;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 2;
  inline const ::std::string& jid() const;
  inline void set_jid(const ::std::string& value);
  inline void set_jid(const char* value);
  inline void set_jid(const char* value, size_t size);
  inline ::std::string* mutable_jid();
  inline ::std::string* release_jid();
  inline void set_allocated_jid(::std::string* jid);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string entmail = 4;
  inline bool has_entmail() const;
  inline void clear_entmail();
  static const int kEntmailFieldNumber = 4;
  inline const ::std::string& entmail() const;
  inline void set_entmail(const ::std::string& value);
  inline void set_entmail(const char* value);
  inline void set_entmail(const char* value, size_t size);
  inline ::std::string* mutable_entmail();
  inline ::std::string* release_entmail();
  inline void set_allocated_entmail(::std::string* entmail);

  // optional string e164 = 5;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 5;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string mobilenum = 6;
  inline bool has_mobilenum() const;
  inline void clear_mobilenum();
  static const int kMobilenumFieldNumber = 6;
  inline const ::std::string& mobilenum() const;
  inline void set_mobilenum(const ::std::string& value);
  inline void set_mobilenum(const char* value);
  inline void set_mobilenum(const char* value, size_t size);
  inline ::std::string* mutable_mobilenum();
  inline ::std::string* release_mobilenum();
  inline void set_allocated_mobilenum(::std::string* mobilenum);

  // optional string userdomainmoid = 7;
  inline bool has_userdomainmoid() const;
  inline void clear_userdomainmoid();
  static const int kUserdomainmoidFieldNumber = 7;
  inline const ::std::string& userdomainmoid() const;
  inline void set_userdomainmoid(const ::std::string& value);
  inline void set_userdomainmoid(const char* value);
  inline void set_userdomainmoid(const char* value, size_t size);
  inline ::std::string* mutable_userdomainmoid();
  inline ::std::string* release_userdomainmoid();
  inline void set_allocated_userdomainmoid(::std::string* userdomainmoid);

  // optional string userdomainname = 8;
  inline bool has_userdomainname() const;
  inline void clear_userdomainname();
  static const int kUserdomainnameFieldNumber = 8;
  inline const ::std::string& userdomainname() const;
  inline void set_userdomainname(const ::std::string& value);
  inline void set_userdomainname(const char* value);
  inline void set_userdomainname(const char* value, size_t size);
  inline ::std::string* mutable_userdomainname();
  inline ::std::string* release_userdomainname();
  inline void set_allocated_userdomainname(::std::string* userdomainname);

  // optional string deviceguid = 9;
  inline bool has_deviceguid() const;
  inline void clear_deviceguid();
  static const int kDeviceguidFieldNumber = 9;
  inline const ::std::string& deviceguid() const;
  inline void set_deviceguid(const ::std::string& value);
  inline void set_deviceguid(const char* value);
  inline void set_deviceguid(const char* value, size_t size);
  inline ::std::string* mutable_deviceguid();
  inline ::std::string* release_deviceguid();
  inline void set_allocated_deviceguid(::std::string* deviceguid);

  // optional string nuserverid = 10;
  inline bool has_nuserverid() const;
  inline void clear_nuserverid();
  static const int kNuserveridFieldNumber = 10;
  inline const ::std::string& nuserverid() const;
  inline void set_nuserverid(const ::std::string& value);
  inline void set_nuserverid(const char* value);
  inline void set_nuserverid(const char* value, size_t size);
  inline ::std::string* mutable_nuserverid();
  inline ::std::string* release_nuserverid();
  inline void set_allocated_nuserverid(::std::string* nuserverid);

  // optional string devicetype = 11;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDevicetypeFieldNumber = 11;
  inline const ::std::string& devicetype() const;
  inline void set_devicetype(const ::std::string& value);
  inline void set_devicetype(const char* value);
  inline void set_devicetype(const char* value, size_t size);
  inline ::std::string* mutable_devicetype();
  inline ::std::string* release_devicetype();
  inline void set_allocated_devicetype(::std::string* devicetype);

  // optional bool enable = 12;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 12;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional bool limited = 13;
  inline bool has_limited() const;
  inline void clear_limited();
  static const int kLimitedFieldNumber = 13;
  inline bool limited() const;
  inline void set_limited(bool value);

  // optional string entname = 14;
  inline bool has_entname() const;
  inline void clear_entname();
  static const int kEntnameFieldNumber = 14;
  inline const ::std::string& entname() const;
  inline void set_entname(const ::std::string& value);
  inline void set_entname(const char* value);
  inline void set_entname(const char* value, size_t size);
  inline ::std::string* mutable_entname();
  inline ::std::string* release_entname();
  inline void set_allocated_entname(::std::string* entname);

  // optional string brief = 15;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 15;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // optional string jobnum = 16;
  inline bool has_jobnum() const;
  inline void clear_jobnum();
  static const int kJobnumFieldNumber = 16;
  inline const ::std::string& jobnum() const;
  inline void set_jobnum(const ::std::string& value);
  inline void set_jobnum(const char* value);
  inline void set_jobnum(const char* value, size_t size);
  inline ::std::string* mutable_jobnum();
  inline ::std::string* release_jobnum();
  inline void set_allocated_jobnum(::std::string* jobnum);

  // optional bool male = 17;
  inline bool has_male() const;
  inline void clear_male();
  static const int kMaleFieldNumber = 17;
  inline bool male() const;
  inline void set_male(bool value);

  // optional string extnum = 18;
  inline bool has_extnum() const;
  inline void clear_extnum();
  static const int kExtnumFieldNumber = 18;
  inline const ::std::string& extnum() const;
  inline void set_extnum(const ::std::string& value);
  inline void set_extnum(const char* value);
  inline void set_extnum(const char* value, size_t size);
  inline ::std::string* mutable_extnum();
  inline ::std::string* release_extnum();
  inline void set_allocated_extnum(::std::string* extnum);

  // optional string seat = 19;
  inline bool has_seat() const;
  inline void clear_seat();
  static const int kSeatFieldNumber = 19;
  inline const ::std::string& seat() const;
  inline void set_seat(const ::std::string& value);
  inline void set_seat(const char* value);
  inline void set_seat(const char* value, size_t size);
  inline ::std::string* mutable_seat();
  inline ::std::string* release_seat();
  inline void set_allocated_seat(::std::string* seat);

  // optional string officeLocation = 20;
  inline bool has_officelocation() const;
  inline void clear_officelocation();
  static const int kOfficeLocationFieldNumber = 20;
  inline const ::std::string& officelocation() const;
  inline void set_officelocation(const ::std::string& value);
  inline void set_officelocation(const char* value);
  inline void set_officelocation(const char* value, size_t size);
  inline ::std::string* mutable_officelocation();
  inline ::std::string* release_officelocation();
  inline void set_allocated_officelocation(::std::string* officelocation);

  // optional string dateOfBirth = 21;
  inline bool has_dateofbirth() const;
  inline void clear_dateofbirth();
  static const int kDateOfBirthFieldNumber = 21;
  inline const ::std::string& dateofbirth() const;
  inline void set_dateofbirth(const ::std::string& value);
  inline void set_dateofbirth(const char* value);
  inline void set_dateofbirth(const char* value, size_t size);
  inline ::std::string* mutable_dateofbirth();
  inline ::std::string* release_dateofbirth();
  inline void set_allocated_dateofbirth(::std::string* dateofbirth);

  // optional string fax = 22;
  inline bool has_fax() const;
  inline void clear_fax();
  static const int kFaxFieldNumber = 22;
  inline const ::std::string& fax() const;
  inline void set_fax(const ::std::string& value);
  inline void set_fax(const char* value);
  inline void set_fax(const char* value, size_t size);
  inline ::std::string* mutable_fax();
  inline ::std::string* release_fax();
  inline void set_allocated_fax(::std::string* fax);

  // optional string restrictUsedOn = 23;
  inline bool has_restrictusedon() const;
  inline void clear_restrictusedon();
  static const int kRestrictUsedOnFieldNumber = 23;
  inline const ::std::string& restrictusedon() const;
  inline void set_restrictusedon(const ::std::string& value);
  inline void set_restrictusedon(const char* value);
  inline void set_restrictusedon(const char* value, size_t size);
  inline ::std::string* mutable_restrictusedon();
  inline ::std::string* release_restrictusedon();
  inline void set_allocated_restrictusedon(::std::string* restrictusedon);

  // optional string portrait32 = 24;
  inline bool has_portrait32() const;
  inline void clear_portrait32();
  static const int kPortrait32FieldNumber = 24;
  inline const ::std::string& portrait32() const;
  inline void set_portrait32(const ::std::string& value);
  inline void set_portrait32(const char* value);
  inline void set_portrait32(const char* value, size_t size);
  inline ::std::string* mutable_portrait32();
  inline ::std::string* release_portrait32();
  inline void set_allocated_portrait32(::std::string* portrait32);

  // optional string portrait40 = 25;
  inline bool has_portrait40() const;
  inline void clear_portrait40();
  static const int kPortrait40FieldNumber = 25;
  inline const ::std::string& portrait40() const;
  inline void set_portrait40(const ::std::string& value);
  inline void set_portrait40(const char* value);
  inline void set_portrait40(const char* value, size_t size);
  inline ::std::string* mutable_portrait40();
  inline ::std::string* release_portrait40();
  inline void set_allocated_portrait40(::std::string* portrait40);

  // optional string portrait64 = 26;
  inline bool has_portrait64() const;
  inline void clear_portrait64();
  static const int kPortrait64FieldNumber = 26;
  inline const ::std::string& portrait64() const;
  inline void set_portrait64(const ::std::string& value);
  inline void set_portrait64(const char* value);
  inline void set_portrait64(const char* value, size_t size);
  inline ::std::string* mutable_portrait64();
  inline ::std::string* release_portrait64();
  inline void set_allocated_portrait64(::std::string* portrait64);

  // optional string portrait128 = 27;
  inline bool has_portrait128() const;
  inline void clear_portrait128();
  static const int kPortrait128FieldNumber = 27;
  inline const ::std::string& portrait128() const;
  inline void set_portrait128(const ::std::string& value);
  inline void set_portrait128(const char* value);
  inline void set_portrait128(const char* value, size_t size);
  inline ::std::string* mutable_portrait128();
  inline ::std::string* release_portrait128();
  inline void set_allocated_portrait128(::std::string* portrait128);

  // optional string portrait256 = 28;
  inline bool has_portrait256() const;
  inline void clear_portrait256();
  static const int kPortrait256FieldNumber = 28;
  inline const ::std::string& portrait256() const;
  inline void set_portrait256(const ::std::string& value);
  inline void set_portrait256(const char* value);
  inline void set_portrait256(const char* value, size_t size);
  inline ::std::string* mutable_portrait256();
  inline ::std::string* release_portrait256();
  inline void set_allocated_portrait256(::std::string* portrait256);

  // optional bool enableweibo = 29;
  inline bool has_enableweibo() const;
  inline void clear_enableweibo();
  static const int kEnableweiboFieldNumber = 29;
  inline bool enableweibo() const;
  inline void set_enableweibo(bool value);

  // optional bool enablemeetingsms = 30;
  inline bool has_enablemeetingsms() const;
  inline void clear_enablemeetingsms();
  static const int kEnablemeetingsmsFieldNumber = 30;
  inline bool enablemeetingsms() const;
  inline void set_enablemeetingsms(bool value);

  // optional bool enablemeeting = 31;
  inline bool has_enablemeeting() const;
  inline void clear_enablemeeting();
  static const int kEnablemeetingFieldNumber = 31;
  inline bool enablemeeting() const;
  inline void set_enablemeeting(bool value);

  // optional bool enablehd = 32;
  inline bool has_enablehd() const;
  inline void clear_enablehd();
  static const int kEnablehdFieldNumber = 32;
  inline bool enablehd() const;
  inline void set_enablehd(bool value);

  // optional bool enablecall = 33;
  inline bool has_enablecall() const;
  inline void clear_enablecall();
  static const int kEnablecallFieldNumber = 33;
  inline bool enablecall() const;
  inline void set_enablecall(bool value);

  // optional bool enableroam = 34;
  inline bool has_enableroam() const;
  inline void clear_enableroam();
  static const int kEnableroamFieldNumber = 34;
  inline bool enableroam() const;
  inline void set_enableroam(bool value);

  // optional bool enablesatellite = 35;
  inline bool has_enablesatellite() const;
  inline void clear_enablesatellite();
  static const int kEnablesatelliteFieldNumber = 35;
  inline bool enablesatellite() const;
  inline void set_enablesatellite(bool value);

  // optional bool enablesatellitep2p = 36;
  inline bool has_enablesatellitep2p() const;
  inline void clear_enablesatellitep2p();
  static const int kEnablesatellitep2PFieldNumber = 36;
  inline bool enablesatellitep2p() const;
  inline void set_enablesatellitep2p(bool value);

  // optional bool weiboadmin = 37;
  inline bool has_weiboadmin() const;
  inline void clear_weiboadmin();
  static const int kWeiboadminFieldNumber = 37;
  inline bool weiboadmin() const;
  inline void set_weiboadmin(bool value);

  // optional bool meetingadmin = 38;
  inline bool has_meetingadmin() const;
  inline void clear_meetingadmin();
  static const int kMeetingadminFieldNumber = 38;
  inline bool meetingadmin() const;
  inline void set_meetingadmin(bool value);

  // optional bool enablebmc = 39;
  inline bool has_enablebmc() const;
  inline void clear_enablebmc();
  static const int kEnablebmcFieldNumber = 39;
  inline bool enablebmc() const;
  inline void set_enablebmc(bool value);

  // optional bool enableumc = 40;
  inline bool has_enableumc() const;
  inline void clear_enableumc();
  static const int kEnableumcFieldNumber = 40;
  inline bool enableumc() const;
  inline void set_enableumc(bool value);

  // optional bool enabledcs = 41;
  inline bool has_enabledcs() const;
  inline void clear_enabledcs();
  static const int kEnabledcsFieldNumber = 41;
  inline bool enabledcs() const;
  inline void set_enabledcs(bool value);

  // optional bool enablevrs = 42;
  inline bool has_enablevrs() const;
  inline void clear_enablevrs();
  static const int kEnablevrsFieldNumber = 42;
  inline bool enablevrs() const;
  inline void set_enablevrs(bool value);

  // optional bool enablenm = 43;
  inline bool has_enablenm() const;
  inline void clear_enablenm();
  static const int kEnablenmFieldNumber = 43;
  inline bool enablenm() const;
  inline void set_enablenm(bool value);

  // optional bool enablevenuemonitor = 44;
  inline bool has_enablevenuemonitor() const;
  inline void clear_enablevenuemonitor();
  static const int kEnablevenuemonitorFieldNumber = 44;
  inline bool enablevenuemonitor() const;
  inline void set_enablevenuemonitor(bool value);

  // optional bool defaultuserdomainadmin = 45;
  inline bool has_defaultuserdomainadmin() const;
  inline void clear_defaultuserdomainadmin();
  static const int kDefaultuserdomainadminFieldNumber = 45;
  inline bool defaultuserdomainadmin() const;
  inline void set_defaultuserdomainadmin(bool value);

  // optional bool enableout = 46;
  inline bool has_enableout() const;
  inline void clear_enableout();
  static const int kEnableoutFieldNumber = 46;
  inline bool enableout() const;
  inline void set_enableout(bool value);

  // optional bool enableincoming = 47;
  inline bool has_enableincoming() const;
  inline void clear_enableincoming();
  static const int kEnableincomingFieldNumber = 47;
  inline bool enableincoming() const;
  inline void set_enableincoming(bool value);

  // optional bool dcsadmin = 48;
  inline bool has_dcsadmin() const;
  inline void clear_dcsadmin();
  static const int kDcsadminFieldNumber = 48;
  inline bool dcsadmin() const;
  inline void set_dcsadmin(bool value);

  // optional bool vrsadmin = 49;
  inline bool has_vrsadmin() const;
  inline void clear_vrsadmin();
  static const int kVrsadminFieldNumber = 49;
  inline bool vrsadmin() const;
  inline void set_vrsadmin(bool value);

  // optional bool nmadmin = 50;
  inline bool has_nmadmin() const;
  inline void clear_nmadmin();
  static const int kNmadminFieldNumber = 50;
  inline bool nmadmin() const;
  inline void set_nmadmin(bool value);

  // optional bool enablevideo = 51;
  inline bool has_enablevideo() const;
  inline void clear_enablevideo();
  static const int kEnablevideoFieldNumber = 51;
  inline bool enablevideo() const;
  inline void set_enablevideo(bool value);

  // optional bool enablelive = 52;
  inline bool has_enablelive() const;
  inline void clear_enablelive();
  static const int kEnableliveFieldNumber = 52;
  inline bool enablelive() const;
  inline void set_enablelive(bool value);

  // optional bool enableplay = 53;
  inline bool has_enableplay() const;
  inline void clear_enableplay();
  static const int kEnableplayFieldNumber = 53;
  inline bool enableplay() const;
  inline void set_enableplay(bool value);

  // optional bool cmsapproval = 54;
  inline bool has_cmsapproval() const;
  inline void clear_cmsapproval();
  static const int kCmsapprovalFieldNumber = 54;
  inline bool cmsapproval() const;
  inline void set_cmsapproval(bool value);

  // optional bool editname = 55;
  inline bool has_editname() const;
  inline void clear_editname();
  static const int kEditnameFieldNumber = 55;
  inline bool editname() const;
  inline void set_editname(bool value);

  // optional .mt.TMTWbParseKedaDepts wbparsekedadepts = 56;
  inline bool has_wbparsekedadepts() const;
  inline void clear_wbparsekedadepts();
  static const int kWbparsekedadeptsFieldNumber = 56;
  inline const ::mt::TMTWbParseKedaDepts& wbparsekedadepts() const;
  inline ::mt::TMTWbParseKedaDepts* mutable_wbparsekedadepts();
  inline ::mt::TMTWbParseKedaDepts* release_wbparsekedadepts();
  inline void set_allocated_wbparsekedadepts(::mt::TMTWbParseKedaDepts* wbparsekedadepts);

  // optional bool enablefullhd = 57;
  inline bool has_enablefullhd() const;
  inline void clear_enablefullhd();
  static const int kEnablefullhdFieldNumber = 57;
  inline bool enablefullhd() const;
  inline void set_enablefullhd(bool value);

  // optional bool enableultrahd = 58;
  inline bool has_enableultrahd() const;
  inline void clear_enableultrahd();
  static const int kEnableultrahdFieldNumber = 58;
  inline bool enableultrahd() const;
  inline void set_enableultrahd(bool value);

  // optional bool enableunicat = 59;
  inline bool has_enableunicat() const;
  inline void clear_enableunicat();
  static const int kEnableunicatFieldNumber = 59;
  inline bool enableunicat() const;
  inline void set_enableunicat(bool value);

  // optional bool enabledownload = 60;
  inline bool has_enabledownload() const;
  inline void clear_enabledownload();
  static const int kEnabledownloadFieldNumber = 60;
  inline bool enabledownload() const;
  inline void set_enabledownload(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTWbParse_Keda_EntUser)
 private:
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_jid();
  inline void clear_has_jid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_entmail();
  inline void clear_has_entmail();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_mobilenum();
  inline void clear_has_mobilenum();
  inline void set_has_userdomainmoid();
  inline void clear_has_userdomainmoid();
  inline void set_has_userdomainname();
  inline void clear_has_userdomainname();
  inline void set_has_deviceguid();
  inline void clear_has_deviceguid();
  inline void set_has_nuserverid();
  inline void clear_has_nuserverid();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_limited();
  inline void clear_has_limited();
  inline void set_has_entname();
  inline void clear_has_entname();
  inline void set_has_brief();
  inline void clear_has_brief();
  inline void set_has_jobnum();
  inline void clear_has_jobnum();
  inline void set_has_male();
  inline void clear_has_male();
  inline void set_has_extnum();
  inline void clear_has_extnum();
  inline void set_has_seat();
  inline void clear_has_seat();
  inline void set_has_officelocation();
  inline void clear_has_officelocation();
  inline void set_has_dateofbirth();
  inline void clear_has_dateofbirth();
  inline void set_has_fax();
  inline void clear_has_fax();
  inline void set_has_restrictusedon();
  inline void clear_has_restrictusedon();
  inline void set_has_portrait32();
  inline void clear_has_portrait32();
  inline void set_has_portrait40();
  inline void clear_has_portrait40();
  inline void set_has_portrait64();
  inline void clear_has_portrait64();
  inline void set_has_portrait128();
  inline void clear_has_portrait128();
  inline void set_has_portrait256();
  inline void clear_has_portrait256();
  inline void set_has_enableweibo();
  inline void clear_has_enableweibo();
  inline void set_has_enablemeetingsms();
  inline void clear_has_enablemeetingsms();
  inline void set_has_enablemeeting();
  inline void clear_has_enablemeeting();
  inline void set_has_enablehd();
  inline void clear_has_enablehd();
  inline void set_has_enablecall();
  inline void clear_has_enablecall();
  inline void set_has_enableroam();
  inline void clear_has_enableroam();
  inline void set_has_enablesatellite();
  inline void clear_has_enablesatellite();
  inline void set_has_enablesatellitep2p();
  inline void clear_has_enablesatellitep2p();
  inline void set_has_weiboadmin();
  inline void clear_has_weiboadmin();
  inline void set_has_meetingadmin();
  inline void clear_has_meetingadmin();
  inline void set_has_enablebmc();
  inline void clear_has_enablebmc();
  inline void set_has_enableumc();
  inline void clear_has_enableumc();
  inline void set_has_enabledcs();
  inline void clear_has_enabledcs();
  inline void set_has_enablevrs();
  inline void clear_has_enablevrs();
  inline void set_has_enablenm();
  inline void clear_has_enablenm();
  inline void set_has_enablevenuemonitor();
  inline void clear_has_enablevenuemonitor();
  inline void set_has_defaultuserdomainadmin();
  inline void clear_has_defaultuserdomainadmin();
  inline void set_has_enableout();
  inline void clear_has_enableout();
  inline void set_has_enableincoming();
  inline void clear_has_enableincoming();
  inline void set_has_dcsadmin();
  inline void clear_has_dcsadmin();
  inline void set_has_vrsadmin();
  inline void clear_has_vrsadmin();
  inline void set_has_nmadmin();
  inline void clear_has_nmadmin();
  inline void set_has_enablevideo();
  inline void clear_has_enablevideo();
  inline void set_has_enablelive();
  inline void clear_has_enablelive();
  inline void set_has_enableplay();
  inline void clear_has_enableplay();
  inline void set_has_cmsapproval();
  inline void clear_has_cmsapproval();
  inline void set_has_editname();
  inline void clear_has_editname();
  inline void set_has_wbparsekedadepts();
  inline void clear_has_wbparsekedadepts();
  inline void set_has_enablefullhd();
  inline void clear_has_enablefullhd();
  inline void set_has_enableultrahd();
  inline void clear_has_enableultrahd();
  inline void set_has_enableunicat();
  inline void clear_has_enableunicat();
  inline void set_has_enabledownload();
  inline void clear_has_enabledownload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::std::string* jid_;
  ::std::string* account_;
  ::std::string* entmail_;
  ::std::string* e164_;
  ::std::string* mobilenum_;
  ::std::string* userdomainmoid_;
  ::std::string* userdomainname_;
  ::std::string* deviceguid_;
  ::std::string* nuserverid_;
  ::std::string* devicetype_;
  ::std::string* entname_;
  ::std::string* brief_;
  ::std::string* jobnum_;
  ::std::string* extnum_;
  ::std::string* seat_;
  ::std::string* officelocation_;
  ::std::string* dateofbirth_;
  ::std::string* fax_;
  ::std::string* restrictusedon_;
  ::std::string* portrait32_;
  bool enable_;
  bool limited_;
  bool male_;
  bool enableweibo_;
  bool enablemeetingsms_;
  bool enablemeeting_;
  bool enablehd_;
  bool enablecall_;
  ::std::string* portrait40_;
  ::std::string* portrait64_;
  ::std::string* portrait128_;
  ::std::string* portrait256_;
  bool enableroam_;
  bool enablesatellite_;
  bool enablesatellitep2p_;
  bool weiboadmin_;
  bool meetingadmin_;
  bool enablebmc_;
  bool enableumc_;
  bool enabledcs_;
  bool enablevrs_;
  bool enablenm_;
  bool enablevenuemonitor_;
  bool defaultuserdomainadmin_;
  bool enableout_;
  bool enableincoming_;
  bool dcsadmin_;
  bool vrsadmin_;
  bool nmadmin_;
  bool enablevideo_;
  bool enablelive_;
  bool enableplay_;
  bool cmsapproval_;
  bool editname_;
  bool enablefullhd_;
  bool enableultrahd_;
  ::mt::TMTWbParseKedaDepts* wbparsekedadepts_;
  bool enableunicat_;
  bool enabledownload_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(60 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParse_Keda_EntUser* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImMemberInfo : public ::google::protobuf::Message {
 public:
  TImMemberInfo();
  virtual ~TImMemberInfo();

  TImMemberInfo(const TImMemberInfo& from);

  inline TImMemberInfo& operator=(const TImMemberInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImMemberInfo& default_instance();

  void Swap(TImMemberInfo* other);

  // implements Message ----------------------------------------------

  TImMemberInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImMemberInfo& from);
  void MergeFrom(const TImMemberInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string membersn = 1;
  inline bool has_membersn() const;
  inline void clear_membersn();
  static const int kMembersnFieldNumber = 1;
  inline const ::std::string& membersn() const;
  inline void set_membersn(const ::std::string& value);
  inline void set_membersn(const char* value);
  inline void set_membersn(const char* value, size_t size);
  inline ::std::string* mutable_membersn();
  inline ::std::string* release_membersn();
  inline void set_allocated_membersn(::std::string* membersn);

  // optional string groupsn = 2;
  inline bool has_groupsn() const;
  inline void clear_groupsn();
  static const int kGroupsnFieldNumber = 2;
  inline const ::std::string& groupsn() const;
  inline void set_groupsn(const ::std::string& value);
  inline void set_groupsn(const char* value);
  inline void set_groupsn(const char* value, size_t size);
  inline ::std::string* mutable_groupsn();
  inline ::std::string* release_groupsn();
  inline void set_allocated_groupsn(::std::string* groupsn);

  // optional string memberno = 3;
  inline bool has_memberno() const;
  inline void clear_memberno();
  static const int kMembernoFieldNumber = 3;
  inline const ::std::string& memberno() const;
  inline void set_memberno(const ::std::string& value);
  inline void set_memberno(const char* value);
  inline void set_memberno(const char* value, size_t size);
  inline ::std::string* mutable_memberno();
  inline ::std::string* release_memberno();
  inline void set_allocated_memberno(::std::string* memberno);

  // optional string markname = 4;
  inline bool has_markname() const;
  inline void clear_markname();
  static const int kMarknameFieldNumber = 4;
  inline const ::std::string& markname() const;
  inline void set_markname(const ::std::string& value);
  inline void set_markname(const char* value);
  inline void set_markname(const char* value, size_t size);
  inline ::std::string* mutable_markname();
  inline ::std::string* release_markname();
  inline void set_allocated_markname(::std::string* markname);

  // optional .mt.EmMtMemberType membertype = 5;
  inline bool has_membertype() const;
  inline void clear_membertype();
  static const int kMembertypeFieldNumber = 5;
  inline ::mt::EmMtMemberType membertype() const;
  inline void set_membertype(::mt::EmMtMemberType value);

  // optional uint32 bitrate = 6;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 6;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.TMTWbParse_Keda_EntUser weiboinfo = 7;
  inline bool has_weiboinfo() const;
  inline void clear_weiboinfo();
  static const int kWeiboinfoFieldNumber = 7;
  inline const ::mt::TMTWbParse_Keda_EntUser& weiboinfo() const;
  inline ::mt::TMTWbParse_Keda_EntUser* mutable_weiboinfo();
  inline ::mt::TMTWbParse_Keda_EntUser* release_weiboinfo();
  inline void set_allocated_weiboinfo(::mt::TMTWbParse_Keda_EntUser* weiboinfo);

  // optional bool noquery = 8;
  inline bool has_noquery() const;
  inline void clear_noquery();
  static const int kNoqueryFieldNumber = 8;
  inline bool noquery() const;
  inline void set_noquery(bool value);

  // @@protoc_insertion_point(class_scope:mt.TImMemberInfo)
 private:
  inline void set_has_membersn();
  inline void clear_has_membersn();
  inline void set_has_groupsn();
  inline void clear_has_groupsn();
  inline void set_has_memberno();
  inline void clear_has_memberno();
  inline void set_has_markname();
  inline void clear_has_markname();
  inline void set_has_membertype();
  inline void clear_has_membertype();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_weiboinfo();
  inline void clear_has_weiboinfo();
  inline void set_has_noquery();
  inline void clear_has_noquery();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* membersn_;
  ::std::string* groupsn_;
  ::std::string* memberno_;
  ::std::string* markname_;
  int membertype_;
  ::google::protobuf::uint32 bitrate_;
  ::mt::TMTWbParse_Keda_EntUser* weiboinfo_;
  bool noquery_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImMemberInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImMemberList : public ::google::protobuf::Message {
 public:
  TImMemberList();
  virtual ~TImMemberList();

  TImMemberList(const TImMemberList& from);

  inline TImMemberList& operator=(const TImMemberList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImMemberList& default_instance();

  void Swap(TImMemberList* other);

  // implements Message ----------------------------------------------

  TImMemberList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImMemberList& from);
  void MergeFrom(const TImMemberList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 arraysize = 1;
  inline bool has_arraysize() const;
  inline void clear_arraysize();
  static const int kArraysizeFieldNumber = 1;
  inline ::google::protobuf::uint32 arraysize() const;
  inline void set_arraysize(::google::protobuf::uint32 value);

  // repeated .mt.TImMemberInfo array = 2;
  inline int array_size() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 2;
  inline const ::mt::TImMemberInfo& array(int index) const;
  inline ::mt::TImMemberInfo* mutable_array(int index);
  inline ::mt::TImMemberInfo* add_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImMemberInfo >&
      array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImMemberInfo >*
      mutable_array();

  // @@protoc_insertion_point(class_scope:mt.TImMemberList)
 private:
  inline void set_has_arraysize();
  inline void clear_has_arraysize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TImMemberInfo > array_;
  ::google::protobuf::uint32 arraysize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImMemberList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTSearchUserInfo : public ::google::protobuf::Message {
 public:
  TMTSearchUserInfo();
  virtual ~TMTSearchUserInfo();

  TMTSearchUserInfo(const TMTSearchUserInfo& from);

  inline TMTSearchUserInfo& operator=(const TMTSearchUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTSearchUserInfo& default_instance();

  void Swap(TMTSearchUserInfo* other);

  // implements Message ----------------------------------------------

  TMTSearchUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTSearchUserInfo& from);
  void MergeFrom(const TMTSearchUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtOperateUserInfo emoperateuser = 1;
  inline bool has_emoperateuser() const;
  inline void clear_emoperateuser();
  static const int kEmoperateuserFieldNumber = 1;
  inline ::mt::EmMtOperateUserInfo emoperateuser() const;
  inline void set_emoperateuser(::mt::EmMtOperateUserInfo value);

  // optional uint32 xmppno = 2;
  inline bool has_xmppno() const;
  inline void clear_xmppno();
  static const int kXmppnoFieldNumber = 2;
  inline ::google::protobuf::uint32 xmppno() const;
  inline void set_xmppno(::google::protobuf::uint32 value);

  // optional .mt.TImMemberInfo immemberinfo = 3;
  inline bool has_immemberinfo() const;
  inline void clear_immemberinfo();
  static const int kImmemberinfoFieldNumber = 3;
  inline const ::mt::TImMemberInfo& immemberinfo() const;
  inline ::mt::TImMemberInfo* mutable_immemberinfo();
  inline ::mt::TImMemberInfo* release_immemberinfo();
  inline void set_allocated_immemberinfo(::mt::TImMemberInfo* immemberinfo);

  // @@protoc_insertion_point(class_scope:mt.TMTSearchUserInfo)
 private:
  inline void set_has_emoperateuser();
  inline void clear_has_emoperateuser();
  inline void set_has_xmppno();
  inline void clear_has_xmppno();
  inline void set_has_immemberinfo();
  inline void clear_has_immemberinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emoperateuser_;
  ::google::protobuf::uint32 xmppno_;
  ::mt::TImMemberInfo* immemberinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TMTSearchUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImMemberFullInfo : public ::google::protobuf::Message {
 public:
  TImMemberFullInfo();
  virtual ~TImMemberFullInfo();

  TImMemberFullInfo(const TImMemberFullInfo& from);

  inline TImMemberFullInfo& operator=(const TImMemberFullInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImMemberFullInfo& default_instance();

  void Swap(TImMemberFullInfo* other);

  // implements Message ----------------------------------------------

  TImMemberFullInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImMemberFullInfo& from);
  void MergeFrom(const TImMemberFullInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TImMemberInfo memberinfo = 1;
  inline bool has_memberinfo() const;
  inline void clear_memberinfo();
  static const int kMemberinfoFieldNumber = 1;
  inline const ::mt::TImMemberInfo& memberinfo() const;
  inline ::mt::TImMemberInfo* mutable_memberinfo();
  inline ::mt::TImMemberInfo* release_memberinfo();
  inline void set_allocated_memberinfo(::mt::TImMemberInfo* memberinfo);

  // optional .mt.EmMtOnlineState memberstate = 2;
  inline bool has_memberstate() const;
  inline void clear_memberstate();
  static const int kMemberstateFieldNumber = 2;
  inline ::mt::EmMtOnlineState memberstate() const;
  inline void set_memberstate(::mt::EmMtOnlineState value);

  // optional bool maxaudio = 3;
  inline bool has_maxaudio() const;
  inline void clear_maxaudio();
  static const int kMaxaudioFieldNumber = 3;
  inline bool maxaudio() const;
  inline void set_maxaudio(bool value);

  // optional bool maxvideo = 4;
  inline bool has_maxvideo() const;
  inline void clear_maxvideo();
  static const int kMaxvideoFieldNumber = 4;
  inline bool maxvideo() const;
  inline void set_maxvideo(bool value);

  // repeated .mt.TSubState mtstate = 5;
  inline int mtstate_size() const;
  inline void clear_mtstate();
  static const int kMtstateFieldNumber = 5;
  inline const ::mt::TSubState& mtstate(int index) const;
  inline ::mt::TSubState* mutable_mtstate(int index);
  inline ::mt::TSubState* add_mtstate();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TSubState >&
      mtstate() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TSubState >*
      mutable_mtstate();

  // @@protoc_insertion_point(class_scope:mt.TImMemberFullInfo)
 private:
  inline void set_has_memberinfo();
  inline void clear_has_memberinfo();
  inline void set_has_memberstate();
  inline void clear_has_memberstate();
  inline void set_has_maxaudio();
  inline void clear_has_maxaudio();
  inline void set_has_maxvideo();
  inline void clear_has_maxvideo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TImMemberInfo* memberinfo_;
  int memberstate_;
  bool maxaudio_;
  bool maxvideo_;
  ::google::protobuf::RepeatedPtrField< ::mt::TSubState > mtstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImMemberFullInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAccountManagerSystem : public ::google::protobuf::Message {
 public:
  TMTAccountManagerSystem();
  virtual ~TMTAccountManagerSystem();

  TMTAccountManagerSystem(const TMTAccountManagerSystem& from);

  inline TMTAccountManagerSystem& operator=(const TMTAccountManagerSystem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAccountManagerSystem& default_instance();

  void Swap(TMTAccountManagerSystem* other);

  // implements Message ----------------------------------------------

  TMTAccountManagerSystem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAccountManagerSystem& from);
  void MergeFrom(const TMTAccountManagerSystem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional uint32 bitmask = 3;
  inline bool has_bitmask() const;
  inline void clear_bitmask();
  static const int kBitmaskFieldNumber = 3;
  inline ::google::protobuf::uint32 bitmask() const;
  inline void set_bitmask(::google::protobuf::uint32 value);

  // optional string mobilenum = 4;
  inline bool has_mobilenum() const;
  inline void clear_mobilenum();
  static const int kMobilenumFieldNumber = 4;
  inline const ::std::string& mobilenum() const;
  inline void set_mobilenum(const ::std::string& value);
  inline void set_mobilenum(const char* value);
  inline void set_mobilenum(const char* value, size_t size);
  inline ::std::string* mutable_mobilenum();
  inline ::std::string* release_mobilenum();
  inline void set_allocated_mobilenum(::std::string* mobilenum);

  // optional string extnum = 5;
  inline bool has_extnum() const;
  inline void clear_extnum();
  static const int kExtnumFieldNumber = 5;
  inline const ::std::string& extnum() const;
  inline void set_extnum(const ::std::string& value);
  inline void set_extnum(const char* value);
  inline void set_extnum(const char* value, size_t size);
  inline ::std::string* mutable_extnum();
  inline ::std::string* release_extnum();
  inline void set_allocated_extnum(::std::string* extnum);

  // optional string seat = 6;
  inline bool has_seat() const;
  inline void clear_seat();
  static const int kSeatFieldNumber = 6;
  inline const ::std::string& seat() const;
  inline void set_seat(const ::std::string& value);
  inline void set_seat(const char* value);
  inline void set_seat(const char* value, size_t size);
  inline ::std::string* mutable_seat();
  inline ::std::string* release_seat();
  inline void set_allocated_seat(::std::string* seat);

  // optional string brief = 7;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 7;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // optional string position = 8;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 8;
  inline const ::std::string& position() const;
  inline void set_position(const ::std::string& value);
  inline void set_position(const char* value);
  inline void set_position(const char* value, size_t size);
  inline ::std::string* mutable_position();
  inline ::std::string* release_position();
  inline void set_allocated_position(::std::string* position);

  // optional bool male = 9;
  inline bool has_male() const;
  inline void clear_male();
  static const int kMaleFieldNumber = 9;
  inline bool male() const;
  inline void set_male(bool value);

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool isadding = 11;
  inline bool has_isadding() const;
  inline void clear_isadding();
  static const int kIsaddingFieldNumber = 11;
  inline bool isadding() const;
  inline void set_isadding(bool value);

  // optional string apiaddr = 12;
  inline bool has_apiaddr() const;
  inline void clear_apiaddr();
  static const int kApiaddrFieldNumber = 12;
  inline const ::std::string& apiaddr() const;
  inline void set_apiaddr(const ::std::string& value);
  inline void set_apiaddr(const char* value);
  inline void set_apiaddr(const char* value, size_t size);
  inline ::std::string* mutable_apiaddr();
  inline ::std::string* release_apiaddr();
  inline void set_allocated_apiaddr(::std::string* apiaddr);

  // optional uint32 contextid = 13;
  inline bool has_contextid() const;
  inline void clear_contextid();
  static const int kContextidFieldNumber = 13;
  inline ::google::protobuf::uint32 contextid() const;
  inline void set_contextid(::google::protobuf::uint32 value);

  // optional string email = 14;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 14;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // @@protoc_insertion_point(class_scope:mt.TMTAccountManagerSystem)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_bitmask();
  inline void clear_has_bitmask();
  inline void set_has_mobilenum();
  inline void clear_has_mobilenum();
  inline void set_has_extnum();
  inline void clear_has_extnum();
  inline void set_has_seat();
  inline void clear_has_seat();
  inline void set_has_brief();
  inline void clear_has_brief();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_male();
  inline void clear_has_male();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_isadding();
  inline void clear_has_isadding();
  inline void set_has_apiaddr();
  inline void clear_has_apiaddr();
  inline void set_has_contextid();
  inline void clear_has_contextid();
  inline void set_has_email();
  inline void clear_has_email();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;
  ::std::string* mobilenum_;
  ::std::string* extnum_;
  ::std::string* seat_;
  ::std::string* brief_;
  ::google::protobuf::uint32 bitmask_;
  bool male_;
  bool isadding_;
  ::std::string* position_;
  ::std::string* name_;
  ::std::string* apiaddr_;
  ::std::string* email_;
  ::google::protobuf::uint32 contextid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TMTAccountManagerSystem* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRestErrorInfo : public ::google::protobuf::Message {
 public:
  TRestErrorInfo();
  virtual ~TRestErrorInfo();

  TRestErrorInfo(const TRestErrorInfo& from);

  inline TRestErrorInfo& operator=(const TRestErrorInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRestErrorInfo& default_instance();

  void Swap(TRestErrorInfo* other);

  // implements Message ----------------------------------------------

  TRestErrorInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRestErrorInfo& from);
  void MergeFrom(const TRestErrorInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string errorinfo = 1;
  inline bool has_errorinfo() const;
  inline void clear_errorinfo();
  static const int kErrorinfoFieldNumber = 1;
  inline const ::std::string& errorinfo() const;
  inline void set_errorinfo(const ::std::string& value);
  inline void set_errorinfo(const char* value);
  inline void set_errorinfo(const char* value, size_t size);
  inline ::std::string* mutable_errorinfo();
  inline ::std::string* release_errorinfo();
  inline void set_allocated_errorinfo(::std::string* errorinfo);

  // optional uint32 errorid = 2;
  inline bool has_errorid() const;
  inline void clear_errorid();
  static const int kErroridFieldNumber = 2;
  inline ::google::protobuf::uint32 errorid() const;
  inline void set_errorid(::google::protobuf::uint32 value);

  // optional .mt.APIType apitype = 3;
  inline bool has_apitype() const;
  inline void clear_apitype();
  static const int kApitypeFieldNumber = 3;
  inline ::mt::APIType apitype() const;
  inline void set_apitype(::mt::APIType value);

  // optional uint32 nackeventid = 4;
  inline bool has_nackeventid() const;
  inline void clear_nackeventid();
  static const int kNackeventidFieldNumber = 4;
  inline ::google::protobuf::uint32 nackeventid() const;
  inline void set_nackeventid(::google::protobuf::uint32 value);

  // repeated uint32 params = 5;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 5;
  inline ::google::protobuf::uint32 params(int index) const;
  inline void set_params(int index, ::google::protobuf::uint32 value);
  inline void add_params(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      params() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_params();

  // @@protoc_insertion_point(class_scope:mt.TRestErrorInfo)
 private:
  inline void set_has_errorinfo();
  inline void clear_has_errorinfo();
  inline void set_has_errorid();
  inline void clear_has_errorid();
  inline void set_has_apitype();
  inline void clear_has_apitype();
  inline void set_has_nackeventid();
  inline void clear_has_nackeventid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* errorinfo_;
  ::google::protobuf::uint32 errorid_;
  int apitype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > params_;
  ::google::protobuf::uint32 nackeventid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TRestErrorInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TCacheP2PMsg : public ::google::protobuf::Message {
 public:
  TCacheP2PMsg();
  virtual ~TCacheP2PMsg();

  TCacheP2PMsg(const TCacheP2PMsg& from);

  inline TCacheP2PMsg& operator=(const TCacheP2PMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCacheP2PMsg& default_instance();

  void Swap(TCacheP2PMsg* other);

  // implements Message ----------------------------------------------

  TCacheP2PMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCacheP2PMsg& from);
  void MergeFrom(const TCacheP2PMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool used = 1;
  inline bool has_used() const;
  inline void clear_used();
  static const int kUsedFieldNumber = 1;
  inline bool used() const;
  inline void set_used(bool value);

  // optional uint32 handle = 2;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional .mt.TImP2PChatMessage data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::mt::TImP2PChatMessage& data() const;
  inline ::mt::TImP2PChatMessage* mutable_data();
  inline ::mt::TImP2PChatMessage* release_data();
  inline void set_allocated_data(::mt::TImP2PChatMessage* data);

  // optional uint32 contextId = 4;
  inline bool has_contextid() const;
  inline void clear_contextid();
  static const int kContextIdFieldNumber = 4;
  inline ::google::protobuf::uint32 contextid() const;
  inline void set_contextid(::google::protobuf::uint32 value);

  // optional uint32 session_cnt = 5;
  inline bool has_session_cnt() const;
  inline void clear_session_cnt();
  static const int kSessionCntFieldNumber = 5;
  inline ::google::protobuf::uint32 session_cnt() const;
  inline void set_session_cnt(::google::protobuf::uint32 value);

  // optional string session = 6;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 6;
  inline const ::std::string& session() const;
  inline void set_session(const ::std::string& value);
  inline void set_session(const char* value);
  inline void set_session(const char* value, size_t size);
  inline ::std::string* mutable_session();
  inline ::std::string* release_session();
  inline void set_allocated_session(::std::string* session);

  // @@protoc_insertion_point(class_scope:mt.TCacheP2PMsg)
 private:
  inline void set_has_used();
  inline void clear_has_used();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_contextid();
  inline void clear_has_contextid();
  inline void set_has_session_cnt();
  inline void clear_has_session_cnt();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool used_;
  ::google::protobuf::uint32 handle_;
  ::mt::TImP2PChatMessage* data_;
  ::google::protobuf::uint32 contextid_;
  ::google::protobuf::uint32 session_cnt_;
  ::std::string* session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TCacheP2PMsg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TCacheGroupChatMsg : public ::google::protobuf::Message {
 public:
  TCacheGroupChatMsg();
  virtual ~TCacheGroupChatMsg();

  TCacheGroupChatMsg(const TCacheGroupChatMsg& from);

  inline TCacheGroupChatMsg& operator=(const TCacheGroupChatMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCacheGroupChatMsg& default_instance();

  void Swap(TCacheGroupChatMsg* other);

  // implements Message ----------------------------------------------

  TCacheGroupChatMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCacheGroupChatMsg& from);
  void MergeFrom(const TCacheGroupChatMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool used = 1;
  inline bool has_used() const;
  inline void clear_used();
  static const int kUsedFieldNumber = 1;
  inline bool used() const;
  inline void set_used(bool value);

  // optional uint32 handle = 2;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional .mt.TImMultiChatMessage data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::mt::TImMultiChatMessage& data() const;
  inline ::mt::TImMultiChatMessage* mutable_data();
  inline ::mt::TImMultiChatMessage* release_data();
  inline void set_allocated_data(::mt::TImMultiChatMessage* data);

  // optional uint32 contextId = 4;
  inline bool has_contextid() const;
  inline void clear_contextid();
  static const int kContextIdFieldNumber = 4;
  inline ::google::protobuf::uint32 contextid() const;
  inline void set_contextid(::google::protobuf::uint32 value);

  // optional uint32 session_cnt = 5;
  inline bool has_session_cnt() const;
  inline void clear_session_cnt();
  static const int kSessionCntFieldNumber = 5;
  inline ::google::protobuf::uint32 session_cnt() const;
  inline void set_session_cnt(::google::protobuf::uint32 value);

  // optional string session = 6;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 6;
  inline const ::std::string& session() const;
  inline void set_session(const ::std::string& value);
  inline void set_session(const char* value);
  inline void set_session(const char* value, size_t size);
  inline ::std::string* mutable_session();
  inline ::std::string* release_session();
  inline void set_allocated_session(::std::string* session);

  // @@protoc_insertion_point(class_scope:mt.TCacheGroupChatMsg)
 private:
  inline void set_has_used();
  inline void clear_has_used();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_contextid();
  inline void clear_has_contextid();
  inline void set_has_session_cnt();
  inline void clear_has_session_cnt();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool used_;
  ::google::protobuf::uint32 handle_;
  ::mt::TImMultiChatMessage* data_;
  ::google::protobuf::uint32 contextid_;
  ::google::protobuf::uint32 session_cnt_;
  ::std::string* session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TCacheGroupChatMsg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImChatPicInfo : public ::google::protobuf::Message {
 public:
  TImChatPicInfo();
  virtual ~TImChatPicInfo();

  TImChatPicInfo(const TImChatPicInfo& from);

  inline TImChatPicInfo& operator=(const TImChatPicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImChatPicInfo& default_instance();

  void Swap(TImChatPicInfo* other);

  // implements Message ----------------------------------------------

  TImChatPicInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImChatPicInfo& from);
  void MergeFrom(const TImChatPicInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional string filename = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:mt.TImChatPicInfo)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImChatPicInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImFont : public ::google::protobuf::Message {
 public:
  TImFont();
  virtual ~TImFont();

  TImFont(const TImFont& from);

  inline TImFont& operator=(const TImFont& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImFont& default_instance();

  void Swap(TImFont* other);

  // implements Message ----------------------------------------------

  TImFont* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImFont& from);
  void MergeFrom(const TImFont& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 height = 1;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 1;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // optional uint32 width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 escapement = 3;
  inline bool has_escapement() const;
  inline void clear_escapement();
  static const int kEscapementFieldNumber = 3;
  inline ::google::protobuf::uint32 escapement() const;
  inline void set_escapement(::google::protobuf::uint32 value);

  // optional uint32 orientation = 4;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  inline ::google::protobuf::uint32 orientation() const;
  inline void set_orientation(::google::protobuf::uint32 value);

  // optional uint32 weight = 5;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 5;
  inline ::google::protobuf::uint32 weight() const;
  inline void set_weight(::google::protobuf::uint32 value);

  // optional bytes italic = 6;
  inline bool has_italic() const;
  inline void clear_italic();
  static const int kItalicFieldNumber = 6;
  inline const ::std::string& italic() const;
  inline void set_italic(const ::std::string& value);
  inline void set_italic(const char* value);
  inline void set_italic(const void* value, size_t size);
  inline ::std::string* mutable_italic();
  inline ::std::string* release_italic();
  inline void set_allocated_italic(::std::string* italic);

  // optional bytes underline = 7;
  inline bool has_underline() const;
  inline void clear_underline();
  static const int kUnderlineFieldNumber = 7;
  inline const ::std::string& underline() const;
  inline void set_underline(const ::std::string& value);
  inline void set_underline(const char* value);
  inline void set_underline(const void* value, size_t size);
  inline ::std::string* mutable_underline();
  inline ::std::string* release_underline();
  inline void set_allocated_underline(::std::string* underline);

  // optional bytes strikeOut = 8;
  inline bool has_strikeout() const;
  inline void clear_strikeout();
  static const int kStrikeOutFieldNumber = 8;
  inline const ::std::string& strikeout() const;
  inline void set_strikeout(const ::std::string& value);
  inline void set_strikeout(const char* value);
  inline void set_strikeout(const void* value, size_t size);
  inline ::std::string* mutable_strikeout();
  inline ::std::string* release_strikeout();
  inline void set_allocated_strikeout(::std::string* strikeout);

  // optional bytes charset = 9;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 9;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const void* value, size_t size);
  inline ::std::string* mutable_charset();
  inline ::std::string* release_charset();
  inline void set_allocated_charset(::std::string* charset);

  // optional bytes outprecision = 10;
  inline bool has_outprecision() const;
  inline void clear_outprecision();
  static const int kOutprecisionFieldNumber = 10;
  inline const ::std::string& outprecision() const;
  inline void set_outprecision(const ::std::string& value);
  inline void set_outprecision(const char* value);
  inline void set_outprecision(const void* value, size_t size);
  inline ::std::string* mutable_outprecision();
  inline ::std::string* release_outprecision();
  inline void set_allocated_outprecision(::std::string* outprecision);

  // optional bytes clipprecision = 11;
  inline bool has_clipprecision() const;
  inline void clear_clipprecision();
  static const int kClipprecisionFieldNumber = 11;
  inline const ::std::string& clipprecision() const;
  inline void set_clipprecision(const ::std::string& value);
  inline void set_clipprecision(const char* value);
  inline void set_clipprecision(const void* value, size_t size);
  inline ::std::string* mutable_clipprecision();
  inline ::std::string* release_clipprecision();
  inline void set_allocated_clipprecision(::std::string* clipprecision);

  // optional bytes quality = 12;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 12;
  inline const ::std::string& quality() const;
  inline void set_quality(const ::std::string& value);
  inline void set_quality(const char* value);
  inline void set_quality(const void* value, size_t size);
  inline ::std::string* mutable_quality();
  inline ::std::string* release_quality();
  inline void set_allocated_quality(::std::string* quality);

  // optional bytes pitchandfamily = 13;
  inline bool has_pitchandfamily() const;
  inline void clear_pitchandfamily();
  static const int kPitchandfamilyFieldNumber = 13;
  inline const ::std::string& pitchandfamily() const;
  inline void set_pitchandfamily(const ::std::string& value);
  inline void set_pitchandfamily(const char* value);
  inline void set_pitchandfamily(const void* value, size_t size);
  inline ::std::string* mutable_pitchandfamily();
  inline ::std::string* release_pitchandfamily();
  inline void set_allocated_pitchandfamily(::std::string* pitchandfamily);

  // optional string facename = 14;
  inline bool has_facename() const;
  inline void clear_facename();
  static const int kFacenameFieldNumber = 14;
  inline const ::std::string& facename() const;
  inline void set_facename(const ::std::string& value);
  inline void set_facename(const char* value);
  inline void set_facename(const char* value, size_t size);
  inline ::std::string* mutable_facename();
  inline ::std::string* release_facename();
  inline void set_allocated_facename(::std::string* facename);

  // @@protoc_insertion_point(class_scope:mt.TImFont)
 private:
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_escapement();
  inline void clear_has_escapement();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_italic();
  inline void clear_has_italic();
  inline void set_has_underline();
  inline void clear_has_underline();
  inline void set_has_strikeout();
  inline void clear_has_strikeout();
  inline void set_has_charset();
  inline void clear_has_charset();
  inline void set_has_outprecision();
  inline void clear_has_outprecision();
  inline void set_has_clipprecision();
  inline void clear_has_clipprecision();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_pitchandfamily();
  inline void clear_has_pitchandfamily();
  inline void set_has_facename();
  inline void clear_has_facename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 escapement_;
  ::google::protobuf::uint32 orientation_;
  ::std::string* italic_;
  ::std::string* underline_;
  ::std::string* strikeout_;
  ::std::string* charset_;
  ::std::string* outprecision_;
  ::std::string* clipprecision_;
  ::std::string* quality_;
  ::std::string* pitchandfamily_;
  ::std::string* facename_;
  ::google::protobuf::uint32 weight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImFont* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImChatContent : public ::google::protobuf::Message {
 public:
  TImChatContent();
  virtual ~TImChatContent();

  TImChatContent(const TImChatContent& from);

  inline TImChatContent& operator=(const TImChatContent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImChatContent& default_instance();

  void Swap(TImChatContent* other);

  // implements Message ----------------------------------------------

  TImChatContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImChatContent& from);
  void MergeFrom(const TImChatContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TImFont font = 1;
  inline bool has_font() const;
  inline void clear_font();
  static const int kFontFieldNumber = 1;
  inline const ::mt::TImFont& font() const;
  inline ::mt::TImFont* mutable_font();
  inline ::mt::TImFont* release_font();
  inline void set_allocated_font(::mt::TImFont* font);

  // optional uint32 color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // optional uint32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional bytes msgheader = 4;
  inline bool has_msgheader() const;
  inline void clear_msgheader();
  static const int kMsgheaderFieldNumber = 4;
  inline const ::std::string& msgheader() const;
  inline void set_msgheader(const ::std::string& value);
  inline void set_msgheader(const char* value);
  inline void set_msgheader(const void* value, size_t size);
  inline ::std::string* mutable_msgheader();
  inline ::std::string* release_msgheader();
  inline void set_allocated_msgheader(::std::string* msgheader);

  // optional bytes content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional .mt.EmChatType chattype = 6;
  inline bool has_chattype() const;
  inline void clear_chattype();
  static const int kChattypeFieldNumber = 6;
  inline ::mt::EmChatType chattype() const;
  inline void set_chattype(::mt::EmChatType value);

  // optional bytes piccount = 7;
  inline bool has_piccount() const;
  inline void clear_piccount();
  static const int kPiccountFieldNumber = 7;
  inline const ::std::string& piccount() const;
  inline void set_piccount(const ::std::string& value);
  inline void set_piccount(const char* value);
  inline void set_piccount(const void* value, size_t size);
  inline ::std::string* mutable_piccount();
  inline ::std::string* release_piccount();
  inline void set_allocated_piccount(::std::string* piccount);

  // repeated .mt.TImChatPicInfo picfileinfotable = 8;
  inline int picfileinfotable_size() const;
  inline void clear_picfileinfotable();
  static const int kPicfileinfotableFieldNumber = 8;
  inline const ::mt::TImChatPicInfo& picfileinfotable(int index) const;
  inline ::mt::TImChatPicInfo* mutable_picfileinfotable(int index);
  inline ::mt::TImChatPicInfo* add_picfileinfotable();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TImChatPicInfo >&
      picfileinfotable() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TImChatPicInfo >*
      mutable_picfileinfotable();

  // @@protoc_insertion_point(class_scope:mt.TImChatContent)
 private:
  inline void set_has_font();
  inline void clear_has_font();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_msgheader();
  inline void clear_has_msgheader();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_chattype();
  inline void clear_has_chattype();
  inline void set_has_piccount();
  inline void clear_has_piccount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TImFont* font_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint32 time_;
  ::std::string* msgheader_;
  ::std::string* content_;
  ::std::string* piccount_;
  ::google::protobuf::RepeatedPtrField< ::mt::TImChatPicInfo > picfileinfotable_;
  int chattype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImChatContent* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TCreateOrEnterChatroom : public ::google::protobuf::Message {
 public:
  TCreateOrEnterChatroom();
  virtual ~TCreateOrEnterChatroom();

  TCreateOrEnterChatroom(const TCreateOrEnterChatroom& from);

  inline TCreateOrEnterChatroom& operator=(const TCreateOrEnterChatroom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCreateOrEnterChatroom& default_instance();

  void Swap(TCreateOrEnterChatroom* other);

  // implements Message ----------------------------------------------

  TCreateOrEnterChatroom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCreateOrEnterChatroom& from);
  void MergeFrom(const TCreateOrEnterChatroom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app = 1;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 1;
  inline ::google::protobuf::uint32 app() const;
  inline void set_app(::google::protobuf::uint32 value);

  // optional .mt.TImMulitChatCreateInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::mt::TImMulitChatCreateInfo& info() const;
  inline ::mt::TImMulitChatCreateInfo* mutable_info();
  inline ::mt::TImMulitChatCreateInfo* release_info();
  inline void set_allocated_info(::mt::TImMulitChatCreateInfo* info);

  // optional uint32 session_cnt = 3;
  inline bool has_session_cnt() const;
  inline void clear_session_cnt();
  static const int kSessionCntFieldNumber = 3;
  inline ::google::protobuf::uint32 session_cnt() const;
  inline void set_session_cnt(::google::protobuf::uint32 value);

  // optional string session = 4;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 4;
  inline const ::std::string& session() const;
  inline void set_session(const ::std::string& value);
  inline void set_session(const char* value);
  inline void set_session(const char* value, size_t size);
  inline ::std::string* mutable_session();
  inline ::std::string* release_session();
  inline void set_allocated_session(::std::string* session);

  // @@protoc_insertion_point(class_scope:mt.TCreateOrEnterChatroom)
 private:
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_session_cnt();
  inline void clear_has_session_cnt();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TImMulitChatCreateInfo* info_;
  ::google::protobuf::uint32 app_;
  ::google::protobuf::uint32 session_cnt_;
  ::std::string* session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TCreateOrEnterChatroom* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDelayChatRoomInfo : public ::google::protobuf::Message {
 public:
  TDelayChatRoomInfo();
  virtual ~TDelayChatRoomInfo();

  TDelayChatRoomInfo(const TDelayChatRoomInfo& from);

  inline TDelayChatRoomInfo& operator=(const TDelayChatRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDelayChatRoomInfo& default_instance();

  void Swap(TDelayChatRoomInfo* other);

  // implements Message ----------------------------------------------

  TDelayChatRoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDelayChatRoomInfo& from);
  void MergeFrom(const TDelayChatRoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool used = 1;
  inline bool has_used() const;
  inline void clear_used();
  static const int kUsedFieldNumber = 1;
  inline bool used() const;
  inline void set_used(bool value);

  // optional uint32 app = 2;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 2;
  inline ::google::protobuf::uint32 app() const;
  inline void set_app(::google::protobuf::uint32 value);

  // optional uint32 room = 3;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 3;
  inline ::google::protobuf::uint32 room() const;
  inline void set_room(::google::protobuf::uint32 value);

  // optional bool invited = 4;
  inline bool has_invited() const;
  inline void clear_invited();
  static const int kInvitedFieldNumber = 4;
  inline bool invited() const;
  inline void set_invited(bool value);

  // optional .mt.TImMulitChatCreateInfo info = 5;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 5;
  inline const ::mt::TImMulitChatCreateInfo& info() const;
  inline ::mt::TImMulitChatCreateInfo* mutable_info();
  inline ::mt::TImMulitChatCreateInfo* release_info();
  inline void set_allocated_info(::mt::TImMulitChatCreateInfo* info);

  // optional uint32 session_cnt = 6;
  inline bool has_session_cnt() const;
  inline void clear_session_cnt();
  static const int kSessionCntFieldNumber = 6;
  inline ::google::protobuf::uint32 session_cnt() const;
  inline void set_session_cnt(::google::protobuf::uint32 value);

  // optional string session = 7;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 7;
  inline const ::std::string& session() const;
  inline void set_session(const ::std::string& value);
  inline void set_session(const char* value);
  inline void set_session(const char* value, size_t size);
  inline ::std::string* mutable_session();
  inline ::std::string* release_session();
  inline void set_allocated_session(::std::string* session);

  // @@protoc_insertion_point(class_scope:mt.TDelayChatRoomInfo)
 private:
  inline void set_has_used();
  inline void clear_has_used();
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_room();
  inline void clear_has_room();
  inline void set_has_invited();
  inline void clear_has_invited();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_session_cnt();
  inline void clear_has_session_cnt();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 app_;
  bool used_;
  bool invited_;
  ::google::protobuf::uint32 room_;
  ::google::protobuf::uint32 session_cnt_;
  ::mt::TImMulitChatCreateInfo* info_;
  ::std::string* session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TDelayChatRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPersistentChatroomItem : public ::google::protobuf::Message {
 public:
  TPersistentChatroomItem();
  virtual ~TPersistentChatroomItem();

  TPersistentChatroomItem(const TPersistentChatroomItem& from);

  inline TPersistentChatroomItem& operator=(const TPersistentChatroomItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPersistentChatroomItem& default_instance();

  void Swap(TPersistentChatroomItem* other);

  // implements Message ----------------------------------------------

  TPersistentChatroomItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPersistentChatroomItem& from);
  void MergeFrom(const TPersistentChatroomItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string roomid = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // optional string chatname = 2;
  inline bool has_chatname() const;
  inline void clear_chatname();
  static const int kChatnameFieldNumber = 2;
  inline const ::std::string& chatname() const;
  inline void set_chatname(const ::std::string& value);
  inline void set_chatname(const char* value);
  inline void set_chatname(const char* value, size_t size);
  inline ::std::string* mutable_chatname();
  inline ::std::string* release_chatname();
  inline void set_allocated_chatname(::std::string* chatname);

  // @@protoc_insertion_point(class_scope:mt.TPersistentChatroomItem)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_chatname();
  inline void clear_has_chatname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::std::string* chatname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TPersistentChatroomItem* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPersistentChatroomList : public ::google::protobuf::Message {
 public:
  TPersistentChatroomList();
  virtual ~TPersistentChatroomList();

  TPersistentChatroomList(const TPersistentChatroomList& from);

  inline TPersistentChatroomList& operator=(const TPersistentChatroomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPersistentChatroomList& default_instance();

  void Swap(TPersistentChatroomList* other);

  // implements Message ----------------------------------------------

  TPersistentChatroomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPersistentChatroomList& from);
  void MergeFrom(const TPersistentChatroomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 arraysize = 1;
  inline bool has_arraysize() const;
  inline void clear_arraysize();
  static const int kArraysizeFieldNumber = 1;
  inline ::google::protobuf::uint32 arraysize() const;
  inline void set_arraysize(::google::protobuf::uint32 value);

  // repeated .mt.TPersistentChatroomItem array = 2;
  inline int array_size() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 2;
  inline const ::mt::TPersistentChatroomItem& array(int index) const;
  inline ::mt::TPersistentChatroomItem* mutable_array(int index);
  inline ::mt::TPersistentChatroomItem* add_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TPersistentChatroomItem >&
      array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TPersistentChatroomItem >*
      mutable_array();

  // @@protoc_insertion_point(class_scope:mt.TPersistentChatroomList)
 private:
  inline void set_has_arraysize();
  inline void clear_has_arraysize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TPersistentChatroomItem > array_;
  ::google::protobuf::uint32 arraysize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TPersistentChatroomList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TImFriendInfo : public ::google::protobuf::Message {
 public:
  TImFriendInfo();
  virtual ~TImFriendInfo();

  TImFriendInfo(const TImFriendInfo& from);

  inline TImFriendInfo& operator=(const TImFriendInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TImFriendInfo& default_instance();

  void Swap(TImFriendInfo* other);

  // implements Message ----------------------------------------------

  TImFriendInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TImFriendInfo& from);
  void MergeFrom(const TImFriendInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string xmppno = 1;
  inline bool has_xmppno() const;
  inline void clear_xmppno();
  static const int kXmppnoFieldNumber = 1;
  inline const ::std::string& xmppno() const;
  inline void set_xmppno(const ::std::string& value);
  inline void set_xmppno(const char* value);
  inline void set_xmppno(const char* value, size_t size);
  inline ::std::string* mutable_xmppno();
  inline ::std::string* release_xmppno();
  inline void set_allocated_xmppno(::std::string* xmppno);

  // optional string jid = 2;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 2;
  inline const ::std::string& jid() const;
  inline void set_jid(const ::std::string& value);
  inline void set_jid(const char* value);
  inline void set_jid(const char* value, size_t size);
  inline ::std::string* mutable_jid();
  inline ::std::string* release_jid();
  inline void set_allocated_jid(::std::string* jid);

  // optional uint32 recordno = 3;
  inline bool has_recordno() const;
  inline void clear_recordno();
  static const int kRecordnoFieldNumber = 3;
  inline ::google::protobuf::uint32 recordno() const;
  inline void set_recordno(::google::protobuf::uint32 value);

  // optional string e164 = 4;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 4;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string h323id = 5;
  inline bool has_h323id() const;
  inline void clear_h323id();
  static const int kH323IdFieldNumber = 5;
  inline const ::std::string& h323id() const;
  inline void set_h323id(const ::std::string& value);
  inline void set_h323id(const char* value);
  inline void set_h323id(const char* value, size_t size);
  inline ::std::string* mutable_h323id();
  inline ::std::string* release_h323id();
  inline void set_allocated_h323id(::std::string* h323id);

  // optional string ip = 6;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 6;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:mt.TImFriendInfo)
 private:
  inline void set_has_xmppno();
  inline void clear_has_xmppno();
  inline void set_has_jid();
  inline void clear_has_jid();
  inline void set_has_recordno();
  inline void clear_has_recordno();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_h323id();
  inline void clear_has_h323id();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* xmppno_;
  ::std::string* jid_;
  ::std::string* e164_;
  ::std::string* h323id_;
  ::std::string* ip_;
  ::google::protobuf::uint32 recordno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structim_2eproto();
  friend void protobuf_AssignDesc_structim_2eproto();
  friend void protobuf_ShutdownFile_structim_2eproto();

  void InitAsDefaultInstance();
  static TImFriendInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// TImUserLogin

// optional uint32 ip = 1;
inline bool TImUserLogin::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImUserLogin::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImUserLogin::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImUserLogin::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TImUserLogin::ip() const {
  return ip_;
}
inline void TImUserLogin::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 2;
inline bool TImUserLogin::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImUserLogin::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImUserLogin::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImUserLogin::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TImUserLogin::port() const {
  return port_;
}
inline void TImUserLogin::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string no = 3;
inline bool TImUserLogin::has_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImUserLogin::set_has_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImUserLogin::clear_has_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImUserLogin::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TImUserLogin::no() const {
  return *no_;
}
inline void TImUserLogin::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImUserLogin::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImUserLogin::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserLogin::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TImUserLogin::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserLogin::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userpwd = 4;
inline bool TImUserLogin::has_userpwd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImUserLogin::set_has_userpwd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImUserLogin::clear_has_userpwd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImUserLogin::clear_userpwd() {
  if (userpwd_ != &::google::protobuf::internal::kEmptyString) {
    userpwd_->clear();
  }
  clear_has_userpwd();
}
inline const ::std::string& TImUserLogin::userpwd() const {
  return *userpwd_;
}
inline void TImUserLogin::set_userpwd(const ::std::string& value) {
  set_has_userpwd();
  if (userpwd_ == &::google::protobuf::internal::kEmptyString) {
    userpwd_ = new ::std::string;
  }
  userpwd_->assign(value);
}
inline void TImUserLogin::set_userpwd(const char* value) {
  set_has_userpwd();
  if (userpwd_ == &::google::protobuf::internal::kEmptyString) {
    userpwd_ = new ::std::string;
  }
  userpwd_->assign(value);
}
inline void TImUserLogin::set_userpwd(const char* value, size_t size) {
  set_has_userpwd();
  if (userpwd_ == &::google::protobuf::internal::kEmptyString) {
    userpwd_ = new ::std::string;
  }
  userpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserLogin::mutable_userpwd() {
  set_has_userpwd();
  if (userpwd_ == &::google::protobuf::internal::kEmptyString) {
    userpwd_ = new ::std::string;
  }
  return userpwd_;
}
inline ::std::string* TImUserLogin::release_userpwd() {
  clear_has_userpwd();
  if (userpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userpwd_;
    userpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserLogin::set_allocated_userpwd(::std::string* userpwd) {
  if (userpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete userpwd_;
  }
  if (userpwd) {
    set_has_userpwd();
    userpwd_ = userpwd;
  } else {
    clear_has_userpwd();
    userpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 pwdlen = 5;
inline bool TImUserLogin::has_pwdlen() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImUserLogin::set_has_pwdlen() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImUserLogin::clear_has_pwdlen() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImUserLogin::clear_pwdlen() {
  pwdlen_ = 0u;
  clear_has_pwdlen();
}
inline ::google::protobuf::uint32 TImUserLogin::pwdlen() const {
  return pwdlen_;
}
inline void TImUserLogin::set_pwdlen(::google::protobuf::uint32 value) {
  set_has_pwdlen();
  pwdlen_ = value;
}

// optional bool fileshareenable = 6;
inline bool TImUserLogin::has_fileshareenable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TImUserLogin::set_has_fileshareenable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TImUserLogin::clear_has_fileshareenable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TImUserLogin::clear_fileshareenable() {
  fileshareenable_ = false;
  clear_has_fileshareenable();
}
inline bool TImUserLogin::fileshareenable() const {
  return fileshareenable_;
}
inline void TImUserLogin::set_fileshareenable(bool value) {
  set_has_fileshareenable();
  fileshareenable_ = value;
}

// optional string stunaddr = 7;
inline bool TImUserLogin::has_stunaddr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TImUserLogin::set_has_stunaddr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TImUserLogin::clear_has_stunaddr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TImUserLogin::clear_stunaddr() {
  if (stunaddr_ != &::google::protobuf::internal::kEmptyString) {
    stunaddr_->clear();
  }
  clear_has_stunaddr();
}
inline const ::std::string& TImUserLogin::stunaddr() const {
  return *stunaddr_;
}
inline void TImUserLogin::set_stunaddr(const ::std::string& value) {
  set_has_stunaddr();
  if (stunaddr_ == &::google::protobuf::internal::kEmptyString) {
    stunaddr_ = new ::std::string;
  }
  stunaddr_->assign(value);
}
inline void TImUserLogin::set_stunaddr(const char* value) {
  set_has_stunaddr();
  if (stunaddr_ == &::google::protobuf::internal::kEmptyString) {
    stunaddr_ = new ::std::string;
  }
  stunaddr_->assign(value);
}
inline void TImUserLogin::set_stunaddr(const char* value, size_t size) {
  set_has_stunaddr();
  if (stunaddr_ == &::google::protobuf::internal::kEmptyString) {
    stunaddr_ = new ::std::string;
  }
  stunaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserLogin::mutable_stunaddr() {
  set_has_stunaddr();
  if (stunaddr_ == &::google::protobuf::internal::kEmptyString) {
    stunaddr_ = new ::std::string;
  }
  return stunaddr_;
}
inline ::std::string* TImUserLogin::release_stunaddr() {
  clear_has_stunaddr();
  if (stunaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stunaddr_;
    stunaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserLogin::set_allocated_stunaddr(::std::string* stunaddr) {
  if (stunaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete stunaddr_;
  }
  if (stunaddr) {
    set_has_stunaddr();
    stunaddr_ = stunaddr;
  } else {
    clear_has_stunaddr();
    stunaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 stunport = 8;
inline bool TImUserLogin::has_stunport() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TImUserLogin::set_has_stunport() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TImUserLogin::clear_has_stunport() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TImUserLogin::clear_stunport() {
  stunport_ = 0u;
  clear_has_stunport();
}
inline ::google::protobuf::uint32 TImUserLogin::stunport() const {
  return stunport_;
}
inline void TImUserLogin::set_stunport(::google::protobuf::uint32 value) {
  set_has_stunport();
  stunport_ = value;
}

// optional string defaultsavedir = 9;
inline bool TImUserLogin::has_defaultsavedir() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TImUserLogin::set_has_defaultsavedir() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TImUserLogin::clear_has_defaultsavedir() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TImUserLogin::clear_defaultsavedir() {
  if (defaultsavedir_ != &::google::protobuf::internal::kEmptyString) {
    defaultsavedir_->clear();
  }
  clear_has_defaultsavedir();
}
inline const ::std::string& TImUserLogin::defaultsavedir() const {
  return *defaultsavedir_;
}
inline void TImUserLogin::set_defaultsavedir(const ::std::string& value) {
  set_has_defaultsavedir();
  if (defaultsavedir_ == &::google::protobuf::internal::kEmptyString) {
    defaultsavedir_ = new ::std::string;
  }
  defaultsavedir_->assign(value);
}
inline void TImUserLogin::set_defaultsavedir(const char* value) {
  set_has_defaultsavedir();
  if (defaultsavedir_ == &::google::protobuf::internal::kEmptyString) {
    defaultsavedir_ = new ::std::string;
  }
  defaultsavedir_->assign(value);
}
inline void TImUserLogin::set_defaultsavedir(const char* value, size_t size) {
  set_has_defaultsavedir();
  if (defaultsavedir_ == &::google::protobuf::internal::kEmptyString) {
    defaultsavedir_ = new ::std::string;
  }
  defaultsavedir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserLogin::mutable_defaultsavedir() {
  set_has_defaultsavedir();
  if (defaultsavedir_ == &::google::protobuf::internal::kEmptyString) {
    defaultsavedir_ = new ::std::string;
  }
  return defaultsavedir_;
}
inline ::std::string* TImUserLogin::release_defaultsavedir() {
  clear_has_defaultsavedir();
  if (defaultsavedir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defaultsavedir_;
    defaultsavedir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserLogin::set_allocated_defaultsavedir(::std::string* defaultsavedir) {
  if (defaultsavedir_ != &::google::protobuf::internal::kEmptyString) {
    delete defaultsavedir_;
  }
  if (defaultsavedir) {
    set_has_defaultsavedir();
    defaultsavedir_ = defaultsavedir;
  } else {
    clear_has_defaultsavedir();
    defaultsavedir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string enterprisename = 10;
inline bool TImUserLogin::has_enterprisename() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TImUserLogin::set_has_enterprisename() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TImUserLogin::clear_has_enterprisename() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TImUserLogin::clear_enterprisename() {
  if (enterprisename_ != &::google::protobuf::internal::kEmptyString) {
    enterprisename_->clear();
  }
  clear_has_enterprisename();
}
inline const ::std::string& TImUserLogin::enterprisename() const {
  return *enterprisename_;
}
inline void TImUserLogin::set_enterprisename(const ::std::string& value) {
  set_has_enterprisename();
  if (enterprisename_ == &::google::protobuf::internal::kEmptyString) {
    enterprisename_ = new ::std::string;
  }
  enterprisename_->assign(value);
}
inline void TImUserLogin::set_enterprisename(const char* value) {
  set_has_enterprisename();
  if (enterprisename_ == &::google::protobuf::internal::kEmptyString) {
    enterprisename_ = new ::std::string;
  }
  enterprisename_->assign(value);
}
inline void TImUserLogin::set_enterprisename(const char* value, size_t size) {
  set_has_enterprisename();
  if (enterprisename_ == &::google::protobuf::internal::kEmptyString) {
    enterprisename_ = new ::std::string;
  }
  enterprisename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserLogin::mutable_enterprisename() {
  set_has_enterprisename();
  if (enterprisename_ == &::google::protobuf::internal::kEmptyString) {
    enterprisename_ = new ::std::string;
  }
  return enterprisename_;
}
inline ::std::string* TImUserLogin::release_enterprisename() {
  clear_has_enterprisename();
  if (enterprisename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enterprisename_;
    enterprisename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserLogin::set_allocated_enterprisename(::std::string* enterprisename) {
  if (enterprisename_ != &::google::protobuf::internal::kEmptyString) {
    delete enterprisename_;
  }
  if (enterprisename) {
    set_has_enterprisename();
    enterprisename_ = enterprisename;
  } else {
    clear_has_enterprisename();
    enterprisename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool audiocapability = 11;
inline bool TImUserLogin::has_audiocapability() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TImUserLogin::set_has_audiocapability() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TImUserLogin::clear_has_audiocapability() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TImUserLogin::clear_audiocapability() {
  audiocapability_ = false;
  clear_has_audiocapability();
}
inline bool TImUserLogin::audiocapability() const {
  return audiocapability_;
}
inline void TImUserLogin::set_audiocapability(bool value) {
  set_has_audiocapability();
  audiocapability_ = value;
}

// optional bool videocapability = 12;
inline bool TImUserLogin::has_videocapability() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TImUserLogin::set_has_videocapability() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TImUserLogin::clear_has_videocapability() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TImUserLogin::clear_videocapability() {
  videocapability_ = false;
  clear_has_videocapability();
}
inline bool TImUserLogin::videocapability() const {
  return videocapability_;
}
inline void TImUserLogin::set_videocapability(bool value) {
  set_has_videocapability();
  videocapability_ = value;
}

// optional string picsavedir = 13;
inline bool TImUserLogin::has_picsavedir() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TImUserLogin::set_has_picsavedir() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TImUserLogin::clear_has_picsavedir() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TImUserLogin::clear_picsavedir() {
  if (picsavedir_ != &::google::protobuf::internal::kEmptyString) {
    picsavedir_->clear();
  }
  clear_has_picsavedir();
}
inline const ::std::string& TImUserLogin::picsavedir() const {
  return *picsavedir_;
}
inline void TImUserLogin::set_picsavedir(const ::std::string& value) {
  set_has_picsavedir();
  if (picsavedir_ == &::google::protobuf::internal::kEmptyString) {
    picsavedir_ = new ::std::string;
  }
  picsavedir_->assign(value);
}
inline void TImUserLogin::set_picsavedir(const char* value) {
  set_has_picsavedir();
  if (picsavedir_ == &::google::protobuf::internal::kEmptyString) {
    picsavedir_ = new ::std::string;
  }
  picsavedir_->assign(value);
}
inline void TImUserLogin::set_picsavedir(const char* value, size_t size) {
  set_has_picsavedir();
  if (picsavedir_ == &::google::protobuf::internal::kEmptyString) {
    picsavedir_ = new ::std::string;
  }
  picsavedir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserLogin::mutable_picsavedir() {
  set_has_picsavedir();
  if (picsavedir_ == &::google::protobuf::internal::kEmptyString) {
    picsavedir_ = new ::std::string;
  }
  return picsavedir_;
}
inline ::std::string* TImUserLogin::release_picsavedir() {
  clear_has_picsavedir();
  if (picsavedir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picsavedir_;
    picsavedir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserLogin::set_allocated_picsavedir(::std::string* picsavedir) {
  if (picsavedir_ != &::google::protobuf::internal::kEmptyString) {
    delete picsavedir_;
  }
  if (picsavedir) {
    set_has_picsavedir();
    picsavedir_ = picsavedir;
  } else {
    clear_has_picsavedir();
    picsavedir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool binstant = 14;
inline bool TImUserLogin::has_binstant() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TImUserLogin::set_has_binstant() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TImUserLogin::clear_has_binstant() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TImUserLogin::clear_binstant() {
  binstant_ = false;
  clear_has_binstant();
}
inline bool TImUserLogin::binstant() const {
  return binstant_;
}
inline void TImUserLogin::set_binstant(bool value) {
  set_has_binstant();
  binstant_ = value;
}

// optional string resource = 15;
inline bool TImUserLogin::has_resource() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TImUserLogin::set_has_resource() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TImUserLogin::clear_has_resource() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TImUserLogin::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& TImUserLogin::resource() const {
  return *resource_;
}
inline void TImUserLogin::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void TImUserLogin::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void TImUserLogin::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserLogin::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* TImUserLogin::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserLogin::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool usesock5 = 16;
inline bool TImUserLogin::has_usesock5() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TImUserLogin::set_has_usesock5() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TImUserLogin::clear_has_usesock5() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TImUserLogin::clear_usesock5() {
  usesock5_ = false;
  clear_has_usesock5();
}
inline bool TImUserLogin::usesock5() const {
  return usesock5_;
}
inline void TImUserLogin::set_usesock5(bool value) {
  set_has_usesock5();
  usesock5_ = value;
}

// optional string sck5addr = 17;
inline bool TImUserLogin::has_sck5addr() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TImUserLogin::set_has_sck5addr() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TImUserLogin::clear_has_sck5addr() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TImUserLogin::clear_sck5addr() {
  if (sck5addr_ != &::google::protobuf::internal::kEmptyString) {
    sck5addr_->clear();
  }
  clear_has_sck5addr();
}
inline const ::std::string& TImUserLogin::sck5addr() const {
  return *sck5addr_;
}
inline void TImUserLogin::set_sck5addr(const ::std::string& value) {
  set_has_sck5addr();
  if (sck5addr_ == &::google::protobuf::internal::kEmptyString) {
    sck5addr_ = new ::std::string;
  }
  sck5addr_->assign(value);
}
inline void TImUserLogin::set_sck5addr(const char* value) {
  set_has_sck5addr();
  if (sck5addr_ == &::google::protobuf::internal::kEmptyString) {
    sck5addr_ = new ::std::string;
  }
  sck5addr_->assign(value);
}
inline void TImUserLogin::set_sck5addr(const char* value, size_t size) {
  set_has_sck5addr();
  if (sck5addr_ == &::google::protobuf::internal::kEmptyString) {
    sck5addr_ = new ::std::string;
  }
  sck5addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserLogin::mutable_sck5addr() {
  set_has_sck5addr();
  if (sck5addr_ == &::google::protobuf::internal::kEmptyString) {
    sck5addr_ = new ::std::string;
  }
  return sck5addr_;
}
inline ::std::string* TImUserLogin::release_sck5addr() {
  clear_has_sck5addr();
  if (sck5addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sck5addr_;
    sck5addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserLogin::set_allocated_sck5addr(::std::string* sck5addr) {
  if (sck5addr_ != &::google::protobuf::internal::kEmptyString) {
    delete sck5addr_;
  }
  if (sck5addr) {
    set_has_sck5addr();
    sck5addr_ = sck5addr;
  } else {
    clear_has_sck5addr();
    sck5addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sock5port = 18;
inline bool TImUserLogin::has_sock5port() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TImUserLogin::set_has_sock5port() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TImUserLogin::clear_has_sock5port() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TImUserLogin::clear_sock5port() {
  sock5port_ = 0u;
  clear_has_sock5port();
}
inline ::google::protobuf::uint32 TImUserLogin::sock5port() const {
  return sock5port_;
}
inline void TImUserLogin::set_sock5port(::google::protobuf::uint32 value) {
  set_has_sock5port();
  sock5port_ = value;
}

// optional string sock5username = 19;
inline bool TImUserLogin::has_sock5username() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TImUserLogin::set_has_sock5username() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TImUserLogin::clear_has_sock5username() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TImUserLogin::clear_sock5username() {
  if (sock5username_ != &::google::protobuf::internal::kEmptyString) {
    sock5username_->clear();
  }
  clear_has_sock5username();
}
inline const ::std::string& TImUserLogin::sock5username() const {
  return *sock5username_;
}
inline void TImUserLogin::set_sock5username(const ::std::string& value) {
  set_has_sock5username();
  if (sock5username_ == &::google::protobuf::internal::kEmptyString) {
    sock5username_ = new ::std::string;
  }
  sock5username_->assign(value);
}
inline void TImUserLogin::set_sock5username(const char* value) {
  set_has_sock5username();
  if (sock5username_ == &::google::protobuf::internal::kEmptyString) {
    sock5username_ = new ::std::string;
  }
  sock5username_->assign(value);
}
inline void TImUserLogin::set_sock5username(const char* value, size_t size) {
  set_has_sock5username();
  if (sock5username_ == &::google::protobuf::internal::kEmptyString) {
    sock5username_ = new ::std::string;
  }
  sock5username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserLogin::mutable_sock5username() {
  set_has_sock5username();
  if (sock5username_ == &::google::protobuf::internal::kEmptyString) {
    sock5username_ = new ::std::string;
  }
  return sock5username_;
}
inline ::std::string* TImUserLogin::release_sock5username() {
  clear_has_sock5username();
  if (sock5username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sock5username_;
    sock5username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserLogin::set_allocated_sock5username(::std::string* sock5username) {
  if (sock5username_ != &::google::protobuf::internal::kEmptyString) {
    delete sock5username_;
  }
  if (sock5username) {
    set_has_sock5username();
    sock5username_ = sock5username;
  } else {
    clear_has_sock5username();
    sock5username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sock5password = 20;
inline bool TImUserLogin::has_sock5password() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TImUserLogin::set_has_sock5password() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TImUserLogin::clear_has_sock5password() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TImUserLogin::clear_sock5password() {
  if (sock5password_ != &::google::protobuf::internal::kEmptyString) {
    sock5password_->clear();
  }
  clear_has_sock5password();
}
inline const ::std::string& TImUserLogin::sock5password() const {
  return *sock5password_;
}
inline void TImUserLogin::set_sock5password(const ::std::string& value) {
  set_has_sock5password();
  if (sock5password_ == &::google::protobuf::internal::kEmptyString) {
    sock5password_ = new ::std::string;
  }
  sock5password_->assign(value);
}
inline void TImUserLogin::set_sock5password(const char* value) {
  set_has_sock5password();
  if (sock5password_ == &::google::protobuf::internal::kEmptyString) {
    sock5password_ = new ::std::string;
  }
  sock5password_->assign(value);
}
inline void TImUserLogin::set_sock5password(const char* value, size_t size) {
  set_has_sock5password();
  if (sock5password_ == &::google::protobuf::internal::kEmptyString) {
    sock5password_ = new ::std::string;
  }
  sock5password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserLogin::mutable_sock5password() {
  set_has_sock5password();
  if (sock5password_ == &::google::protobuf::internal::kEmptyString) {
    sock5password_ = new ::std::string;
  }
  return sock5password_;
}
inline ::std::string* TImUserLogin::release_sock5password() {
  clear_has_sock5password();
  if (sock5password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sock5password_;
    sock5password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserLogin::set_allocated_sock5password(::std::string* sock5password) {
  if (sock5password_ != &::google::protobuf::internal::kEmptyString) {
    delete sock5password_;
  }
  if (sock5password) {
    set_has_sock5password();
    sock5password_ = sock5password;
  } else {
    clear_has_sock5password();
    sock5password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string configpath = 21;
inline bool TImUserLogin::has_configpath() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TImUserLogin::set_has_configpath() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TImUserLogin::clear_has_configpath() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TImUserLogin::clear_configpath() {
  if (configpath_ != &::google::protobuf::internal::kEmptyString) {
    configpath_->clear();
  }
  clear_has_configpath();
}
inline const ::std::string& TImUserLogin::configpath() const {
  return *configpath_;
}
inline void TImUserLogin::set_configpath(const ::std::string& value) {
  set_has_configpath();
  if (configpath_ == &::google::protobuf::internal::kEmptyString) {
    configpath_ = new ::std::string;
  }
  configpath_->assign(value);
}
inline void TImUserLogin::set_configpath(const char* value) {
  set_has_configpath();
  if (configpath_ == &::google::protobuf::internal::kEmptyString) {
    configpath_ = new ::std::string;
  }
  configpath_->assign(value);
}
inline void TImUserLogin::set_configpath(const char* value, size_t size) {
  set_has_configpath();
  if (configpath_ == &::google::protobuf::internal::kEmptyString) {
    configpath_ = new ::std::string;
  }
  configpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserLogin::mutable_configpath() {
  set_has_configpath();
  if (configpath_ == &::google::protobuf::internal::kEmptyString) {
    configpath_ = new ::std::string;
  }
  return configpath_;
}
inline ::std::string* TImUserLogin::release_configpath() {
  clear_has_configpath();
  if (configpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = configpath_;
    configpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserLogin::set_allocated_configpath(::std::string* configpath) {
  if (configpath_ != &::google::protobuf::internal::kEmptyString) {
    delete configpath_;
  }
  if (configpath) {
    set_has_configpath();
    configpath_ = configpath;
  } else {
    clear_has_configpath();
    configpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool compression = 22;
inline bool TImUserLogin::has_compression() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TImUserLogin::set_has_compression() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TImUserLogin::clear_has_compression() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TImUserLogin::clear_compression() {
  compression_ = false;
  clear_has_compression();
}
inline bool TImUserLogin::compression() const {
  return compression_;
}
inline void TImUserLogin::set_compression(bool value) {
  set_has_compression();
  compression_ = value;
}

// -------------------------------------------------------------------

// TImSelfDefInfo

// optional string no = 1;
inline bool TImSelfDefInfo::has_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImSelfDefInfo::set_has_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImSelfDefInfo::clear_has_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImSelfDefInfo::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TImSelfDefInfo::no() const {
  return *no_;
}
inline void TImSelfDefInfo::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImSelfDefInfo::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImSelfDefInfo::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImSelfDefInfo::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TImSelfDefInfo::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImSelfDefInfo::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nickname = 2;
inline bool TImSelfDefInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImSelfDefInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImSelfDefInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImSelfDefInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& TImSelfDefInfo::nickname() const {
  return *nickname_;
}
inline void TImSelfDefInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void TImSelfDefInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void TImSelfDefInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImSelfDefInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* TImSelfDefInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImSelfDefInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 pictureindex = 3;
inline bool TImSelfDefInfo::has_pictureindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImSelfDefInfo::set_has_pictureindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImSelfDefInfo::clear_has_pictureindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImSelfDefInfo::clear_pictureindex() {
  pictureindex_ = 0u;
  clear_has_pictureindex();
}
inline ::google::protobuf::uint32 TImSelfDefInfo::pictureindex() const {
  return pictureindex_;
}
inline void TImSelfDefInfo::set_pictureindex(::google::protobuf::uint32 value) {
  set_has_pictureindex();
  pictureindex_ = value;
}

// optional bool customepic = 4;
inline bool TImSelfDefInfo::has_customepic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImSelfDefInfo::set_has_customepic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImSelfDefInfo::clear_has_customepic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImSelfDefInfo::clear_customepic() {
  customepic_ = false;
  clear_has_customepic();
}
inline bool TImSelfDefInfo::customepic() const {
  return customepic_;
}
inline void TImSelfDefInfo::set_customepic(bool value) {
  set_has_customepic();
  customepic_ = value;
}

// -------------------------------------------------------------------

// TImSelfDefPic

// optional uint32 custompicsize = 1;
inline bool TImSelfDefPic::has_custompicsize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImSelfDefPic::set_has_custompicsize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImSelfDefPic::clear_has_custompicsize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImSelfDefPic::clear_custompicsize() {
  custompicsize_ = 0u;
  clear_has_custompicsize();
}
inline ::google::protobuf::uint32 TImSelfDefPic::custompicsize() const {
  return custompicsize_;
}
inline void TImSelfDefPic::set_custompicsize(::google::protobuf::uint32 value) {
  set_has_custompicsize();
  custompicsize_ = value;
}

// optional string custompicdata = 2;
inline bool TImSelfDefPic::has_custompicdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImSelfDefPic::set_has_custompicdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImSelfDefPic::clear_has_custompicdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImSelfDefPic::clear_custompicdata() {
  if (custompicdata_ != &::google::protobuf::internal::kEmptyString) {
    custompicdata_->clear();
  }
  clear_has_custompicdata();
}
inline const ::std::string& TImSelfDefPic::custompicdata() const {
  return *custompicdata_;
}
inline void TImSelfDefPic::set_custompicdata(const ::std::string& value) {
  set_has_custompicdata();
  if (custompicdata_ == &::google::protobuf::internal::kEmptyString) {
    custompicdata_ = new ::std::string;
  }
  custompicdata_->assign(value);
}
inline void TImSelfDefPic::set_custompicdata(const char* value) {
  set_has_custompicdata();
  if (custompicdata_ == &::google::protobuf::internal::kEmptyString) {
    custompicdata_ = new ::std::string;
  }
  custompicdata_->assign(value);
}
inline void TImSelfDefPic::set_custompicdata(const char* value, size_t size) {
  set_has_custompicdata();
  if (custompicdata_ == &::google::protobuf::internal::kEmptyString) {
    custompicdata_ = new ::std::string;
  }
  custompicdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImSelfDefPic::mutable_custompicdata() {
  set_has_custompicdata();
  if (custompicdata_ == &::google::protobuf::internal::kEmptyString) {
    custompicdata_ = new ::std::string;
  }
  return custompicdata_;
}
inline ::std::string* TImSelfDefPic::release_custompicdata() {
  clear_has_custompicdata();
  if (custompicdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custompicdata_;
    custompicdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImSelfDefPic::set_allocated_custompicdata(::std::string* custompicdata) {
  if (custompicdata_ != &::google::protobuf::internal::kEmptyString) {
    delete custompicdata_;
  }
  if (custompicdata) {
    set_has_custompicdata();
    custompicdata_ = custompicdata;
  } else {
    clear_has_custompicdata();
    custompicdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImSelfDefList

// optional uint32 arraysize = 1;
inline bool TImSelfDefList::has_arraysize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImSelfDefList::set_has_arraysize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImSelfDefList::clear_has_arraysize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImSelfDefList::clear_arraysize() {
  arraysize_ = 0u;
  clear_has_arraysize();
}
inline ::google::protobuf::uint32 TImSelfDefList::arraysize() const {
  return arraysize_;
}
inline void TImSelfDefList::set_arraysize(::google::protobuf::uint32 value) {
  set_has_arraysize();
  arraysize_ = value;
}

// repeated .mt.TImSelfDefInfo array = 2;
inline int TImSelfDefList::array_size() const {
  return array_.size();
}
inline void TImSelfDefList::clear_array() {
  array_.Clear();
}
inline const ::mt::TImSelfDefInfo& TImSelfDefList::array(int index) const {
  return array_.Get(index);
}
inline ::mt::TImSelfDefInfo* TImSelfDefList::mutable_array(int index) {
  return array_.Mutable(index);
}
inline ::mt::TImSelfDefInfo* TImSelfDefList::add_array() {
  return array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImSelfDefInfo >&
TImSelfDefList::array() const {
  return array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImSelfDefInfo >*
TImSelfDefList::mutable_array() {
  return &array_;
}

// repeated .mt.TImSelfDefPic pic = 3;
inline int TImSelfDefList::pic_size() const {
  return pic_.size();
}
inline void TImSelfDefList::clear_pic() {
  pic_.Clear();
}
inline const ::mt::TImSelfDefPic& TImSelfDefList::pic(int index) const {
  return pic_.Get(index);
}
inline ::mt::TImSelfDefPic* TImSelfDefList::mutable_pic(int index) {
  return pic_.Mutable(index);
}
inline ::mt::TImSelfDefPic* TImSelfDefList::add_pic() {
  return pic_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImSelfDefPic >&
TImSelfDefList::pic() const {
  return pic_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImSelfDefPic >*
TImSelfDefList::mutable_pic() {
  return &pic_;
}

// -------------------------------------------------------------------

// TImGroupInfo

// optional string groupsn = 1;
inline bool TImGroupInfo::has_groupsn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImGroupInfo::set_has_groupsn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImGroupInfo::clear_has_groupsn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImGroupInfo::clear_groupsn() {
  if (groupsn_ != &::google::protobuf::internal::kEmptyString) {
    groupsn_->clear();
  }
  clear_has_groupsn();
}
inline const ::std::string& TImGroupInfo::groupsn() const {
  return *groupsn_;
}
inline void TImGroupInfo::set_groupsn(const ::std::string& value) {
  set_has_groupsn();
  if (groupsn_ == &::google::protobuf::internal::kEmptyString) {
    groupsn_ = new ::std::string;
  }
  groupsn_->assign(value);
}
inline void TImGroupInfo::set_groupsn(const char* value) {
  set_has_groupsn();
  if (groupsn_ == &::google::protobuf::internal::kEmptyString) {
    groupsn_ = new ::std::string;
  }
  groupsn_->assign(value);
}
inline void TImGroupInfo::set_groupsn(const char* value, size_t size) {
  set_has_groupsn();
  if (groupsn_ == &::google::protobuf::internal::kEmptyString) {
    groupsn_ = new ::std::string;
  }
  groupsn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImGroupInfo::mutable_groupsn() {
  set_has_groupsn();
  if (groupsn_ == &::google::protobuf::internal::kEmptyString) {
    groupsn_ = new ::std::string;
  }
  return groupsn_;
}
inline ::std::string* TImGroupInfo::release_groupsn() {
  clear_has_groupsn();
  if (groupsn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupsn_;
    groupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImGroupInfo::set_allocated_groupsn(::std::string* groupsn) {
  if (groupsn_ != &::google::protobuf::internal::kEmptyString) {
    delete groupsn_;
  }
  if (groupsn) {
    set_has_groupsn();
    groupsn_ = groupsn;
  } else {
    clear_has_groupsn();
    groupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string groupname = 2;
inline bool TImGroupInfo::has_groupname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImGroupInfo::set_has_groupname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImGroupInfo::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImGroupInfo::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& TImGroupInfo::groupname() const {
  return *groupname_;
}
inline void TImGroupInfo::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void TImGroupInfo::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void TImGroupInfo::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImGroupInfo::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* TImGroupInfo::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImGroupInfo::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string parentgroupSn = 3;
inline bool TImGroupInfo::has_parentgroupsn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImGroupInfo::set_has_parentgroupsn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImGroupInfo::clear_has_parentgroupsn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImGroupInfo::clear_parentgroupsn() {
  if (parentgroupsn_ != &::google::protobuf::internal::kEmptyString) {
    parentgroupsn_->clear();
  }
  clear_has_parentgroupsn();
}
inline const ::std::string& TImGroupInfo::parentgroupsn() const {
  return *parentgroupsn_;
}
inline void TImGroupInfo::set_parentgroupsn(const ::std::string& value) {
  set_has_parentgroupsn();
  if (parentgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    parentgroupsn_ = new ::std::string;
  }
  parentgroupsn_->assign(value);
}
inline void TImGroupInfo::set_parentgroupsn(const char* value) {
  set_has_parentgroupsn();
  if (parentgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    parentgroupsn_ = new ::std::string;
  }
  parentgroupsn_->assign(value);
}
inline void TImGroupInfo::set_parentgroupsn(const char* value, size_t size) {
  set_has_parentgroupsn();
  if (parentgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    parentgroupsn_ = new ::std::string;
  }
  parentgroupsn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImGroupInfo::mutable_parentgroupsn() {
  set_has_parentgroupsn();
  if (parentgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    parentgroupsn_ = new ::std::string;
  }
  return parentgroupsn_;
}
inline ::std::string* TImGroupInfo::release_parentgroupsn() {
  clear_has_parentgroupsn();
  if (parentgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parentgroupsn_;
    parentgroupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImGroupInfo::set_allocated_parentgroupsn(::std::string* parentgroupsn) {
  if (parentgroupsn_ != &::google::protobuf::internal::kEmptyString) {
    delete parentgroupsn_;
  }
  if (parentgroupsn) {
    set_has_parentgroupsn();
    parentgroupsn_ = parentgroupsn;
  } else {
    clear_has_parentgroupsn();
    parentgroupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 grouplevel = 4;
inline bool TImGroupInfo::has_grouplevel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImGroupInfo::set_has_grouplevel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImGroupInfo::clear_has_grouplevel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImGroupInfo::clear_grouplevel() {
  grouplevel_ = 0u;
  clear_has_grouplevel();
}
inline ::google::protobuf::uint32 TImGroupInfo::grouplevel() const {
  return grouplevel_;
}
inline void TImGroupInfo::set_grouplevel(::google::protobuf::uint32 value) {
  set_has_grouplevel();
  grouplevel_ = value;
}

// -------------------------------------------------------------------

// TImGroupList

// optional uint32 arraysize = 1;
inline bool TImGroupList::has_arraysize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImGroupList::set_has_arraysize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImGroupList::clear_has_arraysize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImGroupList::clear_arraysize() {
  arraysize_ = 0u;
  clear_has_arraysize();
}
inline ::google::protobuf::uint32 TImGroupList::arraysize() const {
  return arraysize_;
}
inline void TImGroupList::set_arraysize(::google::protobuf::uint32 value) {
  set_has_arraysize();
  arraysize_ = value;
}

// repeated .mt.TImGroupInfo array = 2;
inline int TImGroupList::array_size() const {
  return array_.size();
}
inline void TImGroupList::clear_array() {
  array_.Clear();
}
inline const ::mt::TImGroupInfo& TImGroupList::array(int index) const {
  return array_.Get(index);
}
inline ::mt::TImGroupInfo* TImGroupList::mutable_array(int index) {
  return array_.Mutable(index);
}
inline ::mt::TImGroupInfo* TImGroupList::add_array() {
  return array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImGroupInfo >&
TImGroupList::array() const {
  return array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImGroupInfo >*
TImGroupList::mutable_array() {
  return &array_;
}

// -------------------------------------------------------------------

// TImSn

// optional string sn = 1;
inline bool TImSn::has_sn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImSn::set_has_sn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImSn::clear_has_sn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImSn::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& TImSn::sn() const {
  return *sn_;
}
inline void TImSn::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void TImSn::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void TImSn::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImSn::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* TImSn::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImSn::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImMoveMember

// optional string membersn = 1;
inline bool TImMoveMember::has_membersn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImMoveMember::set_has_membersn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImMoveMember::clear_has_membersn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImMoveMember::clear_membersn() {
  if (membersn_ != &::google::protobuf::internal::kEmptyString) {
    membersn_->clear();
  }
  clear_has_membersn();
}
inline const ::std::string& TImMoveMember::membersn() const {
  return *membersn_;
}
inline void TImMoveMember::set_membersn(const ::std::string& value) {
  set_has_membersn();
  if (membersn_ == &::google::protobuf::internal::kEmptyString) {
    membersn_ = new ::std::string;
  }
  membersn_->assign(value);
}
inline void TImMoveMember::set_membersn(const char* value) {
  set_has_membersn();
  if (membersn_ == &::google::protobuf::internal::kEmptyString) {
    membersn_ = new ::std::string;
  }
  membersn_->assign(value);
}
inline void TImMoveMember::set_membersn(const char* value, size_t size) {
  set_has_membersn();
  if (membersn_ == &::google::protobuf::internal::kEmptyString) {
    membersn_ = new ::std::string;
  }
  membersn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMoveMember::mutable_membersn() {
  set_has_membersn();
  if (membersn_ == &::google::protobuf::internal::kEmptyString) {
    membersn_ = new ::std::string;
  }
  return membersn_;
}
inline ::std::string* TImMoveMember::release_membersn() {
  clear_has_membersn();
  if (membersn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = membersn_;
    membersn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMoveMember::set_allocated_membersn(::std::string* membersn) {
  if (membersn_ != &::google::protobuf::internal::kEmptyString) {
    delete membersn_;
  }
  if (membersn) {
    set_has_membersn();
    membersn_ = membersn;
  } else {
    clear_has_membersn();
    membersn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string oldgroupsn = 2;
inline bool TImMoveMember::has_oldgroupsn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImMoveMember::set_has_oldgroupsn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImMoveMember::clear_has_oldgroupsn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImMoveMember::clear_oldgroupsn() {
  if (oldgroupsn_ != &::google::protobuf::internal::kEmptyString) {
    oldgroupsn_->clear();
  }
  clear_has_oldgroupsn();
}
inline const ::std::string& TImMoveMember::oldgroupsn() const {
  return *oldgroupsn_;
}
inline void TImMoveMember::set_oldgroupsn(const ::std::string& value) {
  set_has_oldgroupsn();
  if (oldgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    oldgroupsn_ = new ::std::string;
  }
  oldgroupsn_->assign(value);
}
inline void TImMoveMember::set_oldgroupsn(const char* value) {
  set_has_oldgroupsn();
  if (oldgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    oldgroupsn_ = new ::std::string;
  }
  oldgroupsn_->assign(value);
}
inline void TImMoveMember::set_oldgroupsn(const char* value, size_t size) {
  set_has_oldgroupsn();
  if (oldgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    oldgroupsn_ = new ::std::string;
  }
  oldgroupsn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMoveMember::mutable_oldgroupsn() {
  set_has_oldgroupsn();
  if (oldgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    oldgroupsn_ = new ::std::string;
  }
  return oldgroupsn_;
}
inline ::std::string* TImMoveMember::release_oldgroupsn() {
  clear_has_oldgroupsn();
  if (oldgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldgroupsn_;
    oldgroupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMoveMember::set_allocated_oldgroupsn(::std::string* oldgroupsn) {
  if (oldgroupsn_ != &::google::protobuf::internal::kEmptyString) {
    delete oldgroupsn_;
  }
  if (oldgroupsn) {
    set_has_oldgroupsn();
    oldgroupsn_ = oldgroupsn;
  } else {
    clear_has_oldgroupsn();
    oldgroupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string newgroupsn = 3;
inline bool TImMoveMember::has_newgroupsn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImMoveMember::set_has_newgroupsn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImMoveMember::clear_has_newgroupsn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImMoveMember::clear_newgroupsn() {
  if (newgroupsn_ != &::google::protobuf::internal::kEmptyString) {
    newgroupsn_->clear();
  }
  clear_has_newgroupsn();
}
inline const ::std::string& TImMoveMember::newgroupsn() const {
  return *newgroupsn_;
}
inline void TImMoveMember::set_newgroupsn(const ::std::string& value) {
  set_has_newgroupsn();
  if (newgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    newgroupsn_ = new ::std::string;
  }
  newgroupsn_->assign(value);
}
inline void TImMoveMember::set_newgroupsn(const char* value) {
  set_has_newgroupsn();
  if (newgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    newgroupsn_ = new ::std::string;
  }
  newgroupsn_->assign(value);
}
inline void TImMoveMember::set_newgroupsn(const char* value, size_t size) {
  set_has_newgroupsn();
  if (newgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    newgroupsn_ = new ::std::string;
  }
  newgroupsn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMoveMember::mutable_newgroupsn() {
  set_has_newgroupsn();
  if (newgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    newgroupsn_ = new ::std::string;
  }
  return newgroupsn_;
}
inline ::std::string* TImMoveMember::release_newgroupsn() {
  clear_has_newgroupsn();
  if (newgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newgroupsn_;
    newgroupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMoveMember::set_allocated_newgroupsn(::std::string* newgroupsn) {
  if (newgroupsn_ != &::google::protobuf::internal::kEmptyString) {
    delete newgroupsn_;
  }
  if (newgroupsn) {
    set_has_newgroupsn();
    newgroupsn_ = newgroupsn;
  } else {
    clear_has_newgroupsn();
    newgroupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImUserState

// optional string no = 1;
inline bool TImUserState::has_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImUserState::set_has_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImUserState::clear_has_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImUserState::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TImUserState::no() const {
  return *no_;
}
inline void TImUserState::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImUserState::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImUserState::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserState::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TImUserState::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserState::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtOnlineState state = 2;
inline bool TImUserState::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImUserState::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImUserState::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImUserState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::mt::EmMtOnlineState TImUserState::state() const {
  return static_cast< ::mt::EmMtOnlineState >(state_);
}
inline void TImUserState::set_state(::mt::EmMtOnlineState value) {
  assert(::mt::EmMtOnlineState_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// TImSetUserState

// optional string no = 1;
inline bool TImSetUserState::has_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImSetUserState::set_has_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImSetUserState::clear_has_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImSetUserState::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TImSetUserState::no() const {
  return *no_;
}
inline void TImSetUserState::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImSetUserState::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImSetUserState::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImSetUserState::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TImSetUserState::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImSetUserState::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtOnlineState state = 2;
inline bool TImSetUserState::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImSetUserState::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImSetUserState::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImSetUserState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::mt::EmMtOnlineState TImSetUserState::state() const {
  return static_cast< ::mt::EmMtOnlineState >(state_);
}
inline void TImSetUserState::set_state(::mt::EmMtOnlineState value) {
  assert(::mt::EmMtOnlineState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional bool statevalid = 3;
inline bool TImSetUserState::has_statevalid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImSetUserState::set_has_statevalid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImSetUserState::clear_has_statevalid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImSetUserState::clear_statevalid() {
  statevalid_ = false;
  clear_has_statevalid();
}
inline bool TImSetUserState::statevalid() const {
  return statevalid_;
}
inline void TImSetUserState::set_statevalid(bool value) {
  set_has_statevalid();
  statevalid_ = value;
}

// optional bool gkconnected = 4;
inline bool TImSetUserState::has_gkconnected() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImSetUserState::set_has_gkconnected() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImSetUserState::clear_has_gkconnected() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImSetUserState::clear_gkconnected() {
  gkconnected_ = false;
  clear_has_gkconnected();
}
inline bool TImSetUserState::gkconnected() const {
  return gkconnected_;
}
inline void TImSetUserState::set_gkconnected(bool value) {
  set_has_gkconnected();
  gkconnected_ = value;
}

// optional bool gkconnectedvalid = 5;
inline bool TImSetUserState::has_gkconnectedvalid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImSetUserState::set_has_gkconnectedvalid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImSetUserState::clear_has_gkconnectedvalid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImSetUserState::clear_gkconnectedvalid() {
  gkconnectedvalid_ = false;
  clear_has_gkconnectedvalid();
}
inline bool TImSetUserState::gkconnectedvalid() const {
  return gkconnectedvalid_;
}
inline void TImSetUserState::set_gkconnectedvalid(bool value) {
  set_has_gkconnectedvalid();
  gkconnectedvalid_ = value;
}

// -------------------------------------------------------------------

// TDeviceOnlineState

// optional string no = 1;
inline bool TDeviceOnlineState::has_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDeviceOnlineState::set_has_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDeviceOnlineState::clear_has_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDeviceOnlineState::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TDeviceOnlineState::no() const {
  return *no_;
}
inline void TDeviceOnlineState::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TDeviceOnlineState::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TDeviceOnlineState::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDeviceOnlineState::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TDeviceOnlineState::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDeviceOnlineState::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtImTerminalType devicetype = 2;
inline bool TDeviceOnlineState::has_devicetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDeviceOnlineState::set_has_devicetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDeviceOnlineState::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDeviceOnlineState::clear_devicetype() {
  devicetype_ = 0;
  clear_has_devicetype();
}
inline ::mt::EmMtImTerminalType TDeviceOnlineState::devicetype() const {
  return static_cast< ::mt::EmMtImTerminalType >(devicetype_);
}
inline void TDeviceOnlineState::set_devicetype(::mt::EmMtImTerminalType value) {
  assert(::mt::EmMtImTerminalType_IsValid(value));
  set_has_devicetype();
  devicetype_ = value;
}

// optional .mt.EmMtOnlineState state = 3;
inline bool TDeviceOnlineState::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TDeviceOnlineState::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TDeviceOnlineState::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TDeviceOnlineState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::mt::EmMtOnlineState TDeviceOnlineState::state() const {
  return static_cast< ::mt::EmMtOnlineState >(state_);
}
inline void TDeviceOnlineState::set_state(::mt::EmMtOnlineState value) {
  assert(::mt::EmMtOnlineState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .mt.EmMtOnlineState maxstate = 4;
inline bool TDeviceOnlineState::has_maxstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TDeviceOnlineState::set_has_maxstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TDeviceOnlineState::clear_has_maxstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TDeviceOnlineState::clear_maxstate() {
  maxstate_ = 0;
  clear_has_maxstate();
}
inline ::mt::EmMtOnlineState TDeviceOnlineState::maxstate() const {
  return static_cast< ::mt::EmMtOnlineState >(maxstate_);
}
inline void TDeviceOnlineState::set_maxstate(::mt::EmMtOnlineState value) {
  assert(::mt::EmMtOnlineState_IsValid(value));
  set_has_maxstate();
  maxstate_ = value;
}

// optional bool self = 5;
inline bool TDeviceOnlineState::has_self() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TDeviceOnlineState::set_has_self() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TDeviceOnlineState::clear_has_self() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TDeviceOnlineState::clear_self() {
  self_ = false;
  clear_has_self();
}
inline bool TDeviceOnlineState::self() const {
  return self_;
}
inline void TDeviceOnlineState::set_self(bool value) {
  set_has_self();
  self_ = value;
}

// optional bool first = 6;
inline bool TDeviceOnlineState::has_first() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TDeviceOnlineState::set_has_first() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TDeviceOnlineState::clear_has_first() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TDeviceOnlineState::clear_first() {
  first_ = false;
  clear_has_first();
}
inline bool TDeviceOnlineState::first() const {
  return first_;
}
inline void TDeviceOnlineState::set_first(bool value) {
  set_has_first();
  first_ = value;
}

// optional bool fileshare = 7;
inline bool TDeviceOnlineState::has_fileshare() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TDeviceOnlineState::set_has_fileshare() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TDeviceOnlineState::clear_has_fileshare() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TDeviceOnlineState::clear_fileshare() {
  fileshare_ = false;
  clear_has_fileshare();
}
inline bool TDeviceOnlineState::fileshare() const {
  return fileshare_;
}
inline void TDeviceOnlineState::set_fileshare(bool value) {
  set_has_fileshare();
  fileshare_ = value;
}

// optional bool audiocapability = 8;
inline bool TDeviceOnlineState::has_audiocapability() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TDeviceOnlineState::set_has_audiocapability() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TDeviceOnlineState::clear_has_audiocapability() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TDeviceOnlineState::clear_audiocapability() {
  audiocapability_ = false;
  clear_has_audiocapability();
}
inline bool TDeviceOnlineState::audiocapability() const {
  return audiocapability_;
}
inline void TDeviceOnlineState::set_audiocapability(bool value) {
  set_has_audiocapability();
  audiocapability_ = value;
}

// optional bool videocapability = 9;
inline bool TDeviceOnlineState::has_videocapability() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TDeviceOnlineState::set_has_videocapability() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TDeviceOnlineState::clear_has_videocapability() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TDeviceOnlineState::clear_videocapability() {
  videocapability_ = false;
  clear_has_videocapability();
}
inline bool TDeviceOnlineState::videocapability() const {
  return videocapability_;
}
inline void TDeviceOnlineState::set_videocapability(bool value) {
  set_has_videocapability();
  videocapability_ = value;
}

// optional bool gkconnected = 10;
inline bool TDeviceOnlineState::has_gkconnected() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TDeviceOnlineState::set_has_gkconnected() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TDeviceOnlineState::clear_has_gkconnected() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TDeviceOnlineState::clear_gkconnected() {
  gkconnected_ = false;
  clear_has_gkconnected();
}
inline bool TDeviceOnlineState::gkconnected() const {
  return gkconnected_;
}
inline void TDeviceOnlineState::set_gkconnected(bool value) {
  set_has_gkconnected();
  gkconnected_ = value;
}

// optional bool maxaudio = 11;
inline bool TDeviceOnlineState::has_maxaudio() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TDeviceOnlineState::set_has_maxaudio() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TDeviceOnlineState::clear_has_maxaudio() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TDeviceOnlineState::clear_maxaudio() {
  maxaudio_ = false;
  clear_has_maxaudio();
}
inline bool TDeviceOnlineState::maxaudio() const {
  return maxaudio_;
}
inline void TDeviceOnlineState::set_maxaudio(bool value) {
  set_has_maxaudio();
  maxaudio_ = value;
}

// optional bool maxvideo = 12;
inline bool TDeviceOnlineState::has_maxvideo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TDeviceOnlineState::set_has_maxvideo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TDeviceOnlineState::clear_has_maxvideo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TDeviceOnlineState::clear_maxvideo() {
  maxvideo_ = false;
  clear_has_maxvideo();
}
inline bool TDeviceOnlineState::maxvideo() const {
  return maxvideo_;
}
inline void TDeviceOnlineState::set_maxvideo(bool value) {
  set_has_maxvideo();
  maxvideo_ = value;
}

// optional bool loginbeforeme = 13;
inline bool TDeviceOnlineState::has_loginbeforeme() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TDeviceOnlineState::set_has_loginbeforeme() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TDeviceOnlineState::clear_has_loginbeforeme() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TDeviceOnlineState::clear_loginbeforeme() {
  loginbeforeme_ = false;
  clear_has_loginbeforeme();
}
inline bool TDeviceOnlineState::loginbeforeme() const {
  return loginbeforeme_;
}
inline void TDeviceOnlineState::set_loginbeforeme(bool value) {
  set_has_loginbeforeme();
  loginbeforeme_ = value;
}

// -------------------------------------------------------------------

// TImUserStateList

// optional uint32 arraysize = 1;
inline bool TImUserStateList::has_arraysize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImUserStateList::set_has_arraysize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImUserStateList::clear_has_arraysize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImUserStateList::clear_arraysize() {
  arraysize_ = 0u;
  clear_has_arraysize();
}
inline ::google::protobuf::uint32 TImUserStateList::arraysize() const {
  return arraysize_;
}
inline void TImUserStateList::set_arraysize(::google::protobuf::uint32 value) {
  set_has_arraysize();
  arraysize_ = value;
}

// repeated .mt.TImUserState array = 2;
inline int TImUserStateList::array_size() const {
  return array_.size();
}
inline void TImUserStateList::clear_array() {
  array_.Clear();
}
inline const ::mt::TImUserState& TImUserStateList::array(int index) const {
  return array_.Get(index);
}
inline ::mt::TImUserState* TImUserStateList::mutable_array(int index) {
  return array_.Mutable(index);
}
inline ::mt::TImUserState* TImUserStateList::add_array() {
  return array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImUserState >&
TImUserStateList::array() const {
  return array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImUserState >*
TImUserStateList::mutable_array() {
  return &array_;
}

// -------------------------------------------------------------------

// TSubState

// optional .mt.EmMtImTerminalType emtype = 1;
inline bool TSubState::has_emtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSubState::set_has_emtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSubState::clear_has_emtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSubState::clear_emtype() {
  emtype_ = 0;
  clear_has_emtype();
}
inline ::mt::EmMtImTerminalType TSubState::emtype() const {
  return static_cast< ::mt::EmMtImTerminalType >(emtype_);
}
inline void TSubState::set_emtype(::mt::EmMtImTerminalType value) {
  assert(::mt::EmMtImTerminalType_IsValid(value));
  set_has_emtype();
  emtype_ = value;
}

// optional .mt.EmMtOnlineState emState = 2;
inline bool TSubState::has_emstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TSubState::set_has_emstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TSubState::clear_has_emstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TSubState::clear_emstate() {
  emstate_ = 0;
  clear_has_emstate();
}
inline ::mt::EmMtOnlineState TSubState::emstate() const {
  return static_cast< ::mt::EmMtOnlineState >(emstate_);
}
inline void TSubState::set_emstate(::mt::EmMtOnlineState value) {
  assert(::mt::EmMtOnlineState_IsValid(value));
  set_has_emstate();
  emstate_ = value;
}

// optional bool baudiocapability = 3;
inline bool TSubState::has_baudiocapability() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TSubState::set_has_baudiocapability() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TSubState::clear_has_baudiocapability() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TSubState::clear_baudiocapability() {
  baudiocapability_ = false;
  clear_has_baudiocapability();
}
inline bool TSubState::baudiocapability() const {
  return baudiocapability_;
}
inline void TSubState::set_baudiocapability(bool value) {
  set_has_baudiocapability();
  baudiocapability_ = value;
}

// optional bool bvideocapability = 4;
inline bool TSubState::has_bvideocapability() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TSubState::set_has_bvideocapability() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TSubState::clear_has_bvideocapability() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TSubState::clear_bvideocapability() {
  bvideocapability_ = false;
  clear_has_bvideocapability();
}
inline bool TSubState::bvideocapability() const {
  return bvideocapability_;
}
inline void TSubState::set_bvideocapability(bool value) {
  set_has_bvideocapability();
  bvideocapability_ = value;
}

// optional bool bgkconnected = 5;
inline bool TSubState::has_bgkconnected() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TSubState::set_has_bgkconnected() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TSubState::clear_has_bgkconnected() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TSubState::clear_bgkconnected() {
  bgkconnected_ = false;
  clear_has_bgkconnected();
}
inline bool TSubState::bgkconnected() const {
  return bgkconnected_;
}
inline void TSubState::set_bgkconnected(bool value) {
  set_has_bgkconnected();
  bgkconnected_ = value;
}

// -------------------------------------------------------------------

// TImUserStateEx

// optional string no = 1;
inline bool TImUserStateEx::has_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImUserStateEx::set_has_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImUserStateEx::clear_has_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImUserStateEx::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TImUserStateEx::no() const {
  return *no_;
}
inline void TImUserStateEx::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImUserStateEx::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImUserStateEx::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImUserStateEx::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TImUserStateEx::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImUserStateEx::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtOnlineState state = 2;
inline bool TImUserStateEx::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImUserStateEx::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImUserStateEx::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImUserStateEx::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::mt::EmMtOnlineState TImUserStateEx::state() const {
  return static_cast< ::mt::EmMtOnlineState >(state_);
}
inline void TImUserStateEx::set_state(::mt::EmMtOnlineState value) {
  assert(::mt::EmMtOnlineState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional bool maxaudio = 3;
inline bool TImUserStateEx::has_maxaudio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImUserStateEx::set_has_maxaudio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImUserStateEx::clear_has_maxaudio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImUserStateEx::clear_maxaudio() {
  maxaudio_ = false;
  clear_has_maxaudio();
}
inline bool TImUserStateEx::maxaudio() const {
  return maxaudio_;
}
inline void TImUserStateEx::set_maxaudio(bool value) {
  set_has_maxaudio();
  maxaudio_ = value;
}

// optional bool maxvideo = 4;
inline bool TImUserStateEx::has_maxvideo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImUserStateEx::set_has_maxvideo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImUserStateEx::clear_has_maxvideo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImUserStateEx::clear_maxvideo() {
  maxvideo_ = false;
  clear_has_maxvideo();
}
inline bool TImUserStateEx::maxvideo() const {
  return maxvideo_;
}
inline void TImUserStateEx::set_maxvideo(bool value) {
  set_has_maxvideo();
  maxvideo_ = value;
}

// repeated .mt.TSubState mtstate = 5;
inline int TImUserStateEx::mtstate_size() const {
  return mtstate_.size();
}
inline void TImUserStateEx::clear_mtstate() {
  mtstate_.Clear();
}
inline const ::mt::TSubState& TImUserStateEx::mtstate(int index) const {
  return mtstate_.Get(index);
}
inline ::mt::TSubState* TImUserStateEx::mutable_mtstate(int index) {
  return mtstate_.Mutable(index);
}
inline ::mt::TSubState* TImUserStateEx::add_mtstate() {
  return mtstate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TSubState >&
TImUserStateEx::mtstate() const {
  return mtstate_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TSubState >*
TImUserStateEx::mutable_mtstate() {
  return &mtstate_;
}

// -------------------------------------------------------------------

// TImUserStateListEx

// optional uint32 arraysize = 1;
inline bool TImUserStateListEx::has_arraysize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImUserStateListEx::set_has_arraysize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImUserStateListEx::clear_has_arraysize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImUserStateListEx::clear_arraysize() {
  arraysize_ = 0u;
  clear_has_arraysize();
}
inline ::google::protobuf::uint32 TImUserStateListEx::arraysize() const {
  return arraysize_;
}
inline void TImUserStateListEx::set_arraysize(::google::protobuf::uint32 value) {
  set_has_arraysize();
  arraysize_ = value;
}

// repeated .mt.TImUserStateEx array = 2;
inline int TImUserStateListEx::array_size() const {
  return array_.size();
}
inline void TImUserStateListEx::clear_array() {
  array_.Clear();
}
inline const ::mt::TImUserStateEx& TImUserStateListEx::array(int index) const {
  return array_.Get(index);
}
inline ::mt::TImUserStateEx* TImUserStateListEx::mutable_array(int index) {
  return array_.Mutable(index);
}
inline ::mt::TImUserStateEx* TImUserStateListEx::add_array() {
  return array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImUserStateEx >&
TImUserStateListEx::array() const {
  return array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImUserStateEx >*
TImUserStateListEx::mutable_array() {
  return &array_;
}

// -------------------------------------------------------------------

// TImChatBuf

// optional uint32 msglen = 1;
inline bool TImChatBuf::has_msglen() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImChatBuf::set_has_msglen() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImChatBuf::clear_has_msglen() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImChatBuf::clear_msglen() {
  msglen_ = 0u;
  clear_has_msglen();
}
inline ::google::protobuf::uint32 TImChatBuf::msglen() const {
  return msglen_;
}
inline void TImChatBuf::set_msglen(::google::protobuf::uint32 value) {
  set_has_msglen();
  msglen_ = value;
}

// optional bytes mgsbody = 2;
inline bool TImChatBuf::has_mgsbody() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImChatBuf::set_has_mgsbody() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImChatBuf::clear_has_mgsbody() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImChatBuf::clear_mgsbody() {
  if (mgsbody_ != &::google::protobuf::internal::kEmptyString) {
    mgsbody_->clear();
  }
  clear_has_mgsbody();
}
inline const ::std::string& TImChatBuf::mgsbody() const {
  return *mgsbody_;
}
inline void TImChatBuf::set_mgsbody(const ::std::string& value) {
  set_has_mgsbody();
  if (mgsbody_ == &::google::protobuf::internal::kEmptyString) {
    mgsbody_ = new ::std::string;
  }
  mgsbody_->assign(value);
}
inline void TImChatBuf::set_mgsbody(const char* value) {
  set_has_mgsbody();
  if (mgsbody_ == &::google::protobuf::internal::kEmptyString) {
    mgsbody_ = new ::std::string;
  }
  mgsbody_->assign(value);
}
inline void TImChatBuf::set_mgsbody(const void* value, size_t size) {
  set_has_mgsbody();
  if (mgsbody_ == &::google::protobuf::internal::kEmptyString) {
    mgsbody_ = new ::std::string;
  }
  mgsbody_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImChatBuf::mutable_mgsbody() {
  set_has_mgsbody();
  if (mgsbody_ == &::google::protobuf::internal::kEmptyString) {
    mgsbody_ = new ::std::string;
  }
  return mgsbody_;
}
inline ::std::string* TImChatBuf::release_mgsbody() {
  clear_has_mgsbody();
  if (mgsbody_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mgsbody_;
    mgsbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImChatBuf::set_allocated_mgsbody(::std::string* mgsbody) {
  if (mgsbody_ != &::google::protobuf::internal::kEmptyString) {
    delete mgsbody_;
  }
  if (mgsbody) {
    set_has_mgsbody();
    mgsbody_ = mgsbody;
  } else {
    clear_has_mgsbody();
    mgsbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImP2PChatMessage

// optional string dstno = 1;
inline bool TImP2PChatMessage::has_dstno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImP2PChatMessage::set_has_dstno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImP2PChatMessage::clear_has_dstno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImP2PChatMessage::clear_dstno() {
  if (dstno_ != &::google::protobuf::internal::kEmptyString) {
    dstno_->clear();
  }
  clear_has_dstno();
}
inline const ::std::string& TImP2PChatMessage::dstno() const {
  return *dstno_;
}
inline void TImP2PChatMessage::set_dstno(const ::std::string& value) {
  set_has_dstno();
  if (dstno_ == &::google::protobuf::internal::kEmptyString) {
    dstno_ = new ::std::string;
  }
  dstno_->assign(value);
}
inline void TImP2PChatMessage::set_dstno(const char* value) {
  set_has_dstno();
  if (dstno_ == &::google::protobuf::internal::kEmptyString) {
    dstno_ = new ::std::string;
  }
  dstno_->assign(value);
}
inline void TImP2PChatMessage::set_dstno(const char* value, size_t size) {
  set_has_dstno();
  if (dstno_ == &::google::protobuf::internal::kEmptyString) {
    dstno_ = new ::std::string;
  }
  dstno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImP2PChatMessage::mutable_dstno() {
  set_has_dstno();
  if (dstno_ == &::google::protobuf::internal::kEmptyString) {
    dstno_ = new ::std::string;
  }
  return dstno_;
}
inline ::std::string* TImP2PChatMessage::release_dstno() {
  clear_has_dstno();
  if (dstno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dstno_;
    dstno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImP2PChatMessage::set_allocated_dstno(::std::string* dstno) {
  if (dstno_ != &::google::protobuf::internal::kEmptyString) {
    delete dstno_;
  }
  if (dstno) {
    set_has_dstno();
    dstno_ = dstno;
  } else {
    clear_has_dstno();
    dstno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srcno = 2;
inline bool TImP2PChatMessage::has_srcno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImP2PChatMessage::set_has_srcno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImP2PChatMessage::clear_has_srcno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImP2PChatMessage::clear_srcno() {
  if (srcno_ != &::google::protobuf::internal::kEmptyString) {
    srcno_->clear();
  }
  clear_has_srcno();
}
inline const ::std::string& TImP2PChatMessage::srcno() const {
  return *srcno_;
}
inline void TImP2PChatMessage::set_srcno(const ::std::string& value) {
  set_has_srcno();
  if (srcno_ == &::google::protobuf::internal::kEmptyString) {
    srcno_ = new ::std::string;
  }
  srcno_->assign(value);
}
inline void TImP2PChatMessage::set_srcno(const char* value) {
  set_has_srcno();
  if (srcno_ == &::google::protobuf::internal::kEmptyString) {
    srcno_ = new ::std::string;
  }
  srcno_->assign(value);
}
inline void TImP2PChatMessage::set_srcno(const char* value, size_t size) {
  set_has_srcno();
  if (srcno_ == &::google::protobuf::internal::kEmptyString) {
    srcno_ = new ::std::string;
  }
  srcno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImP2PChatMessage::mutable_srcno() {
  set_has_srcno();
  if (srcno_ == &::google::protobuf::internal::kEmptyString) {
    srcno_ = new ::std::string;
  }
  return srcno_;
}
inline ::std::string* TImP2PChatMessage::release_srcno() {
  clear_has_srcno();
  if (srcno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcno_;
    srcno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImP2PChatMessage::set_allocated_srcno(::std::string* srcno) {
  if (srcno_ != &::google::protobuf::internal::kEmptyString) {
    delete srcno_;
  }
  if (srcno) {
    set_has_srcno();
    srcno_ = srcno;
  } else {
    clear_has_srcno();
    srcno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtImTerminalType mttype = 3;
inline bool TImP2PChatMessage::has_mttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImP2PChatMessage::set_has_mttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImP2PChatMessage::clear_has_mttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImP2PChatMessage::clear_mttype() {
  mttype_ = 0;
  clear_has_mttype();
}
inline ::mt::EmMtImTerminalType TImP2PChatMessage::mttype() const {
  return static_cast< ::mt::EmMtImTerminalType >(mttype_);
}
inline void TImP2PChatMessage::set_mttype(::mt::EmMtImTerminalType value) {
  assert(::mt::EmMtImTerminalType_IsValid(value));
  set_has_mttype();
  mttype_ = value;
}

// optional uint32 contextid = 4;
inline bool TImP2PChatMessage::has_contextid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImP2PChatMessage::set_has_contextid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImP2PChatMessage::clear_has_contextid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImP2PChatMessage::clear_contextid() {
  contextid_ = 0u;
  clear_has_contextid();
}
inline ::google::protobuf::uint32 TImP2PChatMessage::contextid() const {
  return contextid_;
}
inline void TImP2PChatMessage::set_contextid(::google::protobuf::uint32 value) {
  set_has_contextid();
  contextid_ = value;
}

// optional .mt.TImChatBuf messagebuf = 5;
inline bool TImP2PChatMessage::has_messagebuf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImP2PChatMessage::set_has_messagebuf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImP2PChatMessage::clear_has_messagebuf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImP2PChatMessage::clear_messagebuf() {
  if (messagebuf_ != NULL) messagebuf_->::mt::TImChatBuf::Clear();
  clear_has_messagebuf();
}
inline const ::mt::TImChatBuf& TImP2PChatMessage::messagebuf() const {
  return messagebuf_ != NULL ? *messagebuf_ : *default_instance_->messagebuf_;
}
inline ::mt::TImChatBuf* TImP2PChatMessage::mutable_messagebuf() {
  set_has_messagebuf();
  if (messagebuf_ == NULL) messagebuf_ = new ::mt::TImChatBuf;
  return messagebuf_;
}
inline ::mt::TImChatBuf* TImP2PChatMessage::release_messagebuf() {
  clear_has_messagebuf();
  ::mt::TImChatBuf* temp = messagebuf_;
  messagebuf_ = NULL;
  return temp;
}
inline void TImP2PChatMessage::set_allocated_messagebuf(::mt::TImChatBuf* messagebuf) {
  delete messagebuf_;
  messagebuf_ = messagebuf;
  if (messagebuf) {
    set_has_messagebuf();
  } else {
    clear_has_messagebuf();
  }
}

// optional string msgid = 6;
inline bool TImP2PChatMessage::has_msgid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TImP2PChatMessage::set_has_msgid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TImP2PChatMessage::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TImP2PChatMessage::clear_msgid() {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    msgid_->clear();
  }
  clear_has_msgid();
}
inline const ::std::string& TImP2PChatMessage::msgid() const {
  return *msgid_;
}
inline void TImP2PChatMessage::set_msgid(const ::std::string& value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void TImP2PChatMessage::set_msgid(const char* value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void TImP2PChatMessage::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImP2PChatMessage::mutable_msgid() {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  return msgid_;
}
inline ::std::string* TImP2PChatMessage::release_msgid() {
  clear_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgid_;
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImP2PChatMessage::set_allocated_msgid(::std::string* msgid) {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    delete msgid_;
  }
  if (msgid) {
    set_has_msgid();
    msgid_ = msgid;
  } else {
    clear_has_msgid();
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImNO

// optional string no = 1;
inline bool TImNO::has_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImNO::set_has_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImNO::clear_has_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImNO::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TImNO::no() const {
  return *no_;
}
inline void TImNO::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImNO::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImNO::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImNO::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TImNO::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImNO::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImNOList

// optional uint32 arraysize = 1;
inline bool TImNOList::has_arraysize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImNOList::set_has_arraysize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImNOList::clear_has_arraysize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImNOList::clear_arraysize() {
  arraysize_ = 0u;
  clear_has_arraysize();
}
inline ::google::protobuf::uint32 TImNOList::arraysize() const {
  return arraysize_;
}
inline void TImNOList::set_arraysize(::google::protobuf::uint32 value) {
  set_has_arraysize();
  arraysize_ = value;
}

// repeated .mt.TImNO array = 2;
inline int TImNOList::array_size() const {
  return array_.size();
}
inline void TImNOList::clear_array() {
  array_.Clear();
}
inline const ::mt::TImNO& TImNOList::array(int index) const {
  return array_.Get(index);
}
inline ::mt::TImNO* TImNOList::mutable_array(int index) {
  return array_.Mutable(index);
}
inline ::mt::TImNO* TImNOList::add_array() {
  return array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImNO >&
TImNOList::array() const {
  return array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImNO >*
TImNOList::mutable_array() {
  return &array_;
}

// -------------------------------------------------------------------

// TBatchAddContactsItem

// optional string memberno = 1;
inline bool TBatchAddContactsItem::has_memberno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TBatchAddContactsItem::set_has_memberno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TBatchAddContactsItem::clear_has_memberno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TBatchAddContactsItem::clear_memberno() {
  if (memberno_ != &::google::protobuf::internal::kEmptyString) {
    memberno_->clear();
  }
  clear_has_memberno();
}
inline const ::std::string& TBatchAddContactsItem::memberno() const {
  return *memberno_;
}
inline void TBatchAddContactsItem::set_memberno(const ::std::string& value) {
  set_has_memberno();
  if (memberno_ == &::google::protobuf::internal::kEmptyString) {
    memberno_ = new ::std::string;
  }
  memberno_->assign(value);
}
inline void TBatchAddContactsItem::set_memberno(const char* value) {
  set_has_memberno();
  if (memberno_ == &::google::protobuf::internal::kEmptyString) {
    memberno_ = new ::std::string;
  }
  memberno_->assign(value);
}
inline void TBatchAddContactsItem::set_memberno(const char* value, size_t size) {
  set_has_memberno();
  if (memberno_ == &::google::protobuf::internal::kEmptyString) {
    memberno_ = new ::std::string;
  }
  memberno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TBatchAddContactsItem::mutable_memberno() {
  set_has_memberno();
  if (memberno_ == &::google::protobuf::internal::kEmptyString) {
    memberno_ = new ::std::string;
  }
  return memberno_;
}
inline ::std::string* TBatchAddContactsItem::release_memberno() {
  clear_has_memberno();
  if (memberno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = memberno_;
    memberno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TBatchAddContactsItem::set_allocated_memberno(::std::string* memberno) {
  if (memberno_ != &::google::protobuf::internal::kEmptyString) {
    delete memberno_;
  }
  if (memberno) {
    set_has_memberno();
    memberno_ = memberno;
  } else {
    clear_has_memberno();
    memberno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string markname = 2;
inline bool TBatchAddContactsItem::has_markname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TBatchAddContactsItem::set_has_markname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TBatchAddContactsItem::clear_has_markname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TBatchAddContactsItem::clear_markname() {
  if (markname_ != &::google::protobuf::internal::kEmptyString) {
    markname_->clear();
  }
  clear_has_markname();
}
inline const ::std::string& TBatchAddContactsItem::markname() const {
  return *markname_;
}
inline void TBatchAddContactsItem::set_markname(const ::std::string& value) {
  set_has_markname();
  if (markname_ == &::google::protobuf::internal::kEmptyString) {
    markname_ = new ::std::string;
  }
  markname_->assign(value);
}
inline void TBatchAddContactsItem::set_markname(const char* value) {
  set_has_markname();
  if (markname_ == &::google::protobuf::internal::kEmptyString) {
    markname_ = new ::std::string;
  }
  markname_->assign(value);
}
inline void TBatchAddContactsItem::set_markname(const char* value, size_t size) {
  set_has_markname();
  if (markname_ == &::google::protobuf::internal::kEmptyString) {
    markname_ = new ::std::string;
  }
  markname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TBatchAddContactsItem::mutable_markname() {
  set_has_markname();
  if (markname_ == &::google::protobuf::internal::kEmptyString) {
    markname_ = new ::std::string;
  }
  return markname_;
}
inline ::std::string* TBatchAddContactsItem::release_markname() {
  clear_has_markname();
  if (markname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = markname_;
    markname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TBatchAddContactsItem::set_allocated_markname(::std::string* markname) {
  if (markname_ != &::google::protobuf::internal::kEmptyString) {
    delete markname_;
  }
  if (markname) {
    set_has_markname();
    markname_ = markname;
  } else {
    clear_has_markname();
    markname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 3;
inline bool TBatchAddContactsItem::has_e164() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TBatchAddContactsItem::set_has_e164() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TBatchAddContactsItem::clear_has_e164() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TBatchAddContactsItem::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TBatchAddContactsItem::e164() const {
  return *e164_;
}
inline void TBatchAddContactsItem::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TBatchAddContactsItem::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TBatchAddContactsItem::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TBatchAddContactsItem::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TBatchAddContactsItem::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TBatchAddContactsItem::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtMemberType membertype = 4;
inline bool TBatchAddContactsItem::has_membertype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TBatchAddContactsItem::set_has_membertype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TBatchAddContactsItem::clear_has_membertype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TBatchAddContactsItem::clear_membertype() {
  membertype_ = 0;
  clear_has_membertype();
}
inline ::mt::EmMtMemberType TBatchAddContactsItem::membertype() const {
  return static_cast< ::mt::EmMtMemberType >(membertype_);
}
inline void TBatchAddContactsItem::set_membertype(::mt::EmMtMemberType value) {
  assert(::mt::EmMtMemberType_IsValid(value));
  set_has_membertype();
  membertype_ = value;
}

// optional uint32 bitrate = 5;
inline bool TBatchAddContactsItem::has_bitrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TBatchAddContactsItem::set_has_bitrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TBatchAddContactsItem::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TBatchAddContactsItem::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TBatchAddContactsItem::bitrate() const {
  return bitrate_;
}
inline void TBatchAddContactsItem::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// -------------------------------------------------------------------

// TBatchAddContacts

// repeated .mt.TBatchAddContactsItem batchcontacts = 1;
inline int TBatchAddContacts::batchcontacts_size() const {
  return batchcontacts_.size();
}
inline void TBatchAddContacts::clear_batchcontacts() {
  batchcontacts_.Clear();
}
inline const ::mt::TBatchAddContactsItem& TBatchAddContacts::batchcontacts(int index) const {
  return batchcontacts_.Get(index);
}
inline ::mt::TBatchAddContactsItem* TBatchAddContacts::mutable_batchcontacts(int index) {
  return batchcontacts_.Mutable(index);
}
inline ::mt::TBatchAddContactsItem* TBatchAddContacts::add_batchcontacts() {
  return batchcontacts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TBatchAddContactsItem >&
TBatchAddContacts::batchcontacts() const {
  return batchcontacts_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TBatchAddContactsItem >*
TBatchAddContacts::mutable_batchcontacts() {
  return &batchcontacts_;
}

// optional string destgroupsn = 3;
inline bool TBatchAddContacts::has_destgroupsn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TBatchAddContacts::set_has_destgroupsn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TBatchAddContacts::clear_has_destgroupsn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TBatchAddContacts::clear_destgroupsn() {
  if (destgroupsn_ != &::google::protobuf::internal::kEmptyString) {
    destgroupsn_->clear();
  }
  clear_has_destgroupsn();
}
inline const ::std::string& TBatchAddContacts::destgroupsn() const {
  return *destgroupsn_;
}
inline void TBatchAddContacts::set_destgroupsn(const ::std::string& value) {
  set_has_destgroupsn();
  if (destgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    destgroupsn_ = new ::std::string;
  }
  destgroupsn_->assign(value);
}
inline void TBatchAddContacts::set_destgroupsn(const char* value) {
  set_has_destgroupsn();
  if (destgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    destgroupsn_ = new ::std::string;
  }
  destgroupsn_->assign(value);
}
inline void TBatchAddContacts::set_destgroupsn(const char* value, size_t size) {
  set_has_destgroupsn();
  if (destgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    destgroupsn_ = new ::std::string;
  }
  destgroupsn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TBatchAddContacts::mutable_destgroupsn() {
  set_has_destgroupsn();
  if (destgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    destgroupsn_ = new ::std::string;
  }
  return destgroupsn_;
}
inline ::std::string* TBatchAddContacts::release_destgroupsn() {
  clear_has_destgroupsn();
  if (destgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = destgroupsn_;
    destgroupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TBatchAddContacts::set_allocated_destgroupsn(::std::string* destgroupsn) {
  if (destgroupsn_ != &::google::protobuf::internal::kEmptyString) {
    delete destgroupsn_;
  }
  if (destgroupsn) {
    set_has_destgroupsn();
    destgroupsn_ = destgroupsn;
  } else {
    clear_has_destgroupsn();
    destgroupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TBatchDelContacts

// repeated .mt.TImSn batchcontacts = 1;
inline int TBatchDelContacts::batchcontacts_size() const {
  return batchcontacts_.size();
}
inline void TBatchDelContacts::clear_batchcontacts() {
  batchcontacts_.Clear();
}
inline const ::mt::TImSn& TBatchDelContacts::batchcontacts(int index) const {
  return batchcontacts_.Get(index);
}
inline ::mt::TImSn* TBatchDelContacts::mutable_batchcontacts(int index) {
  return batchcontacts_.Mutable(index);
}
inline ::mt::TImSn* TBatchDelContacts::add_batchcontacts() {
  return batchcontacts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImSn >&
TBatchDelContacts::batchcontacts() const {
  return batchcontacts_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImSn >*
TBatchDelContacts::mutable_batchcontacts() {
  return &batchcontacts_;
}

// -------------------------------------------------------------------

// TBatchMoveContacts

// repeated .mt.TImSn batchcontacts = 1;
inline int TBatchMoveContacts::batchcontacts_size() const {
  return batchcontacts_.size();
}
inline void TBatchMoveContacts::clear_batchcontacts() {
  batchcontacts_.Clear();
}
inline const ::mt::TImSn& TBatchMoveContacts::batchcontacts(int index) const {
  return batchcontacts_.Get(index);
}
inline ::mt::TImSn* TBatchMoveContacts::mutable_batchcontacts(int index) {
  return batchcontacts_.Mutable(index);
}
inline ::mt::TImSn* TBatchMoveContacts::add_batchcontacts() {
  return batchcontacts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImSn >&
TBatchMoveContacts::batchcontacts() const {
  return batchcontacts_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImSn >*
TBatchMoveContacts::mutable_batchcontacts() {
  return &batchcontacts_;
}

// optional string destgroupsn = 3;
inline bool TBatchMoveContacts::has_destgroupsn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TBatchMoveContacts::set_has_destgroupsn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TBatchMoveContacts::clear_has_destgroupsn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TBatchMoveContacts::clear_destgroupsn() {
  if (destgroupsn_ != &::google::protobuf::internal::kEmptyString) {
    destgroupsn_->clear();
  }
  clear_has_destgroupsn();
}
inline const ::std::string& TBatchMoveContacts::destgroupsn() const {
  return *destgroupsn_;
}
inline void TBatchMoveContacts::set_destgroupsn(const ::std::string& value) {
  set_has_destgroupsn();
  if (destgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    destgroupsn_ = new ::std::string;
  }
  destgroupsn_->assign(value);
}
inline void TBatchMoveContacts::set_destgroupsn(const char* value) {
  set_has_destgroupsn();
  if (destgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    destgroupsn_ = new ::std::string;
  }
  destgroupsn_->assign(value);
}
inline void TBatchMoveContacts::set_destgroupsn(const char* value, size_t size) {
  set_has_destgroupsn();
  if (destgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    destgroupsn_ = new ::std::string;
  }
  destgroupsn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TBatchMoveContacts::mutable_destgroupsn() {
  set_has_destgroupsn();
  if (destgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    destgroupsn_ = new ::std::string;
  }
  return destgroupsn_;
}
inline ::std::string* TBatchMoveContacts::release_destgroupsn() {
  clear_has_destgroupsn();
  if (destgroupsn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = destgroupsn_;
    destgroupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TBatchMoveContacts::set_allocated_destgroupsn(::std::string* destgroupsn) {
  if (destgroupsn_ != &::google::protobuf::internal::kEmptyString) {
    delete destgroupsn_;
  }
  if (destgroupsn) {
    set_has_destgroupsn();
    destgroupsn_ = destgroupsn;
  } else {
    clear_has_destgroupsn();
    destgroupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TRoomId

// optional string roomid = 1;
inline bool TRoomId::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRoomId::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRoomId::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRoomId::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& TRoomId::roomid() const {
  return *roomid_;
}
inline void TRoomId::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TRoomId::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TRoomId::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TRoomId::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* TRoomId::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TRoomId::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImMulitChatCreateInfo

// optional uint32 sessionid = 1;
inline bool TImMulitChatCreateInfo::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImMulitChatCreateInfo::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImMulitChatCreateInfo::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImMulitChatCreateInfo::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TImMulitChatCreateInfo::sessionid() const {
  return sessionid_;
}
inline void TImMulitChatCreateInfo::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional uint32 clientid = 2;
inline bool TImMulitChatCreateInfo::has_clientid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImMulitChatCreateInfo::set_has_clientid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImMulitChatCreateInfo::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImMulitChatCreateInfo::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 TImMulitChatCreateInfo::clientid() const {
  return clientid_;
}
inline void TImMulitChatCreateInfo::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string chatname = 3;
inline bool TImMulitChatCreateInfo::has_chatname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImMulitChatCreateInfo::set_has_chatname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImMulitChatCreateInfo::clear_has_chatname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImMulitChatCreateInfo::clear_chatname() {
  if (chatname_ != &::google::protobuf::internal::kEmptyString) {
    chatname_->clear();
  }
  clear_has_chatname();
}
inline const ::std::string& TImMulitChatCreateInfo::chatname() const {
  return *chatname_;
}
inline void TImMulitChatCreateInfo::set_chatname(const ::std::string& value) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(value);
}
inline void TImMulitChatCreateInfo::set_chatname(const char* value) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(value);
}
inline void TImMulitChatCreateInfo::set_chatname(const char* value, size_t size) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMulitChatCreateInfo::mutable_chatname() {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  return chatname_;
}
inline ::std::string* TImMulitChatCreateInfo::release_chatname() {
  clear_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chatname_;
    chatname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMulitChatCreateInfo::set_allocated_chatname(::std::string* chatname) {
  if (chatname_ != &::google::protobuf::internal::kEmptyString) {
    delete chatname_;
  }
  if (chatname) {
    set_has_chatname();
    chatname_ = chatname;
  } else {
    clear_has_chatname();
    chatname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtMultiChatType multichattype = 4;
inline bool TImMulitChatCreateInfo::has_multichattype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImMulitChatCreateInfo::set_has_multichattype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImMulitChatCreateInfo::clear_has_multichattype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImMulitChatCreateInfo::clear_multichattype() {
  multichattype_ = 0;
  clear_has_multichattype();
}
inline ::mt::EmMtMultiChatType TImMulitChatCreateInfo::multichattype() const {
  return static_cast< ::mt::EmMtMultiChatType >(multichattype_);
}
inline void TImMulitChatCreateInfo::set_multichattype(::mt::EmMtMultiChatType value) {
  assert(::mt::EmMtMultiChatType_IsValid(value));
  set_has_multichattype();
  multichattype_ = value;
}

// optional string confe164 = 5;
inline bool TImMulitChatCreateInfo::has_confe164() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImMulitChatCreateInfo::set_has_confe164() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImMulitChatCreateInfo::clear_has_confe164() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImMulitChatCreateInfo::clear_confe164() {
  if (confe164_ != &::google::protobuf::internal::kEmptyString) {
    confe164_->clear();
  }
  clear_has_confe164();
}
inline const ::std::string& TImMulitChatCreateInfo::confe164() const {
  return *confe164_;
}
inline void TImMulitChatCreateInfo::set_confe164(const ::std::string& value) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(value);
}
inline void TImMulitChatCreateInfo::set_confe164(const char* value) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(value);
}
inline void TImMulitChatCreateInfo::set_confe164(const char* value, size_t size) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMulitChatCreateInfo::mutable_confe164() {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  return confe164_;
}
inline ::std::string* TImMulitChatCreateInfo::release_confe164() {
  clear_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confe164_;
    confe164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMulitChatCreateInfo::set_allocated_confe164(::std::string* confe164) {
  if (confe164_ != &::google::protobuf::internal::kEmptyString) {
    delete confe164_;
  }
  if (confe164) {
    set_has_confe164();
    confe164_ = confe164;
  } else {
    clear_has_confe164();
    confe164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string roomid = 6;
inline bool TImMulitChatCreateInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TImMulitChatCreateInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TImMulitChatCreateInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TImMulitChatCreateInfo::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& TImMulitChatCreateInfo::roomid() const {
  return *roomid_;
}
inline void TImMulitChatCreateInfo::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TImMulitChatCreateInfo::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TImMulitChatCreateInfo::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMulitChatCreateInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* TImMulitChatCreateInfo::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMulitChatCreateInfo::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool persistent = 7;
inline bool TImMulitChatCreateInfo::has_persistent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TImMulitChatCreateInfo::set_has_persistent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TImMulitChatCreateInfo::clear_has_persistent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TImMulitChatCreateInfo::clear_persistent() {
  persistent_ = false;
  clear_has_persistent();
}
inline bool TImMulitChatCreateInfo::persistent() const {
  return persistent_;
}
inline void TImMulitChatCreateInfo::set_persistent(bool value) {
  set_has_persistent();
  persistent_ = value;
}

// optional bool owner = 8;
inline bool TImMulitChatCreateInfo::has_owner() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TImMulitChatCreateInfo::set_has_owner() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TImMulitChatCreateInfo::clear_has_owner() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TImMulitChatCreateInfo::clear_owner() {
  owner_ = false;
  clear_has_owner();
}
inline bool TImMulitChatCreateInfo::owner() const {
  return owner_;
}
inline void TImMulitChatCreateInfo::set_owner(bool value) {
  set_has_owner();
  owner_ = value;
}

// optional string inviterno = 9;
inline bool TImMulitChatCreateInfo::has_inviterno() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TImMulitChatCreateInfo::set_has_inviterno() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TImMulitChatCreateInfo::clear_has_inviterno() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TImMulitChatCreateInfo::clear_inviterno() {
  if (inviterno_ != &::google::protobuf::internal::kEmptyString) {
    inviterno_->clear();
  }
  clear_has_inviterno();
}
inline const ::std::string& TImMulitChatCreateInfo::inviterno() const {
  return *inviterno_;
}
inline void TImMulitChatCreateInfo::set_inviterno(const ::std::string& value) {
  set_has_inviterno();
  if (inviterno_ == &::google::protobuf::internal::kEmptyString) {
    inviterno_ = new ::std::string;
  }
  inviterno_->assign(value);
}
inline void TImMulitChatCreateInfo::set_inviterno(const char* value) {
  set_has_inviterno();
  if (inviterno_ == &::google::protobuf::internal::kEmptyString) {
    inviterno_ = new ::std::string;
  }
  inviterno_->assign(value);
}
inline void TImMulitChatCreateInfo::set_inviterno(const char* value, size_t size) {
  set_has_inviterno();
  if (inviterno_ == &::google::protobuf::internal::kEmptyString) {
    inviterno_ = new ::std::string;
  }
  inviterno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMulitChatCreateInfo::mutable_inviterno() {
  set_has_inviterno();
  if (inviterno_ == &::google::protobuf::internal::kEmptyString) {
    inviterno_ = new ::std::string;
  }
  return inviterno_;
}
inline ::std::string* TImMulitChatCreateInfo::release_inviterno() {
  clear_has_inviterno();
  if (inviterno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inviterno_;
    inviterno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMulitChatCreateInfo::set_allocated_inviterno(::std::string* inviterno) {
  if (inviterno_ != &::google::protobuf::internal::kEmptyString) {
    delete inviterno_;
  }
  if (inviterno) {
    set_has_inviterno();
    inviterno_ = inviterno;
  } else {
    clear_has_inviterno();
    inviterno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImMultiChatMemberInfo

// optional uint32 sessionid = 1;
inline bool TImMultiChatMemberInfo::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImMultiChatMemberInfo::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImMultiChatMemberInfo::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImMultiChatMemberInfo::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TImMultiChatMemberInfo::sessionid() const {
  return sessionid_;
}
inline void TImMultiChatMemberInfo::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional .mt.TImNOList nolist = 2;
inline bool TImMultiChatMemberInfo::has_nolist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImMultiChatMemberInfo::set_has_nolist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImMultiChatMemberInfo::clear_has_nolist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImMultiChatMemberInfo::clear_nolist() {
  if (nolist_ != NULL) nolist_->::mt::TImNOList::Clear();
  clear_has_nolist();
}
inline const ::mt::TImNOList& TImMultiChatMemberInfo::nolist() const {
  return nolist_ != NULL ? *nolist_ : *default_instance_->nolist_;
}
inline ::mt::TImNOList* TImMultiChatMemberInfo::mutable_nolist() {
  set_has_nolist();
  if (nolist_ == NULL) nolist_ = new ::mt::TImNOList;
  return nolist_;
}
inline ::mt::TImNOList* TImMultiChatMemberInfo::release_nolist() {
  clear_has_nolist();
  ::mt::TImNOList* temp = nolist_;
  nolist_ = NULL;
  return temp;
}
inline void TImMultiChatMemberInfo::set_allocated_nolist(::mt::TImNOList* nolist) {
  delete nolist_;
  nolist_ = nolist;
  if (nolist) {
    set_has_nolist();
  } else {
    clear_has_nolist();
  }
}

// optional .mt.TRoomId roomid = 3;
inline bool TImMultiChatMemberInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImMultiChatMemberInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImMultiChatMemberInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImMultiChatMemberInfo::clear_roomid() {
  if (roomid_ != NULL) roomid_->::mt::TRoomId::Clear();
  clear_has_roomid();
}
inline const ::mt::TRoomId& TImMultiChatMemberInfo::roomid() const {
  return roomid_ != NULL ? *roomid_ : *default_instance_->roomid_;
}
inline ::mt::TRoomId* TImMultiChatMemberInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == NULL) roomid_ = new ::mt::TRoomId;
  return roomid_;
}
inline ::mt::TRoomId* TImMultiChatMemberInfo::release_roomid() {
  clear_has_roomid();
  ::mt::TRoomId* temp = roomid_;
  roomid_ = NULL;
  return temp;
}
inline void TImMultiChatMemberInfo::set_allocated_roomid(::mt::TRoomId* roomid) {
  delete roomid_;
  roomid_ = roomid;
  if (roomid) {
    set_has_roomid();
  } else {
    clear_has_roomid();
  }
}

// -------------------------------------------------------------------

// TImMultiChatMemberInfoEx

// optional uint32 sessionid = 1;
inline bool TImMultiChatMemberInfoEx::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImMultiChatMemberInfoEx::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImMultiChatMemberInfoEx::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImMultiChatMemberInfoEx::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TImMultiChatMemberInfoEx::sessionid() const {
  return sessionid_;
}
inline void TImMultiChatMemberInfoEx::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional string no = 2;
inline bool TImMultiChatMemberInfoEx::has_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImMultiChatMemberInfoEx::set_has_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImMultiChatMemberInfoEx::clear_has_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImMultiChatMemberInfoEx::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TImMultiChatMemberInfoEx::no() const {
  return *no_;
}
inline void TImMultiChatMemberInfoEx::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImMultiChatMemberInfoEx::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImMultiChatMemberInfoEx::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMultiChatMemberInfoEx::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TImMultiChatMemberInfoEx::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMultiChatMemberInfoEx::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool owner = 3;
inline bool TImMultiChatMemberInfoEx::has_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImMultiChatMemberInfoEx::set_has_owner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImMultiChatMemberInfoEx::clear_has_owner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImMultiChatMemberInfoEx::clear_owner() {
  owner_ = false;
  clear_has_owner();
}
inline bool TImMultiChatMemberInfoEx::owner() const {
  return owner_;
}
inline void TImMultiChatMemberInfoEx::set_owner(bool value) {
  set_has_owner();
  owner_ = value;
}

// optional bool self = 4;
inline bool TImMultiChatMemberInfoEx::has_self() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImMultiChatMemberInfoEx::set_has_self() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImMultiChatMemberInfoEx::clear_has_self() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImMultiChatMemberInfoEx::clear_self() {
  self_ = false;
  clear_has_self();
}
inline bool TImMultiChatMemberInfoEx::self() const {
  return self_;
}
inline void TImMultiChatMemberInfoEx::set_self(bool value) {
  set_has_self();
  self_ = value;
}

// optional .mt.EmMtImTerminalType mttype = 5;
inline bool TImMultiChatMemberInfoEx::has_mttype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImMultiChatMemberInfoEx::set_has_mttype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImMultiChatMemberInfoEx::clear_has_mttype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImMultiChatMemberInfoEx::clear_mttype() {
  mttype_ = 0;
  clear_has_mttype();
}
inline ::mt::EmMtImTerminalType TImMultiChatMemberInfoEx::mttype() const {
  return static_cast< ::mt::EmMtImTerminalType >(mttype_);
}
inline void TImMultiChatMemberInfoEx::set_mttype(::mt::EmMtImTerminalType value) {
  assert(::mt::EmMtImTerminalType_IsValid(value));
  set_has_mttype();
  mttype_ = value;
}

// optional .mt.EmMtOnlineState state = 6;
inline bool TImMultiChatMemberInfoEx::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TImMultiChatMemberInfoEx::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TImMultiChatMemberInfoEx::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TImMultiChatMemberInfoEx::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::mt::EmMtOnlineState TImMultiChatMemberInfoEx::state() const {
  return static_cast< ::mt::EmMtOnlineState >(state_);
}
inline void TImMultiChatMemberInfoEx::set_state(::mt::EmMtOnlineState value) {
  assert(::mt::EmMtOnlineState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .mt.EmMtOnlineState maxstate = 7;
inline bool TImMultiChatMemberInfoEx::has_maxstate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TImMultiChatMemberInfoEx::set_has_maxstate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TImMultiChatMemberInfoEx::clear_has_maxstate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TImMultiChatMemberInfoEx::clear_maxstate() {
  maxstate_ = 0;
  clear_has_maxstate();
}
inline ::mt::EmMtOnlineState TImMultiChatMemberInfoEx::maxstate() const {
  return static_cast< ::mt::EmMtOnlineState >(maxstate_);
}
inline void TImMultiChatMemberInfoEx::set_maxstate(::mt::EmMtOnlineState value) {
  assert(::mt::EmMtOnlineState_IsValid(value));
  set_has_maxstate();
  maxstate_ = value;
}

// optional .mt.TRoomId roomid = 8;
inline bool TImMultiChatMemberInfoEx::has_roomid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TImMultiChatMemberInfoEx::set_has_roomid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TImMultiChatMemberInfoEx::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TImMultiChatMemberInfoEx::clear_roomid() {
  if (roomid_ != NULL) roomid_->::mt::TRoomId::Clear();
  clear_has_roomid();
}
inline const ::mt::TRoomId& TImMultiChatMemberInfoEx::roomid() const {
  return roomid_ != NULL ? *roomid_ : *default_instance_->roomid_;
}
inline ::mt::TRoomId* TImMultiChatMemberInfoEx::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == NULL) roomid_ = new ::mt::TRoomId;
  return roomid_;
}
inline ::mt::TRoomId* TImMultiChatMemberInfoEx::release_roomid() {
  clear_has_roomid();
  ::mt::TRoomId* temp = roomid_;
  roomid_ = NULL;
  return temp;
}
inline void TImMultiChatMemberInfoEx::set_allocated_roomid(::mt::TRoomId* roomid) {
  delete roomid_;
  roomid_ = roomid;
  if (roomid) {
    set_has_roomid();
  } else {
    clear_has_roomid();
  }
}

// -------------------------------------------------------------------

// TMultiChatMemberStateInfo

// optional uint32 sessionid = 1;
inline bool TMultiChatMemberStateInfo::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMultiChatMemberStateInfo::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMultiChatMemberStateInfo::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMultiChatMemberStateInfo::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TMultiChatMemberStateInfo::sessionid() const {
  return sessionid_;
}
inline void TMultiChatMemberStateInfo::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional string no = 2;
inline bool TMultiChatMemberStateInfo::has_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMultiChatMemberStateInfo::set_has_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMultiChatMemberStateInfo::clear_has_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMultiChatMemberStateInfo::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TMultiChatMemberStateInfo::no() const {
  return *no_;
}
inline void TMultiChatMemberStateInfo::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TMultiChatMemberStateInfo::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TMultiChatMemberStateInfo::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMultiChatMemberStateInfo::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TMultiChatMemberStateInfo::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMultiChatMemberStateInfo::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool owner = 3;
inline bool TMultiChatMemberStateInfo::has_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMultiChatMemberStateInfo::set_has_owner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMultiChatMemberStateInfo::clear_has_owner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMultiChatMemberStateInfo::clear_owner() {
  owner_ = false;
  clear_has_owner();
}
inline bool TMultiChatMemberStateInfo::owner() const {
  return owner_;
}
inline void TMultiChatMemberStateInfo::set_owner(bool value) {
  set_has_owner();
  owner_ = value;
}

// optional bool self = 4;
inline bool TMultiChatMemberStateInfo::has_self() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMultiChatMemberStateInfo::set_has_self() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMultiChatMemberStateInfo::clear_has_self() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMultiChatMemberStateInfo::clear_self() {
  self_ = false;
  clear_has_self();
}
inline bool TMultiChatMemberStateInfo::self() const {
  return self_;
}
inline void TMultiChatMemberStateInfo::set_self(bool value) {
  set_has_self();
  self_ = value;
}

// optional .mt.EmMtOnlineState maxstate = 5;
inline bool TMultiChatMemberStateInfo::has_maxstate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMultiChatMemberStateInfo::set_has_maxstate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMultiChatMemberStateInfo::clear_has_maxstate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMultiChatMemberStateInfo::clear_maxstate() {
  maxstate_ = 0;
  clear_has_maxstate();
}
inline ::mt::EmMtOnlineState TMultiChatMemberStateInfo::maxstate() const {
  return static_cast< ::mt::EmMtOnlineState >(maxstate_);
}
inline void TMultiChatMemberStateInfo::set_maxstate(::mt::EmMtOnlineState value) {
  assert(::mt::EmMtOnlineState_IsValid(value));
  set_has_maxstate();
  maxstate_ = value;
}

// optional bool maxaudio = 6;
inline bool TMultiChatMemberStateInfo::has_maxaudio() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMultiChatMemberStateInfo::set_has_maxaudio() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMultiChatMemberStateInfo::clear_has_maxaudio() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMultiChatMemberStateInfo::clear_maxaudio() {
  maxaudio_ = false;
  clear_has_maxaudio();
}
inline bool TMultiChatMemberStateInfo::maxaudio() const {
  return maxaudio_;
}
inline void TMultiChatMemberStateInfo::set_maxaudio(bool value) {
  set_has_maxaudio();
  maxaudio_ = value;
}

// optional bool maxvideo = 7;
inline bool TMultiChatMemberStateInfo::has_maxvideo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMultiChatMemberStateInfo::set_has_maxvideo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMultiChatMemberStateInfo::clear_has_maxvideo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMultiChatMemberStateInfo::clear_maxvideo() {
  maxvideo_ = false;
  clear_has_maxvideo();
}
inline bool TMultiChatMemberStateInfo::maxvideo() const {
  return maxvideo_;
}
inline void TMultiChatMemberStateInfo::set_maxvideo(bool value) {
  set_has_maxvideo();
  maxvideo_ = value;
}

// optional .mt.TSubState mtttate = 8;
inline bool TMultiChatMemberStateInfo::has_mtttate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMultiChatMemberStateInfo::set_has_mtttate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMultiChatMemberStateInfo::clear_has_mtttate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMultiChatMemberStateInfo::clear_mtttate() {
  if (mtttate_ != NULL) mtttate_->::mt::TSubState::Clear();
  clear_has_mtttate();
}
inline const ::mt::TSubState& TMultiChatMemberStateInfo::mtttate() const {
  return mtttate_ != NULL ? *mtttate_ : *default_instance_->mtttate_;
}
inline ::mt::TSubState* TMultiChatMemberStateInfo::mutable_mtttate() {
  set_has_mtttate();
  if (mtttate_ == NULL) mtttate_ = new ::mt::TSubState;
  return mtttate_;
}
inline ::mt::TSubState* TMultiChatMemberStateInfo::release_mtttate() {
  clear_has_mtttate();
  ::mt::TSubState* temp = mtttate_;
  mtttate_ = NULL;
  return temp;
}
inline void TMultiChatMemberStateInfo::set_allocated_mtttate(::mt::TSubState* mtttate) {
  delete mtttate_;
  mtttate_ = mtttate;
  if (mtttate) {
    set_has_mtttate();
  } else {
    clear_has_mtttate();
  }
}

// optional .mt.TRoomId roomid = 9;
inline bool TMultiChatMemberStateInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMultiChatMemberStateInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMultiChatMemberStateInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMultiChatMemberStateInfo::clear_roomid() {
  if (roomid_ != NULL) roomid_->::mt::TRoomId::Clear();
  clear_has_roomid();
}
inline const ::mt::TRoomId& TMultiChatMemberStateInfo::roomid() const {
  return roomid_ != NULL ? *roomid_ : *default_instance_->roomid_;
}
inline ::mt::TRoomId* TMultiChatMemberStateInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == NULL) roomid_ = new ::mt::TRoomId;
  return roomid_;
}
inline ::mt::TRoomId* TMultiChatMemberStateInfo::release_roomid() {
  clear_has_roomid();
  ::mt::TRoomId* temp = roomid_;
  roomid_ = NULL;
  return temp;
}
inline void TMultiChatMemberStateInfo::set_allocated_roomid(::mt::TRoomId* roomid) {
  delete roomid_;
  roomid_ = roomid;
  if (roomid) {
    set_has_roomid();
  } else {
    clear_has_roomid();
  }
}

// -------------------------------------------------------------------

// TImMultiChatMessage

// optional uint32 sessionid = 1;
inline bool TImMultiChatMessage::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImMultiChatMessage::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImMultiChatMessage::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImMultiChatMessage::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TImMultiChatMessage::sessionid() const {
  return sessionid_;
}
inline void TImMultiChatMessage::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional string srcno = 2;
inline bool TImMultiChatMessage::has_srcno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImMultiChatMessage::set_has_srcno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImMultiChatMessage::clear_has_srcno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImMultiChatMessage::clear_srcno() {
  if (srcno_ != &::google::protobuf::internal::kEmptyString) {
    srcno_->clear();
  }
  clear_has_srcno();
}
inline const ::std::string& TImMultiChatMessage::srcno() const {
  return *srcno_;
}
inline void TImMultiChatMessage::set_srcno(const ::std::string& value) {
  set_has_srcno();
  if (srcno_ == &::google::protobuf::internal::kEmptyString) {
    srcno_ = new ::std::string;
  }
  srcno_->assign(value);
}
inline void TImMultiChatMessage::set_srcno(const char* value) {
  set_has_srcno();
  if (srcno_ == &::google::protobuf::internal::kEmptyString) {
    srcno_ = new ::std::string;
  }
  srcno_->assign(value);
}
inline void TImMultiChatMessage::set_srcno(const char* value, size_t size) {
  set_has_srcno();
  if (srcno_ == &::google::protobuf::internal::kEmptyString) {
    srcno_ = new ::std::string;
  }
  srcno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMultiChatMessage::mutable_srcno() {
  set_has_srcno();
  if (srcno_ == &::google::protobuf::internal::kEmptyString) {
    srcno_ = new ::std::string;
  }
  return srcno_;
}
inline ::std::string* TImMultiChatMessage::release_srcno() {
  clear_has_srcno();
  if (srcno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcno_;
    srcno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMultiChatMessage::set_allocated_srcno(::std::string* srcno) {
  if (srcno_ != &::google::protobuf::internal::kEmptyString) {
    delete srcno_;
  }
  if (srcno) {
    set_has_srcno();
    srcno_ = srcno;
  } else {
    clear_has_srcno();
    srcno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtImTerminalType mttype = 3;
inline bool TImMultiChatMessage::has_mttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImMultiChatMessage::set_has_mttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImMultiChatMessage::clear_has_mttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImMultiChatMessage::clear_mttype() {
  mttype_ = 0;
  clear_has_mttype();
}
inline ::mt::EmMtImTerminalType TImMultiChatMessage::mttype() const {
  return static_cast< ::mt::EmMtImTerminalType >(mttype_);
}
inline void TImMultiChatMessage::set_mttype(::mt::EmMtImTerminalType value) {
  assert(::mt::EmMtImTerminalType_IsValid(value));
  set_has_mttype();
  mttype_ = value;
}

// optional .mt.TImChatBuf messagebuf = 4;
inline bool TImMultiChatMessage::has_messagebuf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImMultiChatMessage::set_has_messagebuf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImMultiChatMessage::clear_has_messagebuf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImMultiChatMessage::clear_messagebuf() {
  if (messagebuf_ != NULL) messagebuf_->::mt::TImChatBuf::Clear();
  clear_has_messagebuf();
}
inline const ::mt::TImChatBuf& TImMultiChatMessage::messagebuf() const {
  return messagebuf_ != NULL ? *messagebuf_ : *default_instance_->messagebuf_;
}
inline ::mt::TImChatBuf* TImMultiChatMessage::mutable_messagebuf() {
  set_has_messagebuf();
  if (messagebuf_ == NULL) messagebuf_ = new ::mt::TImChatBuf;
  return messagebuf_;
}
inline ::mt::TImChatBuf* TImMultiChatMessage::release_messagebuf() {
  clear_has_messagebuf();
  ::mt::TImChatBuf* temp = messagebuf_;
  messagebuf_ = NULL;
  return temp;
}
inline void TImMultiChatMessage::set_allocated_messagebuf(::mt::TImChatBuf* messagebuf) {
  delete messagebuf_;
  messagebuf_ = messagebuf;
  if (messagebuf) {
    set_has_messagebuf();
  } else {
    clear_has_messagebuf();
  }
}

// optional uint32 contextid = 5;
inline bool TImMultiChatMessage::has_contextid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImMultiChatMessage::set_has_contextid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImMultiChatMessage::clear_has_contextid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImMultiChatMessage::clear_contextid() {
  contextid_ = 0u;
  clear_has_contextid();
}
inline ::google::protobuf::uint32 TImMultiChatMessage::contextid() const {
  return contextid_;
}
inline void TImMultiChatMessage::set_contextid(::google::protobuf::uint32 value) {
  set_has_contextid();
  contextid_ = value;
}

// optional .mt.TRoomId roomid = 6;
inline bool TImMultiChatMessage::has_roomid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TImMultiChatMessage::set_has_roomid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TImMultiChatMessage::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TImMultiChatMessage::clear_roomid() {
  if (roomid_ != NULL) roomid_->::mt::TRoomId::Clear();
  clear_has_roomid();
}
inline const ::mt::TRoomId& TImMultiChatMessage::roomid() const {
  return roomid_ != NULL ? *roomid_ : *default_instance_->roomid_;
}
inline ::mt::TRoomId* TImMultiChatMessage::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == NULL) roomid_ = new ::mt::TRoomId;
  return roomid_;
}
inline ::mt::TRoomId* TImMultiChatMessage::release_roomid() {
  clear_has_roomid();
  ::mt::TRoomId* temp = roomid_;
  roomid_ = NULL;
  return temp;
}
inline void TImMultiChatMessage::set_allocated_roomid(::mt::TRoomId* roomid) {
  delete roomid_;
  roomid_ = roomid;
  if (roomid) {
    set_has_roomid();
  } else {
    clear_has_roomid();
  }
}

// optional string msgid = 7;
inline bool TImMultiChatMessage::has_msgid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TImMultiChatMessage::set_has_msgid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TImMultiChatMessage::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TImMultiChatMessage::clear_msgid() {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    msgid_->clear();
  }
  clear_has_msgid();
}
inline const ::std::string& TImMultiChatMessage::msgid() const {
  return *msgid_;
}
inline void TImMultiChatMessage::set_msgid(const ::std::string& value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void TImMultiChatMessage::set_msgid(const char* value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void TImMultiChatMessage::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMultiChatMessage::mutable_msgid() {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  return msgid_;
}
inline ::std::string* TImMultiChatMessage::release_msgid() {
  clear_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgid_;
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMultiChatMessage::set_allocated_msgid(::std::string* msgid) {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    delete msgid_;
  }
  if (msgid) {
    set_has_msgid();
    msgid_ = msgid;
  } else {
    clear_has_msgid();
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMultiChatPicId

// optional uint32 sessionid = 1;
inline bool TMultiChatPicId::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMultiChatPicId::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMultiChatPicId::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMultiChatPicId::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TMultiChatPicId::sessionid() const {
  return sessionid_;
}
inline void TMultiChatPicId::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional string no = 2;
inline bool TMultiChatPicId::has_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMultiChatPicId::set_has_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMultiChatPicId::clear_has_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMultiChatPicId::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TMultiChatPicId::no() const {
  return *no_;
}
inline void TMultiChatPicId::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TMultiChatPicId::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TMultiChatPicId::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMultiChatPicId::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TMultiChatPicId::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMultiChatPicId::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtImTerminalType devicetype = 3;
inline bool TMultiChatPicId::has_devicetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMultiChatPicId::set_has_devicetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMultiChatPicId::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMultiChatPicId::clear_devicetype() {
  devicetype_ = 0;
  clear_has_devicetype();
}
inline ::mt::EmMtImTerminalType TMultiChatPicId::devicetype() const {
  return static_cast< ::mt::EmMtImTerminalType >(devicetype_);
}
inline void TMultiChatPicId::set_devicetype(::mt::EmMtImTerminalType value) {
  assert(::mt::EmMtImTerminalType_IsValid(value));
  set_has_devicetype();
  devicetype_ = value;
}

// optional string sid = 4;
inline bool TMultiChatPicId::has_sid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMultiChatPicId::set_has_sid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMultiChatPicId::clear_has_sid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMultiChatPicId::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& TMultiChatPicId::sid() const {
  return *sid_;
}
inline void TMultiChatPicId::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void TMultiChatPicId::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void TMultiChatPicId::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMultiChatPicId::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* TMultiChatPicId::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMultiChatPicId::set_allocated_sid(::std::string* sid) {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (sid) {
    set_has_sid();
    sid_ = sid;
  } else {
    clear_has_sid();
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TRoomId roomid = 5;
inline bool TMultiChatPicId::has_roomid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMultiChatPicId::set_has_roomid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMultiChatPicId::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMultiChatPicId::clear_roomid() {
  if (roomid_ != NULL) roomid_->::mt::TRoomId::Clear();
  clear_has_roomid();
}
inline const ::mt::TRoomId& TMultiChatPicId::roomid() const {
  return roomid_ != NULL ? *roomid_ : *default_instance_->roomid_;
}
inline ::mt::TRoomId* TMultiChatPicId::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == NULL) roomid_ = new ::mt::TRoomId;
  return roomid_;
}
inline ::mt::TRoomId* TMultiChatPicId::release_roomid() {
  clear_has_roomid();
  ::mt::TRoomId* temp = roomid_;
  roomid_ = NULL;
  return temp;
}
inline void TMultiChatPicId::set_allocated_roomid(::mt::TRoomId* roomid) {
  delete roomid_;
  roomid_ = roomid;
  if (roomid) {
    set_has_roomid();
  } else {
    clear_has_roomid();
  }
}

// -------------------------------------------------------------------

// TDeviceOnlineStateCacheItem

// optional uint32 app = 1;
inline bool TDeviceOnlineStateCacheItem::has_app() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDeviceOnlineStateCacheItem::set_has_app() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDeviceOnlineStateCacheItem::clear_has_app() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDeviceOnlineStateCacheItem::clear_app() {
  app_ = 0u;
  clear_has_app();
}
inline ::google::protobuf::uint32 TDeviceOnlineStateCacheItem::app() const {
  return app_;
}
inline void TDeviceOnlineStateCacheItem::set_app(::google::protobuf::uint32 value) {
  set_has_app();
  app_ = value;
}

// optional .mt.TDeviceOnlineState status = 2;
inline bool TDeviceOnlineStateCacheItem::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDeviceOnlineStateCacheItem::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDeviceOnlineStateCacheItem::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDeviceOnlineStateCacheItem::clear_status() {
  if (status_ != NULL) status_->::mt::TDeviceOnlineState::Clear();
  clear_has_status();
}
inline const ::mt::TDeviceOnlineState& TDeviceOnlineStateCacheItem::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::mt::TDeviceOnlineState* TDeviceOnlineStateCacheItem::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::mt::TDeviceOnlineState;
  return status_;
}
inline ::mt::TDeviceOnlineState* TDeviceOnlineStateCacheItem::release_status() {
  clear_has_status();
  ::mt::TDeviceOnlineState* temp = status_;
  status_ = NULL;
  return temp;
}
inline void TDeviceOnlineStateCacheItem::set_allocated_status(::mt::TDeviceOnlineState* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// -------------------------------------------------------------------

// TDeviceOnlineStateCacheList

// optional uint32 arraysize = 1;
inline bool TDeviceOnlineStateCacheList::has_arraysize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDeviceOnlineStateCacheList::set_has_arraysize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDeviceOnlineStateCacheList::clear_has_arraysize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDeviceOnlineStateCacheList::clear_arraysize() {
  arraysize_ = 0u;
  clear_has_arraysize();
}
inline ::google::protobuf::uint32 TDeviceOnlineStateCacheList::arraysize() const {
  return arraysize_;
}
inline void TDeviceOnlineStateCacheList::set_arraysize(::google::protobuf::uint32 value) {
  set_has_arraysize();
  arraysize_ = value;
}

// repeated .mt.TDeviceOnlineStateCacheItem array = 2;
inline int TDeviceOnlineStateCacheList::array_size() const {
  return array_.size();
}
inline void TDeviceOnlineStateCacheList::clear_array() {
  array_.Clear();
}
inline const ::mt::TDeviceOnlineStateCacheItem& TDeviceOnlineStateCacheList::array(int index) const {
  return array_.Get(index);
}
inline ::mt::TDeviceOnlineStateCacheItem* TDeviceOnlineStateCacheList::mutable_array(int index) {
  return array_.Mutable(index);
}
inline ::mt::TDeviceOnlineStateCacheItem* TDeviceOnlineStateCacheList::add_array() {
  return array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TDeviceOnlineStateCacheItem >&
TDeviceOnlineStateCacheList::array() const {
  return array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TDeviceOnlineStateCacheItem >*
TDeviceOnlineStateCacheList::mutable_array() {
  return &array_;
}

// -------------------------------------------------------------------

// TFriendConferenceInfo

// optional string peerid = 1;
inline bool TFriendConferenceInfo::has_peerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TFriendConferenceInfo::set_has_peerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TFriendConferenceInfo::clear_has_peerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TFriendConferenceInfo::clear_peerid() {
  if (peerid_ != &::google::protobuf::internal::kEmptyString) {
    peerid_->clear();
  }
  clear_has_peerid();
}
inline const ::std::string& TFriendConferenceInfo::peerid() const {
  return *peerid_;
}
inline void TFriendConferenceInfo::set_peerid(const ::std::string& value) {
  set_has_peerid();
  if (peerid_ == &::google::protobuf::internal::kEmptyString) {
    peerid_ = new ::std::string;
  }
  peerid_->assign(value);
}
inline void TFriendConferenceInfo::set_peerid(const char* value) {
  set_has_peerid();
  if (peerid_ == &::google::protobuf::internal::kEmptyString) {
    peerid_ = new ::std::string;
  }
  peerid_->assign(value);
}
inline void TFriendConferenceInfo::set_peerid(const char* value, size_t size) {
  set_has_peerid();
  if (peerid_ == &::google::protobuf::internal::kEmptyString) {
    peerid_ = new ::std::string;
  }
  peerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TFriendConferenceInfo::mutable_peerid() {
  set_has_peerid();
  if (peerid_ == &::google::protobuf::internal::kEmptyString) {
    peerid_ = new ::std::string;
  }
  return peerid_;
}
inline ::std::string* TFriendConferenceInfo::release_peerid() {
  clear_has_peerid();
  if (peerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peerid_;
    peerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TFriendConferenceInfo::set_allocated_peerid(::std::string* peerid) {
  if (peerid_ != &::google::protobuf::internal::kEmptyString) {
    delete peerid_;
  }
  if (peerid) {
    set_has_peerid();
    peerid_ = peerid;
  } else {
    clear_has_peerid();
    peerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtImTerminalType peertype = 2;
inline bool TFriendConferenceInfo::has_peertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TFriendConferenceInfo::set_has_peertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TFriendConferenceInfo::clear_has_peertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TFriendConferenceInfo::clear_peertype() {
  peertype_ = 0;
  clear_has_peertype();
}
inline ::mt::EmMtImTerminalType TFriendConferenceInfo::peertype() const {
  return static_cast< ::mt::EmMtImTerminalType >(peertype_);
}
inline void TFriendConferenceInfo::set_peertype(::mt::EmMtImTerminalType value) {
  assert(::mt::EmMtImTerminalType_IsValid(value));
  set_has_peertype();
  peertype_ = value;
}

// optional string confe164 = 3;
inline bool TFriendConferenceInfo::has_confe164() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TFriendConferenceInfo::set_has_confe164() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TFriendConferenceInfo::clear_has_confe164() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TFriendConferenceInfo::clear_confe164() {
  if (confe164_ != &::google::protobuf::internal::kEmptyString) {
    confe164_->clear();
  }
  clear_has_confe164();
}
inline const ::std::string& TFriendConferenceInfo::confe164() const {
  return *confe164_;
}
inline void TFriendConferenceInfo::set_confe164(const ::std::string& value) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(value);
}
inline void TFriendConferenceInfo::set_confe164(const char* value) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(value);
}
inline void TFriendConferenceInfo::set_confe164(const char* value, size_t size) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TFriendConferenceInfo::mutable_confe164() {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  return confe164_;
}
inline ::std::string* TFriendConferenceInfo::release_confe164() {
  clear_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confe164_;
    confe164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TFriendConferenceInfo::set_allocated_confe164(::std::string* confe164) {
  if (confe164_ != &::google::protobuf::internal::kEmptyString) {
    delete confe164_;
  }
  if (confe164) {
    set_has_confe164();
    confe164_ = confe164;
  } else {
    clear_has_confe164();
    confe164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string roomid = 4;
inline bool TFriendConferenceInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TFriendConferenceInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TFriendConferenceInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TFriendConferenceInfo::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& TFriendConferenceInfo::roomid() const {
  return *roomid_;
}
inline void TFriendConferenceInfo::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TFriendConferenceInfo::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TFriendConferenceInfo::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TFriendConferenceInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* TFriendConferenceInfo::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TFriendConferenceInfo::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string chatname = 5;
inline bool TFriendConferenceInfo::has_chatname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TFriendConferenceInfo::set_has_chatname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TFriendConferenceInfo::clear_has_chatname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TFriendConferenceInfo::clear_chatname() {
  if (chatname_ != &::google::protobuf::internal::kEmptyString) {
    chatname_->clear();
  }
  clear_has_chatname();
}
inline const ::std::string& TFriendConferenceInfo::chatname() const {
  return *chatname_;
}
inline void TFriendConferenceInfo::set_chatname(const ::std::string& value) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(value);
}
inline void TFriendConferenceInfo::set_chatname(const char* value) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(value);
}
inline void TFriendConferenceInfo::set_chatname(const char* value, size_t size) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TFriendConferenceInfo::mutable_chatname() {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  return chatname_;
}
inline ::std::string* TFriendConferenceInfo::release_chatname() {
  clear_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chatname_;
    chatname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TFriendConferenceInfo::set_allocated_chatname(::std::string* chatname) {
  if (chatname_ != &::google::protobuf::internal::kEmptyString) {
    delete chatname_;
  }
  if (chatname) {
    set_has_chatname();
    chatname_ = chatname;
  } else {
    clear_has_chatname();
    chatname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TModifyPwd

// optional string username = 1;
inline bool TModifyPwd::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TModifyPwd::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TModifyPwd::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TModifyPwd::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TModifyPwd::username() const {
  return *username_;
}
inline void TModifyPwd::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TModifyPwd::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TModifyPwd::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TModifyPwd::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TModifyPwd::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TModifyPwd::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string oldpwd = 2;
inline bool TModifyPwd::has_oldpwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TModifyPwd::set_has_oldpwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TModifyPwd::clear_has_oldpwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TModifyPwd::clear_oldpwd() {
  if (oldpwd_ != &::google::protobuf::internal::kEmptyString) {
    oldpwd_->clear();
  }
  clear_has_oldpwd();
}
inline const ::std::string& TModifyPwd::oldpwd() const {
  return *oldpwd_;
}
inline void TModifyPwd::set_oldpwd(const ::std::string& value) {
  set_has_oldpwd();
  if (oldpwd_ == &::google::protobuf::internal::kEmptyString) {
    oldpwd_ = new ::std::string;
  }
  oldpwd_->assign(value);
}
inline void TModifyPwd::set_oldpwd(const char* value) {
  set_has_oldpwd();
  if (oldpwd_ == &::google::protobuf::internal::kEmptyString) {
    oldpwd_ = new ::std::string;
  }
  oldpwd_->assign(value);
}
inline void TModifyPwd::set_oldpwd(const char* value, size_t size) {
  set_has_oldpwd();
  if (oldpwd_ == &::google::protobuf::internal::kEmptyString) {
    oldpwd_ = new ::std::string;
  }
  oldpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TModifyPwd::mutable_oldpwd() {
  set_has_oldpwd();
  if (oldpwd_ == &::google::protobuf::internal::kEmptyString) {
    oldpwd_ = new ::std::string;
  }
  return oldpwd_;
}
inline ::std::string* TModifyPwd::release_oldpwd() {
  clear_has_oldpwd();
  if (oldpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldpwd_;
    oldpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TModifyPwd::set_allocated_oldpwd(::std::string* oldpwd) {
  if (oldpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete oldpwd_;
  }
  if (oldpwd) {
    set_has_oldpwd();
    oldpwd_ = oldpwd;
  } else {
    clear_has_oldpwd();
    oldpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string newpwd = 3;
inline bool TModifyPwd::has_newpwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TModifyPwd::set_has_newpwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TModifyPwd::clear_has_newpwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TModifyPwd::clear_newpwd() {
  if (newpwd_ != &::google::protobuf::internal::kEmptyString) {
    newpwd_->clear();
  }
  clear_has_newpwd();
}
inline const ::std::string& TModifyPwd::newpwd() const {
  return *newpwd_;
}
inline void TModifyPwd::set_newpwd(const ::std::string& value) {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  newpwd_->assign(value);
}
inline void TModifyPwd::set_newpwd(const char* value) {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  newpwd_->assign(value);
}
inline void TModifyPwd::set_newpwd(const char* value, size_t size) {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  newpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TModifyPwd::mutable_newpwd() {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  return newpwd_;
}
inline ::std::string* TModifyPwd::release_newpwd() {
  clear_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newpwd_;
    newpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TModifyPwd::set_allocated_newpwd(::std::string* newpwd) {
  if (newpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete newpwd_;
  }
  if (newpwd) {
    set_has_newpwd();
    newpwd_ = newpwd;
  } else {
    clear_has_newpwd();
    newpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImFileShareReq

// optional string destno = 1;
inline bool TImFileShareReq::has_destno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImFileShareReq::set_has_destno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImFileShareReq::clear_has_destno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImFileShareReq::clear_destno() {
  if (destno_ != &::google::protobuf::internal::kEmptyString) {
    destno_->clear();
  }
  clear_has_destno();
}
inline const ::std::string& TImFileShareReq::destno() const {
  return *destno_;
}
inline void TImFileShareReq::set_destno(const ::std::string& value) {
  set_has_destno();
  if (destno_ == &::google::protobuf::internal::kEmptyString) {
    destno_ = new ::std::string;
  }
  destno_->assign(value);
}
inline void TImFileShareReq::set_destno(const char* value) {
  set_has_destno();
  if (destno_ == &::google::protobuf::internal::kEmptyString) {
    destno_ = new ::std::string;
  }
  destno_->assign(value);
}
inline void TImFileShareReq::set_destno(const char* value, size_t size) {
  set_has_destno();
  if (destno_ == &::google::protobuf::internal::kEmptyString) {
    destno_ = new ::std::string;
  }
  destno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFileShareReq::mutable_destno() {
  set_has_destno();
  if (destno_ == &::google::protobuf::internal::kEmptyString) {
    destno_ = new ::std::string;
  }
  return destno_;
}
inline ::std::string* TImFileShareReq::release_destno() {
  clear_has_destno();
  if (destno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = destno_;
    destno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFileShareReq::set_allocated_destno(::std::string* destno) {
  if (destno_ != &::google::protobuf::internal::kEmptyString) {
    delete destno_;
  }
  if (destno) {
    set_has_destno();
    destno_ = destno;
  } else {
    clear_has_destno();
    destno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 filetype = 2;
inline bool TImFileShareReq::has_filetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImFileShareReq::set_has_filetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImFileShareReq::clear_has_filetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImFileShareReq::clear_filetype() {
  filetype_ = 0u;
  clear_has_filetype();
}
inline ::google::protobuf::uint32 TImFileShareReq::filetype() const {
  return filetype_;
}
inline void TImFileShareReq::set_filetype(::google::protobuf::uint32 value) {
  set_has_filetype();
  filetype_ = value;
}

// optional string filepath = 3;
inline bool TImFileShareReq::has_filepath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImFileShareReq::set_has_filepath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImFileShareReq::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImFileShareReq::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& TImFileShareReq::filepath() const {
  return *filepath_;
}
inline void TImFileShareReq::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void TImFileShareReq::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void TImFileShareReq::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFileShareReq::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  return filepath_;
}
inline ::std::string* TImFileShareReq::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFileShareReq::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 filesize = 4;
inline bool TImFileShareReq::has_filesize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImFileShareReq::set_has_filesize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImFileShareReq::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImFileShareReq::clear_filesize() {
  filesize_ = 0u;
  clear_has_filesize();
}
inline ::google::protobuf::uint32 TImFileShareReq::filesize() const {
  return filesize_;
}
inline void TImFileShareReq::set_filesize(::google::protobuf::uint32 value) {
  set_has_filesize();
  filesize_ = value;
}

// optional uint32 contextid = 5;
inline bool TImFileShareReq::has_contextid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImFileShareReq::set_has_contextid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImFileShareReq::clear_has_contextid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImFileShareReq::clear_contextid() {
  contextid_ = 0u;
  clear_has_contextid();
}
inline ::google::protobuf::uint32 TImFileShareReq::contextid() const {
  return contextid_;
}
inline void TImFileShareReq::set_contextid(::google::protobuf::uint32 value) {
  set_has_contextid();
  contextid_ = value;
}

// optional bool overwrite = 6;
inline bool TImFileShareReq::has_overwrite() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TImFileShareReq::set_has_overwrite() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TImFileShareReq::clear_has_overwrite() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TImFileShareReq::clear_overwrite() {
  overwrite_ = false;
  clear_has_overwrite();
}
inline bool TImFileShareReq::overwrite() const {
  return overwrite_;
}
inline void TImFileShareReq::set_overwrite(bool value) {
  set_has_overwrite();
  overwrite_ = value;
}

// -------------------------------------------------------------------

// TImFileShareOfferInfo

// optional string peerno = 1;
inline bool TImFileShareOfferInfo::has_peerno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImFileShareOfferInfo::set_has_peerno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImFileShareOfferInfo::clear_has_peerno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImFileShareOfferInfo::clear_peerno() {
  if (peerno_ != &::google::protobuf::internal::kEmptyString) {
    peerno_->clear();
  }
  clear_has_peerno();
}
inline const ::std::string& TImFileShareOfferInfo::peerno() const {
  return *peerno_;
}
inline void TImFileShareOfferInfo::set_peerno(const ::std::string& value) {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  peerno_->assign(value);
}
inline void TImFileShareOfferInfo::set_peerno(const char* value) {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  peerno_->assign(value);
}
inline void TImFileShareOfferInfo::set_peerno(const char* value, size_t size) {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  peerno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFileShareOfferInfo::mutable_peerno() {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  return peerno_;
}
inline ::std::string* TImFileShareOfferInfo::release_peerno() {
  clear_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peerno_;
    peerno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFileShareOfferInfo::set_allocated_peerno(::std::string* peerno) {
  if (peerno_ != &::google::protobuf::internal::kEmptyString) {
    delete peerno_;
  }
  if (peerno) {
    set_has_peerno();
    peerno_ = peerno;
  } else {
    clear_has_peerno();
    peerno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 filetype = 2;
inline bool TImFileShareOfferInfo::has_filetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImFileShareOfferInfo::set_has_filetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImFileShareOfferInfo::clear_has_filetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImFileShareOfferInfo::clear_filetype() {
  filetype_ = 0u;
  clear_has_filetype();
}
inline ::google::protobuf::uint32 TImFileShareOfferInfo::filetype() const {
  return filetype_;
}
inline void TImFileShareOfferInfo::set_filetype(::google::protobuf::uint32 value) {
  set_has_filetype();
  filetype_ = value;
}

// optional string filename = 3;
inline bool TImFileShareOfferInfo::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImFileShareOfferInfo::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImFileShareOfferInfo::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImFileShareOfferInfo::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& TImFileShareOfferInfo::filename() const {
  return *filename_;
}
inline void TImFileShareOfferInfo::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TImFileShareOfferInfo::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TImFileShareOfferInfo::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFileShareOfferInfo::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* TImFileShareOfferInfo::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFileShareOfferInfo::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 filesize = 4;
inline bool TImFileShareOfferInfo::has_filesize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImFileShareOfferInfo::set_has_filesize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImFileShareOfferInfo::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImFileShareOfferInfo::clear_filesize() {
  filesize_ = 0u;
  clear_has_filesize();
}
inline ::google::protobuf::uint32 TImFileShareOfferInfo::filesize() const {
  return filesize_;
}
inline void TImFileShareOfferInfo::set_filesize(::google::protobuf::uint32 value) {
  set_has_filesize();
  filesize_ = value;
}

// optional bool sender = 5;
inline bool TImFileShareOfferInfo::has_sender() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImFileShareOfferInfo::set_has_sender() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImFileShareOfferInfo::clear_has_sender() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImFileShareOfferInfo::clear_sender() {
  sender_ = false;
  clear_has_sender();
}
inline bool TImFileShareOfferInfo::sender() const {
  return sender_;
}
inline void TImFileShareOfferInfo::set_sender(bool value) {
  set_has_sender();
  sender_ = value;
}

// -------------------------------------------------------------------

// TImFileShareProgress

// optional uint32 percent = 1;
inline bool TImFileShareProgress::has_percent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImFileShareProgress::set_has_percent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImFileShareProgress::clear_has_percent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImFileShareProgress::clear_percent() {
  percent_ = 0u;
  clear_has_percent();
}
inline ::google::protobuf::uint32 TImFileShareProgress::percent() const {
  return percent_;
}
inline void TImFileShareProgress::set_percent(::google::protobuf::uint32 value) {
  set_has_percent();
  percent_ = value;
}

// optional string curfilename = 2;
inline bool TImFileShareProgress::has_curfilename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImFileShareProgress::set_has_curfilename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImFileShareProgress::clear_has_curfilename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImFileShareProgress::clear_curfilename() {
  if (curfilename_ != &::google::protobuf::internal::kEmptyString) {
    curfilename_->clear();
  }
  clear_has_curfilename();
}
inline const ::std::string& TImFileShareProgress::curfilename() const {
  return *curfilename_;
}
inline void TImFileShareProgress::set_curfilename(const ::std::string& value) {
  set_has_curfilename();
  if (curfilename_ == &::google::protobuf::internal::kEmptyString) {
    curfilename_ = new ::std::string;
  }
  curfilename_->assign(value);
}
inline void TImFileShareProgress::set_curfilename(const char* value) {
  set_has_curfilename();
  if (curfilename_ == &::google::protobuf::internal::kEmptyString) {
    curfilename_ = new ::std::string;
  }
  curfilename_->assign(value);
}
inline void TImFileShareProgress::set_curfilename(const char* value, size_t size) {
  set_has_curfilename();
  if (curfilename_ == &::google::protobuf::internal::kEmptyString) {
    curfilename_ = new ::std::string;
  }
  curfilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFileShareProgress::mutable_curfilename() {
  set_has_curfilename();
  if (curfilename_ == &::google::protobuf::internal::kEmptyString) {
    curfilename_ = new ::std::string;
  }
  return curfilename_;
}
inline ::std::string* TImFileShareProgress::release_curfilename() {
  clear_has_curfilename();
  if (curfilename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = curfilename_;
    curfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFileShareProgress::set_allocated_curfilename(::std::string* curfilename) {
  if (curfilename_ != &::google::protobuf::internal::kEmptyString) {
    delete curfilename_;
  }
  if (curfilename) {
    set_has_curfilename();
    curfilename_ = curfilename;
  } else {
    clear_has_curfilename();
    curfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 transfersize = 3;
inline bool TImFileShareProgress::has_transfersize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImFileShareProgress::set_has_transfersize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImFileShareProgress::clear_has_transfersize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImFileShareProgress::clear_transfersize() {
  transfersize_ = 0u;
  clear_has_transfersize();
}
inline ::google::protobuf::uint32 TImFileShareProgress::transfersize() const {
  return transfersize_;
}
inline void TImFileShareProgress::set_transfersize(::google::protobuf::uint32 value) {
  set_has_transfersize();
  transfersize_ = value;
}

// optional uint32 trasferrate = 4;
inline bool TImFileShareProgress::has_trasferrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImFileShareProgress::set_has_trasferrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImFileShareProgress::clear_has_trasferrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImFileShareProgress::clear_trasferrate() {
  trasferrate_ = 0u;
  clear_has_trasferrate();
}
inline ::google::protobuf::uint32 TImFileShareProgress::trasferrate() const {
  return trasferrate_;
}
inline void TImFileShareProgress::set_trasferrate(::google::protobuf::uint32 value) {
  set_has_trasferrate();
  trasferrate_ = value;
}

// -------------------------------------------------------------------

// TImGroupChatFileShareReq

// optional uint32 sessionid = 1;
inline bool TImGroupChatFileShareReq::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImGroupChatFileShareReq::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImGroupChatFileShareReq::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImGroupChatFileShareReq::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TImGroupChatFileShareReq::sessionid() const {
  return sessionid_;
}
inline void TImGroupChatFileShareReq::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional uint32 filetype = 2;
inline bool TImGroupChatFileShareReq::has_filetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImGroupChatFileShareReq::set_has_filetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImGroupChatFileShareReq::clear_has_filetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImGroupChatFileShareReq::clear_filetype() {
  filetype_ = 0u;
  clear_has_filetype();
}
inline ::google::protobuf::uint32 TImGroupChatFileShareReq::filetype() const {
  return filetype_;
}
inline void TImGroupChatFileShareReq::set_filetype(::google::protobuf::uint32 value) {
  set_has_filetype();
  filetype_ = value;
}

// optional string filepath = 3;
inline bool TImGroupChatFileShareReq::has_filepath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImGroupChatFileShareReq::set_has_filepath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImGroupChatFileShareReq::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImGroupChatFileShareReq::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& TImGroupChatFileShareReq::filepath() const {
  return *filepath_;
}
inline void TImGroupChatFileShareReq::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void TImGroupChatFileShareReq::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void TImGroupChatFileShareReq::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImGroupChatFileShareReq::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  return filepath_;
}
inline ::std::string* TImGroupChatFileShareReq::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImGroupChatFileShareReq::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 filesize = 4;
inline bool TImGroupChatFileShareReq::has_filesize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImGroupChatFileShareReq::set_has_filesize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImGroupChatFileShareReq::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImGroupChatFileShareReq::clear_filesize() {
  filesize_ = 0u;
  clear_has_filesize();
}
inline ::google::protobuf::uint32 TImGroupChatFileShareReq::filesize() const {
  return filesize_;
}
inline void TImGroupChatFileShareReq::set_filesize(::google::protobuf::uint32 value) {
  set_has_filesize();
  filesize_ = value;
}

// optional uint32 contextid = 5;
inline bool TImGroupChatFileShareReq::has_contextid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImGroupChatFileShareReq::set_has_contextid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImGroupChatFileShareReq::clear_has_contextid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImGroupChatFileShareReq::clear_contextid() {
  contextid_ = 0u;
  clear_has_contextid();
}
inline ::google::protobuf::uint32 TImGroupChatFileShareReq::contextid() const {
  return contextid_;
}
inline void TImGroupChatFileShareReq::set_contextid(::google::protobuf::uint32 value) {
  set_has_contextid();
  contextid_ = value;
}

// optional string picsessionid = 6;
inline bool TImGroupChatFileShareReq::has_picsessionid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TImGroupChatFileShareReq::set_has_picsessionid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TImGroupChatFileShareReq::clear_has_picsessionid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TImGroupChatFileShareReq::clear_picsessionid() {
  if (picsessionid_ != &::google::protobuf::internal::kEmptyString) {
    picsessionid_->clear();
  }
  clear_has_picsessionid();
}
inline const ::std::string& TImGroupChatFileShareReq::picsessionid() const {
  return *picsessionid_;
}
inline void TImGroupChatFileShareReq::set_picsessionid(const ::std::string& value) {
  set_has_picsessionid();
  if (picsessionid_ == &::google::protobuf::internal::kEmptyString) {
    picsessionid_ = new ::std::string;
  }
  picsessionid_->assign(value);
}
inline void TImGroupChatFileShareReq::set_picsessionid(const char* value) {
  set_has_picsessionid();
  if (picsessionid_ == &::google::protobuf::internal::kEmptyString) {
    picsessionid_ = new ::std::string;
  }
  picsessionid_->assign(value);
}
inline void TImGroupChatFileShareReq::set_picsessionid(const char* value, size_t size) {
  set_has_picsessionid();
  if (picsessionid_ == &::google::protobuf::internal::kEmptyString) {
    picsessionid_ = new ::std::string;
  }
  picsessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImGroupChatFileShareReq::mutable_picsessionid() {
  set_has_picsessionid();
  if (picsessionid_ == &::google::protobuf::internal::kEmptyString) {
    picsessionid_ = new ::std::string;
  }
  return picsessionid_;
}
inline ::std::string* TImGroupChatFileShareReq::release_picsessionid() {
  clear_has_picsessionid();
  if (picsessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picsessionid_;
    picsessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImGroupChatFileShareReq::set_allocated_picsessionid(::std::string* picsessionid) {
  if (picsessionid_ != &::google::protobuf::internal::kEmptyString) {
    delete picsessionid_;
  }
  if (picsessionid) {
    set_has_picsessionid();
    picsessionid_ = picsessionid;
  } else {
    clear_has_picsessionid();
    picsessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TRoomId roomid = 7;
inline bool TImGroupChatFileShareReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TImGroupChatFileShareReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TImGroupChatFileShareReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TImGroupChatFileShareReq::clear_roomid() {
  if (roomid_ != NULL) roomid_->::mt::TRoomId::Clear();
  clear_has_roomid();
}
inline const ::mt::TRoomId& TImGroupChatFileShareReq::roomid() const {
  return roomid_ != NULL ? *roomid_ : *default_instance_->roomid_;
}
inline ::mt::TRoomId* TImGroupChatFileShareReq::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == NULL) roomid_ = new ::mt::TRoomId;
  return roomid_;
}
inline ::mt::TRoomId* TImGroupChatFileShareReq::release_roomid() {
  clear_has_roomid();
  ::mt::TRoomId* temp = roomid_;
  roomid_ = NULL;
  return temp;
}
inline void TImGroupChatFileShareReq::set_allocated_roomid(::mt::TRoomId* roomid) {
  delete roomid_;
  roomid_ = roomid;
  if (roomid) {
    set_has_roomid();
  } else {
    clear_has_roomid();
  }
}

// optional bool overwrite = 8;
inline bool TImGroupChatFileShareReq::has_overwrite() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TImGroupChatFileShareReq::set_has_overwrite() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TImGroupChatFileShareReq::clear_has_overwrite() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TImGroupChatFileShareReq::clear_overwrite() {
  overwrite_ = false;
  clear_has_overwrite();
}
inline bool TImGroupChatFileShareReq::overwrite() const {
  return overwrite_;
}
inline void TImGroupChatFileShareReq::set_overwrite(bool value) {
  set_has_overwrite();
  overwrite_ = value;
}

// -------------------------------------------------------------------

// TImChatRoomInfo

// optional uint32 sessionid = 1;
inline bool TImChatRoomInfo::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImChatRoomInfo::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImChatRoomInfo::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImChatRoomInfo::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TImChatRoomInfo::sessionid() const {
  return sessionid_;
}
inline void TImChatRoomInfo::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional string chatname = 2;
inline bool TImChatRoomInfo::has_chatname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImChatRoomInfo::set_has_chatname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImChatRoomInfo::clear_has_chatname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImChatRoomInfo::clear_chatname() {
  if (chatname_ != &::google::protobuf::internal::kEmptyString) {
    chatname_->clear();
  }
  clear_has_chatname();
}
inline const ::std::string& TImChatRoomInfo::chatname() const {
  return *chatname_;
}
inline void TImChatRoomInfo::set_chatname(const ::std::string& value) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(value);
}
inline void TImChatRoomInfo::set_chatname(const char* value) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(value);
}
inline void TImChatRoomInfo::set_chatname(const char* value, size_t size) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImChatRoomInfo::mutable_chatname() {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  return chatname_;
}
inline ::std::string* TImChatRoomInfo::release_chatname() {
  clear_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chatname_;
    chatname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImChatRoomInfo::set_allocated_chatname(::std::string* chatname) {
  if (chatname_ != &::google::protobuf::internal::kEmptyString) {
    delete chatname_;
  }
  if (chatname) {
    set_has_chatname();
    chatname_ = chatname;
  } else {
    clear_has_chatname();
    chatname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TRoomId roomid = 3;
inline bool TImChatRoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImChatRoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImChatRoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImChatRoomInfo::clear_roomid() {
  if (roomid_ != NULL) roomid_->::mt::TRoomId::Clear();
  clear_has_roomid();
}
inline const ::mt::TRoomId& TImChatRoomInfo::roomid() const {
  return roomid_ != NULL ? *roomid_ : *default_instance_->roomid_;
}
inline ::mt::TRoomId* TImChatRoomInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == NULL) roomid_ = new ::mt::TRoomId;
  return roomid_;
}
inline ::mt::TRoomId* TImChatRoomInfo::release_roomid() {
  clear_has_roomid();
  ::mt::TRoomId* temp = roomid_;
  roomid_ = NULL;
  return temp;
}
inline void TImChatRoomInfo::set_allocated_roomid(::mt::TRoomId* roomid) {
  delete roomid_;
  roomid_ = roomid;
  if (roomid) {
    set_has_roomid();
  } else {
    clear_has_roomid();
  }
}

// -------------------------------------------------------------------

// TDeclineInfo

// optional string chatname = 1;
inline bool TDeclineInfo::has_chatname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDeclineInfo::set_has_chatname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDeclineInfo::clear_has_chatname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDeclineInfo::clear_chatname() {
  if (chatname_ != &::google::protobuf::internal::kEmptyString) {
    chatname_->clear();
  }
  clear_has_chatname();
}
inline const ::std::string& TDeclineInfo::chatname() const {
  return *chatname_;
}
inline void TDeclineInfo::set_chatname(const ::std::string& value) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(value);
}
inline void TDeclineInfo::set_chatname(const char* value) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(value);
}
inline void TDeclineInfo::set_chatname(const char* value, size_t size) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDeclineInfo::mutable_chatname() {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  return chatname_;
}
inline ::std::string* TDeclineInfo::release_chatname() {
  clear_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chatname_;
    chatname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDeclineInfo::set_allocated_chatname(::std::string* chatname) {
  if (chatname_ != &::google::protobuf::internal::kEmptyString) {
    delete chatname_;
  }
  if (chatname) {
    set_has_chatname();
    chatname_ = chatname;
  } else {
    clear_has_chatname();
    chatname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string roomid = 2;
inline bool TDeclineInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDeclineInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDeclineInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDeclineInfo::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& TDeclineInfo::roomid() const {
  return *roomid_;
}
inline void TDeclineInfo::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TDeclineInfo::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TDeclineInfo::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDeclineInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* TDeclineInfo::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDeclineInfo::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string declineno = 3;
inline bool TDeclineInfo::has_declineno() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TDeclineInfo::set_has_declineno() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TDeclineInfo::clear_has_declineno() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TDeclineInfo::clear_declineno() {
  if (declineno_ != &::google::protobuf::internal::kEmptyString) {
    declineno_->clear();
  }
  clear_has_declineno();
}
inline const ::std::string& TDeclineInfo::declineno() const {
  return *declineno_;
}
inline void TDeclineInfo::set_declineno(const ::std::string& value) {
  set_has_declineno();
  if (declineno_ == &::google::protobuf::internal::kEmptyString) {
    declineno_ = new ::std::string;
  }
  declineno_->assign(value);
}
inline void TDeclineInfo::set_declineno(const char* value) {
  set_has_declineno();
  if (declineno_ == &::google::protobuf::internal::kEmptyString) {
    declineno_ = new ::std::string;
  }
  declineno_->assign(value);
}
inline void TDeclineInfo::set_declineno(const char* value, size_t size) {
  set_has_declineno();
  if (declineno_ == &::google::protobuf::internal::kEmptyString) {
    declineno_ = new ::std::string;
  }
  declineno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDeclineInfo::mutable_declineno() {
  set_has_declineno();
  if (declineno_ == &::google::protobuf::internal::kEmptyString) {
    declineno_ = new ::std::string;
  }
  return declineno_;
}
inline ::std::string* TDeclineInfo::release_declineno() {
  clear_has_declineno();
  if (declineno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = declineno_;
    declineno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDeclineInfo::set_allocated_declineno(::std::string* declineno) {
  if (declineno_ != &::google::protobuf::internal::kEmptyString) {
    delete declineno_;
  }
  if (declineno) {
    set_has_declineno();
    declineno_ = declineno;
  } else {
    clear_has_declineno();
    declineno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EImDeclineReason reason = 4;
inline bool TDeclineInfo::has_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TDeclineInfo::set_has_reason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TDeclineInfo::clear_has_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TDeclineInfo::clear_reason() {
  reason_ = 1;
  clear_has_reason();
}
inline ::mt::EImDeclineReason TDeclineInfo::reason() const {
  return static_cast< ::mt::EImDeclineReason >(reason_);
}
inline void TDeclineInfo::set_reason(::mt::EImDeclineReason value) {
  assert(::mt::EImDeclineReason_IsValid(value));
  set_has_reason();
  reason_ = value;
}

// -------------------------------------------------------------------

// TImMultiChatRosterItem

// optional string no = 1;
inline bool TImMultiChatRosterItem::has_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImMultiChatRosterItem::set_has_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImMultiChatRosterItem::clear_has_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImMultiChatRosterItem::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TImMultiChatRosterItem::no() const {
  return *no_;
}
inline void TImMultiChatRosterItem::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImMultiChatRosterItem::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImMultiChatRosterItem::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMultiChatRosterItem::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TImMultiChatRosterItem::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMultiChatRosterItem::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool owner = 2;
inline bool TImMultiChatRosterItem::has_owner() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImMultiChatRosterItem::set_has_owner() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImMultiChatRosterItem::clear_has_owner() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImMultiChatRosterItem::clear_owner() {
  owner_ = false;
  clear_has_owner();
}
inline bool TImMultiChatRosterItem::owner() const {
  return owner_;
}
inline void TImMultiChatRosterItem::set_owner(bool value) {
  set_has_owner();
  owner_ = value;
}

// optional bool self = 3;
inline bool TImMultiChatRosterItem::has_self() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImMultiChatRosterItem::set_has_self() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImMultiChatRosterItem::clear_has_self() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImMultiChatRosterItem::clear_self() {
  self_ = false;
  clear_has_self();
}
inline bool TImMultiChatRosterItem::self() const {
  return self_;
}
inline void TImMultiChatRosterItem::set_self(bool value) {
  set_has_self();
  self_ = value;
}

// -------------------------------------------------------------------

// TImMultiChatRosterItemList

// optional uint32 sessionid = 1;
inline bool TImMultiChatRosterItemList::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImMultiChatRosterItemList::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImMultiChatRosterItemList::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImMultiChatRosterItemList::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TImMultiChatRosterItemList::sessionid() const {
  return sessionid_;
}
inline void TImMultiChatRosterItemList::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional uint32 arraysize = 2;
inline bool TImMultiChatRosterItemList::has_arraysize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImMultiChatRosterItemList::set_has_arraysize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImMultiChatRosterItemList::clear_has_arraysize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImMultiChatRosterItemList::clear_arraysize() {
  arraysize_ = 0u;
  clear_has_arraysize();
}
inline ::google::protobuf::uint32 TImMultiChatRosterItemList::arraysize() const {
  return arraysize_;
}
inline void TImMultiChatRosterItemList::set_arraysize(::google::protobuf::uint32 value) {
  set_has_arraysize();
  arraysize_ = value;
}

// repeated .mt.TImMultiChatRosterItem array = 3;
inline int TImMultiChatRosterItemList::array_size() const {
  return array_.size();
}
inline void TImMultiChatRosterItemList::clear_array() {
  array_.Clear();
}
inline const ::mt::TImMultiChatRosterItem& TImMultiChatRosterItemList::array(int index) const {
  return array_.Get(index);
}
inline ::mt::TImMultiChatRosterItem* TImMultiChatRosterItemList::mutable_array(int index) {
  return array_.Mutable(index);
}
inline ::mt::TImMultiChatRosterItem* TImMultiChatRosterItemList::add_array() {
  return array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImMultiChatRosterItem >&
TImMultiChatRosterItemList::array() const {
  return array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImMultiChatRosterItem >*
TImMultiChatRosterItemList::mutable_array() {
  return &array_;
}

// optional .mt.TRoomId roomid = 4;
inline bool TImMultiChatRosterItemList::has_roomid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImMultiChatRosterItemList::set_has_roomid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImMultiChatRosterItemList::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImMultiChatRosterItemList::clear_roomid() {
  if (roomid_ != NULL) roomid_->::mt::TRoomId::Clear();
  clear_has_roomid();
}
inline const ::mt::TRoomId& TImMultiChatRosterItemList::roomid() const {
  return roomid_ != NULL ? *roomid_ : *default_instance_->roomid_;
}
inline ::mt::TRoomId* TImMultiChatRosterItemList::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == NULL) roomid_ = new ::mt::TRoomId;
  return roomid_;
}
inline ::mt::TRoomId* TImMultiChatRosterItemList::release_roomid() {
  clear_has_roomid();
  ::mt::TRoomId* temp = roomid_;
  roomid_ = NULL;
  return temp;
}
inline void TImMultiChatRosterItemList::set_allocated_roomid(::mt::TRoomId* roomid) {
  delete roomid_;
  roomid_ = roomid;
  if (roomid) {
    set_has_roomid();
  } else {
    clear_has_roomid();
  }
}

// -------------------------------------------------------------------

// TImMultiChatAddMembernotify

// optional uint32 sessionid = 1;
inline bool TImMultiChatAddMembernotify::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImMultiChatAddMembernotify::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImMultiChatAddMembernotify::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImMultiChatAddMembernotify::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TImMultiChatAddMembernotify::sessionid() const {
  return sessionid_;
}
inline void TImMultiChatAddMembernotify::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional string no = 2;
inline bool TImMultiChatAddMembernotify::has_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImMultiChatAddMembernotify::set_has_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImMultiChatAddMembernotify::clear_has_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImMultiChatAddMembernotify::clear_no() {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TImMultiChatAddMembernotify::no() const {
  return *no_;
}
inline void TImMultiChatAddMembernotify::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImMultiChatAddMembernotify::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(value);
}
inline void TImMultiChatAddMembernotify::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMultiChatAddMembernotify::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    no_ = new ::std::string;
  }
  return no_;
}
inline ::std::string* TImMultiChatAddMembernotify::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMultiChatAddMembernotify::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::kEmptyString) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TRoomId roomid = 3;
inline bool TImMultiChatAddMembernotify::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImMultiChatAddMembernotify::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImMultiChatAddMembernotify::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImMultiChatAddMembernotify::clear_roomid() {
  if (roomid_ != NULL) roomid_->::mt::TRoomId::Clear();
  clear_has_roomid();
}
inline const ::mt::TRoomId& TImMultiChatAddMembernotify::roomid() const {
  return roomid_ != NULL ? *roomid_ : *default_instance_->roomid_;
}
inline ::mt::TRoomId* TImMultiChatAddMembernotify::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == NULL) roomid_ = new ::mt::TRoomId;
  return roomid_;
}
inline ::mt::TRoomId* TImMultiChatAddMembernotify::release_roomid() {
  clear_has_roomid();
  ::mt::TRoomId* temp = roomid_;
  roomid_ = NULL;
  return temp;
}
inline void TImMultiChatAddMembernotify::set_allocated_roomid(::mt::TRoomId* roomid) {
  delete roomid_;
  roomid_ = roomid;
  if (roomid) {
    set_has_roomid();
  } else {
    clear_has_roomid();
  }
}

// -------------------------------------------------------------------

// TImCharState

// optional string peerno = 1;
inline bool TImCharState::has_peerno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImCharState::set_has_peerno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImCharState::clear_has_peerno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImCharState::clear_peerno() {
  if (peerno_ != &::google::protobuf::internal::kEmptyString) {
    peerno_->clear();
  }
  clear_has_peerno();
}
inline const ::std::string& TImCharState::peerno() const {
  return *peerno_;
}
inline void TImCharState::set_peerno(const ::std::string& value) {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  peerno_->assign(value);
}
inline void TImCharState::set_peerno(const char* value) {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  peerno_->assign(value);
}
inline void TImCharState::set_peerno(const char* value, size_t size) {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  peerno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImCharState::mutable_peerno() {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  return peerno_;
}
inline ::std::string* TImCharState::release_peerno() {
  clear_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peerno_;
    peerno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImCharState::set_allocated_peerno(::std::string* peerno) {
  if (peerno_ != &::google::protobuf::internal::kEmptyString) {
    delete peerno_;
  }
  if (peerno) {
    set_has_peerno();
    peerno_ = peerno;
  } else {
    clear_has_peerno();
    peerno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtImTerminalType mttype = 2;
inline bool TImCharState::has_mttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImCharState::set_has_mttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImCharState::clear_has_mttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImCharState::clear_mttype() {
  mttype_ = 0;
  clear_has_mttype();
}
inline ::mt::EmMtImTerminalType TImCharState::mttype() const {
  return static_cast< ::mt::EmMtImTerminalType >(mttype_);
}
inline void TImCharState::set_mttype(::mt::EmMtImTerminalType value) {
  assert(::mt::EmMtImTerminalType_IsValid(value));
  set_has_mttype();
  mttype_ = value;
}

// optional .mt.EImCharState charstate = 3;
inline bool TImCharState::has_charstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImCharState::set_has_charstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImCharState::clear_has_charstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImCharState::clear_charstate() {
  charstate_ = 0;
  clear_has_charstate();
}
inline ::mt::EImCharState TImCharState::charstate() const {
  return static_cast< ::mt::EImCharState >(charstate_);
}
inline void TImCharState::set_charstate(::mt::EImCharState value) {
  assert(::mt::EImCharState_IsValid(value));
  set_has_charstate();
  charstate_ = value;
}

// -------------------------------------------------------------------

// TImSplash

// optional string peerno = 1;
inline bool TImSplash::has_peerno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImSplash::set_has_peerno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImSplash::clear_has_peerno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImSplash::clear_peerno() {
  if (peerno_ != &::google::protobuf::internal::kEmptyString) {
    peerno_->clear();
  }
  clear_has_peerno();
}
inline const ::std::string& TImSplash::peerno() const {
  return *peerno_;
}
inline void TImSplash::set_peerno(const ::std::string& value) {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  peerno_->assign(value);
}
inline void TImSplash::set_peerno(const char* value) {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  peerno_->assign(value);
}
inline void TImSplash::set_peerno(const char* value, size_t size) {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  peerno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImSplash::mutable_peerno() {
  set_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    peerno_ = new ::std::string;
  }
  return peerno_;
}
inline ::std::string* TImSplash::release_peerno() {
  clear_has_peerno();
  if (peerno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peerno_;
    peerno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImSplash::set_allocated_peerno(::std::string* peerno) {
  if (peerno_ != &::google::protobuf::internal::kEmptyString) {
    delete peerno_;
  }
  if (peerno) {
    set_has_peerno();
    peerno_ = peerno;
  } else {
    clear_has_peerno();
    peerno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtImTerminalType mttype = 2;
inline bool TImSplash::has_mttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImSplash::set_has_mttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImSplash::clear_has_mttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImSplash::clear_mttype() {
  mttype_ = 0;
  clear_has_mttype();
}
inline ::mt::EmMtImTerminalType TImSplash::mttype() const {
  return static_cast< ::mt::EmMtImTerminalType >(mttype_);
}
inline void TImSplash::set_mttype(::mt::EmMtImTerminalType value) {
  assert(::mt::EmMtImTerminalType_IsValid(value));
  set_has_mttype();
  mttype_ = value;
}

// optional uint32 splashtype = 3;
inline bool TImSplash::has_splashtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImSplash::set_has_splashtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImSplash::clear_has_splashtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImSplash::clear_splashtype() {
  splashtype_ = 0u;
  clear_has_splashtype();
}
inline ::google::protobuf::uint32 TImSplash::splashtype() const {
  return splashtype_;
}
inline void TImSplash::set_splashtype(::google::protobuf::uint32 value) {
  set_has_splashtype();
  splashtype_ = value;
}

// -------------------------------------------------------------------

// TImCustomCfgItem

// optional string key = 1;
inline bool TImCustomCfgItem::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImCustomCfgItem::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImCustomCfgItem::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImCustomCfgItem::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& TImCustomCfgItem::key() const {
  return *key_;
}
inline void TImCustomCfgItem::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TImCustomCfgItem::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TImCustomCfgItem::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImCustomCfgItem::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* TImCustomCfgItem::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImCustomCfgItem::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool TImCustomCfgItem::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImCustomCfgItem::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImCustomCfgItem::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImCustomCfgItem::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& TImCustomCfgItem::value() const {
  return *value_;
}
inline void TImCustomCfgItem::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TImCustomCfgItem::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TImCustomCfgItem::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImCustomCfgItem::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* TImCustomCfgItem::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImCustomCfgItem::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImCustomCfg

// repeated .mt.TImCustomCfgItem items = 1;
inline int TImCustomCfg::items_size() const {
  return items_.size();
}
inline void TImCustomCfg::clear_items() {
  items_.Clear();
}
inline const ::mt::TImCustomCfgItem& TImCustomCfg::items(int index) const {
  return items_.Get(index);
}
inline ::mt::TImCustomCfgItem* TImCustomCfg::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::mt::TImCustomCfgItem* TImCustomCfg::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImCustomCfgItem >&
TImCustomCfg::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImCustomCfgItem >*
TImCustomCfg::mutable_items() {
  return &items_;
}

// optional uint32 itemscnt = 2;
inline bool TImCustomCfg::has_itemscnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImCustomCfg::set_has_itemscnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImCustomCfg::clear_has_itemscnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImCustomCfg::clear_itemscnt() {
  itemscnt_ = 0u;
  clear_has_itemscnt();
}
inline ::google::protobuf::uint32 TImCustomCfg::itemscnt() const {
  return itemscnt_;
}
inline void TImCustomCfg::set_itemscnt(::google::protobuf::uint32 value) {
  set_has_itemscnt();
  itemscnt_ = value;
}

// optional bool get = 3;
inline bool TImCustomCfg::has_get() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImCustomCfg::set_has_get() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImCustomCfg::clear_has_get() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImCustomCfg::clear_get() {
  get_ = false;
  clear_has_get();
}
inline bool TImCustomCfg::get() const {
  return get_;
}
inline void TImCustomCfg::set_get(bool value) {
  set_has_get();
  get_ = value;
}

// -------------------------------------------------------------------

// TImScreenChatroom

// optional bool screen = 1;
inline bool TImScreenChatroom::has_screen() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImScreenChatroom::set_has_screen() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImScreenChatroom::clear_has_screen() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImScreenChatroom::clear_screen() {
  screen_ = false;
  clear_has_screen();
}
inline bool TImScreenChatroom::screen() const {
  return screen_;
}
inline void TImScreenChatroom::set_screen(bool value) {
  set_has_screen();
  screen_ = value;
}

// optional string roomid = 2;
inline bool TImScreenChatroom::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImScreenChatroom::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImScreenChatroom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImScreenChatroom::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& TImScreenChatroom::roomid() const {
  return *roomid_;
}
inline void TImScreenChatroom::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TImScreenChatroom::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TImScreenChatroom::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImScreenChatroom::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* TImScreenChatroom::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImScreenChatroom::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImScreenedChatrooms

// repeated string roomids = 1;
inline int TImScreenedChatrooms::roomids_size() const {
  return roomids_.size();
}
inline void TImScreenedChatrooms::clear_roomids() {
  roomids_.Clear();
}
inline const ::std::string& TImScreenedChatrooms::roomids(int index) const {
  return roomids_.Get(index);
}
inline ::std::string* TImScreenedChatrooms::mutable_roomids(int index) {
  return roomids_.Mutable(index);
}
inline void TImScreenedChatrooms::set_roomids(int index, const ::std::string& value) {
  roomids_.Mutable(index)->assign(value);
}
inline void TImScreenedChatrooms::set_roomids(int index, const char* value) {
  roomids_.Mutable(index)->assign(value);
}
inline void TImScreenedChatrooms::set_roomids(int index, const char* value, size_t size) {
  roomids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImScreenedChatrooms::add_roomids() {
  return roomids_.Add();
}
inline void TImScreenedChatrooms::add_roomids(const ::std::string& value) {
  roomids_.Add()->assign(value);
}
inline void TImScreenedChatrooms::add_roomids(const char* value) {
  roomids_.Add()->assign(value);
}
inline void TImScreenedChatrooms::add_roomids(const char* value, size_t size) {
  roomids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TImScreenedChatrooms::roomids() const {
  return roomids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TImScreenedChatrooms::mutable_roomids() {
  return &roomids_;
}

// optional uint32 count = 2;
inline bool TImScreenedChatrooms::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImScreenedChatrooms::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImScreenedChatrooms::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImScreenedChatrooms::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TImScreenedChatrooms::count() const {
  return count_;
}
inline void TImScreenedChatrooms::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// TImScreenChatroomR

// optional bool screen = 1;
inline bool TImScreenChatroomR::has_screen() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImScreenChatroomR::set_has_screen() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImScreenChatroomR::clear_has_screen() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImScreenChatroomR::clear_screen() {
  screen_ = false;
  clear_has_screen();
}
inline bool TImScreenChatroomR::screen() const {
  return screen_;
}
inline void TImScreenChatroomR::set_screen(bool value) {
  set_has_screen();
  screen_ = value;
}

// repeated string roomids = 2;
inline int TImScreenChatroomR::roomids_size() const {
  return roomids_.size();
}
inline void TImScreenChatroomR::clear_roomids() {
  roomids_.Clear();
}
inline const ::std::string& TImScreenChatroomR::roomids(int index) const {
  return roomids_.Get(index);
}
inline ::std::string* TImScreenChatroomR::mutable_roomids(int index) {
  return roomids_.Mutable(index);
}
inline void TImScreenChatroomR::set_roomids(int index, const ::std::string& value) {
  roomids_.Mutable(index)->assign(value);
}
inline void TImScreenChatroomR::set_roomids(int index, const char* value) {
  roomids_.Mutable(index)->assign(value);
}
inline void TImScreenChatroomR::set_roomids(int index, const char* value, size_t size) {
  roomids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImScreenChatroomR::add_roomids() {
  return roomids_.Add();
}
inline void TImScreenChatroomR::add_roomids(const ::std::string& value) {
  roomids_.Add()->assign(value);
}
inline void TImScreenChatroomR::add_roomids(const char* value) {
  roomids_.Add()->assign(value);
}
inline void TImScreenChatroomR::add_roomids(const char* value, size_t size) {
  roomids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TImScreenChatroomR::roomids() const {
  return roomids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TImScreenChatroomR::mutable_roomids() {
  return &roomids_;
}

// optional uint32 count = 3;
inline bool TImScreenChatroomR::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImScreenChatroomR::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImScreenChatroomR::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImScreenChatroomR::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TImScreenChatroomR::count() const {
  return count_;
}
inline void TImScreenChatroomR::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// TChatroomMemberCacheItem

// optional string eventid = 1;
inline bool TChatroomMemberCacheItem::has_eventid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TChatroomMemberCacheItem::set_has_eventid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TChatroomMemberCacheItem::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TChatroomMemberCacheItem::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& TChatroomMemberCacheItem::eventid() const {
  return *eventid_;
}
inline void TChatroomMemberCacheItem::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void TChatroomMemberCacheItem::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void TChatroomMemberCacheItem::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TChatroomMemberCacheItem::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* TChatroomMemberCacheItem::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TChatroomMemberCacheItem::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 app = 2;
inline bool TChatroomMemberCacheItem::has_app() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TChatroomMemberCacheItem::set_has_app() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TChatroomMemberCacheItem::clear_has_app() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TChatroomMemberCacheItem::clear_app() {
  app_ = 0u;
  clear_has_app();
}
inline ::google::protobuf::uint32 TChatroomMemberCacheItem::app() const {
  return app_;
}
inline void TChatroomMemberCacheItem::set_app(::google::protobuf::uint32 value) {
  set_has_app();
  app_ = value;
}

// optional .mt.TImMultiChatMemberInfoEx info = 3;
inline bool TChatroomMemberCacheItem::has_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TChatroomMemberCacheItem::set_has_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TChatroomMemberCacheItem::clear_has_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TChatroomMemberCacheItem::clear_info() {
  if (info_ != NULL) info_->::mt::TImMultiChatMemberInfoEx::Clear();
  clear_has_info();
}
inline const ::mt::TImMultiChatMemberInfoEx& TChatroomMemberCacheItem::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::mt::TImMultiChatMemberInfoEx* TChatroomMemberCacheItem::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::mt::TImMultiChatMemberInfoEx;
  return info_;
}
inline ::mt::TImMultiChatMemberInfoEx* TChatroomMemberCacheItem::release_info() {
  clear_has_info();
  ::mt::TImMultiChatMemberInfoEx* temp = info_;
  info_ = NULL;
  return temp;
}
inline void TChatroomMemberCacheItem::set_allocated_info(::mt::TImMultiChatMemberInfoEx* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// TChatroomMemberCacheList

// optional uint32 arraysize = 1;
inline bool TChatroomMemberCacheList::has_arraysize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TChatroomMemberCacheList::set_has_arraysize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TChatroomMemberCacheList::clear_has_arraysize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TChatroomMemberCacheList::clear_arraysize() {
  arraysize_ = 0u;
  clear_has_arraysize();
}
inline ::google::protobuf::uint32 TChatroomMemberCacheList::arraysize() const {
  return arraysize_;
}
inline void TChatroomMemberCacheList::set_arraysize(::google::protobuf::uint32 value) {
  set_has_arraysize();
  arraysize_ = value;
}

// repeated .mt.TChatroomMemberCacheItem array = 2;
inline int TChatroomMemberCacheList::array_size() const {
  return array_.size();
}
inline void TChatroomMemberCacheList::clear_array() {
  array_.Clear();
}
inline const ::mt::TChatroomMemberCacheItem& TChatroomMemberCacheList::array(int index) const {
  return array_.Get(index);
}
inline ::mt::TChatroomMemberCacheItem* TChatroomMemberCacheList::mutable_array(int index) {
  return array_.Mutable(index);
}
inline ::mt::TChatroomMemberCacheItem* TChatroomMemberCacheList::add_array() {
  return array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TChatroomMemberCacheItem >&
TChatroomMemberCacheList::array() const {
  return array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TChatroomMemberCacheItem >*
TChatroomMemberCacheList::mutable_array() {
  return &array_;
}

// -------------------------------------------------------------------

// TWeiboOnlineInfo

// optional string uid = 1;
inline bool TWeiboOnlineInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWeiboOnlineInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWeiboOnlineInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWeiboOnlineInfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& TWeiboOnlineInfo::uid() const {
  return *uid_;
}
inline void TWeiboOnlineInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void TWeiboOnlineInfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void TWeiboOnlineInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWeiboOnlineInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* TWeiboOnlineInfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWeiboOnlineInfo::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 id = 2;
inline bool TWeiboOnlineInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWeiboOnlineInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWeiboOnlineInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWeiboOnlineInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TWeiboOnlineInfo::id() const {
  return id_;
}
inline void TWeiboOnlineInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 3;
inline bool TWeiboOnlineInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TWeiboOnlineInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TWeiboOnlineInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TWeiboOnlineInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TWeiboOnlineInfo::name() const {
  return *name_;
}
inline void TWeiboOnlineInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TWeiboOnlineInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TWeiboOnlineInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWeiboOnlineInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TWeiboOnlineInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWeiboOnlineInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 4;
inline bool TWeiboOnlineInfo::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TWeiboOnlineInfo::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TWeiboOnlineInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TWeiboOnlineInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& TWeiboOnlineInfo::email() const {
  return *email_;
}
inline void TWeiboOnlineInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TWeiboOnlineInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TWeiboOnlineInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWeiboOnlineInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* TWeiboOnlineInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWeiboOnlineInfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mugshot64 = 5;
inline bool TWeiboOnlineInfo::has_mugshot64() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TWeiboOnlineInfo::set_has_mugshot64() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TWeiboOnlineInfo::clear_has_mugshot64() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TWeiboOnlineInfo::clear_mugshot64() {
  if (mugshot64_ != &::google::protobuf::internal::kEmptyString) {
    mugshot64_->clear();
  }
  clear_has_mugshot64();
}
inline const ::std::string& TWeiboOnlineInfo::mugshot64() const {
  return *mugshot64_;
}
inline void TWeiboOnlineInfo::set_mugshot64(const ::std::string& value) {
  set_has_mugshot64();
  if (mugshot64_ == &::google::protobuf::internal::kEmptyString) {
    mugshot64_ = new ::std::string;
  }
  mugshot64_->assign(value);
}
inline void TWeiboOnlineInfo::set_mugshot64(const char* value) {
  set_has_mugshot64();
  if (mugshot64_ == &::google::protobuf::internal::kEmptyString) {
    mugshot64_ = new ::std::string;
  }
  mugshot64_->assign(value);
}
inline void TWeiboOnlineInfo::set_mugshot64(const char* value, size_t size) {
  set_has_mugshot64();
  if (mugshot64_ == &::google::protobuf::internal::kEmptyString) {
    mugshot64_ = new ::std::string;
  }
  mugshot64_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWeiboOnlineInfo::mutable_mugshot64() {
  set_has_mugshot64();
  if (mugshot64_ == &::google::protobuf::internal::kEmptyString) {
    mugshot64_ = new ::std::string;
  }
  return mugshot64_;
}
inline ::std::string* TWeiboOnlineInfo::release_mugshot64() {
  clear_has_mugshot64();
  if (mugshot64_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mugshot64_;
    mugshot64_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWeiboOnlineInfo::set_allocated_mugshot64(::std::string* mugshot64) {
  if (mugshot64_ != &::google::protobuf::internal::kEmptyString) {
    delete mugshot64_;
  }
  if (mugshot64) {
    set_has_mugshot64();
    mugshot64_ = mugshot64;
  } else {
    clear_has_mugshot64();
    mugshot64_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TWeiboCommonInfo

// optional string uid = 1;
inline bool TWeiboCommonInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWeiboCommonInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWeiboCommonInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWeiboCommonInfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& TWeiboCommonInfo::uid() const {
  return *uid_;
}
inline void TWeiboCommonInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void TWeiboCommonInfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void TWeiboCommonInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWeiboCommonInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* TWeiboCommonInfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWeiboCommonInfo::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 amount = 2;
inline bool TWeiboCommonInfo::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWeiboCommonInfo::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWeiboCommonInfo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWeiboCommonInfo::clear_amount() {
  amount_ = 0u;
  clear_has_amount();
}
inline ::google::protobuf::uint32 TWeiboCommonInfo::amount() const {
  return amount_;
}
inline void TWeiboCommonInfo::set_amount(::google::protobuf::uint32 value) {
  set_has_amount();
  amount_ = value;
}

// -------------------------------------------------------------------

// TWeiboNewFeedInfo

// optional uint32 feedid = 1;
inline bool TWeiboNewFeedInfo::has_feedid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWeiboNewFeedInfo::set_has_feedid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWeiboNewFeedInfo::clear_has_feedid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWeiboNewFeedInfo::clear_feedid() {
  feedid_ = 0u;
  clear_has_feedid();
}
inline ::google::protobuf::uint32 TWeiboNewFeedInfo::feedid() const {
  return feedid_;
}
inline void TWeiboNewFeedInfo::set_feedid(::google::protobuf::uint32 value) {
  set_has_feedid();
  feedid_ = value;
}

// optional uint32 groupid = 2;
inline bool TWeiboNewFeedInfo::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWeiboNewFeedInfo::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWeiboNewFeedInfo::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWeiboNewFeedInfo::clear_groupid() {
  groupid_ = 0u;
  clear_has_groupid();
}
inline ::google::protobuf::uint32 TWeiboNewFeedInfo::groupid() const {
  return groupid_;
}
inline void TWeiboNewFeedInfo::set_groupid(::google::protobuf::uint32 value) {
  set_has_groupid();
  groupid_ = value;
}

// optional uint32 groupuid = 3;
inline bool TWeiboNewFeedInfo::has_groupuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TWeiboNewFeedInfo::set_has_groupuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TWeiboNewFeedInfo::clear_has_groupuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TWeiboNewFeedInfo::clear_groupuid() {
  groupuid_ = 0u;
  clear_has_groupuid();
}
inline ::google::protobuf::uint32 TWeiboNewFeedInfo::groupuid() const {
  return groupuid_;
}
inline void TWeiboNewFeedInfo::set_groupuid(::google::protobuf::uint32 value) {
  set_has_groupuid();
  groupuid_ = value;
}

// optional string groupname = 4;
inline bool TWeiboNewFeedInfo::has_groupname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TWeiboNewFeedInfo::set_has_groupname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TWeiboNewFeedInfo::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TWeiboNewFeedInfo::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& TWeiboNewFeedInfo::groupname() const {
  return *groupname_;
}
inline void TWeiboNewFeedInfo::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void TWeiboNewFeedInfo::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void TWeiboNewFeedInfo::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWeiboNewFeedInfo::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* TWeiboNewFeedInfo::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWeiboNewFeedInfo::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 amount = 5;
inline bool TWeiboNewFeedInfo::has_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TWeiboNewFeedInfo::set_has_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TWeiboNewFeedInfo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TWeiboNewFeedInfo::clear_amount() {
  amount_ = 0u;
  clear_has_amount();
}
inline ::google::protobuf::uint32 TWeiboNewFeedInfo::amount() const {
  return amount_;
}
inline void TWeiboNewFeedInfo::set_amount(::google::protobuf::uint32 value) {
  set_has_amount();
  amount_ = value;
}

// -------------------------------------------------------------------

// TMeetingnotify

// optional .mt.EmRestMeetingNotifyType notifytype = 1;
inline bool TMeetingnotify::has_notifytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMeetingnotify::set_has_notifytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMeetingnotify::clear_has_notifytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMeetingnotify::clear_notifytype() {
  notifytype_ = 0;
  clear_has_notifytype();
}
inline ::mt::EmRestMeetingNotifyType TMeetingnotify::notifytype() const {
  return static_cast< ::mt::EmRestMeetingNotifyType >(notifytype_);
}
inline void TMeetingnotify::set_notifytype(::mt::EmRestMeetingNotifyType value) {
  assert(::mt::EmRestMeetingNotifyType_IsValid(value));
  set_has_notifytype();
  notifytype_ = value;
}

// optional string moid = 2;
inline bool TMeetingnotify::has_moid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMeetingnotify::set_has_moid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMeetingnotify::clear_has_moid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMeetingnotify::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMeetingnotify::moid() const {
  return *moid_;
}
inline void TMeetingnotify::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMeetingnotify::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMeetingnotify::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMeetingnotify::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMeetingnotify::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMeetingnotify::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 nofifyid = 3;
inline bool TMeetingnotify::has_nofifyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMeetingnotify::set_has_nofifyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMeetingnotify::clear_has_nofifyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMeetingnotify::clear_nofifyid() {
  nofifyid_ = 0u;
  clear_has_nofifyid();
}
inline ::google::protobuf::uint32 TMeetingnotify::nofifyid() const {
  return nofifyid_;
}
inline void TMeetingnotify::set_nofifyid(::google::protobuf::uint32 value) {
  set_has_nofifyid();
  nofifyid_ = value;
}

// optional uint32 num = 4;
inline bool TMeetingnotify::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMeetingnotify::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMeetingnotify::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMeetingnotify::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 TMeetingnotify::num() const {
  return num_;
}
inline void TMeetingnotify::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// TMTWbParseKedaDept

// optional uint32 departmentid = 1;
inline bool TMTWbParseKedaDept::has_departmentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParseKedaDept::set_has_departmentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParseKedaDept::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParseKedaDept::clear_departmentid() {
  departmentid_ = 0u;
  clear_has_departmentid();
}
inline ::google::protobuf::uint32 TMTWbParseKedaDept::departmentid() const {
  return departmentid_;
}
inline void TMTWbParseKedaDept::set_departmentid(::google::protobuf::uint32 value) {
  set_has_departmentid();
  departmentid_ = value;
}

// optional string departmentname = 2;
inline bool TMTWbParseKedaDept::has_departmentname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTWbParseKedaDept::set_has_departmentname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTWbParseKedaDept::clear_has_departmentname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTWbParseKedaDept::clear_departmentname() {
  if (departmentname_ != &::google::protobuf::internal::kEmptyString) {
    departmentname_->clear();
  }
  clear_has_departmentname();
}
inline const ::std::string& TMTWbParseKedaDept::departmentname() const {
  return *departmentname_;
}
inline void TMTWbParseKedaDept::set_departmentname(const ::std::string& value) {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  departmentname_->assign(value);
}
inline void TMTWbParseKedaDept::set_departmentname(const char* value) {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  departmentname_->assign(value);
}
inline void TMTWbParseKedaDept::set_departmentname(const char* value, size_t size) {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  departmentname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParseKedaDept::mutable_departmentname() {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  return departmentname_;
}
inline ::std::string* TMTWbParseKedaDept::release_departmentname() {
  clear_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentname_;
    departmentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParseKedaDept::set_allocated_departmentname(::std::string* departmentname) {
  if (departmentname_ != &::google::protobuf::internal::kEmptyString) {
    delete departmentname_;
  }
  if (departmentname) {
    set_has_departmentname();
    departmentname_ = departmentname;
  } else {
    clear_has_departmentname();
    departmentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fullPath = 3;
inline bool TMTWbParseKedaDept::has_fullpath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTWbParseKedaDept::set_has_fullpath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTWbParseKedaDept::clear_has_fullpath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTWbParseKedaDept::clear_fullpath() {
  if (fullpath_ != &::google::protobuf::internal::kEmptyString) {
    fullpath_->clear();
  }
  clear_has_fullpath();
}
inline const ::std::string& TMTWbParseKedaDept::fullpath() const {
  return *fullpath_;
}
inline void TMTWbParseKedaDept::set_fullpath(const ::std::string& value) {
  set_has_fullpath();
  if (fullpath_ == &::google::protobuf::internal::kEmptyString) {
    fullpath_ = new ::std::string;
  }
  fullpath_->assign(value);
}
inline void TMTWbParseKedaDept::set_fullpath(const char* value) {
  set_has_fullpath();
  if (fullpath_ == &::google::protobuf::internal::kEmptyString) {
    fullpath_ = new ::std::string;
  }
  fullpath_->assign(value);
}
inline void TMTWbParseKedaDept::set_fullpath(const char* value, size_t size) {
  set_has_fullpath();
  if (fullpath_ == &::google::protobuf::internal::kEmptyString) {
    fullpath_ = new ::std::string;
  }
  fullpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParseKedaDept::mutable_fullpath() {
  set_has_fullpath();
  if (fullpath_ == &::google::protobuf::internal::kEmptyString) {
    fullpath_ = new ::std::string;
  }
  return fullpath_;
}
inline ::std::string* TMTWbParseKedaDept::release_fullpath() {
  clear_has_fullpath();
  if (fullpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fullpath_;
    fullpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParseKedaDept::set_allocated_fullpath(::std::string* fullpath) {
  if (fullpath_ != &::google::protobuf::internal::kEmptyString) {
    delete fullpath_;
  }
  if (fullpath) {
    set_has_fullpath();
    fullpath_ = fullpath;
  } else {
    clear_has_fullpath();
    fullpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deptPosition = 4;
inline bool TMTWbParseKedaDept::has_deptposition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTWbParseKedaDept::set_has_deptposition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTWbParseKedaDept::clear_has_deptposition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTWbParseKedaDept::clear_deptposition() {
  if (deptposition_ != &::google::protobuf::internal::kEmptyString) {
    deptposition_->clear();
  }
  clear_has_deptposition();
}
inline const ::std::string& TMTWbParseKedaDept::deptposition() const {
  return *deptposition_;
}
inline void TMTWbParseKedaDept::set_deptposition(const ::std::string& value) {
  set_has_deptposition();
  if (deptposition_ == &::google::protobuf::internal::kEmptyString) {
    deptposition_ = new ::std::string;
  }
  deptposition_->assign(value);
}
inline void TMTWbParseKedaDept::set_deptposition(const char* value) {
  set_has_deptposition();
  if (deptposition_ == &::google::protobuf::internal::kEmptyString) {
    deptposition_ = new ::std::string;
  }
  deptposition_->assign(value);
}
inline void TMTWbParseKedaDept::set_deptposition(const char* value, size_t size) {
  set_has_deptposition();
  if (deptposition_ == &::google::protobuf::internal::kEmptyString) {
    deptposition_ = new ::std::string;
  }
  deptposition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParseKedaDept::mutable_deptposition() {
  set_has_deptposition();
  if (deptposition_ == &::google::protobuf::internal::kEmptyString) {
    deptposition_ = new ::std::string;
  }
  return deptposition_;
}
inline ::std::string* TMTWbParseKedaDept::release_deptposition() {
  clear_has_deptposition();
  if (deptposition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deptposition_;
    deptposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParseKedaDept::set_allocated_deptposition(::std::string* deptposition) {
  if (deptposition_ != &::google::protobuf::internal::kEmptyString) {
    delete deptposition_;
  }
  if (deptposition) {
    set_has_deptposition();
    deptposition_ = deptposition;
  } else {
    clear_has_deptposition();
    deptposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTWbParseKedaDepts

// optional uint32 deptnum = 1;
inline bool TMTWbParseKedaDepts::has_deptnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParseKedaDepts::set_has_deptnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParseKedaDepts::clear_has_deptnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParseKedaDepts::clear_deptnum() {
  deptnum_ = 0u;
  clear_has_deptnum();
}
inline ::google::protobuf::uint32 TMTWbParseKedaDepts::deptnum() const {
  return deptnum_;
}
inline void TMTWbParseKedaDepts::set_deptnum(::google::protobuf::uint32 value) {
  set_has_deptnum();
  deptnum_ = value;
}

// repeated .mt.TMTWbParseKedaDept kedadept = 2;
inline int TMTWbParseKedaDepts::kedadept_size() const {
  return kedadept_.size();
}
inline void TMTWbParseKedaDepts::clear_kedadept() {
  kedadept_.Clear();
}
inline const ::mt::TMTWbParseKedaDept& TMTWbParseKedaDepts::kedadept(int index) const {
  return kedadept_.Get(index);
}
inline ::mt::TMTWbParseKedaDept* TMTWbParseKedaDepts::mutable_kedadept(int index) {
  return kedadept_.Mutable(index);
}
inline ::mt::TMTWbParseKedaDept* TMTWbParseKedaDepts::add_kedadept() {
  return kedadept_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParseKedaDept >&
TMTWbParseKedaDepts::kedadept() const {
  return kedadept_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParseKedaDept >*
TMTWbParseKedaDepts::mutable_kedadept() {
  return &kedadept_;
}

// -------------------------------------------------------------------

// TMTWbParse_Keda_EntUser

// optional string moid = 1;
inline bool TMTWbParse_Keda_EntUser::has_moid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_moid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_moid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParse_Keda_EntUser::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::moid() const {
  return *moid_;
}
inline void TMTWbParse_Keda_EntUser::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jid = 2;
inline bool TMTWbParse_Keda_EntUser::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTWbParse_Keda_EntUser::clear_jid() {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    jid_->clear();
  }
  clear_has_jid();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::jid() const {
  return *jid_;
}
inline void TMTWbParse_Keda_EntUser::set_jid(const ::std::string& value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_jid(const char* value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_jid(const char* value, size_t size) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_jid() {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  return jid_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_jid() {
  clear_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jid_;
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_jid(::std::string* jid) {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    delete jid_;
  }
  if (jid) {
    set_has_jid();
    jid_ = jid;
  } else {
    clear_has_jid();
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 3;
inline bool TMTWbParse_Keda_EntUser::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTWbParse_Keda_EntUser::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::account() const {
  return *account_;
}
inline void TMTWbParse_Keda_EntUser::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string entmail = 4;
inline bool TMTWbParse_Keda_EntUser::has_entmail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_entmail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_entmail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTWbParse_Keda_EntUser::clear_entmail() {
  if (entmail_ != &::google::protobuf::internal::kEmptyString) {
    entmail_->clear();
  }
  clear_has_entmail();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::entmail() const {
  return *entmail_;
}
inline void TMTWbParse_Keda_EntUser::set_entmail(const ::std::string& value) {
  set_has_entmail();
  if (entmail_ == &::google::protobuf::internal::kEmptyString) {
    entmail_ = new ::std::string;
  }
  entmail_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_entmail(const char* value) {
  set_has_entmail();
  if (entmail_ == &::google::protobuf::internal::kEmptyString) {
    entmail_ = new ::std::string;
  }
  entmail_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_entmail(const char* value, size_t size) {
  set_has_entmail();
  if (entmail_ == &::google::protobuf::internal::kEmptyString) {
    entmail_ = new ::std::string;
  }
  entmail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_entmail() {
  set_has_entmail();
  if (entmail_ == &::google::protobuf::internal::kEmptyString) {
    entmail_ = new ::std::string;
  }
  return entmail_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_entmail() {
  clear_has_entmail();
  if (entmail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entmail_;
    entmail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_entmail(::std::string* entmail) {
  if (entmail_ != &::google::protobuf::internal::kEmptyString) {
    delete entmail_;
  }
  if (entmail) {
    set_has_entmail();
    entmail_ = entmail;
  } else {
    clear_has_entmail();
    entmail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 5;
inline bool TMTWbParse_Keda_EntUser::has_e164() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_e164() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_e164() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTWbParse_Keda_EntUser::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::e164() const {
  return *e164_;
}
inline void TMTWbParse_Keda_EntUser::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobilenum = 6;
inline bool TMTWbParse_Keda_EntUser::has_mobilenum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_mobilenum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_mobilenum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTWbParse_Keda_EntUser::clear_mobilenum() {
  if (mobilenum_ != &::google::protobuf::internal::kEmptyString) {
    mobilenum_->clear();
  }
  clear_has_mobilenum();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::mobilenum() const {
  return *mobilenum_;
}
inline void TMTWbParse_Keda_EntUser::set_mobilenum(const ::std::string& value) {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  mobilenum_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_mobilenum(const char* value) {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  mobilenum_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_mobilenum(const char* value, size_t size) {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  mobilenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_mobilenum() {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  return mobilenum_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_mobilenum() {
  clear_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilenum_;
    mobilenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_mobilenum(::std::string* mobilenum) {
  if (mobilenum_ != &::google::protobuf::internal::kEmptyString) {
    delete mobilenum_;
  }
  if (mobilenum) {
    set_has_mobilenum();
    mobilenum_ = mobilenum;
  } else {
    clear_has_mobilenum();
    mobilenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdomainmoid = 7;
inline bool TMTWbParse_Keda_EntUser::has_userdomainmoid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_userdomainmoid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_userdomainmoid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTWbParse_Keda_EntUser::clear_userdomainmoid() {
  if (userdomainmoid_ != &::google::protobuf::internal::kEmptyString) {
    userdomainmoid_->clear();
  }
  clear_has_userdomainmoid();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::userdomainmoid() const {
  return *userdomainmoid_;
}
inline void TMTWbParse_Keda_EntUser::set_userdomainmoid(const ::std::string& value) {
  set_has_userdomainmoid();
  if (userdomainmoid_ == &::google::protobuf::internal::kEmptyString) {
    userdomainmoid_ = new ::std::string;
  }
  userdomainmoid_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_userdomainmoid(const char* value) {
  set_has_userdomainmoid();
  if (userdomainmoid_ == &::google::protobuf::internal::kEmptyString) {
    userdomainmoid_ = new ::std::string;
  }
  userdomainmoid_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_userdomainmoid(const char* value, size_t size) {
  set_has_userdomainmoid();
  if (userdomainmoid_ == &::google::protobuf::internal::kEmptyString) {
    userdomainmoid_ = new ::std::string;
  }
  userdomainmoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_userdomainmoid() {
  set_has_userdomainmoid();
  if (userdomainmoid_ == &::google::protobuf::internal::kEmptyString) {
    userdomainmoid_ = new ::std::string;
  }
  return userdomainmoid_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_userdomainmoid() {
  clear_has_userdomainmoid();
  if (userdomainmoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdomainmoid_;
    userdomainmoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_userdomainmoid(::std::string* userdomainmoid) {
  if (userdomainmoid_ != &::google::protobuf::internal::kEmptyString) {
    delete userdomainmoid_;
  }
  if (userdomainmoid) {
    set_has_userdomainmoid();
    userdomainmoid_ = userdomainmoid;
  } else {
    clear_has_userdomainmoid();
    userdomainmoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdomainname = 8;
inline bool TMTWbParse_Keda_EntUser::has_userdomainname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_userdomainname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_userdomainname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTWbParse_Keda_EntUser::clear_userdomainname() {
  if (userdomainname_ != &::google::protobuf::internal::kEmptyString) {
    userdomainname_->clear();
  }
  clear_has_userdomainname();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::userdomainname() const {
  return *userdomainname_;
}
inline void TMTWbParse_Keda_EntUser::set_userdomainname(const ::std::string& value) {
  set_has_userdomainname();
  if (userdomainname_ == &::google::protobuf::internal::kEmptyString) {
    userdomainname_ = new ::std::string;
  }
  userdomainname_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_userdomainname(const char* value) {
  set_has_userdomainname();
  if (userdomainname_ == &::google::protobuf::internal::kEmptyString) {
    userdomainname_ = new ::std::string;
  }
  userdomainname_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_userdomainname(const char* value, size_t size) {
  set_has_userdomainname();
  if (userdomainname_ == &::google::protobuf::internal::kEmptyString) {
    userdomainname_ = new ::std::string;
  }
  userdomainname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_userdomainname() {
  set_has_userdomainname();
  if (userdomainname_ == &::google::protobuf::internal::kEmptyString) {
    userdomainname_ = new ::std::string;
  }
  return userdomainname_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_userdomainname() {
  clear_has_userdomainname();
  if (userdomainname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdomainname_;
    userdomainname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_userdomainname(::std::string* userdomainname) {
  if (userdomainname_ != &::google::protobuf::internal::kEmptyString) {
    delete userdomainname_;
  }
  if (userdomainname) {
    set_has_userdomainname();
    userdomainname_ = userdomainname;
  } else {
    clear_has_userdomainname();
    userdomainname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceguid = 9;
inline bool TMTWbParse_Keda_EntUser::has_deviceguid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_deviceguid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_deviceguid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTWbParse_Keda_EntUser::clear_deviceguid() {
  if (deviceguid_ != &::google::protobuf::internal::kEmptyString) {
    deviceguid_->clear();
  }
  clear_has_deviceguid();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::deviceguid() const {
  return *deviceguid_;
}
inline void TMTWbParse_Keda_EntUser::set_deviceguid(const ::std::string& value) {
  set_has_deviceguid();
  if (deviceguid_ == &::google::protobuf::internal::kEmptyString) {
    deviceguid_ = new ::std::string;
  }
  deviceguid_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_deviceguid(const char* value) {
  set_has_deviceguid();
  if (deviceguid_ == &::google::protobuf::internal::kEmptyString) {
    deviceguid_ = new ::std::string;
  }
  deviceguid_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_deviceguid(const char* value, size_t size) {
  set_has_deviceguid();
  if (deviceguid_ == &::google::protobuf::internal::kEmptyString) {
    deviceguid_ = new ::std::string;
  }
  deviceguid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_deviceguid() {
  set_has_deviceguid();
  if (deviceguid_ == &::google::protobuf::internal::kEmptyString) {
    deviceguid_ = new ::std::string;
  }
  return deviceguid_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_deviceguid() {
  clear_has_deviceguid();
  if (deviceguid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceguid_;
    deviceguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_deviceguid(::std::string* deviceguid) {
  if (deviceguid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceguid_;
  }
  if (deviceguid) {
    set_has_deviceguid();
    deviceguid_ = deviceguid;
  } else {
    clear_has_deviceguid();
    deviceguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nuserverid = 10;
inline bool TMTWbParse_Keda_EntUser::has_nuserverid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_nuserverid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_nuserverid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTWbParse_Keda_EntUser::clear_nuserverid() {
  if (nuserverid_ != &::google::protobuf::internal::kEmptyString) {
    nuserverid_->clear();
  }
  clear_has_nuserverid();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::nuserverid() const {
  return *nuserverid_;
}
inline void TMTWbParse_Keda_EntUser::set_nuserverid(const ::std::string& value) {
  set_has_nuserverid();
  if (nuserverid_ == &::google::protobuf::internal::kEmptyString) {
    nuserverid_ = new ::std::string;
  }
  nuserverid_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_nuserverid(const char* value) {
  set_has_nuserverid();
  if (nuserverid_ == &::google::protobuf::internal::kEmptyString) {
    nuserverid_ = new ::std::string;
  }
  nuserverid_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_nuserverid(const char* value, size_t size) {
  set_has_nuserverid();
  if (nuserverid_ == &::google::protobuf::internal::kEmptyString) {
    nuserverid_ = new ::std::string;
  }
  nuserverid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_nuserverid() {
  set_has_nuserverid();
  if (nuserverid_ == &::google::protobuf::internal::kEmptyString) {
    nuserverid_ = new ::std::string;
  }
  return nuserverid_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_nuserverid() {
  clear_has_nuserverid();
  if (nuserverid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nuserverid_;
    nuserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_nuserverid(::std::string* nuserverid) {
  if (nuserverid_ != &::google::protobuf::internal::kEmptyString) {
    delete nuserverid_;
  }
  if (nuserverid) {
    set_has_nuserverid();
    nuserverid_ = nuserverid;
  } else {
    clear_has_nuserverid();
    nuserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string devicetype = 11;
inline bool TMTWbParse_Keda_EntUser::has_devicetype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_devicetype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTWbParse_Keda_EntUser::clear_devicetype() {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    devicetype_->clear();
  }
  clear_has_devicetype();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::devicetype() const {
  return *devicetype_;
}
inline void TMTWbParse_Keda_EntUser::set_devicetype(const ::std::string& value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_devicetype(const char* value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_devicetype(const char* value, size_t size) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_devicetype() {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  return devicetype_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_devicetype() {
  clear_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicetype_;
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    delete devicetype_;
  }
  if (devicetype) {
    set_has_devicetype();
    devicetype_ = devicetype;
  } else {
    clear_has_devicetype();
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool enable = 12;
inline bool TMTWbParse_Keda_EntUser::has_enable() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enable() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enable() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTWbParse_Keda_EntUser::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTWbParse_Keda_EntUser::enable() const {
  return enable_;
}
inline void TMTWbParse_Keda_EntUser::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional bool limited = 13;
inline bool TMTWbParse_Keda_EntUser::has_limited() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_limited() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_limited() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTWbParse_Keda_EntUser::clear_limited() {
  limited_ = false;
  clear_has_limited();
}
inline bool TMTWbParse_Keda_EntUser::limited() const {
  return limited_;
}
inline void TMTWbParse_Keda_EntUser::set_limited(bool value) {
  set_has_limited();
  limited_ = value;
}

// optional string entname = 14;
inline bool TMTWbParse_Keda_EntUser::has_entname() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_entname() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_entname() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTWbParse_Keda_EntUser::clear_entname() {
  if (entname_ != &::google::protobuf::internal::kEmptyString) {
    entname_->clear();
  }
  clear_has_entname();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::entname() const {
  return *entname_;
}
inline void TMTWbParse_Keda_EntUser::set_entname(const ::std::string& value) {
  set_has_entname();
  if (entname_ == &::google::protobuf::internal::kEmptyString) {
    entname_ = new ::std::string;
  }
  entname_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_entname(const char* value) {
  set_has_entname();
  if (entname_ == &::google::protobuf::internal::kEmptyString) {
    entname_ = new ::std::string;
  }
  entname_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_entname(const char* value, size_t size) {
  set_has_entname();
  if (entname_ == &::google::protobuf::internal::kEmptyString) {
    entname_ = new ::std::string;
  }
  entname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_entname() {
  set_has_entname();
  if (entname_ == &::google::protobuf::internal::kEmptyString) {
    entname_ = new ::std::string;
  }
  return entname_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_entname() {
  clear_has_entname();
  if (entname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entname_;
    entname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_entname(::std::string* entname) {
  if (entname_ != &::google::protobuf::internal::kEmptyString) {
    delete entname_;
  }
  if (entname) {
    set_has_entname();
    entname_ = entname;
  } else {
    clear_has_entname();
    entname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brief = 15;
inline bool TMTWbParse_Keda_EntUser::has_brief() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_brief() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_brief() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTWbParse_Keda_EntUser::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::brief() const {
  return *brief_;
}
inline void TMTWbParse_Keda_EntUser::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jobnum = 16;
inline bool TMTWbParse_Keda_EntUser::has_jobnum() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_jobnum() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_jobnum() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTWbParse_Keda_EntUser::clear_jobnum() {
  if (jobnum_ != &::google::protobuf::internal::kEmptyString) {
    jobnum_->clear();
  }
  clear_has_jobnum();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::jobnum() const {
  return *jobnum_;
}
inline void TMTWbParse_Keda_EntUser::set_jobnum(const ::std::string& value) {
  set_has_jobnum();
  if (jobnum_ == &::google::protobuf::internal::kEmptyString) {
    jobnum_ = new ::std::string;
  }
  jobnum_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_jobnum(const char* value) {
  set_has_jobnum();
  if (jobnum_ == &::google::protobuf::internal::kEmptyString) {
    jobnum_ = new ::std::string;
  }
  jobnum_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_jobnum(const char* value, size_t size) {
  set_has_jobnum();
  if (jobnum_ == &::google::protobuf::internal::kEmptyString) {
    jobnum_ = new ::std::string;
  }
  jobnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_jobnum() {
  set_has_jobnum();
  if (jobnum_ == &::google::protobuf::internal::kEmptyString) {
    jobnum_ = new ::std::string;
  }
  return jobnum_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_jobnum() {
  clear_has_jobnum();
  if (jobnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jobnum_;
    jobnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_jobnum(::std::string* jobnum) {
  if (jobnum_ != &::google::protobuf::internal::kEmptyString) {
    delete jobnum_;
  }
  if (jobnum) {
    set_has_jobnum();
    jobnum_ = jobnum;
  } else {
    clear_has_jobnum();
    jobnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool male = 17;
inline bool TMTWbParse_Keda_EntUser::has_male() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_male() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_male() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTWbParse_Keda_EntUser::clear_male() {
  male_ = false;
  clear_has_male();
}
inline bool TMTWbParse_Keda_EntUser::male() const {
  return male_;
}
inline void TMTWbParse_Keda_EntUser::set_male(bool value) {
  set_has_male();
  male_ = value;
}

// optional string extnum = 18;
inline bool TMTWbParse_Keda_EntUser::has_extnum() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_extnum() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_extnum() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTWbParse_Keda_EntUser::clear_extnum() {
  if (extnum_ != &::google::protobuf::internal::kEmptyString) {
    extnum_->clear();
  }
  clear_has_extnum();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::extnum() const {
  return *extnum_;
}
inline void TMTWbParse_Keda_EntUser::set_extnum(const ::std::string& value) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_extnum(const char* value) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_extnum(const char* value, size_t size) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_extnum() {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  return extnum_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_extnum() {
  clear_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extnum_;
    extnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_extnum(::std::string* extnum) {
  if (extnum_ != &::google::protobuf::internal::kEmptyString) {
    delete extnum_;
  }
  if (extnum) {
    set_has_extnum();
    extnum_ = extnum;
  } else {
    clear_has_extnum();
    extnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string seat = 19;
inline bool TMTWbParse_Keda_EntUser::has_seat() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_seat() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_seat() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTWbParse_Keda_EntUser::clear_seat() {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    seat_->clear();
  }
  clear_has_seat();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::seat() const {
  return *seat_;
}
inline void TMTWbParse_Keda_EntUser::set_seat(const ::std::string& value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_seat(const char* value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_seat(const char* value, size_t size) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_seat() {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  return seat_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_seat() {
  clear_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seat_;
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_seat(::std::string* seat) {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    delete seat_;
  }
  if (seat) {
    set_has_seat();
    seat_ = seat;
  } else {
    clear_has_seat();
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string officeLocation = 20;
inline bool TMTWbParse_Keda_EntUser::has_officelocation() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_officelocation() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_officelocation() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTWbParse_Keda_EntUser::clear_officelocation() {
  if (officelocation_ != &::google::protobuf::internal::kEmptyString) {
    officelocation_->clear();
  }
  clear_has_officelocation();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::officelocation() const {
  return *officelocation_;
}
inline void TMTWbParse_Keda_EntUser::set_officelocation(const ::std::string& value) {
  set_has_officelocation();
  if (officelocation_ == &::google::protobuf::internal::kEmptyString) {
    officelocation_ = new ::std::string;
  }
  officelocation_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_officelocation(const char* value) {
  set_has_officelocation();
  if (officelocation_ == &::google::protobuf::internal::kEmptyString) {
    officelocation_ = new ::std::string;
  }
  officelocation_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_officelocation(const char* value, size_t size) {
  set_has_officelocation();
  if (officelocation_ == &::google::protobuf::internal::kEmptyString) {
    officelocation_ = new ::std::string;
  }
  officelocation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_officelocation() {
  set_has_officelocation();
  if (officelocation_ == &::google::protobuf::internal::kEmptyString) {
    officelocation_ = new ::std::string;
  }
  return officelocation_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_officelocation() {
  clear_has_officelocation();
  if (officelocation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = officelocation_;
    officelocation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_officelocation(::std::string* officelocation) {
  if (officelocation_ != &::google::protobuf::internal::kEmptyString) {
    delete officelocation_;
  }
  if (officelocation) {
    set_has_officelocation();
    officelocation_ = officelocation;
  } else {
    clear_has_officelocation();
    officelocation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dateOfBirth = 21;
inline bool TMTWbParse_Keda_EntUser::has_dateofbirth() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_dateofbirth() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_dateofbirth() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTWbParse_Keda_EntUser::clear_dateofbirth() {
  if (dateofbirth_ != &::google::protobuf::internal::kEmptyString) {
    dateofbirth_->clear();
  }
  clear_has_dateofbirth();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::dateofbirth() const {
  return *dateofbirth_;
}
inline void TMTWbParse_Keda_EntUser::set_dateofbirth(const ::std::string& value) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_dateofbirth(const char* value) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_dateofbirth(const char* value, size_t size) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_dateofbirth() {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  return dateofbirth_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_dateofbirth() {
  clear_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dateofbirth_;
    dateofbirth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_dateofbirth(::std::string* dateofbirth) {
  if (dateofbirth_ != &::google::protobuf::internal::kEmptyString) {
    delete dateofbirth_;
  }
  if (dateofbirth) {
    set_has_dateofbirth();
    dateofbirth_ = dateofbirth;
  } else {
    clear_has_dateofbirth();
    dateofbirth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fax = 22;
inline bool TMTWbParse_Keda_EntUser::has_fax() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_fax() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_fax() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTWbParse_Keda_EntUser::clear_fax() {
  if (fax_ != &::google::protobuf::internal::kEmptyString) {
    fax_->clear();
  }
  clear_has_fax();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::fax() const {
  return *fax_;
}
inline void TMTWbParse_Keda_EntUser::set_fax(const ::std::string& value) {
  set_has_fax();
  if (fax_ == &::google::protobuf::internal::kEmptyString) {
    fax_ = new ::std::string;
  }
  fax_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_fax(const char* value) {
  set_has_fax();
  if (fax_ == &::google::protobuf::internal::kEmptyString) {
    fax_ = new ::std::string;
  }
  fax_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_fax(const char* value, size_t size) {
  set_has_fax();
  if (fax_ == &::google::protobuf::internal::kEmptyString) {
    fax_ = new ::std::string;
  }
  fax_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_fax() {
  set_has_fax();
  if (fax_ == &::google::protobuf::internal::kEmptyString) {
    fax_ = new ::std::string;
  }
  return fax_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_fax() {
  clear_has_fax();
  if (fax_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fax_;
    fax_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_fax(::std::string* fax) {
  if (fax_ != &::google::protobuf::internal::kEmptyString) {
    delete fax_;
  }
  if (fax) {
    set_has_fax();
    fax_ = fax;
  } else {
    clear_has_fax();
    fax_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string restrictUsedOn = 23;
inline bool TMTWbParse_Keda_EntUser::has_restrictusedon() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_restrictusedon() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_restrictusedon() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTWbParse_Keda_EntUser::clear_restrictusedon() {
  if (restrictusedon_ != &::google::protobuf::internal::kEmptyString) {
    restrictusedon_->clear();
  }
  clear_has_restrictusedon();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::restrictusedon() const {
  return *restrictusedon_;
}
inline void TMTWbParse_Keda_EntUser::set_restrictusedon(const ::std::string& value) {
  set_has_restrictusedon();
  if (restrictusedon_ == &::google::protobuf::internal::kEmptyString) {
    restrictusedon_ = new ::std::string;
  }
  restrictusedon_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_restrictusedon(const char* value) {
  set_has_restrictusedon();
  if (restrictusedon_ == &::google::protobuf::internal::kEmptyString) {
    restrictusedon_ = new ::std::string;
  }
  restrictusedon_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_restrictusedon(const char* value, size_t size) {
  set_has_restrictusedon();
  if (restrictusedon_ == &::google::protobuf::internal::kEmptyString) {
    restrictusedon_ = new ::std::string;
  }
  restrictusedon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_restrictusedon() {
  set_has_restrictusedon();
  if (restrictusedon_ == &::google::protobuf::internal::kEmptyString) {
    restrictusedon_ = new ::std::string;
  }
  return restrictusedon_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_restrictusedon() {
  clear_has_restrictusedon();
  if (restrictusedon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = restrictusedon_;
    restrictusedon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_restrictusedon(::std::string* restrictusedon) {
  if (restrictusedon_ != &::google::protobuf::internal::kEmptyString) {
    delete restrictusedon_;
  }
  if (restrictusedon) {
    set_has_restrictusedon();
    restrictusedon_ = restrictusedon;
  } else {
    clear_has_restrictusedon();
    restrictusedon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portrait32 = 24;
inline bool TMTWbParse_Keda_EntUser::has_portrait32() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_portrait32() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_portrait32() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTWbParse_Keda_EntUser::clear_portrait32() {
  if (portrait32_ != &::google::protobuf::internal::kEmptyString) {
    portrait32_->clear();
  }
  clear_has_portrait32();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::portrait32() const {
  return *portrait32_;
}
inline void TMTWbParse_Keda_EntUser::set_portrait32(const ::std::string& value) {
  set_has_portrait32();
  if (portrait32_ == &::google::protobuf::internal::kEmptyString) {
    portrait32_ = new ::std::string;
  }
  portrait32_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_portrait32(const char* value) {
  set_has_portrait32();
  if (portrait32_ == &::google::protobuf::internal::kEmptyString) {
    portrait32_ = new ::std::string;
  }
  portrait32_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_portrait32(const char* value, size_t size) {
  set_has_portrait32();
  if (portrait32_ == &::google::protobuf::internal::kEmptyString) {
    portrait32_ = new ::std::string;
  }
  portrait32_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_portrait32() {
  set_has_portrait32();
  if (portrait32_ == &::google::protobuf::internal::kEmptyString) {
    portrait32_ = new ::std::string;
  }
  return portrait32_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_portrait32() {
  clear_has_portrait32();
  if (portrait32_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portrait32_;
    portrait32_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_portrait32(::std::string* portrait32) {
  if (portrait32_ != &::google::protobuf::internal::kEmptyString) {
    delete portrait32_;
  }
  if (portrait32) {
    set_has_portrait32();
    portrait32_ = portrait32;
  } else {
    clear_has_portrait32();
    portrait32_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portrait40 = 25;
inline bool TMTWbParse_Keda_EntUser::has_portrait40() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_portrait40() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_portrait40() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_portrait40() {
  if (portrait40_ != &::google::protobuf::internal::kEmptyString) {
    portrait40_->clear();
  }
  clear_has_portrait40();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::portrait40() const {
  return *portrait40_;
}
inline void TMTWbParse_Keda_EntUser::set_portrait40(const ::std::string& value) {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  portrait40_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_portrait40(const char* value) {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  portrait40_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_portrait40(const char* value, size_t size) {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  portrait40_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_portrait40() {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  return portrait40_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_portrait40() {
  clear_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portrait40_;
    portrait40_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_portrait40(::std::string* portrait40) {
  if (portrait40_ != &::google::protobuf::internal::kEmptyString) {
    delete portrait40_;
  }
  if (portrait40) {
    set_has_portrait40();
    portrait40_ = portrait40;
  } else {
    clear_has_portrait40();
    portrait40_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portrait64 = 26;
inline bool TMTWbParse_Keda_EntUser::has_portrait64() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_portrait64() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_portrait64() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_portrait64() {
  if (portrait64_ != &::google::protobuf::internal::kEmptyString) {
    portrait64_->clear();
  }
  clear_has_portrait64();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::portrait64() const {
  return *portrait64_;
}
inline void TMTWbParse_Keda_EntUser::set_portrait64(const ::std::string& value) {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  portrait64_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_portrait64(const char* value) {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  portrait64_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_portrait64(const char* value, size_t size) {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  portrait64_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_portrait64() {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  return portrait64_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_portrait64() {
  clear_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portrait64_;
    portrait64_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_portrait64(::std::string* portrait64) {
  if (portrait64_ != &::google::protobuf::internal::kEmptyString) {
    delete portrait64_;
  }
  if (portrait64) {
    set_has_portrait64();
    portrait64_ = portrait64;
  } else {
    clear_has_portrait64();
    portrait64_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portrait128 = 27;
inline bool TMTWbParse_Keda_EntUser::has_portrait128() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_portrait128() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_portrait128() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_portrait128() {
  if (portrait128_ != &::google::protobuf::internal::kEmptyString) {
    portrait128_->clear();
  }
  clear_has_portrait128();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::portrait128() const {
  return *portrait128_;
}
inline void TMTWbParse_Keda_EntUser::set_portrait128(const ::std::string& value) {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  portrait128_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_portrait128(const char* value) {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  portrait128_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_portrait128(const char* value, size_t size) {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  portrait128_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_portrait128() {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  return portrait128_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_portrait128() {
  clear_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portrait128_;
    portrait128_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_portrait128(::std::string* portrait128) {
  if (portrait128_ != &::google::protobuf::internal::kEmptyString) {
    delete portrait128_;
  }
  if (portrait128) {
    set_has_portrait128();
    portrait128_ = portrait128;
  } else {
    clear_has_portrait128();
    portrait128_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portrait256 = 28;
inline bool TMTWbParse_Keda_EntUser::has_portrait256() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_portrait256() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_portrait256() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_portrait256() {
  if (portrait256_ != &::google::protobuf::internal::kEmptyString) {
    portrait256_->clear();
  }
  clear_has_portrait256();
}
inline const ::std::string& TMTWbParse_Keda_EntUser::portrait256() const {
  return *portrait256_;
}
inline void TMTWbParse_Keda_EntUser::set_portrait256(const ::std::string& value) {
  set_has_portrait256();
  if (portrait256_ == &::google::protobuf::internal::kEmptyString) {
    portrait256_ = new ::std::string;
  }
  portrait256_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_portrait256(const char* value) {
  set_has_portrait256();
  if (portrait256_ == &::google::protobuf::internal::kEmptyString) {
    portrait256_ = new ::std::string;
  }
  portrait256_->assign(value);
}
inline void TMTWbParse_Keda_EntUser::set_portrait256(const char* value, size_t size) {
  set_has_portrait256();
  if (portrait256_ == &::google::protobuf::internal::kEmptyString) {
    portrait256_ = new ::std::string;
  }
  portrait256_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntUser::mutable_portrait256() {
  set_has_portrait256();
  if (portrait256_ == &::google::protobuf::internal::kEmptyString) {
    portrait256_ = new ::std::string;
  }
  return portrait256_;
}
inline ::std::string* TMTWbParse_Keda_EntUser::release_portrait256() {
  clear_has_portrait256();
  if (portrait256_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portrait256_;
    portrait256_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntUser::set_allocated_portrait256(::std::string* portrait256) {
  if (portrait256_ != &::google::protobuf::internal::kEmptyString) {
    delete portrait256_;
  }
  if (portrait256) {
    set_has_portrait256();
    portrait256_ = portrait256;
  } else {
    clear_has_portrait256();
    portrait256_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool enableweibo = 29;
inline bool TMTWbParse_Keda_EntUser::has_enableweibo() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enableweibo() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enableweibo() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enableweibo() {
  enableweibo_ = false;
  clear_has_enableweibo();
}
inline bool TMTWbParse_Keda_EntUser::enableweibo() const {
  return enableweibo_;
}
inline void TMTWbParse_Keda_EntUser::set_enableweibo(bool value) {
  set_has_enableweibo();
  enableweibo_ = value;
}

// optional bool enablemeetingsms = 30;
inline bool TMTWbParse_Keda_EntUser::has_enablemeetingsms() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablemeetingsms() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablemeetingsms() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablemeetingsms() {
  enablemeetingsms_ = false;
  clear_has_enablemeetingsms();
}
inline bool TMTWbParse_Keda_EntUser::enablemeetingsms() const {
  return enablemeetingsms_;
}
inline void TMTWbParse_Keda_EntUser::set_enablemeetingsms(bool value) {
  set_has_enablemeetingsms();
  enablemeetingsms_ = value;
}

// optional bool enablemeeting = 31;
inline bool TMTWbParse_Keda_EntUser::has_enablemeeting() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablemeeting() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablemeeting() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablemeeting() {
  enablemeeting_ = false;
  clear_has_enablemeeting();
}
inline bool TMTWbParse_Keda_EntUser::enablemeeting() const {
  return enablemeeting_;
}
inline void TMTWbParse_Keda_EntUser::set_enablemeeting(bool value) {
  set_has_enablemeeting();
  enablemeeting_ = value;
}

// optional bool enablehd = 32;
inline bool TMTWbParse_Keda_EntUser::has_enablehd() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablehd() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablehd() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablehd() {
  enablehd_ = false;
  clear_has_enablehd();
}
inline bool TMTWbParse_Keda_EntUser::enablehd() const {
  return enablehd_;
}
inline void TMTWbParse_Keda_EntUser::set_enablehd(bool value) {
  set_has_enablehd();
  enablehd_ = value;
}

// optional bool enablecall = 33;
inline bool TMTWbParse_Keda_EntUser::has_enablecall() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablecall() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablecall() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablecall() {
  enablecall_ = false;
  clear_has_enablecall();
}
inline bool TMTWbParse_Keda_EntUser::enablecall() const {
  return enablecall_;
}
inline void TMTWbParse_Keda_EntUser::set_enablecall(bool value) {
  set_has_enablecall();
  enablecall_ = value;
}

// optional bool enableroam = 34;
inline bool TMTWbParse_Keda_EntUser::has_enableroam() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enableroam() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enableroam() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TMTWbParse_Keda_EntUser::clear_enableroam() {
  enableroam_ = false;
  clear_has_enableroam();
}
inline bool TMTWbParse_Keda_EntUser::enableroam() const {
  return enableroam_;
}
inline void TMTWbParse_Keda_EntUser::set_enableroam(bool value) {
  set_has_enableroam();
  enableroam_ = value;
}

// optional bool enablesatellite = 35;
inline bool TMTWbParse_Keda_EntUser::has_enablesatellite() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablesatellite() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablesatellite() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablesatellite() {
  enablesatellite_ = false;
  clear_has_enablesatellite();
}
inline bool TMTWbParse_Keda_EntUser::enablesatellite() const {
  return enablesatellite_;
}
inline void TMTWbParse_Keda_EntUser::set_enablesatellite(bool value) {
  set_has_enablesatellite();
  enablesatellite_ = value;
}

// optional bool enablesatellitep2p = 36;
inline bool TMTWbParse_Keda_EntUser::has_enablesatellitep2p() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablesatellitep2p() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablesatellitep2p() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablesatellitep2p() {
  enablesatellitep2p_ = false;
  clear_has_enablesatellitep2p();
}
inline bool TMTWbParse_Keda_EntUser::enablesatellitep2p() const {
  return enablesatellitep2p_;
}
inline void TMTWbParse_Keda_EntUser::set_enablesatellitep2p(bool value) {
  set_has_enablesatellitep2p();
  enablesatellitep2p_ = value;
}

// optional bool weiboadmin = 37;
inline bool TMTWbParse_Keda_EntUser::has_weiboadmin() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_weiboadmin() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_weiboadmin() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TMTWbParse_Keda_EntUser::clear_weiboadmin() {
  weiboadmin_ = false;
  clear_has_weiboadmin();
}
inline bool TMTWbParse_Keda_EntUser::weiboadmin() const {
  return weiboadmin_;
}
inline void TMTWbParse_Keda_EntUser::set_weiboadmin(bool value) {
  set_has_weiboadmin();
  weiboadmin_ = value;
}

// optional bool meetingadmin = 38;
inline bool TMTWbParse_Keda_EntUser::has_meetingadmin() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_meetingadmin() {
  _has_bits_[1] |= 0x00000020u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_meetingadmin() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void TMTWbParse_Keda_EntUser::clear_meetingadmin() {
  meetingadmin_ = false;
  clear_has_meetingadmin();
}
inline bool TMTWbParse_Keda_EntUser::meetingadmin() const {
  return meetingadmin_;
}
inline void TMTWbParse_Keda_EntUser::set_meetingadmin(bool value) {
  set_has_meetingadmin();
  meetingadmin_ = value;
}

// optional bool enablebmc = 39;
inline bool TMTWbParse_Keda_EntUser::has_enablebmc() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablebmc() {
  _has_bits_[1] |= 0x00000040u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablebmc() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablebmc() {
  enablebmc_ = false;
  clear_has_enablebmc();
}
inline bool TMTWbParse_Keda_EntUser::enablebmc() const {
  return enablebmc_;
}
inline void TMTWbParse_Keda_EntUser::set_enablebmc(bool value) {
  set_has_enablebmc();
  enablebmc_ = value;
}

// optional bool enableumc = 40;
inline bool TMTWbParse_Keda_EntUser::has_enableumc() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enableumc() {
  _has_bits_[1] |= 0x00000080u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enableumc() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void TMTWbParse_Keda_EntUser::clear_enableumc() {
  enableumc_ = false;
  clear_has_enableumc();
}
inline bool TMTWbParse_Keda_EntUser::enableumc() const {
  return enableumc_;
}
inline void TMTWbParse_Keda_EntUser::set_enableumc(bool value) {
  set_has_enableumc();
  enableumc_ = value;
}

// optional bool enabledcs = 41;
inline bool TMTWbParse_Keda_EntUser::has_enabledcs() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enabledcs() {
  _has_bits_[1] |= 0x00000100u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enabledcs() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void TMTWbParse_Keda_EntUser::clear_enabledcs() {
  enabledcs_ = false;
  clear_has_enabledcs();
}
inline bool TMTWbParse_Keda_EntUser::enabledcs() const {
  return enabledcs_;
}
inline void TMTWbParse_Keda_EntUser::set_enabledcs(bool value) {
  set_has_enabledcs();
  enabledcs_ = value;
}

// optional bool enablevrs = 42;
inline bool TMTWbParse_Keda_EntUser::has_enablevrs() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablevrs() {
  _has_bits_[1] |= 0x00000200u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablevrs() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablevrs() {
  enablevrs_ = false;
  clear_has_enablevrs();
}
inline bool TMTWbParse_Keda_EntUser::enablevrs() const {
  return enablevrs_;
}
inline void TMTWbParse_Keda_EntUser::set_enablevrs(bool value) {
  set_has_enablevrs();
  enablevrs_ = value;
}

// optional bool enablenm = 43;
inline bool TMTWbParse_Keda_EntUser::has_enablenm() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablenm() {
  _has_bits_[1] |= 0x00000400u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablenm() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablenm() {
  enablenm_ = false;
  clear_has_enablenm();
}
inline bool TMTWbParse_Keda_EntUser::enablenm() const {
  return enablenm_;
}
inline void TMTWbParse_Keda_EntUser::set_enablenm(bool value) {
  set_has_enablenm();
  enablenm_ = value;
}

// optional bool enablevenuemonitor = 44;
inline bool TMTWbParse_Keda_EntUser::has_enablevenuemonitor() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablevenuemonitor() {
  _has_bits_[1] |= 0x00000800u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablevenuemonitor() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablevenuemonitor() {
  enablevenuemonitor_ = false;
  clear_has_enablevenuemonitor();
}
inline bool TMTWbParse_Keda_EntUser::enablevenuemonitor() const {
  return enablevenuemonitor_;
}
inline void TMTWbParse_Keda_EntUser::set_enablevenuemonitor(bool value) {
  set_has_enablevenuemonitor();
  enablevenuemonitor_ = value;
}

// optional bool defaultuserdomainadmin = 45;
inline bool TMTWbParse_Keda_EntUser::has_defaultuserdomainadmin() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_defaultuserdomainadmin() {
  _has_bits_[1] |= 0x00001000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_defaultuserdomainadmin() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void TMTWbParse_Keda_EntUser::clear_defaultuserdomainadmin() {
  defaultuserdomainadmin_ = false;
  clear_has_defaultuserdomainadmin();
}
inline bool TMTWbParse_Keda_EntUser::defaultuserdomainadmin() const {
  return defaultuserdomainadmin_;
}
inline void TMTWbParse_Keda_EntUser::set_defaultuserdomainadmin(bool value) {
  set_has_defaultuserdomainadmin();
  defaultuserdomainadmin_ = value;
}

// optional bool enableout = 46;
inline bool TMTWbParse_Keda_EntUser::has_enableout() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enableout() {
  _has_bits_[1] |= 0x00002000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enableout() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enableout() {
  enableout_ = false;
  clear_has_enableout();
}
inline bool TMTWbParse_Keda_EntUser::enableout() const {
  return enableout_;
}
inline void TMTWbParse_Keda_EntUser::set_enableout(bool value) {
  set_has_enableout();
  enableout_ = value;
}

// optional bool enableincoming = 47;
inline bool TMTWbParse_Keda_EntUser::has_enableincoming() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enableincoming() {
  _has_bits_[1] |= 0x00004000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enableincoming() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enableincoming() {
  enableincoming_ = false;
  clear_has_enableincoming();
}
inline bool TMTWbParse_Keda_EntUser::enableincoming() const {
  return enableincoming_;
}
inline void TMTWbParse_Keda_EntUser::set_enableincoming(bool value) {
  set_has_enableincoming();
  enableincoming_ = value;
}

// optional bool dcsadmin = 48;
inline bool TMTWbParse_Keda_EntUser::has_dcsadmin() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_dcsadmin() {
  _has_bits_[1] |= 0x00008000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_dcsadmin() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void TMTWbParse_Keda_EntUser::clear_dcsadmin() {
  dcsadmin_ = false;
  clear_has_dcsadmin();
}
inline bool TMTWbParse_Keda_EntUser::dcsadmin() const {
  return dcsadmin_;
}
inline void TMTWbParse_Keda_EntUser::set_dcsadmin(bool value) {
  set_has_dcsadmin();
  dcsadmin_ = value;
}

// optional bool vrsadmin = 49;
inline bool TMTWbParse_Keda_EntUser::has_vrsadmin() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_vrsadmin() {
  _has_bits_[1] |= 0x00010000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_vrsadmin() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void TMTWbParse_Keda_EntUser::clear_vrsadmin() {
  vrsadmin_ = false;
  clear_has_vrsadmin();
}
inline bool TMTWbParse_Keda_EntUser::vrsadmin() const {
  return vrsadmin_;
}
inline void TMTWbParse_Keda_EntUser::set_vrsadmin(bool value) {
  set_has_vrsadmin();
  vrsadmin_ = value;
}

// optional bool nmadmin = 50;
inline bool TMTWbParse_Keda_EntUser::has_nmadmin() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_nmadmin() {
  _has_bits_[1] |= 0x00020000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_nmadmin() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void TMTWbParse_Keda_EntUser::clear_nmadmin() {
  nmadmin_ = false;
  clear_has_nmadmin();
}
inline bool TMTWbParse_Keda_EntUser::nmadmin() const {
  return nmadmin_;
}
inline void TMTWbParse_Keda_EntUser::set_nmadmin(bool value) {
  set_has_nmadmin();
  nmadmin_ = value;
}

// optional bool enablevideo = 51;
inline bool TMTWbParse_Keda_EntUser::has_enablevideo() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablevideo() {
  _has_bits_[1] |= 0x00040000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablevideo() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablevideo() {
  enablevideo_ = false;
  clear_has_enablevideo();
}
inline bool TMTWbParse_Keda_EntUser::enablevideo() const {
  return enablevideo_;
}
inline void TMTWbParse_Keda_EntUser::set_enablevideo(bool value) {
  set_has_enablevideo();
  enablevideo_ = value;
}

// optional bool enablelive = 52;
inline bool TMTWbParse_Keda_EntUser::has_enablelive() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablelive() {
  _has_bits_[1] |= 0x00080000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablelive() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablelive() {
  enablelive_ = false;
  clear_has_enablelive();
}
inline bool TMTWbParse_Keda_EntUser::enablelive() const {
  return enablelive_;
}
inline void TMTWbParse_Keda_EntUser::set_enablelive(bool value) {
  set_has_enablelive();
  enablelive_ = value;
}

// optional bool enableplay = 53;
inline bool TMTWbParse_Keda_EntUser::has_enableplay() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enableplay() {
  _has_bits_[1] |= 0x00100000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enableplay() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enableplay() {
  enableplay_ = false;
  clear_has_enableplay();
}
inline bool TMTWbParse_Keda_EntUser::enableplay() const {
  return enableplay_;
}
inline void TMTWbParse_Keda_EntUser::set_enableplay(bool value) {
  set_has_enableplay();
  enableplay_ = value;
}

// optional bool cmsapproval = 54;
inline bool TMTWbParse_Keda_EntUser::has_cmsapproval() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_cmsapproval() {
  _has_bits_[1] |= 0x00200000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_cmsapproval() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void TMTWbParse_Keda_EntUser::clear_cmsapproval() {
  cmsapproval_ = false;
  clear_has_cmsapproval();
}
inline bool TMTWbParse_Keda_EntUser::cmsapproval() const {
  return cmsapproval_;
}
inline void TMTWbParse_Keda_EntUser::set_cmsapproval(bool value) {
  set_has_cmsapproval();
  cmsapproval_ = value;
}

// optional bool editname = 55;
inline bool TMTWbParse_Keda_EntUser::has_editname() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_editname() {
  _has_bits_[1] |= 0x00400000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_editname() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void TMTWbParse_Keda_EntUser::clear_editname() {
  editname_ = false;
  clear_has_editname();
}
inline bool TMTWbParse_Keda_EntUser::editname() const {
  return editname_;
}
inline void TMTWbParse_Keda_EntUser::set_editname(bool value) {
  set_has_editname();
  editname_ = value;
}

// optional .mt.TMTWbParseKedaDepts wbparsekedadepts = 56;
inline bool TMTWbParse_Keda_EntUser::has_wbparsekedadepts() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_wbparsekedadepts() {
  _has_bits_[1] |= 0x00800000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_wbparsekedadepts() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void TMTWbParse_Keda_EntUser::clear_wbparsekedadepts() {
  if (wbparsekedadepts_ != NULL) wbparsekedadepts_->::mt::TMTWbParseKedaDepts::Clear();
  clear_has_wbparsekedadepts();
}
inline const ::mt::TMTWbParseKedaDepts& TMTWbParse_Keda_EntUser::wbparsekedadepts() const {
  return wbparsekedadepts_ != NULL ? *wbparsekedadepts_ : *default_instance_->wbparsekedadepts_;
}
inline ::mt::TMTWbParseKedaDepts* TMTWbParse_Keda_EntUser::mutable_wbparsekedadepts() {
  set_has_wbparsekedadepts();
  if (wbparsekedadepts_ == NULL) wbparsekedadepts_ = new ::mt::TMTWbParseKedaDepts;
  return wbparsekedadepts_;
}
inline ::mt::TMTWbParseKedaDepts* TMTWbParse_Keda_EntUser::release_wbparsekedadepts() {
  clear_has_wbparsekedadepts();
  ::mt::TMTWbParseKedaDepts* temp = wbparsekedadepts_;
  wbparsekedadepts_ = NULL;
  return temp;
}
inline void TMTWbParse_Keda_EntUser::set_allocated_wbparsekedadepts(::mt::TMTWbParseKedaDepts* wbparsekedadepts) {
  delete wbparsekedadepts_;
  wbparsekedadepts_ = wbparsekedadepts;
  if (wbparsekedadepts) {
    set_has_wbparsekedadepts();
  } else {
    clear_has_wbparsekedadepts();
  }
}

// optional bool enablefullhd = 57;
inline bool TMTWbParse_Keda_EntUser::has_enablefullhd() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enablefullhd() {
  _has_bits_[1] |= 0x01000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enablefullhd() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enablefullhd() {
  enablefullhd_ = false;
  clear_has_enablefullhd();
}
inline bool TMTWbParse_Keda_EntUser::enablefullhd() const {
  return enablefullhd_;
}
inline void TMTWbParse_Keda_EntUser::set_enablefullhd(bool value) {
  set_has_enablefullhd();
  enablefullhd_ = value;
}

// optional bool enableultrahd = 58;
inline bool TMTWbParse_Keda_EntUser::has_enableultrahd() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enableultrahd() {
  _has_bits_[1] |= 0x02000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enableultrahd() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enableultrahd() {
  enableultrahd_ = false;
  clear_has_enableultrahd();
}
inline bool TMTWbParse_Keda_EntUser::enableultrahd() const {
  return enableultrahd_;
}
inline void TMTWbParse_Keda_EntUser::set_enableultrahd(bool value) {
  set_has_enableultrahd();
  enableultrahd_ = value;
}

// optional bool enableunicat = 59;
inline bool TMTWbParse_Keda_EntUser::has_enableunicat() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enableunicat() {
  _has_bits_[1] |= 0x04000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enableunicat() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enableunicat() {
  enableunicat_ = false;
  clear_has_enableunicat();
}
inline bool TMTWbParse_Keda_EntUser::enableunicat() const {
  return enableunicat_;
}
inline void TMTWbParse_Keda_EntUser::set_enableunicat(bool value) {
  set_has_enableunicat();
  enableunicat_ = value;
}

// optional bool enabledownload = 60;
inline bool TMTWbParse_Keda_EntUser::has_enabledownload() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void TMTWbParse_Keda_EntUser::set_has_enabledownload() {
  _has_bits_[1] |= 0x08000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_has_enabledownload() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void TMTWbParse_Keda_EntUser::clear_enabledownload() {
  enabledownload_ = false;
  clear_has_enabledownload();
}
inline bool TMTWbParse_Keda_EntUser::enabledownload() const {
  return enabledownload_;
}
inline void TMTWbParse_Keda_EntUser::set_enabledownload(bool value) {
  set_has_enabledownload();
  enabledownload_ = value;
}

// -------------------------------------------------------------------

// TImMemberInfo

// optional string membersn = 1;
inline bool TImMemberInfo::has_membersn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImMemberInfo::set_has_membersn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImMemberInfo::clear_has_membersn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImMemberInfo::clear_membersn() {
  if (membersn_ != &::google::protobuf::internal::kEmptyString) {
    membersn_->clear();
  }
  clear_has_membersn();
}
inline const ::std::string& TImMemberInfo::membersn() const {
  return *membersn_;
}
inline void TImMemberInfo::set_membersn(const ::std::string& value) {
  set_has_membersn();
  if (membersn_ == &::google::protobuf::internal::kEmptyString) {
    membersn_ = new ::std::string;
  }
  membersn_->assign(value);
}
inline void TImMemberInfo::set_membersn(const char* value) {
  set_has_membersn();
  if (membersn_ == &::google::protobuf::internal::kEmptyString) {
    membersn_ = new ::std::string;
  }
  membersn_->assign(value);
}
inline void TImMemberInfo::set_membersn(const char* value, size_t size) {
  set_has_membersn();
  if (membersn_ == &::google::protobuf::internal::kEmptyString) {
    membersn_ = new ::std::string;
  }
  membersn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMemberInfo::mutable_membersn() {
  set_has_membersn();
  if (membersn_ == &::google::protobuf::internal::kEmptyString) {
    membersn_ = new ::std::string;
  }
  return membersn_;
}
inline ::std::string* TImMemberInfo::release_membersn() {
  clear_has_membersn();
  if (membersn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = membersn_;
    membersn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMemberInfo::set_allocated_membersn(::std::string* membersn) {
  if (membersn_ != &::google::protobuf::internal::kEmptyString) {
    delete membersn_;
  }
  if (membersn) {
    set_has_membersn();
    membersn_ = membersn;
  } else {
    clear_has_membersn();
    membersn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string groupsn = 2;
inline bool TImMemberInfo::has_groupsn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImMemberInfo::set_has_groupsn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImMemberInfo::clear_has_groupsn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImMemberInfo::clear_groupsn() {
  if (groupsn_ != &::google::protobuf::internal::kEmptyString) {
    groupsn_->clear();
  }
  clear_has_groupsn();
}
inline const ::std::string& TImMemberInfo::groupsn() const {
  return *groupsn_;
}
inline void TImMemberInfo::set_groupsn(const ::std::string& value) {
  set_has_groupsn();
  if (groupsn_ == &::google::protobuf::internal::kEmptyString) {
    groupsn_ = new ::std::string;
  }
  groupsn_->assign(value);
}
inline void TImMemberInfo::set_groupsn(const char* value) {
  set_has_groupsn();
  if (groupsn_ == &::google::protobuf::internal::kEmptyString) {
    groupsn_ = new ::std::string;
  }
  groupsn_->assign(value);
}
inline void TImMemberInfo::set_groupsn(const char* value, size_t size) {
  set_has_groupsn();
  if (groupsn_ == &::google::protobuf::internal::kEmptyString) {
    groupsn_ = new ::std::string;
  }
  groupsn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMemberInfo::mutable_groupsn() {
  set_has_groupsn();
  if (groupsn_ == &::google::protobuf::internal::kEmptyString) {
    groupsn_ = new ::std::string;
  }
  return groupsn_;
}
inline ::std::string* TImMemberInfo::release_groupsn() {
  clear_has_groupsn();
  if (groupsn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupsn_;
    groupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMemberInfo::set_allocated_groupsn(::std::string* groupsn) {
  if (groupsn_ != &::google::protobuf::internal::kEmptyString) {
    delete groupsn_;
  }
  if (groupsn) {
    set_has_groupsn();
    groupsn_ = groupsn;
  } else {
    clear_has_groupsn();
    groupsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string memberno = 3;
inline bool TImMemberInfo::has_memberno() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImMemberInfo::set_has_memberno() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImMemberInfo::clear_has_memberno() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImMemberInfo::clear_memberno() {
  if (memberno_ != &::google::protobuf::internal::kEmptyString) {
    memberno_->clear();
  }
  clear_has_memberno();
}
inline const ::std::string& TImMemberInfo::memberno() const {
  return *memberno_;
}
inline void TImMemberInfo::set_memberno(const ::std::string& value) {
  set_has_memberno();
  if (memberno_ == &::google::protobuf::internal::kEmptyString) {
    memberno_ = new ::std::string;
  }
  memberno_->assign(value);
}
inline void TImMemberInfo::set_memberno(const char* value) {
  set_has_memberno();
  if (memberno_ == &::google::protobuf::internal::kEmptyString) {
    memberno_ = new ::std::string;
  }
  memberno_->assign(value);
}
inline void TImMemberInfo::set_memberno(const char* value, size_t size) {
  set_has_memberno();
  if (memberno_ == &::google::protobuf::internal::kEmptyString) {
    memberno_ = new ::std::string;
  }
  memberno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMemberInfo::mutable_memberno() {
  set_has_memberno();
  if (memberno_ == &::google::protobuf::internal::kEmptyString) {
    memberno_ = new ::std::string;
  }
  return memberno_;
}
inline ::std::string* TImMemberInfo::release_memberno() {
  clear_has_memberno();
  if (memberno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = memberno_;
    memberno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMemberInfo::set_allocated_memberno(::std::string* memberno) {
  if (memberno_ != &::google::protobuf::internal::kEmptyString) {
    delete memberno_;
  }
  if (memberno) {
    set_has_memberno();
    memberno_ = memberno;
  } else {
    clear_has_memberno();
    memberno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string markname = 4;
inline bool TImMemberInfo::has_markname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImMemberInfo::set_has_markname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImMemberInfo::clear_has_markname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImMemberInfo::clear_markname() {
  if (markname_ != &::google::protobuf::internal::kEmptyString) {
    markname_->clear();
  }
  clear_has_markname();
}
inline const ::std::string& TImMemberInfo::markname() const {
  return *markname_;
}
inline void TImMemberInfo::set_markname(const ::std::string& value) {
  set_has_markname();
  if (markname_ == &::google::protobuf::internal::kEmptyString) {
    markname_ = new ::std::string;
  }
  markname_->assign(value);
}
inline void TImMemberInfo::set_markname(const char* value) {
  set_has_markname();
  if (markname_ == &::google::protobuf::internal::kEmptyString) {
    markname_ = new ::std::string;
  }
  markname_->assign(value);
}
inline void TImMemberInfo::set_markname(const char* value, size_t size) {
  set_has_markname();
  if (markname_ == &::google::protobuf::internal::kEmptyString) {
    markname_ = new ::std::string;
  }
  markname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImMemberInfo::mutable_markname() {
  set_has_markname();
  if (markname_ == &::google::protobuf::internal::kEmptyString) {
    markname_ = new ::std::string;
  }
  return markname_;
}
inline ::std::string* TImMemberInfo::release_markname() {
  clear_has_markname();
  if (markname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = markname_;
    markname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImMemberInfo::set_allocated_markname(::std::string* markname) {
  if (markname_ != &::google::protobuf::internal::kEmptyString) {
    delete markname_;
  }
  if (markname) {
    set_has_markname();
    markname_ = markname;
  } else {
    clear_has_markname();
    markname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtMemberType membertype = 5;
inline bool TImMemberInfo::has_membertype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImMemberInfo::set_has_membertype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImMemberInfo::clear_has_membertype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImMemberInfo::clear_membertype() {
  membertype_ = 0;
  clear_has_membertype();
}
inline ::mt::EmMtMemberType TImMemberInfo::membertype() const {
  return static_cast< ::mt::EmMtMemberType >(membertype_);
}
inline void TImMemberInfo::set_membertype(::mt::EmMtMemberType value) {
  assert(::mt::EmMtMemberType_IsValid(value));
  set_has_membertype();
  membertype_ = value;
}

// optional uint32 bitrate = 6;
inline bool TImMemberInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TImMemberInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TImMemberInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TImMemberInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TImMemberInfo::bitrate() const {
  return bitrate_;
}
inline void TImMemberInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.TMTWbParse_Keda_EntUser weiboinfo = 7;
inline bool TImMemberInfo::has_weiboinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TImMemberInfo::set_has_weiboinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TImMemberInfo::clear_has_weiboinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TImMemberInfo::clear_weiboinfo() {
  if (weiboinfo_ != NULL) weiboinfo_->::mt::TMTWbParse_Keda_EntUser::Clear();
  clear_has_weiboinfo();
}
inline const ::mt::TMTWbParse_Keda_EntUser& TImMemberInfo::weiboinfo() const {
  return weiboinfo_ != NULL ? *weiboinfo_ : *default_instance_->weiboinfo_;
}
inline ::mt::TMTWbParse_Keda_EntUser* TImMemberInfo::mutable_weiboinfo() {
  set_has_weiboinfo();
  if (weiboinfo_ == NULL) weiboinfo_ = new ::mt::TMTWbParse_Keda_EntUser;
  return weiboinfo_;
}
inline ::mt::TMTWbParse_Keda_EntUser* TImMemberInfo::release_weiboinfo() {
  clear_has_weiboinfo();
  ::mt::TMTWbParse_Keda_EntUser* temp = weiboinfo_;
  weiboinfo_ = NULL;
  return temp;
}
inline void TImMemberInfo::set_allocated_weiboinfo(::mt::TMTWbParse_Keda_EntUser* weiboinfo) {
  delete weiboinfo_;
  weiboinfo_ = weiboinfo;
  if (weiboinfo) {
    set_has_weiboinfo();
  } else {
    clear_has_weiboinfo();
  }
}

// optional bool noquery = 8;
inline bool TImMemberInfo::has_noquery() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TImMemberInfo::set_has_noquery() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TImMemberInfo::clear_has_noquery() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TImMemberInfo::clear_noquery() {
  noquery_ = false;
  clear_has_noquery();
}
inline bool TImMemberInfo::noquery() const {
  return noquery_;
}
inline void TImMemberInfo::set_noquery(bool value) {
  set_has_noquery();
  noquery_ = value;
}

// -------------------------------------------------------------------

// TImMemberList

// optional uint32 arraysize = 1;
inline bool TImMemberList::has_arraysize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImMemberList::set_has_arraysize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImMemberList::clear_has_arraysize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImMemberList::clear_arraysize() {
  arraysize_ = 0u;
  clear_has_arraysize();
}
inline ::google::protobuf::uint32 TImMemberList::arraysize() const {
  return arraysize_;
}
inline void TImMemberList::set_arraysize(::google::protobuf::uint32 value) {
  set_has_arraysize();
  arraysize_ = value;
}

// repeated .mt.TImMemberInfo array = 2;
inline int TImMemberList::array_size() const {
  return array_.size();
}
inline void TImMemberList::clear_array() {
  array_.Clear();
}
inline const ::mt::TImMemberInfo& TImMemberList::array(int index) const {
  return array_.Get(index);
}
inline ::mt::TImMemberInfo* TImMemberList::mutable_array(int index) {
  return array_.Mutable(index);
}
inline ::mt::TImMemberInfo* TImMemberList::add_array() {
  return array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImMemberInfo >&
TImMemberList::array() const {
  return array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImMemberInfo >*
TImMemberList::mutable_array() {
  return &array_;
}

// -------------------------------------------------------------------

// TMTSearchUserInfo

// optional .mt.EmMtOperateUserInfo emoperateuser = 1;
inline bool TMTSearchUserInfo::has_emoperateuser() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTSearchUserInfo::set_has_emoperateuser() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTSearchUserInfo::clear_has_emoperateuser() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTSearchUserInfo::clear_emoperateuser() {
  emoperateuser_ = 1;
  clear_has_emoperateuser();
}
inline ::mt::EmMtOperateUserInfo TMTSearchUserInfo::emoperateuser() const {
  return static_cast< ::mt::EmMtOperateUserInfo >(emoperateuser_);
}
inline void TMTSearchUserInfo::set_emoperateuser(::mt::EmMtOperateUserInfo value) {
  assert(::mt::EmMtOperateUserInfo_IsValid(value));
  set_has_emoperateuser();
  emoperateuser_ = value;
}

// optional uint32 xmppno = 2;
inline bool TMTSearchUserInfo::has_xmppno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTSearchUserInfo::set_has_xmppno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTSearchUserInfo::clear_has_xmppno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTSearchUserInfo::clear_xmppno() {
  xmppno_ = 0u;
  clear_has_xmppno();
}
inline ::google::protobuf::uint32 TMTSearchUserInfo::xmppno() const {
  return xmppno_;
}
inline void TMTSearchUserInfo::set_xmppno(::google::protobuf::uint32 value) {
  set_has_xmppno();
  xmppno_ = value;
}

// optional .mt.TImMemberInfo immemberinfo = 3;
inline bool TMTSearchUserInfo::has_immemberinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTSearchUserInfo::set_has_immemberinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTSearchUserInfo::clear_has_immemberinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTSearchUserInfo::clear_immemberinfo() {
  if (immemberinfo_ != NULL) immemberinfo_->::mt::TImMemberInfo::Clear();
  clear_has_immemberinfo();
}
inline const ::mt::TImMemberInfo& TMTSearchUserInfo::immemberinfo() const {
  return immemberinfo_ != NULL ? *immemberinfo_ : *default_instance_->immemberinfo_;
}
inline ::mt::TImMemberInfo* TMTSearchUserInfo::mutable_immemberinfo() {
  set_has_immemberinfo();
  if (immemberinfo_ == NULL) immemberinfo_ = new ::mt::TImMemberInfo;
  return immemberinfo_;
}
inline ::mt::TImMemberInfo* TMTSearchUserInfo::release_immemberinfo() {
  clear_has_immemberinfo();
  ::mt::TImMemberInfo* temp = immemberinfo_;
  immemberinfo_ = NULL;
  return temp;
}
inline void TMTSearchUserInfo::set_allocated_immemberinfo(::mt::TImMemberInfo* immemberinfo) {
  delete immemberinfo_;
  immemberinfo_ = immemberinfo;
  if (immemberinfo) {
    set_has_immemberinfo();
  } else {
    clear_has_immemberinfo();
  }
}

// -------------------------------------------------------------------

// TImMemberFullInfo

// optional .mt.TImMemberInfo memberinfo = 1;
inline bool TImMemberFullInfo::has_memberinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImMemberFullInfo::set_has_memberinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImMemberFullInfo::clear_has_memberinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImMemberFullInfo::clear_memberinfo() {
  if (memberinfo_ != NULL) memberinfo_->::mt::TImMemberInfo::Clear();
  clear_has_memberinfo();
}
inline const ::mt::TImMemberInfo& TImMemberFullInfo::memberinfo() const {
  return memberinfo_ != NULL ? *memberinfo_ : *default_instance_->memberinfo_;
}
inline ::mt::TImMemberInfo* TImMemberFullInfo::mutable_memberinfo() {
  set_has_memberinfo();
  if (memberinfo_ == NULL) memberinfo_ = new ::mt::TImMemberInfo;
  return memberinfo_;
}
inline ::mt::TImMemberInfo* TImMemberFullInfo::release_memberinfo() {
  clear_has_memberinfo();
  ::mt::TImMemberInfo* temp = memberinfo_;
  memberinfo_ = NULL;
  return temp;
}
inline void TImMemberFullInfo::set_allocated_memberinfo(::mt::TImMemberInfo* memberinfo) {
  delete memberinfo_;
  memberinfo_ = memberinfo;
  if (memberinfo) {
    set_has_memberinfo();
  } else {
    clear_has_memberinfo();
  }
}

// optional .mt.EmMtOnlineState memberstate = 2;
inline bool TImMemberFullInfo::has_memberstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImMemberFullInfo::set_has_memberstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImMemberFullInfo::clear_has_memberstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImMemberFullInfo::clear_memberstate() {
  memberstate_ = 0;
  clear_has_memberstate();
}
inline ::mt::EmMtOnlineState TImMemberFullInfo::memberstate() const {
  return static_cast< ::mt::EmMtOnlineState >(memberstate_);
}
inline void TImMemberFullInfo::set_memberstate(::mt::EmMtOnlineState value) {
  assert(::mt::EmMtOnlineState_IsValid(value));
  set_has_memberstate();
  memberstate_ = value;
}

// optional bool maxaudio = 3;
inline bool TImMemberFullInfo::has_maxaudio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImMemberFullInfo::set_has_maxaudio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImMemberFullInfo::clear_has_maxaudio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImMemberFullInfo::clear_maxaudio() {
  maxaudio_ = false;
  clear_has_maxaudio();
}
inline bool TImMemberFullInfo::maxaudio() const {
  return maxaudio_;
}
inline void TImMemberFullInfo::set_maxaudio(bool value) {
  set_has_maxaudio();
  maxaudio_ = value;
}

// optional bool maxvideo = 4;
inline bool TImMemberFullInfo::has_maxvideo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImMemberFullInfo::set_has_maxvideo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImMemberFullInfo::clear_has_maxvideo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImMemberFullInfo::clear_maxvideo() {
  maxvideo_ = false;
  clear_has_maxvideo();
}
inline bool TImMemberFullInfo::maxvideo() const {
  return maxvideo_;
}
inline void TImMemberFullInfo::set_maxvideo(bool value) {
  set_has_maxvideo();
  maxvideo_ = value;
}

// repeated .mt.TSubState mtstate = 5;
inline int TImMemberFullInfo::mtstate_size() const {
  return mtstate_.size();
}
inline void TImMemberFullInfo::clear_mtstate() {
  mtstate_.Clear();
}
inline const ::mt::TSubState& TImMemberFullInfo::mtstate(int index) const {
  return mtstate_.Get(index);
}
inline ::mt::TSubState* TImMemberFullInfo::mutable_mtstate(int index) {
  return mtstate_.Mutable(index);
}
inline ::mt::TSubState* TImMemberFullInfo::add_mtstate() {
  return mtstate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TSubState >&
TImMemberFullInfo::mtstate() const {
  return mtstate_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TSubState >*
TImMemberFullInfo::mutable_mtstate() {
  return &mtstate_;
}

// -------------------------------------------------------------------

// TMTAccountManagerSystem

// optional string username = 1;
inline bool TMTAccountManagerSystem::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTAccountManagerSystem::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTAccountManagerSystem::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTAccountManagerSystem::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMTAccountManagerSystem::username() const {
  return *username_;
}
inline void TMTAccountManagerSystem::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTAccountManagerSystem::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTAccountManagerSystem::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAccountManagerSystem::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMTAccountManagerSystem::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAccountManagerSystem::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool TMTAccountManagerSystem::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTAccountManagerSystem::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTAccountManagerSystem::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTAccountManagerSystem::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTAccountManagerSystem::password() const {
  return *password_;
}
inline void TMTAccountManagerSystem::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTAccountManagerSystem::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTAccountManagerSystem::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAccountManagerSystem::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTAccountManagerSystem::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAccountManagerSystem::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 bitmask = 3;
inline bool TMTAccountManagerSystem::has_bitmask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTAccountManagerSystem::set_has_bitmask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTAccountManagerSystem::clear_has_bitmask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTAccountManagerSystem::clear_bitmask() {
  bitmask_ = 0u;
  clear_has_bitmask();
}
inline ::google::protobuf::uint32 TMTAccountManagerSystem::bitmask() const {
  return bitmask_;
}
inline void TMTAccountManagerSystem::set_bitmask(::google::protobuf::uint32 value) {
  set_has_bitmask();
  bitmask_ = value;
}

// optional string mobilenum = 4;
inline bool TMTAccountManagerSystem::has_mobilenum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTAccountManagerSystem::set_has_mobilenum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTAccountManagerSystem::clear_has_mobilenum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTAccountManagerSystem::clear_mobilenum() {
  if (mobilenum_ != &::google::protobuf::internal::kEmptyString) {
    mobilenum_->clear();
  }
  clear_has_mobilenum();
}
inline const ::std::string& TMTAccountManagerSystem::mobilenum() const {
  return *mobilenum_;
}
inline void TMTAccountManagerSystem::set_mobilenum(const ::std::string& value) {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  mobilenum_->assign(value);
}
inline void TMTAccountManagerSystem::set_mobilenum(const char* value) {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  mobilenum_->assign(value);
}
inline void TMTAccountManagerSystem::set_mobilenum(const char* value, size_t size) {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  mobilenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAccountManagerSystem::mutable_mobilenum() {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  return mobilenum_;
}
inline ::std::string* TMTAccountManagerSystem::release_mobilenum() {
  clear_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilenum_;
    mobilenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAccountManagerSystem::set_allocated_mobilenum(::std::string* mobilenum) {
  if (mobilenum_ != &::google::protobuf::internal::kEmptyString) {
    delete mobilenum_;
  }
  if (mobilenum) {
    set_has_mobilenum();
    mobilenum_ = mobilenum;
  } else {
    clear_has_mobilenum();
    mobilenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extnum = 5;
inline bool TMTAccountManagerSystem::has_extnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTAccountManagerSystem::set_has_extnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTAccountManagerSystem::clear_has_extnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTAccountManagerSystem::clear_extnum() {
  if (extnum_ != &::google::protobuf::internal::kEmptyString) {
    extnum_->clear();
  }
  clear_has_extnum();
}
inline const ::std::string& TMTAccountManagerSystem::extnum() const {
  return *extnum_;
}
inline void TMTAccountManagerSystem::set_extnum(const ::std::string& value) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(value);
}
inline void TMTAccountManagerSystem::set_extnum(const char* value) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(value);
}
inline void TMTAccountManagerSystem::set_extnum(const char* value, size_t size) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAccountManagerSystem::mutable_extnum() {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  return extnum_;
}
inline ::std::string* TMTAccountManagerSystem::release_extnum() {
  clear_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extnum_;
    extnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAccountManagerSystem::set_allocated_extnum(::std::string* extnum) {
  if (extnum_ != &::google::protobuf::internal::kEmptyString) {
    delete extnum_;
  }
  if (extnum) {
    set_has_extnum();
    extnum_ = extnum;
  } else {
    clear_has_extnum();
    extnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string seat = 6;
inline bool TMTAccountManagerSystem::has_seat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTAccountManagerSystem::set_has_seat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTAccountManagerSystem::clear_has_seat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTAccountManagerSystem::clear_seat() {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    seat_->clear();
  }
  clear_has_seat();
}
inline const ::std::string& TMTAccountManagerSystem::seat() const {
  return *seat_;
}
inline void TMTAccountManagerSystem::set_seat(const ::std::string& value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void TMTAccountManagerSystem::set_seat(const char* value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void TMTAccountManagerSystem::set_seat(const char* value, size_t size) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAccountManagerSystem::mutable_seat() {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  return seat_;
}
inline ::std::string* TMTAccountManagerSystem::release_seat() {
  clear_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seat_;
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAccountManagerSystem::set_allocated_seat(::std::string* seat) {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    delete seat_;
  }
  if (seat) {
    set_has_seat();
    seat_ = seat;
  } else {
    clear_has_seat();
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brief = 7;
inline bool TMTAccountManagerSystem::has_brief() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTAccountManagerSystem::set_has_brief() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTAccountManagerSystem::clear_has_brief() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTAccountManagerSystem::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TMTAccountManagerSystem::brief() const {
  return *brief_;
}
inline void TMTAccountManagerSystem::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTAccountManagerSystem::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTAccountManagerSystem::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAccountManagerSystem::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TMTAccountManagerSystem::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAccountManagerSystem::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string position = 8;
inline bool TMTAccountManagerSystem::has_position() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTAccountManagerSystem::set_has_position() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTAccountManagerSystem::clear_has_position() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTAccountManagerSystem::clear_position() {
  if (position_ != &::google::protobuf::internal::kEmptyString) {
    position_->clear();
  }
  clear_has_position();
}
inline const ::std::string& TMTAccountManagerSystem::position() const {
  return *position_;
}
inline void TMTAccountManagerSystem::set_position(const ::std::string& value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(value);
}
inline void TMTAccountManagerSystem::set_position(const char* value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(value);
}
inline void TMTAccountManagerSystem::set_position(const char* value, size_t size) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAccountManagerSystem::mutable_position() {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  return position_;
}
inline ::std::string* TMTAccountManagerSystem::release_position() {
  clear_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = position_;
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAccountManagerSystem::set_allocated_position(::std::string* position) {
  if (position_ != &::google::protobuf::internal::kEmptyString) {
    delete position_;
  }
  if (position) {
    set_has_position();
    position_ = position;
  } else {
    clear_has_position();
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool male = 9;
inline bool TMTAccountManagerSystem::has_male() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTAccountManagerSystem::set_has_male() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTAccountManagerSystem::clear_has_male() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTAccountManagerSystem::clear_male() {
  male_ = false;
  clear_has_male();
}
inline bool TMTAccountManagerSystem::male() const {
  return male_;
}
inline void TMTAccountManagerSystem::set_male(bool value) {
  set_has_male();
  male_ = value;
}

// optional string name = 10;
inline bool TMTAccountManagerSystem::has_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTAccountManagerSystem::set_has_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTAccountManagerSystem::clear_has_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTAccountManagerSystem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTAccountManagerSystem::name() const {
  return *name_;
}
inline void TMTAccountManagerSystem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTAccountManagerSystem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTAccountManagerSystem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAccountManagerSystem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTAccountManagerSystem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAccountManagerSystem::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isadding = 11;
inline bool TMTAccountManagerSystem::has_isadding() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTAccountManagerSystem::set_has_isadding() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTAccountManagerSystem::clear_has_isadding() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTAccountManagerSystem::clear_isadding() {
  isadding_ = false;
  clear_has_isadding();
}
inline bool TMTAccountManagerSystem::isadding() const {
  return isadding_;
}
inline void TMTAccountManagerSystem::set_isadding(bool value) {
  set_has_isadding();
  isadding_ = value;
}

// optional string apiaddr = 12;
inline bool TMTAccountManagerSystem::has_apiaddr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTAccountManagerSystem::set_has_apiaddr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTAccountManagerSystem::clear_has_apiaddr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTAccountManagerSystem::clear_apiaddr() {
  if (apiaddr_ != &::google::protobuf::internal::kEmptyString) {
    apiaddr_->clear();
  }
  clear_has_apiaddr();
}
inline const ::std::string& TMTAccountManagerSystem::apiaddr() const {
  return *apiaddr_;
}
inline void TMTAccountManagerSystem::set_apiaddr(const ::std::string& value) {
  set_has_apiaddr();
  if (apiaddr_ == &::google::protobuf::internal::kEmptyString) {
    apiaddr_ = new ::std::string;
  }
  apiaddr_->assign(value);
}
inline void TMTAccountManagerSystem::set_apiaddr(const char* value) {
  set_has_apiaddr();
  if (apiaddr_ == &::google::protobuf::internal::kEmptyString) {
    apiaddr_ = new ::std::string;
  }
  apiaddr_->assign(value);
}
inline void TMTAccountManagerSystem::set_apiaddr(const char* value, size_t size) {
  set_has_apiaddr();
  if (apiaddr_ == &::google::protobuf::internal::kEmptyString) {
    apiaddr_ = new ::std::string;
  }
  apiaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAccountManagerSystem::mutable_apiaddr() {
  set_has_apiaddr();
  if (apiaddr_ == &::google::protobuf::internal::kEmptyString) {
    apiaddr_ = new ::std::string;
  }
  return apiaddr_;
}
inline ::std::string* TMTAccountManagerSystem::release_apiaddr() {
  clear_has_apiaddr();
  if (apiaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = apiaddr_;
    apiaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAccountManagerSystem::set_allocated_apiaddr(::std::string* apiaddr) {
  if (apiaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete apiaddr_;
  }
  if (apiaddr) {
    set_has_apiaddr();
    apiaddr_ = apiaddr;
  } else {
    clear_has_apiaddr();
    apiaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 contextid = 13;
inline bool TMTAccountManagerSystem::has_contextid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTAccountManagerSystem::set_has_contextid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTAccountManagerSystem::clear_has_contextid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTAccountManagerSystem::clear_contextid() {
  contextid_ = 0u;
  clear_has_contextid();
}
inline ::google::protobuf::uint32 TMTAccountManagerSystem::contextid() const {
  return contextid_;
}
inline void TMTAccountManagerSystem::set_contextid(::google::protobuf::uint32 value) {
  set_has_contextid();
  contextid_ = value;
}

// optional string email = 14;
inline bool TMTAccountManagerSystem::has_email() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTAccountManagerSystem::set_has_email() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTAccountManagerSystem::clear_has_email() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTAccountManagerSystem::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& TMTAccountManagerSystem::email() const {
  return *email_;
}
inline void TMTAccountManagerSystem::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTAccountManagerSystem::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTAccountManagerSystem::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAccountManagerSystem::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* TMTAccountManagerSystem::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAccountManagerSystem::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TRestErrorInfo

// optional string errorinfo = 1;
inline bool TRestErrorInfo::has_errorinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRestErrorInfo::set_has_errorinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRestErrorInfo::clear_has_errorinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRestErrorInfo::clear_errorinfo() {
  if (errorinfo_ != &::google::protobuf::internal::kEmptyString) {
    errorinfo_->clear();
  }
  clear_has_errorinfo();
}
inline const ::std::string& TRestErrorInfo::errorinfo() const {
  return *errorinfo_;
}
inline void TRestErrorInfo::set_errorinfo(const ::std::string& value) {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  errorinfo_->assign(value);
}
inline void TRestErrorInfo::set_errorinfo(const char* value) {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  errorinfo_->assign(value);
}
inline void TRestErrorInfo::set_errorinfo(const char* value, size_t size) {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  errorinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TRestErrorInfo::mutable_errorinfo() {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  return errorinfo_;
}
inline ::std::string* TRestErrorInfo::release_errorinfo() {
  clear_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errorinfo_;
    errorinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TRestErrorInfo::set_allocated_errorinfo(::std::string* errorinfo) {
  if (errorinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete errorinfo_;
  }
  if (errorinfo) {
    set_has_errorinfo();
    errorinfo_ = errorinfo;
  } else {
    clear_has_errorinfo();
    errorinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 errorid = 2;
inline bool TRestErrorInfo::has_errorid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRestErrorInfo::set_has_errorid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRestErrorInfo::clear_has_errorid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRestErrorInfo::clear_errorid() {
  errorid_ = 0u;
  clear_has_errorid();
}
inline ::google::protobuf::uint32 TRestErrorInfo::errorid() const {
  return errorid_;
}
inline void TRestErrorInfo::set_errorid(::google::protobuf::uint32 value) {
  set_has_errorid();
  errorid_ = value;
}

// optional .mt.APIType apitype = 3;
inline bool TRestErrorInfo::has_apitype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TRestErrorInfo::set_has_apitype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TRestErrorInfo::clear_has_apitype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TRestErrorInfo::clear_apitype() {
  apitype_ = 0;
  clear_has_apitype();
}
inline ::mt::APIType TRestErrorInfo::apitype() const {
  return static_cast< ::mt::APIType >(apitype_);
}
inline void TRestErrorInfo::set_apitype(::mt::APIType value) {
  assert(::mt::APIType_IsValid(value));
  set_has_apitype();
  apitype_ = value;
}

// optional uint32 nackeventid = 4;
inline bool TRestErrorInfo::has_nackeventid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TRestErrorInfo::set_has_nackeventid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TRestErrorInfo::clear_has_nackeventid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TRestErrorInfo::clear_nackeventid() {
  nackeventid_ = 0u;
  clear_has_nackeventid();
}
inline ::google::protobuf::uint32 TRestErrorInfo::nackeventid() const {
  return nackeventid_;
}
inline void TRestErrorInfo::set_nackeventid(::google::protobuf::uint32 value) {
  set_has_nackeventid();
  nackeventid_ = value;
}

// repeated uint32 params = 5;
inline int TRestErrorInfo::params_size() const {
  return params_.size();
}
inline void TRestErrorInfo::clear_params() {
  params_.Clear();
}
inline ::google::protobuf::uint32 TRestErrorInfo::params(int index) const {
  return params_.Get(index);
}
inline void TRestErrorInfo::set_params(int index, ::google::protobuf::uint32 value) {
  params_.Set(index, value);
}
inline void TRestErrorInfo::add_params(::google::protobuf::uint32 value) {
  params_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TRestErrorInfo::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TRestErrorInfo::mutable_params() {
  return &params_;
}

// -------------------------------------------------------------------

// TCacheP2PMsg

// optional bool used = 1;
inline bool TCacheP2PMsg::has_used() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCacheP2PMsg::set_has_used() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCacheP2PMsg::clear_has_used() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCacheP2PMsg::clear_used() {
  used_ = false;
  clear_has_used();
}
inline bool TCacheP2PMsg::used() const {
  return used_;
}
inline void TCacheP2PMsg::set_used(bool value) {
  set_has_used();
  used_ = value;
}

// optional uint32 handle = 2;
inline bool TCacheP2PMsg::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCacheP2PMsg::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCacheP2PMsg::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCacheP2PMsg::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 TCacheP2PMsg::handle() const {
  return handle_;
}
inline void TCacheP2PMsg::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
}

// optional .mt.TImP2PChatMessage data = 3;
inline bool TCacheP2PMsg::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TCacheP2PMsg::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TCacheP2PMsg::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TCacheP2PMsg::clear_data() {
  if (data_ != NULL) data_->::mt::TImP2PChatMessage::Clear();
  clear_has_data();
}
inline const ::mt::TImP2PChatMessage& TCacheP2PMsg::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::mt::TImP2PChatMessage* TCacheP2PMsg::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::mt::TImP2PChatMessage;
  return data_;
}
inline ::mt::TImP2PChatMessage* TCacheP2PMsg::release_data() {
  clear_has_data();
  ::mt::TImP2PChatMessage* temp = data_;
  data_ = NULL;
  return temp;
}
inline void TCacheP2PMsg::set_allocated_data(::mt::TImP2PChatMessage* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// optional uint32 contextId = 4;
inline bool TCacheP2PMsg::has_contextid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TCacheP2PMsg::set_has_contextid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TCacheP2PMsg::clear_has_contextid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TCacheP2PMsg::clear_contextid() {
  contextid_ = 0u;
  clear_has_contextid();
}
inline ::google::protobuf::uint32 TCacheP2PMsg::contextid() const {
  return contextid_;
}
inline void TCacheP2PMsg::set_contextid(::google::protobuf::uint32 value) {
  set_has_contextid();
  contextid_ = value;
}

// optional uint32 session_cnt = 5;
inline bool TCacheP2PMsg::has_session_cnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TCacheP2PMsg::set_has_session_cnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TCacheP2PMsg::clear_has_session_cnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TCacheP2PMsg::clear_session_cnt() {
  session_cnt_ = 0u;
  clear_has_session_cnt();
}
inline ::google::protobuf::uint32 TCacheP2PMsg::session_cnt() const {
  return session_cnt_;
}
inline void TCacheP2PMsg::set_session_cnt(::google::protobuf::uint32 value) {
  set_has_session_cnt();
  session_cnt_ = value;
}

// optional string session = 6;
inline bool TCacheP2PMsg::has_session() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TCacheP2PMsg::set_has_session() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TCacheP2PMsg::clear_has_session() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TCacheP2PMsg::clear_session() {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    session_->clear();
  }
  clear_has_session();
}
inline const ::std::string& TCacheP2PMsg::session() const {
  return *session_;
}
inline void TCacheP2PMsg::set_session(const ::std::string& value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void TCacheP2PMsg::set_session(const char* value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void TCacheP2PMsg::set_session(const char* value, size_t size) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TCacheP2PMsg::mutable_session() {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  return session_;
}
inline ::std::string* TCacheP2PMsg::release_session() {
  clear_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_;
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TCacheP2PMsg::set_allocated_session(::std::string* session) {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    delete session_;
  }
  if (session) {
    set_has_session();
    session_ = session;
  } else {
    clear_has_session();
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TCacheGroupChatMsg

// optional bool used = 1;
inline bool TCacheGroupChatMsg::has_used() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCacheGroupChatMsg::set_has_used() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCacheGroupChatMsg::clear_has_used() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCacheGroupChatMsg::clear_used() {
  used_ = false;
  clear_has_used();
}
inline bool TCacheGroupChatMsg::used() const {
  return used_;
}
inline void TCacheGroupChatMsg::set_used(bool value) {
  set_has_used();
  used_ = value;
}

// optional uint32 handle = 2;
inline bool TCacheGroupChatMsg::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCacheGroupChatMsg::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCacheGroupChatMsg::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCacheGroupChatMsg::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 TCacheGroupChatMsg::handle() const {
  return handle_;
}
inline void TCacheGroupChatMsg::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
}

// optional .mt.TImMultiChatMessage data = 3;
inline bool TCacheGroupChatMsg::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TCacheGroupChatMsg::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TCacheGroupChatMsg::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TCacheGroupChatMsg::clear_data() {
  if (data_ != NULL) data_->::mt::TImMultiChatMessage::Clear();
  clear_has_data();
}
inline const ::mt::TImMultiChatMessage& TCacheGroupChatMsg::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::mt::TImMultiChatMessage* TCacheGroupChatMsg::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::mt::TImMultiChatMessage;
  return data_;
}
inline ::mt::TImMultiChatMessage* TCacheGroupChatMsg::release_data() {
  clear_has_data();
  ::mt::TImMultiChatMessage* temp = data_;
  data_ = NULL;
  return temp;
}
inline void TCacheGroupChatMsg::set_allocated_data(::mt::TImMultiChatMessage* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// optional uint32 contextId = 4;
inline bool TCacheGroupChatMsg::has_contextid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TCacheGroupChatMsg::set_has_contextid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TCacheGroupChatMsg::clear_has_contextid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TCacheGroupChatMsg::clear_contextid() {
  contextid_ = 0u;
  clear_has_contextid();
}
inline ::google::protobuf::uint32 TCacheGroupChatMsg::contextid() const {
  return contextid_;
}
inline void TCacheGroupChatMsg::set_contextid(::google::protobuf::uint32 value) {
  set_has_contextid();
  contextid_ = value;
}

// optional uint32 session_cnt = 5;
inline bool TCacheGroupChatMsg::has_session_cnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TCacheGroupChatMsg::set_has_session_cnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TCacheGroupChatMsg::clear_has_session_cnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TCacheGroupChatMsg::clear_session_cnt() {
  session_cnt_ = 0u;
  clear_has_session_cnt();
}
inline ::google::protobuf::uint32 TCacheGroupChatMsg::session_cnt() const {
  return session_cnt_;
}
inline void TCacheGroupChatMsg::set_session_cnt(::google::protobuf::uint32 value) {
  set_has_session_cnt();
  session_cnt_ = value;
}

// optional string session = 6;
inline bool TCacheGroupChatMsg::has_session() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TCacheGroupChatMsg::set_has_session() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TCacheGroupChatMsg::clear_has_session() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TCacheGroupChatMsg::clear_session() {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    session_->clear();
  }
  clear_has_session();
}
inline const ::std::string& TCacheGroupChatMsg::session() const {
  return *session_;
}
inline void TCacheGroupChatMsg::set_session(const ::std::string& value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void TCacheGroupChatMsg::set_session(const char* value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void TCacheGroupChatMsg::set_session(const char* value, size_t size) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TCacheGroupChatMsg::mutable_session() {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  return session_;
}
inline ::std::string* TCacheGroupChatMsg::release_session() {
  clear_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_;
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TCacheGroupChatMsg::set_allocated_session(::std::string* session) {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    delete session_;
  }
  if (session) {
    set_has_session();
    session_ = session;
  } else {
    clear_has_session();
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImChatPicInfo

// optional uint32 index = 1;
inline bool TImChatPicInfo::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImChatPicInfo::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImChatPicInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImChatPicInfo::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TImChatPicInfo::index() const {
  return index_;
}
inline void TImChatPicInfo::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional string filename = 2;
inline bool TImChatPicInfo::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImChatPicInfo::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImChatPicInfo::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImChatPicInfo::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& TImChatPicInfo::filename() const {
  return *filename_;
}
inline void TImChatPicInfo::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TImChatPicInfo::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TImChatPicInfo::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImChatPicInfo::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* TImChatPicInfo::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImChatPicInfo::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImFont

// optional uint32 height = 1;
inline bool TImFont::has_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImFont::set_has_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImFont::clear_has_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImFont::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 TImFont::height() const {
  return height_;
}
inline void TImFont::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// optional uint32 width = 2;
inline bool TImFont::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImFont::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImFont::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImFont::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 TImFont::width() const {
  return width_;
}
inline void TImFont::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional uint32 escapement = 3;
inline bool TImFont::has_escapement() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImFont::set_has_escapement() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImFont::clear_has_escapement() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImFont::clear_escapement() {
  escapement_ = 0u;
  clear_has_escapement();
}
inline ::google::protobuf::uint32 TImFont::escapement() const {
  return escapement_;
}
inline void TImFont::set_escapement(::google::protobuf::uint32 value) {
  set_has_escapement();
  escapement_ = value;
}

// optional uint32 orientation = 4;
inline bool TImFont::has_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImFont::set_has_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImFont::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImFont::clear_orientation() {
  orientation_ = 0u;
  clear_has_orientation();
}
inline ::google::protobuf::uint32 TImFont::orientation() const {
  return orientation_;
}
inline void TImFont::set_orientation(::google::protobuf::uint32 value) {
  set_has_orientation();
  orientation_ = value;
}

// optional uint32 weight = 5;
inline bool TImFont::has_weight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImFont::set_has_weight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImFont::clear_has_weight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImFont::clear_weight() {
  weight_ = 0u;
  clear_has_weight();
}
inline ::google::protobuf::uint32 TImFont::weight() const {
  return weight_;
}
inline void TImFont::set_weight(::google::protobuf::uint32 value) {
  set_has_weight();
  weight_ = value;
}

// optional bytes italic = 6;
inline bool TImFont::has_italic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TImFont::set_has_italic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TImFont::clear_has_italic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TImFont::clear_italic() {
  if (italic_ != &::google::protobuf::internal::kEmptyString) {
    italic_->clear();
  }
  clear_has_italic();
}
inline const ::std::string& TImFont::italic() const {
  return *italic_;
}
inline void TImFont::set_italic(const ::std::string& value) {
  set_has_italic();
  if (italic_ == &::google::protobuf::internal::kEmptyString) {
    italic_ = new ::std::string;
  }
  italic_->assign(value);
}
inline void TImFont::set_italic(const char* value) {
  set_has_italic();
  if (italic_ == &::google::protobuf::internal::kEmptyString) {
    italic_ = new ::std::string;
  }
  italic_->assign(value);
}
inline void TImFont::set_italic(const void* value, size_t size) {
  set_has_italic();
  if (italic_ == &::google::protobuf::internal::kEmptyString) {
    italic_ = new ::std::string;
  }
  italic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFont::mutable_italic() {
  set_has_italic();
  if (italic_ == &::google::protobuf::internal::kEmptyString) {
    italic_ = new ::std::string;
  }
  return italic_;
}
inline ::std::string* TImFont::release_italic() {
  clear_has_italic();
  if (italic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = italic_;
    italic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFont::set_allocated_italic(::std::string* italic) {
  if (italic_ != &::google::protobuf::internal::kEmptyString) {
    delete italic_;
  }
  if (italic) {
    set_has_italic();
    italic_ = italic;
  } else {
    clear_has_italic();
    italic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes underline = 7;
inline bool TImFont::has_underline() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TImFont::set_has_underline() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TImFont::clear_has_underline() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TImFont::clear_underline() {
  if (underline_ != &::google::protobuf::internal::kEmptyString) {
    underline_->clear();
  }
  clear_has_underline();
}
inline const ::std::string& TImFont::underline() const {
  return *underline_;
}
inline void TImFont::set_underline(const ::std::string& value) {
  set_has_underline();
  if (underline_ == &::google::protobuf::internal::kEmptyString) {
    underline_ = new ::std::string;
  }
  underline_->assign(value);
}
inline void TImFont::set_underline(const char* value) {
  set_has_underline();
  if (underline_ == &::google::protobuf::internal::kEmptyString) {
    underline_ = new ::std::string;
  }
  underline_->assign(value);
}
inline void TImFont::set_underline(const void* value, size_t size) {
  set_has_underline();
  if (underline_ == &::google::protobuf::internal::kEmptyString) {
    underline_ = new ::std::string;
  }
  underline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFont::mutable_underline() {
  set_has_underline();
  if (underline_ == &::google::protobuf::internal::kEmptyString) {
    underline_ = new ::std::string;
  }
  return underline_;
}
inline ::std::string* TImFont::release_underline() {
  clear_has_underline();
  if (underline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underline_;
    underline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFont::set_allocated_underline(::std::string* underline) {
  if (underline_ != &::google::protobuf::internal::kEmptyString) {
    delete underline_;
  }
  if (underline) {
    set_has_underline();
    underline_ = underline;
  } else {
    clear_has_underline();
    underline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strikeOut = 8;
inline bool TImFont::has_strikeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TImFont::set_has_strikeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TImFont::clear_has_strikeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TImFont::clear_strikeout() {
  if (strikeout_ != &::google::protobuf::internal::kEmptyString) {
    strikeout_->clear();
  }
  clear_has_strikeout();
}
inline const ::std::string& TImFont::strikeout() const {
  return *strikeout_;
}
inline void TImFont::set_strikeout(const ::std::string& value) {
  set_has_strikeout();
  if (strikeout_ == &::google::protobuf::internal::kEmptyString) {
    strikeout_ = new ::std::string;
  }
  strikeout_->assign(value);
}
inline void TImFont::set_strikeout(const char* value) {
  set_has_strikeout();
  if (strikeout_ == &::google::protobuf::internal::kEmptyString) {
    strikeout_ = new ::std::string;
  }
  strikeout_->assign(value);
}
inline void TImFont::set_strikeout(const void* value, size_t size) {
  set_has_strikeout();
  if (strikeout_ == &::google::protobuf::internal::kEmptyString) {
    strikeout_ = new ::std::string;
  }
  strikeout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFont::mutable_strikeout() {
  set_has_strikeout();
  if (strikeout_ == &::google::protobuf::internal::kEmptyString) {
    strikeout_ = new ::std::string;
  }
  return strikeout_;
}
inline ::std::string* TImFont::release_strikeout() {
  clear_has_strikeout();
  if (strikeout_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strikeout_;
    strikeout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFont::set_allocated_strikeout(::std::string* strikeout) {
  if (strikeout_ != &::google::protobuf::internal::kEmptyString) {
    delete strikeout_;
  }
  if (strikeout) {
    set_has_strikeout();
    strikeout_ = strikeout;
  } else {
    clear_has_strikeout();
    strikeout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes charset = 9;
inline bool TImFont::has_charset() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TImFont::set_has_charset() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TImFont::clear_has_charset() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TImFont::clear_charset() {
  if (charset_ != &::google::protobuf::internal::kEmptyString) {
    charset_->clear();
  }
  clear_has_charset();
}
inline const ::std::string& TImFont::charset() const {
  return *charset_;
}
inline void TImFont::set_charset(const ::std::string& value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void TImFont::set_charset(const char* value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void TImFont::set_charset(const void* value, size_t size) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFont::mutable_charset() {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  return charset_;
}
inline ::std::string* TImFont::release_charset() {
  clear_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charset_;
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFont::set_allocated_charset(::std::string* charset) {
  if (charset_ != &::google::protobuf::internal::kEmptyString) {
    delete charset_;
  }
  if (charset) {
    set_has_charset();
    charset_ = charset;
  } else {
    clear_has_charset();
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes outprecision = 10;
inline bool TImFont::has_outprecision() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TImFont::set_has_outprecision() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TImFont::clear_has_outprecision() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TImFont::clear_outprecision() {
  if (outprecision_ != &::google::protobuf::internal::kEmptyString) {
    outprecision_->clear();
  }
  clear_has_outprecision();
}
inline const ::std::string& TImFont::outprecision() const {
  return *outprecision_;
}
inline void TImFont::set_outprecision(const ::std::string& value) {
  set_has_outprecision();
  if (outprecision_ == &::google::protobuf::internal::kEmptyString) {
    outprecision_ = new ::std::string;
  }
  outprecision_->assign(value);
}
inline void TImFont::set_outprecision(const char* value) {
  set_has_outprecision();
  if (outprecision_ == &::google::protobuf::internal::kEmptyString) {
    outprecision_ = new ::std::string;
  }
  outprecision_->assign(value);
}
inline void TImFont::set_outprecision(const void* value, size_t size) {
  set_has_outprecision();
  if (outprecision_ == &::google::protobuf::internal::kEmptyString) {
    outprecision_ = new ::std::string;
  }
  outprecision_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFont::mutable_outprecision() {
  set_has_outprecision();
  if (outprecision_ == &::google::protobuf::internal::kEmptyString) {
    outprecision_ = new ::std::string;
  }
  return outprecision_;
}
inline ::std::string* TImFont::release_outprecision() {
  clear_has_outprecision();
  if (outprecision_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outprecision_;
    outprecision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFont::set_allocated_outprecision(::std::string* outprecision) {
  if (outprecision_ != &::google::protobuf::internal::kEmptyString) {
    delete outprecision_;
  }
  if (outprecision) {
    set_has_outprecision();
    outprecision_ = outprecision;
  } else {
    clear_has_outprecision();
    outprecision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes clipprecision = 11;
inline bool TImFont::has_clipprecision() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TImFont::set_has_clipprecision() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TImFont::clear_has_clipprecision() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TImFont::clear_clipprecision() {
  if (clipprecision_ != &::google::protobuf::internal::kEmptyString) {
    clipprecision_->clear();
  }
  clear_has_clipprecision();
}
inline const ::std::string& TImFont::clipprecision() const {
  return *clipprecision_;
}
inline void TImFont::set_clipprecision(const ::std::string& value) {
  set_has_clipprecision();
  if (clipprecision_ == &::google::protobuf::internal::kEmptyString) {
    clipprecision_ = new ::std::string;
  }
  clipprecision_->assign(value);
}
inline void TImFont::set_clipprecision(const char* value) {
  set_has_clipprecision();
  if (clipprecision_ == &::google::protobuf::internal::kEmptyString) {
    clipprecision_ = new ::std::string;
  }
  clipprecision_->assign(value);
}
inline void TImFont::set_clipprecision(const void* value, size_t size) {
  set_has_clipprecision();
  if (clipprecision_ == &::google::protobuf::internal::kEmptyString) {
    clipprecision_ = new ::std::string;
  }
  clipprecision_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFont::mutable_clipprecision() {
  set_has_clipprecision();
  if (clipprecision_ == &::google::protobuf::internal::kEmptyString) {
    clipprecision_ = new ::std::string;
  }
  return clipprecision_;
}
inline ::std::string* TImFont::release_clipprecision() {
  clear_has_clipprecision();
  if (clipprecision_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clipprecision_;
    clipprecision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFont::set_allocated_clipprecision(::std::string* clipprecision) {
  if (clipprecision_ != &::google::protobuf::internal::kEmptyString) {
    delete clipprecision_;
  }
  if (clipprecision) {
    set_has_clipprecision();
    clipprecision_ = clipprecision;
  } else {
    clear_has_clipprecision();
    clipprecision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes quality = 12;
inline bool TImFont::has_quality() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TImFont::set_has_quality() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TImFont::clear_has_quality() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TImFont::clear_quality() {
  if (quality_ != &::google::protobuf::internal::kEmptyString) {
    quality_->clear();
  }
  clear_has_quality();
}
inline const ::std::string& TImFont::quality() const {
  return *quality_;
}
inline void TImFont::set_quality(const ::std::string& value) {
  set_has_quality();
  if (quality_ == &::google::protobuf::internal::kEmptyString) {
    quality_ = new ::std::string;
  }
  quality_->assign(value);
}
inline void TImFont::set_quality(const char* value) {
  set_has_quality();
  if (quality_ == &::google::protobuf::internal::kEmptyString) {
    quality_ = new ::std::string;
  }
  quality_->assign(value);
}
inline void TImFont::set_quality(const void* value, size_t size) {
  set_has_quality();
  if (quality_ == &::google::protobuf::internal::kEmptyString) {
    quality_ = new ::std::string;
  }
  quality_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFont::mutable_quality() {
  set_has_quality();
  if (quality_ == &::google::protobuf::internal::kEmptyString) {
    quality_ = new ::std::string;
  }
  return quality_;
}
inline ::std::string* TImFont::release_quality() {
  clear_has_quality();
  if (quality_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = quality_;
    quality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFont::set_allocated_quality(::std::string* quality) {
  if (quality_ != &::google::protobuf::internal::kEmptyString) {
    delete quality_;
  }
  if (quality) {
    set_has_quality();
    quality_ = quality;
  } else {
    clear_has_quality();
    quality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pitchandfamily = 13;
inline bool TImFont::has_pitchandfamily() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TImFont::set_has_pitchandfamily() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TImFont::clear_has_pitchandfamily() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TImFont::clear_pitchandfamily() {
  if (pitchandfamily_ != &::google::protobuf::internal::kEmptyString) {
    pitchandfamily_->clear();
  }
  clear_has_pitchandfamily();
}
inline const ::std::string& TImFont::pitchandfamily() const {
  return *pitchandfamily_;
}
inline void TImFont::set_pitchandfamily(const ::std::string& value) {
  set_has_pitchandfamily();
  if (pitchandfamily_ == &::google::protobuf::internal::kEmptyString) {
    pitchandfamily_ = new ::std::string;
  }
  pitchandfamily_->assign(value);
}
inline void TImFont::set_pitchandfamily(const char* value) {
  set_has_pitchandfamily();
  if (pitchandfamily_ == &::google::protobuf::internal::kEmptyString) {
    pitchandfamily_ = new ::std::string;
  }
  pitchandfamily_->assign(value);
}
inline void TImFont::set_pitchandfamily(const void* value, size_t size) {
  set_has_pitchandfamily();
  if (pitchandfamily_ == &::google::protobuf::internal::kEmptyString) {
    pitchandfamily_ = new ::std::string;
  }
  pitchandfamily_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFont::mutable_pitchandfamily() {
  set_has_pitchandfamily();
  if (pitchandfamily_ == &::google::protobuf::internal::kEmptyString) {
    pitchandfamily_ = new ::std::string;
  }
  return pitchandfamily_;
}
inline ::std::string* TImFont::release_pitchandfamily() {
  clear_has_pitchandfamily();
  if (pitchandfamily_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pitchandfamily_;
    pitchandfamily_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFont::set_allocated_pitchandfamily(::std::string* pitchandfamily) {
  if (pitchandfamily_ != &::google::protobuf::internal::kEmptyString) {
    delete pitchandfamily_;
  }
  if (pitchandfamily) {
    set_has_pitchandfamily();
    pitchandfamily_ = pitchandfamily;
  } else {
    clear_has_pitchandfamily();
    pitchandfamily_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string facename = 14;
inline bool TImFont::has_facename() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TImFont::set_has_facename() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TImFont::clear_has_facename() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TImFont::clear_facename() {
  if (facename_ != &::google::protobuf::internal::kEmptyString) {
    facename_->clear();
  }
  clear_has_facename();
}
inline const ::std::string& TImFont::facename() const {
  return *facename_;
}
inline void TImFont::set_facename(const ::std::string& value) {
  set_has_facename();
  if (facename_ == &::google::protobuf::internal::kEmptyString) {
    facename_ = new ::std::string;
  }
  facename_->assign(value);
}
inline void TImFont::set_facename(const char* value) {
  set_has_facename();
  if (facename_ == &::google::protobuf::internal::kEmptyString) {
    facename_ = new ::std::string;
  }
  facename_->assign(value);
}
inline void TImFont::set_facename(const char* value, size_t size) {
  set_has_facename();
  if (facename_ == &::google::protobuf::internal::kEmptyString) {
    facename_ = new ::std::string;
  }
  facename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFont::mutable_facename() {
  set_has_facename();
  if (facename_ == &::google::protobuf::internal::kEmptyString) {
    facename_ = new ::std::string;
  }
  return facename_;
}
inline ::std::string* TImFont::release_facename() {
  clear_has_facename();
  if (facename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = facename_;
    facename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFont::set_allocated_facename(::std::string* facename) {
  if (facename_ != &::google::protobuf::internal::kEmptyString) {
    delete facename_;
  }
  if (facename) {
    set_has_facename();
    facename_ = facename;
  } else {
    clear_has_facename();
    facename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TImChatContent

// optional .mt.TImFont font = 1;
inline bool TImChatContent::has_font() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImChatContent::set_has_font() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImChatContent::clear_has_font() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImChatContent::clear_font() {
  if (font_ != NULL) font_->::mt::TImFont::Clear();
  clear_has_font();
}
inline const ::mt::TImFont& TImChatContent::font() const {
  return font_ != NULL ? *font_ : *default_instance_->font_;
}
inline ::mt::TImFont* TImChatContent::mutable_font() {
  set_has_font();
  if (font_ == NULL) font_ = new ::mt::TImFont;
  return font_;
}
inline ::mt::TImFont* TImChatContent::release_font() {
  clear_has_font();
  ::mt::TImFont* temp = font_;
  font_ = NULL;
  return temp;
}
inline void TImChatContent::set_allocated_font(::mt::TImFont* font) {
  delete font_;
  font_ = font;
  if (font) {
    set_has_font();
  } else {
    clear_has_font();
  }
}

// optional uint32 color = 2;
inline bool TImChatContent::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImChatContent::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImChatContent::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImChatContent::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 TImChatContent::color() const {
  return color_;
}
inline void TImChatContent::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
}

// optional uint32 time = 3;
inline bool TImChatContent::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImChatContent::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImChatContent::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImChatContent::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 TImChatContent::time() const {
  return time_;
}
inline void TImChatContent::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional bytes msgheader = 4;
inline bool TImChatContent::has_msgheader() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImChatContent::set_has_msgheader() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImChatContent::clear_has_msgheader() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImChatContent::clear_msgheader() {
  if (msgheader_ != &::google::protobuf::internal::kEmptyString) {
    msgheader_->clear();
  }
  clear_has_msgheader();
}
inline const ::std::string& TImChatContent::msgheader() const {
  return *msgheader_;
}
inline void TImChatContent::set_msgheader(const ::std::string& value) {
  set_has_msgheader();
  if (msgheader_ == &::google::protobuf::internal::kEmptyString) {
    msgheader_ = new ::std::string;
  }
  msgheader_->assign(value);
}
inline void TImChatContent::set_msgheader(const char* value) {
  set_has_msgheader();
  if (msgheader_ == &::google::protobuf::internal::kEmptyString) {
    msgheader_ = new ::std::string;
  }
  msgheader_->assign(value);
}
inline void TImChatContent::set_msgheader(const void* value, size_t size) {
  set_has_msgheader();
  if (msgheader_ == &::google::protobuf::internal::kEmptyString) {
    msgheader_ = new ::std::string;
  }
  msgheader_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImChatContent::mutable_msgheader() {
  set_has_msgheader();
  if (msgheader_ == &::google::protobuf::internal::kEmptyString) {
    msgheader_ = new ::std::string;
  }
  return msgheader_;
}
inline ::std::string* TImChatContent::release_msgheader() {
  clear_has_msgheader();
  if (msgheader_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgheader_;
    msgheader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImChatContent::set_allocated_msgheader(::std::string* msgheader) {
  if (msgheader_ != &::google::protobuf::internal::kEmptyString) {
    delete msgheader_;
  }
  if (msgheader) {
    set_has_msgheader();
    msgheader_ = msgheader;
  } else {
    clear_has_msgheader();
    msgheader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes content = 5;
inline bool TImChatContent::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImChatContent::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImChatContent::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImChatContent::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& TImChatContent::content() const {
  return *content_;
}
inline void TImChatContent::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void TImChatContent::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void TImChatContent::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImChatContent::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* TImChatContent::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImChatContent::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmChatType chattype = 6;
inline bool TImChatContent::has_chattype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TImChatContent::set_has_chattype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TImChatContent::clear_has_chattype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TImChatContent::clear_chattype() {
  chattype_ = 0;
  clear_has_chattype();
}
inline ::mt::EmChatType TImChatContent::chattype() const {
  return static_cast< ::mt::EmChatType >(chattype_);
}
inline void TImChatContent::set_chattype(::mt::EmChatType value) {
  assert(::mt::EmChatType_IsValid(value));
  set_has_chattype();
  chattype_ = value;
}

// optional bytes piccount = 7;
inline bool TImChatContent::has_piccount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TImChatContent::set_has_piccount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TImChatContent::clear_has_piccount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TImChatContent::clear_piccount() {
  if (piccount_ != &::google::protobuf::internal::kEmptyString) {
    piccount_->clear();
  }
  clear_has_piccount();
}
inline const ::std::string& TImChatContent::piccount() const {
  return *piccount_;
}
inline void TImChatContent::set_piccount(const ::std::string& value) {
  set_has_piccount();
  if (piccount_ == &::google::protobuf::internal::kEmptyString) {
    piccount_ = new ::std::string;
  }
  piccount_->assign(value);
}
inline void TImChatContent::set_piccount(const char* value) {
  set_has_piccount();
  if (piccount_ == &::google::protobuf::internal::kEmptyString) {
    piccount_ = new ::std::string;
  }
  piccount_->assign(value);
}
inline void TImChatContent::set_piccount(const void* value, size_t size) {
  set_has_piccount();
  if (piccount_ == &::google::protobuf::internal::kEmptyString) {
    piccount_ = new ::std::string;
  }
  piccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImChatContent::mutable_piccount() {
  set_has_piccount();
  if (piccount_ == &::google::protobuf::internal::kEmptyString) {
    piccount_ = new ::std::string;
  }
  return piccount_;
}
inline ::std::string* TImChatContent::release_piccount() {
  clear_has_piccount();
  if (piccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = piccount_;
    piccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImChatContent::set_allocated_piccount(::std::string* piccount) {
  if (piccount_ != &::google::protobuf::internal::kEmptyString) {
    delete piccount_;
  }
  if (piccount) {
    set_has_piccount();
    piccount_ = piccount;
  } else {
    clear_has_piccount();
    piccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mt.TImChatPicInfo picfileinfotable = 8;
inline int TImChatContent::picfileinfotable_size() const {
  return picfileinfotable_.size();
}
inline void TImChatContent::clear_picfileinfotable() {
  picfileinfotable_.Clear();
}
inline const ::mt::TImChatPicInfo& TImChatContent::picfileinfotable(int index) const {
  return picfileinfotable_.Get(index);
}
inline ::mt::TImChatPicInfo* TImChatContent::mutable_picfileinfotable(int index) {
  return picfileinfotable_.Mutable(index);
}
inline ::mt::TImChatPicInfo* TImChatContent::add_picfileinfotable() {
  return picfileinfotable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TImChatPicInfo >&
TImChatContent::picfileinfotable() const {
  return picfileinfotable_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TImChatPicInfo >*
TImChatContent::mutable_picfileinfotable() {
  return &picfileinfotable_;
}

// -------------------------------------------------------------------

// TCreateOrEnterChatroom

// optional uint32 app = 1;
inline bool TCreateOrEnterChatroom::has_app() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCreateOrEnterChatroom::set_has_app() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCreateOrEnterChatroom::clear_has_app() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCreateOrEnterChatroom::clear_app() {
  app_ = 0u;
  clear_has_app();
}
inline ::google::protobuf::uint32 TCreateOrEnterChatroom::app() const {
  return app_;
}
inline void TCreateOrEnterChatroom::set_app(::google::protobuf::uint32 value) {
  set_has_app();
  app_ = value;
}

// optional .mt.TImMulitChatCreateInfo info = 2;
inline bool TCreateOrEnterChatroom::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCreateOrEnterChatroom::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCreateOrEnterChatroom::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCreateOrEnterChatroom::clear_info() {
  if (info_ != NULL) info_->::mt::TImMulitChatCreateInfo::Clear();
  clear_has_info();
}
inline const ::mt::TImMulitChatCreateInfo& TCreateOrEnterChatroom::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::mt::TImMulitChatCreateInfo* TCreateOrEnterChatroom::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::mt::TImMulitChatCreateInfo;
  return info_;
}
inline ::mt::TImMulitChatCreateInfo* TCreateOrEnterChatroom::release_info() {
  clear_has_info();
  ::mt::TImMulitChatCreateInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void TCreateOrEnterChatroom::set_allocated_info(::mt::TImMulitChatCreateInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional uint32 session_cnt = 3;
inline bool TCreateOrEnterChatroom::has_session_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TCreateOrEnterChatroom::set_has_session_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TCreateOrEnterChatroom::clear_has_session_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TCreateOrEnterChatroom::clear_session_cnt() {
  session_cnt_ = 0u;
  clear_has_session_cnt();
}
inline ::google::protobuf::uint32 TCreateOrEnterChatroom::session_cnt() const {
  return session_cnt_;
}
inline void TCreateOrEnterChatroom::set_session_cnt(::google::protobuf::uint32 value) {
  set_has_session_cnt();
  session_cnt_ = value;
}

// optional string session = 4;
inline bool TCreateOrEnterChatroom::has_session() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TCreateOrEnterChatroom::set_has_session() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TCreateOrEnterChatroom::clear_has_session() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TCreateOrEnterChatroom::clear_session() {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    session_->clear();
  }
  clear_has_session();
}
inline const ::std::string& TCreateOrEnterChatroom::session() const {
  return *session_;
}
inline void TCreateOrEnterChatroom::set_session(const ::std::string& value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void TCreateOrEnterChatroom::set_session(const char* value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void TCreateOrEnterChatroom::set_session(const char* value, size_t size) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TCreateOrEnterChatroom::mutable_session() {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  return session_;
}
inline ::std::string* TCreateOrEnterChatroom::release_session() {
  clear_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_;
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TCreateOrEnterChatroom::set_allocated_session(::std::string* session) {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    delete session_;
  }
  if (session) {
    set_has_session();
    session_ = session;
  } else {
    clear_has_session();
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TDelayChatRoomInfo

// optional bool used = 1;
inline bool TDelayChatRoomInfo::has_used() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDelayChatRoomInfo::set_has_used() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDelayChatRoomInfo::clear_has_used() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDelayChatRoomInfo::clear_used() {
  used_ = false;
  clear_has_used();
}
inline bool TDelayChatRoomInfo::used() const {
  return used_;
}
inline void TDelayChatRoomInfo::set_used(bool value) {
  set_has_used();
  used_ = value;
}

// optional uint32 app = 2;
inline bool TDelayChatRoomInfo::has_app() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDelayChatRoomInfo::set_has_app() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDelayChatRoomInfo::clear_has_app() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDelayChatRoomInfo::clear_app() {
  app_ = 0u;
  clear_has_app();
}
inline ::google::protobuf::uint32 TDelayChatRoomInfo::app() const {
  return app_;
}
inline void TDelayChatRoomInfo::set_app(::google::protobuf::uint32 value) {
  set_has_app();
  app_ = value;
}

// optional uint32 room = 3;
inline bool TDelayChatRoomInfo::has_room() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TDelayChatRoomInfo::set_has_room() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TDelayChatRoomInfo::clear_has_room() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TDelayChatRoomInfo::clear_room() {
  room_ = 0u;
  clear_has_room();
}
inline ::google::protobuf::uint32 TDelayChatRoomInfo::room() const {
  return room_;
}
inline void TDelayChatRoomInfo::set_room(::google::protobuf::uint32 value) {
  set_has_room();
  room_ = value;
}

// optional bool invited = 4;
inline bool TDelayChatRoomInfo::has_invited() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TDelayChatRoomInfo::set_has_invited() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TDelayChatRoomInfo::clear_has_invited() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TDelayChatRoomInfo::clear_invited() {
  invited_ = false;
  clear_has_invited();
}
inline bool TDelayChatRoomInfo::invited() const {
  return invited_;
}
inline void TDelayChatRoomInfo::set_invited(bool value) {
  set_has_invited();
  invited_ = value;
}

// optional .mt.TImMulitChatCreateInfo info = 5;
inline bool TDelayChatRoomInfo::has_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TDelayChatRoomInfo::set_has_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TDelayChatRoomInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TDelayChatRoomInfo::clear_info() {
  if (info_ != NULL) info_->::mt::TImMulitChatCreateInfo::Clear();
  clear_has_info();
}
inline const ::mt::TImMulitChatCreateInfo& TDelayChatRoomInfo::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::mt::TImMulitChatCreateInfo* TDelayChatRoomInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::mt::TImMulitChatCreateInfo;
  return info_;
}
inline ::mt::TImMulitChatCreateInfo* TDelayChatRoomInfo::release_info() {
  clear_has_info();
  ::mt::TImMulitChatCreateInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void TDelayChatRoomInfo::set_allocated_info(::mt::TImMulitChatCreateInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional uint32 session_cnt = 6;
inline bool TDelayChatRoomInfo::has_session_cnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TDelayChatRoomInfo::set_has_session_cnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TDelayChatRoomInfo::clear_has_session_cnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TDelayChatRoomInfo::clear_session_cnt() {
  session_cnt_ = 0u;
  clear_has_session_cnt();
}
inline ::google::protobuf::uint32 TDelayChatRoomInfo::session_cnt() const {
  return session_cnt_;
}
inline void TDelayChatRoomInfo::set_session_cnt(::google::protobuf::uint32 value) {
  set_has_session_cnt();
  session_cnt_ = value;
}

// optional string session = 7;
inline bool TDelayChatRoomInfo::has_session() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TDelayChatRoomInfo::set_has_session() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TDelayChatRoomInfo::clear_has_session() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TDelayChatRoomInfo::clear_session() {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    session_->clear();
  }
  clear_has_session();
}
inline const ::std::string& TDelayChatRoomInfo::session() const {
  return *session_;
}
inline void TDelayChatRoomInfo::set_session(const ::std::string& value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void TDelayChatRoomInfo::set_session(const char* value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void TDelayChatRoomInfo::set_session(const char* value, size_t size) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDelayChatRoomInfo::mutable_session() {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  return session_;
}
inline ::std::string* TDelayChatRoomInfo::release_session() {
  clear_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_;
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDelayChatRoomInfo::set_allocated_session(::std::string* session) {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    delete session_;
  }
  if (session) {
    set_has_session();
    session_ = session;
  } else {
    clear_has_session();
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TPersistentChatroomItem

// optional string roomid = 1;
inline bool TPersistentChatroomItem::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPersistentChatroomItem::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPersistentChatroomItem::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPersistentChatroomItem::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& TPersistentChatroomItem::roomid() const {
  return *roomid_;
}
inline void TPersistentChatroomItem::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TPersistentChatroomItem::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void TPersistentChatroomItem::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TPersistentChatroomItem::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* TPersistentChatroomItem::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TPersistentChatroomItem::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string chatname = 2;
inline bool TPersistentChatroomItem::has_chatname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TPersistentChatroomItem::set_has_chatname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TPersistentChatroomItem::clear_has_chatname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TPersistentChatroomItem::clear_chatname() {
  if (chatname_ != &::google::protobuf::internal::kEmptyString) {
    chatname_->clear();
  }
  clear_has_chatname();
}
inline const ::std::string& TPersistentChatroomItem::chatname() const {
  return *chatname_;
}
inline void TPersistentChatroomItem::set_chatname(const ::std::string& value) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(value);
}
inline void TPersistentChatroomItem::set_chatname(const char* value) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(value);
}
inline void TPersistentChatroomItem::set_chatname(const char* value, size_t size) {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  chatname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TPersistentChatroomItem::mutable_chatname() {
  set_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    chatname_ = new ::std::string;
  }
  return chatname_;
}
inline ::std::string* TPersistentChatroomItem::release_chatname() {
  clear_has_chatname();
  if (chatname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chatname_;
    chatname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TPersistentChatroomItem::set_allocated_chatname(::std::string* chatname) {
  if (chatname_ != &::google::protobuf::internal::kEmptyString) {
    delete chatname_;
  }
  if (chatname) {
    set_has_chatname();
    chatname_ = chatname;
  } else {
    clear_has_chatname();
    chatname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TPersistentChatroomList

// optional uint32 arraysize = 1;
inline bool TPersistentChatroomList::has_arraysize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPersistentChatroomList::set_has_arraysize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPersistentChatroomList::clear_has_arraysize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPersistentChatroomList::clear_arraysize() {
  arraysize_ = 0u;
  clear_has_arraysize();
}
inline ::google::protobuf::uint32 TPersistentChatroomList::arraysize() const {
  return arraysize_;
}
inline void TPersistentChatroomList::set_arraysize(::google::protobuf::uint32 value) {
  set_has_arraysize();
  arraysize_ = value;
}

// repeated .mt.TPersistentChatroomItem array = 2;
inline int TPersistentChatroomList::array_size() const {
  return array_.size();
}
inline void TPersistentChatroomList::clear_array() {
  array_.Clear();
}
inline const ::mt::TPersistentChatroomItem& TPersistentChatroomList::array(int index) const {
  return array_.Get(index);
}
inline ::mt::TPersistentChatroomItem* TPersistentChatroomList::mutable_array(int index) {
  return array_.Mutable(index);
}
inline ::mt::TPersistentChatroomItem* TPersistentChatroomList::add_array() {
  return array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TPersistentChatroomItem >&
TPersistentChatroomList::array() const {
  return array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TPersistentChatroomItem >*
TPersistentChatroomList::mutable_array() {
  return &array_;
}

// -------------------------------------------------------------------

// TImFriendInfo

// optional string xmppno = 1;
inline bool TImFriendInfo::has_xmppno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TImFriendInfo::set_has_xmppno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TImFriendInfo::clear_has_xmppno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TImFriendInfo::clear_xmppno() {
  if (xmppno_ != &::google::protobuf::internal::kEmptyString) {
    xmppno_->clear();
  }
  clear_has_xmppno();
}
inline const ::std::string& TImFriendInfo::xmppno() const {
  return *xmppno_;
}
inline void TImFriendInfo::set_xmppno(const ::std::string& value) {
  set_has_xmppno();
  if (xmppno_ == &::google::protobuf::internal::kEmptyString) {
    xmppno_ = new ::std::string;
  }
  xmppno_->assign(value);
}
inline void TImFriendInfo::set_xmppno(const char* value) {
  set_has_xmppno();
  if (xmppno_ == &::google::protobuf::internal::kEmptyString) {
    xmppno_ = new ::std::string;
  }
  xmppno_->assign(value);
}
inline void TImFriendInfo::set_xmppno(const char* value, size_t size) {
  set_has_xmppno();
  if (xmppno_ == &::google::protobuf::internal::kEmptyString) {
    xmppno_ = new ::std::string;
  }
  xmppno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFriendInfo::mutable_xmppno() {
  set_has_xmppno();
  if (xmppno_ == &::google::protobuf::internal::kEmptyString) {
    xmppno_ = new ::std::string;
  }
  return xmppno_;
}
inline ::std::string* TImFriendInfo::release_xmppno() {
  clear_has_xmppno();
  if (xmppno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmppno_;
    xmppno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFriendInfo::set_allocated_xmppno(::std::string* xmppno) {
  if (xmppno_ != &::google::protobuf::internal::kEmptyString) {
    delete xmppno_;
  }
  if (xmppno) {
    set_has_xmppno();
    xmppno_ = xmppno;
  } else {
    clear_has_xmppno();
    xmppno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jid = 2;
inline bool TImFriendInfo::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TImFriendInfo::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TImFriendInfo::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TImFriendInfo::clear_jid() {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    jid_->clear();
  }
  clear_has_jid();
}
inline const ::std::string& TImFriendInfo::jid() const {
  return *jid_;
}
inline void TImFriendInfo::set_jid(const ::std::string& value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TImFriendInfo::set_jid(const char* value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TImFriendInfo::set_jid(const char* value, size_t size) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFriendInfo::mutable_jid() {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  return jid_;
}
inline ::std::string* TImFriendInfo::release_jid() {
  clear_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jid_;
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFriendInfo::set_allocated_jid(::std::string* jid) {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    delete jid_;
  }
  if (jid) {
    set_has_jid();
    jid_ = jid;
  } else {
    clear_has_jid();
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 recordno = 3;
inline bool TImFriendInfo::has_recordno() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TImFriendInfo::set_has_recordno() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TImFriendInfo::clear_has_recordno() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TImFriendInfo::clear_recordno() {
  recordno_ = 0u;
  clear_has_recordno();
}
inline ::google::protobuf::uint32 TImFriendInfo::recordno() const {
  return recordno_;
}
inline void TImFriendInfo::set_recordno(::google::protobuf::uint32 value) {
  set_has_recordno();
  recordno_ = value;
}

// optional string e164 = 4;
inline bool TImFriendInfo::has_e164() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TImFriendInfo::set_has_e164() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TImFriendInfo::clear_has_e164() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TImFriendInfo::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TImFriendInfo::e164() const {
  return *e164_;
}
inline void TImFriendInfo::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TImFriendInfo::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TImFriendInfo::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFriendInfo::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TImFriendInfo::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFriendInfo::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string h323id = 5;
inline bool TImFriendInfo::has_h323id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TImFriendInfo::set_has_h323id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TImFriendInfo::clear_has_h323id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TImFriendInfo::clear_h323id() {
  if (h323id_ != &::google::protobuf::internal::kEmptyString) {
    h323id_->clear();
  }
  clear_has_h323id();
}
inline const ::std::string& TImFriendInfo::h323id() const {
  return *h323id_;
}
inline void TImFriendInfo::set_h323id(const ::std::string& value) {
  set_has_h323id();
  if (h323id_ == &::google::protobuf::internal::kEmptyString) {
    h323id_ = new ::std::string;
  }
  h323id_->assign(value);
}
inline void TImFriendInfo::set_h323id(const char* value) {
  set_has_h323id();
  if (h323id_ == &::google::protobuf::internal::kEmptyString) {
    h323id_ = new ::std::string;
  }
  h323id_->assign(value);
}
inline void TImFriendInfo::set_h323id(const char* value, size_t size) {
  set_has_h323id();
  if (h323id_ == &::google::protobuf::internal::kEmptyString) {
    h323id_ = new ::std::string;
  }
  h323id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFriendInfo::mutable_h323id() {
  set_has_h323id();
  if (h323id_ == &::google::protobuf::internal::kEmptyString) {
    h323id_ = new ::std::string;
  }
  return h323id_;
}
inline ::std::string* TImFriendInfo::release_h323id() {
  clear_has_h323id();
  if (h323id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = h323id_;
    h323id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFriendInfo::set_allocated_h323id(::std::string* h323id) {
  if (h323id_ != &::google::protobuf::internal::kEmptyString) {
    delete h323id_;
  }
  if (h323id) {
    set_has_h323id();
    h323id_ = h323id;
  } else {
    clear_has_h323id();
    h323id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 6;
inline bool TImFriendInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TImFriendInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TImFriendInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TImFriendInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& TImFriendInfo::ip() const {
  return *ip_;
}
inline void TImFriendInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TImFriendInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TImFriendInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TImFriendInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* TImFriendInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TImFriendInfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mt

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_structim_2eproto__INCLUDED
