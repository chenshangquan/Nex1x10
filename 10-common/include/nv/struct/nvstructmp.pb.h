// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nvstructmp.proto

#ifndef PROTOBUF_nvstructmp_2eproto__INCLUDED
#define PROTOBUF_nvstructmp_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "nvenum.pb.h"
#include "nvstructcommon.pb.h"
#include "nvstructcfg.pb.h"
// @@protoc_insertion_point(includes)

namespace nv {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
void protobuf_AssignDesc_nvstructmp_2eproto();
void protobuf_ShutdownFile_nvstructmp_2eproto();

class TNVRtpRtcpPair;
class TNVNetRcvParam;
class TNVNetSndParam;
class TNVSnapshotFileInfo;
class TNVAudEncDecParam;
class TNVAudEncStatistic;
class TNVAudDecStatistic;
class TNVVidEncStatistic;
class TNVVidDecStatistic;
class TNVCodecStatistic;
class TNVInputEvent;
class TNVInputEvents;
class TNvVidSrcInfo;
class TNVVidEncParam;
class TNVVidSrcInfoList;
class TNVVidInPortResInfo;
class TNVVidInPortResInfoList;
class TNVChanAddr;
class TNVAudInPower;
class TNVAudInPowerList;
class TNVAudPort;
class TNVVidFreezePrm;
class TNVVidPoint;
class TNVVidLineOverlap;
class TQKCodeParam;

// ===================================================================

class MTMSG_API TNVRtpRtcpPair : public ::google::protobuf::Message {
 public:
  TNVRtpRtcpPair();
  virtual ~TNVRtpRtcpPair();

  TNVRtpRtcpPair(const TNVRtpRtcpPair& from);

  inline TNVRtpRtcpPair& operator=(const TNVRtpRtcpPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVRtpRtcpPair& default_instance();

  void Swap(TNVRtpRtcpPair* other);

  // implements Message ----------------------------------------------

  TNVRtpRtcpPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVRtpRtcpPair& from);
  void MergeFrom(const TNVRtpRtcpPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.TNVNetAddr rtp_addr = 1;
  inline bool has_rtp_addr() const;
  inline void clear_rtp_addr();
  static const int kRtpAddrFieldNumber = 1;
  inline const ::nv::TNVNetAddr& rtp_addr() const;
  inline ::nv::TNVNetAddr* mutable_rtp_addr();
  inline ::nv::TNVNetAddr* release_rtp_addr();
  inline void set_allocated_rtp_addr(::nv::TNVNetAddr* rtp_addr);

  // optional .nv.TNVNetAddr rtcp_addr = 2;
  inline bool has_rtcp_addr() const;
  inline void clear_rtcp_addr();
  static const int kRtcpAddrFieldNumber = 2;
  inline const ::nv::TNVNetAddr& rtcp_addr() const;
  inline ::nv::TNVNetAddr* mutable_rtcp_addr();
  inline ::nv::TNVNetAddr* release_rtcp_addr();
  inline void set_allocated_rtcp_addr(::nv::TNVNetAddr* rtcp_addr);

  // @@protoc_insertion_point(class_scope:nv.TNVRtpRtcpPair)
 private:
  inline void set_has_rtp_addr();
  inline void clear_has_rtp_addr();
  inline void set_has_rtcp_addr();
  inline void clear_has_rtcp_addr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::nv::TNVNetAddr* rtp_addr_;
  ::nv::TNVNetAddr* rtcp_addr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVRtpRtcpPair* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVNetRcvParam : public ::google::protobuf::Message {
 public:
  TNVNetRcvParam();
  virtual ~TNVNetRcvParam();

  TNVNetRcvParam(const TNVNetRcvParam& from);

  inline TNVNetRcvParam& operator=(const TNVNetRcvParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVNetRcvParam& default_instance();

  void Swap(TNVNetRcvParam* other);

  // implements Message ----------------------------------------------

  TNVNetRcvParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVNetRcvParam& from);
  void MergeFrom(const TNVNetRcvParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.TNVNetAddr rtp_rcv_addr = 1;
  inline bool has_rtp_rcv_addr() const;
  inline void clear_rtp_rcv_addr();
  static const int kRtpRcvAddrFieldNumber = 1;
  inline const ::nv::TNVNetAddr& rtp_rcv_addr() const;
  inline ::nv::TNVNetAddr* mutable_rtp_rcv_addr();
  inline ::nv::TNVNetAddr* release_rtp_rcv_addr();
  inline void set_allocated_rtp_rcv_addr(::nv::TNVNetAddr* rtp_rcv_addr);

  // optional .nv.TNVNetAddr rtcp_rcv_addr = 2;
  inline bool has_rtcp_rcv_addr() const;
  inline void clear_rtcp_rcv_addr();
  static const int kRtcpRcvAddrFieldNumber = 2;
  inline const ::nv::TNVNetAddr& rtcp_rcv_addr() const;
  inline ::nv::TNVNetAddr* mutable_rtcp_rcv_addr();
  inline ::nv::TNVNetAddr* release_rtcp_rcv_addr();
  inline void set_allocated_rtcp_rcv_addr(::nv::TNVNetAddr* rtcp_rcv_addr);

  // optional .nv.TNVNetAddr pinghole_addr = 3;
  inline bool has_pinghole_addr() const;
  inline void clear_pinghole_addr();
  static const int kPingholeAddrFieldNumber = 3;
  inline const ::nv::TNVNetAddr& pinghole_addr() const;
  inline ::nv::TNVNetAddr* mutable_pinghole_addr();
  inline ::nv::TNVNetAddr* release_pinghole_addr();
  inline void set_allocated_pinghole_addr(::nv::TNVNetAddr* pinghole_addr);

  // optional .nv.TNVNetAddr rtcp_snd_addr = 4;
  inline bool has_rtcp_snd_addr() const;
  inline void clear_rtcp_snd_addr();
  static const int kRtcpSndAddrFieldNumber = 4;
  inline const ::nv::TNVNetAddr& rtcp_snd_addr() const;
  inline ::nv::TNVNetAddr* mutable_rtcp_snd_addr();
  inline ::nv::TNVNetAddr* release_rtcp_snd_addr();
  inline void set_allocated_rtcp_snd_addr(::nv::TNVNetAddr* rtcp_snd_addr);

  // @@protoc_insertion_point(class_scope:nv.TNVNetRcvParam)
 private:
  inline void set_has_rtp_rcv_addr();
  inline void clear_has_rtp_rcv_addr();
  inline void set_has_rtcp_rcv_addr();
  inline void clear_has_rtcp_rcv_addr();
  inline void set_has_pinghole_addr();
  inline void clear_has_pinghole_addr();
  inline void set_has_rtcp_snd_addr();
  inline void clear_has_rtcp_snd_addr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::nv::TNVNetAddr* rtp_rcv_addr_;
  ::nv::TNVNetAddr* rtcp_rcv_addr_;
  ::nv::TNVNetAddr* pinghole_addr_;
  ::nv::TNVNetAddr* rtcp_snd_addr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVNetRcvParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVNetSndParam : public ::google::protobuf::Message {
 public:
  TNVNetSndParam();
  virtual ~TNVNetSndParam();

  TNVNetSndParam(const TNVNetSndParam& from);

  inline TNVNetSndParam& operator=(const TNVNetSndParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVNetSndParam& default_instance();

  void Swap(TNVNetSndParam* other);

  // implements Message ----------------------------------------------

  TNVNetSndParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVNetSndParam& from);
  void MergeFrom(const TNVNetSndParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.TNVRtpRtcpPair local_addr = 1;
  inline bool has_local_addr() const;
  inline void clear_local_addr();
  static const int kLocalAddrFieldNumber = 1;
  inline const ::nv::TNVRtpRtcpPair& local_addr() const;
  inline ::nv::TNVRtpRtcpPair* mutable_local_addr();
  inline ::nv::TNVRtpRtcpPair* release_local_addr();
  inline void set_allocated_local_addr(::nv::TNVRtpRtcpPair* local_addr);

  // repeated .nv.TNVRtpRtcpPair remote_addrs = 2;
  inline int remote_addrs_size() const;
  inline void clear_remote_addrs();
  static const int kRemoteAddrsFieldNumber = 2;
  inline const ::nv::TNVRtpRtcpPair& remote_addrs(int index) const;
  inline ::nv::TNVRtpRtcpPair* mutable_remote_addrs(int index);
  inline ::nv::TNVRtpRtcpPair* add_remote_addrs();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVRtpRtcpPair >&
      remote_addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVRtpRtcpPair >*
      mutable_remote_addrs();

  // @@protoc_insertion_point(class_scope:nv.TNVNetSndParam)
 private:
  inline void set_has_local_addr();
  inline void clear_has_local_addr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::nv::TNVRtpRtcpPair* local_addr_;
  ::google::protobuf::RepeatedPtrField< ::nv::TNVRtpRtcpPair > remote_addrs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVNetSndParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVSnapshotFileInfo : public ::google::protobuf::Message {
 public:
  TNVSnapshotFileInfo();
  virtual ~TNVSnapshotFileInfo();

  TNVSnapshotFileInfo(const TNVSnapshotFileInfo& from);

  inline TNVSnapshotFileInfo& operator=(const TNVSnapshotFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVSnapshotFileInfo& default_instance();

  void Swap(TNVSnapshotFileInfo* other);

  // implements Message ----------------------------------------------

  TNVSnapshotFileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVSnapshotFileInfo& from);
  void MergeFrom(const TNVSnapshotFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  inline void set_allocated_file_path(::std::string* file_path);

  // optional string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional .nv.TNVTime file_create_time = 3;
  inline bool has_file_create_time() const;
  inline void clear_file_create_time();
  static const int kFileCreateTimeFieldNumber = 3;
  inline const ::nv::TNVTime& file_create_time() const;
  inline ::nv::TNVTime* mutable_file_create_time();
  inline ::nv::TNVTime* release_file_create_time();
  inline void set_allocated_file_create_time(::nv::TNVTime* file_create_time);

  // @@protoc_insertion_point(class_scope:nv.TNVSnapshotFileInfo)
 private:
  inline void set_has_file_path();
  inline void clear_has_file_path();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_create_time();
  inline void clear_has_file_create_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_path_;
  ::std::string* file_name_;
  ::nv::TNVTime* file_create_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVSnapshotFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVAudEncDecParam : public ::google::protobuf::Message {
 public:
  TNVAudEncDecParam();
  virtual ~TNVAudEncDecParam();

  TNVAudEncDecParam(const TNVAudEncDecParam& from);

  inline TNVAudEncDecParam& operator=(const TNVAudEncDecParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVAudEncDecParam& default_instance();

  void Swap(TNVAudEncDecParam* other);

  // implements Message ----------------------------------------------

  TNVAudEncDecParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVAudEncDecParam& from);
  void MergeFrom(const TNVAudEncDecParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvAudFormat aud_format = 1;
  inline bool has_aud_format() const;
  inline void clear_aud_format();
  static const int kAudFormatFieldNumber = 1;
  inline ::nv::EmNvAudFormat aud_format() const;
  inline void set_aud_format(::nv::EmNvAudFormat value);

  // optional .nv.EmNvAacChnlNum aac_channel_num = 2;
  inline bool has_aac_channel_num() const;
  inline void clear_aac_channel_num();
  static const int kAacChannelNumFieldNumber = 2;
  inline ::nv::EmNvAacChnlNum aac_channel_num() const;
  inline void set_aac_channel_num(::nv::EmNvAacChnlNum value);

  // optional .nv.EmNvAacSampFreq aac_sample_rate = 3;
  inline bool has_aac_sample_rate() const;
  inline void clear_aac_sample_rate();
  static const int kAacSampleRateFieldNumber = 3;
  inline ::nv::EmNvAacSampFreq aac_sample_rate() const;
  inline void set_aac_sample_rate(::nv::EmNvAacSampFreq value);

  // optional uint32 aac_rate = 4;
  inline bool has_aac_rate() const;
  inline void clear_aac_rate();
  static const int kAacRateFieldNumber = 4;
  inline ::google::protobuf::uint32 aac_rate() const;
  inline void set_aac_rate(::google::protobuf::uint32 value);

  // optional uint32 g7221_rate = 5;
  inline bool has_g7221_rate() const;
  inline void clear_g7221_rate();
  static const int kG7221RateFieldNumber = 5;
  inline ::google::protobuf::uint32 g7221_rate() const;
  inline void set_g7221_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVAudEncDecParam)
 private:
  inline void set_has_aud_format();
  inline void clear_has_aud_format();
  inline void set_has_aac_channel_num();
  inline void clear_has_aac_channel_num();
  inline void set_has_aac_sample_rate();
  inline void clear_has_aac_sample_rate();
  inline void set_has_aac_rate();
  inline void clear_has_aac_rate();
  inline void set_has_g7221_rate();
  inline void clear_has_g7221_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int aud_format_;
  int aac_channel_num_;
  int aac_sample_rate_;
  ::google::protobuf::uint32 aac_rate_;
  ::google::protobuf::uint32 g7221_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVAudEncDecParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVAudEncStatistic : public ::google::protobuf::Message {
 public:
  TNVAudEncStatistic();
  virtual ~TNVAudEncStatistic();

  TNVAudEncStatistic(const TNVAudEncStatistic& from);

  inline TNVAudEncStatistic& operator=(const TNVAudEncStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVAudEncStatistic& default_instance();

  void Swap(TNVAudEncStatistic* other);

  // implements Message ----------------------------------------------

  TNVAudEncStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVAudEncStatistic& from);
  void MergeFrom(const TNVAudEncStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvCodecComponent type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::nv::EmNvCodecComponent type() const;
  inline void set_type(::nv::EmNvCodecComponent value);

  // optional .nv.EmNvCodecComponentIndex aud_enc_id = 2;
  inline bool has_aud_enc_id() const;
  inline void clear_aud_enc_id();
  static const int kAudEncIdFieldNumber = 2;
  inline ::nv::EmNvCodecComponentIndex aud_enc_id() const;
  inline void set_aud_enc_id(::nv::EmNvCodecComponentIndex value);

  // optional uint32 enc_bitrate = 3;
  inline bool has_enc_bitrate() const;
  inline void clear_enc_bitrate();
  static const int kEncBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 enc_bitrate() const;
  inline void set_enc_bitrate(::google::protobuf::uint32 value);

  // optional .nv.EmNvAudFormat aud_enc_type = 4;
  inline bool has_aud_enc_type() const;
  inline void clear_aud_enc_type();
  static const int kAudEncTypeFieldNumber = 4;
  inline ::nv::EmNvAudFormat aud_enc_type() const;
  inline void set_aud_enc_type(::nv::EmNvAudFormat value);

  // optional bool Audio_Enc_Start = 5;
  inline bool has_audio_enc_start() const;
  inline void clear_audio_enc_start();
  static const int kAudioEncStartFieldNumber = 5;
  inline bool audio_enc_start() const;
  inline void set_audio_enc_start(bool value);

  // optional .nv.EmNvAacChnlNum aac_chnl_num = 6;
  inline bool has_aac_chnl_num() const;
  inline void clear_aac_chnl_num();
  static const int kAacChnlNumFieldNumber = 6;
  inline ::nv::EmNvAacChnlNum aac_chnl_num() const;
  inline void set_aac_chnl_num(::nv::EmNvAacChnlNum value);

  // @@protoc_insertion_point(class_scope:nv.TNVAudEncStatistic)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_aud_enc_id();
  inline void clear_has_aud_enc_id();
  inline void set_has_enc_bitrate();
  inline void clear_has_enc_bitrate();
  inline void set_has_aud_enc_type();
  inline void clear_has_aud_enc_type();
  inline void set_has_audio_enc_start();
  inline void clear_has_audio_enc_start();
  inline void set_has_aac_chnl_num();
  inline void clear_has_aac_chnl_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int aud_enc_id_;
  ::google::protobuf::uint32 enc_bitrate_;
  int aud_enc_type_;
  bool audio_enc_start_;
  int aac_chnl_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVAudEncStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVAudDecStatistic : public ::google::protobuf::Message {
 public:
  TNVAudDecStatistic();
  virtual ~TNVAudDecStatistic();

  TNVAudDecStatistic(const TNVAudDecStatistic& from);

  inline TNVAudDecStatistic& operator=(const TNVAudDecStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVAudDecStatistic& default_instance();

  void Swap(TNVAudDecStatistic* other);

  // implements Message ----------------------------------------------

  TNVAudDecStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVAudDecStatistic& from);
  void MergeFrom(const TNVAudDecStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvCodecComponent type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::nv::EmNvCodecComponent type() const;
  inline void set_type(::nv::EmNvCodecComponent value);

  // optional .nv.EmNvCodecComponentIndex aud_dec_id = 2;
  inline bool has_aud_dec_id() const;
  inline void clear_aud_dec_id();
  static const int kAudDecIdFieldNumber = 2;
  inline ::nv::EmNvCodecComponentIndex aud_dec_id() const;
  inline void set_aud_dec_id(::nv::EmNvCodecComponentIndex value);

  // optional uint32 dec_bitrate = 3;
  inline bool has_dec_bitrate() const;
  inline void clear_dec_bitrate();
  static const int kDecBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 dec_bitrate() const;
  inline void set_dec_bitrate(::google::protobuf::uint32 value);

  // optional uint32 rcved_frames = 4;
  inline bool has_rcved_frames() const;
  inline void clear_rcved_frames();
  static const int kRcvedFramesFieldNumber = 4;
  inline ::google::protobuf::uint32 rcved_frames() const;
  inline void set_rcved_frames(::google::protobuf::uint32 value);

  // optional uint32 lost_pack_ratio = 5;
  inline bool has_lost_pack_ratio() const;
  inline void clear_lost_pack_ratio();
  static const int kLostPackRatioFieldNumber = 5;
  inline ::google::protobuf::uint32 lost_pack_ratio() const;
  inline void set_lost_pack_ratio(::google::protobuf::uint32 value);

  // optional uint32 physical_lost_pack_ratio = 6;
  inline bool has_physical_lost_pack_ratio() const;
  inline void clear_physical_lost_pack_ratio();
  static const int kPhysicalLostPackRatioFieldNumber = 6;
  inline ::google::protobuf::uint32 physical_lost_pack_ratio() const;
  inline void set_physical_lost_pack_ratio(::google::protobuf::uint32 value);

  // optional uint32 lost_packs = 7;
  inline bool has_lost_packs() const;
  inline void clear_lost_packs();
  static const int kLostPacksFieldNumber = 7;
  inline ::google::protobuf::uint32 lost_packs() const;
  inline void set_lost_packs(::google::protobuf::uint32 value);

  // optional .nv.EmNvAudFormat aud_dec_type = 8;
  inline bool has_aud_dec_type() const;
  inline void clear_aud_dec_type();
  static const int kAudDecTypeFieldNumber = 8;
  inline ::nv::EmNvAudFormat aud_dec_type() const;
  inline void set_aud_dec_type(::nv::EmNvAudFormat value);

  // optional bool Audio_Dec_Start = 9;
  inline bool has_audio_dec_start() const;
  inline void clear_audio_dec_start();
  static const int kAudioDecStartFieldNumber = 9;
  inline bool audio_dec_start() const;
  inline void set_audio_dec_start(bool value);

  // optional .nv.EmNvAudFormat audchan_dec_type = 10;
  inline bool has_audchan_dec_type() const;
  inline void clear_audchan_dec_type();
  static const int kAudchanDecTypeFieldNumber = 10;
  inline ::nv::EmNvAudFormat audchan_dec_type() const;
  inline void set_audchan_dec_type(::nv::EmNvAudFormat value);

  // optional .nv.EmNvAacChnlNum aac_chnl_num = 11;
  inline bool has_aac_chnl_num() const;
  inline void clear_aac_chnl_num();
  static const int kAacChnlNumFieldNumber = 11;
  inline ::nv::EmNvAacChnlNum aac_chnl_num() const;
  inline void set_aac_chnl_num(::nv::EmNvAacChnlNum value);

  // @@protoc_insertion_point(class_scope:nv.TNVAudDecStatistic)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_aud_dec_id();
  inline void clear_has_aud_dec_id();
  inline void set_has_dec_bitrate();
  inline void clear_has_dec_bitrate();
  inline void set_has_rcved_frames();
  inline void clear_has_rcved_frames();
  inline void set_has_lost_pack_ratio();
  inline void clear_has_lost_pack_ratio();
  inline void set_has_physical_lost_pack_ratio();
  inline void clear_has_physical_lost_pack_ratio();
  inline void set_has_lost_packs();
  inline void clear_has_lost_packs();
  inline void set_has_aud_dec_type();
  inline void clear_has_aud_dec_type();
  inline void set_has_audio_dec_start();
  inline void clear_has_audio_dec_start();
  inline void set_has_audchan_dec_type();
  inline void clear_has_audchan_dec_type();
  inline void set_has_aac_chnl_num();
  inline void clear_has_aac_chnl_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int aud_dec_id_;
  ::google::protobuf::uint32 dec_bitrate_;
  ::google::protobuf::uint32 rcved_frames_;
  ::google::protobuf::uint32 lost_pack_ratio_;
  ::google::protobuf::uint32 physical_lost_pack_ratio_;
  ::google::protobuf::uint32 lost_packs_;
  int aud_dec_type_;
  bool audio_dec_start_;
  int audchan_dec_type_;
  int aac_chnl_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVAudDecStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVidEncStatistic : public ::google::protobuf::Message {
 public:
  TNVVidEncStatistic();
  virtual ~TNVVidEncStatistic();

  TNVVidEncStatistic(const TNVVidEncStatistic& from);

  inline TNVVidEncStatistic& operator=(const TNVVidEncStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVidEncStatistic& default_instance();

  void Swap(TNVVidEncStatistic* other);

  // implements Message ----------------------------------------------

  TNVVidEncStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVidEncStatistic& from);
  void MergeFrom(const TNVVidEncStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvCodecComponent type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::nv::EmNvCodecComponent type() const;
  inline void set_type(::nv::EmNvCodecComponent value);

  // optional .nv.EmNvCodecComponentIndex vid_enc_id = 2;
  inline bool has_vid_enc_id() const;
  inline void clear_vid_enc_id();
  static const int kVidEncIdFieldNumber = 2;
  inline ::nv::EmNvCodecComponentIndex vid_enc_id() const;
  inline void set_vid_enc_id(::nv::EmNvCodecComponentIndex value);

  // optional uint32 enc_bitrate = 3;
  inline bool has_enc_bitrate() const;
  inline void clear_enc_bitrate();
  static const int kEncBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 enc_bitrate() const;
  inline void set_enc_bitrate(::google::protobuf::uint32 value);

  // optional uint32 frame_rate = 4;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 4;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // optional uint32 vid_width = 5;
  inline bool has_vid_width() const;
  inline void clear_vid_width();
  static const int kVidWidthFieldNumber = 5;
  inline ::google::protobuf::uint32 vid_width() const;
  inline void set_vid_width(::google::protobuf::uint32 value);

  // optional uint32 vid_height = 6;
  inline bool has_vid_height() const;
  inline void clear_vid_height();
  static const int kVidHeightFieldNumber = 6;
  inline ::google::protobuf::uint32 vid_height() const;
  inline void set_vid_height(::google::protobuf::uint32 value);

  // optional .nv.EmNvVidFormat vid_enc_type = 7;
  inline bool has_vid_enc_type() const;
  inline void clear_vid_enc_type();
  static const int kVidEncTypeFieldNumber = 7;
  inline ::nv::EmNvVidFormat vid_enc_type() const;
  inline void set_vid_enc_type(::nv::EmNvVidFormat value);

  // optional bool Video_Enc_Start = 8;
  inline bool has_video_enc_start() const;
  inline void clear_video_enc_start();
  static const int kVideoEncStartFieldNumber = 8;
  inline bool video_enc_start() const;
  inline void set_video_enc_start(bool value);

  // optional .nv.EmNvH264Profile h264_profile = 9;
  inline bool has_h264_profile() const;
  inline void clear_h264_profile();
  static const int kH264ProfileFieldNumber = 9;
  inline ::nv::EmNvH264Profile h264_profile() const;
  inline void set_h264_profile(::nv::EmNvH264Profile value);

  // optional bool video_resource_exist = 10;
  inline bool has_video_resource_exist() const;
  inline void clear_video_resource_exist();
  static const int kVideoResourceExistFieldNumber = 10;
  inline bool video_resource_exist() const;
  inline void set_video_resource_exist(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVVidEncStatistic)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_vid_enc_id();
  inline void clear_has_vid_enc_id();
  inline void set_has_enc_bitrate();
  inline void clear_has_enc_bitrate();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();
  inline void set_has_vid_width();
  inline void clear_has_vid_width();
  inline void set_has_vid_height();
  inline void clear_has_vid_height();
  inline void set_has_vid_enc_type();
  inline void clear_has_vid_enc_type();
  inline void set_has_video_enc_start();
  inline void clear_has_video_enc_start();
  inline void set_has_h264_profile();
  inline void clear_has_h264_profile();
  inline void set_has_video_resource_exist();
  inline void clear_has_video_resource_exist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int vid_enc_id_;
  ::google::protobuf::uint32 enc_bitrate_;
  ::google::protobuf::uint32 frame_rate_;
  ::google::protobuf::uint32 vid_width_;
  ::google::protobuf::uint32 vid_height_;
  int vid_enc_type_;
  int h264_profile_;
  bool video_enc_start_;
  bool video_resource_exist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVVidEncStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVidDecStatistic : public ::google::protobuf::Message {
 public:
  TNVVidDecStatistic();
  virtual ~TNVVidDecStatistic();

  TNVVidDecStatistic(const TNVVidDecStatistic& from);

  inline TNVVidDecStatistic& operator=(const TNVVidDecStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVidDecStatistic& default_instance();

  void Swap(TNVVidDecStatistic* other);

  // implements Message ----------------------------------------------

  TNVVidDecStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVidDecStatistic& from);
  void MergeFrom(const TNVVidDecStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvCodecComponent type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::nv::EmNvCodecComponent type() const;
  inline void set_type(::nv::EmNvCodecComponent value);

  // optional .nv.EmNvCodecComponentIndex vid_dec_id = 2;
  inline bool has_vid_dec_id() const;
  inline void clear_vid_dec_id();
  static const int kVidDecIdFieldNumber = 2;
  inline ::nv::EmNvCodecComponentIndex vid_dec_id() const;
  inline void set_vid_dec_id(::nv::EmNvCodecComponentIndex value);

  // optional uint32 dec_bitrate = 3;
  inline bool has_dec_bitrate() const;
  inline void clear_dec_bitrate();
  static const int kDecBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 dec_bitrate() const;
  inline void set_dec_bitrate(::google::protobuf::uint32 value);

  // optional uint32 rcved_frames = 4;
  inline bool has_rcved_frames() const;
  inline void clear_rcved_frames();
  static const int kRcvedFramesFieldNumber = 4;
  inline ::google::protobuf::uint32 rcved_frames() const;
  inline void set_rcved_frames(::google::protobuf::uint32 value);

  // optional uint32 lost_pack_ratio = 5;
  inline bool has_lost_pack_ratio() const;
  inline void clear_lost_pack_ratio();
  static const int kLostPackRatioFieldNumber = 5;
  inline ::google::protobuf::uint32 lost_pack_ratio() const;
  inline void set_lost_pack_ratio(::google::protobuf::uint32 value);

  // optional uint32 physical_lost_pack_ratio = 6;
  inline bool has_physical_lost_pack_ratio() const;
  inline void clear_physical_lost_pack_ratio();
  static const int kPhysicalLostPackRatioFieldNumber = 6;
  inline ::google::protobuf::uint32 physical_lost_pack_ratio() const;
  inline void set_physical_lost_pack_ratio(::google::protobuf::uint32 value);

  // optional uint32 lost_packs = 7;
  inline bool has_lost_packs() const;
  inline void clear_lost_packs();
  static const int kLostPacksFieldNumber = 7;
  inline ::google::protobuf::uint32 lost_packs() const;
  inline void set_lost_packs(::google::protobuf::uint32 value);

  // optional uint32 frame_rate = 8;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 8;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // optional uint32 vid_width = 9;
  inline bool has_vid_width() const;
  inline void clear_vid_width();
  static const int kVidWidthFieldNumber = 9;
  inline ::google::protobuf::uint32 vid_width() const;
  inline void set_vid_width(::google::protobuf::uint32 value);

  // optional uint32 vid_height = 10;
  inline bool has_vid_height() const;
  inline void clear_vid_height();
  static const int kVidHeightFieldNumber = 10;
  inline ::google::protobuf::uint32 vid_height() const;
  inline void set_vid_height(::google::protobuf::uint32 value);

  // optional .nv.EmNvVidFormat vid_dec_type = 11;
  inline bool has_vid_dec_type() const;
  inline void clear_vid_dec_type();
  static const int kVidDecTypeFieldNumber = 11;
  inline ::nv::EmNvVidFormat vid_dec_type() const;
  inline void set_vid_dec_type(::nv::EmNvVidFormat value);

  // optional bool Video_Dec_Start = 12;
  inline bool has_video_dec_start() const;
  inline void clear_video_dec_start();
  static const int kVideoDecStartFieldNumber = 12;
  inline bool video_dec_start() const;
  inline void set_video_dec_start(bool value);

  // optional .nv.EmNvH264Profile h264_profile = 13;
  inline bool has_h264_profile() const;
  inline void clear_h264_profile();
  static const int kH264ProfileFieldNumber = 13;
  inline ::nv::EmNvH264Profile h264_profile() const;
  inline void set_h264_profile(::nv::EmNvH264Profile value);

  // @@protoc_insertion_point(class_scope:nv.TNVVidDecStatistic)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_vid_dec_id();
  inline void clear_has_vid_dec_id();
  inline void set_has_dec_bitrate();
  inline void clear_has_dec_bitrate();
  inline void set_has_rcved_frames();
  inline void clear_has_rcved_frames();
  inline void set_has_lost_pack_ratio();
  inline void clear_has_lost_pack_ratio();
  inline void set_has_physical_lost_pack_ratio();
  inline void clear_has_physical_lost_pack_ratio();
  inline void set_has_lost_packs();
  inline void clear_has_lost_packs();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();
  inline void set_has_vid_width();
  inline void clear_has_vid_width();
  inline void set_has_vid_height();
  inline void clear_has_vid_height();
  inline void set_has_vid_dec_type();
  inline void clear_has_vid_dec_type();
  inline void set_has_video_dec_start();
  inline void clear_has_video_dec_start();
  inline void set_has_h264_profile();
  inline void clear_has_h264_profile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int vid_dec_id_;
  ::google::protobuf::uint32 dec_bitrate_;
  ::google::protobuf::uint32 rcved_frames_;
  ::google::protobuf::uint32 lost_pack_ratio_;
  ::google::protobuf::uint32 physical_lost_pack_ratio_;
  ::google::protobuf::uint32 lost_packs_;
  ::google::protobuf::uint32 frame_rate_;
  ::google::protobuf::uint32 vid_width_;
  ::google::protobuf::uint32 vid_height_;
  int vid_dec_type_;
  bool video_dec_start_;
  int h264_profile_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVVidDecStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVCodecStatistic : public ::google::protobuf::Message {
 public:
  TNVCodecStatistic();
  virtual ~TNVCodecStatistic();

  TNVCodecStatistic(const TNVCodecStatistic& from);

  inline TNVCodecStatistic& operator=(const TNVCodecStatistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVCodecStatistic& default_instance();

  void Swap(TNVCodecStatistic* other);

  // implements Message ----------------------------------------------

  TNVCodecStatistic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVCodecStatistic& from);
  void MergeFrom(const TNVCodecStatistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVAudEncStatistic main_aud_enc_static = 1;
  inline int main_aud_enc_static_size() const;
  inline void clear_main_aud_enc_static();
  static const int kMainAudEncStaticFieldNumber = 1;
  inline const ::nv::TNVAudEncStatistic& main_aud_enc_static(int index) const;
  inline ::nv::TNVAudEncStatistic* mutable_main_aud_enc_static(int index);
  inline ::nv::TNVAudEncStatistic* add_main_aud_enc_static();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVAudEncStatistic >&
      main_aud_enc_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVAudEncStatistic >*
      mutable_main_aud_enc_static();

  // repeated .nv.TNVAudDecStatistic main_aud_dec_static = 2;
  inline int main_aud_dec_static_size() const;
  inline void clear_main_aud_dec_static();
  static const int kMainAudDecStaticFieldNumber = 2;
  inline const ::nv::TNVAudDecStatistic& main_aud_dec_static(int index) const;
  inline ::nv::TNVAudDecStatistic* mutable_main_aud_dec_static(int index);
  inline ::nv::TNVAudDecStatistic* add_main_aud_dec_static();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVAudDecStatistic >&
      main_aud_dec_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVAudDecStatistic >*
      mutable_main_aud_dec_static();

  // repeated .nv.TNVVidEncStatistic main_vid_enc_static = 3;
  inline int main_vid_enc_static_size() const;
  inline void clear_main_vid_enc_static();
  static const int kMainVidEncStaticFieldNumber = 3;
  inline const ::nv::TNVVidEncStatistic& main_vid_enc_static(int index) const;
  inline ::nv::TNVVidEncStatistic* mutable_main_vid_enc_static(int index);
  inline ::nv::TNVVidEncStatistic* add_main_vid_enc_static();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidEncStatistic >&
      main_vid_enc_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidEncStatistic >*
      mutable_main_vid_enc_static();

  // repeated .nv.TNVVidDecStatistic main_vid_dec_static = 4;
  inline int main_vid_dec_static_size() const;
  inline void clear_main_vid_dec_static();
  static const int kMainVidDecStaticFieldNumber = 4;
  inline const ::nv::TNVVidDecStatistic& main_vid_dec_static(int index) const;
  inline ::nv::TNVVidDecStatistic* mutable_main_vid_dec_static(int index);
  inline ::nv::TNVVidDecStatistic* add_main_vid_dec_static();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidDecStatistic >&
      main_vid_dec_static() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidDecStatistic >*
      mutable_main_vid_dec_static();

  // @@protoc_insertion_point(class_scope:nv.TNVCodecStatistic)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVAudEncStatistic > main_aud_enc_static_;
  ::google::protobuf::RepeatedPtrField< ::nv::TNVAudDecStatistic > main_aud_dec_static_;
  ::google::protobuf::RepeatedPtrField< ::nv::TNVVidEncStatistic > main_vid_enc_static_;
  ::google::protobuf::RepeatedPtrField< ::nv::TNVVidDecStatistic > main_vid_dec_static_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVCodecStatistic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVInputEvent : public ::google::protobuf::Message {
 public:
  TNVInputEvent();
  virtual ~TNVInputEvent();

  TNVInputEvent(const TNVInputEvent& from);

  inline TNVInputEvent& operator=(const TNVInputEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVInputEvent& default_instance();

  void Swap(TNVInputEvent* other);

  // implements Message ----------------------------------------------

  TNVInputEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVInputEvent& from);
  void MergeFrom(const TNVInputEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // optional uint32 value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVInputEvent)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 code_;
  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVInputEvent* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVInputEvents : public ::google::protobuf::Message {
 public:
  TNVInputEvents();
  virtual ~TNVInputEvents();

  TNVInputEvents(const TNVInputEvents& from);

  inline TNVInputEvents& operator=(const TNVInputEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVInputEvents& default_instance();

  void Swap(TNVInputEvents* other);

  // implements Message ----------------------------------------------

  TNVInputEvents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVInputEvents& from);
  void MergeFrom(const TNVInputEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value(int index) const;
  inline void set_value(int index, ::google::protobuf::uint32 value);
  inline void add_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:nv.TNVInputEvents)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVInputEvents* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNvVidSrcInfo : public ::google::protobuf::Message {
 public:
  TNvVidSrcInfo();
  virtual ~TNvVidSrcInfo();

  TNvVidSrcInfo(const TNvVidSrcInfo& from);

  inline TNvVidSrcInfo& operator=(const TNvVidSrcInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNvVidSrcInfo& default_instance();

  void Swap(TNvVidSrcInfo* other);

  // implements Message ----------------------------------------------

  TNvVidSrcInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNvVidSrcInfo& from);
  void MergeFrom(const TNvVidSrcInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvCodecComponent codec_type = 1;
  inline bool has_codec_type() const;
  inline void clear_codec_type();
  static const int kCodecTypeFieldNumber = 1;
  inline ::nv::EmNvCodecComponent codec_type() const;
  inline void set_codec_type(::nv::EmNvCodecComponent value);

  // optional .nv.EmNvCodecComponentIndex codec_id = 2;
  inline bool has_codec_id() const;
  inline void clear_codec_id();
  static const int kCodecIdFieldNumber = 2;
  inline ::nv::EmNvCodecComponentIndex codec_id() const;
  inline void set_codec_id(::nv::EmNvCodecComponentIndex value);

  // optional uint32 video_width = 3;
  inline bool has_video_width() const;
  inline void clear_video_width();
  static const int kVideoWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 video_width() const;
  inline void set_video_width(::google::protobuf::uint32 value);

  // optional uint32 video_height = 4;
  inline bool has_video_height() const;
  inline void clear_video_height();
  static const int kVideoHeightFieldNumber = 4;
  inline ::google::protobuf::uint32 video_height() const;
  inline void set_video_height(::google::protobuf::uint32 value);

  // optional bool video_progressive = 5;
  inline bool has_video_progressive() const;
  inline void clear_video_progressive();
  static const int kVideoProgressiveFieldNumber = 5;
  inline bool video_progressive() const;
  inline void set_video_progressive(bool value);

  // optional uint32 frame_rate = 6;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 6;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNvVidSrcInfo)
 private:
  inline void set_has_codec_type();
  inline void clear_has_codec_type();
  inline void set_has_codec_id();
  inline void clear_has_codec_id();
  inline void set_has_video_width();
  inline void clear_has_video_width();
  inline void set_has_video_height();
  inline void clear_has_video_height();
  inline void set_has_video_progressive();
  inline void clear_has_video_progressive();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int codec_type_;
  int codec_id_;
  ::google::protobuf::uint32 video_width_;
  ::google::protobuf::uint32 video_height_;
  bool video_progressive_;
  ::google::protobuf::uint32 frame_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNvVidSrcInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVidEncParam : public ::google::protobuf::Message {
 public:
  TNVVidEncParam();
  virtual ~TNVVidEncParam();

  TNVVidEncParam(const TNVVidEncParam& from);

  inline TNVVidEncParam& operator=(const TNVVidEncParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVidEncParam& default_instance();

  void Swap(TNVVidEncParam* other);

  // implements Message ----------------------------------------------

  TNVVidEncParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVidEncParam& from);
  void MergeFrom(const TNVVidEncParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvEncodeMode enc_mode = 1;
  inline bool has_enc_mode() const;
  inline void clear_enc_mode();
  static const int kEncModeFieldNumber = 1;
  inline ::nv::EmNvEncodeMode enc_mode() const;
  inline void set_enc_mode(::nv::EmNvEncodeMode value);

  // optional .nv.EmNvVidFormat vid_format = 2;
  inline bool has_vid_format() const;
  inline void clear_vid_format();
  static const int kVidFormatFieldNumber = 2;
  inline ::nv::EmNvVidFormat vid_format() const;
  inline void set_vid_format(::nv::EmNvVidFormat value);

  // optional uint32 max_key_frame_interval = 3;
  inline bool has_max_key_frame_interval() const;
  inline void clear_max_key_frame_interval();
  static const int kMaxKeyFrameIntervalFieldNumber = 3;
  inline ::google::protobuf::uint32 max_key_frame_interval() const;
  inline void set_max_key_frame_interval(::google::protobuf::uint32 value);

  // optional uint32 max_quant = 4;
  inline bool has_max_quant() const;
  inline void clear_max_quant();
  static const int kMaxQuantFieldNumber = 4;
  inline ::google::protobuf::uint32 max_quant() const;
  inline void set_max_quant(::google::protobuf::uint32 value);

  // optional uint32 min_quant = 5;
  inline bool has_min_quant() const;
  inline void clear_min_quant();
  static const int kMinQuantFieldNumber = 5;
  inline ::google::protobuf::uint32 min_quant() const;
  inline void set_min_quant(::google::protobuf::uint32 value);

  // optional uint32 frame_rate = 6;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 6;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 7;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 7;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional uint32 h264_profile = 8;
  inline bool has_h264_profile() const;
  inline void clear_h264_profile();
  static const int kH264ProfileFieldNumber = 8;
  inline ::google::protobuf::uint32 h264_profile() const;
  inline void set_h264_profile(::google::protobuf::uint32 value);

  // optional uint32 width = 9;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 9;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 10;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 10;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVVidEncParam)
 private:
  inline void set_has_enc_mode();
  inline void clear_has_enc_mode();
  inline void set_has_vid_format();
  inline void clear_has_vid_format();
  inline void set_has_max_key_frame_interval();
  inline void clear_has_max_key_frame_interval();
  inline void set_has_max_quant();
  inline void clear_has_max_quant();
  inline void set_has_min_quant();
  inline void clear_has_min_quant();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_h264_profile();
  inline void clear_has_h264_profile();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int enc_mode_;
  int vid_format_;
  ::google::protobuf::uint32 max_key_frame_interval_;
  ::google::protobuf::uint32 max_quant_;
  ::google::protobuf::uint32 min_quant_;
  ::google::protobuf::uint32 frame_rate_;
  ::google::protobuf::uint32 bitrate_;
  ::google::protobuf::uint32 h264_profile_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVVidEncParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVidSrcInfoList : public ::google::protobuf::Message {
 public:
  TNVVidSrcInfoList();
  virtual ~TNVVidSrcInfoList();

  TNVVidSrcInfoList(const TNVVidSrcInfoList& from);

  inline TNVVidSrcInfoList& operator=(const TNVVidSrcInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVidSrcInfoList& default_instance();

  void Swap(TNVVidSrcInfoList* other);

  // implements Message ----------------------------------------------

  TNVVidSrcInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVidSrcInfoList& from);
  void MergeFrom(const TNVVidSrcInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNvVidSrcInfo video_src_status = 1;
  inline int video_src_status_size() const;
  inline void clear_video_src_status();
  static const int kVideoSrcStatusFieldNumber = 1;
  inline const ::nv::TNvVidSrcInfo& video_src_status(int index) const;
  inline ::nv::TNvVidSrcInfo* mutable_video_src_status(int index);
  inline ::nv::TNvVidSrcInfo* add_video_src_status();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNvVidSrcInfo >&
      video_src_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNvVidSrcInfo >*
      mutable_video_src_status();

  // @@protoc_insertion_point(class_scope:nv.TNVVidSrcInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNvVidSrcInfo > video_src_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVVidSrcInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVidInPortResInfo : public ::google::protobuf::Message {
 public:
  TNVVidInPortResInfo();
  virtual ~TNVVidInPortResInfo();

  TNVVidInPortResInfo(const TNVVidInPortResInfo& from);

  inline TNVVidInPortResInfo& operator=(const TNVVidInPortResInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVidInPortResInfo& default_instance();

  void Swap(TNVVidInPortResInfo* other);

  // implements Message ----------------------------------------------

  TNVVidInPortResInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVidInPortResInfo& from);
  void MergeFrom(const TNVVidInPortResInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvVideoInPort video_port = 1;
  inline bool has_video_port() const;
  inline void clear_video_port();
  static const int kVideoPortFieldNumber = 1;
  inline ::nv::EmNvVideoInPort video_port() const;
  inline void set_video_port(::nv::EmNvVideoInPort value);

  // optional uint32 video_width = 2;
  inline bool has_video_width() const;
  inline void clear_video_width();
  static const int kVideoWidthFieldNumber = 2;
  inline ::google::protobuf::uint32 video_width() const;
  inline void set_video_width(::google::protobuf::uint32 value);

  // optional uint32 video_height = 3;
  inline bool has_video_height() const;
  inline void clear_video_height();
  static const int kVideoHeightFieldNumber = 3;
  inline ::google::protobuf::uint32 video_height() const;
  inline void set_video_height(::google::protobuf::uint32 value);

  // optional bool video_progressive = 4;
  inline bool has_video_progressive() const;
  inline void clear_video_progressive();
  static const int kVideoProgressiveFieldNumber = 4;
  inline bool video_progressive() const;
  inline void set_video_progressive(bool value);

  // optional uint32 frame_rate = 5;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 5;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // optional bool has_src = 6;
  inline bool has_has_src() const;
  inline void clear_has_src();
  static const int kHasSrcFieldNumber = 6;
  inline bool has_src() const;
  inline void set_has_src(bool value);

  // optional .nv.EmNvImixVidSrcType video_type = 7;
  inline bool has_video_type() const;
  inline void clear_video_type();
  static const int kVideoTypeFieldNumber = 7;
  inline ::nv::EmNvImixVidSrcType video_type() const;
  inline void set_video_type(::nv::EmNvImixVidSrcType value);

  // optional string vid_name = 8;
  inline bool has_vid_name() const;
  inline void clear_vid_name();
  static const int kVidNameFieldNumber = 8;
  inline const ::std::string& vid_name() const;
  inline void set_vid_name(const ::std::string& value);
  inline void set_vid_name(const char* value);
  inline void set_vid_name(const char* value, size_t size);
  inline ::std::string* mutable_vid_name();
  inline ::std::string* release_vid_name();
  inline void set_allocated_vid_name(::std::string* vid_name);

  // @@protoc_insertion_point(class_scope:nv.TNVVidInPortResInfo)
 private:
  inline void set_has_video_port();
  inline void clear_has_video_port();
  inline void set_has_video_width();
  inline void clear_has_video_width();
  inline void set_has_video_height();
  inline void clear_has_video_height();
  inline void set_has_video_progressive();
  inline void clear_has_video_progressive();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();
  inline void set_has_has_src();
  inline void clear_has_has_src();
  inline void set_has_video_type();
  inline void clear_has_video_type();
  inline void set_has_vid_name();
  inline void clear_has_vid_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_port_;
  ::google::protobuf::uint32 video_width_;
  ::google::protobuf::uint32 video_height_;
  ::google::protobuf::uint32 frame_rate_;
  bool video_progressive_;
  bool has_src_;
  int video_type_;
  ::std::string* vid_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVVidInPortResInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVidInPortResInfoList : public ::google::protobuf::Message {
 public:
  TNVVidInPortResInfoList();
  virtual ~TNVVidInPortResInfoList();

  TNVVidInPortResInfoList(const TNVVidInPortResInfoList& from);

  inline TNVVidInPortResInfoList& operator=(const TNVVidInPortResInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVidInPortResInfoList& default_instance();

  void Swap(TNVVidInPortResInfoList* other);

  // implements Message ----------------------------------------------

  TNVVidInPortResInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVidInPortResInfoList& from);
  void MergeFrom(const TNVVidInPortResInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVVidInPortResInfo video_inport_status = 1;
  inline int video_inport_status_size() const;
  inline void clear_video_inport_status();
  static const int kVideoInportStatusFieldNumber = 1;
  inline const ::nv::TNVVidInPortResInfo& video_inport_status(int index) const;
  inline ::nv::TNVVidInPortResInfo* mutable_video_inport_status(int index);
  inline ::nv::TNVVidInPortResInfo* add_video_inport_status();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidInPortResInfo >&
      video_inport_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidInPortResInfo >*
      mutable_video_inport_status();

  // @@protoc_insertion_point(class_scope:nv.TNVVidInPortResInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVVidInPortResInfo > video_inport_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVVidInPortResInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVChanAddr : public ::google::protobuf::Message {
 public:
  TNVChanAddr();
  virtual ~TNVChanAddr();

  TNVChanAddr(const TNVChanAddr& from);

  inline TNVChanAddr& operator=(const TNVChanAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVChanAddr& default_instance();

  void Swap(TNVChanAddr* other);

  // implements Message ----------------------------------------------

  TNVChanAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVChanAddr& from);
  void MergeFrom(const TNVChanAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.TNVNetAddr local_rtp = 1;
  inline bool has_local_rtp() const;
  inline void clear_local_rtp();
  static const int kLocalRtpFieldNumber = 1;
  inline const ::nv::TNVNetAddr& local_rtp() const;
  inline ::nv::TNVNetAddr* mutable_local_rtp();
  inline ::nv::TNVNetAddr* release_local_rtp();
  inline void set_allocated_local_rtp(::nv::TNVNetAddr* local_rtp);

  // optional .nv.TNVNetAddr local_rtcp = 2;
  inline bool has_local_rtcp() const;
  inline void clear_local_rtcp();
  static const int kLocalRtcpFieldNumber = 2;
  inline const ::nv::TNVNetAddr& local_rtcp() const;
  inline ::nv::TNVNetAddr* mutable_local_rtcp();
  inline ::nv::TNVNetAddr* release_local_rtcp();
  inline void set_allocated_local_rtcp(::nv::TNVNetAddr* local_rtcp);

  // optional .nv.TNVNetAddr peer_rtp = 3;
  inline bool has_peer_rtp() const;
  inline void clear_peer_rtp();
  static const int kPeerRtpFieldNumber = 3;
  inline const ::nv::TNVNetAddr& peer_rtp() const;
  inline ::nv::TNVNetAddr* mutable_peer_rtp();
  inline ::nv::TNVNetAddr* release_peer_rtp();
  inline void set_allocated_peer_rtp(::nv::TNVNetAddr* peer_rtp);

  // optional .nv.TNVNetAddr peer_rtcp = 4;
  inline bool has_peer_rtcp() const;
  inline void clear_peer_rtcp();
  static const int kPeerRtcpFieldNumber = 4;
  inline const ::nv::TNVNetAddr& peer_rtcp() const;
  inline ::nv::TNVNetAddr* mutable_peer_rtcp();
  inline ::nv::TNVNetAddr* release_peer_rtcp();
  inline void set_allocated_peer_rtcp(::nv::TNVNetAddr* peer_rtcp);

  // @@protoc_insertion_point(class_scope:nv.TNVChanAddr)
 private:
  inline void set_has_local_rtp();
  inline void clear_has_local_rtp();
  inline void set_has_local_rtcp();
  inline void clear_has_local_rtcp();
  inline void set_has_peer_rtp();
  inline void clear_has_peer_rtp();
  inline void set_has_peer_rtcp();
  inline void clear_has_peer_rtcp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::nv::TNVNetAddr* local_rtp_;
  ::nv::TNVNetAddr* local_rtcp_;
  ::nv::TNVNetAddr* peer_rtp_;
  ::nv::TNVNetAddr* peer_rtcp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVChanAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVAudInPower : public ::google::protobuf::Message {
 public:
  TNVAudInPower();
  virtual ~TNVAudInPower();

  TNVAudInPower(const TNVAudInPower& from);

  inline TNVAudInPower& operator=(const TNVAudInPower& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVAudInPower& default_instance();

  void Swap(TNVAudInPower* other);

  // implements Message ----------------------------------------------

  TNVAudInPower* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVAudInPower& from);
  void MergeFrom(const TNVAudInPower& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvImixVidSrcType src_type = 1;
  inline bool has_src_type() const;
  inline void clear_src_type();
  static const int kSrcTypeFieldNumber = 1;
  inline ::nv::EmNvImixVidSrcType src_type() const;
  inline void set_src_type(::nv::EmNvImixVidSrcType value);

  // optional bool has_power = 2;
  inline bool has_has_power() const;
  inline void clear_has_power();
  static const int kHasPowerFieldNumber = 2;
  inline bool has_power() const;
  inline void set_has_power(bool value);

  // optional string aud_name = 3;
  inline bool has_aud_name() const;
  inline void clear_aud_name();
  static const int kAudNameFieldNumber = 3;
  inline const ::std::string& aud_name() const;
  inline void set_aud_name(const ::std::string& value);
  inline void set_aud_name(const char* value);
  inline void set_aud_name(const char* value, size_t size);
  inline ::std::string* mutable_aud_name();
  inline ::std::string* release_aud_name();
  inline void set_allocated_aud_name(::std::string* aud_name);

  // @@protoc_insertion_point(class_scope:nv.TNVAudInPower)
 private:
  inline void set_has_src_type();
  inline void clear_has_src_type();
  inline void set_has_has_power();
  inline void clear_has_has_power();
  inline void set_has_aud_name();
  inline void clear_has_aud_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int src_type_;
  bool has_power_;
  ::std::string* aud_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVAudInPower* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVAudInPowerList : public ::google::protobuf::Message {
 public:
  TNVAudInPowerList();
  virtual ~TNVAudInPowerList();

  TNVAudInPowerList(const TNVAudInPowerList& from);

  inline TNVAudInPowerList& operator=(const TNVAudInPowerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVAudInPowerList& default_instance();

  void Swap(TNVAudInPowerList* other);

  // implements Message ----------------------------------------------

  TNVAudInPowerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVAudInPowerList& from);
  void MergeFrom(const TNVAudInPowerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVAudInPower aud_In_Power = 1;
  inline int aud_in_power_size() const;
  inline void clear_aud_in_power();
  static const int kAudInPowerFieldNumber = 1;
  inline const ::nv::TNVAudInPower& aud_in_power(int index) const;
  inline ::nv::TNVAudInPower* mutable_aud_in_power(int index);
  inline ::nv::TNVAudInPower* add_aud_in_power();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVAudInPower >&
      aud_in_power() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVAudInPower >*
      mutable_aud_in_power();

  // @@protoc_insertion_point(class_scope:nv.TNVAudInPowerList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVAudInPower > aud_in_power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVAudInPowerList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVAudPort : public ::google::protobuf::Message {
 public:
  TNVAudPort();
  virtual ~TNVAudPort();

  TNVAudPort(const TNVAudPort& from);

  inline TNVAudPort& operator=(const TNVAudPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVAudPort& default_instance();

  void Swap(TNVAudPort* other);

  // implements Message ----------------------------------------------

  TNVAudPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVAudPort& from);
  void MergeFrom(const TNVAudPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvAudPortIn aud_in_port1 = 1;
  inline bool has_aud_in_port1() const;
  inline void clear_aud_in_port1();
  static const int kAudInPort1FieldNumber = 1;
  inline ::nv::EmNvAudPortIn aud_in_port1() const;
  inline void set_aud_in_port1(::nv::EmNvAudPortIn value);

  // optional .nv.EmNvAudPortIn aud_in_port2 = 2;
  inline bool has_aud_in_port2() const;
  inline void clear_aud_in_port2();
  static const int kAudInPort2FieldNumber = 2;
  inline ::nv::EmNvAudPortIn aud_in_port2() const;
  inline void set_aud_in_port2(::nv::EmNvAudPortIn value);

  // optional .nv.EmNvAudPortOut aud_out_port = 3;
  inline bool has_aud_out_port() const;
  inline void clear_aud_out_port();
  static const int kAudOutPortFieldNumber = 3;
  inline ::nv::EmNvAudPortOut aud_out_port() const;
  inline void set_aud_out_port(::nv::EmNvAudPortOut value);

  // @@protoc_insertion_point(class_scope:nv.TNVAudPort)
 private:
  inline void set_has_aud_in_port1();
  inline void clear_has_aud_in_port1();
  inline void set_has_aud_in_port2();
  inline void clear_has_aud_in_port2();
  inline void set_has_aud_out_port();
  inline void clear_has_aud_out_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int aud_in_port1_;
  int aud_in_port2_;
  int aud_out_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVAudPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVidFreezePrm : public ::google::protobuf::Message {
 public:
  TNVVidFreezePrm();
  virtual ~TNVVidFreezePrm();

  TNVVidFreezePrm(const TNVVidFreezePrm& from);

  inline TNVVidFreezePrm& operator=(const TNVVidFreezePrm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVidFreezePrm& default_instance();

  void Swap(TNVVidFreezePrm* other);

  // implements Message ----------------------------------------------

  TNVVidFreezePrm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVidFreezePrm& from);
  void MergeFrom(const TNVVidFreezePrm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvVideoInPort vid_port = 1;
  inline bool has_vid_port() const;
  inline void clear_vid_port();
  static const int kVidPortFieldNumber = 1;
  inline ::nv::EmNvVideoInPort vid_port() const;
  inline void set_vid_port(::nv::EmNvVideoInPort value);

  // optional uint32 freeze_mode = 2;
  inline bool has_freeze_mode() const;
  inline void clear_freeze_mode();
  static const int kFreezeModeFieldNumber = 2;
  inline ::google::protobuf::uint32 freeze_mode() const;
  inline void set_freeze_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVVidFreezePrm)
 private:
  inline void set_has_vid_port();
  inline void clear_has_vid_port();
  inline void set_has_freeze_mode();
  inline void clear_has_freeze_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int vid_port_;
  ::google::protobuf::uint32 freeze_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVVidFreezePrm* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVidPoint : public ::google::protobuf::Message {
 public:
  TNVVidPoint();
  virtual ~TNVVidPoint();

  TNVVidPoint(const TNVVidPoint& from);

  inline TNVVidPoint& operator=(const TNVVidPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVidPoint& default_instance();

  void Swap(TNVVidPoint* other);

  // implements Message ----------------------------------------------

  TNVVidPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVidPoint& from);
  void MergeFrom(const TNVVidPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 point_x = 1;
  inline bool has_point_x() const;
  inline void clear_point_x();
  static const int kPointXFieldNumber = 1;
  inline ::google::protobuf::uint32 point_x() const;
  inline void set_point_x(::google::protobuf::uint32 value);

  // optional uint32 point_y = 2;
  inline bool has_point_y() const;
  inline void clear_point_y();
  static const int kPointYFieldNumber = 2;
  inline ::google::protobuf::uint32 point_y() const;
  inline void set_point_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVVidPoint)
 private:
  inline void set_has_point_x();
  inline void clear_has_point_x();
  inline void set_has_point_y();
  inline void clear_has_point_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 point_x_;
  ::google::protobuf::uint32 point_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVVidPoint* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVidLineOverlap : public ::google::protobuf::Message {
 public:
  TNVVidLineOverlap();
  virtual ~TNVVidLineOverlap();

  TNVVidLineOverlap(const TNVVidLineOverlap& from);

  inline TNVVidLineOverlap& operator=(const TNVVidLineOverlap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVidLineOverlap& default_instance();

  void Swap(TNVVidLineOverlap* other);

  // implements Message ----------------------------------------------

  TNVVidLineOverlap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVidLineOverlap& from);
  void MergeFrom(const TNVVidLineOverlap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 line_en = 1;
  inline bool has_line_en() const;
  inline void clear_line_en();
  static const int kLineEnFieldNumber = 1;
  inline ::google::protobuf::uint32 line_en() const;
  inline void set_line_en(::google::protobuf::uint32 value);

  // optional uint32 color_y = 2;
  inline bool has_color_y() const;
  inline void clear_color_y();
  static const int kColorYFieldNumber = 2;
  inline ::google::protobuf::uint32 color_y() const;
  inline void set_color_y(::google::protobuf::uint32 value);

  // optional uint32 color_u = 3;
  inline bool has_color_u() const;
  inline void clear_color_u();
  static const int kColorUFieldNumber = 3;
  inline ::google::protobuf::uint32 color_u() const;
  inline void set_color_u(::google::protobuf::uint32 value);

  // optional uint32 color_v = 4;
  inline bool has_color_v() const;
  inline void clear_color_v();
  static const int kColorVFieldNumber = 4;
  inline ::google::protobuf::uint32 color_v() const;
  inline void set_color_v(::google::protobuf::uint32 value);

  // repeated .nv.TNVVidPoint point = 5;
  inline int point_size() const;
  inline void clear_point();
  static const int kPointFieldNumber = 5;
  inline const ::nv::TNVVidPoint& point(int index) const;
  inline ::nv::TNVVidPoint* mutable_point(int index);
  inline ::nv::TNVVidPoint* add_point();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidPoint >&
      point() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidPoint >*
      mutable_point();

  // @@protoc_insertion_point(class_scope:nv.TNVVidLineOverlap)
 private:
  inline void set_has_line_en();
  inline void clear_has_line_en();
  inline void set_has_color_y();
  inline void clear_has_color_y();
  inline void set_has_color_u();
  inline void clear_has_color_u();
  inline void set_has_color_v();
  inline void clear_has_color_v();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 line_en_;
  ::google::protobuf::uint32 color_y_;
  ::google::protobuf::uint32 color_u_;
  ::google::protobuf::uint32 color_v_;
  ::google::protobuf::RepeatedPtrField< ::nv::TNVVidPoint > point_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TNVVidLineOverlap* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TQKCodeParam : public ::google::protobuf::Message {
 public:
  TQKCodeParam();
  virtual ~TQKCodeParam();

  TQKCodeParam(const TQKCodeParam& from);

  inline TQKCodeParam& operator=(const TQKCodeParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TQKCodeParam& default_instance();

  void Swap(TQKCodeParam* other);

  // implements Message ----------------------------------------------

  TQKCodeParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TQKCodeParam& from);
  void MergeFrom(const TQKCodeParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 vid_format = 1;
  inline bool has_vid_format() const;
  inline void clear_vid_format();
  static const int kVidFormatFieldNumber = 1;
  inline ::google::protobuf::uint32 vid_format() const;
  inline void set_vid_format(::google::protobuf::uint32 value);

  // optional uint32 aud_format = 2;
  inline bool has_aud_format() const;
  inline void clear_aud_format();
  static const int kAudFormatFieldNumber = 2;
  inline ::google::protobuf::uint32 aud_format() const;
  inline void set_aud_format(::google::protobuf::uint32 value);

  // optional .nv.EmQkCodeRes res_type = 3;
  inline bool has_res_type() const;
  inline void clear_res_type();
  static const int kResTypeFieldNumber = 3;
  inline ::nv::EmQkCodeRes res_type() const;
  inline void set_res_type(::nv::EmQkCodeRes value);

  // optional uint32 bit_rate = 4;
  inline bool has_bit_rate() const;
  inline void clear_bit_rate();
  static const int kBitRateFieldNumber = 4;
  inline ::google::protobuf::uint32 bit_rate() const;
  inline void set_bit_rate(::google::protobuf::uint32 value);

  // optional uint32 frame_rate = 5;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 5;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TQKCodeParam)
 private:
  inline void set_has_vid_format();
  inline void clear_has_vid_format();
  inline void set_has_aud_format();
  inline void clear_has_aud_format();
  inline void set_has_res_type();
  inline void clear_has_res_type();
  inline void set_has_bit_rate();
  inline void clear_has_bit_rate();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 vid_format_;
  ::google::protobuf::uint32 aud_format_;
  int res_type_;
  ::google::protobuf::uint32 bit_rate_;
  ::google::protobuf::uint32 frame_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmp_2eproto();
  friend void protobuf_AssignDesc_nvstructmp_2eproto();
  friend void protobuf_ShutdownFile_nvstructmp_2eproto();

  void InitAsDefaultInstance();
  static TQKCodeParam* default_instance_;
};
// ===================================================================


// ===================================================================

// TNVRtpRtcpPair

// optional .nv.TNVNetAddr rtp_addr = 1;
inline bool TNVRtpRtcpPair::has_rtp_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVRtpRtcpPair::set_has_rtp_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVRtpRtcpPair::clear_has_rtp_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVRtpRtcpPair::clear_rtp_addr() {
  if (rtp_addr_ != NULL) rtp_addr_->::nv::TNVNetAddr::Clear();
  clear_has_rtp_addr();
}
inline const ::nv::TNVNetAddr& TNVRtpRtcpPair::rtp_addr() const {
  return rtp_addr_ != NULL ? *rtp_addr_ : *default_instance_->rtp_addr_;
}
inline ::nv::TNVNetAddr* TNVRtpRtcpPair::mutable_rtp_addr() {
  set_has_rtp_addr();
  if (rtp_addr_ == NULL) rtp_addr_ = new ::nv::TNVNetAddr;
  return rtp_addr_;
}
inline ::nv::TNVNetAddr* TNVRtpRtcpPair::release_rtp_addr() {
  clear_has_rtp_addr();
  ::nv::TNVNetAddr* temp = rtp_addr_;
  rtp_addr_ = NULL;
  return temp;
}
inline void TNVRtpRtcpPair::set_allocated_rtp_addr(::nv::TNVNetAddr* rtp_addr) {
  delete rtp_addr_;
  rtp_addr_ = rtp_addr;
  if (rtp_addr) {
    set_has_rtp_addr();
  } else {
    clear_has_rtp_addr();
  }
}

// optional .nv.TNVNetAddr rtcp_addr = 2;
inline bool TNVRtpRtcpPair::has_rtcp_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVRtpRtcpPair::set_has_rtcp_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVRtpRtcpPair::clear_has_rtcp_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVRtpRtcpPair::clear_rtcp_addr() {
  if (rtcp_addr_ != NULL) rtcp_addr_->::nv::TNVNetAddr::Clear();
  clear_has_rtcp_addr();
}
inline const ::nv::TNVNetAddr& TNVRtpRtcpPair::rtcp_addr() const {
  return rtcp_addr_ != NULL ? *rtcp_addr_ : *default_instance_->rtcp_addr_;
}
inline ::nv::TNVNetAddr* TNVRtpRtcpPair::mutable_rtcp_addr() {
  set_has_rtcp_addr();
  if (rtcp_addr_ == NULL) rtcp_addr_ = new ::nv::TNVNetAddr;
  return rtcp_addr_;
}
inline ::nv::TNVNetAddr* TNVRtpRtcpPair::release_rtcp_addr() {
  clear_has_rtcp_addr();
  ::nv::TNVNetAddr* temp = rtcp_addr_;
  rtcp_addr_ = NULL;
  return temp;
}
inline void TNVRtpRtcpPair::set_allocated_rtcp_addr(::nv::TNVNetAddr* rtcp_addr) {
  delete rtcp_addr_;
  rtcp_addr_ = rtcp_addr;
  if (rtcp_addr) {
    set_has_rtcp_addr();
  } else {
    clear_has_rtcp_addr();
  }
}

// -------------------------------------------------------------------

// TNVNetRcvParam

// optional .nv.TNVNetAddr rtp_rcv_addr = 1;
inline bool TNVNetRcvParam::has_rtp_rcv_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVNetRcvParam::set_has_rtp_rcv_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVNetRcvParam::clear_has_rtp_rcv_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVNetRcvParam::clear_rtp_rcv_addr() {
  if (rtp_rcv_addr_ != NULL) rtp_rcv_addr_->::nv::TNVNetAddr::Clear();
  clear_has_rtp_rcv_addr();
}
inline const ::nv::TNVNetAddr& TNVNetRcvParam::rtp_rcv_addr() const {
  return rtp_rcv_addr_ != NULL ? *rtp_rcv_addr_ : *default_instance_->rtp_rcv_addr_;
}
inline ::nv::TNVNetAddr* TNVNetRcvParam::mutable_rtp_rcv_addr() {
  set_has_rtp_rcv_addr();
  if (rtp_rcv_addr_ == NULL) rtp_rcv_addr_ = new ::nv::TNVNetAddr;
  return rtp_rcv_addr_;
}
inline ::nv::TNVNetAddr* TNVNetRcvParam::release_rtp_rcv_addr() {
  clear_has_rtp_rcv_addr();
  ::nv::TNVNetAddr* temp = rtp_rcv_addr_;
  rtp_rcv_addr_ = NULL;
  return temp;
}
inline void TNVNetRcvParam::set_allocated_rtp_rcv_addr(::nv::TNVNetAddr* rtp_rcv_addr) {
  delete rtp_rcv_addr_;
  rtp_rcv_addr_ = rtp_rcv_addr;
  if (rtp_rcv_addr) {
    set_has_rtp_rcv_addr();
  } else {
    clear_has_rtp_rcv_addr();
  }
}

// optional .nv.TNVNetAddr rtcp_rcv_addr = 2;
inline bool TNVNetRcvParam::has_rtcp_rcv_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVNetRcvParam::set_has_rtcp_rcv_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVNetRcvParam::clear_has_rtcp_rcv_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVNetRcvParam::clear_rtcp_rcv_addr() {
  if (rtcp_rcv_addr_ != NULL) rtcp_rcv_addr_->::nv::TNVNetAddr::Clear();
  clear_has_rtcp_rcv_addr();
}
inline const ::nv::TNVNetAddr& TNVNetRcvParam::rtcp_rcv_addr() const {
  return rtcp_rcv_addr_ != NULL ? *rtcp_rcv_addr_ : *default_instance_->rtcp_rcv_addr_;
}
inline ::nv::TNVNetAddr* TNVNetRcvParam::mutable_rtcp_rcv_addr() {
  set_has_rtcp_rcv_addr();
  if (rtcp_rcv_addr_ == NULL) rtcp_rcv_addr_ = new ::nv::TNVNetAddr;
  return rtcp_rcv_addr_;
}
inline ::nv::TNVNetAddr* TNVNetRcvParam::release_rtcp_rcv_addr() {
  clear_has_rtcp_rcv_addr();
  ::nv::TNVNetAddr* temp = rtcp_rcv_addr_;
  rtcp_rcv_addr_ = NULL;
  return temp;
}
inline void TNVNetRcvParam::set_allocated_rtcp_rcv_addr(::nv::TNVNetAddr* rtcp_rcv_addr) {
  delete rtcp_rcv_addr_;
  rtcp_rcv_addr_ = rtcp_rcv_addr;
  if (rtcp_rcv_addr) {
    set_has_rtcp_rcv_addr();
  } else {
    clear_has_rtcp_rcv_addr();
  }
}

// optional .nv.TNVNetAddr pinghole_addr = 3;
inline bool TNVNetRcvParam::has_pinghole_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVNetRcvParam::set_has_pinghole_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVNetRcvParam::clear_has_pinghole_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVNetRcvParam::clear_pinghole_addr() {
  if (pinghole_addr_ != NULL) pinghole_addr_->::nv::TNVNetAddr::Clear();
  clear_has_pinghole_addr();
}
inline const ::nv::TNVNetAddr& TNVNetRcvParam::pinghole_addr() const {
  return pinghole_addr_ != NULL ? *pinghole_addr_ : *default_instance_->pinghole_addr_;
}
inline ::nv::TNVNetAddr* TNVNetRcvParam::mutable_pinghole_addr() {
  set_has_pinghole_addr();
  if (pinghole_addr_ == NULL) pinghole_addr_ = new ::nv::TNVNetAddr;
  return pinghole_addr_;
}
inline ::nv::TNVNetAddr* TNVNetRcvParam::release_pinghole_addr() {
  clear_has_pinghole_addr();
  ::nv::TNVNetAddr* temp = pinghole_addr_;
  pinghole_addr_ = NULL;
  return temp;
}
inline void TNVNetRcvParam::set_allocated_pinghole_addr(::nv::TNVNetAddr* pinghole_addr) {
  delete pinghole_addr_;
  pinghole_addr_ = pinghole_addr;
  if (pinghole_addr) {
    set_has_pinghole_addr();
  } else {
    clear_has_pinghole_addr();
  }
}

// optional .nv.TNVNetAddr rtcp_snd_addr = 4;
inline bool TNVNetRcvParam::has_rtcp_snd_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVNetRcvParam::set_has_rtcp_snd_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVNetRcvParam::clear_has_rtcp_snd_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVNetRcvParam::clear_rtcp_snd_addr() {
  if (rtcp_snd_addr_ != NULL) rtcp_snd_addr_->::nv::TNVNetAddr::Clear();
  clear_has_rtcp_snd_addr();
}
inline const ::nv::TNVNetAddr& TNVNetRcvParam::rtcp_snd_addr() const {
  return rtcp_snd_addr_ != NULL ? *rtcp_snd_addr_ : *default_instance_->rtcp_snd_addr_;
}
inline ::nv::TNVNetAddr* TNVNetRcvParam::mutable_rtcp_snd_addr() {
  set_has_rtcp_snd_addr();
  if (rtcp_snd_addr_ == NULL) rtcp_snd_addr_ = new ::nv::TNVNetAddr;
  return rtcp_snd_addr_;
}
inline ::nv::TNVNetAddr* TNVNetRcvParam::release_rtcp_snd_addr() {
  clear_has_rtcp_snd_addr();
  ::nv::TNVNetAddr* temp = rtcp_snd_addr_;
  rtcp_snd_addr_ = NULL;
  return temp;
}
inline void TNVNetRcvParam::set_allocated_rtcp_snd_addr(::nv::TNVNetAddr* rtcp_snd_addr) {
  delete rtcp_snd_addr_;
  rtcp_snd_addr_ = rtcp_snd_addr;
  if (rtcp_snd_addr) {
    set_has_rtcp_snd_addr();
  } else {
    clear_has_rtcp_snd_addr();
  }
}

// -------------------------------------------------------------------

// TNVNetSndParam

// optional .nv.TNVRtpRtcpPair local_addr = 1;
inline bool TNVNetSndParam::has_local_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVNetSndParam::set_has_local_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVNetSndParam::clear_has_local_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVNetSndParam::clear_local_addr() {
  if (local_addr_ != NULL) local_addr_->::nv::TNVRtpRtcpPair::Clear();
  clear_has_local_addr();
}
inline const ::nv::TNVRtpRtcpPair& TNVNetSndParam::local_addr() const {
  return local_addr_ != NULL ? *local_addr_ : *default_instance_->local_addr_;
}
inline ::nv::TNVRtpRtcpPair* TNVNetSndParam::mutable_local_addr() {
  set_has_local_addr();
  if (local_addr_ == NULL) local_addr_ = new ::nv::TNVRtpRtcpPair;
  return local_addr_;
}
inline ::nv::TNVRtpRtcpPair* TNVNetSndParam::release_local_addr() {
  clear_has_local_addr();
  ::nv::TNVRtpRtcpPair* temp = local_addr_;
  local_addr_ = NULL;
  return temp;
}
inline void TNVNetSndParam::set_allocated_local_addr(::nv::TNVRtpRtcpPair* local_addr) {
  delete local_addr_;
  local_addr_ = local_addr;
  if (local_addr) {
    set_has_local_addr();
  } else {
    clear_has_local_addr();
  }
}

// repeated .nv.TNVRtpRtcpPair remote_addrs = 2;
inline int TNVNetSndParam::remote_addrs_size() const {
  return remote_addrs_.size();
}
inline void TNVNetSndParam::clear_remote_addrs() {
  remote_addrs_.Clear();
}
inline const ::nv::TNVRtpRtcpPair& TNVNetSndParam::remote_addrs(int index) const {
  return remote_addrs_.Get(index);
}
inline ::nv::TNVRtpRtcpPair* TNVNetSndParam::mutable_remote_addrs(int index) {
  return remote_addrs_.Mutable(index);
}
inline ::nv::TNVRtpRtcpPair* TNVNetSndParam::add_remote_addrs() {
  return remote_addrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVRtpRtcpPair >&
TNVNetSndParam::remote_addrs() const {
  return remote_addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVRtpRtcpPair >*
TNVNetSndParam::mutable_remote_addrs() {
  return &remote_addrs_;
}

// -------------------------------------------------------------------

// TNVSnapshotFileInfo

// optional string file_path = 1;
inline bool TNVSnapshotFileInfo::has_file_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVSnapshotFileInfo::set_has_file_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVSnapshotFileInfo::clear_has_file_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVSnapshotFileInfo::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& TNVSnapshotFileInfo::file_path() const {
  return *file_path_;
}
inline void TNVSnapshotFileInfo::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void TNVSnapshotFileInfo::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void TNVSnapshotFileInfo::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSnapshotFileInfo::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  return file_path_;
}
inline ::std::string* TNVSnapshotFileInfo::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVSnapshotFileInfo::set_allocated_file_path(::std::string* file_path) {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    delete file_path_;
  }
  if (file_path) {
    set_has_file_path();
    file_path_ = file_path;
  } else {
    clear_has_file_path();
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string file_name = 2;
inline bool TNVSnapshotFileInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVSnapshotFileInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVSnapshotFileInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVSnapshotFileInfo::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& TNVSnapshotFileInfo::file_name() const {
  return *file_name_;
}
inline void TNVSnapshotFileInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TNVSnapshotFileInfo::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TNVSnapshotFileInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSnapshotFileInfo::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* TNVSnapshotFileInfo::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVSnapshotFileInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.TNVTime file_create_time = 3;
inline bool TNVSnapshotFileInfo::has_file_create_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVSnapshotFileInfo::set_has_file_create_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVSnapshotFileInfo::clear_has_file_create_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVSnapshotFileInfo::clear_file_create_time() {
  if (file_create_time_ != NULL) file_create_time_->::nv::TNVTime::Clear();
  clear_has_file_create_time();
}
inline const ::nv::TNVTime& TNVSnapshotFileInfo::file_create_time() const {
  return file_create_time_ != NULL ? *file_create_time_ : *default_instance_->file_create_time_;
}
inline ::nv::TNVTime* TNVSnapshotFileInfo::mutable_file_create_time() {
  set_has_file_create_time();
  if (file_create_time_ == NULL) file_create_time_ = new ::nv::TNVTime;
  return file_create_time_;
}
inline ::nv::TNVTime* TNVSnapshotFileInfo::release_file_create_time() {
  clear_has_file_create_time();
  ::nv::TNVTime* temp = file_create_time_;
  file_create_time_ = NULL;
  return temp;
}
inline void TNVSnapshotFileInfo::set_allocated_file_create_time(::nv::TNVTime* file_create_time) {
  delete file_create_time_;
  file_create_time_ = file_create_time;
  if (file_create_time) {
    set_has_file_create_time();
  } else {
    clear_has_file_create_time();
  }
}

// -------------------------------------------------------------------

// TNVAudEncDecParam

// optional .nv.EmNvAudFormat aud_format = 1;
inline bool TNVAudEncDecParam::has_aud_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVAudEncDecParam::set_has_aud_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVAudEncDecParam::clear_has_aud_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVAudEncDecParam::clear_aud_format() {
  aud_format_ = 0;
  clear_has_aud_format();
}
inline ::nv::EmNvAudFormat TNVAudEncDecParam::aud_format() const {
  return static_cast< ::nv::EmNvAudFormat >(aud_format_);
}
inline void TNVAudEncDecParam::set_aud_format(::nv::EmNvAudFormat value) {
  assert(::nv::EmNvAudFormat_IsValid(value));
  set_has_aud_format();
  aud_format_ = value;
}

// optional .nv.EmNvAacChnlNum aac_channel_num = 2;
inline bool TNVAudEncDecParam::has_aac_channel_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVAudEncDecParam::set_has_aac_channel_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVAudEncDecParam::clear_has_aac_channel_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVAudEncDecParam::clear_aac_channel_num() {
  aac_channel_num_ = 0;
  clear_has_aac_channel_num();
}
inline ::nv::EmNvAacChnlNum TNVAudEncDecParam::aac_channel_num() const {
  return static_cast< ::nv::EmNvAacChnlNum >(aac_channel_num_);
}
inline void TNVAudEncDecParam::set_aac_channel_num(::nv::EmNvAacChnlNum value) {
  assert(::nv::EmNvAacChnlNum_IsValid(value));
  set_has_aac_channel_num();
  aac_channel_num_ = value;
}

// optional .nv.EmNvAacSampFreq aac_sample_rate = 3;
inline bool TNVAudEncDecParam::has_aac_sample_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVAudEncDecParam::set_has_aac_sample_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVAudEncDecParam::clear_has_aac_sample_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVAudEncDecParam::clear_aac_sample_rate() {
  aac_sample_rate_ = 0;
  clear_has_aac_sample_rate();
}
inline ::nv::EmNvAacSampFreq TNVAudEncDecParam::aac_sample_rate() const {
  return static_cast< ::nv::EmNvAacSampFreq >(aac_sample_rate_);
}
inline void TNVAudEncDecParam::set_aac_sample_rate(::nv::EmNvAacSampFreq value) {
  assert(::nv::EmNvAacSampFreq_IsValid(value));
  set_has_aac_sample_rate();
  aac_sample_rate_ = value;
}

// optional uint32 aac_rate = 4;
inline bool TNVAudEncDecParam::has_aac_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVAudEncDecParam::set_has_aac_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVAudEncDecParam::clear_has_aac_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVAudEncDecParam::clear_aac_rate() {
  aac_rate_ = 0u;
  clear_has_aac_rate();
}
inline ::google::protobuf::uint32 TNVAudEncDecParam::aac_rate() const {
  return aac_rate_;
}
inline void TNVAudEncDecParam::set_aac_rate(::google::protobuf::uint32 value) {
  set_has_aac_rate();
  aac_rate_ = value;
}

// optional uint32 g7221_rate = 5;
inline bool TNVAudEncDecParam::has_g7221_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVAudEncDecParam::set_has_g7221_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVAudEncDecParam::clear_has_g7221_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVAudEncDecParam::clear_g7221_rate() {
  g7221_rate_ = 0u;
  clear_has_g7221_rate();
}
inline ::google::protobuf::uint32 TNVAudEncDecParam::g7221_rate() const {
  return g7221_rate_;
}
inline void TNVAudEncDecParam::set_g7221_rate(::google::protobuf::uint32 value) {
  set_has_g7221_rate();
  g7221_rate_ = value;
}

// -------------------------------------------------------------------

// TNVAudEncStatistic

// optional .nv.EmNvCodecComponent type = 1;
inline bool TNVAudEncStatistic::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVAudEncStatistic::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVAudEncStatistic::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVAudEncStatistic::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::nv::EmNvCodecComponent TNVAudEncStatistic::type() const {
  return static_cast< ::nv::EmNvCodecComponent >(type_);
}
inline void TNVAudEncStatistic::set_type(::nv::EmNvCodecComponent value) {
  assert(::nv::EmNvCodecComponent_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .nv.EmNvCodecComponentIndex aud_enc_id = 2;
inline bool TNVAudEncStatistic::has_aud_enc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVAudEncStatistic::set_has_aud_enc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVAudEncStatistic::clear_has_aud_enc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVAudEncStatistic::clear_aud_enc_id() {
  aud_enc_id_ = 0;
  clear_has_aud_enc_id();
}
inline ::nv::EmNvCodecComponentIndex TNVAudEncStatistic::aud_enc_id() const {
  return static_cast< ::nv::EmNvCodecComponentIndex >(aud_enc_id_);
}
inline void TNVAudEncStatistic::set_aud_enc_id(::nv::EmNvCodecComponentIndex value) {
  assert(::nv::EmNvCodecComponentIndex_IsValid(value));
  set_has_aud_enc_id();
  aud_enc_id_ = value;
}

// optional uint32 enc_bitrate = 3;
inline bool TNVAudEncStatistic::has_enc_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVAudEncStatistic::set_has_enc_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVAudEncStatistic::clear_has_enc_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVAudEncStatistic::clear_enc_bitrate() {
  enc_bitrate_ = 0u;
  clear_has_enc_bitrate();
}
inline ::google::protobuf::uint32 TNVAudEncStatistic::enc_bitrate() const {
  return enc_bitrate_;
}
inline void TNVAudEncStatistic::set_enc_bitrate(::google::protobuf::uint32 value) {
  set_has_enc_bitrate();
  enc_bitrate_ = value;
}

// optional .nv.EmNvAudFormat aud_enc_type = 4;
inline bool TNVAudEncStatistic::has_aud_enc_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVAudEncStatistic::set_has_aud_enc_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVAudEncStatistic::clear_has_aud_enc_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVAudEncStatistic::clear_aud_enc_type() {
  aud_enc_type_ = 0;
  clear_has_aud_enc_type();
}
inline ::nv::EmNvAudFormat TNVAudEncStatistic::aud_enc_type() const {
  return static_cast< ::nv::EmNvAudFormat >(aud_enc_type_);
}
inline void TNVAudEncStatistic::set_aud_enc_type(::nv::EmNvAudFormat value) {
  assert(::nv::EmNvAudFormat_IsValid(value));
  set_has_aud_enc_type();
  aud_enc_type_ = value;
}

// optional bool Audio_Enc_Start = 5;
inline bool TNVAudEncStatistic::has_audio_enc_start() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVAudEncStatistic::set_has_audio_enc_start() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVAudEncStatistic::clear_has_audio_enc_start() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVAudEncStatistic::clear_audio_enc_start() {
  audio_enc_start_ = false;
  clear_has_audio_enc_start();
}
inline bool TNVAudEncStatistic::audio_enc_start() const {
  return audio_enc_start_;
}
inline void TNVAudEncStatistic::set_audio_enc_start(bool value) {
  set_has_audio_enc_start();
  audio_enc_start_ = value;
}

// optional .nv.EmNvAacChnlNum aac_chnl_num = 6;
inline bool TNVAudEncStatistic::has_aac_chnl_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVAudEncStatistic::set_has_aac_chnl_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVAudEncStatistic::clear_has_aac_chnl_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVAudEncStatistic::clear_aac_chnl_num() {
  aac_chnl_num_ = 0;
  clear_has_aac_chnl_num();
}
inline ::nv::EmNvAacChnlNum TNVAudEncStatistic::aac_chnl_num() const {
  return static_cast< ::nv::EmNvAacChnlNum >(aac_chnl_num_);
}
inline void TNVAudEncStatistic::set_aac_chnl_num(::nv::EmNvAacChnlNum value) {
  assert(::nv::EmNvAacChnlNum_IsValid(value));
  set_has_aac_chnl_num();
  aac_chnl_num_ = value;
}

// -------------------------------------------------------------------

// TNVAudDecStatistic

// optional .nv.EmNvCodecComponent type = 1;
inline bool TNVAudDecStatistic::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVAudDecStatistic::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVAudDecStatistic::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVAudDecStatistic::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::nv::EmNvCodecComponent TNVAudDecStatistic::type() const {
  return static_cast< ::nv::EmNvCodecComponent >(type_);
}
inline void TNVAudDecStatistic::set_type(::nv::EmNvCodecComponent value) {
  assert(::nv::EmNvCodecComponent_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .nv.EmNvCodecComponentIndex aud_dec_id = 2;
inline bool TNVAudDecStatistic::has_aud_dec_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVAudDecStatistic::set_has_aud_dec_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVAudDecStatistic::clear_has_aud_dec_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVAudDecStatistic::clear_aud_dec_id() {
  aud_dec_id_ = 0;
  clear_has_aud_dec_id();
}
inline ::nv::EmNvCodecComponentIndex TNVAudDecStatistic::aud_dec_id() const {
  return static_cast< ::nv::EmNvCodecComponentIndex >(aud_dec_id_);
}
inline void TNVAudDecStatistic::set_aud_dec_id(::nv::EmNvCodecComponentIndex value) {
  assert(::nv::EmNvCodecComponentIndex_IsValid(value));
  set_has_aud_dec_id();
  aud_dec_id_ = value;
}

// optional uint32 dec_bitrate = 3;
inline bool TNVAudDecStatistic::has_dec_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVAudDecStatistic::set_has_dec_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVAudDecStatistic::clear_has_dec_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVAudDecStatistic::clear_dec_bitrate() {
  dec_bitrate_ = 0u;
  clear_has_dec_bitrate();
}
inline ::google::protobuf::uint32 TNVAudDecStatistic::dec_bitrate() const {
  return dec_bitrate_;
}
inline void TNVAudDecStatistic::set_dec_bitrate(::google::protobuf::uint32 value) {
  set_has_dec_bitrate();
  dec_bitrate_ = value;
}

// optional uint32 rcved_frames = 4;
inline bool TNVAudDecStatistic::has_rcved_frames() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVAudDecStatistic::set_has_rcved_frames() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVAudDecStatistic::clear_has_rcved_frames() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVAudDecStatistic::clear_rcved_frames() {
  rcved_frames_ = 0u;
  clear_has_rcved_frames();
}
inline ::google::protobuf::uint32 TNVAudDecStatistic::rcved_frames() const {
  return rcved_frames_;
}
inline void TNVAudDecStatistic::set_rcved_frames(::google::protobuf::uint32 value) {
  set_has_rcved_frames();
  rcved_frames_ = value;
}

// optional uint32 lost_pack_ratio = 5;
inline bool TNVAudDecStatistic::has_lost_pack_ratio() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVAudDecStatistic::set_has_lost_pack_ratio() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVAudDecStatistic::clear_has_lost_pack_ratio() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVAudDecStatistic::clear_lost_pack_ratio() {
  lost_pack_ratio_ = 0u;
  clear_has_lost_pack_ratio();
}
inline ::google::protobuf::uint32 TNVAudDecStatistic::lost_pack_ratio() const {
  return lost_pack_ratio_;
}
inline void TNVAudDecStatistic::set_lost_pack_ratio(::google::protobuf::uint32 value) {
  set_has_lost_pack_ratio();
  lost_pack_ratio_ = value;
}

// optional uint32 physical_lost_pack_ratio = 6;
inline bool TNVAudDecStatistic::has_physical_lost_pack_ratio() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVAudDecStatistic::set_has_physical_lost_pack_ratio() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVAudDecStatistic::clear_has_physical_lost_pack_ratio() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVAudDecStatistic::clear_physical_lost_pack_ratio() {
  physical_lost_pack_ratio_ = 0u;
  clear_has_physical_lost_pack_ratio();
}
inline ::google::protobuf::uint32 TNVAudDecStatistic::physical_lost_pack_ratio() const {
  return physical_lost_pack_ratio_;
}
inline void TNVAudDecStatistic::set_physical_lost_pack_ratio(::google::protobuf::uint32 value) {
  set_has_physical_lost_pack_ratio();
  physical_lost_pack_ratio_ = value;
}

// optional uint32 lost_packs = 7;
inline bool TNVAudDecStatistic::has_lost_packs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVAudDecStatistic::set_has_lost_packs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVAudDecStatistic::clear_has_lost_packs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVAudDecStatistic::clear_lost_packs() {
  lost_packs_ = 0u;
  clear_has_lost_packs();
}
inline ::google::protobuf::uint32 TNVAudDecStatistic::lost_packs() const {
  return lost_packs_;
}
inline void TNVAudDecStatistic::set_lost_packs(::google::protobuf::uint32 value) {
  set_has_lost_packs();
  lost_packs_ = value;
}

// optional .nv.EmNvAudFormat aud_dec_type = 8;
inline bool TNVAudDecStatistic::has_aud_dec_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVAudDecStatistic::set_has_aud_dec_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVAudDecStatistic::clear_has_aud_dec_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVAudDecStatistic::clear_aud_dec_type() {
  aud_dec_type_ = 0;
  clear_has_aud_dec_type();
}
inline ::nv::EmNvAudFormat TNVAudDecStatistic::aud_dec_type() const {
  return static_cast< ::nv::EmNvAudFormat >(aud_dec_type_);
}
inline void TNVAudDecStatistic::set_aud_dec_type(::nv::EmNvAudFormat value) {
  assert(::nv::EmNvAudFormat_IsValid(value));
  set_has_aud_dec_type();
  aud_dec_type_ = value;
}

// optional bool Audio_Dec_Start = 9;
inline bool TNVAudDecStatistic::has_audio_dec_start() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVAudDecStatistic::set_has_audio_dec_start() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVAudDecStatistic::clear_has_audio_dec_start() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVAudDecStatistic::clear_audio_dec_start() {
  audio_dec_start_ = false;
  clear_has_audio_dec_start();
}
inline bool TNVAudDecStatistic::audio_dec_start() const {
  return audio_dec_start_;
}
inline void TNVAudDecStatistic::set_audio_dec_start(bool value) {
  set_has_audio_dec_start();
  audio_dec_start_ = value;
}

// optional .nv.EmNvAudFormat audchan_dec_type = 10;
inline bool TNVAudDecStatistic::has_audchan_dec_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TNVAudDecStatistic::set_has_audchan_dec_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TNVAudDecStatistic::clear_has_audchan_dec_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TNVAudDecStatistic::clear_audchan_dec_type() {
  audchan_dec_type_ = 0;
  clear_has_audchan_dec_type();
}
inline ::nv::EmNvAudFormat TNVAudDecStatistic::audchan_dec_type() const {
  return static_cast< ::nv::EmNvAudFormat >(audchan_dec_type_);
}
inline void TNVAudDecStatistic::set_audchan_dec_type(::nv::EmNvAudFormat value) {
  assert(::nv::EmNvAudFormat_IsValid(value));
  set_has_audchan_dec_type();
  audchan_dec_type_ = value;
}

// optional .nv.EmNvAacChnlNum aac_chnl_num = 11;
inline bool TNVAudDecStatistic::has_aac_chnl_num() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TNVAudDecStatistic::set_has_aac_chnl_num() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TNVAudDecStatistic::clear_has_aac_chnl_num() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TNVAudDecStatistic::clear_aac_chnl_num() {
  aac_chnl_num_ = 0;
  clear_has_aac_chnl_num();
}
inline ::nv::EmNvAacChnlNum TNVAudDecStatistic::aac_chnl_num() const {
  return static_cast< ::nv::EmNvAacChnlNum >(aac_chnl_num_);
}
inline void TNVAudDecStatistic::set_aac_chnl_num(::nv::EmNvAacChnlNum value) {
  assert(::nv::EmNvAacChnlNum_IsValid(value));
  set_has_aac_chnl_num();
  aac_chnl_num_ = value;
}

// -------------------------------------------------------------------

// TNVVidEncStatistic

// optional .nv.EmNvCodecComponent type = 1;
inline bool TNVVidEncStatistic::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVVidEncStatistic::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVVidEncStatistic::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVVidEncStatistic::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::nv::EmNvCodecComponent TNVVidEncStatistic::type() const {
  return static_cast< ::nv::EmNvCodecComponent >(type_);
}
inline void TNVVidEncStatistic::set_type(::nv::EmNvCodecComponent value) {
  assert(::nv::EmNvCodecComponent_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .nv.EmNvCodecComponentIndex vid_enc_id = 2;
inline bool TNVVidEncStatistic::has_vid_enc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVVidEncStatistic::set_has_vid_enc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVVidEncStatistic::clear_has_vid_enc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVVidEncStatistic::clear_vid_enc_id() {
  vid_enc_id_ = 0;
  clear_has_vid_enc_id();
}
inline ::nv::EmNvCodecComponentIndex TNVVidEncStatistic::vid_enc_id() const {
  return static_cast< ::nv::EmNvCodecComponentIndex >(vid_enc_id_);
}
inline void TNVVidEncStatistic::set_vid_enc_id(::nv::EmNvCodecComponentIndex value) {
  assert(::nv::EmNvCodecComponentIndex_IsValid(value));
  set_has_vid_enc_id();
  vid_enc_id_ = value;
}

// optional uint32 enc_bitrate = 3;
inline bool TNVVidEncStatistic::has_enc_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVVidEncStatistic::set_has_enc_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVVidEncStatistic::clear_has_enc_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVVidEncStatistic::clear_enc_bitrate() {
  enc_bitrate_ = 0u;
  clear_has_enc_bitrate();
}
inline ::google::protobuf::uint32 TNVVidEncStatistic::enc_bitrate() const {
  return enc_bitrate_;
}
inline void TNVVidEncStatistic::set_enc_bitrate(::google::protobuf::uint32 value) {
  set_has_enc_bitrate();
  enc_bitrate_ = value;
}

// optional uint32 frame_rate = 4;
inline bool TNVVidEncStatistic::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVVidEncStatistic::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVVidEncStatistic::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVVidEncStatistic::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TNVVidEncStatistic::frame_rate() const {
  return frame_rate_;
}
inline void TNVVidEncStatistic::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// optional uint32 vid_width = 5;
inline bool TNVVidEncStatistic::has_vid_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVVidEncStatistic::set_has_vid_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVVidEncStatistic::clear_has_vid_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVVidEncStatistic::clear_vid_width() {
  vid_width_ = 0u;
  clear_has_vid_width();
}
inline ::google::protobuf::uint32 TNVVidEncStatistic::vid_width() const {
  return vid_width_;
}
inline void TNVVidEncStatistic::set_vid_width(::google::protobuf::uint32 value) {
  set_has_vid_width();
  vid_width_ = value;
}

// optional uint32 vid_height = 6;
inline bool TNVVidEncStatistic::has_vid_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVVidEncStatistic::set_has_vid_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVVidEncStatistic::clear_has_vid_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVVidEncStatistic::clear_vid_height() {
  vid_height_ = 0u;
  clear_has_vid_height();
}
inline ::google::protobuf::uint32 TNVVidEncStatistic::vid_height() const {
  return vid_height_;
}
inline void TNVVidEncStatistic::set_vid_height(::google::protobuf::uint32 value) {
  set_has_vid_height();
  vid_height_ = value;
}

// optional .nv.EmNvVidFormat vid_enc_type = 7;
inline bool TNVVidEncStatistic::has_vid_enc_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVVidEncStatistic::set_has_vid_enc_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVVidEncStatistic::clear_has_vid_enc_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVVidEncStatistic::clear_vid_enc_type() {
  vid_enc_type_ = 0;
  clear_has_vid_enc_type();
}
inline ::nv::EmNvVidFormat TNVVidEncStatistic::vid_enc_type() const {
  return static_cast< ::nv::EmNvVidFormat >(vid_enc_type_);
}
inline void TNVVidEncStatistic::set_vid_enc_type(::nv::EmNvVidFormat value) {
  assert(::nv::EmNvVidFormat_IsValid(value));
  set_has_vid_enc_type();
  vid_enc_type_ = value;
}

// optional bool Video_Enc_Start = 8;
inline bool TNVVidEncStatistic::has_video_enc_start() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVVidEncStatistic::set_has_video_enc_start() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVVidEncStatistic::clear_has_video_enc_start() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVVidEncStatistic::clear_video_enc_start() {
  video_enc_start_ = false;
  clear_has_video_enc_start();
}
inline bool TNVVidEncStatistic::video_enc_start() const {
  return video_enc_start_;
}
inline void TNVVidEncStatistic::set_video_enc_start(bool value) {
  set_has_video_enc_start();
  video_enc_start_ = value;
}

// optional .nv.EmNvH264Profile h264_profile = 9;
inline bool TNVVidEncStatistic::has_h264_profile() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVVidEncStatistic::set_has_h264_profile() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVVidEncStatistic::clear_has_h264_profile() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVVidEncStatistic::clear_h264_profile() {
  h264_profile_ = 0;
  clear_has_h264_profile();
}
inline ::nv::EmNvH264Profile TNVVidEncStatistic::h264_profile() const {
  return static_cast< ::nv::EmNvH264Profile >(h264_profile_);
}
inline void TNVVidEncStatistic::set_h264_profile(::nv::EmNvH264Profile value) {
  assert(::nv::EmNvH264Profile_IsValid(value));
  set_has_h264_profile();
  h264_profile_ = value;
}

// optional bool video_resource_exist = 10;
inline bool TNVVidEncStatistic::has_video_resource_exist() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TNVVidEncStatistic::set_has_video_resource_exist() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TNVVidEncStatistic::clear_has_video_resource_exist() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TNVVidEncStatistic::clear_video_resource_exist() {
  video_resource_exist_ = false;
  clear_has_video_resource_exist();
}
inline bool TNVVidEncStatistic::video_resource_exist() const {
  return video_resource_exist_;
}
inline void TNVVidEncStatistic::set_video_resource_exist(bool value) {
  set_has_video_resource_exist();
  video_resource_exist_ = value;
}

// -------------------------------------------------------------------

// TNVVidDecStatistic

// optional .nv.EmNvCodecComponent type = 1;
inline bool TNVVidDecStatistic::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVVidDecStatistic::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVVidDecStatistic::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVVidDecStatistic::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::nv::EmNvCodecComponent TNVVidDecStatistic::type() const {
  return static_cast< ::nv::EmNvCodecComponent >(type_);
}
inline void TNVVidDecStatistic::set_type(::nv::EmNvCodecComponent value) {
  assert(::nv::EmNvCodecComponent_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .nv.EmNvCodecComponentIndex vid_dec_id = 2;
inline bool TNVVidDecStatistic::has_vid_dec_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVVidDecStatistic::set_has_vid_dec_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVVidDecStatistic::clear_has_vid_dec_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVVidDecStatistic::clear_vid_dec_id() {
  vid_dec_id_ = 0;
  clear_has_vid_dec_id();
}
inline ::nv::EmNvCodecComponentIndex TNVVidDecStatistic::vid_dec_id() const {
  return static_cast< ::nv::EmNvCodecComponentIndex >(vid_dec_id_);
}
inline void TNVVidDecStatistic::set_vid_dec_id(::nv::EmNvCodecComponentIndex value) {
  assert(::nv::EmNvCodecComponentIndex_IsValid(value));
  set_has_vid_dec_id();
  vid_dec_id_ = value;
}

// optional uint32 dec_bitrate = 3;
inline bool TNVVidDecStatistic::has_dec_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVVidDecStatistic::set_has_dec_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVVidDecStatistic::clear_has_dec_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVVidDecStatistic::clear_dec_bitrate() {
  dec_bitrate_ = 0u;
  clear_has_dec_bitrate();
}
inline ::google::protobuf::uint32 TNVVidDecStatistic::dec_bitrate() const {
  return dec_bitrate_;
}
inline void TNVVidDecStatistic::set_dec_bitrate(::google::protobuf::uint32 value) {
  set_has_dec_bitrate();
  dec_bitrate_ = value;
}

// optional uint32 rcved_frames = 4;
inline bool TNVVidDecStatistic::has_rcved_frames() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVVidDecStatistic::set_has_rcved_frames() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVVidDecStatistic::clear_has_rcved_frames() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVVidDecStatistic::clear_rcved_frames() {
  rcved_frames_ = 0u;
  clear_has_rcved_frames();
}
inline ::google::protobuf::uint32 TNVVidDecStatistic::rcved_frames() const {
  return rcved_frames_;
}
inline void TNVVidDecStatistic::set_rcved_frames(::google::protobuf::uint32 value) {
  set_has_rcved_frames();
  rcved_frames_ = value;
}

// optional uint32 lost_pack_ratio = 5;
inline bool TNVVidDecStatistic::has_lost_pack_ratio() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVVidDecStatistic::set_has_lost_pack_ratio() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVVidDecStatistic::clear_has_lost_pack_ratio() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVVidDecStatistic::clear_lost_pack_ratio() {
  lost_pack_ratio_ = 0u;
  clear_has_lost_pack_ratio();
}
inline ::google::protobuf::uint32 TNVVidDecStatistic::lost_pack_ratio() const {
  return lost_pack_ratio_;
}
inline void TNVVidDecStatistic::set_lost_pack_ratio(::google::protobuf::uint32 value) {
  set_has_lost_pack_ratio();
  lost_pack_ratio_ = value;
}

// optional uint32 physical_lost_pack_ratio = 6;
inline bool TNVVidDecStatistic::has_physical_lost_pack_ratio() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVVidDecStatistic::set_has_physical_lost_pack_ratio() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVVidDecStatistic::clear_has_physical_lost_pack_ratio() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVVidDecStatistic::clear_physical_lost_pack_ratio() {
  physical_lost_pack_ratio_ = 0u;
  clear_has_physical_lost_pack_ratio();
}
inline ::google::protobuf::uint32 TNVVidDecStatistic::physical_lost_pack_ratio() const {
  return physical_lost_pack_ratio_;
}
inline void TNVVidDecStatistic::set_physical_lost_pack_ratio(::google::protobuf::uint32 value) {
  set_has_physical_lost_pack_ratio();
  physical_lost_pack_ratio_ = value;
}

// optional uint32 lost_packs = 7;
inline bool TNVVidDecStatistic::has_lost_packs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVVidDecStatistic::set_has_lost_packs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVVidDecStatistic::clear_has_lost_packs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVVidDecStatistic::clear_lost_packs() {
  lost_packs_ = 0u;
  clear_has_lost_packs();
}
inline ::google::protobuf::uint32 TNVVidDecStatistic::lost_packs() const {
  return lost_packs_;
}
inline void TNVVidDecStatistic::set_lost_packs(::google::protobuf::uint32 value) {
  set_has_lost_packs();
  lost_packs_ = value;
}

// optional uint32 frame_rate = 8;
inline bool TNVVidDecStatistic::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVVidDecStatistic::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVVidDecStatistic::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVVidDecStatistic::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TNVVidDecStatistic::frame_rate() const {
  return frame_rate_;
}
inline void TNVVidDecStatistic::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// optional uint32 vid_width = 9;
inline bool TNVVidDecStatistic::has_vid_width() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVVidDecStatistic::set_has_vid_width() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVVidDecStatistic::clear_has_vid_width() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVVidDecStatistic::clear_vid_width() {
  vid_width_ = 0u;
  clear_has_vid_width();
}
inline ::google::protobuf::uint32 TNVVidDecStatistic::vid_width() const {
  return vid_width_;
}
inline void TNVVidDecStatistic::set_vid_width(::google::protobuf::uint32 value) {
  set_has_vid_width();
  vid_width_ = value;
}

// optional uint32 vid_height = 10;
inline bool TNVVidDecStatistic::has_vid_height() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TNVVidDecStatistic::set_has_vid_height() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TNVVidDecStatistic::clear_has_vid_height() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TNVVidDecStatistic::clear_vid_height() {
  vid_height_ = 0u;
  clear_has_vid_height();
}
inline ::google::protobuf::uint32 TNVVidDecStatistic::vid_height() const {
  return vid_height_;
}
inline void TNVVidDecStatistic::set_vid_height(::google::protobuf::uint32 value) {
  set_has_vid_height();
  vid_height_ = value;
}

// optional .nv.EmNvVidFormat vid_dec_type = 11;
inline bool TNVVidDecStatistic::has_vid_dec_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TNVVidDecStatistic::set_has_vid_dec_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TNVVidDecStatistic::clear_has_vid_dec_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TNVVidDecStatistic::clear_vid_dec_type() {
  vid_dec_type_ = 0;
  clear_has_vid_dec_type();
}
inline ::nv::EmNvVidFormat TNVVidDecStatistic::vid_dec_type() const {
  return static_cast< ::nv::EmNvVidFormat >(vid_dec_type_);
}
inline void TNVVidDecStatistic::set_vid_dec_type(::nv::EmNvVidFormat value) {
  assert(::nv::EmNvVidFormat_IsValid(value));
  set_has_vid_dec_type();
  vid_dec_type_ = value;
}

// optional bool Video_Dec_Start = 12;
inline bool TNVVidDecStatistic::has_video_dec_start() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TNVVidDecStatistic::set_has_video_dec_start() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TNVVidDecStatistic::clear_has_video_dec_start() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TNVVidDecStatistic::clear_video_dec_start() {
  video_dec_start_ = false;
  clear_has_video_dec_start();
}
inline bool TNVVidDecStatistic::video_dec_start() const {
  return video_dec_start_;
}
inline void TNVVidDecStatistic::set_video_dec_start(bool value) {
  set_has_video_dec_start();
  video_dec_start_ = value;
}

// optional .nv.EmNvH264Profile h264_profile = 13;
inline bool TNVVidDecStatistic::has_h264_profile() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TNVVidDecStatistic::set_has_h264_profile() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TNVVidDecStatistic::clear_has_h264_profile() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TNVVidDecStatistic::clear_h264_profile() {
  h264_profile_ = 0;
  clear_has_h264_profile();
}
inline ::nv::EmNvH264Profile TNVVidDecStatistic::h264_profile() const {
  return static_cast< ::nv::EmNvH264Profile >(h264_profile_);
}
inline void TNVVidDecStatistic::set_h264_profile(::nv::EmNvH264Profile value) {
  assert(::nv::EmNvH264Profile_IsValid(value));
  set_has_h264_profile();
  h264_profile_ = value;
}

// -------------------------------------------------------------------

// TNVCodecStatistic

// repeated .nv.TNVAudEncStatistic main_aud_enc_static = 1;
inline int TNVCodecStatistic::main_aud_enc_static_size() const {
  return main_aud_enc_static_.size();
}
inline void TNVCodecStatistic::clear_main_aud_enc_static() {
  main_aud_enc_static_.Clear();
}
inline const ::nv::TNVAudEncStatistic& TNVCodecStatistic::main_aud_enc_static(int index) const {
  return main_aud_enc_static_.Get(index);
}
inline ::nv::TNVAudEncStatistic* TNVCodecStatistic::mutable_main_aud_enc_static(int index) {
  return main_aud_enc_static_.Mutable(index);
}
inline ::nv::TNVAudEncStatistic* TNVCodecStatistic::add_main_aud_enc_static() {
  return main_aud_enc_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVAudEncStatistic >&
TNVCodecStatistic::main_aud_enc_static() const {
  return main_aud_enc_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVAudEncStatistic >*
TNVCodecStatistic::mutable_main_aud_enc_static() {
  return &main_aud_enc_static_;
}

// repeated .nv.TNVAudDecStatistic main_aud_dec_static = 2;
inline int TNVCodecStatistic::main_aud_dec_static_size() const {
  return main_aud_dec_static_.size();
}
inline void TNVCodecStatistic::clear_main_aud_dec_static() {
  main_aud_dec_static_.Clear();
}
inline const ::nv::TNVAudDecStatistic& TNVCodecStatistic::main_aud_dec_static(int index) const {
  return main_aud_dec_static_.Get(index);
}
inline ::nv::TNVAudDecStatistic* TNVCodecStatistic::mutable_main_aud_dec_static(int index) {
  return main_aud_dec_static_.Mutable(index);
}
inline ::nv::TNVAudDecStatistic* TNVCodecStatistic::add_main_aud_dec_static() {
  return main_aud_dec_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVAudDecStatistic >&
TNVCodecStatistic::main_aud_dec_static() const {
  return main_aud_dec_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVAudDecStatistic >*
TNVCodecStatistic::mutable_main_aud_dec_static() {
  return &main_aud_dec_static_;
}

// repeated .nv.TNVVidEncStatistic main_vid_enc_static = 3;
inline int TNVCodecStatistic::main_vid_enc_static_size() const {
  return main_vid_enc_static_.size();
}
inline void TNVCodecStatistic::clear_main_vid_enc_static() {
  main_vid_enc_static_.Clear();
}
inline const ::nv::TNVVidEncStatistic& TNVCodecStatistic::main_vid_enc_static(int index) const {
  return main_vid_enc_static_.Get(index);
}
inline ::nv::TNVVidEncStatistic* TNVCodecStatistic::mutable_main_vid_enc_static(int index) {
  return main_vid_enc_static_.Mutable(index);
}
inline ::nv::TNVVidEncStatistic* TNVCodecStatistic::add_main_vid_enc_static() {
  return main_vid_enc_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidEncStatistic >&
TNVCodecStatistic::main_vid_enc_static() const {
  return main_vid_enc_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidEncStatistic >*
TNVCodecStatistic::mutable_main_vid_enc_static() {
  return &main_vid_enc_static_;
}

// repeated .nv.TNVVidDecStatistic main_vid_dec_static = 4;
inline int TNVCodecStatistic::main_vid_dec_static_size() const {
  return main_vid_dec_static_.size();
}
inline void TNVCodecStatistic::clear_main_vid_dec_static() {
  main_vid_dec_static_.Clear();
}
inline const ::nv::TNVVidDecStatistic& TNVCodecStatistic::main_vid_dec_static(int index) const {
  return main_vid_dec_static_.Get(index);
}
inline ::nv::TNVVidDecStatistic* TNVCodecStatistic::mutable_main_vid_dec_static(int index) {
  return main_vid_dec_static_.Mutable(index);
}
inline ::nv::TNVVidDecStatistic* TNVCodecStatistic::add_main_vid_dec_static() {
  return main_vid_dec_static_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidDecStatistic >&
TNVCodecStatistic::main_vid_dec_static() const {
  return main_vid_dec_static_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidDecStatistic >*
TNVCodecStatistic::mutable_main_vid_dec_static() {
  return &main_vid_dec_static_;
}

// -------------------------------------------------------------------

// TNVInputEvent

// optional uint32 type = 1;
inline bool TNVInputEvent::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVInputEvent::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVInputEvent::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVInputEvent::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 TNVInputEvent::type() const {
  return type_;
}
inline void TNVInputEvent::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 code = 2;
inline bool TNVInputEvent::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVInputEvent::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVInputEvent::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVInputEvent::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 TNVInputEvent::code() const {
  return code_;
}
inline void TNVInputEvent::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
}

// optional uint32 value = 3;
inline bool TNVInputEvent::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVInputEvent::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVInputEvent::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVInputEvent::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 TNVInputEvent::value() const {
  return value_;
}
inline void TNVInputEvent::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// TNVInputEvents

// repeated uint32 value = 1;
inline int TNVInputEvents::value_size() const {
  return value_.size();
}
inline void TNVInputEvents::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint32 TNVInputEvents::value(int index) const {
  return value_.Get(index);
}
inline void TNVInputEvents::set_value(int index, ::google::protobuf::uint32 value) {
  value_.Set(index, value);
}
inline void TNVInputEvents::add_value(::google::protobuf::uint32 value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TNVInputEvents::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TNVInputEvents::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// TNvVidSrcInfo

// optional .nv.EmNvCodecComponent codec_type = 1;
inline bool TNvVidSrcInfo::has_codec_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNvVidSrcInfo::set_has_codec_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNvVidSrcInfo::clear_has_codec_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNvVidSrcInfo::clear_codec_type() {
  codec_type_ = 0;
  clear_has_codec_type();
}
inline ::nv::EmNvCodecComponent TNvVidSrcInfo::codec_type() const {
  return static_cast< ::nv::EmNvCodecComponent >(codec_type_);
}
inline void TNvVidSrcInfo::set_codec_type(::nv::EmNvCodecComponent value) {
  assert(::nv::EmNvCodecComponent_IsValid(value));
  set_has_codec_type();
  codec_type_ = value;
}

// optional .nv.EmNvCodecComponentIndex codec_id = 2;
inline bool TNvVidSrcInfo::has_codec_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNvVidSrcInfo::set_has_codec_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNvVidSrcInfo::clear_has_codec_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNvVidSrcInfo::clear_codec_id() {
  codec_id_ = 0;
  clear_has_codec_id();
}
inline ::nv::EmNvCodecComponentIndex TNvVidSrcInfo::codec_id() const {
  return static_cast< ::nv::EmNvCodecComponentIndex >(codec_id_);
}
inline void TNvVidSrcInfo::set_codec_id(::nv::EmNvCodecComponentIndex value) {
  assert(::nv::EmNvCodecComponentIndex_IsValid(value));
  set_has_codec_id();
  codec_id_ = value;
}

// optional uint32 video_width = 3;
inline bool TNvVidSrcInfo::has_video_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNvVidSrcInfo::set_has_video_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNvVidSrcInfo::clear_has_video_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNvVidSrcInfo::clear_video_width() {
  video_width_ = 0u;
  clear_has_video_width();
}
inline ::google::protobuf::uint32 TNvVidSrcInfo::video_width() const {
  return video_width_;
}
inline void TNvVidSrcInfo::set_video_width(::google::protobuf::uint32 value) {
  set_has_video_width();
  video_width_ = value;
}

// optional uint32 video_height = 4;
inline bool TNvVidSrcInfo::has_video_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNvVidSrcInfo::set_has_video_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNvVidSrcInfo::clear_has_video_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNvVidSrcInfo::clear_video_height() {
  video_height_ = 0u;
  clear_has_video_height();
}
inline ::google::protobuf::uint32 TNvVidSrcInfo::video_height() const {
  return video_height_;
}
inline void TNvVidSrcInfo::set_video_height(::google::protobuf::uint32 value) {
  set_has_video_height();
  video_height_ = value;
}

// optional bool video_progressive = 5;
inline bool TNvVidSrcInfo::has_video_progressive() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNvVidSrcInfo::set_has_video_progressive() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNvVidSrcInfo::clear_has_video_progressive() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNvVidSrcInfo::clear_video_progressive() {
  video_progressive_ = false;
  clear_has_video_progressive();
}
inline bool TNvVidSrcInfo::video_progressive() const {
  return video_progressive_;
}
inline void TNvVidSrcInfo::set_video_progressive(bool value) {
  set_has_video_progressive();
  video_progressive_ = value;
}

// optional uint32 frame_rate = 6;
inline bool TNvVidSrcInfo::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNvVidSrcInfo::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNvVidSrcInfo::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNvVidSrcInfo::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TNvVidSrcInfo::frame_rate() const {
  return frame_rate_;
}
inline void TNvVidSrcInfo::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// -------------------------------------------------------------------

// TNVVidEncParam

// optional .nv.EmNvEncodeMode enc_mode = 1;
inline bool TNVVidEncParam::has_enc_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVVidEncParam::set_has_enc_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVVidEncParam::clear_has_enc_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVVidEncParam::clear_enc_mode() {
  enc_mode_ = 0;
  clear_has_enc_mode();
}
inline ::nv::EmNvEncodeMode TNVVidEncParam::enc_mode() const {
  return static_cast< ::nv::EmNvEncodeMode >(enc_mode_);
}
inline void TNVVidEncParam::set_enc_mode(::nv::EmNvEncodeMode value) {
  assert(::nv::EmNvEncodeMode_IsValid(value));
  set_has_enc_mode();
  enc_mode_ = value;
}

// optional .nv.EmNvVidFormat vid_format = 2;
inline bool TNVVidEncParam::has_vid_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVVidEncParam::set_has_vid_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVVidEncParam::clear_has_vid_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVVidEncParam::clear_vid_format() {
  vid_format_ = 0;
  clear_has_vid_format();
}
inline ::nv::EmNvVidFormat TNVVidEncParam::vid_format() const {
  return static_cast< ::nv::EmNvVidFormat >(vid_format_);
}
inline void TNVVidEncParam::set_vid_format(::nv::EmNvVidFormat value) {
  assert(::nv::EmNvVidFormat_IsValid(value));
  set_has_vid_format();
  vid_format_ = value;
}

// optional uint32 max_key_frame_interval = 3;
inline bool TNVVidEncParam::has_max_key_frame_interval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVVidEncParam::set_has_max_key_frame_interval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVVidEncParam::clear_has_max_key_frame_interval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVVidEncParam::clear_max_key_frame_interval() {
  max_key_frame_interval_ = 0u;
  clear_has_max_key_frame_interval();
}
inline ::google::protobuf::uint32 TNVVidEncParam::max_key_frame_interval() const {
  return max_key_frame_interval_;
}
inline void TNVVidEncParam::set_max_key_frame_interval(::google::protobuf::uint32 value) {
  set_has_max_key_frame_interval();
  max_key_frame_interval_ = value;
}

// optional uint32 max_quant = 4;
inline bool TNVVidEncParam::has_max_quant() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVVidEncParam::set_has_max_quant() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVVidEncParam::clear_has_max_quant() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVVidEncParam::clear_max_quant() {
  max_quant_ = 0u;
  clear_has_max_quant();
}
inline ::google::protobuf::uint32 TNVVidEncParam::max_quant() const {
  return max_quant_;
}
inline void TNVVidEncParam::set_max_quant(::google::protobuf::uint32 value) {
  set_has_max_quant();
  max_quant_ = value;
}

// optional uint32 min_quant = 5;
inline bool TNVVidEncParam::has_min_quant() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVVidEncParam::set_has_min_quant() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVVidEncParam::clear_has_min_quant() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVVidEncParam::clear_min_quant() {
  min_quant_ = 0u;
  clear_has_min_quant();
}
inline ::google::protobuf::uint32 TNVVidEncParam::min_quant() const {
  return min_quant_;
}
inline void TNVVidEncParam::set_min_quant(::google::protobuf::uint32 value) {
  set_has_min_quant();
  min_quant_ = value;
}

// optional uint32 frame_rate = 6;
inline bool TNVVidEncParam::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVVidEncParam::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVVidEncParam::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVVidEncParam::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TNVVidEncParam::frame_rate() const {
  return frame_rate_;
}
inline void TNVVidEncParam::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// optional uint32 bitrate = 7;
inline bool TNVVidEncParam::has_bitrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVVidEncParam::set_has_bitrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVVidEncParam::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVVidEncParam::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TNVVidEncParam::bitrate() const {
  return bitrate_;
}
inline void TNVVidEncParam::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional uint32 h264_profile = 8;
inline bool TNVVidEncParam::has_h264_profile() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVVidEncParam::set_has_h264_profile() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVVidEncParam::clear_has_h264_profile() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVVidEncParam::clear_h264_profile() {
  h264_profile_ = 0u;
  clear_has_h264_profile();
}
inline ::google::protobuf::uint32 TNVVidEncParam::h264_profile() const {
  return h264_profile_;
}
inline void TNVVidEncParam::set_h264_profile(::google::protobuf::uint32 value) {
  set_has_h264_profile();
  h264_profile_ = value;
}

// optional uint32 width = 9;
inline bool TNVVidEncParam::has_width() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVVidEncParam::set_has_width() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVVidEncParam::clear_has_width() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVVidEncParam::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 TNVVidEncParam::width() const {
  return width_;
}
inline void TNVVidEncParam::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional uint32 height = 10;
inline bool TNVVidEncParam::has_height() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TNVVidEncParam::set_has_height() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TNVVidEncParam::clear_has_height() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TNVVidEncParam::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 TNVVidEncParam::height() const {
  return height_;
}
inline void TNVVidEncParam::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// TNVVidSrcInfoList

// repeated .nv.TNvVidSrcInfo video_src_status = 1;
inline int TNVVidSrcInfoList::video_src_status_size() const {
  return video_src_status_.size();
}
inline void TNVVidSrcInfoList::clear_video_src_status() {
  video_src_status_.Clear();
}
inline const ::nv::TNvVidSrcInfo& TNVVidSrcInfoList::video_src_status(int index) const {
  return video_src_status_.Get(index);
}
inline ::nv::TNvVidSrcInfo* TNVVidSrcInfoList::mutable_video_src_status(int index) {
  return video_src_status_.Mutable(index);
}
inline ::nv::TNvVidSrcInfo* TNVVidSrcInfoList::add_video_src_status() {
  return video_src_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNvVidSrcInfo >&
TNVVidSrcInfoList::video_src_status() const {
  return video_src_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNvVidSrcInfo >*
TNVVidSrcInfoList::mutable_video_src_status() {
  return &video_src_status_;
}

// -------------------------------------------------------------------

// TNVVidInPortResInfo

// optional .nv.EmNvVideoInPort video_port = 1;
inline bool TNVVidInPortResInfo::has_video_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVVidInPortResInfo::set_has_video_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVVidInPortResInfo::clear_has_video_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVVidInPortResInfo::clear_video_port() {
  video_port_ = 0;
  clear_has_video_port();
}
inline ::nv::EmNvVideoInPort TNVVidInPortResInfo::video_port() const {
  return static_cast< ::nv::EmNvVideoInPort >(video_port_);
}
inline void TNVVidInPortResInfo::set_video_port(::nv::EmNvVideoInPort value) {
  assert(::nv::EmNvVideoInPort_IsValid(value));
  set_has_video_port();
  video_port_ = value;
}

// optional uint32 video_width = 2;
inline bool TNVVidInPortResInfo::has_video_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVVidInPortResInfo::set_has_video_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVVidInPortResInfo::clear_has_video_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVVidInPortResInfo::clear_video_width() {
  video_width_ = 0u;
  clear_has_video_width();
}
inline ::google::protobuf::uint32 TNVVidInPortResInfo::video_width() const {
  return video_width_;
}
inline void TNVVidInPortResInfo::set_video_width(::google::protobuf::uint32 value) {
  set_has_video_width();
  video_width_ = value;
}

// optional uint32 video_height = 3;
inline bool TNVVidInPortResInfo::has_video_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVVidInPortResInfo::set_has_video_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVVidInPortResInfo::clear_has_video_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVVidInPortResInfo::clear_video_height() {
  video_height_ = 0u;
  clear_has_video_height();
}
inline ::google::protobuf::uint32 TNVVidInPortResInfo::video_height() const {
  return video_height_;
}
inline void TNVVidInPortResInfo::set_video_height(::google::protobuf::uint32 value) {
  set_has_video_height();
  video_height_ = value;
}

// optional bool video_progressive = 4;
inline bool TNVVidInPortResInfo::has_video_progressive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVVidInPortResInfo::set_has_video_progressive() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVVidInPortResInfo::clear_has_video_progressive() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVVidInPortResInfo::clear_video_progressive() {
  video_progressive_ = false;
  clear_has_video_progressive();
}
inline bool TNVVidInPortResInfo::video_progressive() const {
  return video_progressive_;
}
inline void TNVVidInPortResInfo::set_video_progressive(bool value) {
  set_has_video_progressive();
  video_progressive_ = value;
}

// optional uint32 frame_rate = 5;
inline bool TNVVidInPortResInfo::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVVidInPortResInfo::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVVidInPortResInfo::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVVidInPortResInfo::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TNVVidInPortResInfo::frame_rate() const {
  return frame_rate_;
}
inline void TNVVidInPortResInfo::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// optional bool has_src = 6;
inline bool TNVVidInPortResInfo::has_has_src() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVVidInPortResInfo::set_has_has_src() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVVidInPortResInfo::clear_has_has_src() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVVidInPortResInfo::clear_has_src() {
  has_src_ = false;
  clear_has_has_src();
}
inline bool TNVVidInPortResInfo::has_src() const {
  return has_src_;
}
inline void TNVVidInPortResInfo::set_has_src(bool value) {
  set_has_has_src();
  has_src_ = value;
}

// optional .nv.EmNvImixVidSrcType video_type = 7;
inline bool TNVVidInPortResInfo::has_video_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVVidInPortResInfo::set_has_video_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVVidInPortResInfo::clear_has_video_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVVidInPortResInfo::clear_video_type() {
  video_type_ = 0;
  clear_has_video_type();
}
inline ::nv::EmNvImixVidSrcType TNVVidInPortResInfo::video_type() const {
  return static_cast< ::nv::EmNvImixVidSrcType >(video_type_);
}
inline void TNVVidInPortResInfo::set_video_type(::nv::EmNvImixVidSrcType value) {
  assert(::nv::EmNvImixVidSrcType_IsValid(value));
  set_has_video_type();
  video_type_ = value;
}

// optional string vid_name = 8;
inline bool TNVVidInPortResInfo::has_vid_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVVidInPortResInfo::set_has_vid_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVVidInPortResInfo::clear_has_vid_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVVidInPortResInfo::clear_vid_name() {
  if (vid_name_ != &::google::protobuf::internal::kEmptyString) {
    vid_name_->clear();
  }
  clear_has_vid_name();
}
inline const ::std::string& TNVVidInPortResInfo::vid_name() const {
  return *vid_name_;
}
inline void TNVVidInPortResInfo::set_vid_name(const ::std::string& value) {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  vid_name_->assign(value);
}
inline void TNVVidInPortResInfo::set_vid_name(const char* value) {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  vid_name_->assign(value);
}
inline void TNVVidInPortResInfo::set_vid_name(const char* value, size_t size) {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  vid_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVVidInPortResInfo::mutable_vid_name() {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  return vid_name_;
}
inline ::std::string* TNVVidInPortResInfo::release_vid_name() {
  clear_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vid_name_;
    vid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVVidInPortResInfo::set_allocated_vid_name(::std::string* vid_name) {
  if (vid_name_ != &::google::protobuf::internal::kEmptyString) {
    delete vid_name_;
  }
  if (vid_name) {
    set_has_vid_name();
    vid_name_ = vid_name;
  } else {
    clear_has_vid_name();
    vid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVVidInPortResInfoList

// repeated .nv.TNVVidInPortResInfo video_inport_status = 1;
inline int TNVVidInPortResInfoList::video_inport_status_size() const {
  return video_inport_status_.size();
}
inline void TNVVidInPortResInfoList::clear_video_inport_status() {
  video_inport_status_.Clear();
}
inline const ::nv::TNVVidInPortResInfo& TNVVidInPortResInfoList::video_inport_status(int index) const {
  return video_inport_status_.Get(index);
}
inline ::nv::TNVVidInPortResInfo* TNVVidInPortResInfoList::mutable_video_inport_status(int index) {
  return video_inport_status_.Mutable(index);
}
inline ::nv::TNVVidInPortResInfo* TNVVidInPortResInfoList::add_video_inport_status() {
  return video_inport_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidInPortResInfo >&
TNVVidInPortResInfoList::video_inport_status() const {
  return video_inport_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidInPortResInfo >*
TNVVidInPortResInfoList::mutable_video_inport_status() {
  return &video_inport_status_;
}

// -------------------------------------------------------------------

// TNVChanAddr

// optional .nv.TNVNetAddr local_rtp = 1;
inline bool TNVChanAddr::has_local_rtp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVChanAddr::set_has_local_rtp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVChanAddr::clear_has_local_rtp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVChanAddr::clear_local_rtp() {
  if (local_rtp_ != NULL) local_rtp_->::nv::TNVNetAddr::Clear();
  clear_has_local_rtp();
}
inline const ::nv::TNVNetAddr& TNVChanAddr::local_rtp() const {
  return local_rtp_ != NULL ? *local_rtp_ : *default_instance_->local_rtp_;
}
inline ::nv::TNVNetAddr* TNVChanAddr::mutable_local_rtp() {
  set_has_local_rtp();
  if (local_rtp_ == NULL) local_rtp_ = new ::nv::TNVNetAddr;
  return local_rtp_;
}
inline ::nv::TNVNetAddr* TNVChanAddr::release_local_rtp() {
  clear_has_local_rtp();
  ::nv::TNVNetAddr* temp = local_rtp_;
  local_rtp_ = NULL;
  return temp;
}
inline void TNVChanAddr::set_allocated_local_rtp(::nv::TNVNetAddr* local_rtp) {
  delete local_rtp_;
  local_rtp_ = local_rtp;
  if (local_rtp) {
    set_has_local_rtp();
  } else {
    clear_has_local_rtp();
  }
}

// optional .nv.TNVNetAddr local_rtcp = 2;
inline bool TNVChanAddr::has_local_rtcp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVChanAddr::set_has_local_rtcp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVChanAddr::clear_has_local_rtcp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVChanAddr::clear_local_rtcp() {
  if (local_rtcp_ != NULL) local_rtcp_->::nv::TNVNetAddr::Clear();
  clear_has_local_rtcp();
}
inline const ::nv::TNVNetAddr& TNVChanAddr::local_rtcp() const {
  return local_rtcp_ != NULL ? *local_rtcp_ : *default_instance_->local_rtcp_;
}
inline ::nv::TNVNetAddr* TNVChanAddr::mutable_local_rtcp() {
  set_has_local_rtcp();
  if (local_rtcp_ == NULL) local_rtcp_ = new ::nv::TNVNetAddr;
  return local_rtcp_;
}
inline ::nv::TNVNetAddr* TNVChanAddr::release_local_rtcp() {
  clear_has_local_rtcp();
  ::nv::TNVNetAddr* temp = local_rtcp_;
  local_rtcp_ = NULL;
  return temp;
}
inline void TNVChanAddr::set_allocated_local_rtcp(::nv::TNVNetAddr* local_rtcp) {
  delete local_rtcp_;
  local_rtcp_ = local_rtcp;
  if (local_rtcp) {
    set_has_local_rtcp();
  } else {
    clear_has_local_rtcp();
  }
}

// optional .nv.TNVNetAddr peer_rtp = 3;
inline bool TNVChanAddr::has_peer_rtp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVChanAddr::set_has_peer_rtp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVChanAddr::clear_has_peer_rtp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVChanAddr::clear_peer_rtp() {
  if (peer_rtp_ != NULL) peer_rtp_->::nv::TNVNetAddr::Clear();
  clear_has_peer_rtp();
}
inline const ::nv::TNVNetAddr& TNVChanAddr::peer_rtp() const {
  return peer_rtp_ != NULL ? *peer_rtp_ : *default_instance_->peer_rtp_;
}
inline ::nv::TNVNetAddr* TNVChanAddr::mutable_peer_rtp() {
  set_has_peer_rtp();
  if (peer_rtp_ == NULL) peer_rtp_ = new ::nv::TNVNetAddr;
  return peer_rtp_;
}
inline ::nv::TNVNetAddr* TNVChanAddr::release_peer_rtp() {
  clear_has_peer_rtp();
  ::nv::TNVNetAddr* temp = peer_rtp_;
  peer_rtp_ = NULL;
  return temp;
}
inline void TNVChanAddr::set_allocated_peer_rtp(::nv::TNVNetAddr* peer_rtp) {
  delete peer_rtp_;
  peer_rtp_ = peer_rtp;
  if (peer_rtp) {
    set_has_peer_rtp();
  } else {
    clear_has_peer_rtp();
  }
}

// optional .nv.TNVNetAddr peer_rtcp = 4;
inline bool TNVChanAddr::has_peer_rtcp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVChanAddr::set_has_peer_rtcp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVChanAddr::clear_has_peer_rtcp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVChanAddr::clear_peer_rtcp() {
  if (peer_rtcp_ != NULL) peer_rtcp_->::nv::TNVNetAddr::Clear();
  clear_has_peer_rtcp();
}
inline const ::nv::TNVNetAddr& TNVChanAddr::peer_rtcp() const {
  return peer_rtcp_ != NULL ? *peer_rtcp_ : *default_instance_->peer_rtcp_;
}
inline ::nv::TNVNetAddr* TNVChanAddr::mutable_peer_rtcp() {
  set_has_peer_rtcp();
  if (peer_rtcp_ == NULL) peer_rtcp_ = new ::nv::TNVNetAddr;
  return peer_rtcp_;
}
inline ::nv::TNVNetAddr* TNVChanAddr::release_peer_rtcp() {
  clear_has_peer_rtcp();
  ::nv::TNVNetAddr* temp = peer_rtcp_;
  peer_rtcp_ = NULL;
  return temp;
}
inline void TNVChanAddr::set_allocated_peer_rtcp(::nv::TNVNetAddr* peer_rtcp) {
  delete peer_rtcp_;
  peer_rtcp_ = peer_rtcp;
  if (peer_rtcp) {
    set_has_peer_rtcp();
  } else {
    clear_has_peer_rtcp();
  }
}

// -------------------------------------------------------------------

// TNVAudInPower

// optional .nv.EmNvImixVidSrcType src_type = 1;
inline bool TNVAudInPower::has_src_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVAudInPower::set_has_src_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVAudInPower::clear_has_src_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVAudInPower::clear_src_type() {
  src_type_ = 0;
  clear_has_src_type();
}
inline ::nv::EmNvImixVidSrcType TNVAudInPower::src_type() const {
  return static_cast< ::nv::EmNvImixVidSrcType >(src_type_);
}
inline void TNVAudInPower::set_src_type(::nv::EmNvImixVidSrcType value) {
  assert(::nv::EmNvImixVidSrcType_IsValid(value));
  set_has_src_type();
  src_type_ = value;
}

// optional bool has_power = 2;
inline bool TNVAudInPower::has_has_power() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVAudInPower::set_has_has_power() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVAudInPower::clear_has_has_power() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVAudInPower::clear_has_power() {
  has_power_ = false;
  clear_has_has_power();
}
inline bool TNVAudInPower::has_power() const {
  return has_power_;
}
inline void TNVAudInPower::set_has_power(bool value) {
  set_has_has_power();
  has_power_ = value;
}

// optional string aud_name = 3;
inline bool TNVAudInPower::has_aud_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVAudInPower::set_has_aud_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVAudInPower::clear_has_aud_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVAudInPower::clear_aud_name() {
  if (aud_name_ != &::google::protobuf::internal::kEmptyString) {
    aud_name_->clear();
  }
  clear_has_aud_name();
}
inline const ::std::string& TNVAudInPower::aud_name() const {
  return *aud_name_;
}
inline void TNVAudInPower::set_aud_name(const ::std::string& value) {
  set_has_aud_name();
  if (aud_name_ == &::google::protobuf::internal::kEmptyString) {
    aud_name_ = new ::std::string;
  }
  aud_name_->assign(value);
}
inline void TNVAudInPower::set_aud_name(const char* value) {
  set_has_aud_name();
  if (aud_name_ == &::google::protobuf::internal::kEmptyString) {
    aud_name_ = new ::std::string;
  }
  aud_name_->assign(value);
}
inline void TNVAudInPower::set_aud_name(const char* value, size_t size) {
  set_has_aud_name();
  if (aud_name_ == &::google::protobuf::internal::kEmptyString) {
    aud_name_ = new ::std::string;
  }
  aud_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVAudInPower::mutable_aud_name() {
  set_has_aud_name();
  if (aud_name_ == &::google::protobuf::internal::kEmptyString) {
    aud_name_ = new ::std::string;
  }
  return aud_name_;
}
inline ::std::string* TNVAudInPower::release_aud_name() {
  clear_has_aud_name();
  if (aud_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = aud_name_;
    aud_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVAudInPower::set_allocated_aud_name(::std::string* aud_name) {
  if (aud_name_ != &::google::protobuf::internal::kEmptyString) {
    delete aud_name_;
  }
  if (aud_name) {
    set_has_aud_name();
    aud_name_ = aud_name;
  } else {
    clear_has_aud_name();
    aud_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVAudInPowerList

// repeated .nv.TNVAudInPower aud_In_Power = 1;
inline int TNVAudInPowerList::aud_in_power_size() const {
  return aud_in_power_.size();
}
inline void TNVAudInPowerList::clear_aud_in_power() {
  aud_in_power_.Clear();
}
inline const ::nv::TNVAudInPower& TNVAudInPowerList::aud_in_power(int index) const {
  return aud_in_power_.Get(index);
}
inline ::nv::TNVAudInPower* TNVAudInPowerList::mutable_aud_in_power(int index) {
  return aud_in_power_.Mutable(index);
}
inline ::nv::TNVAudInPower* TNVAudInPowerList::add_aud_in_power() {
  return aud_in_power_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVAudInPower >&
TNVAudInPowerList::aud_in_power() const {
  return aud_in_power_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVAudInPower >*
TNVAudInPowerList::mutable_aud_in_power() {
  return &aud_in_power_;
}

// -------------------------------------------------------------------

// TNVAudPort

// optional .nv.EmNvAudPortIn aud_in_port1 = 1;
inline bool TNVAudPort::has_aud_in_port1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVAudPort::set_has_aud_in_port1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVAudPort::clear_has_aud_in_port1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVAudPort::clear_aud_in_port1() {
  aud_in_port1_ = 0;
  clear_has_aud_in_port1();
}
inline ::nv::EmNvAudPortIn TNVAudPort::aud_in_port1() const {
  return static_cast< ::nv::EmNvAudPortIn >(aud_in_port1_);
}
inline void TNVAudPort::set_aud_in_port1(::nv::EmNvAudPortIn value) {
  assert(::nv::EmNvAudPortIn_IsValid(value));
  set_has_aud_in_port1();
  aud_in_port1_ = value;
}

// optional .nv.EmNvAudPortIn aud_in_port2 = 2;
inline bool TNVAudPort::has_aud_in_port2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVAudPort::set_has_aud_in_port2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVAudPort::clear_has_aud_in_port2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVAudPort::clear_aud_in_port2() {
  aud_in_port2_ = 0;
  clear_has_aud_in_port2();
}
inline ::nv::EmNvAudPortIn TNVAudPort::aud_in_port2() const {
  return static_cast< ::nv::EmNvAudPortIn >(aud_in_port2_);
}
inline void TNVAudPort::set_aud_in_port2(::nv::EmNvAudPortIn value) {
  assert(::nv::EmNvAudPortIn_IsValid(value));
  set_has_aud_in_port2();
  aud_in_port2_ = value;
}

// optional .nv.EmNvAudPortOut aud_out_port = 3;
inline bool TNVAudPort::has_aud_out_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVAudPort::set_has_aud_out_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVAudPort::clear_has_aud_out_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVAudPort::clear_aud_out_port() {
  aud_out_port_ = 0;
  clear_has_aud_out_port();
}
inline ::nv::EmNvAudPortOut TNVAudPort::aud_out_port() const {
  return static_cast< ::nv::EmNvAudPortOut >(aud_out_port_);
}
inline void TNVAudPort::set_aud_out_port(::nv::EmNvAudPortOut value) {
  assert(::nv::EmNvAudPortOut_IsValid(value));
  set_has_aud_out_port();
  aud_out_port_ = value;
}

// -------------------------------------------------------------------

// TNVVidFreezePrm

// optional .nv.EmNvVideoInPort vid_port = 1;
inline bool TNVVidFreezePrm::has_vid_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVVidFreezePrm::set_has_vid_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVVidFreezePrm::clear_has_vid_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVVidFreezePrm::clear_vid_port() {
  vid_port_ = 0;
  clear_has_vid_port();
}
inline ::nv::EmNvVideoInPort TNVVidFreezePrm::vid_port() const {
  return static_cast< ::nv::EmNvVideoInPort >(vid_port_);
}
inline void TNVVidFreezePrm::set_vid_port(::nv::EmNvVideoInPort value) {
  assert(::nv::EmNvVideoInPort_IsValid(value));
  set_has_vid_port();
  vid_port_ = value;
}

// optional uint32 freeze_mode = 2;
inline bool TNVVidFreezePrm::has_freeze_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVVidFreezePrm::set_has_freeze_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVVidFreezePrm::clear_has_freeze_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVVidFreezePrm::clear_freeze_mode() {
  freeze_mode_ = 0u;
  clear_has_freeze_mode();
}
inline ::google::protobuf::uint32 TNVVidFreezePrm::freeze_mode() const {
  return freeze_mode_;
}
inline void TNVVidFreezePrm::set_freeze_mode(::google::protobuf::uint32 value) {
  set_has_freeze_mode();
  freeze_mode_ = value;
}

// -------------------------------------------------------------------

// TNVVidPoint

// optional uint32 point_x = 1;
inline bool TNVVidPoint::has_point_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVVidPoint::set_has_point_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVVidPoint::clear_has_point_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVVidPoint::clear_point_x() {
  point_x_ = 0u;
  clear_has_point_x();
}
inline ::google::protobuf::uint32 TNVVidPoint::point_x() const {
  return point_x_;
}
inline void TNVVidPoint::set_point_x(::google::protobuf::uint32 value) {
  set_has_point_x();
  point_x_ = value;
}

// optional uint32 point_y = 2;
inline bool TNVVidPoint::has_point_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVVidPoint::set_has_point_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVVidPoint::clear_has_point_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVVidPoint::clear_point_y() {
  point_y_ = 0u;
  clear_has_point_y();
}
inline ::google::protobuf::uint32 TNVVidPoint::point_y() const {
  return point_y_;
}
inline void TNVVidPoint::set_point_y(::google::protobuf::uint32 value) {
  set_has_point_y();
  point_y_ = value;
}

// -------------------------------------------------------------------

// TNVVidLineOverlap

// optional uint32 line_en = 1;
inline bool TNVVidLineOverlap::has_line_en() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVVidLineOverlap::set_has_line_en() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVVidLineOverlap::clear_has_line_en() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVVidLineOverlap::clear_line_en() {
  line_en_ = 0u;
  clear_has_line_en();
}
inline ::google::protobuf::uint32 TNVVidLineOverlap::line_en() const {
  return line_en_;
}
inline void TNVVidLineOverlap::set_line_en(::google::protobuf::uint32 value) {
  set_has_line_en();
  line_en_ = value;
}

// optional uint32 color_y = 2;
inline bool TNVVidLineOverlap::has_color_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVVidLineOverlap::set_has_color_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVVidLineOverlap::clear_has_color_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVVidLineOverlap::clear_color_y() {
  color_y_ = 0u;
  clear_has_color_y();
}
inline ::google::protobuf::uint32 TNVVidLineOverlap::color_y() const {
  return color_y_;
}
inline void TNVVidLineOverlap::set_color_y(::google::protobuf::uint32 value) {
  set_has_color_y();
  color_y_ = value;
}

// optional uint32 color_u = 3;
inline bool TNVVidLineOverlap::has_color_u() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVVidLineOverlap::set_has_color_u() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVVidLineOverlap::clear_has_color_u() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVVidLineOverlap::clear_color_u() {
  color_u_ = 0u;
  clear_has_color_u();
}
inline ::google::protobuf::uint32 TNVVidLineOverlap::color_u() const {
  return color_u_;
}
inline void TNVVidLineOverlap::set_color_u(::google::protobuf::uint32 value) {
  set_has_color_u();
  color_u_ = value;
}

// optional uint32 color_v = 4;
inline bool TNVVidLineOverlap::has_color_v() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVVidLineOverlap::set_has_color_v() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVVidLineOverlap::clear_has_color_v() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVVidLineOverlap::clear_color_v() {
  color_v_ = 0u;
  clear_has_color_v();
}
inline ::google::protobuf::uint32 TNVVidLineOverlap::color_v() const {
  return color_v_;
}
inline void TNVVidLineOverlap::set_color_v(::google::protobuf::uint32 value) {
  set_has_color_v();
  color_v_ = value;
}

// repeated .nv.TNVVidPoint point = 5;
inline int TNVVidLineOverlap::point_size() const {
  return point_.size();
}
inline void TNVVidLineOverlap::clear_point() {
  point_.Clear();
}
inline const ::nv::TNVVidPoint& TNVVidLineOverlap::point(int index) const {
  return point_.Get(index);
}
inline ::nv::TNVVidPoint* TNVVidLineOverlap::mutable_point(int index) {
  return point_.Mutable(index);
}
inline ::nv::TNVVidPoint* TNVVidLineOverlap::add_point() {
  return point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidPoint >&
TNVVidLineOverlap::point() const {
  return point_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidPoint >*
TNVVidLineOverlap::mutable_point() {
  return &point_;
}

// -------------------------------------------------------------------

// TQKCodeParam

// optional uint32 vid_format = 1;
inline bool TQKCodeParam::has_vid_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TQKCodeParam::set_has_vid_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TQKCodeParam::clear_has_vid_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TQKCodeParam::clear_vid_format() {
  vid_format_ = 0u;
  clear_has_vid_format();
}
inline ::google::protobuf::uint32 TQKCodeParam::vid_format() const {
  return vid_format_;
}
inline void TQKCodeParam::set_vid_format(::google::protobuf::uint32 value) {
  set_has_vid_format();
  vid_format_ = value;
}

// optional uint32 aud_format = 2;
inline bool TQKCodeParam::has_aud_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TQKCodeParam::set_has_aud_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TQKCodeParam::clear_has_aud_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TQKCodeParam::clear_aud_format() {
  aud_format_ = 0u;
  clear_has_aud_format();
}
inline ::google::protobuf::uint32 TQKCodeParam::aud_format() const {
  return aud_format_;
}
inline void TQKCodeParam::set_aud_format(::google::protobuf::uint32 value) {
  set_has_aud_format();
  aud_format_ = value;
}

// optional .nv.EmQkCodeRes res_type = 3;
inline bool TQKCodeParam::has_res_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TQKCodeParam::set_has_res_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TQKCodeParam::clear_has_res_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TQKCodeParam::clear_res_type() {
  res_type_ = 0;
  clear_has_res_type();
}
inline ::nv::EmQkCodeRes TQKCodeParam::res_type() const {
  return static_cast< ::nv::EmQkCodeRes >(res_type_);
}
inline void TQKCodeParam::set_res_type(::nv::EmQkCodeRes value) {
  assert(::nv::EmQkCodeRes_IsValid(value));
  set_has_res_type();
  res_type_ = value;
}

// optional uint32 bit_rate = 4;
inline bool TQKCodeParam::has_bit_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TQKCodeParam::set_has_bit_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TQKCodeParam::clear_has_bit_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TQKCodeParam::clear_bit_rate() {
  bit_rate_ = 0u;
  clear_has_bit_rate();
}
inline ::google::protobuf::uint32 TQKCodeParam::bit_rate() const {
  return bit_rate_;
}
inline void TQKCodeParam::set_bit_rate(::google::protobuf::uint32 value) {
  set_has_bit_rate();
  bit_rate_ = value;
}

// optional uint32 frame_rate = 5;
inline bool TQKCodeParam::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TQKCodeParam::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TQKCodeParam::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TQKCodeParam::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TQKCodeParam::frame_rate() const {
  return frame_rate_;
}
inline void TQKCodeParam::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nv

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nvstructmp_2eproto__INCLUDED
