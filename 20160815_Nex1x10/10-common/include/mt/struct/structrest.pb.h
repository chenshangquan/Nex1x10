// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structrest.proto

#ifndef PROTOBUF_structrest_2eproto__INCLUDED
#define PROTOBUF_structrest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "enum.pb.h"
#include "structcommon.pb.h"
#include "structim.pb.h"
// @@protoc_insertion_point(includes)

namespace mt {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_structrest_2eproto();
void protobuf_AssignDesc_structrest_2eproto();
void protobuf_ShutdownFile_structrest_2eproto();

class TMTMeetingList;
class TMTBookingInfo;
class TMTMeetingListOfPerson;
class TVMeetingParam;
class TMTAddMeeting;
class TMTModifyMeeting;
class TMTModifyMeetingParticipants;
class TMTMeetingFeed;
class TMTQueryFreeRooms;
class TMTRecommendedVirtualRoom;
class TMTNormalRooms;
class TMTRoomListByName;
class TMTQueryRooms;
class TMTCreateMeetingNotify;
class TMTLockRoom;
class TMTLockRooms;
class TMTShortRoom;
class TMTRoomIDs;
class TMTShortMeeting;
class TMTShortRooms;
class TMTShortMeetings;
class TMTMeetingLists;
class TMTRoom;
class TMTRooms;
class TMTRoomList;
class TMTNormalRoomList;
class TMTRoomInfo;
class TMTTemplate;
class TMTTemplates;
class TMTTemplateList;
class TMTPerson;
class TMTPersons;
class TMTTemplateInfo;
class TMTMeetingIDs;
class TMTRegularInfo;
class TMTRegion;
class TMTRegions;
class TMTRoomLockResultItem;
class TMTRoomLockResultItems;
class TMeetingNotify;
class TMTWbParse_Keda_UserProfile;
class TMTWbParse_Keda_User;
class TMTWbParse_Keda_departmentUsers;
class TMTWbParse_Keda_Department;
class TMTWbParse_Keda_Departments;
class TMTWeiboLogin;
class TOauth;
class TMTWbParse_Keda_EntConfig;
class TMTWbParse_Keda_Result;
class TListNotifyByMax;
class TIfExistLockByFormkey;
class TAppClearNotify;
class TMeetingUnlock;
class TRegularFeed;
class TMTAddressBook;
class TMTAddressBooks;
class TDepartment;
class TMTConditionQuery;
class TMTQueryUser;
class TMTQueryPortrait;
class TMTSetAuthMode;
class TMTUserListByStr;
class TMTModifyBrief;
class TMTModifyPortrait;
class TMTWbParse_Keda_EntUsers;
class TMTWBParse_Keda_QueryUsers;
class TMTWbParse_Keda_SearchUsers;
class TMTRoomids;
class TMTVideoConferenceInfo;
class TMTConfInfoRooms;
class TMTConfInfoById;
class TMTParticipantInfo;
class TMTConfInfoParticipants;
class TMTRoomInfoById;
class TMTCommonConfInfo;
class TMTContentCreateMeeting;
class TMTContentUpdateMeeting;
class TMTContentOutMeeting;
class TMTContentNotStartMeeting;
class TMTContentDeadlineChanged;
class TMTContentRegularMeeting;
class TMTContentRegularId;
class TMTContentFeedback;
class TMTContentRoomId;
class TMTContentMeetingId;
class TMTContentStartMeeting;
class TRegularFeedAck;
class TAppGetAllNotifysAck;
class TAppGetAllNotifysAckList;
class TGetMonitorGroupVersionAck;
class TMTMonitorGroup;
class TMTMonitorGroups;
class TMTMonitorDevice;
class TMTMonitorDevices;
class TMTGetPerTemplateList;
class TMTTemplateAccount;
class TMTTemplateRecord;
class TMTTemplateSatellite;
class TMTDualFormatList;
class TMTSetMixInfo;
class TMTGetMixInfo;
class TMTVideoFormatList;
class TMTAudioFormatList;
class TMTTemplateMember;
class TMTTemplateMultiCast;
class TMTTemplateVmpMember;
class TMTTemplateVmp;
class TMTTemplatePoll;
class TMTPerTemplateSimpleInfo;
class TMTPerTemplateDetail;
class TMTPerTemplateList;
class TMTPerTemplateInfo;
class TMTPerTemplate;
class TMTGetPubTemplateList;
class TMTPubTemplateSimpleInfo;
class TMTPubTemplateList;
class TMTPubTemplateInfo;
class TMTPubTemplate;
class TMTCometdMessage;
class TMTCometdMessageList;
class TMTConfMixInfo;
class TMTConfMixBrief;
class TMTConfSatelliteInfo;
class TMTConfRecordInfo;
class TMTConfMultiCastInfo;
class TMTConfVMPInfo;
class TMTConfVMPBrief;
class TMTConfPollInfo;
class TMTRecordAttribute;
class TMTRecordAttributeBrief;
class TMTDCSAttribute;
class TMTInviteMember;
class TMTPeronalTemplate;
class TMTPersonalTemplateMember;
class TMTPersonalTemplatesList;
class TMTSimplePeronalTemplate;
class TMTPerInviteMemberList;
class TMTGetPerMixInfo;
class TMTGetPerVMPInfo;
class TMTGetPerPollInfo;
class TMTGetPerVIPInfo;
class TMTGetPerTemplateInfo;
class TMTCommonTemplate;
class TMTCommonTemplateMember;
class TMTCommonTemplatesList;
class TMTConfInitiator;
class TMTConferenceElement;
class TMTBookConferenceList;
class TMTInstantConfElement;
class TMTInstantConferenceList;
class TMTConditionOfConfList;
class TMTBookConferenceInfo;
class TMTInstantConference;
class TMTInstantConferenceInfo;
class TMTGetIntanceConfList;
class TMTRecordMembers;
class TMTStartRecord;
class TMTStopRecord;
class TMTRecordStateInfo;
class TMTModifyRecordState;
class TMTRecordListMember;
class TMTRecordList;
class TMTConfTerminalInfo;
class TMTConfTerminalList;
class TMTUserDomainInfo;
class TMTUserDomains;
class TMTUserDomainDepartmentInfo;
class TMTUserDomainDepartments;
class TMTPublicGroupInfo;
class TMTPublicGroups;
class TMTPublicGroupUserInfo;
class TMTPublicGroupUsers;
class TMTPushSrvReq;
class TMTPushSrvResult;
class TMTVConfMember;
class TMTCreateVConf;
class TMTVConfResult;
class TMTVConfListReq;
class TMTVConfInfo;
class TMTVConfList;
class TMTVConfResource;
class TMTVConfResources;
class TMTVConfRecord;
class TMTVConfDetailInfo;
class TMTVMtNameStyle;
class TMTContentLiveURL;

// ===================================================================

class MTMSG_API TMTMeetingList : public ::google::protobuf::Message {
 public:
  TMTMeetingList();
  virtual ~TMTMeetingList();

  TMTMeetingList(const TMTMeetingList& from);

  inline TMTMeetingList& operator=(const TMTMeetingList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMeetingList& default_instance();

  void Swap(TMTMeetingList* other);

  // implements Message ----------------------------------------------

  TMTMeetingList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMeetingList& from);
  void MergeFrom(const TMTMeetingList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string startday = 1;
  inline bool has_startday() const;
  inline void clear_startday();
  static const int kStartdayFieldNumber = 1;
  inline const ::std::string& startday() const;
  inline void set_startday(const ::std::string& value);
  inline void set_startday(const char* value);
  inline void set_startday(const char* value, size_t size);
  inline ::std::string* mutable_startday();
  inline ::std::string* release_startday();
  inline void set_allocated_startday(::std::string* startday);

  // optional string endday = 2;
  inline bool has_endday() const;
  inline void clear_endday();
  static const int kEnddayFieldNumber = 2;
  inline const ::std::string& endday() const;
  inline void set_endday(const ::std::string& value);
  inline void set_endday(const char* value);
  inline void set_endday(const char* value, size_t size);
  inline ::std::string* mutable_endday();
  inline ::std::string* release_endday();
  inline void set_allocated_endday(::std::string* endday);

  // optional bool isconfirm = 3;
  inline bool has_isconfirm() const;
  inline void clear_isconfirm();
  static const int kIsconfirmFieldNumber = 3;
  inline bool isconfirm() const;
  inline void set_isconfirm(bool value);

  // optional uint32 start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 6;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 6;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTMeetingList)
 private:
  inline void set_has_startday();
  inline void clear_has_startday();
  inline void set_has_endday();
  inline void clear_has_endday();
  inline void set_has_isconfirm();
  inline void clear_has_isconfirm();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* startday_;
  ::std::string* endday_;
  bool isconfirm_;
  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTMeetingList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTBookingInfo : public ::google::protobuf::Message {
 public:
  TMTBookingInfo();
  virtual ~TMTBookingInfo();

  TMTBookingInfo(const TMTBookingInfo& from);

  inline TMTBookingInfo& operator=(const TMTBookingInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTBookingInfo& default_instance();

  void Swap(TMTBookingInfo* other);

  // implements Message ----------------------------------------------

  TMTBookingInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTBookingInfo& from);
  void MergeFrom(const TMTBookingInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 meetingroomid = 1;
  inline bool has_meetingroomid() const;
  inline void clear_meetingroomid();
  static const int kMeetingroomidFieldNumber = 1;
  inline ::google::protobuf::uint32 meetingroomid() const;
  inline void set_meetingroomid(::google::protobuf::uint32 value);

  // optional string startday = 2;
  inline bool has_startday() const;
  inline void clear_startday();
  static const int kStartdayFieldNumber = 2;
  inline const ::std::string& startday() const;
  inline void set_startday(const ::std::string& value);
  inline void set_startday(const char* value);
  inline void set_startday(const char* value, size_t size);
  inline ::std::string* mutable_startday();
  inline ::std::string* release_startday();
  inline void set_allocated_startday(::std::string* startday);

  // optional string endday = 3;
  inline bool has_endday() const;
  inline void clear_endday();
  static const int kEnddayFieldNumber = 3;
  inline const ::std::string& endday() const;
  inline void set_endday(const ::std::string& value);
  inline void set_endday(const char* value);
  inline void set_endday(const char* value, size_t size);
  inline ::std::string* mutable_endday();
  inline ::std::string* release_endday();
  inline void set_allocated_endday(::std::string* endday);

  // optional uint32 start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 6;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 6;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTBookingInfo)
 private:
  inline void set_has_meetingroomid();
  inline void clear_has_meetingroomid();
  inline void set_has_startday();
  inline void clear_has_startday();
  inline void set_has_endday();
  inline void clear_has_endday();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* startday_;
  ::google::protobuf::uint32 meetingroomid_;
  ::google::protobuf::uint32 start_;
  ::std::string* endday_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTBookingInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMeetingListOfPerson : public ::google::protobuf::Message {
 public:
  TMTMeetingListOfPerson();
  virtual ~TMTMeetingListOfPerson();

  TMTMeetingListOfPerson(const TMTMeetingListOfPerson& from);

  inline TMTMeetingListOfPerson& operator=(const TMTMeetingListOfPerson& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMeetingListOfPerson& default_instance();

  void Swap(TMTMeetingListOfPerson* other);

  // implements Message ----------------------------------------------

  TMTMeetingListOfPerson* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMeetingListOfPerson& from);
  void MergeFrom(const TMTMeetingListOfPerson& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid = 1;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 1;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional string startday = 2;
  inline bool has_startday() const;
  inline void clear_startday();
  static const int kStartdayFieldNumber = 2;
  inline const ::std::string& startday() const;
  inline void set_startday(const ::std::string& value);
  inline void set_startday(const char* value);
  inline void set_startday(const char* value, size_t size);
  inline ::std::string* mutable_startday();
  inline ::std::string* release_startday();
  inline void set_allocated_startday(::std::string* startday);

  // optional string endday = 3;
  inline bool has_endday() const;
  inline void clear_endday();
  static const int kEnddayFieldNumber = 3;
  inline const ::std::string& endday() const;
  inline void set_endday(const ::std::string& value);
  inline void set_endday(const char* value);
  inline void set_endday(const char* value, size_t size);
  inline ::std::string* mutable_endday();
  inline ::std::string* release_endday();
  inline void set_allocated_endday(::std::string* endday);

  // optional uint32 start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 6;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 6;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTMeetingListOfPerson)
 private:
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_startday();
  inline void clear_has_startday();
  inline void set_has_endday();
  inline void clear_has_endday();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::std::string* startday_;
  ::std::string* endday_;
  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTMeetingListOfPerson* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVMeetingParam : public ::google::protobuf::Message {
 public:
  TVMeetingParam();
  virtual ~TVMeetingParam();

  TVMeetingParam(const TVMeetingParam& from);

  inline TVMeetingParam& operator=(const TVMeetingParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVMeetingParam& default_instance();

  void Swap(TVMeetingParam* other);

  // implements Message ----------------------------------------------

  TVMeetingParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVMeetingParam& from);
  void MergeFrom(const TVMeetingParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmClosedMeeting closedmeeting = 1;
  inline bool has_closedmeeting() const;
  inline void clear_closedmeeting();
  static const int kClosedmeetingFieldNumber = 1;
  inline ::mt::EmClosedMeeting closedmeeting() const;
  inline void set_closedmeeting(::mt::EmClosedMeeting value);

  // optional .mt.EmRestDualMode dualmode = 2;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 2;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional string encryptedkey = 3;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 3;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmEncryptArithmetic encryptedtype = 4;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 4;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional bool initmute = 5;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 5;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional .mt.EmMtOpenMode meetingsafe = 6;
  inline bool has_meetingsafe() const;
  inline void clear_meetingsafe();
  static const int kMeetingsafeFieldNumber = 6;
  inline ::mt::EmMtOpenMode meetingsafe() const;
  inline void set_meetingsafe(::mt::EmMtOpenMode value);

  // optional .mt.EmRestMeetingSafeType meetingtype = 7;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 7;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional uint32 meetingscale = 8;
  inline bool has_meetingscale() const;
  inline void clear_meetingscale();
  static const int kMeetingscaleFieldNumber = 8;
  inline ::google::protobuf::uint32 meetingscale() const;
  inline void set_meetingscale(::google::protobuf::uint32 value);

  // optional uint32 onereforming = 9;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOnereformingFieldNumber = 9;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional bool voiceinspireenable = 10;
  inline bool has_voiceinspireenable() const;
  inline void clear_voiceinspireenable();
  static const int kVoiceinspireenableFieldNumber = 10;
  inline bool voiceinspireenable() const;
  inline void set_voiceinspireenable(bool value);

  // optional uint32 voiceinspiretime = 11;
  inline bool has_voiceinspiretime() const;
  inline void clear_voiceinspiretime();
  static const int kVoiceinspiretimeFieldNumber = 11;
  inline ::google::protobuf::uint32 voiceinspiretime() const;
  inline void set_voiceinspiretime(::google::protobuf::uint32 value);

  // optional string password = 12;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 12;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional bool publicmeeting = 13;
  inline bool has_publicmeeting() const;
  inline void clear_publicmeeting();
  static const int kPublicmeetingFieldNumber = 13;
  inline bool publicmeeting() const;
  inline void set_publicmeeting(bool value);

  // repeated .mt.TMTTemplateAccount viplist = 14;
  inline int viplist_size() const;
  inline void clear_viplist();
  static const int kViplistFieldNumber = 14;
  inline const ::mt::TMTTemplateAccount& viplist(int index) const;
  inline ::mt::TMTTemplateAccount* mutable_viplist(int index);
  inline ::mt::TMTTemplateAccount* add_viplist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >&
      viplist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >*
      mutable_viplist();

  // optional .mt.TMTTemplateRecord record = 15;
  inline bool has_record() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 15;
  inline const ::mt::TMTTemplateRecord& record() const;
  inline ::mt::TMTTemplateRecord* mutable_record();
  inline ::mt::TMTTemplateRecord* release_record();
  inline void set_allocated_record(::mt::TMTTemplateRecord* record);

  // optional .mt.TMTTemplateSatellite satellite = 16;
  inline bool has_satellite() const;
  inline void clear_satellite();
  static const int kSatelliteFieldNumber = 16;
  inline const ::mt::TMTTemplateSatellite& satellite() const;
  inline ::mt::TMTTemplateSatellite* mutable_satellite();
  inline ::mt::TMTTemplateSatellite* release_satellite();
  inline void set_allocated_satellite(::mt::TMTTemplateSatellite* satellite);

  // optional .mt.TMTTemplateAccount speaker = 17;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 17;
  inline const ::mt::TMTTemplateAccount& speaker() const;
  inline ::mt::TMTTemplateAccount* mutable_speaker();
  inline ::mt::TMTTemplateAccount* release_speaker();
  inline void set_allocated_speaker(::mt::TMTTemplateAccount* speaker);

  // optional .mt.TMTTemplateAccount admin = 18;
  inline bool has_admin() const;
  inline void clear_admin();
  static const int kAdminFieldNumber = 18;
  inline const ::mt::TMTTemplateAccount& admin() const;
  inline ::mt::TMTTemplateAccount* mutable_admin();
  inline ::mt::TMTTemplateAccount* release_admin();
  inline void set_allocated_admin(::mt::TMTTemplateAccount* admin);

  // repeated .mt.TMTVideoFormatList videoformatlist = 19;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoformatlistFieldNumber = 19;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // repeated .mt.TMTDualFormatList dualformatlist = 20;
  inline int dualformatlist_size() const;
  inline void clear_dualformatlist();
  static const int kDualformatlistFieldNumber = 20;
  inline const ::mt::TMTDualFormatList& dualformatlist(int index) const;
  inline ::mt::TMTDualFormatList* mutable_dualformatlist(int index);
  inline ::mt::TMTDualFormatList* add_dualformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
      dualformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
      mutable_dualformatlist();

  // repeated .mt.TMTAudioFormatList audioformatlist = 21;
  inline int audioformatlist_size() const;
  inline void clear_audioformatlist();
  static const int kAudioformatlistFieldNumber = 21;
  inline const ::mt::TMTAudioFormatList& audioformatlist(int index) const;
  inline ::mt::TMTAudioFormatList* mutable_audioformatlist(int index);
  inline ::mt::TMTAudioFormatList* add_audioformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
      audioformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
      mutable_audioformatlist();

  // optional .mt.TMTSetMixInfo mixinfo = 22;
  inline bool has_mixinfo() const;
  inline void clear_mixinfo();
  static const int kMixinfoFieldNumber = 22;
  inline const ::mt::TMTSetMixInfo& mixinfo() const;
  inline ::mt::TMTSetMixInfo* mutable_mixinfo();
  inline ::mt::TMTSetMixInfo* release_mixinfo();
  inline void set_allocated_mixinfo(::mt::TMTSetMixInfo* mixinfo);

  // optional .mt.TMTTemplateVmp vmp = 23;
  inline bool has_vmp() const;
  inline void clear_vmp();
  static const int kVmpFieldNumber = 23;
  inline const ::mt::TMTTemplateVmp& vmp() const;
  inline ::mt::TMTTemplateVmp* mutable_vmp();
  inline ::mt::TMTTemplateVmp* release_vmp();
  inline void set_allocated_vmp(::mt::TMTTemplateVmp* vmp);

  // optional .mt.TMTTemplatePoll poll = 24;
  inline bool has_poll() const;
  inline void clear_poll();
  static const int kPollFieldNumber = 24;
  inline const ::mt::TMTTemplatePoll& poll() const;
  inline ::mt::TMTTemplatePoll* mutable_poll();
  inline ::mt::TMTTemplatePoll* release_poll();
  inline void set_allocated_poll(::mt::TMTTemplatePoll* poll);

  // @@protoc_insertion_point(class_scope:mt.TVMeetingParam)
 private:
  inline void set_has_closedmeeting();
  inline void clear_has_closedmeeting();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_meetingsafe();
  inline void clear_has_meetingsafe();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_meetingscale();
  inline void clear_has_meetingscale();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_voiceinspireenable();
  inline void clear_has_voiceinspireenable();
  inline void set_has_voiceinspiretime();
  inline void clear_has_voiceinspiretime();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_publicmeeting();
  inline void clear_has_publicmeeting();
  inline void set_has_record();
  inline void clear_has_record();
  inline void set_has_satellite();
  inline void clear_has_satellite();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_admin();
  inline void clear_has_admin();
  inline void set_has_mixinfo();
  inline void clear_has_mixinfo();
  inline void set_has_vmp();
  inline void clear_has_vmp();
  inline void set_has_poll();
  inline void clear_has_poll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int closedmeeting_;
  int dualmode_;
  ::std::string* encryptedkey_;
  int encryptedtype_;
  int meetingsafe_;
  int meetingtype_;
  ::google::protobuf::uint32 meetingscale_;
  ::google::protobuf::uint32 onereforming_;
  bool initmute_;
  bool voiceinspireenable_;
  bool publicmeeting_;
  ::std::string* password_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount > viplist_;
  ::mt::TMTTemplateRecord* record_;
  ::mt::TMTTemplateSatellite* satellite_;
  ::mt::TMTTemplateAccount* speaker_;
  ::mt::TMTTemplateAccount* admin_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList > dualformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList > audioformatlist_;
  ::mt::TMTSetMixInfo* mixinfo_;
  ::mt::TMTTemplateVmp* vmp_;
  ::mt::TMTTemplatePoll* poll_;
  ::google::protobuf::uint32 voiceinspiretime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TVMeetingParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAddMeeting : public ::google::protobuf::Message {
 public:
  TMTAddMeeting();
  virtual ~TMTAddMeeting();

  TMTAddMeeting(const TMTAddMeeting& from);

  inline TMTAddMeeting& operator=(const TMTAddMeeting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAddMeeting& default_instance();

  void Swap(TMTAddMeeting* other);

  // implements Message ----------------------------------------------

  TMTAddMeeting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAddMeeting& from);
  void MergeFrom(const TMTAddMeeting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string subject = 1;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 1;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string day = 2;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 2;
  inline const ::std::string& day() const;
  inline void set_day(const ::std::string& value);
  inline void set_day(const char* value);
  inline void set_day(const char* value, size_t size);
  inline ::std::string* mutable_day();
  inline ::std::string* release_day();
  inline void set_allocated_day(::std::string* day);

  // optional string startshorttime = 3;
  inline bool has_startshorttime() const;
  inline void clear_startshorttime();
  static const int kStartshorttimeFieldNumber = 3;
  inline const ::std::string& startshorttime() const;
  inline void set_startshorttime(const ::std::string& value);
  inline void set_startshorttime(const char* value);
  inline void set_startshorttime(const char* value, size_t size);
  inline ::std::string* mutable_startshorttime();
  inline ::std::string* release_startshorttime();
  inline void set_allocated_startshorttime(::std::string* startshorttime);

  // optional string endshorttime = 4;
  inline bool has_endshorttime() const;
  inline void clear_endshorttime();
  static const int kEndshorttimeFieldNumber = 4;
  inline const ::std::string& endshorttime() const;
  inline void set_endshorttime(const ::std::string& value);
  inline void set_endshorttime(const char* value);
  inline void set_endshorttime(const char* value, size_t size);
  inline ::std::string* mutable_endshorttime();
  inline ::std::string* release_endshorttime();
  inline void set_allocated_endshorttime(::std::string* endshorttime);

  // optional uint32 rooms = 5;
  inline bool has_rooms() const;
  inline void clear_rooms();
  static const int kRoomsFieldNumber = 5;
  inline ::google::protobuf::uint32 rooms() const;
  inline void set_rooms(::google::protobuf::uint32 value);

  // optional string phone = 6;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 6;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string mobile = 7;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 7;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  inline void set_allocated_mobile(::std::string* mobile);

  // optional uint32 participantcnt = 8;
  inline bool has_participantcnt() const;
  inline void clear_participantcnt();
  static const int kParticipantcntFieldNumber = 8;
  inline ::google::protobuf::uint32 participantcnt() const;
  inline void set_participantcnt(::google::protobuf::uint32 value);

  // repeated string participants = 9;
  inline int participants_size() const;
  inline void clear_participants();
  static const int kParticipantsFieldNumber = 9;
  inline const ::std::string& participants(int index) const;
  inline ::std::string* mutable_participants(int index);
  inline void set_participants(int index, const ::std::string& value);
  inline void set_participants(int index, const char* value);
  inline void set_participants(int index, const char* value, size_t size);
  inline ::std::string* add_participants();
  inline void add_participants(const ::std::string& value);
  inline void add_participants(const char* value);
  inline void add_participants(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& participants() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_participants();

  // optional string brief = 10;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 10;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // optional uint32 isvideomeeting = 11;
  inline bool has_isvideomeeting() const;
  inline void clear_isvideomeeting();
  static const int kIsvideomeetingFieldNumber = 11;
  inline ::google::protobuf::uint32 isvideomeeting() const;
  inline void set_isvideomeeting(::google::protobuf::uint32 value);

  // optional uint32 isautocall = 12;
  inline bool has_isautocall() const;
  inline void clear_isautocall();
  static const int kIsautocallFieldNumber = 12;
  inline ::google::protobuf::uint32 isautocall() const;
  inline void set_isautocall(::google::protobuf::uint32 value);

  // optional string templateid = 13;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateidFieldNumber = 13;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional uint32 vroomid = 14;
  inline bool has_vroomid() const;
  inline void clear_vroomid();
  static const int kVroomidFieldNumber = 14;
  inline ::google::protobuf::uint32 vroomid() const;
  inline void set_vroomid(::google::protobuf::uint32 value);

  // optional uint32 notifytype = 15;
  inline bool has_notifytype() const;
  inline void clear_notifytype();
  static const int kNotifytypeFieldNumber = 15;
  inline ::google::protobuf::uint32 notifytype() const;
  inline void set_notifytype(::google::protobuf::uint32 value);

  // optional string meetingformkey = 16;
  inline bool has_meetingformkey() const;
  inline void clear_meetingformkey();
  static const int kMeetingformkeyFieldNumber = 16;
  inline const ::std::string& meetingformkey() const;
  inline void set_meetingformkey(const ::std::string& value);
  inline void set_meetingformkey(const char* value);
  inline void set_meetingformkey(const char* value, size_t size);
  inline ::std::string* mutable_meetingformkey();
  inline ::std::string* release_meetingformkey();
  inline void set_allocated_meetingformkey(::std::string* meetingformkey);

  // optional bool issendsms = 17;
  inline bool has_issendsms() const;
  inline void clear_issendsms();
  static const int kIssendsmsFieldNumber = 17;
  inline bool issendsms() const;
  inline void set_issendsms(bool value);

  // optional .mt.TVMeetingParam vmeetingparam = 18;
  inline bool has_vmeetingparam() const;
  inline void clear_vmeetingparam();
  static const int kVmeetingparamFieldNumber = 18;
  inline const ::mt::TVMeetingParam& vmeetingparam() const;
  inline ::mt::TVMeetingParam* mutable_vmeetingparam();
  inline ::mt::TVMeetingParam* release_vmeetingparam();
  inline void set_allocated_vmeetingparam(::mt::TVMeetingParam* vmeetingparam);

  // @@protoc_insertion_point(class_scope:mt.TMTAddMeeting)
 private:
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_startshorttime();
  inline void clear_has_startshorttime();
  inline void set_has_endshorttime();
  inline void clear_has_endshorttime();
  inline void set_has_rooms();
  inline void clear_has_rooms();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_participantcnt();
  inline void clear_has_participantcnt();
  inline void set_has_brief();
  inline void clear_has_brief();
  inline void set_has_isvideomeeting();
  inline void clear_has_isvideomeeting();
  inline void set_has_isautocall();
  inline void clear_has_isautocall();
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_vroomid();
  inline void clear_has_vroomid();
  inline void set_has_notifytype();
  inline void clear_has_notifytype();
  inline void set_has_meetingformkey();
  inline void clear_has_meetingformkey();
  inline void set_has_issendsms();
  inline void clear_has_issendsms();
  inline void set_has_vmeetingparam();
  inline void clear_has_vmeetingparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subject_;
  ::std::string* day_;
  ::std::string* startshorttime_;
  ::std::string* endshorttime_;
  ::std::string* phone_;
  ::google::protobuf::uint32 rooms_;
  ::google::protobuf::uint32 participantcnt_;
  ::std::string* mobile_;
  ::google::protobuf::RepeatedPtrField< ::std::string> participants_;
  ::std::string* brief_;
  ::google::protobuf::uint32 isvideomeeting_;
  ::google::protobuf::uint32 isautocall_;
  ::std::string* templateid_;
  ::google::protobuf::uint32 vroomid_;
  ::google::protobuf::uint32 notifytype_;
  ::std::string* meetingformkey_;
  ::mt::TVMeetingParam* vmeetingparam_;
  bool issendsms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTAddMeeting* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTModifyMeeting : public ::google::protobuf::Message {
 public:
  TMTModifyMeeting();
  virtual ~TMTModifyMeeting();

  TMTModifyMeeting(const TMTModifyMeeting& from);

  inline TMTModifyMeeting& operator=(const TMTModifyMeeting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTModifyMeeting& default_instance();

  void Swap(TMTModifyMeeting* other);

  // implements Message ----------------------------------------------

  TMTModifyMeeting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTModifyMeeting& from);
  void MergeFrom(const TMTModifyMeeting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 meetingid = 1;
  inline bool has_meetingid() const;
  inline void clear_meetingid();
  static const int kMeetingidFieldNumber = 1;
  inline ::google::protobuf::uint32 meetingid() const;
  inline void set_meetingid(::google::protobuf::uint32 value);

  // optional string subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string day = 3;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline const ::std::string& day() const;
  inline void set_day(const ::std::string& value);
  inline void set_day(const char* value);
  inline void set_day(const char* value, size_t size);
  inline ::std::string* mutable_day();
  inline ::std::string* release_day();
  inline void set_allocated_day(::std::string* day);

  // optional string startshorttime = 4;
  inline bool has_startshorttime() const;
  inline void clear_startshorttime();
  static const int kStartshorttimeFieldNumber = 4;
  inline const ::std::string& startshorttime() const;
  inline void set_startshorttime(const ::std::string& value);
  inline void set_startshorttime(const char* value);
  inline void set_startshorttime(const char* value, size_t size);
  inline ::std::string* mutable_startshorttime();
  inline ::std::string* release_startshorttime();
  inline void set_allocated_startshorttime(::std::string* startshorttime);

  // optional string endshorttime = 5;
  inline bool has_endshorttime() const;
  inline void clear_endshorttime();
  static const int kEndshorttimeFieldNumber = 5;
  inline const ::std::string& endshorttime() const;
  inline void set_endshorttime(const ::std::string& value);
  inline void set_endshorttime(const char* value);
  inline void set_endshorttime(const char* value, size_t size);
  inline ::std::string* mutable_endshorttime();
  inline ::std::string* release_endshorttime();
  inline void set_allocated_endshorttime(::std::string* endshorttime);

  // optional uint32 rooms = 6;
  inline bool has_rooms() const;
  inline void clear_rooms();
  static const int kRoomsFieldNumber = 6;
  inline ::google::protobuf::uint32 rooms() const;
  inline void set_rooms(::google::protobuf::uint32 value);

  // optional string phone = 7;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 7;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string mobile = 8;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 8;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  inline void set_allocated_mobile(::std::string* mobile);

  // optional string brief = 9;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 9;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // optional uint32 isvideomeeting = 10;
  inline bool has_isvideomeeting() const;
  inline void clear_isvideomeeting();
  static const int kIsvideomeetingFieldNumber = 10;
  inline ::google::protobuf::uint32 isvideomeeting() const;
  inline void set_isvideomeeting(::google::protobuf::uint32 value);

  // optional uint32 isautocall = 11;
  inline bool has_isautocall() const;
  inline void clear_isautocall();
  static const int kIsautocallFieldNumber = 11;
  inline ::google::protobuf::uint32 isautocall() const;
  inline void set_isautocall(::google::protobuf::uint32 value);

  // optional string templateid = 12;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateidFieldNumber = 12;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional uint32 vroomId = 13;
  inline bool has_vroomid() const;
  inline void clear_vroomid();
  static const int kVroomIdFieldNumber = 13;
  inline ::google::protobuf::uint32 vroomid() const;
  inline void set_vroomid(::google::protobuf::uint32 value);

  // optional uint32 notifytype = 14;
  inline bool has_notifytype() const;
  inline void clear_notifytype();
  static const int kNotifytypeFieldNumber = 14;
  inline ::google::protobuf::uint32 notifytype() const;
  inline void set_notifytype(::google::protobuf::uint32 value);

  // optional string meetingformkey = 15;
  inline bool has_meetingformkey() const;
  inline void clear_meetingformkey();
  static const int kMeetingformkeyFieldNumber = 15;
  inline const ::std::string& meetingformkey() const;
  inline void set_meetingformkey(const ::std::string& value);
  inline void set_meetingformkey(const char* value);
  inline void set_meetingformkey(const char* value, size_t size);
  inline ::std::string* mutable_meetingformkey();
  inline ::std::string* release_meetingformkey();
  inline void set_allocated_meetingformkey(::std::string* meetingformkey);

  // optional bool isSendsms = 16;
  inline bool has_issendsms() const;
  inline void clear_issendsms();
  static const int kIsSendsmsFieldNumber = 16;
  inline bool issendsms() const;
  inline void set_issendsms(bool value);

  // optional .mt.TVMeetingParam vMeetingParam = 17;
  inline bool has_vmeetingparam() const;
  inline void clear_vmeetingparam();
  static const int kVMeetingParamFieldNumber = 17;
  inline const ::mt::TVMeetingParam& vmeetingparam() const;
  inline ::mt::TVMeetingParam* mutable_vmeetingparam();
  inline ::mt::TVMeetingParam* release_vmeetingparam();
  inline void set_allocated_vmeetingparam(::mt::TVMeetingParam* vmeetingparam);

  // @@protoc_insertion_point(class_scope:mt.TMTModifyMeeting)
 private:
  inline void set_has_meetingid();
  inline void clear_has_meetingid();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_startshorttime();
  inline void clear_has_startshorttime();
  inline void set_has_endshorttime();
  inline void clear_has_endshorttime();
  inline void set_has_rooms();
  inline void clear_has_rooms();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_brief();
  inline void clear_has_brief();
  inline void set_has_isvideomeeting();
  inline void clear_has_isvideomeeting();
  inline void set_has_isautocall();
  inline void clear_has_isautocall();
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_vroomid();
  inline void clear_has_vroomid();
  inline void set_has_notifytype();
  inline void clear_has_notifytype();
  inline void set_has_meetingformkey();
  inline void clear_has_meetingformkey();
  inline void set_has_issendsms();
  inline void clear_has_issendsms();
  inline void set_has_vmeetingparam();
  inline void clear_has_vmeetingparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subject_;
  ::std::string* day_;
  ::google::protobuf::uint32 meetingid_;
  ::google::protobuf::uint32 rooms_;
  ::std::string* startshorttime_;
  ::std::string* endshorttime_;
  ::std::string* phone_;
  ::std::string* mobile_;
  ::std::string* brief_;
  ::google::protobuf::uint32 isvideomeeting_;
  ::google::protobuf::uint32 isautocall_;
  ::std::string* templateid_;
  ::google::protobuf::uint32 vroomid_;
  ::google::protobuf::uint32 notifytype_;
  ::std::string* meetingformkey_;
  ::mt::TVMeetingParam* vmeetingparam_;
  bool issendsms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTModifyMeeting* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTModifyMeetingParticipants : public ::google::protobuf::Message {
 public:
  TMTModifyMeetingParticipants();
  virtual ~TMTModifyMeetingParticipants();

  TMTModifyMeetingParticipants(const TMTModifyMeetingParticipants& from);

  inline TMTModifyMeetingParticipants& operator=(const TMTModifyMeetingParticipants& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTModifyMeetingParticipants& default_instance();

  void Swap(TMTModifyMeetingParticipants* other);

  // implements Message ----------------------------------------------

  TMTModifyMeetingParticipants* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTModifyMeetingParticipants& from);
  void MergeFrom(const TMTModifyMeetingParticipants& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string participants = 1;
  inline int participants_size() const;
  inline void clear_participants();
  static const int kParticipantsFieldNumber = 1;
  inline const ::std::string& participants(int index) const;
  inline ::std::string* mutable_participants(int index);
  inline void set_participants(int index, const ::std::string& value);
  inline void set_participants(int index, const char* value);
  inline void set_participants(int index, const char* value, size_t size);
  inline ::std::string* add_participants();
  inline void add_participants(const ::std::string& value);
  inline void add_participants(const char* value);
  inline void add_participants(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& participants() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_participants();

  // @@protoc_insertion_point(class_scope:mt.TMTModifyMeetingParticipants)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> participants_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTModifyMeetingParticipants* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMeetingFeed : public ::google::protobuf::Message {
 public:
  TMTMeetingFeed();
  virtual ~TMTMeetingFeed();

  TMTMeetingFeed(const TMTMeetingFeed& from);

  inline TMTMeetingFeed& operator=(const TMTMeetingFeed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMeetingFeed& default_instance();

  void Swap(TMTMeetingFeed* other);

  // implements Message ----------------------------------------------

  TMTMeetingFeed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMeetingFeed& from);
  void MergeFrom(const TMTMeetingFeed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 meetingid = 1;
  inline bool has_meetingid() const;
  inline void clear_meetingid();
  static const int kMeetingidFieldNumber = 1;
  inline ::google::protobuf::uint32 meetingid() const;
  inline void set_meetingid(::google::protobuf::uint32 value);

  // optional uint32 accept = 2;
  inline bool has_accept() const;
  inline void clear_accept();
  static const int kAcceptFieldNumber = 2;
  inline ::google::protobuf::uint32 accept() const;
  inline void set_accept(::google::protobuf::uint32 value);

  // optional uint32 jointype = 3;
  inline bool has_jointype() const;
  inline void clear_jointype();
  static const int kJointypeFieldNumber = 3;
  inline ::google::protobuf::uint32 jointype() const;
  inline void set_jointype(::google::protobuf::uint32 value);

  // optional string participateno = 4;
  inline bool has_participateno() const;
  inline void clear_participateno();
  static const int kParticipatenoFieldNumber = 4;
  inline const ::std::string& participateno() const;
  inline void set_participateno(const ::std::string& value);
  inline void set_participateno(const char* value);
  inline void set_participateno(const char* value, size_t size);
  inline ::std::string* mutable_participateno();
  inline ::std::string* release_participateno();
  inline void set_allocated_participateno(::std::string* participateno);

  // optional uint32 reasonid = 5;
  inline bool has_reasonid() const;
  inline void clear_reasonid();
  static const int kReasonidFieldNumber = 5;
  inline ::google::protobuf::uint32 reasonid() const;
  inline void set_reasonid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTMeetingFeed)
 private:
  inline void set_has_meetingid();
  inline void clear_has_meetingid();
  inline void set_has_accept();
  inline void clear_has_accept();
  inline void set_has_jointype();
  inline void clear_has_jointype();
  inline void set_has_participateno();
  inline void clear_has_participateno();
  inline void set_has_reasonid();
  inline void clear_has_reasonid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 meetingid_;
  ::google::protobuf::uint32 accept_;
  ::std::string* participateno_;
  ::google::protobuf::uint32 jointype_;
  ::google::protobuf::uint32 reasonid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTMeetingFeed* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTQueryFreeRooms : public ::google::protobuf::Message {
 public:
  TMTQueryFreeRooms();
  virtual ~TMTQueryFreeRooms();

  TMTQueryFreeRooms(const TMTQueryFreeRooms& from);

  inline TMTQueryFreeRooms& operator=(const TMTQueryFreeRooms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTQueryFreeRooms& default_instance();

  void Swap(TMTQueryFreeRooms* other);

  // implements Message ----------------------------------------------

  TMTQueryFreeRooms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTQueryFreeRooms& from);
  void MergeFrom(const TMTQueryFreeRooms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string starttime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 1;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // repeated uint32 rooms = 2;
  inline int rooms_size() const;
  inline void clear_rooms();
  static const int kRoomsFieldNumber = 2;
  inline ::google::protobuf::uint32 rooms(int index) const;
  inline void set_rooms(int index, ::google::protobuf::uint32 value);
  inline void add_rooms(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      rooms() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_rooms();

  // optional string endtime = 3;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 3;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional uint32 start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 6;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 6;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // optional uint32 peopleadmint = 7;
  inline bool has_peopleadmint() const;
  inline void clear_peopleadmint();
  static const int kPeopleadmintFieldNumber = 7;
  inline ::google::protobuf::uint32 peopleadmint() const;
  inline void set_peopleadmint(::google::protobuf::uint32 value);

  // optional uint32 deviceidmask = 8;
  inline bool has_deviceidmask() const;
  inline void clear_deviceidmask();
  static const int kDeviceidmaskFieldNumber = 8;
  inline ::google::protobuf::uint32 deviceidmask() const;
  inline void set_deviceidmask(::google::protobuf::uint32 value);

  // repeated uint32 regionids = 9;
  inline int regionids_size() const;
  inline void clear_regionids();
  static const int kRegionidsFieldNumber = 9;
  inline ::google::protobuf::uint32 regionids(int index) const;
  inline void set_regionids(int index, ::google::protobuf::uint32 value);
  inline void add_regionids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      regionids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_regionids();

  // @@protoc_insertion_point(class_scope:mt.TMTQueryFreeRooms)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_peopleadmint();
  inline void clear_has_peopleadmint();
  inline void set_has_deviceidmask();
  inline void clear_has_deviceidmask();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* starttime_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > rooms_;
  ::std::string* endtime_;
  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 order_;
  ::google::protobuf::uint32 peopleadmint_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > regionids_;
  ::google::protobuf::uint32 deviceidmask_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTQueryFreeRooms* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRecommendedVirtualRoom : public ::google::protobuf::Message {
 public:
  TMTRecommendedVirtualRoom();
  virtual ~TMTRecommendedVirtualRoom();

  TMTRecommendedVirtualRoom(const TMTRecommendedVirtualRoom& from);

  inline TMTRecommendedVirtualRoom& operator=(const TMTRecommendedVirtualRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRecommendedVirtualRoom& default_instance();

  void Swap(TMTRecommendedVirtualRoom* other);

  // implements Message ----------------------------------------------

  TMTRecommendedVirtualRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRecommendedVirtualRoom& from);
  void MergeFrom(const TMTRecommendedVirtualRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string starttime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 1;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 2;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // @@protoc_insertion_point(class_scope:mt.TMTRecommendedVirtualRoom)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* starttime_;
  ::std::string* endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRecommendedVirtualRoom* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTNormalRooms : public ::google::protobuf::Message {
 public:
  TMTNormalRooms();
  virtual ~TMTNormalRooms();

  TMTNormalRooms(const TMTNormalRooms& from);

  inline TMTNormalRooms& operator=(const TMTNormalRooms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTNormalRooms& default_instance();

  void Swap(TMTNormalRooms* other);

  // implements Message ----------------------------------------------

  TMTNormalRooms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTNormalRooms& from);
  void MergeFrom(const TMTNormalRooms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 3;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 3;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTNormalRooms)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTNormalRooms* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRoomListByName : public ::google::protobuf::Message {
 public:
  TMTRoomListByName();
  virtual ~TMTRoomListByName();

  TMTRoomListByName(const TMTRoomListByName& from);

  inline TMTRoomListByName& operator=(const TMTRoomListByName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRoomListByName& default_instance();

  void Swap(TMTRoomListByName* other);

  // implements Message ----------------------------------------------

  TMTRoomListByName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRoomListByName& from);
  void MergeFrom(const TMTRoomListByName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 3;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 3;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:mt.TMTRoomListByName)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;
  ::std::string* name_;
  ::google::protobuf::uint32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRoomListByName* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTQueryRooms : public ::google::protobuf::Message {
 public:
  TMTQueryRooms();
  virtual ~TMTQueryRooms();

  TMTQueryRooms(const TMTQueryRooms& from);

  inline TMTQueryRooms& operator=(const TMTQueryRooms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTQueryRooms& default_instance();

  void Swap(TMTQueryRooms* other);

  // implements Message ----------------------------------------------

  TMTQueryRooms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTQueryRooms& from);
  void MergeFrom(const TMTQueryRooms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 3;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 3;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // optional uint32 peopleadmit = 4;
  inline bool has_peopleadmit() const;
  inline void clear_peopleadmit();
  static const int kPeopleadmitFieldNumber = 4;
  inline ::google::protobuf::uint32 peopleadmit() const;
  inline void set_peopleadmit(::google::protobuf::uint32 value);

  // optional uint32 deviceidmask = 5;
  inline bool has_deviceidmask() const;
  inline void clear_deviceidmask();
  static const int kDeviceidmaskFieldNumber = 5;
  inline ::google::protobuf::uint32 deviceidmask() const;
  inline void set_deviceidmask(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTQueryRooms)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_peopleadmit();
  inline void clear_has_peopleadmit();
  inline void set_has_deviceidmask();
  inline void clear_has_deviceidmask();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 order_;
  ::google::protobuf::uint32 peopleadmit_;
  ::google::protobuf::uint32 deviceidmask_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTQueryRooms* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCreateMeetingNotify : public ::google::protobuf::Message {
 public:
  TMTCreateMeetingNotify();
  virtual ~TMTCreateMeetingNotify();

  TMTCreateMeetingNotify(const TMTCreateMeetingNotify& from);

  inline TMTCreateMeetingNotify& operator=(const TMTCreateMeetingNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCreateMeetingNotify& default_instance();

  void Swap(TMTCreateMeetingNotify* other);

  // implements Message ----------------------------------------------

  TMTCreateMeetingNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCreateMeetingNotify& from);
  void MergeFrom(const TMTCreateMeetingNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 notifymask = 2;
  inline bool has_notifymask() const;
  inline void clear_notifymask();
  static const int kNotifymaskFieldNumber = 2;
  inline ::google::protobuf::uint32 notifymask() const;
  inline void set_notifymask(::google::protobuf::uint32 value);

  // optional uint32 titletype = 3;
  inline bool has_titletype() const;
  inline void clear_titletype();
  static const int kTitletypeFieldNumber = 3;
  inline ::google::protobuf::uint32 titletype() const;
  inline void set_titletype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTCreateMeetingNotify)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_notifymask();
  inline void clear_has_notifymask();
  inline void set_has_titletype();
  inline void clear_has_titletype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 notifymask_;
  ::google::protobuf::uint32 titletype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTCreateMeetingNotify* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTLockRoom : public ::google::protobuf::Message {
 public:
  TMTLockRoom();
  virtual ~TMTLockRoom();

  TMTLockRoom(const TMTLockRoom& from);

  inline TMTLockRoom& operator=(const TMTLockRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTLockRoom& default_instance();

  void Swap(TMTLockRoom* other);

  // implements Message ----------------------------------------------

  TMTLockRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTLockRoom& from);
  void MergeFrom(const TMTLockRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 roomid = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional string starttime = 2;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 2;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 3;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 3;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // @@protoc_insertion_point(class_scope:mt.TMTLockRoom)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* starttime_;
  ::std::string* endtime_;
  ::google::protobuf::uint32 roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTLockRoom* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTLockRooms : public ::google::protobuf::Message {
 public:
  TMTLockRooms();
  virtual ~TMTLockRooms();

  TMTLockRooms(const TMTLockRooms& from);

  inline TMTLockRooms& operator=(const TMTLockRooms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTLockRooms& default_instance();

  void Swap(TMTLockRooms* other);

  // implements Message ----------------------------------------------

  TMTLockRooms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTLockRooms& from);
  void MergeFrom(const TMTLockRooms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 roomids = 1;
  inline int roomids_size() const;
  inline void clear_roomids();
  static const int kRoomidsFieldNumber = 1;
  inline ::google::protobuf::uint32 roomids(int index) const;
  inline void set_roomids(int index, ::google::protobuf::uint32 value);
  inline void add_roomids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      roomids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_roomids();

  // optional uint32 roomidscnt = 2;
  inline bool has_roomidscnt() const;
  inline void clear_roomidscnt();
  static const int kRoomidscntFieldNumber = 2;
  inline ::google::protobuf::uint32 roomidscnt() const;
  inline void set_roomidscnt(::google::protobuf::uint32 value);

  // optional string starttime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 3;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 4;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // @@protoc_insertion_point(class_scope:mt.TMTLockRooms)
 private:
  inline void set_has_roomidscnt();
  inline void clear_has_roomidscnt();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > roomids_;
  ::std::string* starttime_;
  ::std::string* endtime_;
  ::google::protobuf::uint32 roomidscnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTLockRooms* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTShortRoom : public ::google::protobuf::Message {
 public:
  TMTShortRoom();
  virtual ~TMTShortRoom();

  TMTShortRoom(const TMTShortRoom& from);

  inline TMTShortRoom& operator=(const TMTShortRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTShortRoom& default_instance();

  void Swap(TMTShortRoom* other);

  // implements Message ----------------------------------------------

  TMTShortRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTShortRoom& from);
  void MergeFrom(const TMTShortRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string regionname = 3;
  inline bool has_regionname() const;
  inline void clear_regionname();
  static const int kRegionnameFieldNumber = 3;
  inline const ::std::string& regionname() const;
  inline void set_regionname(const ::std::string& value);
  inline void set_regionname(const char* value);
  inline void set_regionname(const char* value, size_t size);
  inline ::std::string* mutable_regionname();
  inline ::std::string* release_regionname();
  inline void set_allocated_regionname(::std::string* regionname);

  // @@protoc_insertion_point(class_scope:mt.TMTShortRoom)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_regionname();
  inline void clear_has_regionname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* regionname_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTShortRoom* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRoomIDs : public ::google::protobuf::Message {
 public:
  TMTRoomIDs();
  virtual ~TMTRoomIDs();

  TMTRoomIDs(const TMTRoomIDs& from);

  inline TMTRoomIDs& operator=(const TMTRoomIDs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRoomIDs& default_instance();

  void Swap(TMTRoomIDs* other);

  // implements Message ----------------------------------------------

  TMTRoomIDs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRoomIDs& from);
  void MergeFrom(const TMTRoomIDs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated uint32 items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline ::google::protobuf::uint32 items(int index) const;
  inline void set_items(int index, ::google::protobuf::uint32 value);
  inline void add_items(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      items() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:mt.TMTRoomIDs)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > items_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRoomIDs* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTShortMeeting : public ::google::protobuf::Message {
 public:
  TMTShortMeeting();
  virtual ~TMTShortMeeting();

  TMTShortMeeting(const TMTShortMeeting& from);

  inline TMTShortMeeting& operator=(const TMTShortMeeting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTShortMeeting& default_instance();

  void Swap(TMTShortMeeting* other);

  // implements Message ----------------------------------------------

  TMTShortMeeting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTShortMeeting& from);
  void MergeFrom(const TMTShortMeeting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string starttime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 3;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 4;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional string organizermoid = 5;
  inline bool has_organizermoid() const;
  inline void clear_organizermoid();
  static const int kOrganizermoidFieldNumber = 5;
  inline const ::std::string& organizermoid() const;
  inline void set_organizermoid(const ::std::string& value);
  inline void set_organizermoid(const char* value);
  inline void set_organizermoid(const char* value, size_t size);
  inline ::std::string* mutable_organizermoid();
  inline ::std::string* release_organizermoid();
  inline void set_allocated_organizermoid(::std::string* organizermoid);

  // optional uint32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 isvideomeeting = 7;
  inline bool has_isvideomeeting() const;
  inline void clear_isvideomeeting();
  static const int kIsvideomeetingFieldNumber = 7;
  inline ::google::protobuf::uint32 isvideomeeting() const;
  inline void set_isvideomeeting(::google::protobuf::uint32 value);

  // optional .mt.EmParticipantResponse feedbackStatus = 8;
  inline bool has_feedbackstatus() const;
  inline void clear_feedbackstatus();
  static const int kFeedbackStatusFieldNumber = 8;
  inline ::mt::EmParticipantResponse feedbackstatus() const;
  inline void set_feedbackstatus(::mt::EmParticipantResponse value);

  // optional uint32 regularid = 9;
  inline bool has_regularid() const;
  inline void clear_regularid();
  static const int kRegularidFieldNumber = 9;
  inline ::google::protobuf::uint32 regularid() const;
  inline void set_regularid(::google::protobuf::uint32 value);

  // optional .mt.TMTRoomIDs room_ids = 10;
  inline bool has_room_ids() const;
  inline void clear_room_ids();
  static const int kRoomIdsFieldNumber = 10;
  inline const ::mt::TMTRoomIDs& room_ids() const;
  inline ::mt::TMTRoomIDs* mutable_room_ids();
  inline ::mt::TMTRoomIDs* release_room_ids();
  inline void set_allocated_room_ids(::mt::TMTRoomIDs* room_ids);

  // @@protoc_insertion_point(class_scope:mt.TMTShortMeeting)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_organizermoid();
  inline void clear_has_organizermoid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_isvideomeeting();
  inline void clear_has_isvideomeeting();
  inline void set_has_feedbackstatus();
  inline void clear_has_feedbackstatus();
  inline void set_has_regularid();
  inline void clear_has_regularid();
  inline void set_has_room_ids();
  inline void clear_has_room_ids();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subject_;
  ::std::string* starttime_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 status_;
  ::std::string* endtime_;
  ::std::string* organizermoid_;
  ::google::protobuf::uint32 isvideomeeting_;
  int feedbackstatus_;
  ::mt::TMTRoomIDs* room_ids_;
  ::google::protobuf::uint32 regularid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTShortMeeting* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTShortRooms : public ::google::protobuf::Message {
 public:
  TMTShortRooms();
  virtual ~TMTShortRooms();

  TMTShortRooms(const TMTShortRooms& from);

  inline TMTShortRooms& operator=(const TMTShortRooms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTShortRooms& default_instance();

  void Swap(TMTShortRooms* other);

  // implements Message ----------------------------------------------

  TMTShortRooms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTShortRooms& from);
  void MergeFrom(const TMTShortRooms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTShortRoom items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::mt::TMTShortRoom& items(int index) const;
  inline ::mt::TMTShortRoom* mutable_items(int index);
  inline ::mt::TMTShortRoom* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTShortRoom >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTShortRoom >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:mt.TMTShortRooms)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTShortRoom > items_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTShortRooms* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTShortMeetings : public ::google::protobuf::Message {
 public:
  TMTShortMeetings();
  virtual ~TMTShortMeetings();

  TMTShortMeetings(const TMTShortMeetings& from);

  inline TMTShortMeetings& operator=(const TMTShortMeetings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTShortMeetings& default_instance();

  void Swap(TMTShortMeetings* other);

  // implements Message ----------------------------------------------

  TMTShortMeetings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTShortMeetings& from);
  void MergeFrom(const TMTShortMeetings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTShortMeeting items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::mt::TMTShortMeeting& items(int index) const;
  inline ::mt::TMTShortMeeting* mutable_items(int index);
  inline ::mt::TMTShortMeeting* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTShortMeeting >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTShortMeeting >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:mt.TMTShortMeetings)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTShortMeeting > items_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTShortMeetings* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMeetingLists : public ::google::protobuf::Message {
 public:
  TMTMeetingLists();
  virtual ~TMTMeetingLists();

  TMTMeetingLists(const TMTMeetingLists& from);

  inline TMTMeetingLists& operator=(const TMTMeetingLists& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMeetingLists& default_instance();

  void Swap(TMTMeetingLists* other);

  // implements Message ----------------------------------------------

  TMTMeetingLists* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMeetingLists& from);
  void MergeFrom(const TMTMeetingLists& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMTShortRooms related_rooms = 1;
  inline bool has_related_rooms() const;
  inline void clear_related_rooms();
  static const int kRelatedRoomsFieldNumber = 1;
  inline const ::mt::TMTShortRooms& related_rooms() const;
  inline ::mt::TMTShortRooms* mutable_related_rooms();
  inline ::mt::TMTShortRooms* release_related_rooms();
  inline void set_allocated_related_rooms(::mt::TMTShortRooms* related_rooms);

  // optional .mt.TMTShortMeetings meetings = 2;
  inline bool has_meetings() const;
  inline void clear_meetings();
  static const int kMeetingsFieldNumber = 2;
  inline const ::mt::TMTShortMeetings& meetings() const;
  inline ::mt::TMTShortMeetings* mutable_meetings();
  inline ::mt::TMTShortMeetings* release_meetings();
  inline void set_allocated_meetings(::mt::TMTShortMeetings* meetings);

  // @@protoc_insertion_point(class_scope:mt.TMTMeetingLists)
 private:
  inline void set_has_related_rooms();
  inline void clear_has_related_rooms();
  inline void set_has_meetings();
  inline void clear_has_meetings();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTShortRooms* related_rooms_;
  ::mt::TMTShortMeetings* meetings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTMeetingLists* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRoom : public ::google::protobuf::Message {
 public:
  TMTRoom();
  virtual ~TMTRoom();

  TMTRoom(const TMTRoom& from);

  inline TMTRoom& operator=(const TMTRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRoom& default_instance();

  void Swap(TMTRoom* other);

  // implements Message ----------------------------------------------

  TMTRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRoom& from);
  void MergeFrom(const TMTRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string regionname = 3;
  inline bool has_regionname() const;
  inline void clear_regionname();
  static const int kRegionnameFieldNumber = 3;
  inline const ::std::string& regionname() const;
  inline void set_regionname(const ::std::string& value);
  inline void set_regionname(const char* value);
  inline void set_regionname(const char* value, size_t size);
  inline ::std::string* mutable_regionname();
  inline ::std::string* release_regionname();
  inline void set_allocated_regionname(::std::string* regionname);

  // optional string starttime = 4;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 4;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 5;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 5;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional uint32 peopleadmit = 6;
  inline bool has_peopleadmit() const;
  inline void clear_peopleadmit();
  static const int kPeopleadmitFieldNumber = 6;
  inline ::google::protobuf::uint32 peopleadmit() const;
  inline void set_peopleadmit(::google::protobuf::uint32 value);

  // optional uint32 devicemask = 7;
  inline bool has_devicemask() const;
  inline void clear_devicemask();
  static const int kDevicemaskFieldNumber = 7;
  inline ::google::protobuf::uint32 devicemask() const;
  inline void set_devicemask(::google::protobuf::uint32 value);

  // optional uint32 regionid = 8;
  inline bool has_regionid() const;
  inline void clear_regionid();
  static const int kRegionidFieldNumber = 8;
  inline ::google::protobuf::uint32 regionid() const;
  inline void set_regionid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTRoom)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_regionname();
  inline void clear_has_regionname();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_peopleadmit();
  inline void clear_has_peopleadmit();
  inline void set_has_devicemask();
  inline void clear_has_devicemask();
  inline void set_has_regionid();
  inline void clear_has_regionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* regionname_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 peopleadmit_;
  ::std::string* starttime_;
  ::std::string* endtime_;
  ::google::protobuf::uint32 devicemask_;
  ::google::protobuf::uint32 regionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRoom* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRooms : public ::google::protobuf::Message {
 public:
  TMTRooms();
  virtual ~TMTRooms();

  TMTRooms(const TMTRooms& from);

  inline TMTRooms& operator=(const TMTRooms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRooms& default_instance();

  void Swap(TMTRooms* other);

  // implements Message ----------------------------------------------

  TMTRooms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRooms& from);
  void MergeFrom(const TMTRooms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTRoom items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::mt::TMTRoom& items(int index) const;
  inline ::mt::TMTRoom* mutable_items(int index);
  inline ::mt::TMTRoom* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRoom >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRoom >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:mt.TMTRooms)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTRoom > items_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRooms* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRoomList : public ::google::protobuf::Message {
 public:
  TMTRoomList();
  virtual ~TMTRoomList();

  TMTRoomList(const TMTRoomList& from);

  inline TMTRoomList& operator=(const TMTRoomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRoomList& default_instance();

  void Swap(TMTRoomList* other);

  // implements Message ----------------------------------------------

  TMTRoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRoomList& from);
  void MergeFrom(const TMTRoomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMTRooms rooms = 1;
  inline bool has_rooms() const;
  inline void clear_rooms();
  static const int kRoomsFieldNumber = 1;
  inline const ::mt::TMTRooms& rooms() const;
  inline ::mt::TMTRooms* mutable_rooms();
  inline ::mt::TMTRooms* release_rooms();
  inline void set_allocated_rooms(::mt::TMTRooms* rooms);

  // optional uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTRoomList)
 private:
  inline void set_has_rooms();
  inline void clear_has_rooms();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTRooms* rooms_;
  ::google::protobuf::uint32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRoomList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTNormalRoomList : public ::google::protobuf::Message {
 public:
  TMTNormalRoomList();
  virtual ~TMTNormalRoomList();

  TMTNormalRoomList(const TMTNormalRoomList& from);

  inline TMTNormalRoomList& operator=(const TMTNormalRoomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTNormalRoomList& default_instance();

  void Swap(TMTNormalRoomList* other);

  // implements Message ----------------------------------------------

  TMTNormalRoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTNormalRoomList& from);
  void MergeFrom(const TMTNormalRoomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional .mt.TMTShortRooms rooms = 3;
  inline bool has_rooms() const;
  inline void clear_rooms();
  static const int kRoomsFieldNumber = 3;
  inline const ::mt::TMTShortRooms& rooms() const;
  inline ::mt::TMTShortRooms* mutable_rooms();
  inline ::mt::TMTShortRooms* release_rooms();
  inline void set_allocated_rooms(::mt::TMTShortRooms* rooms);

  // @@protoc_insertion_point(class_scope:mt.TMTNormalRoomList)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_rooms();
  inline void clear_has_rooms();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;
  ::mt::TMTShortRooms* rooms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTNormalRoomList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRoomInfo : public ::google::protobuf::Message {
 public:
  TMTRoomInfo();
  virtual ~TMTRoomInfo();

  TMTRoomInfo(const TMTRoomInfo& from);

  inline TMTRoomInfo& operator=(const TMTRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRoomInfo& default_instance();

  void Swap(TMTRoomInfo* other);

  // implements Message ----------------------------------------------

  TMTRoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRoomInfo& from);
  void MergeFrom(const TMTRoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string regionname = 3;
  inline bool has_regionname() const;
  inline void clear_regionname();
  static const int kRegionnameFieldNumber = 3;
  inline const ::std::string& regionname() const;
  inline void set_regionname(const ::std::string& value);
  inline void set_regionname(const char* value);
  inline void set_regionname(const char* value, size_t size);
  inline ::std::string* mutable_regionname();
  inline ::std::string* release_regionname();
  inline void set_allocated_regionname(::std::string* regionname);

  // @@protoc_insertion_point(class_scope:mt.TMTRoomInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_regionname();
  inline void clear_has_regionname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* regionname_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplate : public ::google::protobuf::Message {
 public:
  TMTTemplate();
  virtual ~TMTTemplate();

  TMTTemplate(const TMTTemplate& from);

  inline TMTTemplate& operator=(const TMTTemplate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplate& default_instance();

  void Swap(TMTTemplate* other);

  // implements Message ----------------------------------------------

  TMTTemplate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplate& from);
  void MergeFrom(const TMTTemplate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:mt.TMTTemplate)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplate* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplates : public ::google::protobuf::Message {
 public:
  TMTTemplates();
  virtual ~TMTTemplates();

  TMTTemplates(const TMTTemplates& from);

  inline TMTTemplates& operator=(const TMTTemplates& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplates& default_instance();

  void Swap(TMTTemplates* other);

  // implements Message ----------------------------------------------

  TMTTemplates* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplates& from);
  void MergeFrom(const TMTTemplates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTTemplate items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::mt::TMTTemplate& items(int index) const;
  inline ::mt::TMTTemplate* mutable_items(int index);
  inline ::mt::TMTTemplate* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplate >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplate >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:mt.TMTTemplates)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplate > items_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplates* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplateList : public ::google::protobuf::Message {
 public:
  TMTTemplateList();
  virtual ~TMTTemplateList();

  TMTTemplateList(const TMTTemplateList& from);

  inline TMTTemplateList& operator=(const TMTTemplateList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplateList& default_instance();

  void Swap(TMTTemplateList* other);

  // implements Message ----------------------------------------------

  TMTTemplateList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplateList& from);
  void MergeFrom(const TMTTemplateList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMTTemplates templates = 1;
  inline bool has_templates() const;
  inline void clear_templates();
  static const int kTemplatesFieldNumber = 1;
  inline const ::mt::TMTTemplates& templates() const;
  inline ::mt::TMTTemplates* mutable_templates();
  inline ::mt::TMTTemplates* release_templates();
  inline void set_allocated_templates(::mt::TMTTemplates* templates);

  // @@protoc_insertion_point(class_scope:mt.TMTTemplateList)
 private:
  inline void set_has_templates();
  inline void clear_has_templates();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTTemplates* templates_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplateList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPerson : public ::google::protobuf::Message {
 public:
  TMTPerson();
  virtual ~TMTPerson();

  TMTPerson(const TMTPerson& from);

  inline TMTPerson& operator=(const TMTPerson& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPerson& default_instance();

  void Swap(TMTPerson* other);

  // implements Message ----------------------------------------------

  TMTPerson* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPerson& from);
  void MergeFrom(const TMTPerson& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid = 1;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 1;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional string email = 2;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 2;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string participantno = 4;
  inline bool has_participantno() const;
  inline void clear_participantno();
  static const int kParticipantnoFieldNumber = 4;
  inline const ::std::string& participantno() const;
  inline void set_participantno(const ::std::string& value);
  inline void set_participantno(const char* value);
  inline void set_participantno(const char* value, size_t size);
  inline ::std::string* mutable_participantno();
  inline ::std::string* release_participantno();
  inline void set_allocated_participantno(::std::string* participantno);

  // optional uint32 isparticipant = 5;
  inline bool has_isparticipant() const;
  inline void clear_isparticipant();
  static const int kIsparticipantFieldNumber = 5;
  inline ::google::protobuf::uint32 isparticipant() const;
  inline void set_isparticipant(::google::protobuf::uint32 value);

  // optional uint32 participanttype = 6;
  inline bool has_participanttype() const;
  inline void clear_participanttype();
  static const int kParticipanttypeFieldNumber = 6;
  inline ::google::protobuf::uint32 participanttype() const;
  inline void set_participanttype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTPerson)
 private:
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_participantno();
  inline void clear_has_participantno();
  inline void set_has_isparticipant();
  inline void clear_has_isparticipant();
  inline void set_has_participanttype();
  inline void clear_has_participanttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::std::string* email_;
  ::std::string* name_;
  ::std::string* participantno_;
  ::google::protobuf::uint32 isparticipant_;
  ::google::protobuf::uint32 participanttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPerson* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPersons : public ::google::protobuf::Message {
 public:
  TMTPersons();
  virtual ~TMTPersons();

  TMTPersons(const TMTPersons& from);

  inline TMTPersons& operator=(const TMTPersons& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPersons& default_instance();

  void Swap(TMTPersons* other);

  // implements Message ----------------------------------------------

  TMTPersons* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPersons& from);
  void MergeFrom(const TMTPersons& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTPerson items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::mt::TMTPerson& items(int index) const;
  inline ::mt::TMTPerson* mutable_items(int index);
  inline ::mt::TMTPerson* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPerson >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPerson >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:mt.TMTPersons)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTPerson > items_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPersons* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplateInfo : public ::google::protobuf::Message {
 public:
  TMTTemplateInfo();
  virtual ~TMTTemplateInfo();

  TMTTemplateInfo(const TMTTemplateInfo& from);

  inline TMTTemplateInfo& operator=(const TMTTemplateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplateInfo& default_instance();

  void Swap(TMTTemplateInfo* other);

  // implements Message ----------------------------------------------

  TMTTemplateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplateInfo& from);
  void MergeFrom(const TMTTemplateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string resolution = 3;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 3;
  inline const ::std::string& resolution() const;
  inline void set_resolution(const ::std::string& value);
  inline void set_resolution(const char* value);
  inline void set_resolution(const char* value, size_t size);
  inline ::std::string* mutable_resolution();
  inline ::std::string* release_resolution();
  inline void set_allocated_resolution(::std::string* resolution);

  // optional string bandwith = 4;
  inline bool has_bandwith() const;
  inline void clear_bandwith();
  static const int kBandwithFieldNumber = 4;
  inline const ::std::string& bandwith() const;
  inline void set_bandwith(const ::std::string& value);
  inline void set_bandwith(const char* value);
  inline void set_bandwith(const char* value, size_t size);
  inline ::std::string* mutable_bandwith();
  inline ::std::string* release_bandwith();
  inline void set_allocated_bandwith(::std::string* bandwith);

  // optional .mt.TMTPersons persons = 5;
  inline bool has_persons() const;
  inline void clear_persons();
  static const int kPersonsFieldNumber = 5;
  inline const ::mt::TMTPersons& persons() const;
  inline ::mt::TMTPersons* mutable_persons();
  inline ::mt::TMTPersons* release_persons();
  inline void set_allocated_persons(::mt::TMTPersons* persons);

  // @@protoc_insertion_point(class_scope:mt.TMTTemplateInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_bandwith();
  inline void clear_has_bandwith();
  inline void set_has_persons();
  inline void clear_has_persons();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::std::string* resolution_;
  ::std::string* bandwith_;
  ::mt::TMTPersons* persons_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplateInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMeetingIDs : public ::google::protobuf::Message {
 public:
  TMTMeetingIDs();
  virtual ~TMTMeetingIDs();

  TMTMeetingIDs(const TMTMeetingIDs& from);

  inline TMTMeetingIDs& operator=(const TMTMeetingIDs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMeetingIDs& default_instance();

  void Swap(TMTMeetingIDs* other);

  // implements Message ----------------------------------------------

  TMTMeetingIDs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMeetingIDs& from);
  void MergeFrom(const TMTMeetingIDs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated uint32 items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline ::google::protobuf::uint32 items(int index) const;
  inline void set_items(int index, ::google::protobuf::uint32 value);
  inline void add_items(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      items() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:mt.TMTMeetingIDs)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > items_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTMeetingIDs* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRegularInfo : public ::google::protobuf::Message {
 public:
  TMTRegularInfo();
  virtual ~TMTRegularInfo();

  TMTRegularInfo(const TMTRegularInfo& from);

  inline TMTRegularInfo& operator=(const TMTRegularInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRegularInfo& default_instance();

  void Swap(TMTRegularInfo* other);

  // implements Message ----------------------------------------------

  TMTRegularInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRegularInfo& from);
  void MergeFrom(const TMTRegularInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string starttime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 3;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 4;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional uint32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional string organizer = 6;
  inline bool has_organizer() const;
  inline void clear_organizer();
  static const int kOrganizerFieldNumber = 6;
  inline const ::std::string& organizer() const;
  inline void set_organizer(const ::std::string& value);
  inline void set_organizer(const char* value);
  inline void set_organizer(const char* value, size_t size);
  inline ::std::string* mutable_organizer();
  inline ::std::string* release_organizer();
  inline void set_allocated_organizer(::std::string* organizer);

  // optional string organizermail = 7;
  inline bool has_organizermail() const;
  inline void clear_organizermail();
  static const int kOrganizermailFieldNumber = 7;
  inline const ::std::string& organizermail() const;
  inline void set_organizermail(const ::std::string& value);
  inline void set_organizermail(const char* value);
  inline void set_organizermail(const char* value, size_t size);
  inline ::std::string* mutable_organizermail();
  inline ::std::string* release_organizermail();
  inline void set_allocated_organizermail(::std::string* organizermail);

  // optional string phone = 8;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 8;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string mobile = 9;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 9;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  inline void set_allocated_mobile(::std::string* mobile);

  // optional string brief = 10;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 10;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // optional uint32 isvideo = 11;
  inline bool has_isvideo() const;
  inline void clear_isvideo();
  static const int kIsvideoFieldNumber = 11;
  inline ::google::protobuf::uint32 isvideo() const;
  inline void set_isvideo(::google::protobuf::uint32 value);

  // optional string startdate = 12;
  inline bool has_startdate() const;
  inline void clear_startdate();
  static const int kStartdateFieldNumber = 12;
  inline const ::std::string& startdate() const;
  inline void set_startdate(const ::std::string& value);
  inline void set_startdate(const char* value);
  inline void set_startdate(const char* value, size_t size);
  inline ::std::string* mutable_startdate();
  inline ::std::string* release_startdate();
  inline void set_allocated_startdate(::std::string* startdate);

  // optional string enddate = 13;
  inline bool has_enddate() const;
  inline void clear_enddate();
  static const int kEnddateFieldNumber = 13;
  inline const ::std::string& enddate() const;
  inline void set_enddate(const ::std::string& value);
  inline void set_enddate(const char* value);
  inline void set_enddate(const char* value, size_t size);
  inline ::std::string* mutable_enddate();
  inline ::std::string* release_enddate();
  inline void set_allocated_enddate(::std::string* enddate);

  // optional uint32 repeattype = 14;
  inline bool has_repeattype() const;
  inline void clear_repeattype();
  static const int kRepeattypeFieldNumber = 14;
  inline ::google::protobuf::uint32 repeattype() const;
  inline void set_repeattype(::google::protobuf::uint32 value);

  // optional uint32 frequency = 15;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 15;
  inline ::google::protobuf::uint32 frequency() const;
  inline void set_frequency(::google::protobuf::uint32 value);

  // optional string weekdays = 16;
  inline bool has_weekdays() const;
  inline void clear_weekdays();
  static const int kWeekdaysFieldNumber = 16;
  inline const ::std::string& weekdays() const;
  inline void set_weekdays(const ::std::string& value);
  inline void set_weekdays(const char* value);
  inline void set_weekdays(const char* value, size_t size);
  inline ::std::string* mutable_weekdays();
  inline ::std::string* release_weekdays();
  inline void set_allocated_weekdays(::std::string* weekdays);

  // optional .mt.TMTMeetingIDs meeting_ids = 17;
  inline bool has_meeting_ids() const;
  inline void clear_meeting_ids();
  static const int kMeetingIdsFieldNumber = 17;
  inline const ::mt::TMTMeetingIDs& meeting_ids() const;
  inline ::mt::TMTMeetingIDs* mutable_meeting_ids();
  inline ::mt::TMTMeetingIDs* release_meeting_ids();
  inline void set_allocated_meeting_ids(::mt::TMTMeetingIDs* meeting_ids);

  // @@protoc_insertion_point(class_scope:mt.TMTRegularInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_organizer();
  inline void clear_has_organizer();
  inline void set_has_organizermail();
  inline void clear_has_organizermail();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_brief();
  inline void clear_has_brief();
  inline void set_has_isvideo();
  inline void clear_has_isvideo();
  inline void set_has_startdate();
  inline void clear_has_startdate();
  inline void set_has_enddate();
  inline void clear_has_enddate();
  inline void set_has_repeattype();
  inline void clear_has_repeattype();
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_weekdays();
  inline void clear_has_weekdays();
  inline void set_has_meeting_ids();
  inline void clear_has_meeting_ids();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subject_;
  ::std::string* starttime_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 status_;
  ::std::string* endtime_;
  ::std::string* organizer_;
  ::std::string* organizermail_;
  ::std::string* phone_;
  ::std::string* mobile_;
  ::std::string* brief_;
  ::std::string* startdate_;
  ::google::protobuf::uint32 isvideo_;
  ::google::protobuf::uint32 repeattype_;
  ::std::string* enddate_;
  ::std::string* weekdays_;
  ::mt::TMTMeetingIDs* meeting_ids_;
  ::google::protobuf::uint32 frequency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRegularInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRegion : public ::google::protobuf::Message {
 public:
  TMTRegion();
  virtual ~TMTRegion();

  TMTRegion(const TMTRegion& from);

  inline TMTRegion& operator=(const TMTRegion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRegion& default_instance();

  void Swap(TMTRegion* other);

  // implements Message ----------------------------------------------

  TMTRegion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRegion& from);
  void MergeFrom(const TMTRegion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:mt.TMTRegion)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRegion* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRegions : public ::google::protobuf::Message {
 public:
  TMTRegions();
  virtual ~TMTRegions();

  TMTRegions(const TMTRegions& from);

  inline TMTRegions& operator=(const TMTRegions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRegions& default_instance();

  void Swap(TMTRegions* other);

  // implements Message ----------------------------------------------

  TMTRegions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRegions& from);
  void MergeFrom(const TMTRegions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTRegion items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::mt::TMTRegion& items(int index) const;
  inline ::mt::TMTRegion* mutable_items(int index);
  inline ::mt::TMTRegion* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRegion >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRegion >*
      mutable_items();

  // optional string companyid = 3;
  inline bool has_companyid() const;
  inline void clear_companyid();
  static const int kCompanyidFieldNumber = 3;
  inline const ::std::string& companyid() const;
  inline void set_companyid(const ::std::string& value);
  inline void set_companyid(const char* value);
  inline void set_companyid(const char* value, size_t size);
  inline ::std::string* mutable_companyid();
  inline ::std::string* release_companyid();
  inline void set_allocated_companyid(::std::string* companyid);

  // @@protoc_insertion_point(class_scope:mt.TMTRegions)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_companyid();
  inline void clear_has_companyid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTRegion > items_;
  ::std::string* companyid_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRegions* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRoomLockResultItem : public ::google::protobuf::Message {
 public:
  TMTRoomLockResultItem();
  virtual ~TMTRoomLockResultItem();

  TMTRoomLockResultItem(const TMTRoomLockResultItem& from);

  inline TMTRoomLockResultItem& operator=(const TMTRoomLockResultItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRoomLockResultItem& default_instance();

  void Swap(TMTRoomLockResultItem* other);

  // implements Message ----------------------------------------------

  TMTRoomLockResultItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRoomLockResultItem& from);
  void MergeFrom(const TMTRoomLockResultItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTRoomLockResultItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRoomLockResultItem* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRoomLockResultItems : public ::google::protobuf::Message {
 public:
  TMTRoomLockResultItems();
  virtual ~TMTRoomLockResultItems();

  TMTRoomLockResultItems(const TMTRoomLockResultItems& from);

  inline TMTRoomLockResultItems& operator=(const TMTRoomLockResultItems& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRoomLockResultItems& default_instance();

  void Swap(TMTRoomLockResultItems* other);

  // implements Message ----------------------------------------------

  TMTRoomLockResultItems* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRoomLockResultItems& from);
  void MergeFrom(const TMTRoomLockResultItems& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTRoomLockResultItem items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::mt::TMTRoomLockResultItem& items(int index) const;
  inline ::mt::TMTRoomLockResultItem* mutable_items(int index);
  inline ::mt::TMTRoomLockResultItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRoomLockResultItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRoomLockResultItem >*
      mutable_items();

  // optional uint32 success = 3;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 3;
  inline ::google::protobuf::uint32 success() const;
  inline void set_success(::google::protobuf::uint32 value);

  // optional string meetingformkey = 4;
  inline bool has_meetingformkey() const;
  inline void clear_meetingformkey();
  static const int kMeetingformkeyFieldNumber = 4;
  inline const ::std::string& meetingformkey() const;
  inline void set_meetingformkey(const ::std::string& value);
  inline void set_meetingformkey(const char* value);
  inline void set_meetingformkey(const char* value, size_t size);
  inline ::std::string* mutable_meetingformkey();
  inline ::std::string* release_meetingformkey();
  inline void set_allocated_meetingformkey(::std::string* meetingformkey);

  // optional string starttime = 5;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 5;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 6;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 6;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // @@protoc_insertion_point(class_scope:mt.TMTRoomLockResultItems)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_meetingformkey();
  inline void clear_has_meetingformkey();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTRoomLockResultItem > items_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 success_;
  ::std::string* meetingformkey_;
  ::std::string* starttime_;
  ::std::string* endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRoomLockResultItems* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMeetingNotify : public ::google::protobuf::Message {
 public:
  TMeetingNotify();
  virtual ~TMeetingNotify();

  TMeetingNotify(const TMeetingNotify& from);

  inline TMeetingNotify& operator=(const TMeetingNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMeetingNotify& default_instance();

  void Swap(TMeetingNotify* other);

  // implements Message ----------------------------------------------

  TMeetingNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMeetingNotify& from);
  void MergeFrom(const TMeetingNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmRestMeetingNotifyType notifytype = 1;
  inline bool has_notifytype() const;
  inline void clear_notifytype();
  static const int kNotifytypeFieldNumber = 1;
  inline ::mt::EmRestMeetingNotifyType notifytype() const;
  inline void set_notifytype(::mt::EmRestMeetingNotifyType value);

  // optional string moid = 2;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 2;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional uint32 notifyid = 3;
  inline bool has_notifyid() const;
  inline void clear_notifyid();
  static const int kNotifyidFieldNumber = 3;
  inline ::google::protobuf::uint32 notifyid() const;
  inline void set_notifyid(::google::protobuf::uint32 value);

  // optional uint32 num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMeetingNotify)
 private:
  inline void set_has_notifytype();
  inline void clear_has_notifytype();
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_notifyid();
  inline void clear_has_notifyid();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  int notifytype_;
  ::google::protobuf::uint32 notifyid_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMeetingNotify* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParse_Keda_UserProfile : public ::google::protobuf::Message {
 public:
  TMTWbParse_Keda_UserProfile();
  virtual ~TMTWbParse_Keda_UserProfile();

  TMTWbParse_Keda_UserProfile(const TMTWbParse_Keda_UserProfile& from);

  inline TMTWbParse_Keda_UserProfile& operator=(const TMTWbParse_Keda_UserProfile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParse_Keda_UserProfile& default_instance();

  void Swap(TMTWbParse_Keda_UserProfile* other);

  // implements Message ----------------------------------------------

  TMTWbParse_Keda_UserProfile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParse_Keda_UserProfile& from);
  void MergeFrom(const TMTWbParse_Keda_UserProfile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string jobtitle = 2;
  inline bool has_jobtitle() const;
  inline void clear_jobtitle();
  static const int kJobtitleFieldNumber = 2;
  inline const ::std::string& jobtitle() const;
  inline void set_jobtitle(const ::std::string& value);
  inline void set_jobtitle(const char* value);
  inline void set_jobtitle(const char* value, size_t size);
  inline ::std::string* mutable_jobtitle();
  inline ::std::string* release_jobtitle();
  inline void set_allocated_jobtitle(::std::string* jobtitle);

  // optional string location = 3;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 3;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional string workphone = 4;
  inline bool has_workphone() const;
  inline void clear_workphone();
  static const int kWorkphoneFieldNumber = 4;
  inline const ::std::string& workphone() const;
  inline void set_workphone(const ::std::string& value);
  inline void set_workphone(const char* value);
  inline void set_workphone(const char* value, size_t size);
  inline ::std::string* mutable_workphone();
  inline ::std::string* release_workphone();
  inline void set_allocated_workphone(::std::string* workphone);

  // optional string mobilephone = 5;
  inline bool has_mobilephone() const;
  inline void clear_mobilephone();
  static const int kMobilephoneFieldNumber = 5;
  inline const ::std::string& mobilephone() const;
  inline void set_mobilephone(const ::std::string& value);
  inline void set_mobilephone(const char* value);
  inline void set_mobilephone(const char* value, size_t size);
  inline ::std::string* mutable_mobilephone();
  inline ::std::string* release_mobilephone();
  inline void set_allocated_mobilephone(::std::string* mobilephone);

  // @@protoc_insertion_point(class_scope:mt.TMTWbParse_Keda_UserProfile)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_jobtitle();
  inline void clear_has_jobtitle();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_workphone();
  inline void clear_has_workphone();
  inline void set_has_mobilephone();
  inline void clear_has_mobilephone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* jobtitle_;
  ::std::string* location_;
  ::std::string* workphone_;
  ::std::string* mobilephone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParse_Keda_UserProfile* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParse_Keda_User : public ::google::protobuf::Message {
 public:
  TMTWbParse_Keda_User();
  virtual ~TMTWbParse_Keda_User();

  TMTWbParse_Keda_User(const TMTWbParse_Keda_User& from);

  inline TMTWbParse_Keda_User& operator=(const TMTWbParse_Keda_User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParse_Keda_User& default_instance();

  void Swap(TMTWbParse_Keda_User* other);

  // implements Message ----------------------------------------------

  TMTWbParse_Keda_User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParse_Keda_User& from);
  void MergeFrom(const TMTWbParse_Keda_User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid = 1;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 1;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional string jid = 2;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 2;
  inline const ::std::string& jid() const;
  inline void set_jid(const ::std::string& value);
  inline void set_jid(const char* value);
  inline void set_jid(const char* value, size_t size);
  inline ::std::string* mutable_jid();
  inline ::std::string* release_jid();
  inline void set_allocated_jid(::std::string* jid);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string e164 = 5;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 5;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string mobile = 6;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 6;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  inline void set_allocated_mobile(::std::string* mobile);

  // optional string devicetype = 7;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDevicetypeFieldNumber = 7;
  inline const ::std::string& devicetype() const;
  inline void set_devicetype(const ::std::string& value);
  inline void set_devicetype(const char* value);
  inline void set_devicetype(const char* value, size_t size);
  inline ::std::string* mutable_devicetype();
  inline ::std::string* release_devicetype();
  inline void set_allocated_devicetype(::std::string* devicetype);

  // optional string name = 8;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 8;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string extnum = 9;
  inline bool has_extnum() const;
  inline void clear_extnum();
  static const int kExtnumFieldNumber = 9;
  inline const ::std::string& extnum() const;
  inline void set_extnum(const ::std::string& value);
  inline void set_extnum(const char* value);
  inline void set_extnum(const char* value, size_t size);
  inline ::std::string* mutable_extnum();
  inline ::std::string* release_extnum();
  inline void set_allocated_extnum(::std::string* extnum);

  // optional string seat = 10;
  inline bool has_seat() const;
  inline void clear_seat();
  static const int kSeatFieldNumber = 10;
  inline const ::std::string& seat() const;
  inline void set_seat(const ::std::string& value);
  inline void set_seat(const char* value);
  inline void set_seat(const char* value, size_t size);
  inline ::std::string* mutable_seat();
  inline ::std::string* release_seat();
  inline void set_allocated_seat(::std::string* seat);

  // optional string brief = 11;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 11;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // optional string portrait40 = 12;
  inline bool has_portrait40() const;
  inline void clear_portrait40();
  static const int kPortrait40FieldNumber = 12;
  inline const ::std::string& portrait40() const;
  inline void set_portrait40(const ::std::string& value);
  inline void set_portrait40(const char* value);
  inline void set_portrait40(const char* value, size_t size);
  inline ::std::string* mutable_portrait40();
  inline ::std::string* release_portrait40();
  inline void set_allocated_portrait40(::std::string* portrait40);

  // optional string portrait64 = 13;
  inline bool has_portrait64() const;
  inline void clear_portrait64();
  static const int kPortrait64FieldNumber = 13;
  inline const ::std::string& portrait64() const;
  inline void set_portrait64(const ::std::string& value);
  inline void set_portrait64(const char* value);
  inline void set_portrait64(const char* value, size_t size);
  inline ::std::string* mutable_portrait64();
  inline ::std::string* release_portrait64();
  inline void set_allocated_portrait64(::std::string* portrait64);

  // optional string portrait128 = 14;
  inline bool has_portrait128() const;
  inline void clear_portrait128();
  static const int kPortrait128FieldNumber = 14;
  inline const ::std::string& portrait128() const;
  inline void set_portrait128(const ::std::string& value);
  inline void set_portrait128(const char* value);
  inline void set_portrait128(const char* value, size_t size);
  inline ::std::string* mutable_portrait128();
  inline ::std::string* release_portrait128();
  inline void set_allocated_portrait128(::std::string* portrait128);

  // optional uint32 departmentid = 15;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentidFieldNumber = 15;
  inline ::google::protobuf::uint32 departmentid() const;
  inline void set_departmentid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTWbParse_Keda_User)
 private:
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_jid();
  inline void clear_has_jid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_extnum();
  inline void clear_has_extnum();
  inline void set_has_seat();
  inline void clear_has_seat();
  inline void set_has_brief();
  inline void clear_has_brief();
  inline void set_has_portrait40();
  inline void clear_has_portrait40();
  inline void set_has_portrait64();
  inline void clear_has_portrait64();
  inline void set_has_portrait128();
  inline void clear_has_portrait128();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::std::string* jid_;
  ::std::string* account_;
  ::std::string* email_;
  ::std::string* e164_;
  ::std::string* mobile_;
  ::std::string* devicetype_;
  ::std::string* name_;
  ::std::string* extnum_;
  ::std::string* seat_;
  ::std::string* brief_;
  ::std::string* portrait40_;
  ::std::string* portrait64_;
  ::std::string* portrait128_;
  ::google::protobuf::uint32 departmentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParse_Keda_User* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParse_Keda_departmentUsers : public ::google::protobuf::Message {
 public:
  TMTWbParse_Keda_departmentUsers();
  virtual ~TMTWbParse_Keda_departmentUsers();

  TMTWbParse_Keda_departmentUsers(const TMTWbParse_Keda_departmentUsers& from);

  inline TMTWbParse_Keda_departmentUsers& operator=(const TMTWbParse_Keda_departmentUsers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParse_Keda_departmentUsers& default_instance();

  void Swap(TMTWbParse_Keda_departmentUsers* other);

  // implements Message ----------------------------------------------

  TMTWbParse_Keda_departmentUsers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParse_Keda_departmentUsers& from);
  void MergeFrom(const TMTWbParse_Keda_departmentUsers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 userNum = 1;
  inline bool has_usernum() const;
  inline void clear_usernum();
  static const int kUserNumFieldNumber = 1;
  inline ::google::protobuf::uint32 usernum() const;
  inline void set_usernum(::google::protobuf::uint32 value);

  // repeated .mt.TMTWbParse_Keda_User user = 2;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::mt::TMTWbParse_Keda_User& user(int index) const;
  inline ::mt::TMTWbParse_Keda_User* mutable_user(int index);
  inline ::mt::TMTWbParse_Keda_User* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_User >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_User >*
      mutable_user();

  // @@protoc_insertion_point(class_scope:mt.TMTWbParse_Keda_departmentUsers)
 private:
  inline void set_has_usernum();
  inline void clear_has_usernum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_User > user_;
  ::google::protobuf::uint32 usernum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParse_Keda_departmentUsers* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParse_Keda_Department : public ::google::protobuf::Message {
 public:
  TMTWbParse_Keda_Department();
  virtual ~TMTWbParse_Keda_Department();

  TMTWbParse_Keda_Department(const TMTWbParse_Keda_Department& from);

  inline TMTWbParse_Keda_Department& operator=(const TMTWbParse_Keda_Department& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParse_Keda_Department& default_instance();

  void Swap(TMTWbParse_Keda_Department* other);

  // implements Message ----------------------------------------------

  TMTWbParse_Keda_Department* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParse_Keda_Department& from);
  void MergeFrom(const TMTWbParse_Keda_Department& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid = 1;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 1;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional uint32 departmentid = 2;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentidFieldNumber = 2;
  inline ::google::protobuf::uint32 departmentid() const;
  inline void set_departmentid(::google::protobuf::uint32 value);

  // optional string departmentname = 3;
  inline bool has_departmentname() const;
  inline void clear_departmentname();
  static const int kDepartmentnameFieldNumber = 3;
  inline const ::std::string& departmentname() const;
  inline void set_departmentname(const ::std::string& value);
  inline void set_departmentname(const char* value);
  inline void set_departmentname(const char* value, size_t size);
  inline ::std::string* mutable_departmentname();
  inline ::std::string* release_departmentname();
  inline void set_allocated_departmentname(::std::string* departmentname);

  // optional uint32 parentid = 4;
  inline bool has_parentid() const;
  inline void clear_parentid();
  static const int kParentidFieldNumber = 4;
  inline ::google::protobuf::uint32 parentid() const;
  inline void set_parentid(::google::protobuf::uint32 value);

  // optional string leaf = 5;
  inline bool has_leaf() const;
  inline void clear_leaf();
  static const int kLeafFieldNumber = 5;
  inline const ::std::string& leaf() const;
  inline void set_leaf(const ::std::string& value);
  inline void set_leaf(const char* value);
  inline void set_leaf(const char* value, size_t size);
  inline ::std::string* mutable_leaf();
  inline ::std::string* release_leaf();
  inline void set_allocated_leaf(::std::string* leaf);

  // optional uint32 seqnumber = 6;
  inline bool has_seqnumber() const;
  inline void clear_seqnumber();
  static const int kSeqnumberFieldNumber = 6;
  inline ::google::protobuf::uint32 seqnumber() const;
  inline void set_seqnumber(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTWbParse_Keda_Department)
 private:
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_departmentname();
  inline void clear_has_departmentname();
  inline void set_has_parentid();
  inline void clear_has_parentid();
  inline void set_has_leaf();
  inline void clear_has_leaf();
  inline void set_has_seqnumber();
  inline void clear_has_seqnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::std::string* departmentname_;
  ::google::protobuf::uint32 departmentid_;
  ::google::protobuf::uint32 parentid_;
  ::std::string* leaf_;
  ::google::protobuf::uint32 seqnumber_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParse_Keda_Department* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParse_Keda_Departments : public ::google::protobuf::Message {
 public:
  TMTWbParse_Keda_Departments();
  virtual ~TMTWbParse_Keda_Departments();

  TMTWbParse_Keda_Departments(const TMTWbParse_Keda_Departments& from);

  inline TMTWbParse_Keda_Departments& operator=(const TMTWbParse_Keda_Departments& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParse_Keda_Departments& default_instance();

  void Swap(TMTWbParse_Keda_Departments* other);

  // implements Message ----------------------------------------------

  TMTWbParse_Keda_Departments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParse_Keda_Departments& from);
  void MergeFrom(const TMTWbParse_Keda_Departments& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 departmentnum = 1;
  inline bool has_departmentnum() const;
  inline void clear_departmentnum();
  static const int kDepartmentnumFieldNumber = 1;
  inline ::google::protobuf::uint32 departmentnum() const;
  inline void set_departmentnum(::google::protobuf::uint32 value);

  // repeated .mt.TMTWbParse_Keda_Department department = 2;
  inline int department_size() const;
  inline void clear_department();
  static const int kDepartmentFieldNumber = 2;
  inline const ::mt::TMTWbParse_Keda_Department& department(int index) const;
  inline ::mt::TMTWbParse_Keda_Department* mutable_department(int index);
  inline ::mt::TMTWbParse_Keda_Department* add_department();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_Department >&
      department() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_Department >*
      mutable_department();

  // @@protoc_insertion_point(class_scope:mt.TMTWbParse_Keda_Departments)
 private:
  inline void set_has_departmentnum();
  inline void clear_has_departmentnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_Department > department_;
  ::google::protobuf::uint32 departmentnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParse_Keda_Departments* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWeiboLogin : public ::google::protobuf::Message {
 public:
  TMTWeiboLogin();
  virtual ~TMTWeiboLogin();

  TMTWeiboLogin(const TMTWeiboLogin& from);

  inline TMTWeiboLogin& operator=(const TMTWeiboLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWeiboLogin& default_instance();

  void Swap(TMTWeiboLogin* other);

  // implements Message ----------------------------------------------

  TMTWeiboLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWeiboLogin& from);
  void MergeFrom(const TMTWeiboLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:mt.TMTWeiboLogin)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTWeiboLogin* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TOauth : public ::google::protobuf::Message {
 public:
  TOauth();
  virtual ~TOauth();

  TOauth(const TOauth& from);

  inline TOauth& operator=(const TOauth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOauth& default_instance();

  void Swap(TOauth* other);

  // implements Message ----------------------------------------------

  TOauth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOauth& from);
  void MergeFrom(const TOauth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string oauth_consumer_key = 1;
  inline bool has_oauth_consumer_key() const;
  inline void clear_oauth_consumer_key();
  static const int kOauthConsumerKeyFieldNumber = 1;
  inline const ::std::string& oauth_consumer_key() const;
  inline void set_oauth_consumer_key(const ::std::string& value);
  inline void set_oauth_consumer_key(const char* value);
  inline void set_oauth_consumer_key(const char* value, size_t size);
  inline ::std::string* mutable_oauth_consumer_key();
  inline ::std::string* release_oauth_consumer_key();
  inline void set_allocated_oauth_consumer_key(::std::string* oauth_consumer_key);

  // optional string oauth_consumer_secret = 2;
  inline bool has_oauth_consumer_secret() const;
  inline void clear_oauth_consumer_secret();
  static const int kOauthConsumerSecretFieldNumber = 2;
  inline const ::std::string& oauth_consumer_secret() const;
  inline void set_oauth_consumer_secret(const ::std::string& value);
  inline void set_oauth_consumer_secret(const char* value);
  inline void set_oauth_consumer_secret(const char* value, size_t size);
  inline ::std::string* mutable_oauth_consumer_secret();
  inline ::std::string* release_oauth_consumer_secret();
  inline void set_allocated_oauth_consumer_secret(::std::string* oauth_consumer_secret);

  // optional string server_ip = 3;
  inline bool has_server_ip() const;
  inline void clear_server_ip();
  static const int kServerIpFieldNumber = 3;
  inline const ::std::string& server_ip() const;
  inline void set_server_ip(const ::std::string& value);
  inline void set_server_ip(const char* value);
  inline void set_server_ip(const char* value, size_t size);
  inline ::std::string* mutable_server_ip();
  inline ::std::string* release_server_ip();
  inline void set_allocated_server_ip(::std::string* server_ip);

  // @@protoc_insertion_point(class_scope:mt.TOauth)
 private:
  inline void set_has_oauth_consumer_key();
  inline void clear_has_oauth_consumer_key();
  inline void set_has_oauth_consumer_secret();
  inline void clear_has_oauth_consumer_secret();
  inline void set_has_server_ip();
  inline void clear_has_server_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* oauth_consumer_key_;
  ::std::string* oauth_consumer_secret_;
  ::std::string* server_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TOauth* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParse_Keda_EntConfig : public ::google::protobuf::Message {
 public:
  TMTWbParse_Keda_EntConfig();
  virtual ~TMTWbParse_Keda_EntConfig();

  TMTWbParse_Keda_EntConfig(const TMTWbParse_Keda_EntConfig& from);

  inline TMTWbParse_Keda_EntConfig& operator=(const TMTWbParse_Keda_EntConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParse_Keda_EntConfig& default_instance();

  void Swap(TMTWbParse_Keda_EntConfig* other);

  // implements Message ----------------------------------------------

  TMTWbParse_Keda_EntConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParse_Keda_EntConfig& from);
  void MergeFrom(const TMTWbParse_Keda_EntConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string xmppdomain = 1;
  inline bool has_xmppdomain() const;
  inline void clear_xmppdomain();
  static const int kXmppdomainFieldNumber = 1;
  inline const ::std::string& xmppdomain() const;
  inline void set_xmppdomain(const ::std::string& value);
  inline void set_xmppdomain(const char* value);
  inline void set_xmppdomain(const char* value, size_t size);
  inline ::std::string* mutable_xmppdomain();
  inline ::std::string* release_xmppdomain();
  inline void set_allocated_xmppdomain(::std::string* xmppdomain);

  // optional string apiurl = 2;
  inline bool has_apiurl() const;
  inline void clear_apiurl();
  static const int kApiurlFieldNumber = 2;
  inline const ::std::string& apiurl() const;
  inline void set_apiurl(const ::std::string& value);
  inline void set_apiurl(const char* value);
  inline void set_apiurl(const char* value, size_t size);
  inline ::std::string* mutable_apiurl();
  inline ::std::string* release_apiurl();
  inline void set_allocated_apiurl(::std::string* apiurl);

  // optional string weibourl = 3;
  inline bool has_weibourl() const;
  inline void clear_weibourl();
  static const int kWeibourlFieldNumber = 3;
  inline const ::std::string& weibourl() const;
  inline void set_weibourl(const ::std::string& value);
  inline void set_weibourl(const char* value);
  inline void set_weibourl(const char* value, size_t size);
  inline ::std::string* mutable_weibourl();
  inline ::std::string* release_weibourl();
  inline void set_allocated_weibourl(::std::string* weibourl);

  // optional string webimUrl = 4;
  inline bool has_webimurl() const;
  inline void clear_webimurl();
  static const int kWebimUrlFieldNumber = 4;
  inline const ::std::string& webimurl() const;
  inline void set_webimurl(const ::std::string& value);
  inline void set_webimurl(const char* value);
  inline void set_webimurl(const char* value, size_t size);
  inline ::std::string* mutable_webimurl();
  inline ::std::string* release_webimurl();
  inline void set_allocated_webimurl(::std::string* webimurl);

  // optional string tcpimUrl = 5;
  inline bool has_tcpimurl() const;
  inline void clear_tcpimurl();
  static const int kTcpimUrlFieldNumber = 5;
  inline const ::std::string& tcpimurl() const;
  inline void set_tcpimurl(const ::std::string& value);
  inline void set_tcpimurl(const char* value);
  inline void set_tcpimurl(const char* value, size_t size);
  inline ::std::string* mutable_tcpimurl();
  inline ::std::string* release_tcpimurl();
  inline void set_allocated_tcpimurl(::std::string* tcpimurl);

  // optional string tcpport = 6;
  inline bool has_tcpport() const;
  inline void clear_tcpport();
  static const int kTcpportFieldNumber = 6;
  inline const ::std::string& tcpport() const;
  inline void set_tcpport(const ::std::string& value);
  inline void set_tcpport(const char* value);
  inline void set_tcpport(const char* value, size_t size);
  inline ::std::string* mutable_tcpport();
  inline ::std::string* release_tcpport();
  inline void set_allocated_tcpport(::std::string* tcpport);

  // optional string ulsurl = 7;
  inline bool has_ulsurl() const;
  inline void clear_ulsurl();
  static const int kUlsurlFieldNumber = 7;
  inline const ::std::string& ulsurl() const;
  inline void set_ulsurl(const ::std::string& value);
  inline void set_ulsurl(const char* value);
  inline void set_ulsurl(const char* value, size_t size);
  inline ::std::string* mutable_ulsurl();
  inline ::std::string* release_ulsurl();
  inline void set_allocated_ulsurl(::std::string* ulsurl);

  // optional string ulsport = 8;
  inline bool has_ulsport() const;
  inline void clear_ulsport();
  static const int kUlsportFieldNumber = 8;
  inline const ::std::string& ulsport() const;
  inline void set_ulsport(const ::std::string& value);
  inline void set_ulsport(const char* value);
  inline void set_ulsport(const char* value, size_t size);
  inline ::std::string* mutable_ulsport();
  inline ::std::string* release_ulsport();
  inline void set_allocated_ulsport(::std::string* ulsport);

  // @@protoc_insertion_point(class_scope:mt.TMTWbParse_Keda_EntConfig)
 private:
  inline void set_has_xmppdomain();
  inline void clear_has_xmppdomain();
  inline void set_has_apiurl();
  inline void clear_has_apiurl();
  inline void set_has_weibourl();
  inline void clear_has_weibourl();
  inline void set_has_webimurl();
  inline void clear_has_webimurl();
  inline void set_has_tcpimurl();
  inline void clear_has_tcpimurl();
  inline void set_has_tcpport();
  inline void clear_has_tcpport();
  inline void set_has_ulsurl();
  inline void clear_has_ulsurl();
  inline void set_has_ulsport();
  inline void clear_has_ulsport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* xmppdomain_;
  ::std::string* apiurl_;
  ::std::string* weibourl_;
  ::std::string* webimurl_;
  ::std::string* tcpimurl_;
  ::std::string* tcpport_;
  ::std::string* ulsurl_;
  ::std::string* ulsport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParse_Keda_EntConfig* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParse_Keda_Result : public ::google::protobuf::Message {
 public:
  TMTWbParse_Keda_Result();
  virtual ~TMTWbParse_Keda_Result();

  TMTWbParse_Keda_Result(const TMTWbParse_Keda_Result& from);

  inline TMTWbParse_Keda_Result& operator=(const TMTWbParse_Keda_Result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParse_Keda_Result& default_instance();

  void Swap(TMTWbParse_Keda_Result* other);

  // implements Message ----------------------------------------------

  TMTWbParse_Keda_Result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParse_Keda_Result& from);
  void MergeFrom(const TMTWbParse_Keda_Result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMTWbParse_Keda_EntUser user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::mt::TMTWbParse_Keda_EntUser& user() const;
  inline ::mt::TMTWbParse_Keda_EntUser* mutable_user();
  inline ::mt::TMTWbParse_Keda_EntUser* release_user();
  inline void set_allocated_user(::mt::TMTWbParse_Keda_EntUser* user);

  // optional .mt.TMTWbParse_Keda_EntConfig config = 2;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline const ::mt::TMTWbParse_Keda_EntConfig& config() const;
  inline ::mt::TMTWbParse_Keda_EntConfig* mutable_config();
  inline ::mt::TMTWbParse_Keda_EntConfig* release_config();
  inline void set_allocated_config(::mt::TMTWbParse_Keda_EntConfig* config);

  // @@protoc_insertion_point(class_scope:mt.TMTWbParse_Keda_Result)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTWbParse_Keda_EntUser* user_;
  ::mt::TMTWbParse_Keda_EntConfig* config_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParse_Keda_Result* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TListNotifyByMax : public ::google::protobuf::Message {
 public:
  TListNotifyByMax();
  virtual ~TListNotifyByMax();

  TListNotifyByMax(const TListNotifyByMax& from);

  inline TListNotifyByMax& operator=(const TListNotifyByMax& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TListNotifyByMax& default_instance();

  void Swap(TListNotifyByMax* other);

  // implements Message ----------------------------------------------

  TListNotifyByMax* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TListNotifyByMax& from);
  void MergeFrom(const TListNotifyByMax& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 messagetype = 2;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessagetypeFieldNumber = 2;
  inline ::google::protobuf::uint32 messagetype() const;
  inline void set_messagetype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TListNotifyByMax)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_messagetype();
  inline void clear_has_messagetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 messagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TListNotifyByMax* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TIfExistLockByFormkey : public ::google::protobuf::Message {
 public:
  TIfExistLockByFormkey();
  virtual ~TIfExistLockByFormkey();

  TIfExistLockByFormkey(const TIfExistLockByFormkey& from);

  inline TIfExistLockByFormkey& operator=(const TIfExistLockByFormkey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TIfExistLockByFormkey& default_instance();

  void Swap(TIfExistLockByFormkey* other);

  // implements Message ----------------------------------------------

  TIfExistLockByFormkey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TIfExistLockByFormkey& from);
  void MergeFrom(const TIfExistLockByFormkey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string formkey = 1;
  inline bool has_formkey() const;
  inline void clear_formkey();
  static const int kFormkeyFieldNumber = 1;
  inline const ::std::string& formkey() const;
  inline void set_formkey(const ::std::string& value);
  inline void set_formkey(const char* value);
  inline void set_formkey(const char* value, size_t size);
  inline ::std::string* mutable_formkey();
  inline ::std::string* release_formkey();
  inline void set_allocated_formkey(::std::string* formkey);

  // @@protoc_insertion_point(class_scope:mt.TIfExistLockByFormkey)
 private:
  inline void set_has_formkey();
  inline void clear_has_formkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* formkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TIfExistLockByFormkey* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAppClearNotify : public ::google::protobuf::Message {
 public:
  TAppClearNotify();
  virtual ~TAppClearNotify();

  TAppClearNotify(const TAppClearNotify& from);

  inline TAppClearNotify& operator=(const TAppClearNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAppClearNotify& default_instance();

  void Swap(TAppClearNotify* other);

  // implements Message ----------------------------------------------

  TAppClearNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAppClearNotify& from);
  void MergeFrom(const TAppClearNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string notifytype = 1;
  inline bool has_notifytype() const;
  inline void clear_notifytype();
  static const int kNotifytypeFieldNumber = 1;
  inline const ::std::string& notifytype() const;
  inline void set_notifytype(const ::std::string& value);
  inline void set_notifytype(const char* value);
  inline void set_notifytype(const char* value, size_t size);
  inline ::std::string* mutable_notifytype();
  inline ::std::string* release_notifytype();
  inline void set_allocated_notifytype(::std::string* notifytype);

  // @@protoc_insertion_point(class_scope:mt.TAppClearNotify)
 private:
  inline void set_has_notifytype();
  inline void clear_has_notifytype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* notifytype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TAppClearNotify* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMeetingUnlock : public ::google::protobuf::Message {
 public:
  TMeetingUnlock();
  virtual ~TMeetingUnlock();

  TMeetingUnlock(const TMeetingUnlock& from);

  inline TMeetingUnlock& operator=(const TMeetingUnlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMeetingUnlock& default_instance();

  void Swap(TMeetingUnlock* other);

  // implements Message ----------------------------------------------

  TMeetingUnlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMeetingUnlock& from);
  void MergeFrom(const TMeetingUnlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string meetingformkey = 1;
  inline bool has_meetingformkey() const;
  inline void clear_meetingformkey();
  static const int kMeetingformkeyFieldNumber = 1;
  inline const ::std::string& meetingformkey() const;
  inline void set_meetingformkey(const ::std::string& value);
  inline void set_meetingformkey(const char* value);
  inline void set_meetingformkey(const char* value, size_t size);
  inline ::std::string* mutable_meetingformkey();
  inline ::std::string* release_meetingformkey();
  inline void set_allocated_meetingformkey(::std::string* meetingformkey);

  // @@protoc_insertion_point(class_scope:mt.TMeetingUnlock)
 private:
  inline void set_has_meetingformkey();
  inline void clear_has_meetingformkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetingformkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMeetingUnlock* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRegularFeed : public ::google::protobuf::Message {
 public:
  TRegularFeed();
  virtual ~TRegularFeed();

  TRegularFeed(const TRegularFeed& from);

  inline TRegularFeed& operator=(const TRegularFeed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRegularFeed& default_instance();

  void Swap(TRegularFeed* other);

  // implements Message ----------------------------------------------

  TRegularFeed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRegularFeed& from);
  void MergeFrom(const TRegularFeed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 regularid = 1;
  inline bool has_regularid() const;
  inline void clear_regularid();
  static const int kRegularidFieldNumber = 1;
  inline ::google::protobuf::uint32 regularid() const;
  inline void set_regularid(::google::protobuf::uint32 value);

  // optional bool accept = 2;
  inline bool has_accept() const;
  inline void clear_accept();
  static const int kAcceptFieldNumber = 2;
  inline bool accept() const;
  inline void set_accept(bool value);

  // optional uint32 jointype = 3;
  inline bool has_jointype() const;
  inline void clear_jointype();
  static const int kJointypeFieldNumber = 3;
  inline ::google::protobuf::uint32 jointype() const;
  inline void set_jointype(::google::protobuf::uint32 value);

  // optional string participantno = 4;
  inline bool has_participantno() const;
  inline void clear_participantno();
  static const int kParticipantnoFieldNumber = 4;
  inline const ::std::string& participantno() const;
  inline void set_participantno(const ::std::string& value);
  inline void set_participantno(const char* value);
  inline void set_participantno(const char* value, size_t size);
  inline ::std::string* mutable_participantno();
  inline ::std::string* release_participantno();
  inline void set_allocated_participantno(::std::string* participantno);

  // optional uint32 rejectreason = 5;
  inline bool has_rejectreason() const;
  inline void clear_rejectreason();
  static const int kRejectreasonFieldNumber = 5;
  inline ::google::protobuf::uint32 rejectreason() const;
  inline void set_rejectreason(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TRegularFeed)
 private:
  inline void set_has_regularid();
  inline void clear_has_regularid();
  inline void set_has_accept();
  inline void clear_has_accept();
  inline void set_has_jointype();
  inline void clear_has_jointype();
  inline void set_has_participantno();
  inline void clear_has_participantno();
  inline void set_has_rejectreason();
  inline void clear_has_rejectreason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 regularid_;
  bool accept_;
  ::std::string* participantno_;
  ::google::protobuf::uint32 jointype_;
  ::google::protobuf::uint32 rejectreason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TRegularFeed* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAddressBook : public ::google::protobuf::Message {
 public:
  TMTAddressBook();
  virtual ~TMTAddressBook();

  TMTAddressBook(const TMTAddressBook& from);

  inline TMTAddressBook& operator=(const TMTAddressBook& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAddressBook& default_instance();

  void Swap(TMTAddressBook* other);

  // implements Message ----------------------------------------------

  TMTAddressBook* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAddressBook& from);
  void MergeFrom(const TMTAddressBook& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid = 1;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 1;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional string jid = 2;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 2;
  inline const ::std::string& jid() const;
  inline void set_jid(const ::std::string& value);
  inline void set_jid(const char* value);
  inline void set_jid(const char* value, size_t size);
  inline ::std::string* mutable_jid();
  inline ::std::string* release_jid();
  inline void set_allocated_jid(::std::string* jid);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string email = 5;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 5;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string e164 = 6;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 6;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string mobilenum = 7;
  inline bool has_mobilenum() const;
  inline void clear_mobilenum();
  static const int kMobilenumFieldNumber = 7;
  inline const ::std::string& mobilenum() const;
  inline void set_mobilenum(const ::std::string& value);
  inline void set_mobilenum(const char* value);
  inline void set_mobilenum(const char* value, size_t size);
  inline ::std::string* mutable_mobilenum();
  inline ::std::string* release_mobilenum();
  inline void set_allocated_mobilenum(::std::string* mobilenum);

  // optional string extnum = 8;
  inline bool has_extnum() const;
  inline void clear_extnum();
  static const int kExtnumFieldNumber = 8;
  inline const ::std::string& extnum() const;
  inline void set_extnum(const ::std::string& value);
  inline void set_extnum(const char* value);
  inline void set_extnum(const char* value, size_t size);
  inline ::std::string* mutable_extnum();
  inline ::std::string* release_extnum();
  inline void set_allocated_extnum(::std::string* extnum);

  // @@protoc_insertion_point(class_scope:mt.TMTAddressBook)
 private:
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_jid();
  inline void clear_has_jid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_mobilenum();
  inline void clear_has_mobilenum();
  inline void set_has_extnum();
  inline void clear_has_extnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::std::string* jid_;
  ::std::string* account_;
  ::std::string* name_;
  ::std::string* email_;
  ::std::string* e164_;
  ::std::string* mobilenum_;
  ::std::string* extnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTAddressBook* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAddressBooks : public ::google::protobuf::Message {
 public:
  TMTAddressBooks();
  virtual ~TMTAddressBooks();

  TMTAddressBooks(const TMTAddressBooks& from);

  inline TMTAddressBooks& operator=(const TMTAddressBooks& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAddressBooks& default_instance();

  void Swap(TMTAddressBooks* other);

  // implements Message ----------------------------------------------

  TMTAddressBooks* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAddressBooks& from);
  void MergeFrom(const TMTAddressBooks& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 addressNum = 1;
  inline bool has_addressnum() const;
  inline void clear_addressnum();
  static const int kAddressNumFieldNumber = 1;
  inline ::google::protobuf::uint32 addressnum() const;
  inline void set_addressnum(::google::protobuf::uint32 value);

  // repeated .mt.TMTAddressBook address = 2;
  inline int address_size() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::mt::TMTAddressBook& address(int index) const;
  inline ::mt::TMTAddressBook* mutable_address(int index);
  inline ::mt::TMTAddressBook* add_address();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAddressBook >&
      address() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAddressBook >*
      mutable_address();

  // @@protoc_insertion_point(class_scope:mt.TMTAddressBooks)
 private:
  inline void set_has_addressnum();
  inline void clear_has_addressnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTAddressBook > address_;
  ::google::protobuf::uint32 addressnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTAddressBooks* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDepartment : public ::google::protobuf::Message {
 public:
  TDepartment();
  virtual ~TDepartment();

  TDepartment(const TDepartment& from);

  inline TDepartment& operator=(const TDepartment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDepartment& default_instance();

  void Swap(TDepartment* other);

  // implements Message ----------------------------------------------

  TDepartment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDepartment& from);
  void MergeFrom(const TDepartment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string departmentid = 1;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentidFieldNumber = 1;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  inline void set_allocated_departmentid(::std::string* departmentid);

  // optional string departmentname = 2;
  inline bool has_departmentname() const;
  inline void clear_departmentname();
  static const int kDepartmentnameFieldNumber = 2;
  inline const ::std::string& departmentname() const;
  inline void set_departmentname(const ::std::string& value);
  inline void set_departmentname(const char* value);
  inline void set_departmentname(const char* value, size_t size);
  inline ::std::string* mutable_departmentname();
  inline ::std::string* release_departmentname();
  inline void set_allocated_departmentname(::std::string* departmentname);

  // optional string username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:mt.TDepartment)
 private:
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_departmentname();
  inline void clear_has_departmentname();
  inline void set_has_username();
  inline void clear_has_username();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* departmentid_;
  ::std::string* departmentname_;
  ::std::string* username_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TDepartment* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConditionQuery : public ::google::protobuf::Message {
 public:
  TMTConditionQuery();
  virtual ~TMTConditionQuery();

  TMTConditionQuery(const TMTConditionQuery& from);

  inline TMTConditionQuery& operator=(const TMTConditionQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConditionQuery& default_instance();

  void Swap(TMTConditionQuery* other);

  // implements Message ----------------------------------------------

  TMTConditionQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConditionQuery& from);
  void MergeFrom(const TMTConditionQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string e164 = 2;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 2;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string account = 4;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string mobilephone = 5;
  inline bool has_mobilephone() const;
  inline void clear_mobilephone();
  static const int kMobilephoneFieldNumber = 5;
  inline const ::std::string& mobilephone() const;
  inline void set_mobilephone(const ::std::string& value);
  inline void set_mobilephone(const char* value);
  inline void set_mobilephone(const char* value, size_t size);
  inline ::std::string* mutable_mobilephone();
  inline ::std::string* release_mobilephone();
  inline void set_allocated_mobilephone(::std::string* mobilephone);

  // optional uint32 inent = 6;
  inline bool has_inent() const;
  inline void clear_inent();
  static const int kInentFieldNumber = 6;
  inline ::google::protobuf::uint32 inent() const;
  inline void set_inent(::google::protobuf::uint32 value);

  // optional uint32 startrow = 7;
  inline bool has_startrow() const;
  inline void clear_startrow();
  static const int kStartrowFieldNumber = 7;
  inline ::google::protobuf::uint32 startrow() const;
  inline void set_startrow(::google::protobuf::uint32 value);

  // optional uint32 pagesize = 8;
  inline bool has_pagesize() const;
  inline void clear_pagesize();
  static const int kPagesizeFieldNumber = 8;
  inline ::google::protobuf::uint32 pagesize() const;
  inline void set_pagesize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTConditionQuery)
 private:
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_mobilephone();
  inline void clear_has_mobilephone();
  inline void set_has_inent();
  inline void clear_has_inent();
  inline void set_has_startrow();
  inline void clear_has_startrow();
  inline void set_has_pagesize();
  inline void clear_has_pagesize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* email_;
  ::std::string* e164_;
  ::std::string* name_;
  ::std::string* account_;
  ::std::string* mobilephone_;
  ::google::protobuf::uint32 inent_;
  ::google::protobuf::uint32 startrow_;
  ::google::protobuf::uint32 pagesize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConditionQuery* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTQueryUser : public ::google::protobuf::Message {
 public:
  TMTQueryUser();
  virtual ~TMTQueryUser();

  TMTQueryUser(const TMTQueryUser& from);

  inline TMTQueryUser& operator=(const TMTQueryUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTQueryUser& default_instance();

  void Swap(TMTQueryUser* other);

  // implements Message ----------------------------------------------

  TMTQueryUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTQueryUser& from);
  void MergeFrom(const TMTQueryUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 usernum = 1;
  inline bool has_usernum() const;
  inline void clear_usernum();
  static const int kUsernumFieldNumber = 1;
  inline ::google::protobuf::uint32 usernum() const;
  inline void set_usernum(::google::protobuf::uint32 value);

  // repeated string userno = 2;
  inline int userno_size() const;
  inline void clear_userno();
  static const int kUsernoFieldNumber = 2;
  inline const ::std::string& userno(int index) const;
  inline ::std::string* mutable_userno(int index);
  inline void set_userno(int index, const ::std::string& value);
  inline void set_userno(int index, const char* value);
  inline void set_userno(int index, const char* value, size_t size);
  inline ::std::string* add_userno();
  inline void add_userno(const ::std::string& value);
  inline void add_userno(const char* value);
  inline void add_userno(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& userno() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_userno();

  // @@protoc_insertion_point(class_scope:mt.TMTQueryUser)
 private:
  inline void set_has_usernum();
  inline void clear_has_usernum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> userno_;
  ::google::protobuf::uint32 usernum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTQueryUser* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTQueryPortrait : public ::google::protobuf::Message {
 public:
  TMTQueryPortrait();
  virtual ~TMTQueryPortrait();

  TMTQueryPortrait(const TMTQueryPortrait& from);

  inline TMTQueryPortrait& operator=(const TMTQueryPortrait& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTQueryPortrait& default_instance();

  void Swap(TMTQueryPortrait* other);

  // implements Message ----------------------------------------------

  TMTQueryPortrait* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTQueryPortrait& from);
  void MergeFrom(const TMTQueryPortrait& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtPortrait mtportrait = 1;
  inline bool has_mtportrait() const;
  inline void clear_mtportrait();
  static const int kMtportraitFieldNumber = 1;
  inline ::mt::EmMtPortrait mtportrait() const;
  inline void set_mtportrait(::mt::EmMtPortrait value);

  // optional string portraitstr = 2;
  inline bool has_portraitstr() const;
  inline void clear_portraitstr();
  static const int kPortraitstrFieldNumber = 2;
  inline const ::std::string& portraitstr() const;
  inline void set_portraitstr(const ::std::string& value);
  inline void set_portraitstr(const char* value);
  inline void set_portraitstr(const char* value, size_t size);
  inline ::std::string* mutable_portraitstr();
  inline ::std::string* release_portraitstr();
  inline void set_allocated_portraitstr(::std::string* portraitstr);

  // optional string filename = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional uint64 requestpointer = 4;
  inline bool has_requestpointer() const;
  inline void clear_requestpointer();
  static const int kRequestpointerFieldNumber = 4;
  inline ::google::protobuf::uint64 requestpointer() const;
  inline void set_requestpointer(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mt.TMTQueryPortrait)
 private:
  inline void set_has_mtportrait();
  inline void clear_has_mtportrait();
  inline void set_has_portraitstr();
  inline void clear_has_portraitstr();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_requestpointer();
  inline void clear_has_requestpointer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* portraitstr_;
  ::std::string* filename_;
  ::google::protobuf::uint64 requestpointer_;
  int mtportrait_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTQueryPortrait* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTSetAuthMode : public ::google::protobuf::Message {
 public:
  TMTSetAuthMode();
  virtual ~TMTSetAuthMode();

  TMTSetAuthMode(const TMTSetAuthMode& from);

  inline TMTSetAuthMode& operator=(const TMTSetAuthMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTSetAuthMode& default_instance();

  void Swap(TMTSetAuthMode* other);

  // implements Message ----------------------------------------------

  TMTSetAuthMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTSetAuthMode& from);
  void MergeFrom(const TMTSetAuthMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string jid = 1;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 1;
  inline const ::std::string& jid() const;
  inline void set_jid(const ::std::string& value);
  inline void set_jid(const char* value);
  inline void set_jid(const char* value, size_t size);
  inline ::std::string* mutable_jid();
  inline ::std::string* release_jid();
  inline void set_allocated_jid(::std::string* jid);

  // optional uint32 authmode = 2;
  inline bool has_authmode() const;
  inline void clear_authmode();
  static const int kAuthmodeFieldNumber = 2;
  inline ::google::protobuf::uint32 authmode() const;
  inline void set_authmode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTSetAuthMode)
 private:
  inline void set_has_jid();
  inline void clear_has_jid();
  inline void set_has_authmode();
  inline void clear_has_authmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* jid_;
  ::google::protobuf::uint32 authmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTSetAuthMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUserListByStr : public ::google::protobuf::Message {
 public:
  TMTUserListByStr();
  virtual ~TMTUserListByStr();

  TMTUserListByStr(const TMTUserListByStr& from);

  inline TMTUserListByStr& operator=(const TMTUserListByStr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUserListByStr& default_instance();

  void Swap(TMTUserListByStr* other);

  // implements Message ----------------------------------------------

  TMTUserListByStr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUserListByStr& from);
  void MergeFrom(const TMTUserListByStr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // optional uint32 startrow = 3;
  inline bool has_startrow() const;
  inline void clear_startrow();
  static const int kStartrowFieldNumber = 3;
  inline ::google::protobuf::uint32 startrow() const;
  inline void set_startrow(::google::protobuf::uint32 value);

  // optional uint32 pagesize = 4;
  inline bool has_pagesize() const;
  inline void clear_pagesize();
  static const int kPagesizeFieldNumber = 4;
  inline ::google::protobuf::uint32 pagesize() const;
  inline void set_pagesize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTUserListByStr)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_startrow();
  inline void clear_has_startrow();
  inline void set_has_pagesize();
  inline void clear_has_pagesize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* str_;
  ::google::protobuf::uint32 startrow_;
  ::google::protobuf::uint32 pagesize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTUserListByStr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTModifyBrief : public ::google::protobuf::Message {
 public:
  TMTModifyBrief();
  virtual ~TMTModifyBrief();

  TMTModifyBrief(const TMTModifyBrief& from);

  inline TMTModifyBrief& operator=(const TMTModifyBrief& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTModifyBrief& default_instance();

  void Swap(TMTModifyBrief* other);

  // implements Message ----------------------------------------------

  TMTModifyBrief* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTModifyBrief& from);
  void MergeFrom(const TMTModifyBrief& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string brief = 2;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 2;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // @@protoc_insertion_point(class_scope:mt.TMTModifyBrief)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_brief();
  inline void clear_has_brief();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* brief_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTModifyBrief* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTModifyPortrait : public ::google::protobuf::Message {
 public:
  TMTModifyPortrait();
  virtual ~TMTModifyPortrait();

  TMTModifyPortrait(const TMTModifyPortrait& from);

  inline TMTModifyPortrait& operator=(const TMTModifyPortrait& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTModifyPortrait& default_instance();

  void Swap(TMTModifyPortrait* other);

  // implements Message ----------------------------------------------

  TMTModifyPortrait* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTModifyPortrait& from);
  void MergeFrom(const TMTModifyPortrait& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 x1 = 1;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline ::google::protobuf::uint32 x1() const;
  inline void set_x1(::google::protobuf::uint32 value);

  // optional uint32 y1 = 2;
  inline bool has_y1() const;
  inline void clear_y1();
  static const int kY1FieldNumber = 2;
  inline ::google::protobuf::uint32 y1() const;
  inline void set_y1(::google::protobuf::uint32 value);

  // optional uint32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 heith = 4;
  inline bool has_heith() const;
  inline void clear_heith();
  static const int kHeithFieldNumber = 4;
  inline ::google::protobuf::uint32 heith() const;
  inline void set_heith(::google::protobuf::uint32 value);

  // optional uint32 len = 5;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 5;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // optional string path = 6;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 6;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:mt.TMTModifyPortrait)
 private:
  inline void set_has_x1();
  inline void clear_has_x1();
  inline void set_has_y1();
  inline void clear_has_y1();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_heith();
  inline void clear_has_heith();
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 x1_;
  ::google::protobuf::uint32 y1_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 heith_;
  ::std::string* path_;
  ::google::protobuf::uint32 len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTModifyPortrait* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParse_Keda_EntUsers : public ::google::protobuf::Message {
 public:
  TMTWbParse_Keda_EntUsers();
  virtual ~TMTWbParse_Keda_EntUsers();

  TMTWbParse_Keda_EntUsers(const TMTWbParse_Keda_EntUsers& from);

  inline TMTWbParse_Keda_EntUsers& operator=(const TMTWbParse_Keda_EntUsers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParse_Keda_EntUsers& default_instance();

  void Swap(TMTWbParse_Keda_EntUsers* other);

  // implements Message ----------------------------------------------

  TMTWbParse_Keda_EntUsers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParse_Keda_EntUsers& from);
  void MergeFrom(const TMTWbParse_Keda_EntUsers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 usernum = 1;
  inline bool has_usernum() const;
  inline void clear_usernum();
  static const int kUsernumFieldNumber = 1;
  inline ::google::protobuf::uint32 usernum() const;
  inline void set_usernum(::google::protobuf::uint32 value);

  // repeated .mt.TMTWbParse_Keda_EntUser user = 2;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::mt::TMTWbParse_Keda_EntUser& user(int index) const;
  inline ::mt::TMTWbParse_Keda_EntUser* mutable_user(int index);
  inline ::mt::TMTWbParse_Keda_EntUser* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_EntUser >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_EntUser >*
      mutable_user();

  // @@protoc_insertion_point(class_scope:mt.TMTWbParse_Keda_EntUsers)
 private:
  inline void set_has_usernum();
  inline void clear_has_usernum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_EntUser > user_;
  ::google::protobuf::uint32 usernum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParse_Keda_EntUsers* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWBParse_Keda_QueryUsers : public ::google::protobuf::Message {
 public:
  TMTWBParse_Keda_QueryUsers();
  virtual ~TMTWBParse_Keda_QueryUsers();

  TMTWBParse_Keda_QueryUsers(const TMTWBParse_Keda_QueryUsers& from);

  inline TMTWBParse_Keda_QueryUsers& operator=(const TMTWBParse_Keda_QueryUsers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWBParse_Keda_QueryUsers& default_instance();

  void Swap(TMTWBParse_Keda_QueryUsers* other);

  // implements Message ----------------------------------------------

  TMTWBParse_Keda_QueryUsers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWBParse_Keda_QueryUsers& from);
  void MergeFrom(const TMTWBParse_Keda_QueryUsers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 totalcount = 1;
  inline bool has_totalcount() const;
  inline void clear_totalcount();
  static const int kTotalcountFieldNumber = 1;
  inline ::google::protobuf::uint32 totalcount() const;
  inline void set_totalcount(::google::protobuf::uint32 value);

  // optional .mt.TMTWbParse_Keda_EntUsers users = 2;
  inline bool has_users() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 2;
  inline const ::mt::TMTWbParse_Keda_EntUsers& users() const;
  inline ::mt::TMTWbParse_Keda_EntUsers* mutable_users();
  inline ::mt::TMTWbParse_Keda_EntUsers* release_users();
  inline void set_allocated_users(::mt::TMTWbParse_Keda_EntUsers* users);

  // @@protoc_insertion_point(class_scope:mt.TMTWBParse_Keda_QueryUsers)
 private:
  inline void set_has_totalcount();
  inline void clear_has_totalcount();
  inline void set_has_users();
  inline void clear_has_users();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTWbParse_Keda_EntUsers* users_;
  ::google::protobuf::uint32 totalcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTWBParse_Keda_QueryUsers* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTWbParse_Keda_SearchUsers : public ::google::protobuf::Message {
 public:
  TMTWbParse_Keda_SearchUsers();
  virtual ~TMTWbParse_Keda_SearchUsers();

  TMTWbParse_Keda_SearchUsers(const TMTWbParse_Keda_SearchUsers& from);

  inline TMTWbParse_Keda_SearchUsers& operator=(const TMTWbParse_Keda_SearchUsers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTWbParse_Keda_SearchUsers& default_instance();

  void Swap(TMTWbParse_Keda_SearchUsers* other);

  // implements Message ----------------------------------------------

  TMTWbParse_Keda_SearchUsers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTWbParse_Keda_SearchUsers& from);
  void MergeFrom(const TMTWbParse_Keda_SearchUsers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 totalcount = 1;
  inline bool has_totalcount() const;
  inline void clear_totalcount();
  static const int kTotalcountFieldNumber = 1;
  inline ::google::protobuf::uint32 totalcount() const;
  inline void set_totalcount(::google::protobuf::uint32 value);

  // optional string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // optional .mt.TMTWbParse_Keda_EntUsers users = 3;
  inline bool has_users() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 3;
  inline const ::mt::TMTWbParse_Keda_EntUsers& users() const;
  inline ::mt::TMTWbParse_Keda_EntUsers* mutable_users();
  inline ::mt::TMTWbParse_Keda_EntUsers* release_users();
  inline void set_allocated_users(::mt::TMTWbParse_Keda_EntUsers* users);

  // @@protoc_insertion_point(class_scope:mt.TMTWbParse_Keda_SearchUsers)
 private:
  inline void set_has_totalcount();
  inline void clear_has_totalcount();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_users();
  inline void clear_has_users();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_;
  ::mt::TMTWbParse_Keda_EntUsers* users_;
  ::google::protobuf::uint32 totalcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTWbParse_Keda_SearchUsers* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRoomids : public ::google::protobuf::Message {
 public:
  TMTRoomids();
  virtual ~TMTRoomids();

  TMTRoomids(const TMTRoomids& from);

  inline TMTRoomids& operator=(const TMTRoomids& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRoomids& default_instance();

  void Swap(TMTRoomids* other);

  // implements Message ----------------------------------------------

  TMTRoomids* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRoomids& from);
  void MergeFrom(const TMTRoomids& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated uint32 items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline ::google::protobuf::uint32 items(int index) const;
  inline void set_items(int index, ::google::protobuf::uint32 value);
  inline void add_items(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      items() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:mt.TMTRoomids)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > items_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRoomids* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoConferenceInfo : public ::google::protobuf::Message {
 public:
  TMTVideoConferenceInfo();
  virtual ~TMTVideoConferenceInfo();

  TMTVideoConferenceInfo(const TMTVideoConferenceInfo& from);

  inline TMTVideoConferenceInfo& operator=(const TMTVideoConferenceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoConferenceInfo& default_instance();

  void Swap(TMTVideoConferenceInfo* other);

  // implements Message ----------------------------------------------

  TMTVideoConferenceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoConferenceInfo& from);
  void MergeFrom(const TMTVideoConferenceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string e164 = 1;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 1;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string templateid = 2;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateidFieldNumber = 2;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional string templatename = 3;
  inline bool has_templatename() const;
  inline void clear_templatename();
  static const int kTemplatenameFieldNumber = 3;
  inline const ::std::string& templatename() const;
  inline void set_templatename(const ::std::string& value);
  inline void set_templatename(const char* value);
  inline void set_templatename(const char* value, size_t size);
  inline ::std::string* mutable_templatename();
  inline ::std::string* release_templatename();
  inline void set_allocated_templatename(::std::string* templatename);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional uint32 shortno = 5;
  inline bool has_shortno() const;
  inline void clear_shortno();
  static const int kShortnoFieldNumber = 5;
  inline ::google::protobuf::uint32 shortno() const;
  inline void set_shortno(::google::protobuf::uint32 value);

  // optional uint32 state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional uint32 isautocall = 7;
  inline bool has_isautocall() const;
  inline void clear_isautocall();
  static const int kIsautocallFieldNumber = 7;
  inline ::google::protobuf::uint32 isautocall() const;
  inline void set_isautocall(::google::protobuf::uint32 value);

  // optional .mt.EmClosedMeeting closedmeeting = 8;
  inline bool has_closedmeeting() const;
  inline void clear_closedmeeting();
  static const int kClosedmeetingFieldNumber = 8;
  inline ::mt::EmClosedMeeting closedmeeting() const;
  inline void set_closedmeeting(::mt::EmClosedMeeting value);

  // optional .mt.EmMtOpenMode meetingsafe = 9;
  inline bool has_meetingsafe() const;
  inline void clear_meetingsafe();
  static const int kMeetingsafeFieldNumber = 9;
  inline ::mt::EmMtOpenMode meetingsafe() const;
  inline void set_meetingsafe(::mt::EmMtOpenMode value);

  // optional .mt.EmRestMeetingSafeType meetingtype = 10;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 10;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional uint32 meetingscale = 11;
  inline bool has_meetingscale() const;
  inline void clear_meetingscale();
  static const int kMeetingscaleFieldNumber = 11;
  inline ::google::protobuf::uint32 meetingscale() const;
  inline void set_meetingscale(::google::protobuf::uint32 value);

  // optional uint32 onereforming = 12;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOnereformingFieldNumber = 12;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional bool publicmeeting = 13;
  inline bool has_publicmeeting() const;
  inline void clear_publicmeeting();
  static const int kPublicmeetingFieldNumber = 13;
  inline bool publicmeeting() const;
  inline void set_publicmeeting(bool value);

  // optional .mt.TMTTemplateMember speaker = 14;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 14;
  inline const ::mt::TMTTemplateMember& speaker() const;
  inline ::mt::TMTTemplateMember* mutable_speaker();
  inline ::mt::TMTTemplateMember* release_speaker();
  inline void set_allocated_speaker(::mt::TMTTemplateMember* speaker);

  // optional .mt.TMTTemplateMember admin = 15;
  inline bool has_admin() const;
  inline void clear_admin();
  static const int kAdminFieldNumber = 15;
  inline const ::mt::TMTTemplateMember& admin() const;
  inline ::mt::TMTTemplateMember* mutable_admin();
  inline ::mt::TMTTemplateMember* release_admin();
  inline void set_allocated_admin(::mt::TMTTemplateMember* admin);

  // optional .mt.TMTGetMixInfo mixinfo = 16;
  inline bool has_mixinfo() const;
  inline void clear_mixinfo();
  static const int kMixinfoFieldNumber = 16;
  inline const ::mt::TMTGetMixInfo& mixinfo() const;
  inline ::mt::TMTGetMixInfo* mutable_mixinfo();
  inline ::mt::TMTGetMixInfo* release_mixinfo();
  inline void set_allocated_mixinfo(::mt::TMTGetMixInfo* mixinfo);

  // optional uint32 calltimes = 17;
  inline bool has_calltimes() const;
  inline void clear_calltimes();
  static const int kCalltimesFieldNumber = 17;
  inline ::google::protobuf::uint32 calltimes() const;
  inline void set_calltimes(::google::protobuf::uint32 value);

  // optional uint32 callinterval = 18;
  inline bool has_callinterval() const;
  inline void clear_callinterval();
  static const int kCallintervalFieldNumber = 18;
  inline ::google::protobuf::uint32 callinterval() const;
  inline void set_callinterval(::google::protobuf::uint32 value);

  // optional bool callchase = 19;
  inline bool has_callchase() const;
  inline void clear_callchase();
  static const int kCallchaseFieldNumber = 19;
  inline bool callchase() const;
  inline void set_callchase(bool value);

  // optional bool initmute = 20;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 20;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional .mt.EmRestVideoQuality videoquality = 21;
  inline bool has_videoquality() const;
  inline void clear_videoquality();
  static const int kVideoqualityFieldNumber = 21;
  inline ::mt::EmRestVideoQuality videoquality() const;
  inline void set_videoquality(::mt::EmRestVideoQuality value);

  // optional .mt.EmEncryptArithmetic encryptedtype = 22;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 22;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional string encryptedkey = 23;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 23;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestDualMode dualmode = 24;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 24;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool voiceinspireenable = 25;
  inline bool has_voiceinspireenable() const;
  inline void clear_voiceinspireenable();
  static const int kVoiceinspireenableFieldNumber = 25;
  inline bool voiceinspireenable() const;
  inline void set_voiceinspireenable(bool value);

  // optional uint32 voiceinspiretime = 26;
  inline bool has_voiceinspiretime() const;
  inline void clear_voiceinspiretime();
  static const int kVoiceinspiretimeFieldNumber = 26;
  inline ::google::protobuf::uint32 voiceinspiretime() const;
  inline void set_voiceinspiretime(::google::protobuf::uint32 value);

  // optional .mt.EmRestCascadeMode cascademode = 27;
  inline bool has_cascademode() const;
  inline void clear_cascademode();
  static const int kCascademodeFieldNumber = 27;
  inline ::mt::EmRestCascadeMode cascademode() const;
  inline void set_cascademode(::mt::EmRestCascadeMode value);

  // optional bool cascadeupload = 28;
  inline bool has_cascadeupload() const;
  inline void clear_cascadeupload();
  static const int kCascadeuploadFieldNumber = 28;
  inline bool cascadeupload() const;
  inline void set_cascadeupload(bool value);

  // optional bool cascadereturn = 29;
  inline bool has_cascadereturn() const;
  inline void clear_cascadereturn();
  static const int kCascadereturnFieldNumber = 29;
  inline bool cascadereturn() const;
  inline void set_cascadereturn(bool value);

  // optional uint32 cascadereturnpara = 30;
  inline bool has_cascadereturnpara() const;
  inline void clear_cascadereturnpara();
  static const int kCascadereturnparaFieldNumber = 30;
  inline ::google::protobuf::uint32 cascadereturnpara() const;
  inline void set_cascadereturnpara(::google::protobuf::uint32 value);

  // optional .mt.TMTTemplateSatellite satellite = 31;
  inline bool has_satellite() const;
  inline void clear_satellite();
  static const int kSatelliteFieldNumber = 31;
  inline const ::mt::TMTTemplateSatellite& satellite() const;
  inline ::mt::TMTTemplateSatellite* mutable_satellite();
  inline ::mt::TMTTemplateSatellite* release_satellite();
  inline void set_allocated_satellite(::mt::TMTTemplateSatellite* satellite);

  // optional .mt.TMTTemplateRecord record = 32;
  inline bool has_record() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 32;
  inline const ::mt::TMTTemplateRecord& record() const;
  inline ::mt::TMTTemplateRecord* mutable_record();
  inline ::mt::TMTTemplateRecord* release_record();
  inline void set_allocated_record(::mt::TMTTemplateRecord* record);

  // optional .mt.TMTTemplateMultiCast multicast = 33;
  inline bool has_multicast() const;
  inline void clear_multicast();
  static const int kMulticastFieldNumber = 33;
  inline const ::mt::TMTTemplateMultiCast& multicast() const;
  inline ::mt::TMTTemplateMultiCast* mutable_multicast();
  inline ::mt::TMTTemplateMultiCast* release_multicast();
  inline void set_allocated_multicast(::mt::TMTTemplateMultiCast* multicast);

  // repeated .mt.TMTVideoFormatList videoformatlist = 34;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoformatlistFieldNumber = 34;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // repeated .mt.TMTAudioFormatList audioformatlist = 35;
  inline int audioformatlist_size() const;
  inline void clear_audioformatlist();
  static const int kAudioformatlistFieldNumber = 35;
  inline const ::mt::TMTAudioFormatList& audioformatlist(int index) const;
  inline ::mt::TMTAudioFormatList* mutable_audioformatlist(int index);
  inline ::mt::TMTAudioFormatList* add_audioformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
      audioformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
      mutable_audioformatlist();

  // repeated .mt.TMTDualFormatList dualformatlist = 36;
  inline int dualformatlist_size() const;
  inline void clear_dualformatlist();
  static const int kDualformatlistFieldNumber = 36;
  inline const ::mt::TMTDualFormatList& dualformatlist(int index) const;
  inline ::mt::TMTDualFormatList* mutable_dualformatlist(int index);
  inline ::mt::TMTDualFormatList* add_dualformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
      dualformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
      mutable_dualformatlist();

  // optional .mt.TMTTemplateVmp vmp = 37;
  inline bool has_vmp() const;
  inline void clear_vmp();
  static const int kVmpFieldNumber = 37;
  inline const ::mt::TMTTemplateVmp& vmp() const;
  inline ::mt::TMTTemplateVmp* mutable_vmp();
  inline ::mt::TMTTemplateVmp* release_vmp();
  inline void set_allocated_vmp(::mt::TMTTemplateVmp* vmp);

  // repeated .mt.TMTTemplateMember viplist = 38;
  inline int viplist_size() const;
  inline void clear_viplist();
  static const int kViplistFieldNumber = 38;
  inline const ::mt::TMTTemplateMember& viplist(int index) const;
  inline ::mt::TMTTemplateMember* mutable_viplist(int index);
  inline ::mt::TMTTemplateMember* add_viplist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      viplist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_viplist();

  // optional .mt.TMTTemplatePoll poll = 39;
  inline bool has_poll() const;
  inline void clear_poll();
  static const int kPollFieldNumber = 39;
  inline const ::mt::TMTTemplatePoll& poll() const;
  inline ::mt::TMTTemplatePoll* mutable_poll();
  inline ::mt::TMTTemplatePoll* release_poll();
  inline void set_allocated_poll(::mt::TMTTemplatePoll* poll);

  // repeated .mt.TMTTemplateMember callchasememberlist = 40;
  inline int callchasememberlist_size() const;
  inline void clear_callchasememberlist();
  static const int kCallchasememberlistFieldNumber = 40;
  inline const ::mt::TMTTemplateMember& callchasememberlist(int index) const;
  inline ::mt::TMTTemplateMember* mutable_callchasememberlist(int index);
  inline ::mt::TMTTemplateMember* add_callchasememberlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      callchasememberlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_callchasememberlist();

  // @@protoc_insertion_point(class_scope:mt.TMTVideoConferenceInfo)
 private:
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_templatename();
  inline void clear_has_templatename();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_shortno();
  inline void clear_has_shortno();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_isautocall();
  inline void clear_has_isautocall();
  inline void set_has_closedmeeting();
  inline void clear_has_closedmeeting();
  inline void set_has_meetingsafe();
  inline void clear_has_meetingsafe();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_meetingscale();
  inline void clear_has_meetingscale();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_publicmeeting();
  inline void clear_has_publicmeeting();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_admin();
  inline void clear_has_admin();
  inline void set_has_mixinfo();
  inline void clear_has_mixinfo();
  inline void set_has_calltimes();
  inline void clear_has_calltimes();
  inline void set_has_callinterval();
  inline void clear_has_callinterval();
  inline void set_has_callchase();
  inline void clear_has_callchase();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_videoquality();
  inline void clear_has_videoquality();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_voiceinspireenable();
  inline void clear_has_voiceinspireenable();
  inline void set_has_voiceinspiretime();
  inline void clear_has_voiceinspiretime();
  inline void set_has_cascademode();
  inline void clear_has_cascademode();
  inline void set_has_cascadeupload();
  inline void clear_has_cascadeupload();
  inline void set_has_cascadereturn();
  inline void clear_has_cascadereturn();
  inline void set_has_cascadereturnpara();
  inline void clear_has_cascadereturnpara();
  inline void set_has_satellite();
  inline void clear_has_satellite();
  inline void set_has_record();
  inline void clear_has_record();
  inline void set_has_multicast();
  inline void clear_has_multicast();
  inline void set_has_vmp();
  inline void clear_has_vmp();
  inline void set_has_poll();
  inline void clear_has_poll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* e164_;
  ::std::string* templateid_;
  ::std::string* templatename_;
  ::std::string* password_;
  ::google::protobuf::uint32 shortno_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 isautocall_;
  int closedmeeting_;
  int meetingsafe_;
  int meetingtype_;
  ::google::protobuf::uint32 meetingscale_;
  ::google::protobuf::uint32 onereforming_;
  ::mt::TMTTemplateMember* speaker_;
  ::mt::TMTTemplateMember* admin_;
  ::mt::TMTGetMixInfo* mixinfo_;
  ::google::protobuf::uint32 calltimes_;
  ::google::protobuf::uint32 callinterval_;
  bool publicmeeting_;
  bool callchase_;
  bool initmute_;
  bool voiceinspireenable_;
  int videoquality_;
  ::std::string* encryptedkey_;
  int encryptedtype_;
  int dualmode_;
  ::google::protobuf::uint32 voiceinspiretime_;
  int cascademode_;
  bool cascadeupload_;
  bool cascadereturn_;
  ::google::protobuf::uint32 cascadereturnpara_;
  ::mt::TMTTemplateSatellite* satellite_;
  ::mt::TMTTemplateRecord* record_;
  ::mt::TMTTemplateMultiCast* multicast_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList > audioformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList > dualformatlist_;
  ::mt::TMTTemplateVmp* vmp_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > viplist_;
  ::mt::TMTTemplatePoll* poll_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > callchasememberlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(40 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoConferenceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfInfoRooms : public ::google::protobuf::Message {
 public:
  TMTConfInfoRooms();
  virtual ~TMTConfInfoRooms();

  TMTConfInfoRooms(const TMTConfInfoRooms& from);

  inline TMTConfInfoRooms& operator=(const TMTConfInfoRooms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfInfoRooms& default_instance();

  void Swap(TMTConfInfoRooms* other);

  // implements Message ----------------------------------------------

  TMTConfInfoRooms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfInfoRooms& from);
  void MergeFrom(const TMTConfInfoRooms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 roomcount = 1;
  inline bool has_roomcount() const;
  inline void clear_roomcount();
  static const int kRoomcountFieldNumber = 1;
  inline ::google::protobuf::uint32 roomcount() const;
  inline void set_roomcount(::google::protobuf::uint32 value);

  // repeated .mt.TMTRoomInfo roominfo = 2;
  inline int roominfo_size() const;
  inline void clear_roominfo();
  static const int kRoominfoFieldNumber = 2;
  inline const ::mt::TMTRoomInfo& roominfo(int index) const;
  inline ::mt::TMTRoomInfo* mutable_roominfo(int index);
  inline ::mt::TMTRoomInfo* add_roominfo();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRoomInfo >&
      roominfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRoomInfo >*
      mutable_roominfo();

  // @@protoc_insertion_point(class_scope:mt.TMTConfInfoRooms)
 private:
  inline void set_has_roomcount();
  inline void clear_has_roomcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTRoomInfo > roominfo_;
  ::google::protobuf::uint32 roomcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfInfoRooms* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfInfoById : public ::google::protobuf::Message {
 public:
  TMTConfInfoById();
  virtual ~TMTConfInfoById();

  TMTConfInfoById(const TMTConfInfoById& from);

  inline TMTConfInfoById& operator=(const TMTConfInfoById& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfInfoById& default_instance();

  void Swap(TMTConfInfoById* other);

  // implements Message ----------------------------------------------

  TMTConfInfoById* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfInfoById& from);
  void MergeFrom(const TMTConfInfoById& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string starttime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 3;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 4;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional uint32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional string organizermoid = 6;
  inline bool has_organizermoid() const;
  inline void clear_organizermoid();
  static const int kOrganizermoidFieldNumber = 6;
  inline const ::std::string& organizermoid() const;
  inline void set_organizermoid(const ::std::string& value);
  inline void set_organizermoid(const char* value);
  inline void set_organizermoid(const char* value, size_t size);
  inline ::std::string* mutable_organizermoid();
  inline ::std::string* release_organizermoid();
  inline void set_allocated_organizermoid(::std::string* organizermoid);

  // optional string organizer = 7;
  inline bool has_organizer() const;
  inline void clear_organizer();
  static const int kOrganizerFieldNumber = 7;
  inline const ::std::string& organizer() const;
  inline void set_organizer(const ::std::string& value);
  inline void set_organizer(const char* value);
  inline void set_organizer(const char* value, size_t size);
  inline ::std::string* mutable_organizer();
  inline ::std::string* release_organizer();
  inline void set_allocated_organizer(::std::string* organizer);

  // optional string organizermail = 8;
  inline bool has_organizermail() const;
  inline void clear_organizermail();
  static const int kOrganizermailFieldNumber = 8;
  inline const ::std::string& organizermail() const;
  inline void set_organizermail(const ::std::string& value);
  inline void set_organizermail(const char* value);
  inline void set_organizermail(const char* value, size_t size);
  inline ::std::string* mutable_organizermail();
  inline ::std::string* release_organizermail();
  inline void set_allocated_organizermail(::std::string* organizermail);

  // optional string phone = 9;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 9;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string mobile = 10;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 10;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  inline void set_allocated_mobile(::std::string* mobile);

  // optional string brief = 11;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 11;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // optional uint32 isvideo = 12;
  inline bool has_isvideo() const;
  inline void clear_isvideo();
  static const int kIsvideoFieldNumber = 12;
  inline ::google::protobuf::uint32 isvideo() const;
  inline void set_isvideo(::google::protobuf::uint32 value);

  // optional .mt.TMTConfInfoRooms confinforooms = 13;
  inline bool has_confinforooms() const;
  inline void clear_confinforooms();
  static const int kConfinforoomsFieldNumber = 13;
  inline const ::mt::TMTConfInfoRooms& confinforooms() const;
  inline ::mt::TMTConfInfoRooms* mutable_confinforooms();
  inline ::mt::TMTConfInfoRooms* release_confinforooms();
  inline void set_allocated_confinforooms(::mt::TMTConfInfoRooms* confinforooms);

  // optional .mt.TMTVideoConferenceInfo videoconfinfo = 14;
  inline bool has_videoconfinfo() const;
  inline void clear_videoconfinfo();
  static const int kVideoconfinfoFieldNumber = 14;
  inline const ::mt::TMTVideoConferenceInfo& videoconfinfo() const;
  inline ::mt::TMTVideoConferenceInfo* mutable_videoconfinfo();
  inline ::mt::TMTVideoConferenceInfo* release_videoconfinfo();
  inline void set_allocated_videoconfinfo(::mt::TMTVideoConferenceInfo* videoconfinfo);

  // @@protoc_insertion_point(class_scope:mt.TMTConfInfoById)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_organizermoid();
  inline void clear_has_organizermoid();
  inline void set_has_organizer();
  inline void clear_has_organizer();
  inline void set_has_organizermail();
  inline void clear_has_organizermail();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_brief();
  inline void clear_has_brief();
  inline void set_has_isvideo();
  inline void clear_has_isvideo();
  inline void set_has_confinforooms();
  inline void clear_has_confinforooms();
  inline void set_has_videoconfinfo();
  inline void clear_has_videoconfinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subject_;
  ::std::string* starttime_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 status_;
  ::std::string* endtime_;
  ::std::string* organizermoid_;
  ::std::string* organizer_;
  ::std::string* organizermail_;
  ::std::string* phone_;
  ::std::string* mobile_;
  ::std::string* brief_;
  ::mt::TMTConfInfoRooms* confinforooms_;
  ::mt::TMTVideoConferenceInfo* videoconfinfo_;
  ::google::protobuf::uint32 isvideo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfInfoById* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTParticipantInfo : public ::google::protobuf::Message {
 public:
  TMTParticipantInfo();
  virtual ~TMTParticipantInfo();

  TMTParticipantInfo(const TMTParticipantInfo& from);

  inline TMTParticipantInfo& operator=(const TMTParticipantInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTParticipantInfo& default_instance();

  void Swap(TMTParticipantInfo* other);

  // implements Message ----------------------------------------------

  TMTParticipantInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTParticipantInfo& from);
  void MergeFrom(const TMTParticipantInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid = 1;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 1;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional string email = 2;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 2;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string participantNo = 4;
  inline bool has_participantno() const;
  inline void clear_participantno();
  static const int kParticipantNoFieldNumber = 4;
  inline const ::std::string& participantno() const;
  inline void set_participantno(const ::std::string& value);
  inline void set_participantno(const char* value);
  inline void set_participantno(const char* value, size_t size);
  inline ::std::string* mutable_participantno();
  inline ::std::string* release_participantno();
  inline void set_allocated_participantno(::std::string* participantno);

  // optional .mt.EmParticipantResponse participantresponse = 5;
  inline bool has_participantresponse() const;
  inline void clear_participantresponse();
  static const int kParticipantresponseFieldNumber = 5;
  inline ::mt::EmParticipantResponse participantresponse() const;
  inline void set_participantresponse(::mt::EmParticipantResponse value);

  // optional uint32 participanttype = 6;
  inline bool has_participanttype() const;
  inline void clear_participanttype();
  static const int kParticipanttypeFieldNumber = 6;
  inline ::google::protobuf::uint32 participanttype() const;
  inline void set_participanttype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTParticipantInfo)
 private:
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_participantno();
  inline void clear_has_participantno();
  inline void set_has_participantresponse();
  inline void clear_has_participantresponse();
  inline void set_has_participanttype();
  inline void clear_has_participanttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::std::string* email_;
  ::std::string* name_;
  ::std::string* participantno_;
  int participantresponse_;
  ::google::protobuf::uint32 participanttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTParticipantInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfInfoParticipants : public ::google::protobuf::Message {
 public:
  TMTConfInfoParticipants();
  virtual ~TMTConfInfoParticipants();

  TMTConfInfoParticipants(const TMTConfInfoParticipants& from);

  inline TMTConfInfoParticipants& operator=(const TMTConfInfoParticipants& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfInfoParticipants& default_instance();

  void Swap(TMTConfInfoParticipants* other);

  // implements Message ----------------------------------------------

  TMTConfInfoParticipants* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfInfoParticipants& from);
  void MergeFrom(const TMTConfInfoParticipants& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 participantcount = 1;
  inline bool has_participantcount() const;
  inline void clear_participantcount();
  static const int kParticipantcountFieldNumber = 1;
  inline ::google::protobuf::uint32 participantcount() const;
  inline void set_participantcount(::google::protobuf::uint32 value);

  // optional string confe164 = 2;
  inline bool has_confe164() const;
  inline void clear_confe164();
  static const int kConfe164FieldNumber = 2;
  inline const ::std::string& confe164() const;
  inline void set_confe164(const ::std::string& value);
  inline void set_confe164(const char* value);
  inline void set_confe164(const char* value, size_t size);
  inline ::std::string* mutable_confe164();
  inline ::std::string* release_confe164();
  inline void set_allocated_confe164(::std::string* confe164);

  // optional uint32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // repeated .mt.TMTParticipantInfo participantinfo = 4;
  inline int participantinfo_size() const;
  inline void clear_participantinfo();
  static const int kParticipantinfoFieldNumber = 4;
  inline const ::mt::TMTParticipantInfo& participantinfo(int index) const;
  inline ::mt::TMTParticipantInfo* mutable_participantinfo(int index);
  inline ::mt::TMTParticipantInfo* add_participantinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTParticipantInfo >&
      participantinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTParticipantInfo >*
      mutable_participantinfo();

  // @@protoc_insertion_point(class_scope:mt.TMTConfInfoParticipants)
 private:
  inline void set_has_participantcount();
  inline void clear_has_participantcount();
  inline void set_has_confe164();
  inline void clear_has_confe164();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* confe164_;
  ::google::protobuf::uint32 participantcount_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTParticipantInfo > participantinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfInfoParticipants* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRoomInfoById : public ::google::protobuf::Message {
 public:
  TMTRoomInfoById();
  virtual ~TMTRoomInfoById();

  TMTRoomInfoById(const TMTRoomInfoById& from);

  inline TMTRoomInfoById& operator=(const TMTRoomInfoById& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRoomInfoById& default_instance();

  void Swap(TMTRoomInfoById* other);

  // implements Message ----------------------------------------------

  TMTRoomInfoById* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRoomInfoById& from);
  void MergeFrom(const TMTRoomInfoById& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 peopleadmit = 3;
  inline bool has_peopleadmit() const;
  inline void clear_peopleadmit();
  static const int kPeopleadmitFieldNumber = 3;
  inline ::google::protobuf::uint32 peopleadmit() const;
  inline void set_peopleadmit(::google::protobuf::uint32 value);

  // optional uint32 area = 4;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 4;
  inline ::google::protobuf::uint32 area() const;
  inline void set_area(::google::protobuf::uint32 value);

  // optional string phone = 5;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 5;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional uint32 hasvideo = 6;
  inline bool has_hasvideo() const;
  inline void clear_hasvideo();
  static const int kHasvideoFieldNumber = 6;
  inline ::google::protobuf::uint32 hasvideo() const;
  inline void set_hasvideo(::google::protobuf::uint32 value);

  // optional string e164 = 7;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 7;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string deviceadmin = 8;
  inline bool has_deviceadmin() const;
  inline void clear_deviceadmin();
  static const int kDeviceadminFieldNumber = 8;
  inline const ::std::string& deviceadmin() const;
  inline void set_deviceadmin(const ::std::string& value);
  inline void set_deviceadmin(const char* value);
  inline void set_deviceadmin(const char* value, size_t size);
  inline ::std::string* mutable_deviceadmin();
  inline ::std::string* release_deviceadmin();
  inline void set_allocated_deviceadmin(::std::string* deviceadmin);

  // optional string adminphone = 9;
  inline bool has_adminphone() const;
  inline void clear_adminphone();
  static const int kAdminphoneFieldNumber = 9;
  inline const ::std::string& adminphone() const;
  inline void set_adminphone(const ::std::string& value);
  inline void set_adminphone(const char* value);
  inline void set_adminphone(const char* value, size_t size);
  inline ::std::string* mutable_adminphone();
  inline ::std::string* release_adminphone();
  inline void set_allocated_adminphone(::std::string* adminphone);

  // optional string remark = 10;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 10;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // optional uint32 devicemask = 11;
  inline bool has_devicemask() const;
  inline void clear_devicemask();
  static const int kDevicemaskFieldNumber = 11;
  inline ::google::protobuf::uint32 devicemask() const;
  inline void set_devicemask(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTRoomInfoById)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_peopleadmit();
  inline void clear_has_peopleadmit();
  inline void set_has_area();
  inline void clear_has_area();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_hasvideo();
  inline void clear_has_hasvideo();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_deviceadmin();
  inline void clear_has_deviceadmin();
  inline void set_has_adminphone();
  inline void clear_has_adminphone();
  inline void set_has_remark();
  inline void clear_has_remark();
  inline void set_has_devicemask();
  inline void clear_has_devicemask();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 peopleadmit_;
  ::std::string* phone_;
  ::google::protobuf::uint32 area_;
  ::google::protobuf::uint32 hasvideo_;
  ::std::string* e164_;
  ::std::string* deviceadmin_;
  ::std::string* adminphone_;
  ::std::string* remark_;
  ::google::protobuf::uint32 devicemask_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRoomInfoById* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCommonConfInfo : public ::google::protobuf::Message {
 public:
  TMTCommonConfInfo();
  virtual ~TMTCommonConfInfo();

  TMTCommonConfInfo(const TMTCommonConfInfo& from);

  inline TMTCommonConfInfo& operator=(const TMTCommonConfInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCommonConfInfo& default_instance();

  void Swap(TMTCommonConfInfo* other);

  // implements Message ----------------------------------------------

  TMTCommonConfInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCommonConfInfo& from);
  void MergeFrom(const TMTCommonConfInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string receivermoid = 2;
  inline bool has_receivermoid() const;
  inline void clear_receivermoid();
  static const int kReceivermoidFieldNumber = 2;
  inline const ::std::string& receivermoid() const;
  inline void set_receivermoid(const ::std::string& value);
  inline void set_receivermoid(const char* value);
  inline void set_receivermoid(const char* value, size_t size);
  inline ::std::string* mutable_receivermoid();
  inline ::std::string* release_receivermoid();
  inline void set_allocated_receivermoid(::std::string* receivermoid);

  // optional uint32 messagetype = 3;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessagetypeFieldNumber = 3;
  inline ::google::protobuf::uint32 messagetype() const;
  inline void set_messagetype(::google::protobuf::uint32 value);

  // optional string companymoid = 4;
  inline bool has_companymoid() const;
  inline void clear_companymoid();
  static const int kCompanymoidFieldNumber = 4;
  inline const ::std::string& companymoid() const;
  inline void set_companymoid(const ::std::string& value);
  inline void set_companymoid(const char* value);
  inline void set_companymoid(const char* value, size_t size);
  inline ::std::string* mutable_companymoid();
  inline ::std::string* release_companymoid();
  inline void set_allocated_companymoid(::std::string* companymoid);

  // optional string createtime = 5;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 5;
  inline const ::std::string& createtime() const;
  inline void set_createtime(const ::std::string& value);
  inline void set_createtime(const char* value);
  inline void set_createtime(const char* value, size_t size);
  inline ::std::string* mutable_createtime();
  inline ::std::string* release_createtime();
  inline void set_allocated_createtime(::std::string* createtime);

  // @@protoc_insertion_point(class_scope:mt.TMTCommonConfInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_receivermoid();
  inline void clear_has_receivermoid();
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_companymoid();
  inline void clear_has_companymoid();
  inline void set_has_createtime();
  inline void clear_has_createtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* receivermoid_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 messagetype_;
  ::std::string* companymoid_;
  ::std::string* createtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTCommonConfInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentCreateMeeting : public ::google::protobuf::Message {
 public:
  TMTContentCreateMeeting();
  virtual ~TMTContentCreateMeeting();

  TMTContentCreateMeeting(const TMTContentCreateMeeting& from);

  inline TMTContentCreateMeeting& operator=(const TMTContentCreateMeeting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentCreateMeeting& default_instance();

  void Swap(TMTContentCreateMeeting* other);

  // implements Message ----------------------------------------------

  TMTContentCreateMeeting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentCreateMeeting& from);
  void MergeFrom(const TMTContentCreateMeeting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string starttime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 3;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 4;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional bool isvideomeeting = 5;
  inline bool has_isvideomeeting() const;
  inline void clear_isvideomeeting();
  static const int kIsvideomeetingFieldNumber = 5;
  inline bool isvideomeeting() const;
  inline void set_isvideomeeting(bool value);

  // optional string phone = 6;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 6;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string mobilephone = 7;
  inline bool has_mobilephone() const;
  inline void clear_mobilephone();
  static const int kMobilephoneFieldNumber = 7;
  inline const ::std::string& mobilephone() const;
  inline void set_mobilephone(const ::std::string& value);
  inline void set_mobilephone(const char* value);
  inline void set_mobilephone(const char* value, size_t size);
  inline ::std::string* mutable_mobilephone();
  inline ::std::string* release_mobilephone();
  inline void set_allocated_mobilephone(::std::string* mobilephone);

  // optional string organizer = 8;
  inline bool has_organizer() const;
  inline void clear_organizer();
  static const int kOrganizerFieldNumber = 8;
  inline const ::std::string& organizer() const;
  inline void set_organizer(const ::std::string& value);
  inline void set_organizer(const char* value);
  inline void set_organizer(const char* value, size_t size);
  inline ::std::string* mutable_organizer();
  inline ::std::string* release_organizer();
  inline void set_allocated_organizer(::std::string* organizer);

  // optional string organizermoid = 9;
  inline bool has_organizermoid() const;
  inline void clear_organizermoid();
  static const int kOrganizermoidFieldNumber = 9;
  inline const ::std::string& organizermoid() const;
  inline void set_organizermoid(const ::std::string& value);
  inline void set_organizermoid(const char* value);
  inline void set_organizermoid(const char* value, size_t size);
  inline ::std::string* mutable_organizermoid();
  inline ::std::string* release_organizermoid();
  inline void set_allocated_organizermoid(::std::string* organizermoid);

  // optional .mt.TMTConfInfoRooms room = 10;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 10;
  inline const ::mt::TMTConfInfoRooms& room() const;
  inline ::mt::TMTConfInfoRooms* mutable_room();
  inline ::mt::TMTConfInfoRooms* release_room();
  inline void set_allocated_room(::mt::TMTConfInfoRooms* room);

  // @@protoc_insertion_point(class_scope:mt.TMTContentCreateMeeting)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_isvideomeeting();
  inline void clear_has_isvideomeeting();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_mobilephone();
  inline void clear_has_mobilephone();
  inline void set_has_organizer();
  inline void clear_has_organizer();
  inline void set_has_organizermoid();
  inline void clear_has_organizermoid();
  inline void set_has_room();
  inline void clear_has_room();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subject_;
  ::std::string* starttime_;
  ::google::protobuf::uint32 id_;
  bool isvideomeeting_;
  ::std::string* endtime_;
  ::std::string* phone_;
  ::std::string* mobilephone_;
  ::std::string* organizer_;
  ::std::string* organizermoid_;
  ::mt::TMTConfInfoRooms* room_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentCreateMeeting* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentUpdateMeeting : public ::google::protobuf::Message {
 public:
  TMTContentUpdateMeeting();
  virtual ~TMTContentUpdateMeeting();

  TMTContentUpdateMeeting(const TMTContentUpdateMeeting& from);

  inline TMTContentUpdateMeeting& operator=(const TMTContentUpdateMeeting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentUpdateMeeting& default_instance();

  void Swap(TMTContentUpdateMeeting* other);

  // implements Message ----------------------------------------------

  TMTContentUpdateMeeting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentUpdateMeeting& from);
  void MergeFrom(const TMTContentUpdateMeeting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string starttime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 3;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 4;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional string organizermoid = 5;
  inline bool has_organizermoid() const;
  inline void clear_organizermoid();
  static const int kOrganizermoidFieldNumber = 5;
  inline const ::std::string& organizermoid() const;
  inline void set_organizermoid(const ::std::string& value);
  inline void set_organizermoid(const char* value);
  inline void set_organizermoid(const char* value, size_t size);
  inline ::std::string* mutable_organizermoid();
  inline ::std::string* release_organizermoid();
  inline void set_allocated_organizermoid(::std::string* organizermoid);

  // optional string brief = 6;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 6;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // optional string beforesubject = 7;
  inline bool has_beforesubject() const;
  inline void clear_beforesubject();
  static const int kBeforesubjectFieldNumber = 7;
  inline const ::std::string& beforesubject() const;
  inline void set_beforesubject(const ::std::string& value);
  inline void set_beforesubject(const char* value);
  inline void set_beforesubject(const char* value, size_t size);
  inline ::std::string* mutable_beforesubject();
  inline ::std::string* release_beforesubject();
  inline void set_allocated_beforesubject(::std::string* beforesubject);

  // optional .mt.TMTConfInfoRooms room = 8;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 8;
  inline const ::mt::TMTConfInfoRooms& room() const;
  inline ::mt::TMTConfInfoRooms* mutable_room();
  inline ::mt::TMTConfInfoRooms* release_room();
  inline void set_allocated_room(::mt::TMTConfInfoRooms* room);

  // @@protoc_insertion_point(class_scope:mt.TMTContentUpdateMeeting)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_organizermoid();
  inline void clear_has_organizermoid();
  inline void set_has_brief();
  inline void clear_has_brief();
  inline void set_has_beforesubject();
  inline void clear_has_beforesubject();
  inline void set_has_room();
  inline void clear_has_room();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subject_;
  ::std::string* starttime_;
  ::std::string* endtime_;
  ::std::string* organizermoid_;
  ::std::string* brief_;
  ::std::string* beforesubject_;
  ::mt::TMTConfInfoRooms* room_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentUpdateMeeting* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentOutMeeting : public ::google::protobuf::Message {
 public:
  TMTContentOutMeeting();
  virtual ~TMTContentOutMeeting();

  TMTContentOutMeeting(const TMTContentOutMeeting& from);

  inline TMTContentOutMeeting& operator=(const TMTContentOutMeeting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentOutMeeting& default_instance();

  void Swap(TMTContentOutMeeting* other);

  // implements Message ----------------------------------------------

  TMTContentOutMeeting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentOutMeeting& from);
  void MergeFrom(const TMTContentOutMeeting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string organizermoid = 3;
  inline bool has_organizermoid() const;
  inline void clear_organizermoid();
  static const int kOrganizermoidFieldNumber = 3;
  inline const ::std::string& organizermoid() const;
  inline void set_organizermoid(const ::std::string& value);
  inline void set_organizermoid(const char* value);
  inline void set_organizermoid(const char* value, size_t size);
  inline ::std::string* mutable_organizermoid();
  inline ::std::string* release_organizermoid();
  inline void set_allocated_organizermoid(::std::string* organizermoid);

  // @@protoc_insertion_point(class_scope:mt.TMTContentOutMeeting)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_organizermoid();
  inline void clear_has_organizermoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subject_;
  ::std::string* organizermoid_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentOutMeeting* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentNotStartMeeting : public ::google::protobuf::Message {
 public:
  TMTContentNotStartMeeting();
  virtual ~TMTContentNotStartMeeting();

  TMTContentNotStartMeeting(const TMTContentNotStartMeeting& from);

  inline TMTContentNotStartMeeting& operator=(const TMTContentNotStartMeeting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentNotStartMeeting& default_instance();

  void Swap(TMTContentNotStartMeeting* other);

  // implements Message ----------------------------------------------

  TMTContentNotStartMeeting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentNotStartMeeting& from);
  void MergeFrom(const TMTContentNotStartMeeting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string starttime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 3;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 4;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional string organizermoid = 5;
  inline bool has_organizermoid() const;
  inline void clear_organizermoid();
  static const int kOrganizermoidFieldNumber = 5;
  inline const ::std::string& organizermoid() const;
  inline void set_organizermoid(const ::std::string& value);
  inline void set_organizermoid(const char* value);
  inline void set_organizermoid(const char* value, size_t size);
  inline ::std::string* mutable_organizermoid();
  inline ::std::string* release_organizermoid();
  inline void set_allocated_organizermoid(::std::string* organizermoid);

  // optional .mt.TMTConfInfoRooms room = 6;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 6;
  inline const ::mt::TMTConfInfoRooms& room() const;
  inline ::mt::TMTConfInfoRooms* mutable_room();
  inline ::mt::TMTConfInfoRooms* release_room();
  inline void set_allocated_room(::mt::TMTConfInfoRooms* room);

  // @@protoc_insertion_point(class_scope:mt.TMTContentNotStartMeeting)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_organizermoid();
  inline void clear_has_organizermoid();
  inline void set_has_room();
  inline void clear_has_room();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subject_;
  ::std::string* starttime_;
  ::std::string* endtime_;
  ::std::string* organizermoid_;
  ::mt::TMTConfInfoRooms* room_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentNotStartMeeting* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentDeadlineChanged : public ::google::protobuf::Message {
 public:
  TMTContentDeadlineChanged();
  virtual ~TMTContentDeadlineChanged();

  TMTContentDeadlineChanged(const TMTContentDeadlineChanged& from);

  inline TMTContentDeadlineChanged& operator=(const TMTContentDeadlineChanged& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentDeadlineChanged& default_instance();

  void Swap(TMTContentDeadlineChanged* other);

  // implements Message ----------------------------------------------

  TMTContentDeadlineChanged* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentDeadlineChanged& from);
  void MergeFrom(const TMTContentDeadlineChanged& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string deadline = 1;
  inline bool has_deadline() const;
  inline void clear_deadline();
  static const int kDeadlineFieldNumber = 1;
  inline const ::std::string& deadline() const;
  inline void set_deadline(const ::std::string& value);
  inline void set_deadline(const char* value);
  inline void set_deadline(const char* value, size_t size);
  inline ::std::string* mutable_deadline();
  inline ::std::string* release_deadline();
  inline void set_allocated_deadline(::std::string* deadline);

  // @@protoc_insertion_point(class_scope:mt.TMTContentDeadlineChanged)
 private:
  inline void set_has_deadline();
  inline void clear_has_deadline();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* deadline_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentDeadlineChanged* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentRegularMeeting : public ::google::protobuf::Message {
 public:
  TMTContentRegularMeeting();
  virtual ~TMTContentRegularMeeting();

  TMTContentRegularMeeting(const TMTContentRegularMeeting& from);

  inline TMTContentRegularMeeting& operator=(const TMTContentRegularMeeting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentRegularMeeting& default_instance();

  void Swap(TMTContentRegularMeeting* other);

  // implements Message ----------------------------------------------

  TMTContentRegularMeeting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentRegularMeeting& from);
  void MergeFrom(const TMTContentRegularMeeting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 regularid = 1;
  inline bool has_regularid() const;
  inline void clear_regularid();
  static const int kRegularidFieldNumber = 1;
  inline ::google::protobuf::uint32 regularid() const;
  inline void set_regularid(::google::protobuf::uint32 value);

  // optional string organizermoid = 2;
  inline bool has_organizermoid() const;
  inline void clear_organizermoid();
  static const int kOrganizermoidFieldNumber = 2;
  inline const ::std::string& organizermoid() const;
  inline void set_organizermoid(const ::std::string& value);
  inline void set_organizermoid(const char* value);
  inline void set_organizermoid(const char* value, size_t size);
  inline ::std::string* mutable_organizermoid();
  inline ::std::string* release_organizermoid();
  inline void set_allocated_organizermoid(::std::string* organizermoid);

  // optional string subject = 3;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 3;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string organizermail = 4;
  inline bool has_organizermail() const;
  inline void clear_organizermail();
  static const int kOrganizermailFieldNumber = 4;
  inline const ::std::string& organizermail() const;
  inline void set_organizermail(const ::std::string& value);
  inline void set_organizermail(const char* value);
  inline void set_organizermail(const char* value, size_t size);
  inline ::std::string* mutable_organizermail();
  inline ::std::string* release_organizermail();
  inline void set_allocated_organizermail(::std::string* organizermail);

  // optional string organizer = 5;
  inline bool has_organizer() const;
  inline void clear_organizer();
  static const int kOrganizerFieldNumber = 5;
  inline const ::std::string& organizer() const;
  inline void set_organizer(const ::std::string& value);
  inline void set_organizer(const char* value);
  inline void set_organizer(const char* value, size_t size);
  inline ::std::string* mutable_organizer();
  inline ::std::string* release_organizer();
  inline void set_allocated_organizer(::std::string* organizer);

  // optional string phone = 6;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 6;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string brief = 7;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 7;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // optional uint32 status = 8;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 8;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional string mobilephone = 9;
  inline bool has_mobilephone() const;
  inline void clear_mobilephone();
  static const int kMobilephoneFieldNumber = 9;
  inline const ::std::string& mobilephone() const;
  inline void set_mobilephone(const ::std::string& value);
  inline void set_mobilephone(const char* value);
  inline void set_mobilephone(const char* value, size_t size);
  inline ::std::string* mutable_mobilephone();
  inline ::std::string* release_mobilephone();
  inline void set_allocated_mobilephone(::std::string* mobilephone);

  // optional bool isvideomeeting = 10;
  inline bool has_isvideomeeting() const;
  inline void clear_isvideomeeting();
  static const int kIsvideomeetingFieldNumber = 10;
  inline bool isvideomeeting() const;
  inline void set_isvideomeeting(bool value);

  // optional string starttime = 11;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 11;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 12;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 12;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional string startdate = 13;
  inline bool has_startdate() const;
  inline void clear_startdate();
  static const int kStartdateFieldNumber = 13;
  inline const ::std::string& startdate() const;
  inline void set_startdate(const ::std::string& value);
  inline void set_startdate(const char* value);
  inline void set_startdate(const char* value, size_t size);
  inline ::std::string* mutable_startdate();
  inline ::std::string* release_startdate();
  inline void set_allocated_startdate(::std::string* startdate);

  // optional uint32 repeattype = 14;
  inline bool has_repeattype() const;
  inline void clear_repeattype();
  static const int kRepeattypeFieldNumber = 14;
  inline ::google::protobuf::uint32 repeattype() const;
  inline void set_repeattype(::google::protobuf::uint32 value);

  // optional uint32 frequency = 15;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 15;
  inline ::google::protobuf::uint32 frequency() const;
  inline void set_frequency(::google::protobuf::uint32 value);

  // optional string weekdays = 16;
  inline bool has_weekdays() const;
  inline void clear_weekdays();
  static const int kWeekdaysFieldNumber = 16;
  inline const ::std::string& weekdays() const;
  inline void set_weekdays(const ::std::string& value);
  inline void set_weekdays(const char* value);
  inline void set_weekdays(const char* value, size_t size);
  inline ::std::string* mutable_weekdays();
  inline ::std::string* release_weekdays();
  inline void set_allocated_weekdays(::std::string* weekdays);

  // optional string enddate = 17;
  inline bool has_enddate() const;
  inline void clear_enddate();
  static const int kEnddateFieldNumber = 17;
  inline const ::std::string& enddate() const;
  inline void set_enddate(const ::std::string& value);
  inline void set_enddate(const char* value);
  inline void set_enddate(const char* value, size_t size);
  inline ::std::string* mutable_enddate();
  inline ::std::string* release_enddate();
  inline void set_allocated_enddate(::std::string* enddate);

  // repeated uint32 meetingid = 18;
  inline int meetingid_size() const;
  inline void clear_meetingid();
  static const int kMeetingidFieldNumber = 18;
  inline ::google::protobuf::uint32 meetingid(int index) const;
  inline void set_meetingid(int index, ::google::protobuf::uint32 value);
  inline void add_meetingid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      meetingid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_meetingid();

  // @@protoc_insertion_point(class_scope:mt.TMTContentRegularMeeting)
 private:
  inline void set_has_regularid();
  inline void clear_has_regularid();
  inline void set_has_organizermoid();
  inline void clear_has_organizermoid();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_organizermail();
  inline void clear_has_organizermail();
  inline void set_has_organizer();
  inline void clear_has_organizer();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_brief();
  inline void clear_has_brief();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_mobilephone();
  inline void clear_has_mobilephone();
  inline void set_has_isvideomeeting();
  inline void clear_has_isvideomeeting();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_startdate();
  inline void clear_has_startdate();
  inline void set_has_repeattype();
  inline void clear_has_repeattype();
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_weekdays();
  inline void clear_has_weekdays();
  inline void set_has_enddate();
  inline void clear_has_enddate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* organizermoid_;
  ::std::string* subject_;
  ::std::string* organizermail_;
  ::google::protobuf::uint32 regularid_;
  ::google::protobuf::uint32 status_;
  ::std::string* organizer_;
  ::std::string* phone_;
  ::std::string* brief_;
  ::std::string* mobilephone_;
  ::std::string* starttime_;
  ::std::string* endtime_;
  bool isvideomeeting_;
  ::google::protobuf::uint32 repeattype_;
  ::std::string* startdate_;
  ::std::string* weekdays_;
  ::std::string* enddate_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > meetingid_;
  ::google::protobuf::uint32 frequency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentRegularMeeting* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentRegularId : public ::google::protobuf::Message {
 public:
  TMTContentRegularId();
  virtual ~TMTContentRegularId();

  TMTContentRegularId(const TMTContentRegularId& from);

  inline TMTContentRegularId& operator=(const TMTContentRegularId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentRegularId& default_instance();

  void Swap(TMTContentRegularId* other);

  // implements Message ----------------------------------------------

  TMTContentRegularId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentRegularId& from);
  void MergeFrom(const TMTContentRegularId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 regularid = 1;
  inline bool has_regularid() const;
  inline void clear_regularid();
  static const int kRegularidFieldNumber = 1;
  inline ::google::protobuf::uint32 regularid() const;
  inline void set_regularid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTContentRegularId)
 private:
  inline void set_has_regularid();
  inline void clear_has_regularid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 regularid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentRegularId* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentFeedback : public ::google::protobuf::Message {
 public:
  TMTContentFeedback();
  virtual ~TMTContentFeedback();

  TMTContentFeedback(const TMTContentFeedback& from);

  inline TMTContentFeedback& operator=(const TMTContentFeedback& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentFeedback& default_instance();

  void Swap(TMTContentFeedback* other);

  // implements Message ----------------------------------------------

  TMTContentFeedback* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentFeedback& from);
  void MergeFrom(const TMTContentFeedback& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string moid = 2;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 2;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional .mt.EmParticipantResponse isparticipated = 3;
  inline bool has_isparticipated() const;
  inline void clear_isparticipated();
  static const int kIsparticipatedFieldNumber = 3;
  inline ::mt::EmParticipantResponse isparticipated() const;
  inline void set_isparticipated(::mt::EmParticipantResponse value);

  // optional uint32 participatetype = 4;
  inline bool has_participatetype() const;
  inline void clear_participatetype();
  static const int kParticipatetypeFieldNumber = 4;
  inline ::google::protobuf::uint32 participatetype() const;
  inline void set_participatetype(::google::protobuf::uint32 value);

  // optional uint32 reasonid = 5;
  inline bool has_reasonid() const;
  inline void clear_reasonid();
  static const int kReasonidFieldNumber = 5;
  inline ::google::protobuf::uint32 reasonid() const;
  inline void set_reasonid(::google::protobuf::uint32 value);

  // optional bool isvideomeeting = 6;
  inline bool has_isvideomeeting() const;
  inline void clear_isvideomeeting();
  static const int kIsvideomeetingFieldNumber = 6;
  inline bool isvideomeeting() const;
  inline void set_isvideomeeting(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTContentFeedback)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_isparticipated();
  inline void clear_has_isparticipated();
  inline void set_has_participatetype();
  inline void clear_has_participatetype();
  inline void set_has_reasonid();
  inline void clear_has_reasonid();
  inline void set_has_isvideomeeting();
  inline void clear_has_isvideomeeting();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::google::protobuf::uint32 id_;
  int isparticipated_;
  ::google::protobuf::uint32 participatetype_;
  ::google::protobuf::uint32 reasonid_;
  bool isvideomeeting_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentFeedback* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentRoomId : public ::google::protobuf::Message {
 public:
  TMTContentRoomId();
  virtual ~TMTContentRoomId();

  TMTContentRoomId(const TMTContentRoomId& from);

  inline TMTContentRoomId& operator=(const TMTContentRoomId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentRoomId& default_instance();

  void Swap(TMTContentRoomId* other);

  // implements Message ----------------------------------------------

  TMTContentRoomId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentRoomId& from);
  void MergeFrom(const TMTContentRoomId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTContentRoomId)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentRoomId* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentMeetingId : public ::google::protobuf::Message {
 public:
  TMTContentMeetingId();
  virtual ~TMTContentMeetingId();

  TMTContentMeetingId(const TMTContentMeetingId& from);

  inline TMTContentMeetingId& operator=(const TMTContentMeetingId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentMeetingId& default_instance();

  void Swap(TMTContentMeetingId* other);

  // implements Message ----------------------------------------------

  TMTContentMeetingId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentMeetingId& from);
  void MergeFrom(const TMTContentMeetingId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTContentMeetingId)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentMeetingId* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentStartMeeting : public ::google::protobuf::Message {
 public:
  TMTContentStartMeeting();
  virtual ~TMTContentStartMeeting();

  TMTContentStartMeeting(const TMTContentStartMeeting& from);

  inline TMTContentStartMeeting& operator=(const TMTContentStartMeeting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentStartMeeting& default_instance();

  void Swap(TMTContentStartMeeting* other);

  // implements Message ----------------------------------------------

  TMTContentStartMeeting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentStartMeeting& from);
  void MergeFrom(const TMTContentStartMeeting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string starttime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 3;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 4;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional string organizermoid = 5;
  inline bool has_organizermoid() const;
  inline void clear_organizermoid();
  static const int kOrganizermoidFieldNumber = 5;
  inline const ::std::string& organizermoid() const;
  inline void set_organizermoid(const ::std::string& value);
  inline void set_organizermoid(const char* value);
  inline void set_organizermoid(const char* value, size_t size);
  inline ::std::string* mutable_organizermoid();
  inline ::std::string* release_organizermoid();
  inline void set_allocated_organizermoid(::std::string* organizermoid);

  // @@protoc_insertion_point(class_scope:mt.TMTContentStartMeeting)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_organizermoid();
  inline void clear_has_organizermoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subject_;
  ::std::string* starttime_;
  ::std::string* endtime_;
  ::std::string* organizermoid_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentStartMeeting* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRegularFeedAck : public ::google::protobuf::Message {
 public:
  TRegularFeedAck();
  virtual ~TRegularFeedAck();

  TRegularFeedAck(const TRegularFeedAck& from);

  inline TRegularFeedAck& operator=(const TRegularFeedAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRegularFeedAck& default_instance();

  void Swap(TRegularFeedAck* other);

  // implements Message ----------------------------------------------

  TRegularFeedAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRegularFeedAck& from);
  void MergeFrom(const TRegularFeedAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 regularid = 1;
  inline bool has_regularid() const;
  inline void clear_regularid();
  static const int kRegularidFieldNumber = 1;
  inline ::google::protobuf::uint32 regularid() const;
  inline void set_regularid(::google::protobuf::uint32 value);

  // optional bool accept = 2;
  inline bool has_accept() const;
  inline void clear_accept();
  static const int kAcceptFieldNumber = 2;
  inline bool accept() const;
  inline void set_accept(bool value);

  // optional uint32 jointype = 3;
  inline bool has_jointype() const;
  inline void clear_jointype();
  static const int kJointypeFieldNumber = 3;
  inline ::google::protobuf::uint32 jointype() const;
  inline void set_jointype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TRegularFeedAck)
 private:
  inline void set_has_regularid();
  inline void clear_has_regularid();
  inline void set_has_accept();
  inline void clear_has_accept();
  inline void set_has_jointype();
  inline void clear_has_jointype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 regularid_;
  bool accept_;
  ::google::protobuf::uint32 jointype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TRegularFeedAck* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAppGetAllNotifysAck : public ::google::protobuf::Message {
 public:
  TAppGetAllNotifysAck();
  virtual ~TAppGetAllNotifysAck();

  TAppGetAllNotifysAck(const TAppGetAllNotifysAck& from);

  inline TAppGetAllNotifysAck& operator=(const TAppGetAllNotifysAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAppGetAllNotifysAck& default_instance();

  void Swap(TAppGetAllNotifysAck* other);

  // implements Message ----------------------------------------------

  TAppGetAllNotifysAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAppGetAllNotifysAck& from);
  void MergeFrom(const TAppGetAllNotifysAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 notify_cnt = 1;
  inline bool has_notify_cnt() const;
  inline void clear_notify_cnt();
  static const int kNotifyCntFieldNumber = 1;
  inline ::google::protobuf::uint32 notify_cnt() const;
  inline void set_notify_cnt(::google::protobuf::uint32 value);

  // optional .mt.EmRestNotifyType notify_type = 2;
  inline bool has_notify_type() const;
  inline void clear_notify_type();
  static const int kNotifyTypeFieldNumber = 2;
  inline ::mt::EmRestNotifyType notify_type() const;
  inline void set_notify_type(::mt::EmRestNotifyType value);

  // @@protoc_insertion_point(class_scope:mt.TAppGetAllNotifysAck)
 private:
  inline void set_has_notify_cnt();
  inline void clear_has_notify_cnt();
  inline void set_has_notify_type();
  inline void clear_has_notify_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 notify_cnt_;
  int notify_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TAppGetAllNotifysAck* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAppGetAllNotifysAckList : public ::google::protobuf::Message {
 public:
  TAppGetAllNotifysAckList();
  virtual ~TAppGetAllNotifysAckList();

  TAppGetAllNotifysAckList(const TAppGetAllNotifysAckList& from);

  inline TAppGetAllNotifysAckList& operator=(const TAppGetAllNotifysAckList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAppGetAllNotifysAckList& default_instance();

  void Swap(TAppGetAllNotifysAckList* other);

  // implements Message ----------------------------------------------

  TAppGetAllNotifysAckList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAppGetAllNotifysAckList& from);
  void MergeFrom(const TAppGetAllNotifysAckList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAppGetAllNotifysAck notify_list = 1;
  inline int notify_list_size() const;
  inline void clear_notify_list();
  static const int kNotifyListFieldNumber = 1;
  inline const ::mt::TAppGetAllNotifysAck& notify_list(int index) const;
  inline ::mt::TAppGetAllNotifysAck* mutable_notify_list(int index);
  inline ::mt::TAppGetAllNotifysAck* add_notify_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAppGetAllNotifysAck >&
      notify_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAppGetAllNotifysAck >*
      mutable_notify_list();

  // @@protoc_insertion_point(class_scope:mt.TAppGetAllNotifysAckList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAppGetAllNotifysAck > notify_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TAppGetAllNotifysAckList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TGetMonitorGroupVersionAck : public ::google::protobuf::Message {
 public:
  TGetMonitorGroupVersionAck();
  virtual ~TGetMonitorGroupVersionAck();

  TGetMonitorGroupVersionAck(const TGetMonitorGroupVersionAck& from);

  inline TGetMonitorGroupVersionAck& operator=(const TGetMonitorGroupVersionAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGetMonitorGroupVersionAck& default_instance();

  void Swap(TGetMonitorGroupVersionAck* other);

  // implements Message ----------------------------------------------

  TGetMonitorGroupVersionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGetMonitorGroupVersionAck& from);
  void MergeFrom(const TGetMonitorGroupVersionAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mt.TGetMonitorGroupVersionAck)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TGetMonitorGroupVersionAck* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMonitorGroup : public ::google::protobuf::Message {
 public:
  TMTMonitorGroup();
  virtual ~TMTMonitorGroup();

  TMTMonitorGroup(const TMTMonitorGroup& from);

  inline TMTMonitorGroup& operator=(const TMTMonitorGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMonitorGroup& default_instance();

  void Swap(TMTMonitorGroup* other);

  // implements Message ----------------------------------------------

  TMTMonitorGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMonitorGroup& from);
  void MergeFrom(const TMTMonitorGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string groupid = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 2;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // optional string groupname = 3;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupnameFieldNumber = 3;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional string parentid = 4;
  inline bool has_parentid() const;
  inline void clear_parentid();
  static const int kParentidFieldNumber = 4;
  inline const ::std::string& parentid() const;
  inline void set_parentid(const ::std::string& value);
  inline void set_parentid(const char* value);
  inline void set_parentid(const char* value, size_t size);
  inline ::std::string* mutable_parentid();
  inline ::std::string* release_parentid();
  inline void set_allocated_parentid(::std::string* parentid);

  // optional string newgroup = 5;
  inline bool has_newgroup() const;
  inline void clear_newgroup();
  static const int kNewgroupFieldNumber = 5;
  inline const ::std::string& newgroup() const;
  inline void set_newgroup(const ::std::string& value);
  inline void set_newgroup(const char* value);
  inline void set_newgroup(const char* value, size_t size);
  inline ::std::string* mutable_newgroup();
  inline ::std::string* release_newgroup();
  inline void set_allocated_newgroup(::std::string* newgroup);

  // optional string leaf = 6;
  inline bool has_leaf() const;
  inline void clear_leaf();
  static const int kLeafFieldNumber = 6;
  inline const ::std::string& leaf() const;
  inline void set_leaf(const ::std::string& value);
  inline void set_leaf(const char* value);
  inline void set_leaf(const char* value, size_t size);
  inline ::std::string* mutable_leaf();
  inline ::std::string* release_leaf();
  inline void set_allocated_leaf(::std::string* leaf);

  // @@protoc_insertion_point(class_scope:mt.TMTMonitorGroup)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_parentid();
  inline void clear_has_parentid();
  inline void set_has_newgroup();
  inline void clear_has_newgroup();
  inline void set_has_leaf();
  inline void clear_has_leaf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* groupid_;
  ::std::string* groupname_;
  ::std::string* parentid_;
  ::std::string* newgroup_;
  ::std::string* leaf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTMonitorGroup* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMonitorGroups : public ::google::protobuf::Message {
 public:
  TMTMonitorGroups();
  virtual ~TMTMonitorGroups();

  TMTMonitorGroups(const TMTMonitorGroups& from);

  inline TMTMonitorGroups& operator=(const TMTMonitorGroups& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMonitorGroups& default_instance();

  void Swap(TMTMonitorGroups* other);

  // implements Message ----------------------------------------------

  TMTMonitorGroups* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMonitorGroups& from);
  void MergeFrom(const TMTMonitorGroups& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTMonitorGroup monitorgroup = 1;
  inline int monitorgroup_size() const;
  inline void clear_monitorgroup();
  static const int kMonitorgroupFieldNumber = 1;
  inline const ::mt::TMTMonitorGroup& monitorgroup(int index) const;
  inline ::mt::TMTMonitorGroup* mutable_monitorgroup(int index);
  inline ::mt::TMTMonitorGroup* add_monitorgroup();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTMonitorGroup >&
      monitorgroup() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTMonitorGroup >*
      mutable_monitorgroup();

  // @@protoc_insertion_point(class_scope:mt.TMTMonitorGroups)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTMonitorGroup > monitorgroup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTMonitorGroups* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMonitorDevice : public ::google::protobuf::Message {
 public:
  TMTMonitorDevice();
  virtual ~TMTMonitorDevice();

  TMTMonitorDevice(const TMTMonitorDevice& from);

  inline TMTMonitorDevice& operator=(const TMTMonitorDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMonitorDevice& default_instance();

  void Swap(TMTMonitorDevice* other);

  // implements Message ----------------------------------------------

  TMTMonitorDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMonitorDevice& from);
  void MergeFrom(const TMTMonitorDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string groupid = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 1;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string deviceguid = 4;
  inline bool has_deviceguid() const;
  inline void clear_deviceguid();
  static const int kDeviceguidFieldNumber = 4;
  inline const ::std::string& deviceguid() const;
  inline void set_deviceguid(const ::std::string& value);
  inline void set_deviceguid(const char* value);
  inline void set_deviceguid(const char* value, size_t size);
  inline ::std::string* mutable_deviceguid();
  inline ::std::string* release_deviceguid();
  inline void set_allocated_deviceguid(::std::string* deviceguid);

  // optional string e164 = 5;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 5;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string devicetype = 6;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDevicetypeFieldNumber = 6;
  inline const ::std::string& devicetype() const;
  inline void set_devicetype(const ::std::string& value);
  inline void set_devicetype(const char* value);
  inline void set_devicetype(const char* value, size_t size);
  inline ::std::string* mutable_devicetype();
  inline ::std::string* release_devicetype();
  inline void set_allocated_devicetype(::std::string* devicetype);

  // optional string description = 7;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 7;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string note = 8;
  inline bool has_note() const;
  inline void clear_note();
  static const int kNoteFieldNumber = 8;
  inline const ::std::string& note() const;
  inline void set_note(const ::std::string& value);
  inline void set_note(const char* value);
  inline void set_note(const char* value, size_t size);
  inline ::std::string* mutable_note();
  inline ::std::string* release_note();
  inline void set_allocated_note(::std::string* note);

  // @@protoc_insertion_point(class_scope:mt.TMTMonitorDevice)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_deviceguid();
  inline void clear_has_deviceguid();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_note();
  inline void clear_has_note();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* groupid_;
  ::std::string* id_;
  ::std::string* name_;
  ::std::string* deviceguid_;
  ::std::string* e164_;
  ::std::string* devicetype_;
  ::std::string* description_;
  ::std::string* note_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTMonitorDevice* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMonitorDevices : public ::google::protobuf::Message {
 public:
  TMTMonitorDevices();
  virtual ~TMTMonitorDevices();

  TMTMonitorDevices(const TMTMonitorDevices& from);

  inline TMTMonitorDevices& operator=(const TMTMonitorDevices& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMonitorDevices& default_instance();

  void Swap(TMTMonitorDevices* other);

  // implements Message ----------------------------------------------

  TMTMonitorDevices* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMonitorDevices& from);
  void MergeFrom(const TMTMonitorDevices& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTMonitorDevice m_atMonitorDevice = 1;
  inline int m_atmonitordevice_size() const;
  inline void clear_m_atmonitordevice();
  static const int kMAtMonitorDeviceFieldNumber = 1;
  inline const ::mt::TMTMonitorDevice& m_atmonitordevice(int index) const;
  inline ::mt::TMTMonitorDevice* mutable_m_atmonitordevice(int index);
  inline ::mt::TMTMonitorDevice* add_m_atmonitordevice();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTMonitorDevice >&
      m_atmonitordevice() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTMonitorDevice >*
      mutable_m_atmonitordevice();

  // @@protoc_insertion_point(class_scope:mt.TMTMonitorDevices)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTMonitorDevice > m_atmonitordevice_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTMonitorDevices* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTGetPerTemplateList : public ::google::protobuf::Message {
 public:
  TMTGetPerTemplateList();
  virtual ~TMTGetPerTemplateList();

  TMTGetPerTemplateList(const TMTGetPerTemplateList& from);

  inline TMTGetPerTemplateList& operator=(const TMTGetPerTemplateList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTGetPerTemplateList& default_instance();

  void Swap(TMTGetPerTemplateList* other);

  // implements Message ----------------------------------------------

  TMTGetPerTemplateList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTGetPerTemplateList& from);
  void MergeFrom(const TMTGetPerTemplateList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 3;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 3;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTGetPerTemplateList)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTGetPerTemplateList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplateAccount : public ::google::protobuf::Message {
 public:
  TMTTemplateAccount();
  virtual ~TMTTemplateAccount();

  TMTTemplateAccount(const TMTTemplateAccount& from);

  inline TMTTemplateAccount& operator=(const TMTTemplateAccount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplateAccount& default_instance();

  void Swap(TMTTemplateAccount* other);

  // implements Message ----------------------------------------------

  TMTTemplateAccount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplateAccount& from);
  void MergeFrom(const TMTTemplateAccount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional .mt.EmMtAddrType accounttype = 2;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccounttypeFieldNumber = 2;
  inline ::mt::EmMtAddrType accounttype() const;
  inline void set_accounttype(::mt::EmMtAddrType value);

  // @@protoc_insertion_point(class_scope:mt.TMTTemplateAccount)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int accounttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplateAccount* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplateRecord : public ::google::protobuf::Message {
 public:
  TMTTemplateRecord();
  virtual ~TMTTemplateRecord();

  TMTTemplateRecord(const TMTTemplateRecord& from);

  inline TMTTemplateRecord& operator=(const TMTTemplateRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplateRecord& default_instance();

  void Swap(TMTTemplateRecord* other);

  // implements Message ----------------------------------------------

  TMTTemplateRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplateRecord& from);
  void MergeFrom(const TMTTemplateRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool doubleflow = 1;
  inline bool has_doubleflow() const;
  inline void clear_doubleflow();
  static const int kDoubleflowFieldNumber = 1;
  inline bool doubleflow() const;
  inline void set_doubleflow(bool value);

  // optional bool enable = 2;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 2;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional bool main = 3;
  inline bool has_main() const;
  inline void clear_main();
  static const int kMainFieldNumber = 3;
  inline bool main() const;
  inline void set_main(bool value);

  // optional bool publish = 4;
  inline bool has_publish() const;
  inline void clear_publish();
  static const int kPublishFieldNumber = 4;
  inline bool publish() const;
  inline void set_publish(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTTemplateRecord)
 private:
  inline void set_has_doubleflow();
  inline void clear_has_doubleflow();
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_main();
  inline void clear_has_main();
  inline void set_has_publish();
  inline void clear_has_publish();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool doubleflow_;
  bool enable_;
  bool main_;
  bool publish_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplateRecord* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplateSatellite : public ::google::protobuf::Message {
 public:
  TMTTemplateSatellite();
  virtual ~TMTTemplateSatellite();

  TMTTemplateSatellite(const TMTTemplateSatellite& from);

  inline TMTTemplateSatellite& operator=(const TMTTemplateSatellite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplateSatellite& default_instance();

  void Swap(TMTTemplateSatellite* other);

  // implements Message ----------------------------------------------

  TMTTemplateSatellite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplateSatellite& from);
  void MergeFrom(const TMTTemplateSatellite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional string multicastaddr = 2;
  inline bool has_multicastaddr() const;
  inline void clear_multicastaddr();
  static const int kMulticastaddrFieldNumber = 2;
  inline const ::std::string& multicastaddr() const;
  inline void set_multicastaddr(const ::std::string& value);
  inline void set_multicastaddr(const char* value);
  inline void set_multicastaddr(const char* value, size_t size);
  inline ::std::string* mutable_multicastaddr();
  inline ::std::string* release_multicastaddr();
  inline void set_allocated_multicastaddr(::std::string* multicastaddr);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional uint32 returnnum = 4;
  inline bool has_returnnum() const;
  inline void clear_returnnum();
  static const int kReturnnumFieldNumber = 4;
  inline ::google::protobuf::uint32 returnnum() const;
  inline void set_returnnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTTemplateSatellite)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_multicastaddr();
  inline void clear_has_multicastaddr();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_returnnum();
  inline void clear_has_returnnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* multicastaddr_;
  bool enable_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 returnnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplateSatellite* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTDualFormatList : public ::google::protobuf::Message {
 public:
  TMTDualFormatList();
  virtual ~TMTDualFormatList();

  TMTDualFormatList(const TMTDualFormatList& from);

  inline TMTDualFormatList& operator=(const TMTDualFormatList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTDualFormatList& default_instance();

  void Swap(TMTDualFormatList* other);

  // implements Message ----------------------------------------------

  TMTDualFormatList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTDualFormatList& from);
  void MergeFrom(const TMTDualFormatList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 frame = 1;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 1;
  inline ::google::protobuf::uint32 frame() const;
  inline void set_frame(::google::protobuf::uint32 value);

  // optional .mt.EmMtResolution resolution = 2;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 2;
  inline ::mt::EmMtResolution resolution() const;
  inline void set_resolution(::mt::EmMtResolution value);

  // optional .mt.EmVidFormat videoformat = 3;
  inline bool has_videoformat() const;
  inline void clear_videoformat();
  static const int kVideoformatFieldNumber = 3;
  inline ::mt::EmVidFormat videoformat() const;
  inline void set_videoformat(::mt::EmVidFormat value);

  // @@protoc_insertion_point(class_scope:mt.TMTDualFormatList)
 private:
  inline void set_has_frame();
  inline void clear_has_frame();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_videoformat();
  inline void clear_has_videoformat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 frame_;
  int resolution_;
  int videoformat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTDualFormatList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTSetMixInfo : public ::google::protobuf::Message {
 public:
  TMTSetMixInfo();
  virtual ~TMTSetMixInfo();

  TMTSetMixInfo(const TMTSetMixInfo& from);

  inline TMTSetMixInfo& operator=(const TMTSetMixInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTSetMixInfo& default_instance();

  void Swap(TMTSetMixInfo* other);

  // implements Message ----------------------------------------------

  TMTSetMixInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTSetMixInfo& from);
  void MergeFrom(const TMTSetMixInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional .mt.EmMtMixType mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::mt::EmMtMixType mode() const;
  inline void set_mode(::mt::EmMtMixType value);

  // repeated .mt.TMTTemplateAccount mixmemberlist = 3;
  inline int mixmemberlist_size() const;
  inline void clear_mixmemberlist();
  static const int kMixmemberlistFieldNumber = 3;
  inline const ::mt::TMTTemplateAccount& mixmemberlist(int index) const;
  inline ::mt::TMTTemplateAccount* mutable_mixmemberlist(int index);
  inline ::mt::TMTTemplateAccount* add_mixmemberlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >&
      mixmemberlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >*
      mutable_mixmemberlist();

  // @@protoc_insertion_point(class_scope:mt.TMTSetMixInfo)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  int mode_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount > mixmemberlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTSetMixInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTGetMixInfo : public ::google::protobuf::Message {
 public:
  TMTGetMixInfo();
  virtual ~TMTGetMixInfo();

  TMTGetMixInfo(const TMTGetMixInfo& from);

  inline TMTGetMixInfo& operator=(const TMTGetMixInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTGetMixInfo& default_instance();

  void Swap(TMTGetMixInfo* other);

  // implements Message ----------------------------------------------

  TMTGetMixInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTGetMixInfo& from);
  void MergeFrom(const TMTGetMixInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional .mt.EmMtMixType mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::mt::EmMtMixType mode() const;
  inline void set_mode(::mt::EmMtMixType value);

  // repeated .mt.TMTTemplateMember mixmemberlist = 3;
  inline int mixmemberlist_size() const;
  inline void clear_mixmemberlist();
  static const int kMixmemberlistFieldNumber = 3;
  inline const ::mt::TMTTemplateMember& mixmemberlist(int index) const;
  inline ::mt::TMTTemplateMember* mutable_mixmemberlist(int index);
  inline ::mt::TMTTemplateMember* add_mixmemberlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      mixmemberlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_mixmemberlist();

  // @@protoc_insertion_point(class_scope:mt.TMTGetMixInfo)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  int mode_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > mixmemberlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTGetMixInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoFormatList : public ::google::protobuf::Message {
 public:
  TMTVideoFormatList();
  virtual ~TMTVideoFormatList();

  TMTVideoFormatList(const TMTVideoFormatList& from);

  inline TMTVideoFormatList& operator=(const TMTVideoFormatList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoFormatList& default_instance();

  void Swap(TMTVideoFormatList* other);

  // implements Message ----------------------------------------------

  TMTVideoFormatList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoFormatList& from);
  void MergeFrom(const TMTVideoFormatList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVidFormat videoformat = 1;
  inline bool has_videoformat() const;
  inline void clear_videoformat();
  static const int kVideoformatFieldNumber = 1;
  inline ::mt::EmVidFormat videoformat() const;
  inline void set_videoformat(::mt::EmVidFormat value);

  // optional .mt.EmH264Profile videoprofile = 2;
  inline bool has_videoprofile() const;
  inline void clear_videoprofile();
  static const int kVideoprofileFieldNumber = 2;
  inline ::mt::EmH264Profile videoprofile() const;
  inline void set_videoprofile(::mt::EmH264Profile value);

  // optional .mt.EmMtResolution resolution = 3;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 3;
  inline ::mt::EmMtResolution resolution() const;
  inline void set_resolution(::mt::EmMtResolution value);

  // optional uint32 frame = 4;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 4;
  inline ::google::protobuf::uint32 frame() const;
  inline void set_frame(::google::protobuf::uint32 value);

  // optional uint32 rate = 5;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 5;
  inline ::google::protobuf::uint32 rate() const;
  inline void set_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTVideoFormatList)
 private:
  inline void set_has_videoformat();
  inline void clear_has_videoformat();
  inline void set_has_videoprofile();
  inline void clear_has_videoprofile();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_frame();
  inline void clear_has_frame();
  inline void set_has_rate();
  inline void clear_has_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int videoformat_;
  int videoprofile_;
  int resolution_;
  ::google::protobuf::uint32 frame_;
  ::google::protobuf::uint32 rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoFormatList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAudioFormatList : public ::google::protobuf::Message {
 public:
  TMTAudioFormatList();
  virtual ~TMTAudioFormatList();

  TMTAudioFormatList(const TMTAudioFormatList& from);

  inline TMTAudioFormatList& operator=(const TMTAudioFormatList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAudioFormatList& default_instance();

  void Swap(TMTAudioFormatList* other);

  // implements Message ----------------------------------------------

  TMTAudioFormatList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAudioFormatList& from);
  void MergeFrom(const TMTAudioFormatList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmAudFormat audioformat = 1;
  inline bool has_audioformat() const;
  inline void clear_audioformat();
  static const int kAudioformatFieldNumber = 1;
  inline ::mt::EmAudFormat audioformat() const;
  inline void set_audioformat(::mt::EmAudFormat value);

  // optional .mt.EmAacChnlNum aaccnnlnum = 2;
  inline bool has_aaccnnlnum() const;
  inline void clear_aaccnnlnum();
  static const int kAaccnnlnumFieldNumber = 2;
  inline ::mt::EmAacChnlNum aaccnnlnum() const;
  inline void set_aaccnnlnum(::mt::EmAacChnlNum value);

  // @@protoc_insertion_point(class_scope:mt.TMTAudioFormatList)
 private:
  inline void set_has_audioformat();
  inline void clear_has_audioformat();
  inline void set_has_aaccnnlnum();
  inline void clear_has_aaccnnlnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int audioformat_;
  int aaccnnlnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTAudioFormatList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplateMember : public ::google::protobuf::Message {
 public:
  TMTTemplateMember();
  virtual ~TMTTemplateMember();

  TMTTemplateMember(const TMTTemplateMember& from);

  inline TMTTemplateMember& operator=(const TMTTemplateMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplateMember& default_instance();

  void Swap(TMTTemplateMember* other);

  // implements Message ----------------------------------------------

  TMTTemplateMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplateMember& from);
  void MergeFrom(const TMTTemplateMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional .mt.EmMtAddrType accounttype = 3;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccounttypeFieldNumber = 3;
  inline ::mt::EmMtAddrType accounttype() const;
  inline void set_accounttype(::mt::EmMtAddrType value);

  // @@protoc_insertion_point(class_scope:mt.TMTTemplateMember)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* account_;
  int accounttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplateMember* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplateMultiCast : public ::google::protobuf::Message {
 public:
  TMTTemplateMultiCast();
  virtual ~TMTTemplateMultiCast();

  TMTTemplateMultiCast(const TMTTemplateMultiCast& from);

  inline TMTTemplateMultiCast& operator=(const TMTTemplateMultiCast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplateMultiCast& default_instance();

  void Swap(TMTTemplateMultiCast* other);

  // implements Message ----------------------------------------------

  TMTTemplateMultiCast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplateMultiCast& from);
  void MergeFrom(const TMTTemplateMultiCast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string multicastAddr = 1;
  inline bool has_multicastaddr() const;
  inline void clear_multicastaddr();
  static const int kMulticastAddrFieldNumber = 1;
  inline const ::std::string& multicastaddr() const;
  inline void set_multicastaddr(const ::std::string& value);
  inline void set_multicastaddr(const char* value);
  inline void set_multicastaddr(const char* value, size_t size);
  inline ::std::string* mutable_multicastaddr();
  inline ::std::string* release_multicastaddr();
  inline void set_allocated_multicastaddr(::std::string* multicastaddr);

  // optional bool enable = 2;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 2;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTTemplateMultiCast)
 private:
  inline void set_has_multicastaddr();
  inline void clear_has_multicastaddr();
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* multicastaddr_;
  bool enable_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplateMultiCast* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplateVmpMember : public ::google::protobuf::Message {
 public:
  TMTTemplateVmpMember();
  virtual ~TMTTemplateVmpMember();

  TMTTemplateVmpMember(const TMTTemplateVmpMember& from);

  inline TMTTemplateVmpMember& operator=(const TMTTemplateVmpMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplateVmpMember& default_instance();

  void Swap(TMTTemplateVmpMember* other);

  // implements Message ----------------------------------------------

  TMTTemplateVmpMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplateVmpMember& from);
  void MergeFrom(const TMTTemplateVmpMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional .mt.EmMtAddrType accounttype = 3;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccounttypeFieldNumber = 3;
  inline ::mt::EmMtAddrType accounttype() const;
  inline void set_accounttype(::mt::EmMtAddrType value);

  // optional .mt.EmMtVMPMmbType followtype = 4;
  inline bool has_followtype() const;
  inline void clear_followtype();
  static const int kFollowtypeFieldNumber = 4;
  inline ::mt::EmMtVMPMmbType followtype() const;
  inline void set_followtype(::mt::EmMtVMPMmbType value);

  // optional uint32 index = 5;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional .mt.TMTConfPollInfo poll = 6;
  inline bool has_poll() const;
  inline void clear_poll();
  static const int kPollFieldNumber = 6;
  inline const ::mt::TMTConfPollInfo& poll() const;
  inline ::mt::TMTConfPollInfo* mutable_poll();
  inline ::mt::TMTConfPollInfo* release_poll();
  inline void set_allocated_poll(::mt::TMTConfPollInfo* poll);

  // @@protoc_insertion_point(class_scope:mt.TMTTemplateVmpMember)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_followtype();
  inline void clear_has_followtype();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_poll();
  inline void clear_has_poll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* account_;
  int accounttype_;
  int followtype_;
  ::mt::TMTConfPollInfo* poll_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplateVmpMember* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplateVmp : public ::google::protobuf::Message {
 public:
  TMTTemplateVmp();
  virtual ~TMTTemplateVmp();

  TMTTemplateVmp(const TMTTemplateVmp& from);

  inline TMTTemplateVmp& operator=(const TMTTemplateVmp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplateVmp& default_instance();

  void Swap(TMTTemplateVmp* other);

  // implements Message ----------------------------------------------

  TMTTemplateVmp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplateVmp& from);
  void MergeFrom(const TMTTemplateVmp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional .mt.EmMtVmpStyle style = 2;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 2;
  inline ::mt::EmMtVmpStyle style() const;
  inline void set_style(::mt::EmMtVmpStyle value);

  // optional bool voicehint = 3;
  inline bool has_voicehint() const;
  inline void clear_voicehint();
  static const int kVoicehintFieldNumber = 3;
  inline bool voicehint() const;
  inline void set_voicehint(bool value);

  // optional bool showmtname = 4;
  inline bool has_showmtname() const;
  inline void clear_showmtname();
  static const int kShowmtnameFieldNumber = 4;
  inline bool showmtname() const;
  inline void set_showmtname(bool value);

  // repeated .mt.TMTTemplateVmpMember memberlist = 5;
  inline int memberlist_size() const;
  inline void clear_memberlist();
  static const int kMemberlistFieldNumber = 5;
  inline const ::mt::TMTTemplateVmpMember& memberlist(int index) const;
  inline ::mt::TMTTemplateVmpMember* mutable_memberlist(int index);
  inline ::mt::TMTTemplateVmpMember* add_memberlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateVmpMember >&
      memberlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateVmpMember >*
      mutable_memberlist();

  // optional bool broadcast = 6;
  inline bool has_broadcast() const;
  inline void clear_broadcast();
  static const int kBroadcastFieldNumber = 6;
  inline bool broadcast() const;
  inline void set_broadcast(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTTemplateVmp)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_voicehint();
  inline void clear_has_voicehint();
  inline void set_has_showmtname();
  inline void clear_has_showmtname();
  inline void set_has_broadcast();
  inline void clear_has_broadcast();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int style_;
  bool enable_;
  bool voicehint_;
  bool showmtname_;
  bool broadcast_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateVmpMember > memberlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplateVmp* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTemplatePoll : public ::google::protobuf::Message {
 public:
  TMTTemplatePoll();
  virtual ~TMTTemplatePoll();

  TMTTemplatePoll(const TMTTemplatePoll& from);

  inline TMTTemplatePoll& operator=(const TMTTemplatePoll& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTemplatePoll& default_instance();

  void Swap(TMTTemplatePoll* other);

  // implements Message ----------------------------------------------

  TMTTemplatePoll* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTemplatePoll& from);
  void MergeFrom(const TMTTemplatePoll& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional uint32 interval = 3;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 3;
  inline ::google::protobuf::uint32 interval() const;
  inline void set_interval(::google::protobuf::uint32 value);

  // optional bool speaker = 4;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 4;
  inline bool speaker() const;
  inline void set_speaker(bool value);

  // repeated .mt.TMTTemplateMember memberlist = 5;
  inline int memberlist_size() const;
  inline void clear_memberlist();
  static const int kMemberlistFieldNumber = 5;
  inline const ::mt::TMTTemplateMember& memberlist(int index) const;
  inline ::mt::TMTTemplateMember* mutable_memberlist(int index);
  inline ::mt::TMTTemplateMember* add_memberlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      memberlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_memberlist();

  // @@protoc_insertion_point(class_scope:mt.TMTTemplatePoll)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_interval();
  inline void clear_has_interval();
  inline void set_has_speaker();
  inline void clear_has_speaker();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 num_;
  bool enable_;
  bool speaker_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > memberlist_;
  ::google::protobuf::uint32 interval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTTemplatePoll* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPerTemplateSimpleInfo : public ::google::protobuf::Message {
 public:
  TMTPerTemplateSimpleInfo();
  virtual ~TMTPerTemplateSimpleInfo();

  TMTPerTemplateSimpleInfo(const TMTPerTemplateSimpleInfo& from);

  inline TMTPerTemplateSimpleInfo& operator=(const TMTPerTemplateSimpleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPerTemplateSimpleInfo& default_instance();

  void Swap(TMTPerTemplateSimpleInfo* other);

  // implements Message ----------------------------------------------

  TMTPerTemplateSimpleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPerTemplateSimpleInfo& from);
  void MergeFrom(const TMTPerTemplateSimpleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 templateid = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateidFieldNumber = 1;
  inline ::google::protobuf::uint32 templateid() const;
  inline void set_templateid(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 4;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 4;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmMtResolution resolution = 5;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 5;
  inline ::mt::EmMtResolution resolution() const;
  inline void set_resolution(::mt::EmMtResolution value);

  // @@protoc_insertion_point(class_scope:mt.TMTPerTemplateSimpleInfo)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_resolution();
  inline void clear_has_resolution();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 templateid_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 bitrate_;
  int resolution_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPerTemplateSimpleInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPerTemplateDetail : public ::google::protobuf::Message {
 public:
  TMTPerTemplateDetail();
  virtual ~TMTPerTemplateDetail();

  TMTPerTemplateDetail(const TMTPerTemplateDetail& from);

  inline TMTPerTemplateDetail& operator=(const TMTPerTemplateDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPerTemplateDetail& default_instance();

  void Swap(TMTPerTemplateDetail* other);

  // implements Message ----------------------------------------------

  TMTPerTemplateDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPerTemplateDetail& from);
  void MergeFrom(const TMTPerTemplateDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMTPerTemplateSimpleInfo personaltemplate = 1;
  inline bool has_personaltemplate() const;
  inline void clear_personaltemplate();
  static const int kPersonaltemplateFieldNumber = 1;
  inline const ::mt::TMTPerTemplateSimpleInfo& personaltemplate() const;
  inline ::mt::TMTPerTemplateSimpleInfo* mutable_personaltemplate();
  inline ::mt::TMTPerTemplateSimpleInfo* release_personaltemplate();
  inline void set_allocated_personaltemplate(::mt::TMTPerTemplateSimpleInfo* personaltemplate);

  // repeated .mt.TMTTemplateMember members = 2;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 2;
  inline const ::mt::TMTTemplateMember& members(int index) const;
  inline ::mt::TMTTemplateMember* mutable_members(int index);
  inline ::mt::TMTTemplateMember* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_members();

  // @@protoc_insertion_point(class_scope:mt.TMTPerTemplateDetail)
 private:
  inline void set_has_personaltemplate();
  inline void clear_has_personaltemplate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTPerTemplateSimpleInfo* personaltemplate_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > members_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPerTemplateDetail* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPerTemplateList : public ::google::protobuf::Message {
 public:
  TMTPerTemplateList();
  virtual ~TMTPerTemplateList();

  TMTPerTemplateList(const TMTPerTemplateList& from);

  inline TMTPerTemplateList& operator=(const TMTPerTemplateList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPerTemplateList& default_instance();

  void Swap(TMTPerTemplateList* other);

  // implements Message ----------------------------------------------

  TMTPerTemplateList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPerTemplateList& from);
  void MergeFrom(const TMTPerTemplateList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTPerTemplateDetail templatedetail = 1;
  inline int templatedetail_size() const;
  inline void clear_templatedetail();
  static const int kTemplatedetailFieldNumber = 1;
  inline const ::mt::TMTPerTemplateDetail& templatedetail(int index) const;
  inline ::mt::TMTPerTemplateDetail* mutable_templatedetail(int index);
  inline ::mt::TMTPerTemplateDetail* add_templatedetail();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPerTemplateDetail >&
      templatedetail() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPerTemplateDetail >*
      mutable_templatedetail();

  // @@protoc_insertion_point(class_scope:mt.TMTPerTemplateList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTPerTemplateDetail > templatedetail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPerTemplateList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPerTemplateInfo : public ::google::protobuf::Message {
 public:
  TMTPerTemplateInfo();
  virtual ~TMTPerTemplateInfo();

  TMTPerTemplateInfo(const TMTPerTemplateInfo& from);

  inline TMTPerTemplateInfo& operator=(const TMTPerTemplateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPerTemplateInfo& default_instance();

  void Swap(TMTPerTemplateInfo* other);

  // implements Message ----------------------------------------------

  TMTPerTemplateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPerTemplateInfo& from);
  void MergeFrom(const TMTPerTemplateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 templateid = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateidFieldNumber = 1;
  inline ::google::protobuf::uint32 templateid() const;
  inline void set_templateid(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 4;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 4;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmMtOpenMode meetingsafe = 5;
  inline bool has_meetingsafe() const;
  inline void clear_meetingsafe();
  static const int kMeetingsafeFieldNumber = 5;
  inline ::mt::EmMtOpenMode meetingsafe() const;
  inline void set_meetingsafe(::mt::EmMtOpenMode value);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .mt.EmEncryptArithmetic encryptedtype = 7;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 7;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional string encryptedkey = 8;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 8;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestMeetingSafeType meetingtype = 9;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 9;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional .mt.TMTTemplateSatellite satellite = 10;
  inline bool has_satellite() const;
  inline void clear_satellite();
  static const int kSatelliteFieldNumber = 10;
  inline const ::mt::TMTTemplateSatellite& satellite() const;
  inline ::mt::TMTTemplateSatellite* mutable_satellite();
  inline ::mt::TMTTemplateSatellite* release_satellite();
  inline void set_allocated_satellite(::mt::TMTTemplateSatellite* satellite);

  // optional bool publicmeeting = 11;
  inline bool has_publicmeeting() const;
  inline void clear_publicmeeting();
  static const int kPublicmeetingFieldNumber = 11;
  inline bool publicmeeting() const;
  inline void set_publicmeeting(bool value);

  // optional .mt.TMTGetMixInfo mixinfo = 12;
  inline bool has_mixinfo() const;
  inline void clear_mixinfo();
  static const int kMixinfoFieldNumber = 12;
  inline const ::mt::TMTGetMixInfo& mixinfo() const;
  inline ::mt::TMTGetMixInfo* mutable_mixinfo();
  inline ::mt::TMTGetMixInfo* release_mixinfo();
  inline void set_allocated_mixinfo(::mt::TMTGetMixInfo* mixinfo);

  // repeated .mt.TMTVideoFormatList videoformatlist = 13;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoformatlistFieldNumber = 13;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // repeated .mt.TMTAudioFormatList audioformatlist = 14;
  inline int audioformatlist_size() const;
  inline void clear_audioformatlist();
  static const int kAudioformatlistFieldNumber = 14;
  inline const ::mt::TMTAudioFormatList& audioformatlist(int index) const;
  inline ::mt::TMTAudioFormatList* mutable_audioformatlist(int index);
  inline ::mt::TMTAudioFormatList* add_audioformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
      audioformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
      mutable_audioformatlist();

  // repeated .mt.TMTTemplateMember members = 15;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 15;
  inline const ::mt::TMTTemplateMember& members(int index) const;
  inline ::mt::TMTTemplateMember* mutable_members(int index);
  inline ::mt::TMTTemplateMember* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_members();

  // optional .mt.TMTTemplateMember speaker = 16;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 16;
  inline const ::mt::TMTTemplateMember& speaker() const;
  inline ::mt::TMTTemplateMember* mutable_speaker();
  inline ::mt::TMTTemplateMember* release_speaker();
  inline void set_allocated_speaker(::mt::TMTTemplateMember* speaker);

  // optional .mt.TMTTemplateMember admin = 17;
  inline bool has_admin() const;
  inline void clear_admin();
  static const int kAdminFieldNumber = 17;
  inline const ::mt::TMTTemplateMember& admin() const;
  inline ::mt::TMTTemplateMember* mutable_admin();
  inline ::mt::TMTTemplateMember* release_admin();
  inline void set_allocated_admin(::mt::TMTTemplateMember* admin);

  // optional uint32 calltimes = 18;
  inline bool has_calltimes() const;
  inline void clear_calltimes();
  static const int kCalltimesFieldNumber = 18;
  inline ::google::protobuf::uint32 calltimes() const;
  inline void set_calltimes(::google::protobuf::uint32 value);

  // optional uint32 callinterval = 19;
  inline bool has_callinterval() const;
  inline void clear_callinterval();
  static const int kCallintervalFieldNumber = 19;
  inline ::google::protobuf::uint32 callinterval() const;
  inline void set_callinterval(::google::protobuf::uint32 value);

  // optional bool callchase = 20;
  inline bool has_callchase() const;
  inline void clear_callchase();
  static const int kCallchaseFieldNumber = 20;
  inline bool callchase() const;
  inline void set_callchase(bool value);

  // optional bool initmute = 21;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 21;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional .mt.EmRestVideoQuality videoquality = 22;
  inline bool has_videoquality() const;
  inline void clear_videoquality();
  static const int kVideoqualityFieldNumber = 22;
  inline ::mt::EmRestVideoQuality videoquality() const;
  inline void set_videoquality(::mt::EmRestVideoQuality value);

  // optional .mt.EmRestDualMode dualmode = 23;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 23;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool voiceinspireenable = 24;
  inline bool has_voiceinspireenable() const;
  inline void clear_voiceinspireenable();
  static const int kVoiceinspireenableFieldNumber = 24;
  inline bool voiceinspireenable() const;
  inline void set_voiceinspireenable(bool value);

  // optional .mt.EmRestCascadeMode cascademode = 25;
  inline bool has_cascademode() const;
  inline void clear_cascademode();
  static const int kCascademodeFieldNumber = 25;
  inline ::mt::EmRestCascadeMode cascademode() const;
  inline void set_cascademode(::mt::EmRestCascadeMode value);

  // optional bool cascadeupload = 26;
  inline bool has_cascadeupload() const;
  inline void clear_cascadeupload();
  static const int kCascadeuploadFieldNumber = 26;
  inline bool cascadeupload() const;
  inline void set_cascadeupload(bool value);

  // optional bool cascadereturn = 27;
  inline bool has_cascadereturn() const;
  inline void clear_cascadereturn();
  static const int kCascadereturnFieldNumber = 27;
  inline bool cascadereturn() const;
  inline void set_cascadereturn(bool value);

  // optional uint32 cascadereturnpara = 28;
  inline bool has_cascadereturnpara() const;
  inline void clear_cascadereturnpara();
  static const int kCascadereturnparaFieldNumber = 28;
  inline ::google::protobuf::uint32 cascadereturnpara() const;
  inline void set_cascadereturnpara(::google::protobuf::uint32 value);

  // optional .mt.TMTTemplateRecord record = 29;
  inline bool has_record() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 29;
  inline const ::mt::TMTTemplateRecord& record() const;
  inline ::mt::TMTTemplateRecord* mutable_record();
  inline ::mt::TMTTemplateRecord* release_record();
  inline void set_allocated_record(::mt::TMTTemplateRecord* record);

  // optional .mt.TMTTemplateMultiCast multicast = 30;
  inline bool has_multicast() const;
  inline void clear_multicast();
  static const int kMulticastFieldNumber = 30;
  inline const ::mt::TMTTemplateMultiCast& multicast() const;
  inline ::mt::TMTTemplateMultiCast* mutable_multicast();
  inline ::mt::TMTTemplateMultiCast* release_multicast();
  inline void set_allocated_multicast(::mt::TMTTemplateMultiCast* multicast);

  // repeated .mt.TMTDualFormatList dualformatlist = 31;
  inline int dualformatlist_size() const;
  inline void clear_dualformatlist();
  static const int kDualformatlistFieldNumber = 31;
  inline const ::mt::TMTDualFormatList& dualformatlist(int index) const;
  inline ::mt::TMTDualFormatList* mutable_dualformatlist(int index);
  inline ::mt::TMTDualFormatList* add_dualformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
      dualformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
      mutable_dualformatlist();

  // optional .mt.TMTTemplateVmp vmp = 32;
  inline bool has_vmp() const;
  inline void clear_vmp();
  static const int kVmpFieldNumber = 32;
  inline const ::mt::TMTTemplateVmp& vmp() const;
  inline ::mt::TMTTemplateVmp* mutable_vmp();
  inline ::mt::TMTTemplateVmp* release_vmp();
  inline void set_allocated_vmp(::mt::TMTTemplateVmp* vmp);

  // repeated .mt.TMTTemplateMember viplist = 33;
  inline int viplist_size() const;
  inline void clear_viplist();
  static const int kViplistFieldNumber = 33;
  inline const ::mt::TMTTemplateMember& viplist(int index) const;
  inline ::mt::TMTTemplateMember* mutable_viplist(int index);
  inline ::mt::TMTTemplateMember* add_viplist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      viplist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_viplist();

  // optional .mt.TMTTemplatePoll poll = 34;
  inline bool has_poll() const;
  inline void clear_poll();
  static const int kPollFieldNumber = 34;
  inline const ::mt::TMTTemplatePoll& poll() const;
  inline ::mt::TMTTemplatePoll* mutable_poll();
  inline ::mt::TMTTemplatePoll* release_poll();
  inline void set_allocated_poll(::mt::TMTTemplatePoll* poll);

  // repeated .mt.TMTTemplateMember callchasememberlist = 35;
  inline int callchasememberlist_size() const;
  inline void clear_callchasememberlist();
  static const int kCallchasememberlistFieldNumber = 35;
  inline const ::mt::TMTTemplateMember& callchasememberlist(int index) const;
  inline ::mt::TMTTemplateMember* mutable_callchasememberlist(int index);
  inline ::mt::TMTTemplateMember* add_callchasememberlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      callchasememberlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_callchasememberlist();

  // optional .mt.EmClosedMeeting closedmeeting = 36;
  inline bool has_closedmeeting() const;
  inline void clear_closedmeeting();
  static const int kClosedmeetingFieldNumber = 36;
  inline ::mt::EmClosedMeeting closedmeeting() const;
  inline void set_closedmeeting(::mt::EmClosedMeeting value);

  // optional uint32 meetingscale = 37;
  inline bool has_meetingscale() const;
  inline void clear_meetingscale();
  static const int kMeetingscaleFieldNumber = 37;
  inline ::google::protobuf::uint32 meetingscale() const;
  inline void set_meetingscale(::google::protobuf::uint32 value);

  // optional uint32 onereforming = 38;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOnereformingFieldNumber = 38;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional string presetednumber = 39;
  inline bool has_presetednumber() const;
  inline void clear_presetednumber();
  static const int kPresetednumberFieldNumber = 39;
  inline const ::std::string& presetednumber() const;
  inline void set_presetednumber(const ::std::string& value);
  inline void set_presetednumber(const char* value);
  inline void set_presetednumber(const char* value, size_t size);
  inline ::std::string* mutable_presetednumber();
  inline ::std::string* release_presetednumber();
  inline void set_allocated_presetednumber(::std::string* presetednumber);

  // optional uint32 vioceinspiretime = 40;
  inline bool has_vioceinspiretime() const;
  inline void clear_vioceinspiretime();
  static const int kVioceinspiretimeFieldNumber = 40;
  inline ::google::protobuf::uint32 vioceinspiretime() const;
  inline void set_vioceinspiretime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTPerTemplateInfo)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_meetingsafe();
  inline void clear_has_meetingsafe();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_satellite();
  inline void clear_has_satellite();
  inline void set_has_publicmeeting();
  inline void clear_has_publicmeeting();
  inline void set_has_mixinfo();
  inline void clear_has_mixinfo();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_admin();
  inline void clear_has_admin();
  inline void set_has_calltimes();
  inline void clear_has_calltimes();
  inline void set_has_callinterval();
  inline void clear_has_callinterval();
  inline void set_has_callchase();
  inline void clear_has_callchase();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_videoquality();
  inline void clear_has_videoquality();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_voiceinspireenable();
  inline void clear_has_voiceinspireenable();
  inline void set_has_cascademode();
  inline void clear_has_cascademode();
  inline void set_has_cascadeupload();
  inline void clear_has_cascadeupload();
  inline void set_has_cascadereturn();
  inline void clear_has_cascadereturn();
  inline void set_has_cascadereturnpara();
  inline void clear_has_cascadereturnpara();
  inline void set_has_record();
  inline void clear_has_record();
  inline void set_has_multicast();
  inline void clear_has_multicast();
  inline void set_has_vmp();
  inline void clear_has_vmp();
  inline void set_has_poll();
  inline void clear_has_poll();
  inline void set_has_closedmeeting();
  inline void clear_has_closedmeeting();
  inline void set_has_meetingscale();
  inline void clear_has_meetingscale();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_presetednumber();
  inline void clear_has_presetednumber();
  inline void set_has_vioceinspiretime();
  inline void clear_has_vioceinspiretime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 templateid_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 bitrate_;
  int meetingsafe_;
  ::std::string* password_;
  ::std::string* encryptedkey_;
  int encryptedtype_;
  int meetingtype_;
  ::mt::TMTTemplateSatellite* satellite_;
  ::mt::TMTGetMixInfo* mixinfo_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList > audioformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > members_;
  ::mt::TMTTemplateMember* speaker_;
  ::mt::TMTTemplateMember* admin_;
  ::google::protobuf::uint32 calltimes_;
  ::google::protobuf::uint32 callinterval_;
  bool publicmeeting_;
  bool callchase_;
  bool initmute_;
  bool voiceinspireenable_;
  int videoquality_;
  int dualmode_;
  int cascademode_;
  bool cascadeupload_;
  bool cascadereturn_;
  ::google::protobuf::uint32 cascadereturnpara_;
  ::mt::TMTTemplateRecord* record_;
  ::mt::TMTTemplateMultiCast* multicast_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList > dualformatlist_;
  ::mt::TMTTemplateVmp* vmp_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > viplist_;
  ::mt::TMTTemplatePoll* poll_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > callchasememberlist_;
  int closedmeeting_;
  ::google::protobuf::uint32 meetingscale_;
  ::std::string* presetednumber_;
  ::google::protobuf::uint32 onereforming_;
  ::google::protobuf::uint32 vioceinspiretime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(40 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPerTemplateInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPerTemplate : public ::google::protobuf::Message {
 public:
  TMTPerTemplate();
  virtual ~TMTPerTemplate();

  TMTPerTemplate(const TMTPerTemplate& from);

  inline TMTPerTemplate& operator=(const TMTPerTemplate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPerTemplate& default_instance();

  void Swap(TMTPerTemplate* other);

  // implements Message ----------------------------------------------

  TMTPerTemplate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPerTemplate& from);
  void MergeFrom(const TMTPerTemplate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMTTemplateAccount admin = 1;
  inline bool has_admin() const;
  inline void clear_admin();
  static const int kAdminFieldNumber = 1;
  inline const ::mt::TMTTemplateAccount& admin() const;
  inline ::mt::TMTTemplateAccount* mutable_admin();
  inline ::mt::TMTTemplateAccount* release_admin();
  inline void set_allocated_admin(::mt::TMTTemplateAccount* admin);

  // optional uint32 bitrate = 2;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 2;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmRestDualMode dualmode = 3;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 3;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional string encryptedkey = 4;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 4;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional uint32 duration = 5;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 5;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional .mt.EmEncryptArithmetic encryptedtype = 6;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 6;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional bool initmute = 7;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 7;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional .mt.EmMtOpenMode meetingsafe = 8;
  inline bool has_meetingsafe() const;
  inline void clear_meetingsafe();
  static const int kMeetingsafeFieldNumber = 8;
  inline ::mt::EmMtOpenMode meetingsafe() const;
  inline void set_meetingsafe(::mt::EmMtOpenMode value);

  // optional .mt.EmRestMeetingSafeType meetingtype = 9;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 9;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // repeated .mt.TMTTemplateAccount members = 10;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 10;
  inline const ::mt::TMTTemplateAccount& members(int index) const;
  inline ::mt::TMTTemplateAccount* mutable_members(int index);
  inline ::mt::TMTTemplateAccount* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >*
      mutable_members();

  // optional .mt.TMTSetMixInfo mixinfo = 11;
  inline bool has_mixinfo() const;
  inline void clear_mixinfo();
  static const int kMixinfoFieldNumber = 11;
  inline const ::mt::TMTSetMixInfo& mixinfo() const;
  inline ::mt::TMTSetMixInfo* mutable_mixinfo();
  inline ::mt::TMTSetMixInfo* release_mixinfo();
  inline void set_allocated_mixinfo(::mt::TMTSetMixInfo* mixinfo);

  // optional string name = 12;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 12;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string password = 13;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 13;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional bool publicmeeting = 14;
  inline bool has_publicmeeting() const;
  inline void clear_publicmeeting();
  static const int kPublicmeetingFieldNumber = 14;
  inline bool publicmeeting() const;
  inline void set_publicmeeting(bool value);

  // optional .mt.EmMtResolution resolution = 15;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 15;
  inline ::mt::EmMtResolution resolution() const;
  inline void set_resolution(::mt::EmMtResolution value);

  // optional .mt.TMTTemplateRecord record = 16;
  inline bool has_record() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 16;
  inline const ::mt::TMTTemplateRecord& record() const;
  inline ::mt::TMTTemplateRecord* mutable_record();
  inline ::mt::TMTTemplateRecord* release_record();
  inline void set_allocated_record(::mt::TMTTemplateRecord* record);

  // optional .mt.TMTTemplateSatellite satellite = 17;
  inline bool has_satellite() const;
  inline void clear_satellite();
  static const int kSatelliteFieldNumber = 17;
  inline const ::mt::TMTTemplateSatellite& satellite() const;
  inline ::mt::TMTTemplateSatellite* mutable_satellite();
  inline ::mt::TMTTemplateSatellite* release_satellite();
  inline void set_allocated_satellite(::mt::TMTTemplateSatellite* satellite);

  // optional .mt.TMTTemplateAccount speaker = 18;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 18;
  inline const ::mt::TMTTemplateAccount& speaker() const;
  inline ::mt::TMTTemplateAccount* mutable_speaker();
  inline ::mt::TMTTemplateAccount* release_speaker();
  inline void set_allocated_speaker(::mt::TMTTemplateAccount* speaker);

  // optional uint32 templateid = 19;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateidFieldNumber = 19;
  inline ::google::protobuf::uint32 templateid() const;
  inline void set_templateid(::google::protobuf::uint32 value);

  // repeated .mt.TMTVideoFormatList videoformatlist = 20;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoformatlistFieldNumber = 20;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // repeated .mt.TMTAudioFormatList audioformatlist = 21;
  inline int audioformatlist_size() const;
  inline void clear_audioformatlist();
  static const int kAudioformatlistFieldNumber = 21;
  inline const ::mt::TMTAudioFormatList& audioformatlist(int index) const;
  inline ::mt::TMTAudioFormatList* mutable_audioformatlist(int index);
  inline ::mt::TMTAudioFormatList* add_audioformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
      audioformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
      mutable_audioformatlist();

  // repeated .mt.TMTDualFormatList dualformatlist = 22;
  inline int dualformatlist_size() const;
  inline void clear_dualformatlist();
  static const int kDualformatlistFieldNumber = 22;
  inline const ::mt::TMTDualFormatList& dualformatlist(int index) const;
  inline ::mt::TMTDualFormatList* mutable_dualformatlist(int index);
  inline ::mt::TMTDualFormatList* add_dualformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
      dualformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
      mutable_dualformatlist();

  // repeated .mt.TMTTemplateAccount viplist = 23;
  inline int viplist_size() const;
  inline void clear_viplist();
  static const int kViplistFieldNumber = 23;
  inline const ::mt::TMTTemplateAccount& viplist(int index) const;
  inline ::mt::TMTTemplateAccount* mutable_viplist(int index);
  inline ::mt::TMTTemplateAccount* add_viplist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >&
      viplist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >*
      mutable_viplist();

  // optional .mt.EmClosedMeeting closedmeeting = 24;
  inline bool has_closedmeeting() const;
  inline void clear_closedmeeting();
  static const int kClosedmeetingFieldNumber = 24;
  inline ::mt::EmClosedMeeting closedmeeting() const;
  inline void set_closedmeeting(::mt::EmClosedMeeting value);

  // optional .mt.TMTTemplateVmp vmp = 25;
  inline bool has_vmp() const;
  inline void clear_vmp();
  static const int kVmpFieldNumber = 25;
  inline const ::mt::TMTTemplateVmp& vmp() const;
  inline ::mt::TMTTemplateVmp* mutable_vmp();
  inline ::mt::TMTTemplateVmp* release_vmp();
  inline void set_allocated_vmp(::mt::TMTTemplateVmp* vmp);

  // optional uint32 meetingscale = 26;
  inline bool has_meetingscale() const;
  inline void clear_meetingscale();
  static const int kMeetingscaleFieldNumber = 26;
  inline ::google::protobuf::uint32 meetingscale() const;
  inline void set_meetingscale(::google::protobuf::uint32 value);

  // optional uint32 onereforming = 27;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOnereformingFieldNumber = 27;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional bool voiceinspireenable = 28;
  inline bool has_voiceinspireenable() const;
  inline void clear_voiceinspireenable();
  static const int kVoiceinspireenableFieldNumber = 28;
  inline bool voiceinspireenable() const;
  inline void set_voiceinspireenable(bool value);

  // optional uint32 vioceinspiretime = 29;
  inline bool has_vioceinspiretime() const;
  inline void clear_vioceinspiretime();
  static const int kVioceinspiretimeFieldNumber = 29;
  inline ::google::protobuf::uint32 vioceinspiretime() const;
  inline void set_vioceinspiretime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTPerTemplate)
 private:
  inline void set_has_admin();
  inline void clear_has_admin();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_meetingsafe();
  inline void clear_has_meetingsafe();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_mixinfo();
  inline void clear_has_mixinfo();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_publicmeeting();
  inline void clear_has_publicmeeting();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_record();
  inline void clear_has_record();
  inline void set_has_satellite();
  inline void clear_has_satellite();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_closedmeeting();
  inline void clear_has_closedmeeting();
  inline void set_has_vmp();
  inline void clear_has_vmp();
  inline void set_has_meetingscale();
  inline void clear_has_meetingscale();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_voiceinspireenable();
  inline void clear_has_voiceinspireenable();
  inline void set_has_vioceinspiretime();
  inline void clear_has_vioceinspiretime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTTemplateAccount* admin_;
  ::google::protobuf::uint32 bitrate_;
  int dualmode_;
  ::std::string* encryptedkey_;
  ::google::protobuf::uint32 duration_;
  int encryptedtype_;
  int meetingsafe_;
  int meetingtype_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount > members_;
  ::mt::TMTSetMixInfo* mixinfo_;
  ::std::string* name_;
  ::std::string* password_;
  ::mt::TMTTemplateRecord* record_;
  int resolution_;
  bool initmute_;
  bool publicmeeting_;
  bool voiceinspireenable_;
  ::mt::TMTTemplateSatellite* satellite_;
  ::mt::TMTTemplateAccount* speaker_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList > audioformatlist_;
  ::google::protobuf::uint32 templateid_;
  int closedmeeting_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList > dualformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount > viplist_;
  ::mt::TMTTemplateVmp* vmp_;
  ::google::protobuf::uint32 meetingscale_;
  ::google::protobuf::uint32 onereforming_;
  ::google::protobuf::uint32 vioceinspiretime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPerTemplate* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTGetPubTemplateList : public ::google::protobuf::Message {
 public:
  TMTGetPubTemplateList();
  virtual ~TMTGetPubTemplateList();

  TMTGetPubTemplateList(const TMTGetPubTemplateList& from);

  inline TMTGetPubTemplateList& operator=(const TMTGetPubTemplateList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTGetPubTemplateList& default_instance();

  void Swap(TMTGetPubTemplateList* other);

  // implements Message ----------------------------------------------

  TMTGetPubTemplateList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTGetPubTemplateList& from);
  void MergeFrom(const TMTGetPubTemplateList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 3;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 3;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTGetPubTemplateList)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTGetPubTemplateList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPubTemplateSimpleInfo : public ::google::protobuf::Message {
 public:
  TMTPubTemplateSimpleInfo();
  virtual ~TMTPubTemplateSimpleInfo();

  TMTPubTemplateSimpleInfo(const TMTPubTemplateSimpleInfo& from);

  inline TMTPubTemplateSimpleInfo& operator=(const TMTPubTemplateSimpleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPubTemplateSimpleInfo& default_instance();

  void Swap(TMTPubTemplateSimpleInfo* other);

  // implements Message ----------------------------------------------

  TMTPubTemplateSimpleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPubTemplateSimpleInfo& from);
  void MergeFrom(const TMTPubTemplateSimpleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templatekey = 1;
  inline bool has_templatekey() const;
  inline void clear_templatekey();
  static const int kTemplatekeyFieldNumber = 1;
  inline const ::std::string& templatekey() const;
  inline void set_templatekey(const ::std::string& value);
  inline void set_templatekey(const char* value);
  inline void set_templatekey(const char* value, size_t size);
  inline ::std::string* mutable_templatekey();
  inline ::std::string* release_templatekey();
  inline void set_allocated_templatekey(::std::string* templatekey);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 4;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 4;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmMtResolution resolution = 5;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 5;
  inline ::mt::EmMtResolution resolution() const;
  inline void set_resolution(::mt::EmMtResolution value);

  // @@protoc_insertion_point(class_scope:mt.TMTPubTemplateSimpleInfo)
 private:
  inline void set_has_templatekey();
  inline void clear_has_templatekey();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_resolution();
  inline void clear_has_resolution();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templatekey_;
  ::std::string* name_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 bitrate_;
  int resolution_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPubTemplateSimpleInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPubTemplateList : public ::google::protobuf::Message {
 public:
  TMTPubTemplateList();
  virtual ~TMTPubTemplateList();

  TMTPubTemplateList(const TMTPubTemplateList& from);

  inline TMTPubTemplateList& operator=(const TMTPubTemplateList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPubTemplateList& default_instance();

  void Swap(TMTPubTemplateList* other);

  // implements Message ----------------------------------------------

  TMTPubTemplateList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPubTemplateList& from);
  void MergeFrom(const TMTPubTemplateList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTPubTemplateSimpleInfo pubtemplatesimpleinfo = 1;
  inline int pubtemplatesimpleinfo_size() const;
  inline void clear_pubtemplatesimpleinfo();
  static const int kPubtemplatesimpleinfoFieldNumber = 1;
  inline const ::mt::TMTPubTemplateSimpleInfo& pubtemplatesimpleinfo(int index) const;
  inline ::mt::TMTPubTemplateSimpleInfo* mutable_pubtemplatesimpleinfo(int index);
  inline ::mt::TMTPubTemplateSimpleInfo* add_pubtemplatesimpleinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPubTemplateSimpleInfo >&
      pubtemplatesimpleinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPubTemplateSimpleInfo >*
      mutable_pubtemplatesimpleinfo();

  // @@protoc_insertion_point(class_scope:mt.TMTPubTemplateList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTPubTemplateSimpleInfo > pubtemplatesimpleinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPubTemplateList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPubTemplateInfo : public ::google::protobuf::Message {
 public:
  TMTPubTemplateInfo();
  virtual ~TMTPubTemplateInfo();

  TMTPubTemplateInfo(const TMTPubTemplateInfo& from);

  inline TMTPubTemplateInfo& operator=(const TMTPubTemplateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPubTemplateInfo& default_instance();

  void Swap(TMTPubTemplateInfo* other);

  // implements Message ----------------------------------------------

  TMTPubTemplateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPubTemplateInfo& from);
  void MergeFrom(const TMTPubTemplateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templatekey = 1;
  inline bool has_templatekey() const;
  inline void clear_templatekey();
  static const int kTemplatekeyFieldNumber = 1;
  inline const ::std::string& templatekey() const;
  inline void set_templatekey(const ::std::string& value);
  inline void set_templatekey(const char* value);
  inline void set_templatekey(const char* value, size_t size);
  inline ::std::string* mutable_templatekey();
  inline ::std::string* release_templatekey();
  inline void set_allocated_templatekey(::std::string* templatekey);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 4;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 4;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmMtOpenMode meetingsafe = 5;
  inline bool has_meetingsafe() const;
  inline void clear_meetingsafe();
  static const int kMeetingsafeFieldNumber = 5;
  inline ::mt::EmMtOpenMode meetingsafe() const;
  inline void set_meetingsafe(::mt::EmMtOpenMode value);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .mt.EmEncryptArithmetic encryptedtype = 7;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 7;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional string encryptedkey = 8;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 8;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestMeetingSafeType meetingtype = 9;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 9;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional .mt.TMTTemplateSatellite satellite = 10;
  inline bool has_satellite() const;
  inline void clear_satellite();
  static const int kSatelliteFieldNumber = 10;
  inline const ::mt::TMTTemplateSatellite& satellite() const;
  inline ::mt::TMTTemplateSatellite* mutable_satellite();
  inline ::mt::TMTTemplateSatellite* release_satellite();
  inline void set_allocated_satellite(::mt::TMTTemplateSatellite* satellite);

  // optional bool publicmeeting = 11;
  inline bool has_publicmeeting() const;
  inline void clear_publicmeeting();
  static const int kPublicmeetingFieldNumber = 11;
  inline bool publicmeeting() const;
  inline void set_publicmeeting(bool value);

  // optional .mt.EmMtMixType mixmode = 12;
  inline bool has_mixmode() const;
  inline void clear_mixmode();
  static const int kMixmodeFieldNumber = 12;
  inline ::mt::EmMtMixType mixmode() const;
  inline void set_mixmode(::mt::EmMtMixType value);

  // repeated .mt.TMTVideoFormatList videoformatlist = 13;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoformatlistFieldNumber = 13;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // repeated .mt.TMTAudioFormatList audioformatlist = 14;
  inline int audioformatlist_size() const;
  inline void clear_audioformatlist();
  static const int kAudioformatlistFieldNumber = 14;
  inline const ::mt::TMTAudioFormatList& audioformatlist(int index) const;
  inline ::mt::TMTAudioFormatList* mutable_audioformatlist(int index);
  inline ::mt::TMTAudioFormatList* add_audioformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
      audioformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
      mutable_audioformatlist();

  // optional uint32 calltimes = 15;
  inline bool has_calltimes() const;
  inline void clear_calltimes();
  static const int kCalltimesFieldNumber = 15;
  inline ::google::protobuf::uint32 calltimes() const;
  inline void set_calltimes(::google::protobuf::uint32 value);

  // optional uint32 callinterval = 16;
  inline bool has_callinterval() const;
  inline void clear_callinterval();
  static const int kCallintervalFieldNumber = 16;
  inline ::google::protobuf::uint32 callinterval() const;
  inline void set_callinterval(::google::protobuf::uint32 value);

  // optional bool initmute = 17;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 17;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional .mt.EmRestVideoQuality videoquality = 18;
  inline bool has_videoquality() const;
  inline void clear_videoquality();
  static const int kVideoqualityFieldNumber = 18;
  inline ::mt::EmRestVideoQuality videoquality() const;
  inline void set_videoquality(::mt::EmRestVideoQuality value);

  // optional .mt.EmRestDualMode dualmode = 19;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 19;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool voiceinspireenable = 20;
  inline bool has_voiceinspireenable() const;
  inline void clear_voiceinspireenable();
  static const int kVoiceinspireenableFieldNumber = 20;
  inline bool voiceinspireenable() const;
  inline void set_voiceinspireenable(bool value);

  // optional .mt.EmRestCascadeMode cascademode = 21;
  inline bool has_cascademode() const;
  inline void clear_cascademode();
  static const int kCascademodeFieldNumber = 21;
  inline ::mt::EmRestCascadeMode cascademode() const;
  inline void set_cascademode(::mt::EmRestCascadeMode value);

  // optional bool cascadeupload = 22;
  inline bool has_cascadeupload() const;
  inline void clear_cascadeupload();
  static const int kCascadeuploadFieldNumber = 22;
  inline bool cascadeupload() const;
  inline void set_cascadeupload(bool value);

  // optional bool cascadereturn = 23;
  inline bool has_cascadereturn() const;
  inline void clear_cascadereturn();
  static const int kCascadereturnFieldNumber = 23;
  inline bool cascadereturn() const;
  inline void set_cascadereturn(bool value);

  // optional uint32 cascadereturnpara = 24;
  inline bool has_cascadereturnpara() const;
  inline void clear_cascadereturnpara();
  static const int kCascadereturnparaFieldNumber = 24;
  inline ::google::protobuf::uint32 cascadereturnpara() const;
  inline void set_cascadereturnpara(::google::protobuf::uint32 value);

  // optional .mt.TMTTemplateRecord record = 25;
  inline bool has_record() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 25;
  inline const ::mt::TMTTemplateRecord& record() const;
  inline ::mt::TMTTemplateRecord* mutable_record();
  inline ::mt::TMTTemplateRecord* release_record();
  inline void set_allocated_record(::mt::TMTTemplateRecord* record);

  // optional .mt.TMTTemplateMultiCast multicast = 26;
  inline bool has_multicast() const;
  inline void clear_multicast();
  static const int kMulticastFieldNumber = 26;
  inline const ::mt::TMTTemplateMultiCast& multicast() const;
  inline ::mt::TMTTemplateMultiCast* mutable_multicast();
  inline ::mt::TMTTemplateMultiCast* release_multicast();
  inline void set_allocated_multicast(::mt::TMTTemplateMultiCast* multicast);

  // repeated .mt.TMTDualFormatList dualformatlist = 27;
  inline int dualformatlist_size() const;
  inline void clear_dualformatlist();
  static const int kDualformatlistFieldNumber = 27;
  inline const ::mt::TMTDualFormatList& dualformatlist(int index) const;
  inline ::mt::TMTDualFormatList* mutable_dualformatlist(int index);
  inline ::mt::TMTDualFormatList* add_dualformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
      dualformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
      mutable_dualformatlist();

  // optional .mt.EmClosedMeeting closedmeeting = 28;
  inline bool has_closedmeeting() const;
  inline void clear_closedmeeting();
  static const int kClosedmeetingFieldNumber = 28;
  inline ::mt::EmClosedMeeting closedmeeting() const;
  inline void set_closedmeeting(::mt::EmClosedMeeting value);

  // optional uint32 voiceinspiretime = 29;
  inline bool has_voiceinspiretime() const;
  inline void clear_voiceinspiretime();
  static const int kVoiceinspiretimeFieldNumber = 29;
  inline ::google::protobuf::uint32 voiceinspiretime() const;
  inline void set_voiceinspiretime(::google::protobuf::uint32 value);

  // optional uint32 meetingscale = 30;
  inline bool has_meetingscale() const;
  inline void clear_meetingscale();
  static const int kMeetingscaleFieldNumber = 30;
  inline ::google::protobuf::uint32 meetingscale() const;
  inline void set_meetingscale(::google::protobuf::uint32 value);

  // optional bool onereforming = 31;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOnereformingFieldNumber = 31;
  inline bool onereforming() const;
  inline void set_onereforming(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTPubTemplateInfo)
 private:
  inline void set_has_templatekey();
  inline void clear_has_templatekey();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_meetingsafe();
  inline void clear_has_meetingsafe();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_satellite();
  inline void clear_has_satellite();
  inline void set_has_publicmeeting();
  inline void clear_has_publicmeeting();
  inline void set_has_mixmode();
  inline void clear_has_mixmode();
  inline void set_has_calltimes();
  inline void clear_has_calltimes();
  inline void set_has_callinterval();
  inline void clear_has_callinterval();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_videoquality();
  inline void clear_has_videoquality();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_voiceinspireenable();
  inline void clear_has_voiceinspireenable();
  inline void set_has_cascademode();
  inline void clear_has_cascademode();
  inline void set_has_cascadeupload();
  inline void clear_has_cascadeupload();
  inline void set_has_cascadereturn();
  inline void clear_has_cascadereturn();
  inline void set_has_cascadereturnpara();
  inline void clear_has_cascadereturnpara();
  inline void set_has_record();
  inline void clear_has_record();
  inline void set_has_multicast();
  inline void clear_has_multicast();
  inline void set_has_closedmeeting();
  inline void clear_has_closedmeeting();
  inline void set_has_voiceinspiretime();
  inline void clear_has_voiceinspiretime();
  inline void set_has_meetingscale();
  inline void clear_has_meetingscale();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templatekey_;
  ::std::string* name_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 bitrate_;
  ::std::string* password_;
  int meetingsafe_;
  int encryptedtype_;
  ::std::string* encryptedkey_;
  ::mt::TMTTemplateSatellite* satellite_;
  int meetingtype_;
  int mixmode_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList > audioformatlist_;
  ::google::protobuf::uint32 calltimes_;
  ::google::protobuf::uint32 callinterval_;
  bool publicmeeting_;
  bool initmute_;
  bool voiceinspireenable_;
  bool cascadeupload_;
  int videoquality_;
  int dualmode_;
  int cascademode_;
  ::mt::TMTTemplateRecord* record_;
  ::mt::TMTTemplateMultiCast* multicast_;
  ::google::protobuf::uint32 cascadereturnpara_;
  bool cascadereturn_;
  bool onereforming_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList > dualformatlist_;
  int closedmeeting_;
  ::google::protobuf::uint32 voiceinspiretime_;
  ::google::protobuf::uint32 meetingscale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPubTemplateInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPubTemplate : public ::google::protobuf::Message {
 public:
  TMTPubTemplate();
  virtual ~TMTPubTemplate();

  TMTPubTemplate(const TMTPubTemplate& from);

  inline TMTPubTemplate& operator=(const TMTPubTemplate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPubTemplate& default_instance();

  void Swap(TMTPubTemplate* other);

  // implements Message ----------------------------------------------

  TMTPubTemplate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPubTemplate& from);
  void MergeFrom(const TMTPubTemplate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .mt.EmRestMeetingSafeType meetingtype = 2;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 2;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional uint32 bitrate = 3;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmMtResolution resolution = 4;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 4;
  inline ::mt::EmMtResolution resolution() const;
  inline void set_resolution(::mt::EmMtResolution value);

  // optional .mt.EmMtOpenMode meetingsafe = 5;
  inline bool has_meetingsafe() const;
  inline void clear_meetingsafe();
  static const int kMeetingsafeFieldNumber = 5;
  inline ::mt::EmMtOpenMode meetingsafe() const;
  inline void set_meetingsafe(::mt::EmMtOpenMode value);

  // optional .mt.EmEncryptArithmetic encryptedtype = 6;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 6;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional string encryptedkey = 7;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 7;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestDualMode dualmode = 8;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 8;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional uint32 duration = 9;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 9;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional .mt.EmMtMixType mixmode = 10;
  inline bool has_mixmode() const;
  inline void clear_mixmode();
  static const int kMixmodeFieldNumber = 10;
  inline ::mt::EmMtMixType mixmode() const;
  inline void set_mixmode(::mt::EmMtMixType value);

  // optional .mt.TMTTemplateSatellite satellite = 11;
  inline bool has_satellite() const;
  inline void clear_satellite();
  static const int kSatelliteFieldNumber = 11;
  inline const ::mt::TMTTemplateSatellite& satellite() const;
  inline ::mt::TMTTemplateSatellite* mutable_satellite();
  inline ::mt::TMTTemplateSatellite* release_satellite();
  inline void set_allocated_satellite(::mt::TMTTemplateSatellite* satellite);

  // optional bool publicmeeting = 12;
  inline bool has_publicmeeting() const;
  inline void clear_publicmeeting();
  static const int kPublicmeetingFieldNumber = 12;
  inline bool publicmeeting() const;
  inline void set_publicmeeting(bool value);

  // repeated .mt.TMTVideoFormatList videoformatlist = 13;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoformatlistFieldNumber = 13;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // repeated .mt.TMTDualFormatList dualformatlist = 14;
  inline int dualformatlist_size() const;
  inline void clear_dualformatlist();
  static const int kDualformatlistFieldNumber = 14;
  inline const ::mt::TMTDualFormatList& dualformatlist(int index) const;
  inline ::mt::TMTDualFormatList* mutable_dualformatlist(int index);
  inline ::mt::TMTDualFormatList* add_dualformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
      dualformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
      mutable_dualformatlist();

  // repeated .mt.TMTAudioFormatList audioformatlist = 15;
  inline int audioformatlist_size() const;
  inline void clear_audioformatlist();
  static const int kAudioformatlistFieldNumber = 15;
  inline const ::mt::TMTAudioFormatList& audioformatlist(int index) const;
  inline ::mt::TMTAudioFormatList* mutable_audioformatlist(int index);
  inline ::mt::TMTAudioFormatList* add_audioformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
      audioformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
      mutable_audioformatlist();

  // optional .mt.EmClosedMeeting closedmeeting = 16;
  inline bool has_closedmeeting() const;
  inline void clear_closedmeeting();
  static const int kClosedmeetingFieldNumber = 16;
  inline ::mt::EmClosedMeeting closedmeeting() const;
  inline void set_closedmeeting(::mt::EmClosedMeeting value);

  // optional bool encrypted_auth = 17;
  inline bool has_encrypted_auth() const;
  inline void clear_encrypted_auth();
  static const int kEncryptedAuthFieldNumber = 17;
  inline bool encrypted_auth() const;
  inline void set_encrypted_auth(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTPubTemplate)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_meetingsafe();
  inline void clear_has_meetingsafe();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_mixmode();
  inline void clear_has_mixmode();
  inline void set_has_satellite();
  inline void clear_has_satellite();
  inline void set_has_publicmeeting();
  inline void clear_has_publicmeeting();
  inline void set_has_closedmeeting();
  inline void clear_has_closedmeeting();
  inline void set_has_encrypted_auth();
  inline void clear_has_encrypted_auth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  int meetingtype_;
  ::google::protobuf::uint32 bitrate_;
  int resolution_;
  int meetingsafe_;
  ::std::string* encryptedkey_;
  int encryptedtype_;
  int dualmode_;
  ::google::protobuf::uint32 duration_;
  int mixmode_;
  ::mt::TMTTemplateSatellite* satellite_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList > dualformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList > audioformatlist_;
  bool publicmeeting_;
  bool encrypted_auth_;
  int closedmeeting_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPubTemplate* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCometdMessage : public ::google::protobuf::Message {
 public:
  TMTCometdMessage();
  virtual ~TMTCometdMessage();

  TMTCometdMessage(const TMTCometdMessage& from);

  inline TMTCometdMessage& operator=(const TMTCometdMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCometdMessage& default_instance();

  void Swap(TMTCometdMessage* other);

  // implements Message ----------------------------------------------

  TMTCometdMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCometdMessage& from);
  void MergeFrom(const TMTCometdMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmRestMeetingNotifyType messagetype = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessagetypeFieldNumber = 1;
  inline ::mt::EmRestMeetingNotifyType messagetype() const;
  inline void set_messagetype(::mt::EmRestMeetingNotifyType value);

  // optional uint32 notifyid = 2;
  inline bool has_notifyid() const;
  inline void clear_notifyid();
  static const int kNotifyidFieldNumber = 2;
  inline ::google::protobuf::uint32 notifyid() const;
  inline void set_notifyid(::google::protobuf::uint32 value);

  // optional uint32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTCometdMessage)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_notifyid();
  inline void clear_has_notifyid();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int messagetype_;
  ::google::protobuf::uint32 notifyid_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTCometdMessage* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCometdMessageList : public ::google::protobuf::Message {
 public:
  TMTCometdMessageList();
  virtual ~TMTCometdMessageList();

  TMTCometdMessageList(const TMTCometdMessageList& from);

  inline TMTCometdMessageList& operator=(const TMTCometdMessageList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCometdMessageList& default_instance();

  void Swap(TMTCometdMessageList* other);

  // implements Message ----------------------------------------------

  TMTCometdMessageList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCometdMessageList& from);
  void MergeFrom(const TMTCometdMessageList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTCometdMessage cometdmessagelist = 1;
  inline int cometdmessagelist_size() const;
  inline void clear_cometdmessagelist();
  static const int kCometdmessagelistFieldNumber = 1;
  inline const ::mt::TMTCometdMessage& cometdmessagelist(int index) const;
  inline ::mt::TMTCometdMessage* mutable_cometdmessagelist(int index);
  inline ::mt::TMTCometdMessage* add_cometdmessagelist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTCometdMessage >&
      cometdmessagelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTCometdMessage >*
      mutable_cometdmessagelist();

  // @@protoc_insertion_point(class_scope:mt.TMTCometdMessageList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTCometdMessage > cometdmessagelist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTCometdMessageList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfMixInfo : public ::google::protobuf::Message {
 public:
  TMTConfMixInfo();
  virtual ~TMTConfMixInfo();

  TMTConfMixInfo(const TMTConfMixInfo& from);

  inline TMTConfMixInfo& operator=(const TMTConfMixInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfMixInfo& default_instance();

  void Swap(TMTConfMixInfo* other);

  // implements Message ----------------------------------------------

  TMTConfMixInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfMixInfo& from);
  void MergeFrom(const TMTConfMixInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtMixType mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::mt::EmMtMixType mode() const;
  inline void set_mode(::mt::EmMtMixType value);

  // repeated .mt.TMTTemplateMember mixmemberlist = 2;
  inline int mixmemberlist_size() const;
  inline void clear_mixmemberlist();
  static const int kMixmemberlistFieldNumber = 2;
  inline const ::mt::TMTTemplateMember& mixmemberlist(int index) const;
  inline ::mt::TMTTemplateMember* mutable_mixmemberlist(int index);
  inline ::mt::TMTTemplateMember* add_mixmemberlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      mixmemberlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_mixmemberlist();

  // @@protoc_insertion_point(class_scope:mt.TMTConfMixInfo)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > mixmemberlist_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfMixInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfMixBrief : public ::google::protobuf::Message {
 public:
  TMTConfMixBrief();
  virtual ~TMTConfMixBrief();

  TMTConfMixBrief(const TMTConfMixBrief& from);

  inline TMTConfMixBrief& operator=(const TMTConfMixBrief& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfMixBrief& default_instance();

  void Swap(TMTConfMixBrief* other);

  // implements Message ----------------------------------------------

  TMTConfMixBrief* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfMixBrief& from);
  void MergeFrom(const TMTConfMixBrief& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtMixType mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::mt::EmMtMixType mode() const;
  inline void set_mode(::mt::EmMtMixType value);

  // @@protoc_insertion_point(class_scope:mt.TMTConfMixBrief)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfMixBrief* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfSatelliteInfo : public ::google::protobuf::Message {
 public:
  TMTConfSatelliteInfo();
  virtual ~TMTConfSatelliteInfo();

  TMTConfSatelliteInfo(const TMTConfSatelliteInfo& from);

  inline TMTConfSatelliteInfo& operator=(const TMTConfSatelliteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfSatelliteInfo& default_instance();

  void Swap(TMTConfSatelliteInfo* other);

  // implements Message ----------------------------------------------

  TMTConfSatelliteInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfSatelliteInfo& from);
  void MergeFrom(const TMTConfSatelliteInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string multicastaddr = 1;
  inline bool has_multicastaddr() const;
  inline void clear_multicastaddr();
  static const int kMulticastaddrFieldNumber = 1;
  inline const ::std::string& multicastaddr() const;
  inline void set_multicastaddr(const ::std::string& value);
  inline void set_multicastaddr(const char* value);
  inline void set_multicastaddr(const char* value, size_t size);
  inline ::std::string* mutable_multicastaddr();
  inline ::std::string* release_multicastaddr();
  inline void set_allocated_multicastaddr(::std::string* multicastaddr);

  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional uint32 returnnum = 3;
  inline bool has_returnnum() const;
  inline void clear_returnnum();
  static const int kReturnnumFieldNumber = 3;
  inline ::google::protobuf::uint32 returnnum() const;
  inline void set_returnnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTConfSatelliteInfo)
 private:
  inline void set_has_multicastaddr();
  inline void clear_has_multicastaddr();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_returnnum();
  inline void clear_has_returnnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* multicastaddr_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 returnnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfSatelliteInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfRecordInfo : public ::google::protobuf::Message {
 public:
  TMTConfRecordInfo();
  virtual ~TMTConfRecordInfo();

  TMTConfRecordInfo(const TMTConfRecordInfo& from);

  inline TMTConfRecordInfo& operator=(const TMTConfRecordInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfRecordInfo& default_instance();

  void Swap(TMTConfRecordInfo* other);

  // implements Message ----------------------------------------------

  TMTConfRecordInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfRecordInfo& from);
  void MergeFrom(const TMTConfRecordInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool doubleflow = 1;
  inline bool has_doubleflow() const;
  inline void clear_doubleflow();
  static const int kDoubleflowFieldNumber = 1;
  inline bool doubleflow() const;
  inline void set_doubleflow(bool value);

  // optional bool main = 2;
  inline bool has_main() const;
  inline void clear_main();
  static const int kMainFieldNumber = 2;
  inline bool main() const;
  inline void set_main(bool value);

  // optional bool publish = 3;
  inline bool has_publish() const;
  inline void clear_publish();
  static const int kPublishFieldNumber = 3;
  inline bool publish() const;
  inline void set_publish(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTConfRecordInfo)
 private:
  inline void set_has_doubleflow();
  inline void clear_has_doubleflow();
  inline void set_has_main();
  inline void clear_has_main();
  inline void set_has_publish();
  inline void clear_has_publish();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool doubleflow_;
  bool main_;
  bool publish_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfRecordInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfMultiCastInfo : public ::google::protobuf::Message {
 public:
  TMTConfMultiCastInfo();
  virtual ~TMTConfMultiCastInfo();

  TMTConfMultiCastInfo(const TMTConfMultiCastInfo& from);

  inline TMTConfMultiCastInfo& operator=(const TMTConfMultiCastInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfMultiCastInfo& default_instance();

  void Swap(TMTConfMultiCastInfo* other);

  // implements Message ----------------------------------------------

  TMTConfMultiCastInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfMultiCastInfo& from);
  void MergeFrom(const TMTConfMultiCastInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string multicastAddr = 1;
  inline bool has_multicastaddr() const;
  inline void clear_multicastaddr();
  static const int kMulticastAddrFieldNumber = 1;
  inline const ::std::string& multicastaddr() const;
  inline void set_multicastaddr(const ::std::string& value);
  inline void set_multicastaddr(const char* value);
  inline void set_multicastaddr(const char* value, size_t size);
  inline ::std::string* mutable_multicastaddr();
  inline ::std::string* release_multicastaddr();
  inline void set_allocated_multicastaddr(::std::string* multicastaddr);

  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTConfMultiCastInfo)
 private:
  inline void set_has_multicastaddr();
  inline void clear_has_multicastaddr();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* multicastaddr_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfMultiCastInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfVMPInfo : public ::google::protobuf::Message {
 public:
  TMTConfVMPInfo();
  virtual ~TMTConfVMPInfo();

  TMTConfVMPInfo(const TMTConfVMPInfo& from);

  inline TMTConfVMPInfo& operator=(const TMTConfVMPInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfVMPInfo& default_instance();

  void Swap(TMTConfVMPInfo* other);

  // implements Message ----------------------------------------------

  TMTConfVMPInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfVMPInfo& from);
  void MergeFrom(const TMTConfVMPInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtVmpStyle style = 1;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 1;
  inline ::mt::EmMtVmpStyle style() const;
  inline void set_style(::mt::EmMtVmpStyle value);

  // optional bool voicehint = 2;
  inline bool has_voicehint() const;
  inline void clear_voicehint();
  static const int kVoicehintFieldNumber = 2;
  inline bool voicehint() const;
  inline void set_voicehint(bool value);

  // optional bool showmtname = 3;
  inline bool has_showmtname() const;
  inline void clear_showmtname();
  static const int kShowmtnameFieldNumber = 3;
  inline bool showmtname() const;
  inline void set_showmtname(bool value);

  // repeated .mt.TMTTemplateVmpMember memberlist = 4;
  inline int memberlist_size() const;
  inline void clear_memberlist();
  static const int kMemberlistFieldNumber = 4;
  inline const ::mt::TMTTemplateVmpMember& memberlist(int index) const;
  inline ::mt::TMTTemplateVmpMember* mutable_memberlist(int index);
  inline ::mt::TMTTemplateVmpMember* add_memberlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateVmpMember >&
      memberlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateVmpMember >*
      mutable_memberlist();

  // optional bool broadcast = 5;
  inline bool has_broadcast() const;
  inline void clear_broadcast();
  static const int kBroadcastFieldNumber = 5;
  inline bool broadcast() const;
  inline void set_broadcast(bool value);

  // optional bool enable = 6;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 6;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional .mt.EmVmpMode mode = 7;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 7;
  inline ::mt::EmVmpMode mode() const;
  inline void set_mode(::mt::EmVmpMode value);

  // optional .mt.TMTVMtNameStyle mtnamestyle = 8;
  inline bool has_mtnamestyle() const;
  inline void clear_mtnamestyle();
  static const int kMtnamestyleFieldNumber = 8;
  inline const ::mt::TMTVMtNameStyle& mtnamestyle() const;
  inline ::mt::TMTVMtNameStyle* mutable_mtnamestyle();
  inline ::mt::TMTVMtNameStyle* release_mtnamestyle();
  inline void set_allocated_mtnamestyle(::mt::TMTVMtNameStyle* mtnamestyle);

  // @@protoc_insertion_point(class_scope:mt.TMTConfVMPInfo)
 private:
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_voicehint();
  inline void clear_has_voicehint();
  inline void set_has_showmtname();
  inline void clear_has_showmtname();
  inline void set_has_broadcast();
  inline void clear_has_broadcast();
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_mtnamestyle();
  inline void clear_has_mtnamestyle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int style_;
  bool voicehint_;
  bool showmtname_;
  bool broadcast_;
  bool enable_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateVmpMember > memberlist_;
  ::mt::TMTVMtNameStyle* mtnamestyle_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfVMPInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfVMPBrief : public ::google::protobuf::Message {
 public:
  TMTConfVMPBrief();
  virtual ~TMTConfVMPBrief();

  TMTConfVMPBrief(const TMTConfVMPBrief& from);

  inline TMTConfVMPBrief& operator=(const TMTConfVMPBrief& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfVMPBrief& default_instance();

  void Swap(TMTConfVMPBrief* other);

  // implements Message ----------------------------------------------

  TMTConfVMPBrief* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfVMPBrief& from);
  void MergeFrom(const TMTConfVMPBrief& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional .mt.EmVmpMode mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::mt::EmVmpMode mode() const;
  inline void set_mode(::mt::EmVmpMode value);

  // @@protoc_insertion_point(class_scope:mt.TMTConfVMPBrief)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfVMPBrief* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfPollInfo : public ::google::protobuf::Message {
 public:
  TMTConfPollInfo();
  virtual ~TMTConfPollInfo();

  TMTConfPollInfo(const TMTConfPollInfo& from);

  inline TMTConfPollInfo& operator=(const TMTConfPollInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfPollInfo& default_instance();

  void Swap(TMTConfPollInfo* other);

  // implements Message ----------------------------------------------

  TMTConfPollInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfPollInfo& from);
  void MergeFrom(const TMTConfPollInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional uint32 interval = 2;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 interval() const;
  inline void set_interval(::google::protobuf::uint32 value);

  // repeated .mt.TMTTemplateMember memberlist = 3;
  inline int memberlist_size() const;
  inline void clear_memberlist();
  static const int kMemberlistFieldNumber = 3;
  inline const ::mt::TMTTemplateMember& memberlist(int index) const;
  inline ::mt::TMTTemplateMember* mutable_memberlist(int index);
  inline ::mt::TMTTemplateMember* add_memberlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      memberlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_memberlist();

  // optional bool enable = 4;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 4;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional .mt.EmPollMode mode = 5;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 5;
  inline ::mt::EmPollMode mode() const;
  inline void set_mode(::mt::EmPollMode value);

  // @@protoc_insertion_point(class_scope:mt.TMTConfPollInfo)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_interval();
  inline void clear_has_interval();
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 interval_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > memberlist_;
  bool enable_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfPollInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRecordAttribute : public ::google::protobuf::Message {
 public:
  TMTRecordAttribute();
  virtual ~TMTRecordAttribute();

  TMTRecordAttribute(const TMTRecordAttribute& from);

  inline TMTRecordAttribute& operator=(const TMTRecordAttribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRecordAttribute& default_instance();

  void Swap(TMTRecordAttribute* other);

  // implements Message ----------------------------------------------

  TMTRecordAttribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRecordAttribute& from);
  void MergeFrom(const TMTRecordAttribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmPublishMode emPublishMode = 1;
  inline bool has_empublishmode() const;
  inline void clear_empublishmode();
  static const int kEmPublishModeFieldNumber = 1;
  inline ::mt::EmPublishMode empublishmode() const;
  inline void set_empublishmode(::mt::EmPublishMode value);

  // optional .mt.EmRecordMode emRecordMode = 2;
  inline bool has_emrecordmode() const;
  inline void clear_emrecordmode();
  static const int kEmRecordModeFieldNumber = 2;
  inline ::mt::EmRecordMode emrecordmode() const;
  inline void set_emrecordmode(::mt::EmRecordMode value);

  // optional bool bAnonymous = 3;
  inline bool has_banonymous() const;
  inline void clear_banonymous();
  static const int kBAnonymousFieldNumber = 3;
  inline bool banonymous() const;
  inline void set_banonymous(bool value);

  // optional bool bDualStream = 4;
  inline bool has_bdualstream() const;
  inline void clear_bdualstream();
  static const int kBDualStreamFieldNumber = 4;
  inline bool bdualstream() const;
  inline void set_bdualstream(bool value);

  // optional string vrsId = 5;
  inline bool has_vrsid() const;
  inline void clear_vrsid();
  static const int kVrsIdFieldNumber = 5;
  inline const ::std::string& vrsid() const;
  inline void set_vrsid(const ::std::string& value);
  inline void set_vrsid(const char* value);
  inline void set_vrsid(const char* value, size_t size);
  inline ::std::string* mutable_vrsid();
  inline ::std::string* release_vrsid();
  inline void set_allocated_vrsid(::std::string* vrsid);

  // @@protoc_insertion_point(class_scope:mt.TMTRecordAttribute)
 private:
  inline void set_has_empublishmode();
  inline void clear_has_empublishmode();
  inline void set_has_emrecordmode();
  inline void clear_has_emrecordmode();
  inline void set_has_banonymous();
  inline void clear_has_banonymous();
  inline void set_has_bdualstream();
  inline void clear_has_bdualstream();
  inline void set_has_vrsid();
  inline void clear_has_vrsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int empublishmode_;
  int emrecordmode_;
  ::std::string* vrsid_;
  bool banonymous_;
  bool bdualstream_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRecordAttribute* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRecordAttributeBrief : public ::google::protobuf::Message {
 public:
  TMTRecordAttributeBrief();
  virtual ~TMTRecordAttributeBrief();

  TMTRecordAttributeBrief(const TMTRecordAttributeBrief& from);

  inline TMTRecordAttributeBrief& operator=(const TMTRecordAttributeBrief& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRecordAttributeBrief& default_instance();

  void Swap(TMTRecordAttributeBrief* other);

  // implements Message ----------------------------------------------

  TMTRecordAttributeBrief* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRecordAttributeBrief& from);
  void MergeFrom(const TMTRecordAttributeBrief& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmRecordMode emRecordMode = 1;
  inline bool has_emrecordmode() const;
  inline void clear_emrecordmode();
  static const int kEmRecordModeFieldNumber = 1;
  inline ::mt::EmRecordMode emrecordmode() const;
  inline void set_emrecordmode(::mt::EmRecordMode value);

  // optional string vrsId = 2;
  inline bool has_vrsid() const;
  inline void clear_vrsid();
  static const int kVrsIdFieldNumber = 2;
  inline const ::std::string& vrsid() const;
  inline void set_vrsid(const ::std::string& value);
  inline void set_vrsid(const char* value);
  inline void set_vrsid(const char* value, size_t size);
  inline ::std::string* mutable_vrsid();
  inline ::std::string* release_vrsid();
  inline void set_allocated_vrsid(::std::string* vrsid);

  // @@protoc_insertion_point(class_scope:mt.TMTRecordAttributeBrief)
 private:
  inline void set_has_emrecordmode();
  inline void clear_has_emrecordmode();
  inline void set_has_vrsid();
  inline void clear_has_vrsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* vrsid_;
  int emrecordmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRecordAttributeBrief* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTDCSAttribute : public ::google::protobuf::Message {
 public:
  TMTDCSAttribute();
  virtual ~TMTDCSAttribute();

  TMTDCSAttribute(const TMTDCSAttribute& from);

  inline TMTDCSAttribute& operator=(const TMTDCSAttribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTDCSAttribute& default_instance();

  void Swap(TMTDCSAttribute* other);

  // implements Message ----------------------------------------------

  TMTDCSAttribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTDCSAttribute& from);
  void MergeFrom(const TMTDCSAttribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtDcsConfMode emDCSMode = 1;
  inline bool has_emdcsmode() const;
  inline void clear_emdcsmode();
  static const int kEmDCSModeFieldNumber = 1;
  inline ::mt::EmMtDcsConfMode emdcsmode() const;
  inline void set_emdcsmode(::mt::EmMtDcsConfMode value);

  // @@protoc_insertion_point(class_scope:mt.TMTDCSAttribute)
 private:
  inline void set_has_emdcsmode();
  inline void clear_has_emdcsmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emdcsmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTDCSAttribute* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTInviteMember : public ::google::protobuf::Message {
 public:
  TMTInviteMember();
  virtual ~TMTInviteMember();

  TMTInviteMember(const TMTInviteMember& from);

  inline TMTInviteMember& operator=(const TMTInviteMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTInviteMember& default_instance();

  void Swap(TMTInviteMember* other);

  // implements Message ----------------------------------------------

  TMTInviteMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTInviteMember& from);
  void MergeFrom(const TMTInviteMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional .mt.EmMtAddrType accounttype = 3;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccounttypeFieldNumber = 3;
  inline ::mt::EmMtAddrType accounttype() const;
  inline void set_accounttype(::mt::EmMtAddrType value);

  // optional .mt.EmConfProtocol protocol = 4;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 4;
  inline ::mt::EmConfProtocol protocol() const;
  inline void set_protocol(::mt::EmConfProtocol value);

  // @@protoc_insertion_point(class_scope:mt.TMTInviteMember)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_protocol();
  inline void clear_has_protocol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* account_;
  int accounttype_;
  int protocol_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTInviteMember* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPeronalTemplate : public ::google::protobuf::Message {
 public:
  TMTPeronalTemplate();
  virtual ~TMTPeronalTemplate();

  TMTPeronalTemplate(const TMTPeronalTemplate& from);

  inline TMTPeronalTemplate& operator=(const TMTPeronalTemplate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPeronalTemplate& default_instance();

  void Swap(TMTPeronalTemplate* other);

  // implements Message ----------------------------------------------

  TMTPeronalTemplate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPeronalTemplate& from);
  void MergeFrom(const TMTPeronalTemplate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 bitrate = 2;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 2;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmClosedMeeting closeConf = 3;
  inline bool has_closeconf() const;
  inline void clear_closeconf();
  static const int kCloseConfFieldNumber = 3;
  inline ::mt::EmClosedMeeting closeconf() const;
  inline void set_closeconf(::mt::EmClosedMeeting value);

  // optional .mt.EmMtOpenMode safeConf = 4;
  inline bool has_safeconf() const;
  inline void clear_safeconf();
  static const int kSafeConfFieldNumber = 4;
  inline ::mt::EmMtOpenMode safeconf() const;
  inline void set_safeconf(::mt::EmMtOpenMode value);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .mt.EmEncryptArithmetic encryptedtype = 6;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 6;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional .mt.EmRestMeetingSafeType meetingtype = 7;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 7;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional uint32 callTimes = 8;
  inline bool has_calltimes() const;
  inline void clear_calltimes();
  static const int kCallTimesFieldNumber = 8;
  inline ::google::protobuf::uint32 calltimes() const;
  inline void set_calltimes(::google::protobuf::uint32 value);

  // optional uint32 callInterval = 9;
  inline bool has_callinterval() const;
  inline void clear_callinterval();
  static const int kCallIntervalFieldNumber = 9;
  inline ::google::protobuf::uint32 callinterval() const;
  inline void set_callinterval(::google::protobuf::uint32 value);

  // optional bool initmute = 10;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 10;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional bool initSilence = 11;
  inline bool has_initsilence() const;
  inline void clear_initsilence();
  static const int kInitSilenceFieldNumber = 11;
  inline bool initsilence() const;
  inline void set_initsilence(bool value);

  // optional .mt.EmRestVideoQuality vidoQuality = 12;
  inline bool has_vidoquality() const;
  inline void clear_vidoquality();
  static const int kVidoQualityFieldNumber = 12;
  inline ::mt::EmRestVideoQuality vidoquality() const;
  inline void set_vidoquality(::mt::EmRestVideoQuality value);

  // optional uint32 oneReforming = 13;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOneReformingFieldNumber = 13;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional string encryptedkey = 14;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 14;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestDualMode dualmode = 15;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 15;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool voiceActivityDetection = 16;
  inline bool has_voiceactivitydetection() const;
  inline void clear_voiceactivitydetection();
  static const int kVoiceActivityDetectionFieldNumber = 16;
  inline bool voiceactivitydetection() const;
  inline void set_voiceactivitydetection(bool value);

  // optional uint32 vacinterval = 17;
  inline bool has_vacinterval() const;
  inline void clear_vacinterval();
  static const int kVacintervalFieldNumber = 17;
  inline ::google::protobuf::uint32 vacinterval() const;
  inline void set_vacinterval(::google::protobuf::uint32 value);

  // optional .mt.EmRestCascadeMode emCascadeMode = 18;
  inline bool has_emcascademode() const;
  inline void clear_emcascademode();
  static const int kEmCascadeModeFieldNumber = 18;
  inline ::mt::EmRestCascadeMode emcascademode() const;
  inline void set_emcascademode(::mt::EmRestCascadeMode value);

  // optional bool cascadeUpload = 19;
  inline bool has_cascadeupload() const;
  inline void clear_cascadeupload();
  static const int kCascadeUploadFieldNumber = 19;
  inline bool cascadeupload() const;
  inline void set_cascadeupload(bool value);

  // optional bool cascadeReturn = 20;
  inline bool has_cascadereturn() const;
  inline void clear_cascadereturn();
  static const int kCascadeReturnFieldNumber = 20;
  inline bool cascadereturn() const;
  inline void set_cascadereturn(bool value);

  // optional uint32 cascadeReturnPara = 21;
  inline bool has_cascadereturnpara() const;
  inline void clear_cascadereturnpara();
  static const int kCascadeReturnParaFieldNumber = 21;
  inline ::google::protobuf::uint32 cascadereturnpara() const;
  inline void set_cascadereturnpara(::google::protobuf::uint32 value);

  // optional bool publicConf = 22;
  inline bool has_publicconf() const;
  inline void clear_publicconf();
  static const int kPublicConfFieldNumber = 22;
  inline bool publicconf() const;
  inline void set_publicconf(bool value);

  // optional uint32 maxJoinMt = 23;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxJoinMtFieldNumber = 23;
  inline ::google::protobuf::uint32 maxjoinmt() const;
  inline void set_maxjoinmt(::google::protobuf::uint32 value);

  // optional bool autoEnd = 24;
  inline bool has_autoend() const;
  inline void clear_autoend();
  static const int kAutoEndFieldNumber = 24;
  inline bool autoend() const;
  inline void set_autoend(bool value);

  // optional bool preoccpuyResouce = 25;
  inline bool has_preoccpuyresouce() const;
  inline void clear_preoccpuyresouce();
  static const int kPreoccpuyResouceFieldNumber = 25;
  inline bool preoccpuyresouce() const;
  inline void set_preoccpuyresouce(bool value);

  // optional .mt.TMTTemplateMember speaker = 26;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 26;
  inline const ::mt::TMTTemplateMember& speaker() const;
  inline ::mt::TMTTemplateMember* mutable_speaker();
  inline ::mt::TMTTemplateMember* release_speaker();
  inline void set_allocated_speaker(::mt::TMTTemplateMember* speaker);

  // optional .mt.TMTTemplateMember chairman = 27;
  inline bool has_chairman() const;
  inline void clear_chairman();
  static const int kChairmanFieldNumber = 27;
  inline const ::mt::TMTTemplateMember& chairman() const;
  inline ::mt::TMTTemplateMember* mutable_chairman();
  inline ::mt::TMTTemplateMember* release_chairman();
  inline void set_allocated_chairman(::mt::TMTTemplateMember* chairman);

  // optional .mt.TMTConfMixInfo mix = 28;
  inline bool has_mix() const;
  inline void clear_mix();
  static const int kMixFieldNumber = 28;
  inline const ::mt::TMTConfMixInfo& mix() const;
  inline ::mt::TMTConfMixInfo* mutable_mix();
  inline ::mt::TMTConfMixInfo* release_mix();
  inline void set_allocated_mix(::mt::TMTConfMixInfo* mix);

  // repeated .mt.TMTVideoFormatList videoFormatList = 29;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoFormatListFieldNumber = 29;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // repeated .mt.TMTInviteMember inviteMembers = 30;
  inline int invitemembers_size() const;
  inline void clear_invitemembers();
  static const int kInviteMembersFieldNumber = 30;
  inline const ::mt::TMTInviteMember& invitemembers(int index) const;
  inline ::mt::TMTInviteMember* mutable_invitemembers(int index);
  inline ::mt::TMTInviteMember* add_invitemembers();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >&
      invitemembers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >*
      mutable_invitemembers();

  // optional .mt.TMTConfVMPInfo vmp = 31;
  inline bool has_vmp() const;
  inline void clear_vmp();
  static const int kVmpFieldNumber = 31;
  inline const ::mt::TMTConfVMPInfo& vmp() const;
  inline ::mt::TMTConfVMPInfo* mutable_vmp();
  inline ::mt::TMTConfVMPInfo* release_vmp();
  inline void set_allocated_vmp(::mt::TMTConfVMPInfo* vmp);

  // repeated .mt.TMTTemplateMember viplist = 32;
  inline int viplist_size() const;
  inline void clear_viplist();
  static const int kViplistFieldNumber = 32;
  inline const ::mt::TMTTemplateMember& viplist(int index) const;
  inline ::mt::TMTTemplateMember* mutable_viplist(int index);
  inline ::mt::TMTTemplateMember* add_viplist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      viplist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_viplist();

  // optional .mt.TMTConfPollInfo poll = 33;
  inline bool has_poll() const;
  inline void clear_poll();
  static const int kPollFieldNumber = 33;
  inline const ::mt::TMTConfPollInfo& poll() const;
  inline ::mt::TMTConfPollInfo* mutable_poll();
  inline ::mt::TMTConfPollInfo* release_poll();
  inline void set_allocated_poll(::mt::TMTConfPollInfo* poll);

  // optional string templateID = 34;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateIDFieldNumber = 34;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional bool encrypted_auth = 35;
  inline bool has_encrypted_auth() const;
  inline void clear_encrypted_auth();
  static const int kEncryptedAuthFieldNumber = 35;
  inline bool encrypted_auth() const;
  inline void set_encrypted_auth(bool value);

  // optional .mt.EmCallMode emCallMode = 36;
  inline bool has_emcallmode() const;
  inline void clear_emcallmode();
  static const int kEmCallModeFieldNumber = 36;
  inline ::mt::EmCallMode emcallmode() const;
  inline void set_emcallmode(::mt::EmCallMode value);

  // optional .mt.TMTRecordAttribute recordattr = 37;
  inline bool has_recordattr() const;
  inline void clear_recordattr();
  static const int kRecordattrFieldNumber = 37;
  inline const ::mt::TMTRecordAttribute& recordattr() const;
  inline ::mt::TMTRecordAttribute* mutable_recordattr();
  inline ::mt::TMTRecordAttribute* release_recordattr();
  inline void set_allocated_recordattr(::mt::TMTRecordAttribute* recordattr);

  // optional .mt.TMTDCSAttribute dcsattr = 38;
  inline bool has_dcsattr() const;
  inline void clear_dcsattr();
  static const int kDcsattrFieldNumber = 38;
  inline const ::mt::TMTDCSAttribute& dcsattr() const;
  inline ::mt::TMTDCSAttribute* mutable_dcsattr();
  inline ::mt::TMTDCSAttribute* release_dcsattr();
  inline void set_allocated_dcsattr(::mt::TMTDCSAttribute* dcsattr);

  // optional .mt.EmMtFecMode fecmode = 39;
  inline bool has_fecmode() const;
  inline void clear_fecmode();
  static const int kFecmodeFieldNumber = 39;
  inline ::mt::EmMtFecMode fecmode() const;
  inline void set_fecmode(::mt::EmMtFecMode value);

  // optional bool mutefilter = 40;
  inline bool has_mutefilter() const;
  inline void clear_mutefilter();
  static const int kMutefilterFieldNumber = 40;
  inline bool mutefilter() const;
  inline void set_mutefilter(bool value);

  // optional bool doubleflow = 41;
  inline bool has_doubleflow() const;
  inline void clear_doubleflow();
  static const int kDoubleflowFieldNumber = 41;
  inline bool doubleflow() const;
  inline void set_doubleflow(bool value);

  // optional uint32 duration = 42;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 42;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // repeated .mt.TMTTemplateMember keepcallingmembers = 43;
  inline int keepcallingmembers_size() const;
  inline void clear_keepcallingmembers();
  static const int kKeepcallingmembersFieldNumber = 43;
  inline const ::mt::TMTTemplateMember& keepcallingmembers(int index) const;
  inline ::mt::TMTTemplateMember* mutable_keepcallingmembers(int index);
  inline ::mt::TMTTemplateMember* add_keepcallingmembers();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      keepcallingmembers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_keepcallingmembers();

  // @@protoc_insertion_point(class_scope:mt.TMTPeronalTemplate)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_closeconf();
  inline void clear_has_closeconf();
  inline void set_has_safeconf();
  inline void clear_has_safeconf();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_calltimes();
  inline void clear_has_calltimes();
  inline void set_has_callinterval();
  inline void clear_has_callinterval();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_initsilence();
  inline void clear_has_initsilence();
  inline void set_has_vidoquality();
  inline void clear_has_vidoquality();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_voiceactivitydetection();
  inline void clear_has_voiceactivitydetection();
  inline void set_has_vacinterval();
  inline void clear_has_vacinterval();
  inline void set_has_emcascademode();
  inline void clear_has_emcascademode();
  inline void set_has_cascadeupload();
  inline void clear_has_cascadeupload();
  inline void set_has_cascadereturn();
  inline void clear_has_cascadereturn();
  inline void set_has_cascadereturnpara();
  inline void clear_has_cascadereturnpara();
  inline void set_has_publicconf();
  inline void clear_has_publicconf();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_autoend();
  inline void clear_has_autoend();
  inline void set_has_preoccpuyresouce();
  inline void clear_has_preoccpuyresouce();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_chairman();
  inline void clear_has_chairman();
  inline void set_has_mix();
  inline void clear_has_mix();
  inline void set_has_vmp();
  inline void clear_has_vmp();
  inline void set_has_poll();
  inline void clear_has_poll();
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_encrypted_auth();
  inline void clear_has_encrypted_auth();
  inline void set_has_emcallmode();
  inline void clear_has_emcallmode();
  inline void set_has_recordattr();
  inline void clear_has_recordattr();
  inline void set_has_dcsattr();
  inline void clear_has_dcsattr();
  inline void set_has_fecmode();
  inline void clear_has_fecmode();
  inline void set_has_mutefilter();
  inline void clear_has_mutefilter();
  inline void set_has_doubleflow();
  inline void clear_has_doubleflow();
  inline void set_has_duration();
  inline void clear_has_duration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 bitrate_;
  int closeconf_;
  ::std::string* password_;
  int safeconf_;
  int encryptedtype_;
  int meetingtype_;
  ::google::protobuf::uint32 calltimes_;
  ::google::protobuf::uint32 callinterval_;
  int vidoquality_;
  ::google::protobuf::uint32 onereforming_;
  bool initmute_;
  bool initsilence_;
  bool voiceactivitydetection_;
  bool cascadeupload_;
  ::std::string* encryptedkey_;
  int dualmode_;
  ::google::protobuf::uint32 vacinterval_;
  int emcascademode_;
  ::google::protobuf::uint32 cascadereturnpara_;
  bool cascadereturn_;
  bool publicconf_;
  bool autoend_;
  bool preoccpuyresouce_;
  ::google::protobuf::uint32 maxjoinmt_;
  ::mt::TMTTemplateMember* speaker_;
  ::mt::TMTTemplateMember* chairman_;
  ::mt::TMTConfMixInfo* mix_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember > invitemembers_;
  ::mt::TMTConfVMPInfo* vmp_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > viplist_;
  ::mt::TMTConfPollInfo* poll_;
  ::std::string* templateid_;
  ::mt::TMTRecordAttribute* recordattr_;
  ::mt::TMTDCSAttribute* dcsattr_;
  int emcallmode_;
  bool encrypted_auth_;
  bool mutefilter_;
  bool doubleflow_;
  int fecmode_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > keepcallingmembers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(43 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPeronalTemplate* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPersonalTemplateMember : public ::google::protobuf::Message {
 public:
  TMTPersonalTemplateMember();
  virtual ~TMTPersonalTemplateMember();

  TMTPersonalTemplateMember(const TMTPersonalTemplateMember& from);

  inline TMTPersonalTemplateMember& operator=(const TMTPersonalTemplateMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPersonalTemplateMember& default_instance();

  void Swap(TMTPersonalTemplateMember* other);

  // implements Message ----------------------------------------------

  TMTPersonalTemplateMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPersonalTemplateMember& from);
  void MergeFrom(const TMTPersonalTemplateMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templateID = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateIDFieldNumber = 1;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 bitrate = 3;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmClosedMeeting closeConf = 4;
  inline bool has_closeconf() const;
  inline void clear_closeconf();
  static const int kCloseConfFieldNumber = 4;
  inline ::mt::EmClosedMeeting closeconf() const;
  inline void set_closeconf(::mt::EmClosedMeeting value);

  // optional .mt.EmMtOpenMode safeConf = 5;
  inline bool has_safeconf() const;
  inline void clear_safeconf();
  static const int kSafeConfFieldNumber = 5;
  inline ::mt::EmMtOpenMode safeconf() const;
  inline void set_safeconf(::mt::EmMtOpenMode value);

  // optional .mt.EmEncryptArithmetic encryptedtype = 6;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 6;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional .mt.EmRestMeetingSafeType meetingtype = 7;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 7;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional bool initmute = 8;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 8;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional bool initSilence = 9;
  inline bool has_initsilence() const;
  inline void clear_initsilence();
  static const int kInitSilenceFieldNumber = 9;
  inline bool initsilence() const;
  inline void set_initsilence(bool value);

  // optional .mt.EmRestVideoQuality vidoQuality = 10;
  inline bool has_vidoquality() const;
  inline void clear_vidoquality();
  static const int kVidoQualityFieldNumber = 10;
  inline ::mt::EmRestVideoQuality vidoquality() const;
  inline void set_vidoquality(::mt::EmRestVideoQuality value);

  // optional uint32 oneReforming = 11;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOneReformingFieldNumber = 11;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional string encryptedkey = 12;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 12;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestDualMode dualmode = 13;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 13;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool voiceActivityDetection = 14;
  inline bool has_voiceactivitydetection() const;
  inline void clear_voiceactivitydetection();
  static const int kVoiceActivityDetectionFieldNumber = 14;
  inline bool voiceactivitydetection() const;
  inline void set_voiceactivitydetection(bool value);

  // optional bool publicConf = 15;
  inline bool has_publicconf() const;
  inline void clear_publicconf();
  static const int kPublicConfFieldNumber = 15;
  inline bool publicconf() const;
  inline void set_publicconf(bool value);

  // optional .mt.EmMtResolution resolution = 16;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 16;
  inline ::mt::EmMtResolution resolution() const;
  inline void set_resolution(::mt::EmMtResolution value);

  // optional uint32 maxJoinMt = 17;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxJoinMtFieldNumber = 17;
  inline ::google::protobuf::uint32 maxjoinmt() const;
  inline void set_maxjoinmt(::google::protobuf::uint32 value);

  // optional bool encrypted_auth = 18;
  inline bool has_encrypted_auth() const;
  inline void clear_encrypted_auth();
  static const int kEncryptedAuthFieldNumber = 18;
  inline bool encrypted_auth() const;
  inline void set_encrypted_auth(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTPersonalTemplateMember)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_closeconf();
  inline void clear_has_closeconf();
  inline void set_has_safeconf();
  inline void clear_has_safeconf();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_initsilence();
  inline void clear_has_initsilence();
  inline void set_has_vidoquality();
  inline void clear_has_vidoquality();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_voiceactivitydetection();
  inline void clear_has_voiceactivitydetection();
  inline void set_has_publicconf();
  inline void clear_has_publicconf();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_encrypted_auth();
  inline void clear_has_encrypted_auth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templateid_;
  ::std::string* name_;
  ::google::protobuf::uint32 bitrate_;
  int closeconf_;
  int safeconf_;
  int encryptedtype_;
  int meetingtype_;
  int vidoquality_;
  ::google::protobuf::uint32 onereforming_;
  bool initmute_;
  bool initsilence_;
  bool voiceactivitydetection_;
  bool publicconf_;
  ::std::string* encryptedkey_;
  int dualmode_;
  int resolution_;
  ::google::protobuf::uint32 maxjoinmt_;
  bool encrypted_auth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPersonalTemplateMember* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPersonalTemplatesList : public ::google::protobuf::Message {
 public:
  TMTPersonalTemplatesList();
  virtual ~TMTPersonalTemplatesList();

  TMTPersonalTemplatesList(const TMTPersonalTemplatesList& from);

  inline TMTPersonalTemplatesList& operator=(const TMTPersonalTemplatesList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPersonalTemplatesList& default_instance();

  void Swap(TMTPersonalTemplatesList* other);

  // implements Message ----------------------------------------------

  TMTPersonalTemplatesList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPersonalTemplatesList& from);
  void MergeFrom(const TMTPersonalTemplatesList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 dwCount = 1;
  inline bool has_dwcount() const;
  inline void clear_dwcount();
  static const int kDwCountFieldNumber = 1;
  inline ::google::protobuf::uint32 dwcount() const;
  inline void set_dwcount(::google::protobuf::uint32 value);

  // repeated .mt.TMTPersonalTemplateMember personalTemplateMember = 2;
  inline int personaltemplatemember_size() const;
  inline void clear_personaltemplatemember();
  static const int kPersonalTemplateMemberFieldNumber = 2;
  inline const ::mt::TMTPersonalTemplateMember& personaltemplatemember(int index) const;
  inline ::mt::TMTPersonalTemplateMember* mutable_personaltemplatemember(int index);
  inline ::mt::TMTPersonalTemplateMember* add_personaltemplatemember();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPersonalTemplateMember >&
      personaltemplatemember() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPersonalTemplateMember >*
      mutable_personaltemplatemember();

  // @@protoc_insertion_point(class_scope:mt.TMTPersonalTemplatesList)
 private:
  inline void set_has_dwcount();
  inline void clear_has_dwcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTPersonalTemplateMember > personaltemplatemember_;
  ::google::protobuf::uint32 dwcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPersonalTemplatesList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTSimplePeronalTemplate : public ::google::protobuf::Message {
 public:
  TMTSimplePeronalTemplate();
  virtual ~TMTSimplePeronalTemplate();

  TMTSimplePeronalTemplate(const TMTSimplePeronalTemplate& from);

  inline TMTSimplePeronalTemplate& operator=(const TMTSimplePeronalTemplate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTSimplePeronalTemplate& default_instance();

  void Swap(TMTSimplePeronalTemplate* other);

  // implements Message ----------------------------------------------

  TMTSimplePeronalTemplate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTSimplePeronalTemplate& from);
  void MergeFrom(const TMTSimplePeronalTemplate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templateID = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateIDFieldNumber = 1;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 bitrate = 3;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmClosedMeeting closeConf = 4;
  inline bool has_closeconf() const;
  inline void clear_closeconf();
  static const int kCloseConfFieldNumber = 4;
  inline ::mt::EmClosedMeeting closeconf() const;
  inline void set_closeconf(::mt::EmClosedMeeting value);

  // optional .mt.EmMtOpenMode safeConf = 5;
  inline bool has_safeconf() const;
  inline void clear_safeconf();
  static const int kSafeConfFieldNumber = 5;
  inline ::mt::EmMtOpenMode safeconf() const;
  inline void set_safeconf(::mt::EmMtOpenMode value);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .mt.EmEncryptArithmetic encryptedtype = 7;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 7;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional .mt.EmRestMeetingSafeType meetingtype = 8;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 8;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional uint32 callTimes = 9;
  inline bool has_calltimes() const;
  inline void clear_calltimes();
  static const int kCallTimesFieldNumber = 9;
  inline ::google::protobuf::uint32 calltimes() const;
  inline void set_calltimes(::google::protobuf::uint32 value);

  // optional uint32 callInterval = 10;
  inline bool has_callinterval() const;
  inline void clear_callinterval();
  static const int kCallIntervalFieldNumber = 10;
  inline ::google::protobuf::uint32 callinterval() const;
  inline void set_callinterval(::google::protobuf::uint32 value);

  // optional bool callChase = 11;
  inline bool has_callchase() const;
  inline void clear_callchase();
  static const int kCallChaseFieldNumber = 11;
  inline bool callchase() const;
  inline void set_callchase(bool value);

  // optional bool initmute = 12;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 12;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional bool initSilence = 13;
  inline bool has_initsilence() const;
  inline void clear_initsilence();
  static const int kInitSilenceFieldNumber = 13;
  inline bool initsilence() const;
  inline void set_initsilence(bool value);

  // optional .mt.EmRestVideoQuality vidoQuality = 14;
  inline bool has_vidoquality() const;
  inline void clear_vidoquality();
  static const int kVidoQualityFieldNumber = 14;
  inline ::mt::EmRestVideoQuality vidoquality() const;
  inline void set_vidoquality(::mt::EmRestVideoQuality value);

  // optional uint32 oneReforming = 15;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOneReformingFieldNumber = 15;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional string encryptedkey = 16;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 16;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestDualMode dualmode = 17;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 17;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool voiceActivityDetection = 18;
  inline bool has_voiceactivitydetection() const;
  inline void clear_voiceactivitydetection();
  static const int kVoiceActivityDetectionFieldNumber = 18;
  inline bool voiceactivitydetection() const;
  inline void set_voiceactivitydetection(bool value);

  // optional .mt.EmRestCascadeMode emCascadeMode = 19;
  inline bool has_emcascademode() const;
  inline void clear_emcascademode();
  static const int kEmCascadeModeFieldNumber = 19;
  inline ::mt::EmRestCascadeMode emcascademode() const;
  inline void set_emcascademode(::mt::EmRestCascadeMode value);

  // optional bool cascadeUpload = 20;
  inline bool has_cascadeupload() const;
  inline void clear_cascadeupload();
  static const int kCascadeUploadFieldNumber = 20;
  inline bool cascadeupload() const;
  inline void set_cascadeupload(bool value);

  // optional bool cascadeReturn = 21;
  inline bool has_cascadereturn() const;
  inline void clear_cascadereturn();
  static const int kCascadeReturnFieldNumber = 21;
  inline bool cascadereturn() const;
  inline void set_cascadereturn(bool value);

  // optional uint32 cascadeReturnPara = 22;
  inline bool has_cascadereturnpara() const;
  inline void clear_cascadereturnpara();
  static const int kCascadeReturnParaFieldNumber = 22;
  inline ::google::protobuf::uint32 cascadereturnpara() const;
  inline void set_cascadereturnpara(::google::protobuf::uint32 value);

  // optional uint32 maxJoinMt = 23;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxJoinMtFieldNumber = 23;
  inline ::google::protobuf::uint32 maxjoinmt() const;
  inline void set_maxjoinmt(::google::protobuf::uint32 value);

  // optional uint32 inviteNum = 24;
  inline bool has_invitenum() const;
  inline void clear_invitenum();
  static const int kInviteNumFieldNumber = 24;
  inline ::google::protobuf::uint32 invitenum() const;
  inline void set_invitenum(::google::protobuf::uint32 value);

  // optional uint32 mixNum = 25;
  inline bool has_mixnum() const;
  inline void clear_mixnum();
  static const int kMixNumFieldNumber = 25;
  inline ::google::protobuf::uint32 mixnum() const;
  inline void set_mixnum(::google::protobuf::uint32 value);

  // optional uint32 vmpNum = 26;
  inline bool has_vmpnum() const;
  inline void clear_vmpnum();
  static const int kVmpNumFieldNumber = 26;
  inline ::google::protobuf::uint32 vmpnum() const;
  inline void set_vmpnum(::google::protobuf::uint32 value);

  // optional uint32 vipNum = 27;
  inline bool has_vipnum() const;
  inline void clear_vipnum();
  static const int kVipNumFieldNumber = 27;
  inline ::google::protobuf::uint32 vipnum() const;
  inline void set_vipnum(::google::protobuf::uint32 value);

  // optional uint32 pollNum = 28;
  inline bool has_pollnum() const;
  inline void clear_pollnum();
  static const int kPollNumFieldNumber = 28;
  inline ::google::protobuf::uint32 pollnum() const;
  inline void set_pollnum(::google::protobuf::uint32 value);

  // optional .mt.TMTTemplateMember speaker = 29;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 29;
  inline const ::mt::TMTTemplateMember& speaker() const;
  inline ::mt::TMTTemplateMember* mutable_speaker();
  inline ::mt::TMTTemplateMember* release_speaker();
  inline void set_allocated_speaker(::mt::TMTTemplateMember* speaker);

  // optional .mt.TMTTemplateMember chairman = 30;
  inline bool has_chairman() const;
  inline void clear_chairman();
  static const int kChairmanFieldNumber = 30;
  inline const ::mt::TMTTemplateMember& chairman() const;
  inline ::mt::TMTTemplateMember* mutable_chairman();
  inline ::mt::TMTTemplateMember* release_chairman();
  inline void set_allocated_chairman(::mt::TMTTemplateMember* chairman);

  // optional bool publicConf = 31;
  inline bool has_publicconf() const;
  inline void clear_publicconf();
  static const int kPublicConfFieldNumber = 31;
  inline bool publicconf() const;
  inline void set_publicconf(bool value);

  // repeated .mt.TMTVideoFormatList videoFormatList = 32;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoFormatListFieldNumber = 32;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // optional .mt.EmCallMode emCallMode = 33;
  inline bool has_emcallmode() const;
  inline void clear_emcallmode();
  static const int kEmCallModeFieldNumber = 33;
  inline ::mt::EmCallMode emcallmode() const;
  inline void set_emcallmode(::mt::EmCallMode value);

  // optional .mt.EmMtFecMode fecmode = 34;
  inline bool has_fecmode() const;
  inline void clear_fecmode();
  static const int kFecmodeFieldNumber = 34;
  inline ::mt::EmMtFecMode fecmode() const;
  inline void set_fecmode(::mt::EmMtFecMode value);

  // optional bool mutefilter = 35;
  inline bool has_mutefilter() const;
  inline void clear_mutefilter();
  static const int kMutefilterFieldNumber = 35;
  inline bool mutefilter() const;
  inline void set_mutefilter(bool value);

  // optional bool encrypted_auth = 36;
  inline bool has_encrypted_auth() const;
  inline void clear_encrypted_auth();
  static const int kEncryptedAuthFieldNumber = 36;
  inline bool encrypted_auth() const;
  inline void set_encrypted_auth(bool value);

  // optional bool doubleflow = 37;
  inline bool has_doubleflow() const;
  inline void clear_doubleflow();
  static const int kDoubleflowFieldNumber = 37;
  inline bool doubleflow() const;
  inline void set_doubleflow(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTSimplePeronalTemplate)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_closeconf();
  inline void clear_has_closeconf();
  inline void set_has_safeconf();
  inline void clear_has_safeconf();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_calltimes();
  inline void clear_has_calltimes();
  inline void set_has_callinterval();
  inline void clear_has_callinterval();
  inline void set_has_callchase();
  inline void clear_has_callchase();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_initsilence();
  inline void clear_has_initsilence();
  inline void set_has_vidoquality();
  inline void clear_has_vidoquality();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_voiceactivitydetection();
  inline void clear_has_voiceactivitydetection();
  inline void set_has_emcascademode();
  inline void clear_has_emcascademode();
  inline void set_has_cascadeupload();
  inline void clear_has_cascadeupload();
  inline void set_has_cascadereturn();
  inline void clear_has_cascadereturn();
  inline void set_has_cascadereturnpara();
  inline void clear_has_cascadereturnpara();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_invitenum();
  inline void clear_has_invitenum();
  inline void set_has_mixnum();
  inline void clear_has_mixnum();
  inline void set_has_vmpnum();
  inline void clear_has_vmpnum();
  inline void set_has_vipnum();
  inline void clear_has_vipnum();
  inline void set_has_pollnum();
  inline void clear_has_pollnum();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_chairman();
  inline void clear_has_chairman();
  inline void set_has_publicconf();
  inline void clear_has_publicconf();
  inline void set_has_emcallmode();
  inline void clear_has_emcallmode();
  inline void set_has_fecmode();
  inline void clear_has_fecmode();
  inline void set_has_mutefilter();
  inline void clear_has_mutefilter();
  inline void set_has_encrypted_auth();
  inline void clear_has_encrypted_auth();
  inline void set_has_doubleflow();
  inline void clear_has_doubleflow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templateid_;
  ::std::string* name_;
  ::google::protobuf::uint32 bitrate_;
  int closeconf_;
  ::std::string* password_;
  int safeconf_;
  int encryptedtype_;
  int meetingtype_;
  ::google::protobuf::uint32 calltimes_;
  ::google::protobuf::uint32 callinterval_;
  bool callchase_;
  bool initmute_;
  bool initsilence_;
  bool voiceactivitydetection_;
  int vidoquality_;
  ::google::protobuf::uint32 onereforming_;
  ::std::string* encryptedkey_;
  int dualmode_;
  int emcascademode_;
  ::google::protobuf::uint32 cascadereturnpara_;
  ::google::protobuf::uint32 maxjoinmt_;
  ::google::protobuf::uint32 invitenum_;
  ::google::protobuf::uint32 mixnum_;
  ::google::protobuf::uint32 vmpnum_;
  bool cascadeupload_;
  bool cascadereturn_;
  bool publicconf_;
  bool mutefilter_;
  ::google::protobuf::uint32 vipnum_;
  ::google::protobuf::uint32 pollnum_;
  ::mt::TMTTemplateMember* speaker_;
  ::mt::TMTTemplateMember* chairman_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  int emcallmode_;
  int fecmode_;
  bool encrypted_auth_;
  bool doubleflow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(37 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTSimplePeronalTemplate* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPerInviteMemberList : public ::google::protobuf::Message {
 public:
  TMTPerInviteMemberList();
  virtual ~TMTPerInviteMemberList();

  TMTPerInviteMemberList(const TMTPerInviteMemberList& from);

  inline TMTPerInviteMemberList& operator=(const TMTPerInviteMemberList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPerInviteMemberList& default_instance();

  void Swap(TMTPerInviteMemberList* other);

  // implements Message ----------------------------------------------

  TMTPerInviteMemberList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPerInviteMemberList& from);
  void MergeFrom(const TMTPerInviteMemberList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templateID = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateIDFieldNumber = 1;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTInviteMember inviteMembers = 3;
  inline int invitemembers_size() const;
  inline void clear_invitemembers();
  static const int kInviteMembersFieldNumber = 3;
  inline const ::mt::TMTInviteMember& invitemembers(int index) const;
  inline ::mt::TMTInviteMember* mutable_invitemembers(int index);
  inline ::mt::TMTInviteMember* add_invitemembers();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >&
      invitemembers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >*
      mutable_invitemembers();

  // @@protoc_insertion_point(class_scope:mt.TMTPerInviteMemberList)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templateid_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember > invitemembers_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPerInviteMemberList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTGetPerMixInfo : public ::google::protobuf::Message {
 public:
  TMTGetPerMixInfo();
  virtual ~TMTGetPerMixInfo();

  TMTGetPerMixInfo(const TMTGetPerMixInfo& from);

  inline TMTGetPerMixInfo& operator=(const TMTGetPerMixInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTGetPerMixInfo& default_instance();

  void Swap(TMTGetPerMixInfo* other);

  // implements Message ----------------------------------------------

  TMTGetPerMixInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTGetPerMixInfo& from);
  void MergeFrom(const TMTGetPerMixInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templateID = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateIDFieldNumber = 1;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional .mt.TMTConfMixInfo mix = 2;
  inline bool has_mix() const;
  inline void clear_mix();
  static const int kMixFieldNumber = 2;
  inline const ::mt::TMTConfMixInfo& mix() const;
  inline ::mt::TMTConfMixInfo* mutable_mix();
  inline ::mt::TMTConfMixInfo* release_mix();
  inline void set_allocated_mix(::mt::TMTConfMixInfo* mix);

  // @@protoc_insertion_point(class_scope:mt.TMTGetPerMixInfo)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_mix();
  inline void clear_has_mix();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templateid_;
  ::mt::TMTConfMixInfo* mix_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTGetPerMixInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTGetPerVMPInfo : public ::google::protobuf::Message {
 public:
  TMTGetPerVMPInfo();
  virtual ~TMTGetPerVMPInfo();

  TMTGetPerVMPInfo(const TMTGetPerVMPInfo& from);

  inline TMTGetPerVMPInfo& operator=(const TMTGetPerVMPInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTGetPerVMPInfo& default_instance();

  void Swap(TMTGetPerVMPInfo* other);

  // implements Message ----------------------------------------------

  TMTGetPerVMPInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTGetPerVMPInfo& from);
  void MergeFrom(const TMTGetPerVMPInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templateID = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateIDFieldNumber = 1;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional .mt.TMTConfVMPInfo VMP = 2;
  inline bool has_vmp() const;
  inline void clear_vmp();
  static const int kVMPFieldNumber = 2;
  inline const ::mt::TMTConfVMPInfo& vmp() const;
  inline ::mt::TMTConfVMPInfo* mutable_vmp();
  inline ::mt::TMTConfVMPInfo* release_vmp();
  inline void set_allocated_vmp(::mt::TMTConfVMPInfo* vmp);

  // @@protoc_insertion_point(class_scope:mt.TMTGetPerVMPInfo)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_vmp();
  inline void clear_has_vmp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templateid_;
  ::mt::TMTConfVMPInfo* vmp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTGetPerVMPInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTGetPerPollInfo : public ::google::protobuf::Message {
 public:
  TMTGetPerPollInfo();
  virtual ~TMTGetPerPollInfo();

  TMTGetPerPollInfo(const TMTGetPerPollInfo& from);

  inline TMTGetPerPollInfo& operator=(const TMTGetPerPollInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTGetPerPollInfo& default_instance();

  void Swap(TMTGetPerPollInfo* other);

  // implements Message ----------------------------------------------

  TMTGetPerPollInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTGetPerPollInfo& from);
  void MergeFrom(const TMTGetPerPollInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templateID = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateIDFieldNumber = 1;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional .mt.TMTConfPollInfo poll = 2;
  inline bool has_poll() const;
  inline void clear_poll();
  static const int kPollFieldNumber = 2;
  inline const ::mt::TMTConfPollInfo& poll() const;
  inline ::mt::TMTConfPollInfo* mutable_poll();
  inline ::mt::TMTConfPollInfo* release_poll();
  inline void set_allocated_poll(::mt::TMTConfPollInfo* poll);

  // @@protoc_insertion_point(class_scope:mt.TMTGetPerPollInfo)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_poll();
  inline void clear_has_poll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templateid_;
  ::mt::TMTConfPollInfo* poll_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTGetPerPollInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTGetPerVIPInfo : public ::google::protobuf::Message {
 public:
  TMTGetPerVIPInfo();
  virtual ~TMTGetPerVIPInfo();

  TMTGetPerVIPInfo(const TMTGetPerVIPInfo& from);

  inline TMTGetPerVIPInfo& operator=(const TMTGetPerVIPInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTGetPerVIPInfo& default_instance();

  void Swap(TMTGetPerVIPInfo* other);

  // implements Message ----------------------------------------------

  TMTGetPerVIPInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTGetPerVIPInfo& from);
  void MergeFrom(const TMTGetPerVIPInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templateID = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateIDFieldNumber = 1;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional uint32 dwCount = 2;
  inline bool has_dwcount() const;
  inline void clear_dwcount();
  static const int kDwCountFieldNumber = 2;
  inline ::google::protobuf::uint32 dwcount() const;
  inline void set_dwcount(::google::protobuf::uint32 value);

  // repeated .mt.TMTTemplateMember vip = 3;
  inline int vip_size() const;
  inline void clear_vip();
  static const int kVipFieldNumber = 3;
  inline const ::mt::TMTTemplateMember& vip(int index) const;
  inline ::mt::TMTTemplateMember* mutable_vip(int index);
  inline ::mt::TMTTemplateMember* add_vip();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      vip() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_vip();

  // @@protoc_insertion_point(class_scope:mt.TMTGetPerVIPInfo)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_dwcount();
  inline void clear_has_dwcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templateid_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > vip_;
  ::google::protobuf::uint32 dwcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTGetPerVIPInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTGetPerTemplateInfo : public ::google::protobuf::Message {
 public:
  TMTGetPerTemplateInfo();
  virtual ~TMTGetPerTemplateInfo();

  TMTGetPerTemplateInfo(const TMTGetPerTemplateInfo& from);

  inline TMTGetPerTemplateInfo& operator=(const TMTGetPerTemplateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTGetPerTemplateInfo& default_instance();

  void Swap(TMTGetPerTemplateInfo* other);

  // implements Message ----------------------------------------------

  TMTGetPerTemplateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTGetPerTemplateInfo& from);
  void MergeFrom(const TMTGetPerTemplateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templateID = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateIDFieldNumber = 1;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional uint32 start = 2;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 4;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 4;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTGetPerTemplateInfo)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templateid_;
  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTGetPerTemplateInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCommonTemplate : public ::google::protobuf::Message {
 public:
  TMTCommonTemplate();
  virtual ~TMTCommonTemplate();

  TMTCommonTemplate(const TMTCommonTemplate& from);

  inline TMTCommonTemplate& operator=(const TMTCommonTemplate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCommonTemplate& default_instance();

  void Swap(TMTCommonTemplate* other);

  // implements Message ----------------------------------------------

  TMTCommonTemplate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCommonTemplate& from);
  void MergeFrom(const TMTCommonTemplate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templateID = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateIDFieldNumber = 1;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 bitrate = 4;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 4;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmClosedMeeting closeConf = 5;
  inline bool has_closeconf() const;
  inline void clear_closeconf();
  static const int kCloseConfFieldNumber = 5;
  inline ::mt::EmClosedMeeting closeconf() const;
  inline void set_closeconf(::mt::EmClosedMeeting value);

  // optional .mt.EmMtOpenMode safeConf = 6;
  inline bool has_safeconf() const;
  inline void clear_safeconf();
  static const int kSafeConfFieldNumber = 6;
  inline ::mt::EmMtOpenMode safeconf() const;
  inline void set_safeconf(::mt::EmMtOpenMode value);

  // optional string password = 7;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 7;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .mt.EmEncryptArithmetic encryptedtype = 8;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 8;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional .mt.EmRestMeetingSafeType meetingtype = 9;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 9;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional bool publicConf = 10;
  inline bool has_publicconf() const;
  inline void clear_publicconf();
  static const int kPublicConfFieldNumber = 10;
  inline bool publicconf() const;
  inline void set_publicconf(bool value);

  // optional uint32 callTimes = 11;
  inline bool has_calltimes() const;
  inline void clear_calltimes();
  static const int kCallTimesFieldNumber = 11;
  inline ::google::protobuf::uint32 calltimes() const;
  inline void set_calltimes(::google::protobuf::uint32 value);

  // optional uint32 callInterval = 12;
  inline bool has_callinterval() const;
  inline void clear_callinterval();
  static const int kCallIntervalFieldNumber = 12;
  inline ::google::protobuf::uint32 callinterval() const;
  inline void set_callinterval(::google::protobuf::uint32 value);

  // optional bool initmute = 13;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 13;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional bool initSilence = 14;
  inline bool has_initsilence() const;
  inline void clear_initsilence();
  static const int kInitSilenceFieldNumber = 14;
  inline bool initsilence() const;
  inline void set_initsilence(bool value);

  // optional .mt.EmRestVideoQuality vidoQuality = 15;
  inline bool has_vidoquality() const;
  inline void clear_vidoquality();
  static const int kVidoQualityFieldNumber = 15;
  inline ::mt::EmRestVideoQuality vidoquality() const;
  inline void set_vidoquality(::mt::EmRestVideoQuality value);

  // optional uint32 oneReforming = 16;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOneReformingFieldNumber = 16;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional string encryptedkey = 17;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 17;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestDualMode dualmode = 18;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 18;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool voiceActivityDetection = 19;
  inline bool has_voiceactivitydetection() const;
  inline void clear_voiceactivitydetection();
  static const int kVoiceActivityDetectionFieldNumber = 19;
  inline bool voiceactivitydetection() const;
  inline void set_voiceactivitydetection(bool value);

  // optional .mt.EmRestCascadeMode emCascadeMode = 20;
  inline bool has_emcascademode() const;
  inline void clear_emcascademode();
  static const int kEmCascadeModeFieldNumber = 20;
  inline ::mt::EmRestCascadeMode emcascademode() const;
  inline void set_emcascademode(::mt::EmRestCascadeMode value);

  // optional bool cascadeUpload = 21;
  inline bool has_cascadeupload() const;
  inline void clear_cascadeupload();
  static const int kCascadeUploadFieldNumber = 21;
  inline bool cascadeupload() const;
  inline void set_cascadeupload(bool value);

  // optional bool cascadeReturn = 22;
  inline bool has_cascadereturn() const;
  inline void clear_cascadereturn();
  static const int kCascadeReturnFieldNumber = 22;
  inline bool cascadereturn() const;
  inline void set_cascadereturn(bool value);

  // optional uint32 cascadeReturnPara = 23;
  inline bool has_cascadereturnpara() const;
  inline void clear_cascadereturnpara();
  static const int kCascadeReturnParaFieldNumber = 23;
  inline ::google::protobuf::uint32 cascadereturnpara() const;
  inline void set_cascadereturnpara(::google::protobuf::uint32 value);

  // optional uint32 maxJoinMt = 24;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxJoinMtFieldNumber = 24;
  inline ::google::protobuf::uint32 maxjoinmt() const;
  inline void set_maxjoinmt(::google::protobuf::uint32 value);

  // optional bool autoEnd = 25;
  inline bool has_autoend() const;
  inline void clear_autoend();
  static const int kAutoEndFieldNumber = 25;
  inline bool autoend() const;
  inline void set_autoend(bool value);

  // optional bool preoccpuyResouce = 26;
  inline bool has_preoccpuyresouce() const;
  inline void clear_preoccpuyresouce();
  static const int kPreoccpuyResouceFieldNumber = 26;
  inline bool preoccpuyresouce() const;
  inline void set_preoccpuyresouce(bool value);

  // repeated .mt.TMTVideoFormatList videoFormatList = 27;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoFormatListFieldNumber = 27;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // optional uint32 vacinterval = 28;
  inline bool has_vacinterval() const;
  inline void clear_vacinterval();
  static const int kVacintervalFieldNumber = 28;
  inline ::google::protobuf::uint32 vacinterval() const;
  inline void set_vacinterval(::google::protobuf::uint32 value);

  // optional bool encrypted_auth = 29;
  inline bool has_encrypted_auth() const;
  inline void clear_encrypted_auth();
  static const int kEncryptedAuthFieldNumber = 29;
  inline bool encrypted_auth() const;
  inline void set_encrypted_auth(bool value);

  // optional .mt.TMTDCSAttribute dcsattr = 30;
  inline bool has_dcsattr() const;
  inline void clear_dcsattr();
  static const int kDcsattrFieldNumber = 30;
  inline const ::mt::TMTDCSAttribute& dcsattr() const;
  inline ::mt::TMTDCSAttribute* mutable_dcsattr();
  inline ::mt::TMTDCSAttribute* release_dcsattr();
  inline void set_allocated_dcsattr(::mt::TMTDCSAttribute* dcsattr);

  // optional .mt.EmMtFecMode fecmode = 31;
  inline bool has_fecmode() const;
  inline void clear_fecmode();
  static const int kFecmodeFieldNumber = 31;
  inline ::mt::EmMtFecMode fecmode() const;
  inline void set_fecmode(::mt::EmMtFecMode value);

  // optional .mt.TMTConfVMPBrief vmp = 32;
  inline bool has_vmp() const;
  inline void clear_vmp();
  static const int kVmpFieldNumber = 32;
  inline const ::mt::TMTConfVMPBrief& vmp() const;
  inline ::mt::TMTConfVMPBrief* mutable_vmp();
  inline ::mt::TMTConfVMPBrief* release_vmp();
  inline void set_allocated_vmp(::mt::TMTConfVMPBrief* vmp);

  // optional .mt.TMTConfMixBrief mix = 33;
  inline bool has_mix() const;
  inline void clear_mix();
  static const int kMixFieldNumber = 33;
  inline const ::mt::TMTConfMixBrief& mix() const;
  inline ::mt::TMTConfMixBrief* mutable_mix();
  inline ::mt::TMTConfMixBrief* release_mix();
  inline void set_allocated_mix(::mt::TMTConfMixBrief* mix);

  // optional bool mutefilter = 34;
  inline bool has_mutefilter() const;
  inline void clear_mutefilter();
  static const int kMutefilterFieldNumber = 34;
  inline bool mutefilter() const;
  inline void set_mutefilter(bool value);

  // optional bool doubleflow = 35;
  inline bool has_doubleflow() const;
  inline void clear_doubleflow();
  static const int kDoubleflowFieldNumber = 35;
  inline bool doubleflow() const;
  inline void set_doubleflow(bool value);

  // optional uint32 duration = 36;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 36;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional .mt.EmCallMode emCallMode = 37;
  inline bool has_emcallmode() const;
  inline void clear_emcallmode();
  static const int kEmCallModeFieldNumber = 37;
  inline ::mt::EmCallMode emcallmode() const;
  inline void set_emcallmode(::mt::EmCallMode value);

  // optional .mt.TMTRecordAttributeBrief recordattr = 38;
  inline bool has_recordattr() const;
  inline void clear_recordattr();
  static const int kRecordattrFieldNumber = 38;
  inline const ::mt::TMTRecordAttributeBrief& recordattr() const;
  inline ::mt::TMTRecordAttributeBrief* mutable_recordattr();
  inline ::mt::TMTRecordAttributeBrief* release_recordattr();
  inline void set_allocated_recordattr(::mt::TMTRecordAttributeBrief* recordattr);

  // @@protoc_insertion_point(class_scope:mt.TMTCommonTemplate)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_closeconf();
  inline void clear_has_closeconf();
  inline void set_has_safeconf();
  inline void clear_has_safeconf();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_publicconf();
  inline void clear_has_publicconf();
  inline void set_has_calltimes();
  inline void clear_has_calltimes();
  inline void set_has_callinterval();
  inline void clear_has_callinterval();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_initsilence();
  inline void clear_has_initsilence();
  inline void set_has_vidoquality();
  inline void clear_has_vidoquality();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_voiceactivitydetection();
  inline void clear_has_voiceactivitydetection();
  inline void set_has_emcascademode();
  inline void clear_has_emcascademode();
  inline void set_has_cascadeupload();
  inline void clear_has_cascadeupload();
  inline void set_has_cascadereturn();
  inline void clear_has_cascadereturn();
  inline void set_has_cascadereturnpara();
  inline void clear_has_cascadereturnpara();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_autoend();
  inline void clear_has_autoend();
  inline void set_has_preoccpuyresouce();
  inline void clear_has_preoccpuyresouce();
  inline void set_has_vacinterval();
  inline void clear_has_vacinterval();
  inline void set_has_encrypted_auth();
  inline void clear_has_encrypted_auth();
  inline void set_has_dcsattr();
  inline void clear_has_dcsattr();
  inline void set_has_fecmode();
  inline void clear_has_fecmode();
  inline void set_has_vmp();
  inline void clear_has_vmp();
  inline void set_has_mix();
  inline void clear_has_mix();
  inline void set_has_mutefilter();
  inline void clear_has_mutefilter();
  inline void set_has_doubleflow();
  inline void clear_has_doubleflow();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_emcallmode();
  inline void clear_has_emcallmode();
  inline void set_has_recordattr();
  inline void clear_has_recordattr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templateid_;
  ::std::string* name_;
  ::google::protobuf::uint32 bitrate_;
  int closeconf_;
  ::std::string* password_;
  int safeconf_;
  int encryptedtype_;
  int meetingtype_;
  ::google::protobuf::uint32 calltimes_;
  ::google::protobuf::uint32 callinterval_;
  bool publicconf_;
  bool initmute_;
  bool initsilence_;
  bool voiceactivitydetection_;
  int vidoquality_;
  ::google::protobuf::uint32 onereforming_;
  ::std::string* encryptedkey_;
  int dualmode_;
  int emcascademode_;
  ::google::protobuf::uint32 cascadereturnpara_;
  bool cascadeupload_;
  bool cascadereturn_;
  bool autoend_;
  bool preoccpuyresouce_;
  ::google::protobuf::uint32 maxjoinmt_;
  ::google::protobuf::uint32 vacinterval_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  ::mt::TMTDCSAttribute* dcsattr_;
  ::mt::TMTConfVMPBrief* vmp_;
  int fecmode_;
  bool encrypted_auth_;
  bool mutefilter_;
  bool doubleflow_;
  ::mt::TMTConfMixBrief* mix_;
  ::google::protobuf::uint32 duration_;
  int emcallmode_;
  ::mt::TMTRecordAttributeBrief* recordattr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(37 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTCommonTemplate* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCommonTemplateMember : public ::google::protobuf::Message {
 public:
  TMTCommonTemplateMember();
  virtual ~TMTCommonTemplateMember();

  TMTCommonTemplateMember(const TMTCommonTemplateMember& from);

  inline TMTCommonTemplateMember& operator=(const TMTCommonTemplateMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCommonTemplateMember& default_instance();

  void Swap(TMTCommonTemplateMember* other);

  // implements Message ----------------------------------------------

  TMTCommonTemplateMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCommonTemplateMember& from);
  void MergeFrom(const TMTCommonTemplateMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string templateID = 1;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateIDFieldNumber = 1;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 bitrate = 3;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmClosedMeeting closeConf = 4;
  inline bool has_closeconf() const;
  inline void clear_closeconf();
  static const int kCloseConfFieldNumber = 4;
  inline ::mt::EmClosedMeeting closeconf() const;
  inline void set_closeconf(::mt::EmClosedMeeting value);

  // optional .mt.EmMtOpenMode safeConf = 5;
  inline bool has_safeconf() const;
  inline void clear_safeconf();
  static const int kSafeConfFieldNumber = 5;
  inline ::mt::EmMtOpenMode safeconf() const;
  inline void set_safeconf(::mt::EmMtOpenMode value);

  // optional .mt.EmEncryptArithmetic encryptedtype = 6;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 6;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional .mt.EmRestMeetingSafeType meetingtype = 7;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 7;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional bool initmute = 8;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 8;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional bool initSilence = 9;
  inline bool has_initsilence() const;
  inline void clear_initsilence();
  static const int kInitSilenceFieldNumber = 9;
  inline bool initsilence() const;
  inline void set_initsilence(bool value);

  // optional .mt.EmRestVideoQuality vidoQuality = 10;
  inline bool has_vidoquality() const;
  inline void clear_vidoquality();
  static const int kVidoQualityFieldNumber = 10;
  inline ::mt::EmRestVideoQuality vidoquality() const;
  inline void set_vidoquality(::mt::EmRestVideoQuality value);

  // optional uint32 oneReforming = 11;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOneReformingFieldNumber = 11;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional string encryptedkey = 12;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 12;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestDualMode dualmode = 13;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 13;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool voiceActivityDetection = 14;
  inline bool has_voiceactivitydetection() const;
  inline void clear_voiceactivitydetection();
  static const int kVoiceActivityDetectionFieldNumber = 14;
  inline bool voiceactivitydetection() const;
  inline void set_voiceactivitydetection(bool value);

  // optional bool publicConf = 15;
  inline bool has_publicconf() const;
  inline void clear_publicconf();
  static const int kPublicConfFieldNumber = 15;
  inline bool publicconf() const;
  inline void set_publicconf(bool value);

  // optional .mt.EmMtResolution resolution = 16;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 16;
  inline ::mt::EmMtResolution resolution() const;
  inline void set_resolution(::mt::EmMtResolution value);

  // optional uint32 maxJoinMt = 17;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxJoinMtFieldNumber = 17;
  inline ::google::protobuf::uint32 maxjoinmt() const;
  inline void set_maxjoinmt(::google::protobuf::uint32 value);

  // optional bool encrypted_auth = 18;
  inline bool has_encrypted_auth() const;
  inline void clear_encrypted_auth();
  static const int kEncryptedAuthFieldNumber = 18;
  inline bool encrypted_auth() const;
  inline void set_encrypted_auth(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTCommonTemplateMember)
 private:
  inline void set_has_templateid();
  inline void clear_has_templateid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_closeconf();
  inline void clear_has_closeconf();
  inline void set_has_safeconf();
  inline void clear_has_safeconf();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_initsilence();
  inline void clear_has_initsilence();
  inline void set_has_vidoquality();
  inline void clear_has_vidoquality();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_voiceactivitydetection();
  inline void clear_has_voiceactivitydetection();
  inline void set_has_publicconf();
  inline void clear_has_publicconf();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_encrypted_auth();
  inline void clear_has_encrypted_auth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* templateid_;
  ::std::string* name_;
  ::google::protobuf::uint32 bitrate_;
  int closeconf_;
  int safeconf_;
  int encryptedtype_;
  int meetingtype_;
  int vidoquality_;
  ::google::protobuf::uint32 onereforming_;
  bool initmute_;
  bool initsilence_;
  bool voiceactivitydetection_;
  bool publicconf_;
  ::std::string* encryptedkey_;
  int dualmode_;
  int resolution_;
  ::google::protobuf::uint32 maxjoinmt_;
  bool encrypted_auth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTCommonTemplateMember* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCommonTemplatesList : public ::google::protobuf::Message {
 public:
  TMTCommonTemplatesList();
  virtual ~TMTCommonTemplatesList();

  TMTCommonTemplatesList(const TMTCommonTemplatesList& from);

  inline TMTCommonTemplatesList& operator=(const TMTCommonTemplatesList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCommonTemplatesList& default_instance();

  void Swap(TMTCommonTemplatesList* other);

  // implements Message ----------------------------------------------

  TMTCommonTemplatesList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCommonTemplatesList& from);
  void MergeFrom(const TMTCommonTemplatesList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 dwCount = 1;
  inline bool has_dwcount() const;
  inline void clear_dwcount();
  static const int kDwCountFieldNumber = 1;
  inline ::google::protobuf::uint32 dwcount() const;
  inline void set_dwcount(::google::protobuf::uint32 value);

  // repeated .mt.TMTCommonTemplateMember commonTemplateMember = 2;
  inline int commontemplatemember_size() const;
  inline void clear_commontemplatemember();
  static const int kCommonTemplateMemberFieldNumber = 2;
  inline const ::mt::TMTCommonTemplateMember& commontemplatemember(int index) const;
  inline ::mt::TMTCommonTemplateMember* mutable_commontemplatemember(int index);
  inline ::mt::TMTCommonTemplateMember* add_commontemplatemember();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTCommonTemplateMember >&
      commontemplatemember() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTCommonTemplateMember >*
      mutable_commontemplatemember();

  // @@protoc_insertion_point(class_scope:mt.TMTCommonTemplatesList)
 private:
  inline void set_has_dwcount();
  inline void clear_has_dwcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTCommonTemplateMember > commontemplatemember_;
  ::google::protobuf::uint32 dwcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTCommonTemplatesList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfInitiator : public ::google::protobuf::Message {
 public:
  TMTConfInitiator();
  virtual ~TMTConfInitiator();

  TMTConfInitiator(const TMTConfInitiator& from);

  inline TMTConfInitiator& operator=(const TMTConfInitiator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfInitiator& default_instance();

  void Swap(TMTConfInitiator* other);

  // implements Message ----------------------------------------------

  TMTConfInitiator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfInitiator& from);
  void MergeFrom(const TMTConfInitiator& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional .mt.EmMtAddrType accounttype = 3;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccounttypeFieldNumber = 3;
  inline ::mt::EmMtAddrType accounttype() const;
  inline void set_accounttype(::mt::EmMtAddrType value);

  // optional string telephone = 4;
  inline bool has_telephone() const;
  inline void clear_telephone();
  static const int kTelephoneFieldNumber = 4;
  inline const ::std::string& telephone() const;
  inline void set_telephone(const ::std::string& value);
  inline void set_telephone(const char* value);
  inline void set_telephone(const char* value, size_t size);
  inline ::std::string* mutable_telephone();
  inline ::std::string* release_telephone();
  inline void set_allocated_telephone(::std::string* telephone);

  // optional string mobile = 5;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 5;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  inline void set_allocated_mobile(::std::string* mobile);

  // @@protoc_insertion_point(class_scope:mt.TMTConfInitiator)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_telephone();
  inline void clear_has_telephone();
  inline void set_has_mobile();
  inline void clear_has_mobile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* account_;
  ::std::string* telephone_;
  ::std::string* mobile_;
  int accounttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfInitiator* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConferenceElement : public ::google::protobuf::Message {
 public:
  TMTConferenceElement();
  virtual ~TMTConferenceElement();

  TMTConferenceElement(const TMTConferenceElement& from);

  inline TMTConferenceElement& operator=(const TMTConferenceElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConferenceElement& default_instance();

  void Swap(TMTConferenceElement* other);

  // implements Message ----------------------------------------------

  TMTConferenceElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConferenceElement& from);
  void MergeFrom(const TMTConferenceElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string confID = 2;
  inline bool has_confid() const;
  inline void clear_confid();
  static const int kConfIDFieldNumber = 2;
  inline const ::std::string& confid() const;
  inline void set_confid(const ::std::string& value);
  inline void set_confid(const char* value);
  inline void set_confid(const char* value, size_t size);
  inline ::std::string* mutable_confid();
  inline ::std::string* release_confid();
  inline void set_allocated_confid(::std::string* confid);

  // optional .mt.EmRestMeetingSafeType confType = 3;
  inline bool has_conftype() const;
  inline void clear_conftype();
  static const int kConfTypeFieldNumber = 3;
  inline ::mt::EmRestMeetingSafeType conftype() const;
  inline void set_conftype(::mt::EmRestMeetingSafeType value);

  // optional string starTime = 4;
  inline bool has_startime() const;
  inline void clear_startime();
  static const int kStarTimeFieldNumber = 4;
  inline const ::std::string& startime() const;
  inline void set_startime(const ::std::string& value);
  inline void set_startime(const char* value);
  inline void set_startime(const char* value, size_t size);
  inline ::std::string* mutable_startime();
  inline ::std::string* release_startime();
  inline void set_allocated_startime(::std::string* startime);

  // optional string endTime = 5;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 5;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional uint32 duration = 6;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 6;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 7;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 7;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmClosedMeeting closeConf = 8;
  inline bool has_closeconf() const;
  inline void clear_closeconf();
  static const int kCloseConfFieldNumber = 8;
  inline ::mt::EmClosedMeeting closeconf() const;
  inline void set_closeconf(::mt::EmClosedMeeting value);

  // optional .mt.EmMtOpenMode safeConf = 9;
  inline bool has_safeconf() const;
  inline void clear_safeconf();
  static const int kSafeConfFieldNumber = 9;
  inline ::mt::EmMtOpenMode safeconf() const;
  inline void set_safeconf(::mt::EmMtOpenMode value);

  // optional .mt.EmEncryptArithmetic encryptedtype = 10;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 10;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional string password = 11;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 11;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional bool initmute = 12;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 12;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional bool initSilence = 13;
  inline bool has_initsilence() const;
  inline void clear_initsilence();
  static const int kInitSilenceFieldNumber = 13;
  inline bool initsilence() const;
  inline void set_initsilence(bool value);

  // optional .mt.EmRestVideoQuality vidoQuality = 14;
  inline bool has_vidoquality() const;
  inline void clear_vidoquality();
  static const int kVidoQualityFieldNumber = 14;
  inline ::mt::EmRestVideoQuality vidoquality() const;
  inline void set_vidoquality(::mt::EmRestVideoQuality value);

  // optional uint32 oneReforming = 15;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOneReformingFieldNumber = 15;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional string encryptedkey = 16;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 16;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestDualMode dualmode = 17;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 17;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool voiceActivityDetection = 18;
  inline bool has_voiceactivitydetection() const;
  inline void clear_voiceactivitydetection();
  static const int kVoiceActivityDetectionFieldNumber = 18;
  inline bool voiceactivitydetection() const;
  inline void set_voiceactivitydetection(bool value);

  // optional bool publicConf = 19;
  inline bool has_publicconf() const;
  inline void clear_publicconf();
  static const int kPublicConfFieldNumber = 19;
  inline bool publicconf() const;
  inline void set_publicconf(bool value);

  // optional uint32 invitedMtNum = 20;
  inline bool has_invitedmtnum() const;
  inline void clear_invitedmtnum();
  static const int kInvitedMtNumFieldNumber = 20;
  inline ::google::protobuf::uint32 invitedmtnum() const;
  inline void set_invitedmtnum(::google::protobuf::uint32 value);

  // optional uint32 maxJoinMt = 21;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxJoinMtFieldNumber = 21;
  inline ::google::protobuf::uint32 maxjoinmt() const;
  inline void set_maxjoinmt(::google::protobuf::uint32 value);

  // optional .mt.TMTConfInitiator confInitiator = 22;
  inline bool has_confinitiator() const;
  inline void clear_confinitiator();
  static const int kConfInitiatorFieldNumber = 22;
  inline const ::mt::TMTConfInitiator& confinitiator() const;
  inline ::mt::TMTConfInitiator* mutable_confinitiator();
  inline ::mt::TMTConfInitiator* release_confinitiator();
  inline void set_allocated_confinitiator(::mt::TMTConfInitiator* confinitiator);

  // optional bool encrypted_auth = 23;
  inline bool has_encrypted_auth() const;
  inline void clear_encrypted_auth();
  static const int kEncryptedAuthFieldNumber = 23;
  inline bool encrypted_auth() const;
  inline void set_encrypted_auth(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTConferenceElement)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_confid();
  inline void clear_has_confid();
  inline void set_has_conftype();
  inline void clear_has_conftype();
  inline void set_has_startime();
  inline void clear_has_startime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_closeconf();
  inline void clear_has_closeconf();
  inline void set_has_safeconf();
  inline void clear_has_safeconf();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_initsilence();
  inline void clear_has_initsilence();
  inline void set_has_vidoquality();
  inline void clear_has_vidoquality();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_voiceactivitydetection();
  inline void clear_has_voiceactivitydetection();
  inline void set_has_publicconf();
  inline void clear_has_publicconf();
  inline void set_has_invitedmtnum();
  inline void clear_has_invitedmtnum();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_confinitiator();
  inline void clear_has_confinitiator();
  inline void set_has_encrypted_auth();
  inline void clear_has_encrypted_auth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* confid_;
  ::std::string* startime_;
  int conftype_;
  ::google::protobuf::uint32 duration_;
  ::std::string* endtime_;
  ::google::protobuf::uint32 bitrate_;
  int closeconf_;
  int safeconf_;
  int encryptedtype_;
  ::std::string* password_;
  int vidoquality_;
  ::google::protobuf::uint32 onereforming_;
  bool initmute_;
  bool initsilence_;
  bool voiceactivitydetection_;
  bool publicconf_;
  int dualmode_;
  ::std::string* encryptedkey_;
  ::google::protobuf::uint32 invitedmtnum_;
  ::google::protobuf::uint32 maxjoinmt_;
  ::mt::TMTConfInitiator* confinitiator_;
  bool encrypted_auth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConferenceElement* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTBookConferenceList : public ::google::protobuf::Message {
 public:
  TMTBookConferenceList();
  virtual ~TMTBookConferenceList();

  TMTBookConferenceList(const TMTBookConferenceList& from);

  inline TMTBookConferenceList& operator=(const TMTBookConferenceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTBookConferenceList& default_instance();

  void Swap(TMTBookConferenceList* other);

  // implements Message ----------------------------------------------

  TMTBookConferenceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTBookConferenceList& from);
  void MergeFrom(const TMTBookConferenceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTConferenceElement bookConfList = 3;
  inline int bookconflist_size() const;
  inline void clear_bookconflist();
  static const int kBookConfListFieldNumber = 3;
  inline const ::mt::TMTConferenceElement& bookconflist(int index) const;
  inline ::mt::TMTConferenceElement* mutable_bookconflist(int index);
  inline ::mt::TMTConferenceElement* add_bookconflist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTConferenceElement >&
      bookconflist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTConferenceElement >*
      mutable_bookconflist();

  // @@protoc_insertion_point(class_scope:mt.TMTBookConferenceList)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 total_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTConferenceElement > bookconflist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTBookConferenceList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTInstantConfElement : public ::google::protobuf::Message {
 public:
  TMTInstantConfElement();
  virtual ~TMTInstantConfElement();

  TMTInstantConfElement(const TMTInstantConfElement& from);

  inline TMTInstantConfElement& operator=(const TMTInstantConfElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTInstantConfElement& default_instance();

  void Swap(TMTInstantConfElement* other);

  // implements Message ----------------------------------------------

  TMTInstantConfElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTInstantConfElement& from);
  void MergeFrom(const TMTInstantConfElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string confID = 2;
  inline bool has_confid() const;
  inline void clear_confid();
  static const int kConfIDFieldNumber = 2;
  inline const ::std::string& confid() const;
  inline void set_confid(const ::std::string& value);
  inline void set_confid(const char* value);
  inline void set_confid(const char* value, size_t size);
  inline ::std::string* mutable_confid();
  inline ::std::string* release_confid();
  inline void set_allocated_confid(::std::string* confid);

  // optional bool voiceInspireEnable = 3;
  inline bool has_voiceinspireenable() const;
  inline void clear_voiceinspireenable();
  static const int kVoiceInspireEnableFieldNumber = 3;
  inline bool voiceinspireenable() const;
  inline void set_voiceinspireenable(bool value);

  // optional .mt.EmRestMeetingSafeType confType = 4;
  inline bool has_conftype() const;
  inline void clear_conftype();
  static const int kConfTypeFieldNumber = 4;
  inline ::mt::EmRestMeetingSafeType conftype() const;
  inline void set_conftype(::mt::EmRestMeetingSafeType value);

  // optional string startTime = 5;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 5;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endTime = 6;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 6;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional uint32 duration = 7;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 7;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 8;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 8;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmClosedMeeting closeConf = 9;
  inline bool has_closeconf() const;
  inline void clear_closeconf();
  static const int kCloseConfFieldNumber = 9;
  inline ::mt::EmClosedMeeting closeconf() const;
  inline void set_closeconf(::mt::EmClosedMeeting value);

  // optional .mt.EmMtOpenMode safeConf = 10;
  inline bool has_safeconf() const;
  inline void clear_safeconf();
  static const int kSafeConfFieldNumber = 10;
  inline ::mt::EmMtOpenMode safeconf() const;
  inline void set_safeconf(::mt::EmMtOpenMode value);

  // optional bool autoEnd = 11;
  inline bool has_autoend() const;
  inline void clear_autoend();
  static const int kAutoEndFieldNumber = 11;
  inline bool autoend() const;
  inline void set_autoend(bool value);

  // optional bool preoccupyResource = 12;
  inline bool has_preoccupyresource() const;
  inline void clear_preoccupyresource();
  static const int kPreoccupyResourceFieldNumber = 12;
  inline bool preoccupyresource() const;
  inline void set_preoccupyresource(bool value);

  // optional .mt.EmEncryptArithmetic encryptedtype = 13;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 13;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional bool initmute = 14;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 14;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional bool initSilence = 15;
  inline bool has_initsilence() const;
  inline void clear_initsilence();
  static const int kInitSilenceFieldNumber = 15;
  inline bool initsilence() const;
  inline void set_initsilence(bool value);

  // optional .mt.EmRestVideoQuality vidoQuality = 16;
  inline bool has_vidoquality() const;
  inline void clear_vidoquality();
  static const int kVidoQualityFieldNumber = 16;
  inline ::mt::EmRestVideoQuality vidoquality() const;
  inline void set_vidoquality(::mt::EmRestVideoQuality value);

  // optional string encryptedkey = 17;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 17;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestDualMode dualmode = 18;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 18;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool publicConf = 19;
  inline bool has_publicconf() const;
  inline void clear_publicconf();
  static const int kPublicConfFieldNumber = 19;
  inline bool publicconf() const;
  inline void set_publicconf(bool value);

  // optional uint32 maxJoinMt = 20;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxJoinMtFieldNumber = 20;
  inline ::google::protobuf::uint32 maxjoinmt() const;
  inline void set_maxjoinmt(::google::protobuf::uint32 value);

  // optional .mt.TMTConfInitiator confInitiator = 21;
  inline bool has_confinitiator() const;
  inline void clear_confinitiator();
  static const int kConfInitiatorFieldNumber = 21;
  inline const ::mt::TMTConfInitiator& confinitiator() const;
  inline ::mt::TMTConfInitiator* mutable_confinitiator();
  inline ::mt::TMTConfInitiator* release_confinitiator();
  inline void set_allocated_confinitiator(::mt::TMTConfInitiator* confinitiator);

  // optional uint32 vacinterval = 22;
  inline bool has_vacinterval() const;
  inline void clear_vacinterval();
  static const int kVacintervalFieldNumber = 22;
  inline ::google::protobuf::uint32 vacinterval() const;
  inline void set_vacinterval(::google::protobuf::uint32 value);

  // optional uint32 conflevel = 23;
  inline bool has_conflevel() const;
  inline void clear_conflevel();
  static const int kConflevelFieldNumber = 23;
  inline ::google::protobuf::uint32 conflevel() const;
  inline void set_conflevel(::google::protobuf::uint32 value);

  // optional bool needPassword = 24;
  inline bool has_needpassword() const;
  inline void clear_needpassword();
  static const int kNeedPasswordFieldNumber = 24;
  inline bool needpassword() const;
  inline void set_needpassword(bool value);

  // optional bool forcebroadcast = 25;
  inline bool has_forcebroadcast() const;
  inline void clear_forcebroadcast();
  static const int kForcebroadcastFieldNumber = 25;
  inline bool forcebroadcast() const;
  inline void set_forcebroadcast(bool value);

  // optional bool encrypted_auth = 26;
  inline bool has_encrypted_auth() const;
  inline void clear_encrypted_auth();
  static const int kEncryptedAuthFieldNumber = 26;
  inline bool encrypted_auth() const;
  inline void set_encrypted_auth(bool value);

  // optional .mt.EmMtFecMode fecmode = 27;
  inline bool has_fecmode() const;
  inline void clear_fecmode();
  static const int kFecmodeFieldNumber = 27;
  inline ::mt::EmMtFecMode fecmode() const;
  inline void set_fecmode(::mt::EmMtFecMode value);

  // optional string MeetingRoomName = 28;
  inline bool has_meetingroomname() const;
  inline void clear_meetingroomname();
  static const int kMeetingRoomNameFieldNumber = 28;
  inline const ::std::string& meetingroomname() const;
  inline void set_meetingroomname(const ::std::string& value);
  inline void set_meetingroomname(const char* value);
  inline void set_meetingroomname(const char* value, size_t size);
  inline ::std::string* mutable_meetingroomname();
  inline ::std::string* release_meetingroomname();
  inline void set_allocated_meetingroomname(::std::string* meetingroomname);

  // optional bool doubleflow = 29;
  inline bool has_doubleflow() const;
  inline void clear_doubleflow();
  static const int kDoubleflowFieldNumber = 29;
  inline bool doubleflow() const;
  inline void set_doubleflow(bool value);

  // optional bool mutefilter = 30;
  inline bool has_mutefilter() const;
  inline void clear_mutefilter();
  static const int kMutefilterFieldNumber = 30;
  inline bool mutefilter() const;
  inline void set_mutefilter(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTInstantConfElement)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_confid();
  inline void clear_has_confid();
  inline void set_has_voiceinspireenable();
  inline void clear_has_voiceinspireenable();
  inline void set_has_conftype();
  inline void clear_has_conftype();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_closeconf();
  inline void clear_has_closeconf();
  inline void set_has_safeconf();
  inline void clear_has_safeconf();
  inline void set_has_autoend();
  inline void clear_has_autoend();
  inline void set_has_preoccupyresource();
  inline void clear_has_preoccupyresource();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_initsilence();
  inline void clear_has_initsilence();
  inline void set_has_vidoquality();
  inline void clear_has_vidoquality();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_publicconf();
  inline void clear_has_publicconf();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_confinitiator();
  inline void clear_has_confinitiator();
  inline void set_has_vacinterval();
  inline void clear_has_vacinterval();
  inline void set_has_conflevel();
  inline void clear_has_conflevel();
  inline void set_has_needpassword();
  inline void clear_has_needpassword();
  inline void set_has_forcebroadcast();
  inline void clear_has_forcebroadcast();
  inline void set_has_encrypted_auth();
  inline void clear_has_encrypted_auth();
  inline void set_has_fecmode();
  inline void clear_has_fecmode();
  inline void set_has_meetingroomname();
  inline void clear_has_meetingroomname();
  inline void set_has_doubleflow();
  inline void clear_has_doubleflow();
  inline void set_has_mutefilter();
  inline void clear_has_mutefilter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* confid_;
  ::std::string* starttime_;
  int conftype_;
  ::google::protobuf::uint32 duration_;
  ::std::string* endtime_;
  ::google::protobuf::uint32 bitrate_;
  int closeconf_;
  int safeconf_;
  bool voiceinspireenable_;
  bool autoend_;
  bool preoccupyresource_;
  bool initmute_;
  int encryptedtype_;
  int vidoquality_;
  ::std::string* encryptedkey_;
  int dualmode_;
  ::google::protobuf::uint32 maxjoinmt_;
  ::mt::TMTConfInitiator* confinitiator_;
  bool initsilence_;
  bool publicconf_;
  bool needpassword_;
  bool forcebroadcast_;
  ::google::protobuf::uint32 vacinterval_;
  ::google::protobuf::uint32 conflevel_;
  int fecmode_;
  ::std::string* meetingroomname_;
  bool encrypted_auth_;
  bool doubleflow_;
  bool mutefilter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTInstantConfElement* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTInstantConferenceList : public ::google::protobuf::Message {
 public:
  TMTInstantConferenceList();
  virtual ~TMTInstantConferenceList();

  TMTInstantConferenceList(const TMTInstantConferenceList& from);

  inline TMTInstantConferenceList& operator=(const TMTInstantConferenceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTInstantConferenceList& default_instance();

  void Swap(TMTInstantConferenceList* other);

  // implements Message ----------------------------------------------

  TMTInstantConferenceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTInstantConferenceList& from);
  void MergeFrom(const TMTInstantConferenceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTInstantConfElement instantConfList = 3;
  inline int instantconflist_size() const;
  inline void clear_instantconflist();
  static const int kInstantConfListFieldNumber = 3;
  inline const ::mt::TMTInstantConfElement& instantconflist(int index) const;
  inline ::mt::TMTInstantConfElement* mutable_instantconflist(int index);
  inline ::mt::TMTInstantConfElement* add_instantconflist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTInstantConfElement >&
      instantconflist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTInstantConfElement >*
      mutable_instantconflist();

  // @@protoc_insertion_point(class_scope:mt.TMTInstantConferenceList)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 total_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTInstantConfElement > instantconflist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTInstantConferenceList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConditionOfConfList : public ::google::protobuf::Message {
 public:
  TMTConditionOfConfList();
  virtual ~TMTConditionOfConfList();

  TMTConditionOfConfList(const TMTConditionOfConfList& from);

  inline TMTConditionOfConfList& operator=(const TMTConditionOfConfList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConditionOfConfList& default_instance();

  void Swap(TMTConditionOfConfList* other);

  // implements Message ----------------------------------------------

  TMTConditionOfConfList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConditionOfConfList& from);
  void MergeFrom(const TMTConditionOfConfList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string starTime = 1;
  inline bool has_startime() const;
  inline void clear_startime();
  static const int kStarTimeFieldNumber = 1;
  inline const ::std::string& startime() const;
  inline void set_startime(const ::std::string& value);
  inline void set_startime(const char* value);
  inline void set_startime(const char* value, size_t size);
  inline ::std::string* mutable_startime();
  inline ::std::string* release_startime();
  inline void set_allocated_startime(::std::string* startime);

  // optional string endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional uint32 start = 3;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 3;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 5;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 5;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTConditionOfConfList)
 private:
  inline void set_has_startime();
  inline void clear_has_startime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* startime_;
  ::std::string* endtime_;
  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConditionOfConfList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTBookConferenceInfo : public ::google::protobuf::Message {
 public:
  TMTBookConferenceInfo();
  virtual ~TMTBookConferenceInfo();

  TMTBookConferenceInfo(const TMTBookConferenceInfo& from);

  inline TMTBookConferenceInfo& operator=(const TMTBookConferenceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTBookConferenceInfo& default_instance();

  void Swap(TMTBookConferenceInfo* other);

  // implements Message ----------------------------------------------

  TMTBookConferenceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTBookConferenceInfo& from);
  void MergeFrom(const TMTBookConferenceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string confID = 2;
  inline bool has_confid() const;
  inline void clear_confid();
  static const int kConfIDFieldNumber = 2;
  inline const ::std::string& confid() const;
  inline void set_confid(const ::std::string& value);
  inline void set_confid(const char* value);
  inline void set_confid(const char* value, size_t size);
  inline ::std::string* mutable_confid();
  inline ::std::string* release_confid();
  inline void set_allocated_confid(::std::string* confid);

  // optional .mt.EmRestMeetingSafeType confType = 3;
  inline bool has_conftype() const;
  inline void clear_conftype();
  static const int kConfTypeFieldNumber = 3;
  inline ::mt::EmRestMeetingSafeType conftype() const;
  inline void set_conftype(::mt::EmRestMeetingSafeType value);

  // optional string starTime = 4;
  inline bool has_startime() const;
  inline void clear_startime();
  static const int kStarTimeFieldNumber = 4;
  inline const ::std::string& startime() const;
  inline void set_startime(const ::std::string& value);
  inline void set_startime(const char* value);
  inline void set_startime(const char* value, size_t size);
  inline ::std::string* mutable_startime();
  inline ::std::string* release_startime();
  inline void set_allocated_startime(::std::string* startime);

  // optional string endTime = 5;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 5;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional uint32 duration = 6;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 6;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 7;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 7;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmClosedMeeting closeConf = 8;
  inline bool has_closeconf() const;
  inline void clear_closeconf();
  static const int kCloseConfFieldNumber = 8;
  inline ::mt::EmClosedMeeting closeconf() const;
  inline void set_closeconf(::mt::EmClosedMeeting value);

  // optional .mt.EmMtOpenMode safeConf = 9;
  inline bool has_safeconf() const;
  inline void clear_safeconf();
  static const int kSafeConfFieldNumber = 9;
  inline ::mt::EmMtOpenMode safeconf() const;
  inline void set_safeconf(::mt::EmMtOpenMode value);

  // optional string password = 10;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 10;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .mt.EmEncryptArithmetic encryptedtype = 11;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 11;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional string encryptedkey = 12;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 12;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional uint32 callTimes = 13;
  inline bool has_calltimes() const;
  inline void clear_calltimes();
  static const int kCallTimesFieldNumber = 13;
  inline ::google::protobuf::uint32 calltimes() const;
  inline void set_calltimes(::google::protobuf::uint32 value);

  // optional uint32 callInterval = 14;
  inline bool has_callinterval() const;
  inline void clear_callinterval();
  static const int kCallIntervalFieldNumber = 14;
  inline ::google::protobuf::uint32 callinterval() const;
  inline void set_callinterval(::google::protobuf::uint32 value);

  // optional bool initmute = 15;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 15;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional bool initSilence = 16;
  inline bool has_initsilence() const;
  inline void clear_initsilence();
  static const int kInitSilenceFieldNumber = 16;
  inline bool initsilence() const;
  inline void set_initsilence(bool value);

  // optional .mt.EmRestVideoQuality vidoQuality = 17;
  inline bool has_vidoquality() const;
  inline void clear_vidoquality();
  static const int kVidoQualityFieldNumber = 17;
  inline ::mt::EmRestVideoQuality vidoquality() const;
  inline void set_vidoquality(::mt::EmRestVideoQuality value);

  // optional .mt.EmRestDualMode dualmode = 18;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 18;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool voiceActivityDetection = 19;
  inline bool has_voiceactivitydetection() const;
  inline void clear_voiceactivitydetection();
  static const int kVoiceActivityDetectionFieldNumber = 19;
  inline bool voiceactivitydetection() const;
  inline void set_voiceactivitydetection(bool value);

  // optional .mt.EmRestCascadeMode emCascadeMode = 20;
  inline bool has_emcascademode() const;
  inline void clear_emcascademode();
  static const int kEmCascadeModeFieldNumber = 20;
  inline ::mt::EmRestCascadeMode emcascademode() const;
  inline void set_emcascademode(::mt::EmRestCascadeMode value);

  // optional bool cascadeUpload = 21;
  inline bool has_cascadeupload() const;
  inline void clear_cascadeupload();
  static const int kCascadeUploadFieldNumber = 21;
  inline bool cascadeupload() const;
  inline void set_cascadeupload(bool value);

  // optional bool cascadeReturn = 22;
  inline bool has_cascadereturn() const;
  inline void clear_cascadereturn();
  static const int kCascadeReturnFieldNumber = 22;
  inline bool cascadereturn() const;
  inline void set_cascadereturn(bool value);

  // optional uint32 cascadeReturnPara = 23;
  inline bool has_cascadereturnpara() const;
  inline void clear_cascadereturnpara();
  static const int kCascadeReturnParaFieldNumber = 23;
  inline ::google::protobuf::uint32 cascadereturnpara() const;
  inline void set_cascadereturnpara(::google::protobuf::uint32 value);

  // optional bool publicConf = 24;
  inline bool has_publicconf() const;
  inline void clear_publicconf();
  static const int kPublicConfFieldNumber = 24;
  inline bool publicconf() const;
  inline void set_publicconf(bool value);

  // optional bool vmpEnable = 25;
  inline bool has_vmpenable() const;
  inline void clear_vmpenable();
  static const int kVmpEnableFieldNumber = 25;
  inline bool vmpenable() const;
  inline void set_vmpenable(bool value);

  // optional bool mixEnable = 26;
  inline bool has_mixenable() const;
  inline void clear_mixenable();
  static const int kMixEnableFieldNumber = 26;
  inline bool mixenable() const;
  inline void set_mixenable(bool value);

  // optional bool pollEnable = 27;
  inline bool has_pollenable() const;
  inline void clear_pollenable();
  static const int kPollEnableFieldNumber = 27;
  inline bool pollenable() const;
  inline void set_pollenable(bool value);

  // optional uint32 invitedMtNum = 28;
  inline bool has_invitedmtnum() const;
  inline void clear_invitedmtnum();
  static const int kInvitedMtNumFieldNumber = 28;
  inline ::google::protobuf::uint32 invitedmtnum() const;
  inline void set_invitedmtnum(::google::protobuf::uint32 value);

  // optional uint32 maxJoinMt = 29;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxJoinMtFieldNumber = 29;
  inline ::google::protobuf::uint32 maxjoinmt() const;
  inline void set_maxjoinmt(::google::protobuf::uint32 value);

  // optional .mt.TMTConfInitiator confInitiator = 30;
  inline bool has_confinitiator() const;
  inline void clear_confinitiator();
  static const int kConfInitiatorFieldNumber = 30;
  inline const ::mt::TMTConfInitiator& confinitiator() const;
  inline ::mt::TMTConfInitiator* mutable_confinitiator();
  inline ::mt::TMTConfInitiator* release_confinitiator();
  inline void set_allocated_confinitiator(::mt::TMTConfInitiator* confinitiator);

  // optional .mt.TMTTemplateMember speaker = 31;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 31;
  inline const ::mt::TMTTemplateMember& speaker() const;
  inline ::mt::TMTTemplateMember* mutable_speaker();
  inline ::mt::TMTTemplateMember* release_speaker();
  inline void set_allocated_speaker(::mt::TMTTemplateMember* speaker);

  // optional .mt.TMTTemplateMember chairman = 32;
  inline bool has_chairman() const;
  inline void clear_chairman();
  static const int kChairmanFieldNumber = 32;
  inline const ::mt::TMTTemplateMember& chairman() const;
  inline ::mt::TMTTemplateMember* mutable_chairman();
  inline ::mt::TMTTemplateMember* release_chairman();
  inline void set_allocated_chairman(::mt::TMTTemplateMember* chairman);

  // repeated .mt.TMTVideoFormatList videoFormatList = 33;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoFormatListFieldNumber = 33;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // optional uint32 oneReforming = 34;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOneReformingFieldNumber = 34;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional bool autoEnd = 35;
  inline bool has_autoend() const;
  inline void clear_autoend();
  static const int kAutoEndFieldNumber = 35;
  inline bool autoend() const;
  inline void set_autoend(bool value);

  // optional bool preoccpuyResouce = 36;
  inline bool has_preoccpuyresouce() const;
  inline void clear_preoccpuyresouce();
  static const int kPreoccpuyResouceFieldNumber = 36;
  inline bool preoccpuyresouce() const;
  inline void set_preoccpuyresouce(bool value);

  // optional bool encrypted_auth = 37;
  inline bool has_encrypted_auth() const;
  inline void clear_encrypted_auth();
  static const int kEncryptedAuthFieldNumber = 37;
  inline bool encrypted_auth() const;
  inline void set_encrypted_auth(bool value);

  // optional .mt.EmMtFecMode fecmode = 38;
  inline bool has_fecmode() const;
  inline void clear_fecmode();
  static const int kFecmodeFieldNumber = 38;
  inline ::mt::EmMtFecMode fecmode() const;
  inline void set_fecmode(::mt::EmMtFecMode value);

  // optional bool doubleflow = 39;
  inline bool has_doubleflow() const;
  inline void clear_doubleflow();
  static const int kDoubleflowFieldNumber = 39;
  inline bool doubleflow() const;
  inline void set_doubleflow(bool value);

  // optional bool mutefilter = 40;
  inline bool has_mutefilter() const;
  inline void clear_mutefilter();
  static const int kMutefilterFieldNumber = 40;
  inline bool mutefilter() const;
  inline void set_mutefilter(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTBookConferenceInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_confid();
  inline void clear_has_confid();
  inline void set_has_conftype();
  inline void clear_has_conftype();
  inline void set_has_startime();
  inline void clear_has_startime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_closeconf();
  inline void clear_has_closeconf();
  inline void set_has_safeconf();
  inline void clear_has_safeconf();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_calltimes();
  inline void clear_has_calltimes();
  inline void set_has_callinterval();
  inline void clear_has_callinterval();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_initsilence();
  inline void clear_has_initsilence();
  inline void set_has_vidoquality();
  inline void clear_has_vidoquality();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_voiceactivitydetection();
  inline void clear_has_voiceactivitydetection();
  inline void set_has_emcascademode();
  inline void clear_has_emcascademode();
  inline void set_has_cascadeupload();
  inline void clear_has_cascadeupload();
  inline void set_has_cascadereturn();
  inline void clear_has_cascadereturn();
  inline void set_has_cascadereturnpara();
  inline void clear_has_cascadereturnpara();
  inline void set_has_publicconf();
  inline void clear_has_publicconf();
  inline void set_has_vmpenable();
  inline void clear_has_vmpenable();
  inline void set_has_mixenable();
  inline void clear_has_mixenable();
  inline void set_has_pollenable();
  inline void clear_has_pollenable();
  inline void set_has_invitedmtnum();
  inline void clear_has_invitedmtnum();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_confinitiator();
  inline void clear_has_confinitiator();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_chairman();
  inline void clear_has_chairman();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_autoend();
  inline void clear_has_autoend();
  inline void set_has_preoccpuyresouce();
  inline void clear_has_preoccpuyresouce();
  inline void set_has_encrypted_auth();
  inline void clear_has_encrypted_auth();
  inline void set_has_fecmode();
  inline void clear_has_fecmode();
  inline void set_has_doubleflow();
  inline void clear_has_doubleflow();
  inline void set_has_mutefilter();
  inline void clear_has_mutefilter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* confid_;
  ::std::string* startime_;
  int conftype_;
  ::google::protobuf::uint32 duration_;
  ::std::string* endtime_;
  ::google::protobuf::uint32 bitrate_;
  int closeconf_;
  ::std::string* password_;
  int safeconf_;
  int encryptedtype_;
  ::std::string* encryptedkey_;
  ::google::protobuf::uint32 calltimes_;
  ::google::protobuf::uint32 callinterval_;
  int vidoquality_;
  bool initmute_;
  bool initsilence_;
  bool voiceactivitydetection_;
  bool cascadeupload_;
  int dualmode_;
  int emcascademode_;
  ::google::protobuf::uint32 cascadereturnpara_;
  bool cascadereturn_;
  bool publicconf_;
  bool vmpenable_;
  bool mixenable_;
  ::google::protobuf::uint32 invitedmtnum_;
  ::google::protobuf::uint32 maxjoinmt_;
  ::mt::TMTConfInitiator* confinitiator_;
  ::mt::TMTTemplateMember* speaker_;
  ::mt::TMTTemplateMember* chairman_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  bool pollenable_;
  bool autoend_;
  bool preoccpuyresouce_;
  bool encrypted_auth_;
  ::google::protobuf::uint32 onereforming_;
  int fecmode_;
  bool doubleflow_;
  bool mutefilter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(40 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTBookConferenceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTInstantConference : public ::google::protobuf::Message {
 public:
  TMTInstantConference();
  virtual ~TMTInstantConference();

  TMTInstantConference(const TMTInstantConference& from);

  inline TMTInstantConference& operator=(const TMTInstantConference& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTInstantConference& default_instance();

  void Swap(TMTInstantConference* other);

  // implements Message ----------------------------------------------

  TMTInstantConference* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTInstantConference& from);
  void MergeFrom(const TMTInstantConference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 3;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmClosedMeeting closeConf = 4;
  inline bool has_closeconf() const;
  inline void clear_closeconf();
  static const int kCloseConfFieldNumber = 4;
  inline ::mt::EmClosedMeeting closeconf() const;
  inline void set_closeconf(::mt::EmClosedMeeting value);

  // optional .mt.EmMtOpenMode safeConf = 5;
  inline bool has_safeconf() const;
  inline void clear_safeconf();
  static const int kSafeConfFieldNumber = 5;
  inline ::mt::EmMtOpenMode safeconf() const;
  inline void set_safeconf(::mt::EmMtOpenMode value);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .mt.EmEncryptArithmetic encryptedtype = 7;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 7;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional .mt.EmRestMeetingSafeType meetingtype = 8;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 8;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional uint32 callTimes = 9;
  inline bool has_calltimes() const;
  inline void clear_calltimes();
  static const int kCallTimesFieldNumber = 9;
  inline ::google::protobuf::uint32 calltimes() const;
  inline void set_calltimes(::google::protobuf::uint32 value);

  // optional uint32 callInterval = 10;
  inline bool has_callinterval() const;
  inline void clear_callinterval();
  static const int kCallIntervalFieldNumber = 10;
  inline ::google::protobuf::uint32 callinterval() const;
  inline void set_callinterval(::google::protobuf::uint32 value);

  // optional bool initmute = 11;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 11;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional bool initSilence = 12;
  inline bool has_initsilence() const;
  inline void clear_initsilence();
  static const int kInitSilenceFieldNumber = 12;
  inline bool initsilence() const;
  inline void set_initsilence(bool value);

  // optional .mt.EmRestVideoQuality vidoQuality = 13;
  inline bool has_vidoquality() const;
  inline void clear_vidoquality();
  static const int kVidoQualityFieldNumber = 13;
  inline ::mt::EmRestVideoQuality vidoquality() const;
  inline void set_vidoquality(::mt::EmRestVideoQuality value);

  // optional string encryptedkey = 14;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 14;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestDualMode dualmode = 15;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 15;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool voiceActivityDetection = 16;
  inline bool has_voiceactivitydetection() const;
  inline void clear_voiceactivitydetection();
  static const int kVoiceActivityDetectionFieldNumber = 16;
  inline bool voiceactivitydetection() const;
  inline void set_voiceactivitydetection(bool value);

  // optional .mt.EmRestCascadeMode emCascadeMode = 17;
  inline bool has_emcascademode() const;
  inline void clear_emcascademode();
  static const int kEmCascadeModeFieldNumber = 17;
  inline ::mt::EmRestCascadeMode emcascademode() const;
  inline void set_emcascademode(::mt::EmRestCascadeMode value);

  // optional bool cascadeUpload = 18;
  inline bool has_cascadeupload() const;
  inline void clear_cascadeupload();
  static const int kCascadeUploadFieldNumber = 18;
  inline bool cascadeupload() const;
  inline void set_cascadeupload(bool value);

  // optional bool cascadeReturn = 19;
  inline bool has_cascadereturn() const;
  inline void clear_cascadereturn();
  static const int kCascadeReturnFieldNumber = 19;
  inline bool cascadereturn() const;
  inline void set_cascadereturn(bool value);

  // optional uint32 cascadeReturnPara = 20;
  inline bool has_cascadereturnpara() const;
  inline void clear_cascadereturnpara();
  static const int kCascadeReturnParaFieldNumber = 20;
  inline ::google::protobuf::uint32 cascadereturnpara() const;
  inline void set_cascadereturnpara(::google::protobuf::uint32 value);

  // optional uint32 maxJoinMt = 21;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxJoinMtFieldNumber = 21;
  inline ::google::protobuf::uint32 maxjoinmt() const;
  inline void set_maxjoinmt(::google::protobuf::uint32 value);

  // optional .mt.TMTTemplateMember speaker = 22;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 22;
  inline const ::mt::TMTTemplateMember& speaker() const;
  inline ::mt::TMTTemplateMember* mutable_speaker();
  inline ::mt::TMTTemplateMember* release_speaker();
  inline void set_allocated_speaker(::mt::TMTTemplateMember* speaker);

  // optional .mt.TMTTemplateMember chairman = 23;
  inline bool has_chairman() const;
  inline void clear_chairman();
  static const int kChairmanFieldNumber = 23;
  inline const ::mt::TMTTemplateMember& chairman() const;
  inline ::mt::TMTTemplateMember* mutable_chairman();
  inline ::mt::TMTTemplateMember* release_chairman();
  inline void set_allocated_chairman(::mt::TMTTemplateMember* chairman);

  // optional bool publicConf = 24;
  inline bool has_publicconf() const;
  inline void clear_publicconf();
  static const int kPublicConfFieldNumber = 24;
  inline bool publicconf() const;
  inline void set_publicconf(bool value);

  // optional .mt.TMTConfMixInfo mix = 25;
  inline bool has_mix() const;
  inline void clear_mix();
  static const int kMixFieldNumber = 25;
  inline const ::mt::TMTConfMixInfo& mix() const;
  inline ::mt::TMTConfMixInfo* mutable_mix();
  inline ::mt::TMTConfMixInfo* release_mix();
  inline void set_allocated_mix(::mt::TMTConfMixInfo* mix);

  // repeated .mt.TMTVideoFormatList videoFormatList = 26;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoFormatListFieldNumber = 26;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // repeated .mt.TMTInviteMember inviteMembers = 27;
  inline int invitemembers_size() const;
  inline void clear_invitemembers();
  static const int kInviteMembersFieldNumber = 27;
  inline const ::mt::TMTInviteMember& invitemembers(int index) const;
  inline ::mt::TMTInviteMember* mutable_invitemembers(int index);
  inline ::mt::TMTInviteMember* add_invitemembers();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >&
      invitemembers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >*
      mutable_invitemembers();

  // optional .mt.TMTConfVMPInfo vmp = 28;
  inline bool has_vmp() const;
  inline void clear_vmp();
  static const int kVmpFieldNumber = 28;
  inline const ::mt::TMTConfVMPInfo& vmp() const;
  inline ::mt::TMTConfVMPInfo* mutable_vmp();
  inline ::mt::TMTConfVMPInfo* release_vmp();
  inline void set_allocated_vmp(::mt::TMTConfVMPInfo* vmp);

  // repeated .mt.TMTTemplateMember viplist = 29;
  inline int viplist_size() const;
  inline void clear_viplist();
  static const int kViplistFieldNumber = 29;
  inline const ::mt::TMTTemplateMember& viplist(int index) const;
  inline ::mt::TMTTemplateMember* mutable_viplist(int index);
  inline ::mt::TMTTemplateMember* add_viplist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      viplist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_viplist();

  // optional .mt.TMTConfPollInfo poll = 30;
  inline bool has_poll() const;
  inline void clear_poll();
  static const int kPollFieldNumber = 30;
  inline const ::mt::TMTConfPollInfo& poll() const;
  inline ::mt::TMTConfPollInfo* mutable_poll();
  inline ::mt::TMTConfPollInfo* release_poll();
  inline void set_allocated_poll(::mt::TMTConfPollInfo* poll);

  // optional bool autoEnd = 31;
  inline bool has_autoend() const;
  inline void clear_autoend();
  static const int kAutoEndFieldNumber = 31;
  inline bool autoend() const;
  inline void set_autoend(bool value);

  // optional bool preoccpuyResouce = 32;
  inline bool has_preoccpuyresouce() const;
  inline void clear_preoccpuyresouce();
  static const int kPreoccpuyResouceFieldNumber = 32;
  inline bool preoccpuyresouce() const;
  inline void set_preoccpuyresouce(bool value);

  // optional uint32 vacinterval = 33;
  inline bool has_vacinterval() const;
  inline void clear_vacinterval();
  static const int kVacintervalFieldNumber = 33;
  inline ::google::protobuf::uint32 vacinterval() const;
  inline void set_vacinterval(::google::protobuf::uint32 value);

  // optional .mt.TMTRecordAttribute recordattr = 34;
  inline bool has_recordattr() const;
  inline void clear_recordattr();
  static const int kRecordattrFieldNumber = 34;
  inline const ::mt::TMTRecordAttribute& recordattr() const;
  inline ::mt::TMTRecordAttribute* mutable_recordattr();
  inline ::mt::TMTRecordAttribute* release_recordattr();
  inline void set_allocated_recordattr(::mt::TMTRecordAttribute* recordattr);

  // optional bool encrypted_auth = 35;
  inline bool has_encrypted_auth() const;
  inline void clear_encrypted_auth();
  static const int kEncryptedAuthFieldNumber = 35;
  inline bool encrypted_auth() const;
  inline void set_encrypted_auth(bool value);

  // optional .mt.EmCallMode emCallMode = 36;
  inline bool has_emcallmode() const;
  inline void clear_emcallmode();
  static const int kEmCallModeFieldNumber = 36;
  inline ::mt::EmCallMode emcallmode() const;
  inline void set_emcallmode(::mt::EmCallMode value);

  // optional .mt.TMTDCSAttribute dcsattr = 37;
  inline bool has_dcsattr() const;
  inline void clear_dcsattr();
  static const int kDcsattrFieldNumber = 37;
  inline const ::mt::TMTDCSAttribute& dcsattr() const;
  inline ::mt::TMTDCSAttribute* mutable_dcsattr();
  inline ::mt::TMTDCSAttribute* release_dcsattr();
  inline void set_allocated_dcsattr(::mt::TMTDCSAttribute* dcsattr);

  // optional .mt.EmVConfCreateType vconfcreatetype = 38;
  inline bool has_vconfcreatetype() const;
  inline void clear_vconfcreatetype();
  static const int kVconfcreatetypeFieldNumber = 38;
  inline ::mt::EmVConfCreateType vconfcreatetype() const;
  inline void set_vconfcreatetype(::mt::EmVConfCreateType value);

  // optional string vconfid = 39;
  inline bool has_vconfid() const;
  inline void clear_vconfid();
  static const int kVconfidFieldNumber = 39;
  inline const ::std::string& vconfid() const;
  inline void set_vconfid(const ::std::string& value);
  inline void set_vconfid(const char* value);
  inline void set_vconfid(const char* value, size_t size);
  inline ::std::string* mutable_vconfid();
  inline ::std::string* release_vconfid();
  inline void set_allocated_vconfid(::std::string* vconfid);

  // optional .mt.EmMtFecMode fecmode = 40;
  inline bool has_fecmode() const;
  inline void clear_fecmode();
  static const int kFecmodeFieldNumber = 40;
  inline ::mt::EmMtFecMode fecmode() const;
  inline void set_fecmode(::mt::EmMtFecMode value);

  // optional bool doubleflow = 41;
  inline bool has_doubleflow() const;
  inline void clear_doubleflow();
  static const int kDoubleflowFieldNumber = 41;
  inline bool doubleflow() const;
  inline void set_doubleflow(bool value);

  // optional bool mutefilter = 42;
  inline bool has_mutefilter() const;
  inline void clear_mutefilter();
  static const int kMutefilterFieldNumber = 42;
  inline bool mutefilter() const;
  inline void set_mutefilter(bool value);

  // repeated .mt.TMTTemplateMember keepcallingmembers = 43;
  inline int keepcallingmembers_size() const;
  inline void clear_keepcallingmembers();
  static const int kKeepcallingmembersFieldNumber = 43;
  inline const ::mt::TMTTemplateMember& keepcallingmembers(int index) const;
  inline ::mt::TMTTemplateMember* mutable_keepcallingmembers(int index);
  inline ::mt::TMTTemplateMember* add_keepcallingmembers();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
      keepcallingmembers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
      mutable_keepcallingmembers();

  // @@protoc_insertion_point(class_scope:mt.TMTInstantConference)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_closeconf();
  inline void clear_has_closeconf();
  inline void set_has_safeconf();
  inline void clear_has_safeconf();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_calltimes();
  inline void clear_has_calltimes();
  inline void set_has_callinterval();
  inline void clear_has_callinterval();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_initsilence();
  inline void clear_has_initsilence();
  inline void set_has_vidoquality();
  inline void clear_has_vidoquality();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_voiceactivitydetection();
  inline void clear_has_voiceactivitydetection();
  inline void set_has_emcascademode();
  inline void clear_has_emcascademode();
  inline void set_has_cascadeupload();
  inline void clear_has_cascadeupload();
  inline void set_has_cascadereturn();
  inline void clear_has_cascadereturn();
  inline void set_has_cascadereturnpara();
  inline void clear_has_cascadereturnpara();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_chairman();
  inline void clear_has_chairman();
  inline void set_has_publicconf();
  inline void clear_has_publicconf();
  inline void set_has_mix();
  inline void clear_has_mix();
  inline void set_has_vmp();
  inline void clear_has_vmp();
  inline void set_has_poll();
  inline void clear_has_poll();
  inline void set_has_autoend();
  inline void clear_has_autoend();
  inline void set_has_preoccpuyresouce();
  inline void clear_has_preoccpuyresouce();
  inline void set_has_vacinterval();
  inline void clear_has_vacinterval();
  inline void set_has_recordattr();
  inline void clear_has_recordattr();
  inline void set_has_encrypted_auth();
  inline void clear_has_encrypted_auth();
  inline void set_has_emcallmode();
  inline void clear_has_emcallmode();
  inline void set_has_dcsattr();
  inline void clear_has_dcsattr();
  inline void set_has_vconfcreatetype();
  inline void clear_has_vconfcreatetype();
  inline void set_has_vconfid();
  inline void clear_has_vconfid();
  inline void set_has_fecmode();
  inline void clear_has_fecmode();
  inline void set_has_doubleflow();
  inline void clear_has_doubleflow();
  inline void set_has_mutefilter();
  inline void clear_has_mutefilter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 bitrate_;
  int closeconf_;
  int safeconf_;
  ::std::string* password_;
  int encryptedtype_;
  int meetingtype_;
  ::google::protobuf::uint32 calltimes_;
  ::google::protobuf::uint32 callinterval_;
  ::std::string* encryptedkey_;
  int vidoquality_;
  bool initmute_;
  bool initsilence_;
  bool voiceactivitydetection_;
  bool cascadeupload_;
  int dualmode_;
  int emcascademode_;
  ::google::protobuf::uint32 cascadereturnpara_;
  ::google::protobuf::uint32 maxjoinmt_;
  ::mt::TMTTemplateMember* speaker_;
  ::mt::TMTTemplateMember* chairman_;
  ::mt::TMTConfMixInfo* mix_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember > invitemembers_;
  bool cascadereturn_;
  bool publicconf_;
  bool autoend_;
  bool preoccpuyresouce_;
  ::google::protobuf::uint32 vacinterval_;
  ::mt::TMTConfVMPInfo* vmp_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > viplist_;
  ::mt::TMTConfPollInfo* poll_;
  ::mt::TMTRecordAttribute* recordattr_;
  ::mt::TMTDCSAttribute* dcsattr_;
  int emcallmode_;
  int vconfcreatetype_;
  ::std::string* vconfid_;
  bool encrypted_auth_;
  bool doubleflow_;
  bool mutefilter_;
  int fecmode_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember > keepcallingmembers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(43 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTInstantConference* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTInstantConferenceInfo : public ::google::protobuf::Message {
 public:
  TMTInstantConferenceInfo();
  virtual ~TMTInstantConferenceInfo();

  TMTInstantConferenceInfo(const TMTInstantConferenceInfo& from);

  inline TMTInstantConferenceInfo& operator=(const TMTInstantConferenceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTInstantConferenceInfo& default_instance();

  void Swap(TMTInstantConferenceInfo* other);

  // implements Message ----------------------------------------------

  TMTInstantConferenceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTInstantConferenceInfo& from);
  void MergeFrom(const TMTInstantConferenceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string confID = 2;
  inline bool has_confid() const;
  inline void clear_confid();
  static const int kConfIDFieldNumber = 2;
  inline const ::std::string& confid() const;
  inline void set_confid(const ::std::string& value);
  inline void set_confid(const char* value);
  inline void set_confid(const char* value, size_t size);
  inline ::std::string* mutable_confid();
  inline ::std::string* release_confid();
  inline void set_allocated_confid(::std::string* confid);

  // optional .mt.EmRestMeetingSafeType confType = 3;
  inline bool has_conftype() const;
  inline void clear_conftype();
  static const int kConfTypeFieldNumber = 3;
  inline ::mt::EmRestMeetingSafeType conftype() const;
  inline void set_conftype(::mt::EmRestMeetingSafeType value);

  // optional string starTime = 4;
  inline bool has_startime() const;
  inline void clear_startime();
  static const int kStarTimeFieldNumber = 4;
  inline const ::std::string& startime() const;
  inline void set_startime(const ::std::string& value);
  inline void set_startime(const char* value);
  inline void set_startime(const char* value, size_t size);
  inline ::std::string* mutable_startime();
  inline ::std::string* release_startime();
  inline void set_allocated_startime(::std::string* startime);

  // optional string endTime = 5;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 5;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional uint32 duration = 6;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 6;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 7;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 7;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmClosedMeeting closeConf = 8;
  inline bool has_closeconf() const;
  inline void clear_closeconf();
  static const int kCloseConfFieldNumber = 8;
  inline ::mt::EmClosedMeeting closeconf() const;
  inline void set_closeconf(::mt::EmClosedMeeting value);

  // optional .mt.EmMtOpenMode safeConf = 9;
  inline bool has_safeconf() const;
  inline void clear_safeconf();
  static const int kSafeConfFieldNumber = 9;
  inline ::mt::EmMtOpenMode safeconf() const;
  inline void set_safeconf(::mt::EmMtOpenMode value);

  // optional .mt.EmEncryptArithmetic encryptedtype = 10;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 10;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional uint32 callTimes = 11;
  inline bool has_calltimes() const;
  inline void clear_calltimes();
  static const int kCallTimesFieldNumber = 11;
  inline ::google::protobuf::uint32 calltimes() const;
  inline void set_calltimes(::google::protobuf::uint32 value);

  // optional uint32 callInterval = 12;
  inline bool has_callinterval() const;
  inline void clear_callinterval();
  static const int kCallIntervalFieldNumber = 12;
  inline ::google::protobuf::uint32 callinterval() const;
  inline void set_callinterval(::google::protobuf::uint32 value);

  // optional bool forcebroadcast = 13;
  inline bool has_forcebroadcast() const;
  inline void clear_forcebroadcast();
  static const int kForcebroadcastFieldNumber = 13;
  inline bool forcebroadcast() const;
  inline void set_forcebroadcast(bool value);

  // optional bool initmute = 14;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 14;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional bool initSilence = 15;
  inline bool has_initsilence() const;
  inline void clear_initsilence();
  static const int kInitSilenceFieldNumber = 15;
  inline bool initsilence() const;
  inline void set_initsilence(bool value);

  // optional .mt.EmRestVideoQuality vidoQuality = 16;
  inline bool has_vidoquality() const;
  inline void clear_vidoquality();
  static const int kVidoQualityFieldNumber = 16;
  inline ::mt::EmRestVideoQuality vidoquality() const;
  inline void set_vidoquality(::mt::EmRestVideoQuality value);

  // optional string encryptedkey = 17;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 17;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmRestDualMode dualmode = 18;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 18;
  inline ::mt::EmRestDualMode dualmode() const;
  inline void set_dualmode(::mt::EmRestDualMode value);

  // optional bool publicConf = 19;
  inline bool has_publicconf() const;
  inline void clear_publicconf();
  static const int kPublicConfFieldNumber = 19;
  inline bool publicconf() const;
  inline void set_publicconf(bool value);

  // optional bool autoEnd = 20;
  inline bool has_autoend() const;
  inline void clear_autoend();
  static const int kAutoEndFieldNumber = 20;
  inline bool autoend() const;
  inline void set_autoend(bool value);

  // optional bool preoccpuyResouce = 21;
  inline bool has_preoccpuyresouce() const;
  inline void clear_preoccpuyresouce();
  static const int kPreoccpuyResouceFieldNumber = 21;
  inline bool preoccpuyresouce() const;
  inline void set_preoccpuyresouce(bool value);

  // optional uint32 maxJoinMt = 22;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxJoinMtFieldNumber = 22;
  inline ::google::protobuf::uint32 maxjoinmt() const;
  inline void set_maxjoinmt(::google::protobuf::uint32 value);

  // optional bool voiceInspireEnable = 23;
  inline bool has_voiceinspireenable() const;
  inline void clear_voiceinspireenable();
  static const int kVoiceInspireEnableFieldNumber = 23;
  inline bool voiceinspireenable() const;
  inline void set_voiceinspireenable(bool value);

  // optional .mt.TMTConfInitiator confInitiator = 24;
  inline bool has_confinitiator() const;
  inline void clear_confinitiator();
  static const int kConfInitiatorFieldNumber = 24;
  inline const ::mt::TMTConfInitiator& confinitiator() const;
  inline ::mt::TMTConfInitiator* mutable_confinitiator();
  inline ::mt::TMTConfInitiator* release_confinitiator();
  inline void set_allocated_confinitiator(::mt::TMTConfInitiator* confinitiator);

  // repeated .mt.TMTVideoFormatList videoFormatList = 25;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoFormatListFieldNumber = 25;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // optional bool vmpEnable = 26;
  inline bool has_vmpenable() const;
  inline void clear_vmpenable();
  static const int kVmpEnableFieldNumber = 26;
  inline bool vmpenable() const;
  inline void set_vmpenable(bool value);

  // optional bool mixEnable = 27;
  inline bool has_mixenable() const;
  inline void clear_mixenable();
  static const int kMixEnableFieldNumber = 27;
  inline bool mixenable() const;
  inline void set_mixenable(bool value);

  // optional bool pollEnable = 28;
  inline bool has_pollenable() const;
  inline void clear_pollenable();
  static const int kPollEnableFieldNumber = 28;
  inline bool pollenable() const;
  inline void set_pollenable(bool value);

  // optional bool needPassword = 29;
  inline bool has_needpassword() const;
  inline void clear_needpassword();
  static const int kNeedPasswordFieldNumber = 29;
  inline bool needpassword() const;
  inline void set_needpassword(bool value);

  // optional .mt.EmRestCascadeMode emCascadeMode = 30;
  inline bool has_emcascademode() const;
  inline void clear_emcascademode();
  static const int kEmCascadeModeFieldNumber = 30;
  inline ::mt::EmRestCascadeMode emcascademode() const;
  inline void set_emcascademode(::mt::EmRestCascadeMode value);

  // optional bool cascadeUpload = 31;
  inline bool has_cascadeupload() const;
  inline void clear_cascadeupload();
  static const int kCascadeUploadFieldNumber = 31;
  inline bool cascadeupload() const;
  inline void set_cascadeupload(bool value);

  // optional bool cascadeReturn = 32;
  inline bool has_cascadereturn() const;
  inline void clear_cascadereturn();
  static const int kCascadeReturnFieldNumber = 32;
  inline bool cascadereturn() const;
  inline void set_cascadereturn(bool value);

  // optional uint32 cascadeReturnPara = 33;
  inline bool has_cascadereturnpara() const;
  inline void clear_cascadereturnpara();
  static const int kCascadeReturnParaFieldNumber = 33;
  inline ::google::protobuf::uint32 cascadereturnpara() const;
  inline void set_cascadereturnpara(::google::protobuf::uint32 value);

  // optional uint32 vacinterval = 34;
  inline bool has_vacinterval() const;
  inline void clear_vacinterval();
  static const int kVacintervalFieldNumber = 34;
  inline ::google::protobuf::uint32 vacinterval() const;
  inline void set_vacinterval(::google::protobuf::uint32 value);

  // optional uint32 conflevel = 35;
  inline bool has_conflevel() const;
  inline void clear_conflevel();
  static const int kConflevelFieldNumber = 35;
  inline ::google::protobuf::uint32 conflevel() const;
  inline void set_conflevel(::google::protobuf::uint32 value);

  // optional bool encrypted_auth = 36;
  inline bool has_encrypted_auth() const;
  inline void clear_encrypted_auth();
  static const int kEncryptedAuthFieldNumber = 36;
  inline bool encrypted_auth() const;
  inline void set_encrypted_auth(bool value);

  // optional .mt.EmCallMode emCallMode = 37;
  inline bool has_emcallmode() const;
  inline void clear_emcallmode();
  static const int kEmCallModeFieldNumber = 37;
  inline ::mt::EmCallMode emcallmode() const;
  inline void set_emcallmode(::mt::EmCallMode value);

  // optional .mt.EmMtFecMode fecmode = 38;
  inline bool has_fecmode() const;
  inline void clear_fecmode();
  static const int kFecmodeFieldNumber = 38;
  inline ::mt::EmMtFecMode fecmode() const;
  inline void set_fecmode(::mt::EmMtFecMode value);

  // optional string MeetingRoomName = 39;
  inline bool has_meetingroomname() const;
  inline void clear_meetingroomname();
  static const int kMeetingRoomNameFieldNumber = 39;
  inline const ::std::string& meetingroomname() const;
  inline void set_meetingroomname(const ::std::string& value);
  inline void set_meetingroomname(const char* value);
  inline void set_meetingroomname(const char* value, size_t size);
  inline ::std::string* mutable_meetingroomname();
  inline ::std::string* release_meetingroomname();
  inline void set_allocated_meetingroomname(::std::string* meetingroomname);

  // optional bool doubleflow = 40;
  inline bool has_doubleflow() const;
  inline void clear_doubleflow();
  static const int kDoubleflowFieldNumber = 40;
  inline bool doubleflow() const;
  inline void set_doubleflow(bool value);

  // optional bool mutefilter = 41;
  inline bool has_mutefilter() const;
  inline void clear_mutefilter();
  static const int kMutefilterFieldNumber = 41;
  inline bool mutefilter() const;
  inline void set_mutefilter(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTInstantConferenceInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_confid();
  inline void clear_has_confid();
  inline void set_has_conftype();
  inline void clear_has_conftype();
  inline void set_has_startime();
  inline void clear_has_startime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_closeconf();
  inline void clear_has_closeconf();
  inline void set_has_safeconf();
  inline void clear_has_safeconf();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_calltimes();
  inline void clear_has_calltimes();
  inline void set_has_callinterval();
  inline void clear_has_callinterval();
  inline void set_has_forcebroadcast();
  inline void clear_has_forcebroadcast();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_initsilence();
  inline void clear_has_initsilence();
  inline void set_has_vidoquality();
  inline void clear_has_vidoquality();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_publicconf();
  inline void clear_has_publicconf();
  inline void set_has_autoend();
  inline void clear_has_autoend();
  inline void set_has_preoccpuyresouce();
  inline void clear_has_preoccpuyresouce();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_voiceinspireenable();
  inline void clear_has_voiceinspireenable();
  inline void set_has_confinitiator();
  inline void clear_has_confinitiator();
  inline void set_has_vmpenable();
  inline void clear_has_vmpenable();
  inline void set_has_mixenable();
  inline void clear_has_mixenable();
  inline void set_has_pollenable();
  inline void clear_has_pollenable();
  inline void set_has_needpassword();
  inline void clear_has_needpassword();
  inline void set_has_emcascademode();
  inline void clear_has_emcascademode();
  inline void set_has_cascadeupload();
  inline void clear_has_cascadeupload();
  inline void set_has_cascadereturn();
  inline void clear_has_cascadereturn();
  inline void set_has_cascadereturnpara();
  inline void clear_has_cascadereturnpara();
  inline void set_has_vacinterval();
  inline void clear_has_vacinterval();
  inline void set_has_conflevel();
  inline void clear_has_conflevel();
  inline void set_has_encrypted_auth();
  inline void clear_has_encrypted_auth();
  inline void set_has_emcallmode();
  inline void clear_has_emcallmode();
  inline void set_has_fecmode();
  inline void clear_has_fecmode();
  inline void set_has_meetingroomname();
  inline void clear_has_meetingroomname();
  inline void set_has_doubleflow();
  inline void clear_has_doubleflow();
  inline void set_has_mutefilter();
  inline void clear_has_mutefilter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* confid_;
  ::std::string* startime_;
  int conftype_;
  ::google::protobuf::uint32 duration_;
  ::std::string* endtime_;
  ::google::protobuf::uint32 bitrate_;
  int closeconf_;
  int safeconf_;
  int encryptedtype_;
  ::google::protobuf::uint32 calltimes_;
  ::google::protobuf::uint32 callinterval_;
  bool forcebroadcast_;
  bool initmute_;
  bool initsilence_;
  bool publicconf_;
  int vidoquality_;
  ::std::string* encryptedkey_;
  int dualmode_;
  ::google::protobuf::uint32 maxjoinmt_;
  ::mt::TMTConfInitiator* confinitiator_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  bool autoend_;
  bool preoccpuyresouce_;
  bool voiceinspireenable_;
  bool vmpenable_;
  bool mixenable_;
  bool pollenable_;
  bool needpassword_;
  bool cascadeupload_;
  int emcascademode_;
  ::google::protobuf::uint32 cascadereturnpara_;
  ::google::protobuf::uint32 vacinterval_;
  ::google::protobuf::uint32 conflevel_;
  int emcallmode_;
  bool cascadereturn_;
  bool encrypted_auth_;
  bool doubleflow_;
  bool mutefilter_;
  ::std::string* meetingroomname_;
  int fecmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(41 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTInstantConferenceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTGetIntanceConfList : public ::google::protobuf::Message {
 public:
  TMTGetIntanceConfList();
  virtual ~TMTGetIntanceConfList();

  TMTGetIntanceConfList(const TMTGetIntanceConfList& from);

  inline TMTGetIntanceConfList& operator=(const TMTGetIntanceConfList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTGetIntanceConfList& default_instance();

  void Swap(TMTGetIntanceConfList* other);

  // implements Message ----------------------------------------------

  TMTGetIntanceConfList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTGetIntanceConfList& from);
  void MergeFrom(const TMTGetIntanceConfList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTGetIntanceConfList)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTGetIntanceConfList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRecordMembers : public ::google::protobuf::Message {
 public:
  TMTRecordMembers();
  virtual ~TMTRecordMembers();

  TMTRecordMembers(const TMTRecordMembers& from);

  inline TMTRecordMembers& operator=(const TMTRecordMembers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRecordMembers& default_instance();

  void Swap(TMTRecordMembers* other);

  // implements Message ----------------------------------------------

  TMTRecordMembers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRecordMembers& from);
  void MergeFrom(const TMTRecordMembers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mtID = 1;
  inline bool has_mtid() const;
  inline void clear_mtid();
  static const int kMtIDFieldNumber = 1;
  inline const ::std::string& mtid() const;
  inline void set_mtid(const ::std::string& value);
  inline void set_mtid(const char* value);
  inline void set_mtid(const char* value, size_t size);
  inline ::std::string* mutable_mtid();
  inline ::std::string* release_mtid();
  inline void set_allocated_mtid(::std::string* mtid);

  // @@protoc_insertion_point(class_scope:mt.TMTRecordMembers)
 private:
  inline void set_has_mtid();
  inline void clear_has_mtid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mtid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRecordMembers* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTStartRecord : public ::google::protobuf::Message {
 public:
  TMTStartRecord();
  virtual ~TMTStartRecord();

  TMTStartRecord(const TMTStartRecord& from);

  inline TMTStartRecord& operator=(const TMTStartRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTStartRecord& default_instance();

  void Swap(TMTStartRecord* other);

  // implements Message ----------------------------------------------

  TMTStartRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTStartRecord& from);
  void MergeFrom(const TMTStartRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string confID = 1;
  inline bool has_confid() const;
  inline void clear_confid();
  static const int kConfIDFieldNumber = 1;
  inline const ::std::string& confid() const;
  inline void set_confid(const ::std::string& value);
  inline void set_confid(const char* value);
  inline void set_confid(const char* value, size_t size);
  inline ::std::string* mutable_confid();
  inline ::std::string* release_confid();
  inline void set_allocated_confid(::std::string* confid);

  // optional string videoName = 2;
  inline bool has_videoname() const;
  inline void clear_videoname();
  static const int kVideoNameFieldNumber = 2;
  inline const ::std::string& videoname() const;
  inline void set_videoname(const ::std::string& value);
  inline void set_videoname(const char* value);
  inline void set_videoname(const char* value, size_t size);
  inline ::std::string* mutable_videoname();
  inline ::std::string* release_videoname();
  inline void set_allocated_videoname(::std::string* videoname);

  // optional .mt.EmRecordType emRecordType = 3;
  inline bool has_emrecordtype() const;
  inline void clear_emrecordtype();
  static const int kEmRecordTypeFieldNumber = 3;
  inline ::mt::EmRecordType emrecordtype() const;
  inline void set_emrecordtype(::mt::EmRecordType value);

  // optional .mt.EmPublishMode emPublishMode = 4;
  inline bool has_empublishmode() const;
  inline void clear_empublishmode();
  static const int kEmPublishModeFieldNumber = 4;
  inline ::mt::EmPublishMode empublishmode() const;
  inline void set_empublishmode(::mt::EmPublishMode value);

  // optional .mt.EmRecordMode emRecordMode = 5;
  inline bool has_emrecordmode() const;
  inline void clear_emrecordmode();
  static const int kEmRecordModeFieldNumber = 5;
  inline ::mt::EmRecordMode emrecordmode() const;
  inline void set_emrecordmode(::mt::EmRecordMode value);

  // optional bool bAnonymous = 6;
  inline bool has_banonymous() const;
  inline void clear_banonymous();
  static const int kBAnonymousFieldNumber = 6;
  inline bool banonymous() const;
  inline void set_banonymous(bool value);

  // optional bool bMainStream = 7;
  inline bool has_bmainstream() const;
  inline void clear_bmainstream();
  static const int kBMainStreamFieldNumber = 7;
  inline bool bmainstream() const;
  inline void set_bmainstream(bool value);

  // optional bool bDualStream = 8;
  inline bool has_bdualstream() const;
  inline void clear_bdualstream();
  static const int kBDualStreamFieldNumber = 8;
  inline bool bdualstream() const;
  inline void set_bdualstream(bool value);

  // repeated .mt.TMTRecordMembers recordMembers = 9;
  inline int recordmembers_size() const;
  inline void clear_recordmembers();
  static const int kRecordMembersFieldNumber = 9;
  inline const ::mt::TMTRecordMembers& recordmembers(int index) const;
  inline ::mt::TMTRecordMembers* mutable_recordmembers(int index);
  inline ::mt::TMTRecordMembers* add_recordmembers();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >&
      recordmembers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >*
      mutable_recordmembers();

  // optional string vrsId = 10;
  inline bool has_vrsid() const;
  inline void clear_vrsid();
  static const int kVrsIdFieldNumber = 10;
  inline const ::std::string& vrsid() const;
  inline void set_vrsid(const ::std::string& value);
  inline void set_vrsid(const char* value);
  inline void set_vrsid(const char* value, size_t size);
  inline ::std::string* mutable_vrsid();
  inline ::std::string* release_vrsid();
  inline void set_allocated_vrsid(::std::string* vrsid);

  // @@protoc_insertion_point(class_scope:mt.TMTStartRecord)
 private:
  inline void set_has_confid();
  inline void clear_has_confid();
  inline void set_has_videoname();
  inline void clear_has_videoname();
  inline void set_has_emrecordtype();
  inline void clear_has_emrecordtype();
  inline void set_has_empublishmode();
  inline void clear_has_empublishmode();
  inline void set_has_emrecordmode();
  inline void clear_has_emrecordmode();
  inline void set_has_banonymous();
  inline void clear_has_banonymous();
  inline void set_has_bmainstream();
  inline void clear_has_bmainstream();
  inline void set_has_bdualstream();
  inline void clear_has_bdualstream();
  inline void set_has_vrsid();
  inline void clear_has_vrsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* confid_;
  ::std::string* videoname_;
  int emrecordtype_;
  int empublishmode_;
  int emrecordmode_;
  bool banonymous_;
  bool bmainstream_;
  bool bdualstream_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers > recordmembers_;
  ::std::string* vrsid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTStartRecord* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTStopRecord : public ::google::protobuf::Message {
 public:
  TMTStopRecord();
  virtual ~TMTStopRecord();

  TMTStopRecord(const TMTStopRecord& from);

  inline TMTStopRecord& operator=(const TMTStopRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTStopRecord& default_instance();

  void Swap(TMTStopRecord* other);

  // implements Message ----------------------------------------------

  TMTStopRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTStopRecord& from);
  void MergeFrom(const TMTStopRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string confID = 1;
  inline bool has_confid() const;
  inline void clear_confid();
  static const int kConfIDFieldNumber = 1;
  inline const ::std::string& confid() const;
  inline void set_confid(const ::std::string& value);
  inline void set_confid(const char* value);
  inline void set_confid(const char* value, size_t size);
  inline ::std::string* mutable_confid();
  inline ::std::string* release_confid();
  inline void set_allocated_confid(::std::string* confid);

  // optional string recordID = 2;
  inline bool has_recordid() const;
  inline void clear_recordid();
  static const int kRecordIDFieldNumber = 2;
  inline const ::std::string& recordid() const;
  inline void set_recordid(const ::std::string& value);
  inline void set_recordid(const char* value);
  inline void set_recordid(const char* value, size_t size);
  inline ::std::string* mutable_recordid();
  inline ::std::string* release_recordid();
  inline void set_allocated_recordid(::std::string* recordid);

  // optional .mt.EmRecordMode emRecordMode = 3;
  inline bool has_emrecordmode() const;
  inline void clear_emrecordmode();
  static const int kEmRecordModeFieldNumber = 3;
  inline ::mt::EmRecordMode emrecordmode() const;
  inline void set_emrecordmode(::mt::EmRecordMode value);

  // @@protoc_insertion_point(class_scope:mt.TMTStopRecord)
 private:
  inline void set_has_confid();
  inline void clear_has_confid();
  inline void set_has_recordid();
  inline void clear_has_recordid();
  inline void set_has_emrecordmode();
  inline void clear_has_emrecordmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* confid_;
  ::std::string* recordid_;
  int emrecordmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTStopRecord* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRecordStateInfo : public ::google::protobuf::Message {
 public:
  TMTRecordStateInfo();
  virtual ~TMTRecordStateInfo();

  TMTRecordStateInfo(const TMTRecordStateInfo& from);

  inline TMTRecordStateInfo& operator=(const TMTRecordStateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRecordStateInfo& default_instance();

  void Swap(TMTRecordStateInfo* other);

  // implements Message ----------------------------------------------

  TMTRecordStateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRecordStateInfo& from);
  void MergeFrom(const TMTRecordStateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string videoName = 1;
  inline bool has_videoname() const;
  inline void clear_videoname();
  static const int kVideoNameFieldNumber = 1;
  inline const ::std::string& videoname() const;
  inline void set_videoname(const ::std::string& value);
  inline void set_videoname(const char* value);
  inline void set_videoname(const char* value, size_t size);
  inline ::std::string* mutable_videoname();
  inline ::std::string* release_videoname();
  inline void set_allocated_videoname(::std::string* videoname);

  // optional .mt.EmRecordType emRecordType = 2;
  inline bool has_emrecordtype() const;
  inline void clear_emrecordtype();
  static const int kEmRecordTypeFieldNumber = 2;
  inline ::mt::EmRecordType emrecordtype() const;
  inline void set_emrecordtype(::mt::EmRecordType value);

  // optional .mt.EmRecordState emRecordState = 3;
  inline bool has_emrecordstate() const;
  inline void clear_emrecordstate();
  static const int kEmRecordStateFieldNumber = 3;
  inline ::mt::EmRecordState emrecordstate() const;
  inline void set_emrecordstate(::mt::EmRecordState value);

  // optional .mt.EmPublishMode emPublishMode = 4;
  inline bool has_empublishmode() const;
  inline void clear_empublishmode();
  static const int kEmPublishModeFieldNumber = 4;
  inline ::mt::EmPublishMode empublishmode() const;
  inline void set_empublishmode(::mt::EmPublishMode value);

  // optional .mt.EmRecordMode emRecordMode = 5;
  inline bool has_emrecordmode() const;
  inline void clear_emrecordmode();
  static const int kEmRecordModeFieldNumber = 5;
  inline ::mt::EmRecordMode emrecordmode() const;
  inline void set_emrecordmode(::mt::EmRecordMode value);

  // optional bool bAnonymous = 6;
  inline bool has_banonymous() const;
  inline void clear_banonymous();
  static const int kBAnonymousFieldNumber = 6;
  inline bool banonymous() const;
  inline void set_banonymous(bool value);

  // optional bool bMainStream = 7;
  inline bool has_bmainstream() const;
  inline void clear_bmainstream();
  static const int kBMainStreamFieldNumber = 7;
  inline bool bmainstream() const;
  inline void set_bmainstream(bool value);

  // optional bool bDualStream = 8;
  inline bool has_bdualstream() const;
  inline void clear_bdualstream();
  static const int kBDualStreamFieldNumber = 8;
  inline bool bdualstream() const;
  inline void set_bdualstream(bool value);

  // optional uint32 CurrentProgress = 9;
  inline bool has_currentprogress() const;
  inline void clear_currentprogress();
  static const int kCurrentProgressFieldNumber = 9;
  inline ::google::protobuf::uint32 currentprogress() const;
  inline void set_currentprogress(::google::protobuf::uint32 value);

  // repeated .mt.TMTRecordMembers recordMembers = 10;
  inline int recordmembers_size() const;
  inline void clear_recordmembers();
  static const int kRecordMembersFieldNumber = 10;
  inline const ::mt::TMTRecordMembers& recordmembers(int index) const;
  inline ::mt::TMTRecordMembers* mutable_recordmembers(int index);
  inline ::mt::TMTRecordMembers* add_recordmembers();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >&
      recordmembers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >*
      mutable_recordmembers();

  // @@protoc_insertion_point(class_scope:mt.TMTRecordStateInfo)
 private:
  inline void set_has_videoname();
  inline void clear_has_videoname();
  inline void set_has_emrecordtype();
  inline void clear_has_emrecordtype();
  inline void set_has_emrecordstate();
  inline void clear_has_emrecordstate();
  inline void set_has_empublishmode();
  inline void clear_has_empublishmode();
  inline void set_has_emrecordmode();
  inline void clear_has_emrecordmode();
  inline void set_has_banonymous();
  inline void clear_has_banonymous();
  inline void set_has_bmainstream();
  inline void clear_has_bmainstream();
  inline void set_has_bdualstream();
  inline void clear_has_bdualstream();
  inline void set_has_currentprogress();
  inline void clear_has_currentprogress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* videoname_;
  int emrecordtype_;
  int emrecordstate_;
  int empublishmode_;
  int emrecordmode_;
  bool banonymous_;
  bool bmainstream_;
  bool bdualstream_;
  ::google::protobuf::uint32 currentprogress_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers > recordmembers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRecordStateInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTModifyRecordState : public ::google::protobuf::Message {
 public:
  TMTModifyRecordState();
  virtual ~TMTModifyRecordState();

  TMTModifyRecordState(const TMTModifyRecordState& from);

  inline TMTModifyRecordState& operator=(const TMTModifyRecordState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTModifyRecordState& default_instance();

  void Swap(TMTModifyRecordState* other);

  // implements Message ----------------------------------------------

  TMTModifyRecordState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTModifyRecordState& from);
  void MergeFrom(const TMTModifyRecordState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string confID = 1;
  inline bool has_confid() const;
  inline void clear_confid();
  static const int kConfIDFieldNumber = 1;
  inline const ::std::string& confid() const;
  inline void set_confid(const ::std::string& value);
  inline void set_confid(const char* value);
  inline void set_confid(const char* value, size_t size);
  inline ::std::string* mutable_confid();
  inline ::std::string* release_confid();
  inline void set_allocated_confid(::std::string* confid);

  // optional string recordID = 2;
  inline bool has_recordid() const;
  inline void clear_recordid();
  static const int kRecordIDFieldNumber = 2;
  inline const ::std::string& recordid() const;
  inline void set_recordid(const ::std::string& value);
  inline void set_recordid(const char* value);
  inline void set_recordid(const char* value, size_t size);
  inline ::std::string* mutable_recordid();
  inline ::std::string* release_recordid();
  inline void set_allocated_recordid(::std::string* recordid);

  // optional .mt.EmRecordMode emRecordMode = 3;
  inline bool has_emrecordmode() const;
  inline void clear_emrecordmode();
  static const int kEmRecordModeFieldNumber = 3;
  inline ::mt::EmRecordMode emrecordmode() const;
  inline void set_emrecordmode(::mt::EmRecordMode value);

  // optional .mt.EmRecordCmd emRecordCmd = 4;
  inline bool has_emrecordcmd() const;
  inline void clear_emrecordcmd();
  static const int kEmRecordCmdFieldNumber = 4;
  inline ::mt::EmRecordCmd emrecordcmd() const;
  inline void set_emrecordcmd(::mt::EmRecordCmd value);

  // @@protoc_insertion_point(class_scope:mt.TMTModifyRecordState)
 private:
  inline void set_has_confid();
  inline void clear_has_confid();
  inline void set_has_recordid();
  inline void clear_has_recordid();
  inline void set_has_emrecordmode();
  inline void clear_has_emrecordmode();
  inline void set_has_emrecordcmd();
  inline void clear_has_emrecordcmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* confid_;
  ::std::string* recordid_;
  int emrecordmode_;
  int emrecordcmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTModifyRecordState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRecordListMember : public ::google::protobuf::Message {
 public:
  TMTRecordListMember();
  virtual ~TMTRecordListMember();

  TMTRecordListMember(const TMTRecordListMember& from);

  inline TMTRecordListMember& operator=(const TMTRecordListMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRecordListMember& default_instance();

  void Swap(TMTRecordListMember* other);

  // implements Message ----------------------------------------------

  TMTRecordListMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRecordListMember& from);
  void MergeFrom(const TMTRecordListMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string videoName = 1;
  inline bool has_videoname() const;
  inline void clear_videoname();
  static const int kVideoNameFieldNumber = 1;
  inline const ::std::string& videoname() const;
  inline void set_videoname(const ::std::string& value);
  inline void set_videoname(const char* value);
  inline void set_videoname(const char* value, size_t size);
  inline ::std::string* mutable_videoname();
  inline ::std::string* release_videoname();
  inline void set_allocated_videoname(::std::string* videoname);

  // optional .mt.EmRecordType emRecordType = 2;
  inline bool has_emrecordtype() const;
  inline void clear_emrecordtype();
  static const int kEmRecordTypeFieldNumber = 2;
  inline ::mt::EmRecordType emrecordtype() const;
  inline void set_emrecordtype(::mt::EmRecordType value);

  // optional .mt.EmRecordState emRecordState = 3;
  inline bool has_emrecordstate() const;
  inline void clear_emrecordstate();
  static const int kEmRecordStateFieldNumber = 3;
  inline ::mt::EmRecordState emrecordstate() const;
  inline void set_emrecordstate(::mt::EmRecordState value);

  // optional .mt.EmPublishMode emPublishMode = 4;
  inline bool has_empublishmode() const;
  inline void clear_empublishmode();
  static const int kEmPublishModeFieldNumber = 4;
  inline ::mt::EmPublishMode empublishmode() const;
  inline void set_empublishmode(::mt::EmPublishMode value);

  // optional .mt.EmRecordMode emRecordMode = 5;
  inline bool has_emrecordmode() const;
  inline void clear_emrecordmode();
  static const int kEmRecordModeFieldNumber = 5;
  inline ::mt::EmRecordMode emrecordmode() const;
  inline void set_emrecordmode(::mt::EmRecordMode value);

  // optional bool bAnonymous = 6;
  inline bool has_banonymous() const;
  inline void clear_banonymous();
  static const int kBAnonymousFieldNumber = 6;
  inline bool banonymous() const;
  inline void set_banonymous(bool value);

  // optional bool bMainStream = 7;
  inline bool has_bmainstream() const;
  inline void clear_bmainstream();
  static const int kBMainStreamFieldNumber = 7;
  inline bool bmainstream() const;
  inline void set_bmainstream(bool value);

  // optional bool bDualStream = 8;
  inline bool has_bdualstream() const;
  inline void clear_bdualstream();
  static const int kBDualStreamFieldNumber = 8;
  inline bool bdualstream() const;
  inline void set_bdualstream(bool value);

  // optional uint32 CurrentProgress = 9;
  inline bool has_currentprogress() const;
  inline void clear_currentprogress();
  static const int kCurrentProgressFieldNumber = 9;
  inline ::google::protobuf::uint32 currentprogress() const;
  inline void set_currentprogress(::google::protobuf::uint32 value);

  // repeated .mt.TMTRecordMembers recordMembers = 10;
  inline int recordmembers_size() const;
  inline void clear_recordmembers();
  static const int kRecordMembersFieldNumber = 10;
  inline const ::mt::TMTRecordMembers& recordmembers(int index) const;
  inline ::mt::TMTRecordMembers* mutable_recordmembers(int index);
  inline ::mt::TMTRecordMembers* add_recordmembers();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >&
      recordmembers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >*
      mutable_recordmembers();

  // optional string recordID = 11;
  inline bool has_recordid() const;
  inline void clear_recordid();
  static const int kRecordIDFieldNumber = 11;
  inline const ::std::string& recordid() const;
  inline void set_recordid(const ::std::string& value);
  inline void set_recordid(const char* value);
  inline void set_recordid(const char* value, size_t size);
  inline ::std::string* mutable_recordid();
  inline ::std::string* release_recordid();
  inline void set_allocated_recordid(::std::string* recordid);

  // @@protoc_insertion_point(class_scope:mt.TMTRecordListMember)
 private:
  inline void set_has_videoname();
  inline void clear_has_videoname();
  inline void set_has_emrecordtype();
  inline void clear_has_emrecordtype();
  inline void set_has_emrecordstate();
  inline void clear_has_emrecordstate();
  inline void set_has_empublishmode();
  inline void clear_has_empublishmode();
  inline void set_has_emrecordmode();
  inline void clear_has_emrecordmode();
  inline void set_has_banonymous();
  inline void clear_has_banonymous();
  inline void set_has_bmainstream();
  inline void clear_has_bmainstream();
  inline void set_has_bdualstream();
  inline void clear_has_bdualstream();
  inline void set_has_currentprogress();
  inline void clear_has_currentprogress();
  inline void set_has_recordid();
  inline void clear_has_recordid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* videoname_;
  int emrecordtype_;
  int emrecordstate_;
  int empublishmode_;
  int emrecordmode_;
  bool banonymous_;
  bool bmainstream_;
  bool bdualstream_;
  ::google::protobuf::uint32 currentprogress_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers > recordmembers_;
  ::std::string* recordid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRecordListMember* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRecordList : public ::google::protobuf::Message {
 public:
  TMTRecordList();
  virtual ~TMTRecordList();

  TMTRecordList(const TMTRecordList& from);

  inline TMTRecordList& operator=(const TMTRecordList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRecordList& default_instance();

  void Swap(TMTRecordList* other);

  // implements Message ----------------------------------------------

  TMTRecordList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRecordList& from);
  void MergeFrom(const TMTRecordList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTRecordListMember recordlist = 1;
  inline int recordlist_size() const;
  inline void clear_recordlist();
  static const int kRecordlistFieldNumber = 1;
  inline const ::mt::TMTRecordListMember& recordlist(int index) const;
  inline ::mt::TMTRecordListMember* mutable_recordlist(int index);
  inline ::mt::TMTRecordListMember* add_recordlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordListMember >&
      recordlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordListMember >*
      mutable_recordlist();

  // @@protoc_insertion_point(class_scope:mt.TMTRecordList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordListMember > recordlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTRecordList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfTerminalInfo : public ::google::protobuf::Message {
 public:
  TMTConfTerminalInfo();
  virtual ~TMTConfTerminalInfo();

  TMTConfTerminalInfo(const TMTConfTerminalInfo& from);

  inline TMTConfTerminalInfo& operator=(const TMTConfTerminalInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfTerminalInfo& default_instance();

  void Swap(TMTConfTerminalInfo* other);

  // implements Message ----------------------------------------------

  TMTConfTerminalInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfTerminalInfo& from);
  void MergeFrom(const TMTConfTerminalInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string alias = 1;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 1;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // optional string mtid = 2;
  inline bool has_mtid() const;
  inline void clear_mtid();
  static const int kMtidFieldNumber = 2;
  inline const ::std::string& mtid() const;
  inline void set_mtid(const ::std::string& value);
  inline void set_mtid(const char* value);
  inline void set_mtid(const char* value, size_t size);
  inline ::std::string* mutable_mtid();
  inline ::std::string* release_mtid();
  inline void set_allocated_mtid(::std::string* mtid);

  // optional string e164 = 3;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 3;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional uint32 bitrate = 4;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 4;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional bool online = 5;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 5;
  inline bool online() const;
  inline void set_online(bool value);

  // optional bool silence = 6;
  inline bool has_silence() const;
  inline void clear_silence();
  static const int kSilenceFieldNumber = 6;
  inline bool silence() const;
  inline void set_silence(bool value);

  // optional bool mute = 7;
  inline bool has_mute() const;
  inline void clear_mute();
  static const int kMuteFieldNumber = 7;
  inline bool mute() const;
  inline void set_mute(bool value);

  // optional bool dual = 8;
  inline bool has_dual() const;
  inline void clear_dual();
  static const int kDualFieldNumber = 8;
  inline bool dual() const;
  inline void set_dual(bool value);

  // optional bool mix = 9;
  inline bool has_mix() const;
  inline void clear_mix();
  static const int kMixFieldNumber = 9;
  inline bool mix() const;
  inline void set_mix(bool value);

  // optional bool vmp = 10;
  inline bool has_vmp() const;
  inline void clear_vmp();
  static const int kVmpFieldNumber = 10;
  inline bool vmp() const;
  inline void set_vmp(bool value);

  // optional bool inspection = 11;
  inline bool has_inspection() const;
  inline void clear_inspection();
  static const int kInspectionFieldNumber = 11;
  inline bool inspection() const;
  inline void set_inspection(bool value);

  // optional bool record = 12;
  inline bool has_record() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 12;
  inline bool record() const;
  inline void set_record(bool value);

  // optional bool poll = 13;
  inline bool has_poll() const;
  inline void clear_poll();
  static const int kPollFieldNumber = 13;
  inline bool poll() const;
  inline void set_poll(bool value);

  // optional bool upload = 14;
  inline bool has_upload() const;
  inline void clear_upload();
  static const int kUploadFieldNumber = 14;
  inline bool upload() const;
  inline void set_upload(bool value);

  // optional .mt.EmMtType emMtType = 15;
  inline bool has_emmttype() const;
  inline void clear_emmttype();
  static const int kEmMtTypeFieldNumber = 15;
  inline ::mt::EmMtType emmttype() const;
  inline void set_emmttype(::mt::EmMtType value);

  // optional .mt.EmCallMode emCallMode = 16;
  inline bool has_emcallmode() const;
  inline void clear_emcallmode();
  static const int kEmCallModeFieldNumber = 16;
  inline ::mt::EmCallMode emcallmode() const;
  inline void set_emcallmode(::mt::EmCallMode value);

  // optional .mt.EmConfProtocol emProtocol = 17;
  inline bool has_emprotocol() const;
  inline void clear_emprotocol();
  static const int kEmProtocolFieldNumber = 17;
  inline ::mt::EmConfProtocol emprotocol() const;
  inline void set_emprotocol(::mt::EmConfProtocol value);

  // optional string ip = 18;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 18;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:mt.TMTConfTerminalInfo)
 private:
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_mtid();
  inline void clear_has_mtid();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_silence();
  inline void clear_has_silence();
  inline void set_has_mute();
  inline void clear_has_mute();
  inline void set_has_dual();
  inline void clear_has_dual();
  inline void set_has_mix();
  inline void clear_has_mix();
  inline void set_has_vmp();
  inline void clear_has_vmp();
  inline void set_has_inspection();
  inline void clear_has_inspection();
  inline void set_has_record();
  inline void clear_has_record();
  inline void set_has_poll();
  inline void clear_has_poll();
  inline void set_has_upload();
  inline void clear_has_upload();
  inline void set_has_emmttype();
  inline void clear_has_emmttype();
  inline void set_has_emcallmode();
  inline void clear_has_emcallmode();
  inline void set_has_emprotocol();
  inline void clear_has_emprotocol();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alias_;
  ::std::string* mtid_;
  ::std::string* e164_;
  ::google::protobuf::uint32 bitrate_;
  bool online_;
  bool silence_;
  bool mute_;
  bool dual_;
  bool mix_;
  bool vmp_;
  bool inspection_;
  bool record_;
  bool poll_;
  bool upload_;
  int emmttype_;
  int emcallmode_;
  ::std::string* ip_;
  int emprotocol_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfTerminalInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTConfTerminalList : public ::google::protobuf::Message {
 public:
  TMTConfTerminalList();
  virtual ~TMTConfTerminalList();

  TMTConfTerminalList(const TMTConfTerminalList& from);

  inline TMTConfTerminalList& operator=(const TMTConfTerminalList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTConfTerminalList& default_instance();

  void Swap(TMTConfTerminalList* other);

  // implements Message ----------------------------------------------

  TMTConfTerminalList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTConfTerminalList& from);
  void MergeFrom(const TMTConfTerminalList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTConfTerminalInfo confTerminalList = 1;
  inline int confterminallist_size() const;
  inline void clear_confterminallist();
  static const int kConfTerminalListFieldNumber = 1;
  inline const ::mt::TMTConfTerminalInfo& confterminallist(int index) const;
  inline ::mt::TMTConfTerminalInfo* mutable_confterminallist(int index);
  inline ::mt::TMTConfTerminalInfo* add_confterminallist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTConfTerminalInfo >&
      confterminallist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTConfTerminalInfo >*
      mutable_confterminallist();

  // @@protoc_insertion_point(class_scope:mt.TMTConfTerminalList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTConfTerminalInfo > confterminallist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTConfTerminalList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUserDomainInfo : public ::google::protobuf::Message {
 public:
  TMTUserDomainInfo();
  virtual ~TMTUserDomainInfo();

  TMTUserDomainInfo(const TMTUserDomainInfo& from);

  inline TMTUserDomainInfo& operator=(const TMTUserDomainInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUserDomainInfo& default_instance();

  void Swap(TMTUserDomainInfo* other);

  // implements Message ----------------------------------------------

  TMTUserDomainInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUserDomainInfo& from);
  void MergeFrom(const TMTUserDomainInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid = 1;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 1;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string group_name = 3;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 3;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // optional string parent_id = 4;
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 4;
  inline const ::std::string& parent_id() const;
  inline void set_parent_id(const ::std::string& value);
  inline void set_parent_id(const char* value);
  inline void set_parent_id(const char* value, size_t size);
  inline ::std::string* mutable_parent_id();
  inline ::std::string* release_parent_id();
  inline void set_allocated_parent_id(::std::string* parent_id);

  // optional uint32 version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTUserDomainInfo)
 private:
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::std::string* name_;
  ::std::string* group_name_;
  ::std::string* parent_id_;
  ::google::protobuf::uint32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTUserDomainInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUserDomains : public ::google::protobuf::Message {
 public:
  TMTUserDomains();
  virtual ~TMTUserDomains();

  TMTUserDomains(const TMTUserDomains& from);

  inline TMTUserDomains& operator=(const TMTUserDomains& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUserDomains& default_instance();

  void Swap(TMTUserDomains* other);

  // implements Message ----------------------------------------------

  TMTUserDomains* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUserDomains& from);
  void MergeFrom(const TMTUserDomains& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTUserDomainInfo user_domain_info = 2;
  inline int user_domain_info_size() const;
  inline void clear_user_domain_info();
  static const int kUserDomainInfoFieldNumber = 2;
  inline const ::mt::TMTUserDomainInfo& user_domain_info(int index) const;
  inline ::mt::TMTUserDomainInfo* mutable_user_domain_info(int index);
  inline ::mt::TMTUserDomainInfo* add_user_domain_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUserDomainInfo >&
      user_domain_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUserDomainInfo >*
      mutable_user_domain_info();

  // @@protoc_insertion_point(class_scope:mt.TMTUserDomains)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTUserDomainInfo > user_domain_info_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTUserDomains* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUserDomainDepartmentInfo : public ::google::protobuf::Message {
 public:
  TMTUserDomainDepartmentInfo();
  virtual ~TMTUserDomainDepartmentInfo();

  TMTUserDomainDepartmentInfo(const TMTUserDomainDepartmentInfo& from);

  inline TMTUserDomainDepartmentInfo& operator=(const TMTUserDomainDepartmentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUserDomainDepartmentInfo& default_instance();

  void Swap(TMTUserDomainDepartmentInfo* other);

  // implements Message ----------------------------------------------

  TMTUserDomainDepartmentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUserDomainDepartmentInfo& from);
  void MergeFrom(const TMTUserDomainDepartmentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid = 1;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 1;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional uint32 department_id = 2;
  inline bool has_department_id() const;
  inline void clear_department_id();
  static const int kDepartmentIdFieldNumber = 2;
  inline ::google::protobuf::uint32 department_id() const;
  inline void set_department_id(::google::protobuf::uint32 value);

  // optional string department_name = 3;
  inline bool has_department_name() const;
  inline void clear_department_name();
  static const int kDepartmentNameFieldNumber = 3;
  inline const ::std::string& department_name() const;
  inline void set_department_name(const ::std::string& value);
  inline void set_department_name(const char* value);
  inline void set_department_name(const char* value, size_t size);
  inline ::std::string* mutable_department_name();
  inline ::std::string* release_department_name();
  inline void set_allocated_department_name(::std::string* department_name);

  // optional uint32 parent_id = 4;
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 4;
  inline ::google::protobuf::uint32 parent_id() const;
  inline void set_parent_id(::google::protobuf::uint32 value);

  // optional bool leaf = 5;
  inline bool has_leaf() const;
  inline void clear_leaf();
  static const int kLeafFieldNumber = 5;
  inline bool leaf() const;
  inline void set_leaf(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTUserDomainDepartmentInfo)
 private:
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_department_id();
  inline void clear_has_department_id();
  inline void set_has_department_name();
  inline void clear_has_department_name();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_leaf();
  inline void clear_has_leaf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::std::string* department_name_;
  ::google::protobuf::uint32 department_id_;
  ::google::protobuf::uint32 parent_id_;
  bool leaf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTUserDomainDepartmentInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUserDomainDepartments : public ::google::protobuf::Message {
 public:
  TMTUserDomainDepartments();
  virtual ~TMTUserDomainDepartments();

  TMTUserDomainDepartments(const TMTUserDomainDepartments& from);

  inline TMTUserDomainDepartments& operator=(const TMTUserDomainDepartments& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUserDomainDepartments& default_instance();

  void Swap(TMTUserDomainDepartments* other);

  // implements Message ----------------------------------------------

  TMTUserDomainDepartments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUserDomainDepartments& from);
  void MergeFrom(const TMTUserDomainDepartments& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .mt.TMTUserDomainDepartmentInfo user_domain_dept_info = 2;
  inline int user_domain_dept_info_size() const;
  inline void clear_user_domain_dept_info();
  static const int kUserDomainDeptInfoFieldNumber = 2;
  inline const ::mt::TMTUserDomainDepartmentInfo& user_domain_dept_info(int index) const;
  inline ::mt::TMTUserDomainDepartmentInfo* mutable_user_domain_dept_info(int index);
  inline ::mt::TMTUserDomainDepartmentInfo* add_user_domain_dept_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUserDomainDepartmentInfo >&
      user_domain_dept_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUserDomainDepartmentInfo >*
      mutable_user_domain_dept_info();

  // @@protoc_insertion_point(class_scope:mt.TMTUserDomainDepartments)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTUserDomainDepartmentInfo > user_domain_dept_info_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTUserDomainDepartments* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPublicGroupInfo : public ::google::protobuf::Message {
 public:
  TMTPublicGroupInfo();
  virtual ~TMTPublicGroupInfo();

  TMTPublicGroupInfo(const TMTPublicGroupInfo& from);

  inline TMTPublicGroupInfo& operator=(const TMTPublicGroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPublicGroupInfo& default_instance();

  void Swap(TMTPublicGroupInfo* other);

  // implements Message ----------------------------------------------

  TMTPublicGroupInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPublicGroupInfo& from);
  void MergeFrom(const TMTPublicGroupInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid = 1;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 1;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string parent_moid = 3;
  inline bool has_parent_moid() const;
  inline void clear_parent_moid();
  static const int kParentMoidFieldNumber = 3;
  inline const ::std::string& parent_moid() const;
  inline void set_parent_moid(const ::std::string& value);
  inline void set_parent_moid(const char* value);
  inline void set_parent_moid(const char* value, size_t size);
  inline ::std::string* mutable_parent_moid();
  inline ::std::string* release_parent_moid();
  inline void set_allocated_parent_moid(::std::string* parent_moid);

  // @@protoc_insertion_point(class_scope:mt.TMTPublicGroupInfo)
 private:
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_parent_moid();
  inline void clear_has_parent_moid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::std::string* name_;
  ::std::string* parent_moid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPublicGroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPublicGroups : public ::google::protobuf::Message {
 public:
  TMTPublicGroups();
  virtual ~TMTPublicGroups();

  TMTPublicGroups(const TMTPublicGroups& from);

  inline TMTPublicGroups& operator=(const TMTPublicGroups& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPublicGroups& default_instance();

  void Swap(TMTPublicGroups* other);

  // implements Message ----------------------------------------------

  TMTPublicGroups* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPublicGroups& from);
  void MergeFrom(const TMTPublicGroups& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTPublicGroupInfo group_info = 1;
  inline int group_info_size() const;
  inline void clear_group_info();
  static const int kGroupInfoFieldNumber = 1;
  inline const ::mt::TMTPublicGroupInfo& group_info(int index) const;
  inline ::mt::TMTPublicGroupInfo* mutable_group_info(int index);
  inline ::mt::TMTPublicGroupInfo* add_group_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPublicGroupInfo >&
      group_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPublicGroupInfo >*
      mutable_group_info();

  // @@protoc_insertion_point(class_scope:mt.TMTPublicGroups)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTPublicGroupInfo > group_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPublicGroups* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPublicGroupUserInfo : public ::google::protobuf::Message {
 public:
  TMTPublicGroupUserInfo();
  virtual ~TMTPublicGroupUserInfo();

  TMTPublicGroupUserInfo(const TMTPublicGroupUserInfo& from);

  inline TMTPublicGroupUserInfo& operator=(const TMTPublicGroupUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPublicGroupUserInfo& default_instance();

  void Swap(TMTPublicGroupUserInfo* other);

  // implements Message ----------------------------------------------

  TMTPublicGroupUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPublicGroupUserInfo& from);
  void MergeFrom(const TMTPublicGroupUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid = 1;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 1;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional string jid = 2;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 2;
  inline const ::std::string& jid() const;
  inline void set_jid(const ::std::string& value);
  inline void set_jid(const char* value);
  inline void set_jid(const char* value, size_t size);
  inline ::std::string* mutable_jid();
  inline ::std::string* release_jid();
  inline void set_allocated_jid(::std::string* jid);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string e164 = 5;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 5;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string mobile = 6;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 6;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  inline void set_allocated_mobile(::std::string* mobile);

  // optional string group_moid = 7;
  inline bool has_group_moid() const;
  inline void clear_group_moid();
  static const int kGroupMoidFieldNumber = 7;
  inline const ::std::string& group_moid() const;
  inline void set_group_moid(const ::std::string& value);
  inline void set_group_moid(const char* value);
  inline void set_group_moid(const char* value, size_t size);
  inline ::std::string* mutable_group_moid();
  inline ::std::string* release_group_moid();
  inline void set_allocated_group_moid(::std::string* group_moid);

  // optional string name = 8;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 8;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string extnum = 9;
  inline bool has_extnum() const;
  inline void clear_extnum();
  static const int kExtnumFieldNumber = 9;
  inline const ::std::string& extnum() const;
  inline void set_extnum(const ::std::string& value);
  inline void set_extnum(const char* value);
  inline void set_extnum(const char* value, size_t size);
  inline ::std::string* mutable_extnum();
  inline ::std::string* release_extnum();
  inline void set_allocated_extnum(::std::string* extnum);

  // optional string seat = 10;
  inline bool has_seat() const;
  inline void clear_seat();
  static const int kSeatFieldNumber = 10;
  inline const ::std::string& seat() const;
  inline void set_seat(const ::std::string& value);
  inline void set_seat(const char* value);
  inline void set_seat(const char* value, size_t size);
  inline ::std::string* mutable_seat();
  inline ::std::string* release_seat();
  inline void set_allocated_seat(::std::string* seat);

  // optional string brief = 11;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 11;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // optional string portrait40 = 12;
  inline bool has_portrait40() const;
  inline void clear_portrait40();
  static const int kPortrait40FieldNumber = 12;
  inline const ::std::string& portrait40() const;
  inline void set_portrait40(const ::std::string& value);
  inline void set_portrait40(const char* value);
  inline void set_portrait40(const char* value, size_t size);
  inline ::std::string* mutable_portrait40();
  inline ::std::string* release_portrait40();
  inline void set_allocated_portrait40(::std::string* portrait40);

  // optional string portrait64 = 13;
  inline bool has_portrait64() const;
  inline void clear_portrait64();
  static const int kPortrait64FieldNumber = 13;
  inline const ::std::string& portrait64() const;
  inline void set_portrait64(const ::std::string& value);
  inline void set_portrait64(const char* value);
  inline void set_portrait64(const char* value, size_t size);
  inline ::std::string* mutable_portrait64();
  inline ::std::string* release_portrait64();
  inline void set_allocated_portrait64(::std::string* portrait64);

  // optional string portrait128 = 14;
  inline bool has_portrait128() const;
  inline void clear_portrait128();
  static const int kPortrait128FieldNumber = 14;
  inline const ::std::string& portrait128() const;
  inline void set_portrait128(const ::std::string& value);
  inline void set_portrait128(const char* value);
  inline void set_portrait128(const char* value, size_t size);
  inline ::std::string* mutable_portrait128();
  inline ::std::string* release_portrait128();
  inline void set_allocated_portrait128(::std::string* portrait128);

  // @@protoc_insertion_point(class_scope:mt.TMTPublicGroupUserInfo)
 private:
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_jid();
  inline void clear_has_jid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_group_moid();
  inline void clear_has_group_moid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_extnum();
  inline void clear_has_extnum();
  inline void set_has_seat();
  inline void clear_has_seat();
  inline void set_has_brief();
  inline void clear_has_brief();
  inline void set_has_portrait40();
  inline void clear_has_portrait40();
  inline void set_has_portrait64();
  inline void clear_has_portrait64();
  inline void set_has_portrait128();
  inline void clear_has_portrait128();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_;
  ::std::string* jid_;
  ::std::string* account_;
  ::std::string* email_;
  ::std::string* e164_;
  ::std::string* mobile_;
  ::std::string* group_moid_;
  ::std::string* name_;
  ::std::string* extnum_;
  ::std::string* seat_;
  ::std::string* brief_;
  ::std::string* portrait40_;
  ::std::string* portrait64_;
  ::std::string* portrait128_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPublicGroupUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPublicGroupUsers : public ::google::protobuf::Message {
 public:
  TMTPublicGroupUsers();
  virtual ~TMTPublicGroupUsers();

  TMTPublicGroupUsers(const TMTPublicGroupUsers& from);

  inline TMTPublicGroupUsers& operator=(const TMTPublicGroupUsers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPublicGroupUsers& default_instance();

  void Swap(TMTPublicGroupUsers* other);

  // implements Message ----------------------------------------------

  TMTPublicGroupUsers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPublicGroupUsers& from);
  void MergeFrom(const TMTPublicGroupUsers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTPublicGroupUserInfo user_info = 1;
  inline int user_info_size() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::mt::TMTPublicGroupUserInfo& user_info(int index) const;
  inline ::mt::TMTPublicGroupUserInfo* mutable_user_info(int index);
  inline ::mt::TMTPublicGroupUserInfo* add_user_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPublicGroupUserInfo >&
      user_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPublicGroupUserInfo >*
      mutable_user_info();

  // @@protoc_insertion_point(class_scope:mt.TMTPublicGroupUsers)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTPublicGroupUserInfo > user_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPublicGroupUsers* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPushSrvReq : public ::google::protobuf::Message {
 public:
  TMTPushSrvReq();
  virtual ~TMTPushSrvReq();

  TMTPushSrvReq(const TMTPushSrvReq& from);

  inline TMTPushSrvReq& operator=(const TMTPushSrvReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPushSrvReq& default_instance();

  void Swap(TMTPushSrvReq* other);

  // implements Message ----------------------------------------------

  TMTPushSrvReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPushSrvReq& from);
  void MergeFrom(const TMTPushSrvReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string usermoid = 4;
  inline bool has_usermoid() const;
  inline void clear_usermoid();
  static const int kUsermoidFieldNumber = 4;
  inline const ::std::string& usermoid() const;
  inline void set_usermoid(const ::std::string& value);
  inline void set_usermoid(const char* value);
  inline void set_usermoid(const char* value, size_t size);
  inline ::std::string* mutable_usermoid();
  inline ::std::string* release_usermoid();
  inline void set_allocated_usermoid(::std::string* usermoid);

  // optional string e164 = 5;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 5;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string mttype = 6;
  inline bool has_mttype() const;
  inline void clear_mttype();
  static const int kMttypeFieldNumber = 6;
  inline const ::std::string& mttype() const;
  inline void set_mttype(const ::std::string& value);
  inline void set_mttype(const char* value);
  inline void set_mttype(const char* value, size_t size);
  inline ::std::string* mutable_mttype();
  inline ::std::string* release_mttype();
  inline void set_allocated_mttype(::std::string* mttype);

  // optional string alideviceid = 7;
  inline bool has_alideviceid() const;
  inline void clear_alideviceid();
  static const int kAlideviceidFieldNumber = 7;
  inline const ::std::string& alideviceid() const;
  inline void set_alideviceid(const ::std::string& value);
  inline void set_alideviceid(const char* value);
  inline void set_alideviceid(const char* value, size_t size);
  inline ::std::string* mutable_alideviceid();
  inline ::std::string* release_alideviceid();
  inline void set_allocated_alideviceid(::std::string* alideviceid);

  // optional string aliappkey = 8;
  inline bool has_aliappkey() const;
  inline void clear_aliappkey();
  static const int kAliappkeyFieldNumber = 8;
  inline const ::std::string& aliappkey() const;
  inline void set_aliappkey(const ::std::string& value);
  inline void set_aliappkey(const char* value);
  inline void set_aliappkey(const char* value, size_t size);
  inline ::std::string* mutable_aliappkey();
  inline ::std::string* release_aliappkey();
  inline void set_allocated_aliappkey(::std::string* aliappkey);

  // optional string mtsystype = 9;
  inline bool has_mtsystype() const;
  inline void clear_mtsystype();
  static const int kMtsystypeFieldNumber = 9;
  inline const ::std::string& mtsystype() const;
  inline void set_mtsystype(const ::std::string& value);
  inline void set_mtsystype(const char* value);
  inline void set_mtsystype(const char* value, size_t size);
  inline ::std::string* mutable_mtsystype();
  inline ::std::string* release_mtsystype();
  inline void set_allocated_mtsystype(::std::string* mtsystype);

  // optional string mtsyslan = 10;
  inline bool has_mtsyslan() const;
  inline void clear_mtsyslan();
  static const int kMtsyslanFieldNumber = 10;
  inline const ::std::string& mtsyslan() const;
  inline void set_mtsyslan(const ::std::string& value);
  inline void set_mtsyslan(const char* value);
  inline void set_mtsyslan(const char* value, size_t size);
  inline ::std::string* mutable_mtsyslan();
  inline ::std::string* release_mtsyslan();
  inline void set_allocated_mtsyslan(::std::string* mtsyslan);

  // optional string deviceid = 11;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 11;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional uint32 srvip = 12;
  inline bool has_srvip() const;
  inline void clear_srvip();
  static const int kSrvipFieldNumber = 12;
  inline ::google::protobuf::uint32 srvip() const;
  inline void set_srvip(::google::protobuf::uint32 value);

  // optional string jid = 13;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 13;
  inline const ::std::string& jid() const;
  inline void set_jid(const ::std::string& value);
  inline void set_jid(const char* value);
  inline void set_jid(const char* value, size_t size);
  inline ::std::string* mutable_jid();
  inline ::std::string* release_jid();
  inline void set_allocated_jid(::std::string* jid);

  // @@protoc_insertion_point(class_scope:mt.TMTPushSrvReq)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_usermoid();
  inline void clear_has_usermoid();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_mttype();
  inline void clear_has_mttype();
  inline void set_has_alideviceid();
  inline void clear_has_alideviceid();
  inline void set_has_aliappkey();
  inline void clear_has_aliappkey();
  inline void set_has_mtsystype();
  inline void clear_has_mtsystype();
  inline void set_has_mtsyslan();
  inline void clear_has_mtsyslan();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_srvip();
  inline void clear_has_srvip();
  inline void set_has_jid();
  inline void clear_has_jid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;
  ::std::string* version_;
  ::std::string* usermoid_;
  ::std::string* e164_;
  ::std::string* mttype_;
  ::std::string* alideviceid_;
  ::std::string* aliappkey_;
  ::std::string* mtsystype_;
  ::std::string* mtsyslan_;
  ::std::string* deviceid_;
  ::std::string* jid_;
  ::google::protobuf::uint32 srvip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPushSrvReq* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPushSrvResult : public ::google::protobuf::Message {
 public:
  TMTPushSrvResult();
  virtual ~TMTPushSrvResult();

  TMTPushSrvResult(const TMTPushSrvResult& from);

  inline TMTPushSrvResult& operator=(const TMTPushSrvResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPushSrvResult& default_instance();

  void Swap(TMTPushSrvResult* other);

  // implements Message ----------------------------------------------

  TMTPushSrvResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPushSrvResult& from);
  void MergeFrom(const TMTPushSrvResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // optional uint32 errorcode = 2;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTPushSrvResult)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool success_;
  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTPushSrvResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVConfMember : public ::google::protobuf::Message {
 public:
  TMTVConfMember();
  virtual ~TMTVConfMember();

  TMTVConfMember(const TMTVConfMember& from);

  inline TMTVConfMember& operator=(const TMTVConfMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVConfMember& default_instance();

  void Swap(TMTVConfMember* other);

  // implements Message ----------------------------------------------

  TMTVConfMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVConfMember& from);
  void MergeFrom(const TMTVConfMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional .mt.EmMtAddrType accounttype = 3;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccounttypeFieldNumber = 3;
  inline ::mt::EmMtAddrType accounttype() const;
  inline void set_accounttype(::mt::EmMtAddrType value);

  // optional .mt.EmConfProtocol protocol = 4;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 4;
  inline ::mt::EmConfProtocol protocol() const;
  inline void set_protocol(::mt::EmConfProtocol value);

  // @@protoc_insertion_point(class_scope:mt.TMTVConfMember)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_protocol();
  inline void clear_has_protocol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* account_;
  int accounttype_;
  int protocol_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVConfMember* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCreateVConf : public ::google::protobuf::Message {
 public:
  TMTCreateVConf();
  virtual ~TMTCreateVConf();

  TMTCreateVConf(const TMTCreateVConf& from);

  inline TMTCreateVConf& operator=(const TMTCreateVConf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCreateVConf& default_instance();

  void Swap(TMTCreateVConf* other);

  // implements Message ----------------------------------------------

  TMTCreateVConf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCreateVConf& from);
  void MergeFrom(const TMTCreateVConf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 confid = 1;
  inline bool has_confid() const;
  inline void clear_confid();
  static const int kConfidFieldNumber = 1;
  inline ::google::protobuf::uint32 confid() const;
  inline void set_confid(::google::protobuf::uint32 value);

  // optional string confname = 2;
  inline bool has_confname() const;
  inline void clear_confname();
  static const int kConfnameFieldNumber = 2;
  inline const ::std::string& confname() const;
  inline void set_confname(const ::std::string& value);
  inline void set_confname(const char* value);
  inline void set_confname(const char* value, size_t size);
  inline ::std::string* mutable_confname();
  inline ::std::string* release_confname();
  inline void set_allocated_confname(::std::string* confname);

  // optional uint32 duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // repeated .mt.TMTVConfMember member = 4;
  inline int member_size() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 4;
  inline const ::mt::TMTVConfMember& member(int index) const;
  inline ::mt::TMTVConfMember* mutable_member(int index);
  inline ::mt::TMTVConfMember* add_member();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >&
      member() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >*
      mutable_member();

  // @@protoc_insertion_point(class_scope:mt.TMTCreateVConf)
 private:
  inline void set_has_confid();
  inline void clear_has_confid();
  inline void set_has_confname();
  inline void clear_has_confname();
  inline void set_has_duration();
  inline void clear_has_duration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* confname_;
  ::google::protobuf::uint32 confid_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember > member_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTCreateVConf* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVConfResult : public ::google::protobuf::Message {
 public:
  TMTVConfResult();
  virtual ~TMTVConfResult();

  TMTVConfResult(const TMTVConfResult& from);

  inline TMTVConfResult& operator=(const TMTVConfResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVConfResult& default_instance();

  void Swap(TMTVConfResult* other);

  // implements Message ----------------------------------------------

  TMTVConfResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVConfResult& from);
  void MergeFrom(const TMTVConfResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // optional uint32 errorcode = 2;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional string description = 3;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 3;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string templateid = 4;
  inline bool has_templateid() const;
  inline void clear_templateid();
  static const int kTemplateidFieldNumber = 4;
  inline const ::std::string& templateid() const;
  inline void set_templateid(const ::std::string& value);
  inline void set_templateid(const char* value);
  inline void set_templateid(const char* value, size_t size);
  inline ::std::string* mutable_templateid();
  inline ::std::string* release_templateid();
  inline void set_allocated_templateid(::std::string* templateid);

  // @@protoc_insertion_point(class_scope:mt.TMTVConfResult)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_templateid();
  inline void clear_has_templateid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool success_;
  ::google::protobuf::uint32 errorcode_;
  ::std::string* description_;
  ::std::string* templateid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVConfResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVConfListReq : public ::google::protobuf::Message {
 public:
  TMTVConfListReq();
  virtual ~TMTVConfListReq();

  TMTVConfListReq(const TMTVConfListReq& from);

  inline TMTVConfListReq& operator=(const TMTVConfListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVConfListReq& default_instance();

  void Swap(TMTVConfListReq* other);

  // implements Message ----------------------------------------------

  TMTVConfListReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVConfListReq& from);
  void MergeFrom(const TMTVConfListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 order = 2;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 2;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // optional uint32 start = 3;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 3;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTVConfListReq)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_start();
  inline void clear_has_start();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 order_;
  ::google::protobuf::uint32 start_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVConfListReq* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVConfInfo : public ::google::protobuf::Message {
 public:
  TMTVConfInfo();
  virtual ~TMTVConfInfo();

  TMTVConfInfo(const TMTVConfInfo& from);

  inline TMTVConfInfo& operator=(const TMTVConfInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVConfInfo& default_instance();

  void Swap(TMTVConfInfo* other);

  // implements Message ----------------------------------------------

  TMTVConfInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVConfInfo& from);
  void MergeFrom(const TMTVConfInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string confid = 1;
  inline bool has_confid() const;
  inline void clear_confid();
  static const int kConfidFieldNumber = 1;
  inline const ::std::string& confid() const;
  inline void set_confid(const ::std::string& value);
  inline void set_confid(const char* value);
  inline void set_confid(const char* value, size_t size);
  inline ::std::string* mutable_confid();
  inline ::std::string* release_confid();
  inline void set_allocated_confid(::std::string* confid);

  // optional string confe164 = 2;
  inline bool has_confe164() const;
  inline void clear_confe164();
  static const int kConfe164FieldNumber = 2;
  inline const ::std::string& confe164() const;
  inline void set_confe164(const ::std::string& value);
  inline void set_confe164(const char* value);
  inline void set_confe164(const char* value, size_t size);
  inline ::std::string* mutable_confe164();
  inline ::std::string* release_confe164();
  inline void set_allocated_confe164(::std::string* confe164);

  // optional string virualroomname = 3;
  inline bool has_virualroomname() const;
  inline void clear_virualroomname();
  static const int kVirualroomnameFieldNumber = 3;
  inline const ::std::string& virualroomname() const;
  inline void set_virualroomname(const ::std::string& value);
  inline void set_virualroomname(const char* value);
  inline void set_virualroomname(const char* value, size_t size);
  inline ::std::string* mutable_virualroomname();
  inline ::std::string* release_virualroomname();
  inline void set_allocated_virualroomname(::std::string* virualroomname);

  // optional string confname = 4;
  inline bool has_confname() const;
  inline void clear_confname();
  static const int kConfnameFieldNumber = 4;
  inline const ::std::string& confname() const;
  inline void set_confname(const ::std::string& value);
  inline void set_confname(const char* value);
  inline void set_confname(const char* value, size_t size);
  inline ::std::string* mutable_confname();
  inline ::std::string* release_confname();
  inline void set_allocated_confname(::std::string* confname);

  // optional .mt.EmMtOpenMode safeconf = 5;
  inline bool has_safeconf() const;
  inline void clear_safeconf();
  static const int kSafeconfFieldNumber = 5;
  inline ::mt::EmMtOpenMode safeconf() const;
  inline void set_safeconf(::mt::EmMtOpenMode value);

  // optional .mt.EmMtVConfStatus confstatus = 6;
  inline bool has_confstatus() const;
  inline void clear_confstatus();
  static const int kConfstatusFieldNumber = 6;
  inline ::mt::EmMtVConfStatus confstatus() const;
  inline void set_confstatus(::mt::EmMtVConfStatus value);

  // optional .mt.EmMtMaxJoinMt maxjoinmt = 7;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxjoinmtFieldNumber = 7;
  inline ::mt::EmMtMaxJoinMt maxjoinmt() const;
  inline void set_maxjoinmt(::mt::EmMtMaxJoinMt value);

  // optional string encryptedkey = 8;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 8;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional uint32 bitrate = 9;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 9;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional bool exclusive = 10;
  inline bool has_exclusive() const;
  inline void clear_exclusive();
  static const int kExclusiveFieldNumber = 10;
  inline bool exclusive() const;
  inline void set_exclusive(bool value);

  // repeated .mt.TMTVConfMember exuser = 11;
  inline int exuser_size() const;
  inline void clear_exuser();
  static const int kExuserFieldNumber = 11;
  inline const ::mt::TMTVConfMember& exuser(int index) const;
  inline ::mt::TMTVConfMember* mutable_exuser(int index);
  inline ::mt::TMTVConfMember* add_exuser();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >&
      exuser() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >*
      mutable_exuser();

  // optional .mt.EmMtResolution resolution = 12;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 12;
  inline ::mt::EmMtResolution resolution() const;
  inline void set_resolution(::mt::EmMtResolution value);

  // @@protoc_insertion_point(class_scope:mt.TMTVConfInfo)
 private:
  inline void set_has_confid();
  inline void clear_has_confid();
  inline void set_has_confe164();
  inline void clear_has_confe164();
  inline void set_has_virualroomname();
  inline void clear_has_virualroomname();
  inline void set_has_confname();
  inline void clear_has_confname();
  inline void set_has_safeconf();
  inline void clear_has_safeconf();
  inline void set_has_confstatus();
  inline void clear_has_confstatus();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_exclusive();
  inline void clear_has_exclusive();
  inline void set_has_resolution();
  inline void clear_has_resolution();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* confid_;
  ::std::string* confe164_;
  ::std::string* virualroomname_;
  ::std::string* confname_;
  int safeconf_;
  int confstatus_;
  ::std::string* encryptedkey_;
  int maxjoinmt_;
  ::google::protobuf::uint32 bitrate_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember > exuser_;
  bool exclusive_;
  int resolution_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVConfInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVConfList : public ::google::protobuf::Message {
 public:
  TMTVConfList();
  virtual ~TMTVConfList();

  TMTVConfList(const TMTVConfList& from);

  inline TMTVConfList& operator=(const TMTVConfList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVConfList& default_instance();

  void Swap(TMTVConfList* other);

  // implements Message ----------------------------------------------

  TMTVConfList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVConfList& from);
  void MergeFrom(const TMTVConfList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTVConfInfo confinfo = 1;
  inline int confinfo_size() const;
  inline void clear_confinfo();
  static const int kConfinfoFieldNumber = 1;
  inline const ::mt::TMTVConfInfo& confinfo(int index) const;
  inline ::mt::TMTVConfInfo* mutable_confinfo(int index);
  inline ::mt::TMTVConfInfo* add_confinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfInfo >&
      confinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfInfo >*
      mutable_confinfo();

  // @@protoc_insertion_point(class_scope:mt.TMTVConfList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfInfo > confinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVConfList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVConfResource : public ::google::protobuf::Message {
 public:
  TMTVConfResource();
  virtual ~TMTVConfResource();

  TMTVConfResource(const TMTVConfResource& from);

  inline TMTVConfResource& operator=(const TMTVConfResource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVConfResource& default_instance();

  void Swap(TMTVConfResource* other);

  // implements Message ----------------------------------------------

  TMTVConfResource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVConfResource& from);
  void MergeFrom(const TMTVConfResource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional uint32 used = 3;
  inline bool has_used() const;
  inline void clear_used();
  static const int kUsedFieldNumber = 3;
  inline ::google::protobuf::uint32 used() const;
  inline void set_used(::google::protobuf::uint32 value);

  // optional .mt.EmMtResolution resolution = 4;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 4;
  inline ::mt::EmMtResolution resolution() const;
  inline void set_resolution(::mt::EmMtResolution value);

  // optional .mt.EmMtMaxJoinMt maxjoinmt = 5;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxjoinmtFieldNumber = 5;
  inline ::mt::EmMtMaxJoinMt maxjoinmt() const;
  inline void set_maxjoinmt(::mt::EmMtMaxJoinMt value);

  // @@protoc_insertion_point(class_scope:mt.TMTVConfResource)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_used();
  inline void clear_has_used();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::uint32 used_;
  int resolution_;
  int maxjoinmt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVConfResource* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVConfResources : public ::google::protobuf::Message {
 public:
  TMTVConfResources();
  virtual ~TMTVConfResources();

  TMTVConfResources(const TMTVConfResources& from);

  inline TMTVConfResources& operator=(const TMTVConfResources& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVConfResources& default_instance();

  void Swap(TMTVConfResources* other);

  // implements Message ----------------------------------------------

  TMTVConfResources* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVConfResources& from);
  void MergeFrom(const TMTVConfResources& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTVConfResource resource = 1;
  inline int resource_size() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 1;
  inline const ::mt::TMTVConfResource& resource(int index) const;
  inline ::mt::TMTVConfResource* mutable_resource(int index);
  inline ::mt::TMTVConfResource* add_resource();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfResource >&
      resource() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfResource >*
      mutable_resource();

  // optional .mt.EmResourceType resourcetype = 2;
  inline bool has_resourcetype() const;
  inline void clear_resourcetype();
  static const int kResourcetypeFieldNumber = 2;
  inline ::mt::EmResourceType resourcetype() const;
  inline void set_resourcetype(::mt::EmResourceType value);

  // @@protoc_insertion_point(class_scope:mt.TMTVConfResources)
 private:
  inline void set_has_resourcetype();
  inline void clear_has_resourcetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfResource > resource_;
  int resourcetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVConfResources* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVConfRecord : public ::google::protobuf::Message {
 public:
  TMTVConfRecord();
  virtual ~TMTVConfRecord();

  TMTVConfRecord(const TMTVConfRecord& from);

  inline TMTVConfRecord& operator=(const TMTVConfRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVConfRecord& default_instance();

  void Swap(TMTVConfRecord* other);

  // implements Message ----------------------------------------------

  TMTVConfRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVConfRecord& from);
  void MergeFrom(const TMTVConfRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmPublishMode publishmode = 1;
  inline bool has_publishmode() const;
  inline void clear_publishmode();
  static const int kPublishmodeFieldNumber = 1;
  inline ::mt::EmPublishMode publishmode() const;
  inline void set_publishmode(::mt::EmPublishMode value);

  // optional .mt.EmRecordMode recordmode = 2;
  inline bool has_recordmode() const;
  inline void clear_recordmode();
  static const int kRecordmodeFieldNumber = 2;
  inline ::mt::EmRecordMode recordmode() const;
  inline void set_recordmode(::mt::EmRecordMode value);

  // optional bool doubleflow = 3;
  inline bool has_doubleflow() const;
  inline void clear_doubleflow();
  static const int kDoubleflowFieldNumber = 3;
  inline bool doubleflow() const;
  inline void set_doubleflow(bool value);

  // optional bool anonymous = 4;
  inline bool has_anonymous() const;
  inline void clear_anonymous();
  static const int kAnonymousFieldNumber = 4;
  inline bool anonymous() const;
  inline void set_anonymous(bool value);

  // optional string vrsid = 5;
  inline bool has_vrsid() const;
  inline void clear_vrsid();
  static const int kVrsidFieldNumber = 5;
  inline const ::std::string& vrsid() const;
  inline void set_vrsid(const ::std::string& value);
  inline void set_vrsid(const char* value);
  inline void set_vrsid(const char* value, size_t size);
  inline ::std::string* mutable_vrsid();
  inline ::std::string* release_vrsid();
  inline void set_allocated_vrsid(::std::string* vrsid);

  // @@protoc_insertion_point(class_scope:mt.TMTVConfRecord)
 private:
  inline void set_has_publishmode();
  inline void clear_has_publishmode();
  inline void set_has_recordmode();
  inline void clear_has_recordmode();
  inline void set_has_doubleflow();
  inline void clear_has_doubleflow();
  inline void set_has_anonymous();
  inline void clear_has_anonymous();
  inline void set_has_vrsid();
  inline void clear_has_vrsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int publishmode_;
  int recordmode_;
  ::std::string* vrsid_;
  bool doubleflow_;
  bool anonymous_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVConfRecord* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVConfDetailInfo : public ::google::protobuf::Message {
 public:
  TMTVConfDetailInfo();
  virtual ~TMTVConfDetailInfo();

  TMTVConfDetailInfo(const TMTVConfDetailInfo& from);

  inline TMTVConfDetailInfo& operator=(const TMTVConfDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVConfDetailInfo& default_instance();

  void Swap(TMTVConfDetailInfo* other);

  // implements Message ----------------------------------------------

  TMTVConfDetailInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVConfDetailInfo& from);
  void MergeFrom(const TMTVConfDetailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string virtualroomname = 1;
  inline bool has_virtualroomname() const;
  inline void clear_virtualroomname();
  static const int kVirtualroomnameFieldNumber = 1;
  inline const ::std::string& virtualroomname() const;
  inline void set_virtualroomname(const ::std::string& value);
  inline void set_virtualroomname(const char* value);
  inline void set_virtualroomname(const char* value, size_t size);
  inline ::std::string* mutable_virtualroomname();
  inline ::std::string* release_virtualroomname();
  inline void set_allocated_virtualroomname(::std::string* virtualroomname);

  // optional string confe164 = 2;
  inline bool has_confe164() const;
  inline void clear_confe164();
  static const int kConfe164FieldNumber = 2;
  inline const ::std::string& confe164() const;
  inline void set_confe164(const ::std::string& value);
  inline void set_confe164(const char* value);
  inline void set_confe164(const char* value, size_t size);
  inline ::std::string* mutable_confe164();
  inline ::std::string* release_confe164();
  inline void set_allocated_confe164(::std::string* confe164);

  // optional uint32 duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 4;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 4;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // repeated .mt.TMTVideoFormatList videoformatlist = 5;
  inline int videoformatlist_size() const;
  inline void clear_videoformatlist();
  static const int kVideoformatlistFieldNumber = 5;
  inline const ::mt::TMTVideoFormatList& videoformatlist(int index) const;
  inline ::mt::TMTVideoFormatList* mutable_videoformatlist(int index);
  inline ::mt::TMTVideoFormatList* add_videoformatlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
      videoformatlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
      mutable_videoformatlist();

  // optional string confname = 6;
  inline bool has_confname() const;
  inline void clear_confname();
  static const int kConfnameFieldNumber = 6;
  inline const ::std::string& confname() const;
  inline void set_confname(const ::std::string& value);
  inline void set_confname(const char* value);
  inline void set_confname(const char* value, size_t size);
  inline ::std::string* mutable_confname();
  inline ::std::string* release_confname();
  inline void set_allocated_confname(::std::string* confname);

  // optional .mt.EmRestMeetingSafeType meetingtype = 7;
  inline bool has_meetingtype() const;
  inline void clear_meetingtype();
  static const int kMeetingtypeFieldNumber = 7;
  inline ::mt::EmRestMeetingSafeType meetingtype() const;
  inline void set_meetingtype(::mt::EmRestMeetingSafeType value);

  // optional .mt.EmMtOpenMode meetingsafe = 8;
  inline bool has_meetingsafe() const;
  inline void clear_meetingsafe();
  static const int kMeetingsafeFieldNumber = 8;
  inline ::mt::EmMtOpenMode meetingsafe() const;
  inline void set_meetingsafe(::mt::EmMtOpenMode value);

  // optional .mt.EmMtVConfStatus confstatus = 9;
  inline bool has_confstatus() const;
  inline void clear_confstatus();
  static const int kConfstatusFieldNumber = 9;
  inline ::mt::EmMtVConfStatus confstatus() const;
  inline void set_confstatus(::mt::EmMtVConfStatus value);

  // optional .mt.EmMtMaxJoinMt maxjoinmt = 10;
  inline bool has_maxjoinmt() const;
  inline void clear_maxjoinmt();
  static const int kMaxjoinmtFieldNumber = 10;
  inline ::mt::EmMtMaxJoinMt maxjoinmt() const;
  inline void set_maxjoinmt(::mt::EmMtMaxJoinMt value);

  // optional .mt.EmRestCascadeMode cascademode = 11;
  inline bool has_cascademode() const;
  inline void clear_cascademode();
  static const int kCascademodeFieldNumber = 11;
  inline ::mt::EmRestCascadeMode cascademode() const;
  inline void set_cascademode(::mt::EmRestCascadeMode value);

  // optional bool cascadeupload = 12;
  inline bool has_cascadeupload() const;
  inline void clear_cascadeupload();
  static const int kCascadeuploadFieldNumber = 12;
  inline bool cascadeupload() const;
  inline void set_cascadeupload(bool value);

  // optional bool cascadereturn = 13;
  inline bool has_cascadereturn() const;
  inline void clear_cascadereturn();
  static const int kCascadereturnFieldNumber = 13;
  inline bool cascadereturn() const;
  inline void set_cascadereturn(bool value);

  // optional uint32 cascadereturnpara = 14;
  inline bool has_cascadereturnpara() const;
  inline void clear_cascadereturnpara();
  static const int kCascadereturnparaFieldNumber = 14;
  inline ::google::protobuf::uint32 cascadereturnpara() const;
  inline void set_cascadereturnpara(::google::protobuf::uint32 value);

  // optional bool initmute = 15;
  inline bool has_initmute() const;
  inline void clear_initmute();
  static const int kInitmuteFieldNumber = 15;
  inline bool initmute() const;
  inline void set_initmute(bool value);

  // optional bool mutefilter = 16;
  inline bool has_mutefilter() const;
  inline void clear_mutefilter();
  static const int kMutefilterFieldNumber = 16;
  inline bool mutefilter() const;
  inline void set_mutefilter(bool value);

  // optional .mt.TMTGetMixInfo mixinfo = 17;
  inline bool has_mixinfo() const;
  inline void clear_mixinfo();
  static const int kMixinfoFieldNumber = 17;
  inline const ::mt::TMTGetMixInfo& mixinfo() const;
  inline ::mt::TMTGetMixInfo* mutable_mixinfo();
  inline ::mt::TMTGetMixInfo* release_mixinfo();
  inline void set_allocated_mixinfo(::mt::TMTGetMixInfo* mixinfo);

  // optional .mt.EmVmpMode vmp = 18;
  inline bool has_vmp() const;
  inline void clear_vmp();
  static const int kVmpFieldNumber = 18;
  inline ::mt::EmVmpMode vmp() const;
  inline void set_vmp(::mt::EmVmpMode value);

  // optional .mt.TMTVConfRecord record = 19;
  inline bool has_record() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 19;
  inline const ::mt::TMTVConfRecord& record() const;
  inline ::mt::TMTVConfRecord* mutable_record();
  inline ::mt::TMTVConfRecord* release_record();
  inline void set_allocated_record(::mt::TMTVConfRecord* record);

  // optional bool preoccpuyresource = 20;
  inline bool has_preoccpuyresource() const;
  inline void clear_preoccpuyresource();
  static const int kPreoccpuyresourceFieldNumber = 20;
  inline bool preoccpuyresource() const;
  inline void set_preoccpuyresource(bool value);

  // optional .mt.EmEncryptArithmetic encryptedtype = 21;
  inline bool has_encryptedtype() const;
  inline void clear_encryptedtype();
  static const int kEncryptedtypeFieldNumber = 21;
  inline ::mt::EmEncryptArithmetic encryptedtype() const;
  inline void set_encryptedtype(::mt::EmEncryptArithmetic value);

  // optional string encryptedkey = 22;
  inline bool has_encryptedkey() const;
  inline void clear_encryptedkey();
  static const int kEncryptedkeyFieldNumber = 22;
  inline const ::std::string& encryptedkey() const;
  inline void set_encryptedkey(const ::std::string& value);
  inline void set_encryptedkey(const char* value);
  inline void set_encryptedkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptedkey();
  inline ::std::string* release_encryptedkey();
  inline void set_allocated_encryptedkey(::std::string* encryptedkey);

  // optional .mt.EmMtDualMode dualmode = 23;
  inline bool has_dualmode() const;
  inline void clear_dualmode();
  static const int kDualmodeFieldNumber = 23;
  inline ::mt::EmMtDualMode dualmode() const;
  inline void set_dualmode(::mt::EmMtDualMode value);

  // optional .mt.EmAnswerMode answermode = 24;
  inline bool has_answermode() const;
  inline void clear_answermode();
  static const int kAnswermodeFieldNumber = 24;
  inline ::mt::EmAnswerMode answermode() const;
  inline void set_answermode(::mt::EmAnswerMode value);

  // optional uint32 calltimes = 25;
  inline bool has_calltimes() const;
  inline void clear_calltimes();
  static const int kCalltimesFieldNumber = 25;
  inline ::google::protobuf::uint32 calltimes() const;
  inline void set_calltimes(::google::protobuf::uint32 value);

  // optional uint32 callinterval = 26;
  inline bool has_callinterval() const;
  inline void clear_callinterval();
  static const int kCallintervalFieldNumber = 26;
  inline ::google::protobuf::uint32 callinterval() const;
  inline void set_callinterval(::google::protobuf::uint32 value);

  // optional bool voiceinspireenable = 27;
  inline bool has_voiceinspireenable() const;
  inline void clear_voiceinspireenable();
  static const int kVoiceinspireenableFieldNumber = 27;
  inline bool voiceinspireenable() const;
  inline void set_voiceinspireenable(bool value);

  // optional uint32 onereforming = 28;
  inline bool has_onereforming() const;
  inline void clear_onereforming();
  static const int kOnereformingFieldNumber = 28;
  inline ::google::protobuf::uint32 onereforming() const;
  inline void set_onereforming(::google::protobuf::uint32 value);

  // optional .mt.EmMtFecMode fecmode = 29;
  inline bool has_fecmode() const;
  inline void clear_fecmode();
  static const int kFecmodeFieldNumber = 29;
  inline ::mt::EmMtFecMode fecmode() const;
  inline void set_fecmode(::mt::EmMtFecMode value);

  // optional bool exclusive = 30;
  inline bool has_exclusive() const;
  inline void clear_exclusive();
  static const int kExclusiveFieldNumber = 30;
  inline bool exclusive() const;
  inline void set_exclusive(bool value);

  // repeated .mt.TMTVConfMember exuser = 31;
  inline int exuser_size() const;
  inline void clear_exuser();
  static const int kExuserFieldNumber = 31;
  inline const ::mt::TMTVConfMember& exuser(int index) const;
  inline ::mt::TMTVConfMember* mutable_exuser(int index);
  inline ::mt::TMTVConfMember* add_exuser();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >&
      exuser() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >*
      mutable_exuser();

  // @@protoc_insertion_point(class_scope:mt.TMTVConfDetailInfo)
 private:
  inline void set_has_virtualroomname();
  inline void clear_has_virtualroomname();
  inline void set_has_confe164();
  inline void clear_has_confe164();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_confname();
  inline void clear_has_confname();
  inline void set_has_meetingtype();
  inline void clear_has_meetingtype();
  inline void set_has_meetingsafe();
  inline void clear_has_meetingsafe();
  inline void set_has_confstatus();
  inline void clear_has_confstatus();
  inline void set_has_maxjoinmt();
  inline void clear_has_maxjoinmt();
  inline void set_has_cascademode();
  inline void clear_has_cascademode();
  inline void set_has_cascadeupload();
  inline void clear_has_cascadeupload();
  inline void set_has_cascadereturn();
  inline void clear_has_cascadereturn();
  inline void set_has_cascadereturnpara();
  inline void clear_has_cascadereturnpara();
  inline void set_has_initmute();
  inline void clear_has_initmute();
  inline void set_has_mutefilter();
  inline void clear_has_mutefilter();
  inline void set_has_mixinfo();
  inline void clear_has_mixinfo();
  inline void set_has_vmp();
  inline void clear_has_vmp();
  inline void set_has_record();
  inline void clear_has_record();
  inline void set_has_preoccpuyresource();
  inline void clear_has_preoccpuyresource();
  inline void set_has_encryptedtype();
  inline void clear_has_encryptedtype();
  inline void set_has_encryptedkey();
  inline void clear_has_encryptedkey();
  inline void set_has_dualmode();
  inline void clear_has_dualmode();
  inline void set_has_answermode();
  inline void clear_has_answermode();
  inline void set_has_calltimes();
  inline void clear_has_calltimes();
  inline void set_has_callinterval();
  inline void clear_has_callinterval();
  inline void set_has_voiceinspireenable();
  inline void clear_has_voiceinspireenable();
  inline void set_has_onereforming();
  inline void clear_has_onereforming();
  inline void set_has_fecmode();
  inline void clear_has_fecmode();
  inline void set_has_exclusive();
  inline void clear_has_exclusive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* virtualroomname_;
  ::std::string* confe164_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 bitrate_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList > videoformatlist_;
  ::std::string* confname_;
  int meetingtype_;
  int meetingsafe_;
  int confstatus_;
  int maxjoinmt_;
  int cascademode_;
  ::google::protobuf::uint32 cascadereturnpara_;
  bool cascadeupload_;
  bool cascadereturn_;
  bool initmute_;
  bool mutefilter_;
  int vmp_;
  ::mt::TMTGetMixInfo* mixinfo_;
  ::mt::TMTVConfRecord* record_;
  ::std::string* encryptedkey_;
  int encryptedtype_;
  int dualmode_;
  int answermode_;
  ::google::protobuf::uint32 calltimes_;
  bool preoccpuyresource_;
  bool voiceinspireenable_;
  bool exclusive_;
  ::google::protobuf::uint32 callinterval_;
  ::google::protobuf::uint32 onereforming_;
  int fecmode_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember > exuser_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVConfDetailInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVMtNameStyle : public ::google::protobuf::Message {
 public:
  TMTVMtNameStyle();
  virtual ~TMTVMtNameStyle();

  TMTVMtNameStyle(const TMTVMtNameStyle& from);

  inline TMTVMtNameStyle& operator=(const TMTVMtNameStyle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVMtNameStyle& default_instance();

  void Swap(TMTVMtNameStyle* other);

  // implements Message ----------------------------------------------

  TMTVMtNameStyle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVMtNameStyle& from);
  void MergeFrom(const TMTVMtNameStyle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 font_size = 1;
  inline bool has_font_size() const;
  inline void clear_font_size();
  static const int kFontSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 font_size() const;
  inline void set_font_size(::google::protobuf::uint32 value);

  // optional uint32 position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);

  // optional string font_color = 3;
  inline bool has_font_color() const;
  inline void clear_font_color();
  static const int kFontColorFieldNumber = 3;
  inline const ::std::string& font_color() const;
  inline void set_font_color(const ::std::string& value);
  inline void set_font_color(const char* value);
  inline void set_font_color(const char* value, size_t size);
  inline ::std::string* mutable_font_color();
  inline ::std::string* release_font_color();
  inline void set_allocated_font_color(::std::string* font_color);

  // @@protoc_insertion_point(class_scope:mt.TMTVMtNameStyle)
 private:
  inline void set_has_font_size();
  inline void clear_has_font_size();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_font_color();
  inline void clear_has_font_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 font_size_;
  ::google::protobuf::uint32 position_;
  ::std::string* font_color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTVMtNameStyle* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTContentLiveURL : public ::google::protobuf::Message {
 public:
  TMTContentLiveURL();
  virtual ~TMTContentLiveURL();

  TMTContentLiveURL(const TMTContentLiveURL& from);

  inline TMTContentLiveURL& operator=(const TMTContentLiveURL& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTContentLiveURL& default_instance();

  void Swap(TMTContentLiveURL* other);

  // implements Message ----------------------------------------------

  TMTContentLiveURL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTContentLiveURL& from);
  void MergeFrom(const TMTContentLiveURL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional string starttime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 3;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 4;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional bool isvideomeeting = 5;
  inline bool has_isvideomeeting() const;
  inline void clear_isvideomeeting();
  static const int kIsvideomeetingFieldNumber = 5;
  inline bool isvideomeeting() const;
  inline void set_isvideomeeting(bool value);

  // optional string phone = 6;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 6;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string mobilephone = 7;
  inline bool has_mobilephone() const;
  inline void clear_mobilephone();
  static const int kMobilephoneFieldNumber = 7;
  inline const ::std::string& mobilephone() const;
  inline void set_mobilephone(const ::std::string& value);
  inline void set_mobilephone(const char* value);
  inline void set_mobilephone(const char* value, size_t size);
  inline ::std::string* mutable_mobilephone();
  inline ::std::string* release_mobilephone();
  inline void set_allocated_mobilephone(::std::string* mobilephone);

  // optional string short_url = 8;
  inline bool has_short_url() const;
  inline void clear_short_url();
  static const int kShortUrlFieldNumber = 8;
  inline const ::std::string& short_url() const;
  inline void set_short_url(const ::std::string& value);
  inline void set_short_url(const char* value);
  inline void set_short_url(const char* value, size_t size);
  inline ::std::string* mutable_short_url();
  inline ::std::string* release_short_url();
  inline void set_allocated_short_url(::std::string* short_url);

  // optional string organizermoid = 9;
  inline bool has_organizermoid() const;
  inline void clear_organizermoid();
  static const int kOrganizermoidFieldNumber = 9;
  inline const ::std::string& organizermoid() const;
  inline void set_organizermoid(const ::std::string& value);
  inline void set_organizermoid(const char* value);
  inline void set_organizermoid(const char* value, size_t size);
  inline ::std::string* mutable_organizermoid();
  inline ::std::string* release_organizermoid();
  inline void set_allocated_organizermoid(::std::string* organizermoid);

  // optional .mt.TMTConfInfoRooms room = 10;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 10;
  inline const ::mt::TMTConfInfoRooms& room() const;
  inline ::mt::TMTConfInfoRooms* mutable_room();
  inline ::mt::TMTConfInfoRooms* release_room();
  inline void set_allocated_room(::mt::TMTConfInfoRooms* room);

  // @@protoc_insertion_point(class_scope:mt.TMTContentLiveURL)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_isvideomeeting();
  inline void clear_has_isvideomeeting();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_mobilephone();
  inline void clear_has_mobilephone();
  inline void set_has_short_url();
  inline void clear_has_short_url();
  inline void set_has_organizermoid();
  inline void clear_has_organizermoid();
  inline void set_has_room();
  inline void clear_has_room();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subject_;
  ::std::string* starttime_;
  ::google::protobuf::uint32 id_;
  bool isvideomeeting_;
  ::std::string* endtime_;
  ::std::string* phone_;
  ::std::string* mobilephone_;
  ::std::string* short_url_;
  ::std::string* organizermoid_;
  ::mt::TMTConfInfoRooms* room_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structrest_2eproto();
  friend void protobuf_AssignDesc_structrest_2eproto();
  friend void protobuf_ShutdownFile_structrest_2eproto();

  void InitAsDefaultInstance();
  static TMTContentLiveURL* default_instance_;
};
// ===================================================================


// ===================================================================

// TMTMeetingList

// optional string startday = 1;
inline bool TMTMeetingList::has_startday() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTMeetingList::set_has_startday() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTMeetingList::clear_has_startday() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTMeetingList::clear_startday() {
  if (startday_ != &::google::protobuf::internal::kEmptyString) {
    startday_->clear();
  }
  clear_has_startday();
}
inline const ::std::string& TMTMeetingList::startday() const {
  return *startday_;
}
inline void TMTMeetingList::set_startday(const ::std::string& value) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(value);
}
inline void TMTMeetingList::set_startday(const char* value) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(value);
}
inline void TMTMeetingList::set_startday(const char* value, size_t size) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMeetingList::mutable_startday() {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  return startday_;
}
inline ::std::string* TMTMeetingList::release_startday() {
  clear_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startday_;
    startday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMeetingList::set_allocated_startday(::std::string* startday) {
  if (startday_ != &::google::protobuf::internal::kEmptyString) {
    delete startday_;
  }
  if (startday) {
    set_has_startday();
    startday_ = startday;
  } else {
    clear_has_startday();
    startday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endday = 2;
inline bool TMTMeetingList::has_endday() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTMeetingList::set_has_endday() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTMeetingList::clear_has_endday() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTMeetingList::clear_endday() {
  if (endday_ != &::google::protobuf::internal::kEmptyString) {
    endday_->clear();
  }
  clear_has_endday();
}
inline const ::std::string& TMTMeetingList::endday() const {
  return *endday_;
}
inline void TMTMeetingList::set_endday(const ::std::string& value) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(value);
}
inline void TMTMeetingList::set_endday(const char* value) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(value);
}
inline void TMTMeetingList::set_endday(const char* value, size_t size) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMeetingList::mutable_endday() {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  return endday_;
}
inline ::std::string* TMTMeetingList::release_endday() {
  clear_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endday_;
    endday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMeetingList::set_allocated_endday(::std::string* endday) {
  if (endday_ != &::google::protobuf::internal::kEmptyString) {
    delete endday_;
  }
  if (endday) {
    set_has_endday();
    endday_ = endday;
  } else {
    clear_has_endday();
    endday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isconfirm = 3;
inline bool TMTMeetingList::has_isconfirm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTMeetingList::set_has_isconfirm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTMeetingList::clear_has_isconfirm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTMeetingList::clear_isconfirm() {
  isconfirm_ = false;
  clear_has_isconfirm();
}
inline bool TMTMeetingList::isconfirm() const {
  return isconfirm_;
}
inline void TMTMeetingList::set_isconfirm(bool value) {
  set_has_isconfirm();
  isconfirm_ = value;
}

// optional uint32 start = 4;
inline bool TMTMeetingList::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTMeetingList::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTMeetingList::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTMeetingList::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTMeetingList::start() const {
  return start_;
}
inline void TMTMeetingList::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 5;
inline bool TMTMeetingList::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTMeetingList::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTMeetingList::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTMeetingList::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTMeetingList::count() const {
  return count_;
}
inline void TMTMeetingList::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 6;
inline bool TMTMeetingList::has_order() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTMeetingList::set_has_order() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTMeetingList::clear_has_order() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTMeetingList::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTMeetingList::order() const {
  return order_;
}
inline void TMTMeetingList::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// -------------------------------------------------------------------

// TMTBookingInfo

// optional uint32 meetingroomid = 1;
inline bool TMTBookingInfo::has_meetingroomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTBookingInfo::set_has_meetingroomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTBookingInfo::clear_has_meetingroomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTBookingInfo::clear_meetingroomid() {
  meetingroomid_ = 0u;
  clear_has_meetingroomid();
}
inline ::google::protobuf::uint32 TMTBookingInfo::meetingroomid() const {
  return meetingroomid_;
}
inline void TMTBookingInfo::set_meetingroomid(::google::protobuf::uint32 value) {
  set_has_meetingroomid();
  meetingroomid_ = value;
}

// optional string startday = 2;
inline bool TMTBookingInfo::has_startday() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTBookingInfo::set_has_startday() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTBookingInfo::clear_has_startday() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTBookingInfo::clear_startday() {
  if (startday_ != &::google::protobuf::internal::kEmptyString) {
    startday_->clear();
  }
  clear_has_startday();
}
inline const ::std::string& TMTBookingInfo::startday() const {
  return *startday_;
}
inline void TMTBookingInfo::set_startday(const ::std::string& value) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(value);
}
inline void TMTBookingInfo::set_startday(const char* value) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(value);
}
inline void TMTBookingInfo::set_startday(const char* value, size_t size) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBookingInfo::mutable_startday() {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  return startday_;
}
inline ::std::string* TMTBookingInfo::release_startday() {
  clear_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startday_;
    startday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBookingInfo::set_allocated_startday(::std::string* startday) {
  if (startday_ != &::google::protobuf::internal::kEmptyString) {
    delete startday_;
  }
  if (startday) {
    set_has_startday();
    startday_ = startday;
  } else {
    clear_has_startday();
    startday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endday = 3;
inline bool TMTBookingInfo::has_endday() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTBookingInfo::set_has_endday() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTBookingInfo::clear_has_endday() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTBookingInfo::clear_endday() {
  if (endday_ != &::google::protobuf::internal::kEmptyString) {
    endday_->clear();
  }
  clear_has_endday();
}
inline const ::std::string& TMTBookingInfo::endday() const {
  return *endday_;
}
inline void TMTBookingInfo::set_endday(const ::std::string& value) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(value);
}
inline void TMTBookingInfo::set_endday(const char* value) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(value);
}
inline void TMTBookingInfo::set_endday(const char* value, size_t size) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBookingInfo::mutable_endday() {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  return endday_;
}
inline ::std::string* TMTBookingInfo::release_endday() {
  clear_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endday_;
    endday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBookingInfo::set_allocated_endday(::std::string* endday) {
  if (endday_ != &::google::protobuf::internal::kEmptyString) {
    delete endday_;
  }
  if (endday) {
    set_has_endday();
    endday_ = endday;
  } else {
    clear_has_endday();
    endday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 start = 4;
inline bool TMTBookingInfo::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTBookingInfo::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTBookingInfo::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTBookingInfo::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTBookingInfo::start() const {
  return start_;
}
inline void TMTBookingInfo::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 5;
inline bool TMTBookingInfo::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTBookingInfo::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTBookingInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTBookingInfo::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTBookingInfo::count() const {
  return count_;
}
inline void TMTBookingInfo::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 6;
inline bool TMTBookingInfo::has_order() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTBookingInfo::set_has_order() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTBookingInfo::clear_has_order() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTBookingInfo::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTBookingInfo::order() const {
  return order_;
}
inline void TMTBookingInfo::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// -------------------------------------------------------------------

// TMTMeetingListOfPerson

// optional string moid = 1;
inline bool TMTMeetingListOfPerson::has_moid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTMeetingListOfPerson::set_has_moid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTMeetingListOfPerson::clear_has_moid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTMeetingListOfPerson::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTMeetingListOfPerson::moid() const {
  return *moid_;
}
inline void TMTMeetingListOfPerson::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTMeetingListOfPerson::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTMeetingListOfPerson::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMeetingListOfPerson::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTMeetingListOfPerson::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMeetingListOfPerson::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string startday = 2;
inline bool TMTMeetingListOfPerson::has_startday() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTMeetingListOfPerson::set_has_startday() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTMeetingListOfPerson::clear_has_startday() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTMeetingListOfPerson::clear_startday() {
  if (startday_ != &::google::protobuf::internal::kEmptyString) {
    startday_->clear();
  }
  clear_has_startday();
}
inline const ::std::string& TMTMeetingListOfPerson::startday() const {
  return *startday_;
}
inline void TMTMeetingListOfPerson::set_startday(const ::std::string& value) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(value);
}
inline void TMTMeetingListOfPerson::set_startday(const char* value) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(value);
}
inline void TMTMeetingListOfPerson::set_startday(const char* value, size_t size) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMeetingListOfPerson::mutable_startday() {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  return startday_;
}
inline ::std::string* TMTMeetingListOfPerson::release_startday() {
  clear_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startday_;
    startday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMeetingListOfPerson::set_allocated_startday(::std::string* startday) {
  if (startday_ != &::google::protobuf::internal::kEmptyString) {
    delete startday_;
  }
  if (startday) {
    set_has_startday();
    startday_ = startday;
  } else {
    clear_has_startday();
    startday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endday = 3;
inline bool TMTMeetingListOfPerson::has_endday() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTMeetingListOfPerson::set_has_endday() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTMeetingListOfPerson::clear_has_endday() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTMeetingListOfPerson::clear_endday() {
  if (endday_ != &::google::protobuf::internal::kEmptyString) {
    endday_->clear();
  }
  clear_has_endday();
}
inline const ::std::string& TMTMeetingListOfPerson::endday() const {
  return *endday_;
}
inline void TMTMeetingListOfPerson::set_endday(const ::std::string& value) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(value);
}
inline void TMTMeetingListOfPerson::set_endday(const char* value) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(value);
}
inline void TMTMeetingListOfPerson::set_endday(const char* value, size_t size) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMeetingListOfPerson::mutable_endday() {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  return endday_;
}
inline ::std::string* TMTMeetingListOfPerson::release_endday() {
  clear_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endday_;
    endday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMeetingListOfPerson::set_allocated_endday(::std::string* endday) {
  if (endday_ != &::google::protobuf::internal::kEmptyString) {
    delete endday_;
  }
  if (endday) {
    set_has_endday();
    endday_ = endday;
  } else {
    clear_has_endday();
    endday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 start = 4;
inline bool TMTMeetingListOfPerson::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTMeetingListOfPerson::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTMeetingListOfPerson::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTMeetingListOfPerson::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTMeetingListOfPerson::start() const {
  return start_;
}
inline void TMTMeetingListOfPerson::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 5;
inline bool TMTMeetingListOfPerson::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTMeetingListOfPerson::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTMeetingListOfPerson::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTMeetingListOfPerson::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTMeetingListOfPerson::count() const {
  return count_;
}
inline void TMTMeetingListOfPerson::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 6;
inline bool TMTMeetingListOfPerson::has_order() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTMeetingListOfPerson::set_has_order() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTMeetingListOfPerson::clear_has_order() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTMeetingListOfPerson::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTMeetingListOfPerson::order() const {
  return order_;
}
inline void TMTMeetingListOfPerson::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// -------------------------------------------------------------------

// TVMeetingParam

// optional .mt.EmClosedMeeting closedmeeting = 1;
inline bool TVMeetingParam::has_closedmeeting() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVMeetingParam::set_has_closedmeeting() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVMeetingParam::clear_has_closedmeeting() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVMeetingParam::clear_closedmeeting() {
  closedmeeting_ = 0;
  clear_has_closedmeeting();
}
inline ::mt::EmClosedMeeting TVMeetingParam::closedmeeting() const {
  return static_cast< ::mt::EmClosedMeeting >(closedmeeting_);
}
inline void TVMeetingParam::set_closedmeeting(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closedmeeting();
  closedmeeting_ = value;
}

// optional .mt.EmRestDualMode dualmode = 2;
inline bool TVMeetingParam::has_dualmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVMeetingParam::set_has_dualmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVMeetingParam::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVMeetingParam::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TVMeetingParam::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TVMeetingParam::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional string encryptedkey = 3;
inline bool TVMeetingParam::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVMeetingParam::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVMeetingParam::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVMeetingParam::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TVMeetingParam::encryptedkey() const {
  return *encryptedkey_;
}
inline void TVMeetingParam::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TVMeetingParam::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TVMeetingParam::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVMeetingParam::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TVMeetingParam::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVMeetingParam::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmEncryptArithmetic encryptedtype = 4;
inline bool TVMeetingParam::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVMeetingParam::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVMeetingParam::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVMeetingParam::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TVMeetingParam::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TVMeetingParam::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional bool initmute = 5;
inline bool TVMeetingParam::has_initmute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVMeetingParam::set_has_initmute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVMeetingParam::clear_has_initmute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVMeetingParam::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TVMeetingParam::initmute() const {
  return initmute_;
}
inline void TVMeetingParam::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional .mt.EmMtOpenMode meetingsafe = 6;
inline bool TVMeetingParam::has_meetingsafe() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVMeetingParam::set_has_meetingsafe() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVMeetingParam::clear_has_meetingsafe() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVMeetingParam::clear_meetingsafe() {
  meetingsafe_ = 1;
  clear_has_meetingsafe();
}
inline ::mt::EmMtOpenMode TVMeetingParam::meetingsafe() const {
  return static_cast< ::mt::EmMtOpenMode >(meetingsafe_);
}
inline void TVMeetingParam::set_meetingsafe(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_meetingsafe();
  meetingsafe_ = value;
}

// optional .mt.EmRestMeetingSafeType meetingtype = 7;
inline bool TVMeetingParam::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVMeetingParam::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVMeetingParam::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVMeetingParam::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TVMeetingParam::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TVMeetingParam::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional uint32 meetingscale = 8;
inline bool TVMeetingParam::has_meetingscale() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TVMeetingParam::set_has_meetingscale() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TVMeetingParam::clear_has_meetingscale() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TVMeetingParam::clear_meetingscale() {
  meetingscale_ = 0u;
  clear_has_meetingscale();
}
inline ::google::protobuf::uint32 TVMeetingParam::meetingscale() const {
  return meetingscale_;
}
inline void TVMeetingParam::set_meetingscale(::google::protobuf::uint32 value) {
  set_has_meetingscale();
  meetingscale_ = value;
}

// optional uint32 onereforming = 9;
inline bool TVMeetingParam::has_onereforming() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TVMeetingParam::set_has_onereforming() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TVMeetingParam::clear_has_onereforming() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TVMeetingParam::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TVMeetingParam::onereforming() const {
  return onereforming_;
}
inline void TVMeetingParam::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional bool voiceinspireenable = 10;
inline bool TVMeetingParam::has_voiceinspireenable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TVMeetingParam::set_has_voiceinspireenable() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TVMeetingParam::clear_has_voiceinspireenable() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TVMeetingParam::clear_voiceinspireenable() {
  voiceinspireenable_ = false;
  clear_has_voiceinspireenable();
}
inline bool TVMeetingParam::voiceinspireenable() const {
  return voiceinspireenable_;
}
inline void TVMeetingParam::set_voiceinspireenable(bool value) {
  set_has_voiceinspireenable();
  voiceinspireenable_ = value;
}

// optional uint32 voiceinspiretime = 11;
inline bool TVMeetingParam::has_voiceinspiretime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TVMeetingParam::set_has_voiceinspiretime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TVMeetingParam::clear_has_voiceinspiretime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TVMeetingParam::clear_voiceinspiretime() {
  voiceinspiretime_ = 0u;
  clear_has_voiceinspiretime();
}
inline ::google::protobuf::uint32 TVMeetingParam::voiceinspiretime() const {
  return voiceinspiretime_;
}
inline void TVMeetingParam::set_voiceinspiretime(::google::protobuf::uint32 value) {
  set_has_voiceinspiretime();
  voiceinspiretime_ = value;
}

// optional string password = 12;
inline bool TVMeetingParam::has_password() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TVMeetingParam::set_has_password() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TVMeetingParam::clear_has_password() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TVMeetingParam::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TVMeetingParam::password() const {
  return *password_;
}
inline void TVMeetingParam::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TVMeetingParam::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TVMeetingParam::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVMeetingParam::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TVMeetingParam::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVMeetingParam::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool publicmeeting = 13;
inline bool TVMeetingParam::has_publicmeeting() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TVMeetingParam::set_has_publicmeeting() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TVMeetingParam::clear_has_publicmeeting() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TVMeetingParam::clear_publicmeeting() {
  publicmeeting_ = false;
  clear_has_publicmeeting();
}
inline bool TVMeetingParam::publicmeeting() const {
  return publicmeeting_;
}
inline void TVMeetingParam::set_publicmeeting(bool value) {
  set_has_publicmeeting();
  publicmeeting_ = value;
}

// repeated .mt.TMTTemplateAccount viplist = 14;
inline int TVMeetingParam::viplist_size() const {
  return viplist_.size();
}
inline void TVMeetingParam::clear_viplist() {
  viplist_.Clear();
}
inline const ::mt::TMTTemplateAccount& TVMeetingParam::viplist(int index) const {
  return viplist_.Get(index);
}
inline ::mt::TMTTemplateAccount* TVMeetingParam::mutable_viplist(int index) {
  return viplist_.Mutable(index);
}
inline ::mt::TMTTemplateAccount* TVMeetingParam::add_viplist() {
  return viplist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >&
TVMeetingParam::viplist() const {
  return viplist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >*
TVMeetingParam::mutable_viplist() {
  return &viplist_;
}

// optional .mt.TMTTemplateRecord record = 15;
inline bool TVMeetingParam::has_record() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TVMeetingParam::set_has_record() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TVMeetingParam::clear_has_record() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TVMeetingParam::clear_record() {
  if (record_ != NULL) record_->::mt::TMTTemplateRecord::Clear();
  clear_has_record();
}
inline const ::mt::TMTTemplateRecord& TVMeetingParam::record() const {
  return record_ != NULL ? *record_ : *default_instance_->record_;
}
inline ::mt::TMTTemplateRecord* TVMeetingParam::mutable_record() {
  set_has_record();
  if (record_ == NULL) record_ = new ::mt::TMTTemplateRecord;
  return record_;
}
inline ::mt::TMTTemplateRecord* TVMeetingParam::release_record() {
  clear_has_record();
  ::mt::TMTTemplateRecord* temp = record_;
  record_ = NULL;
  return temp;
}
inline void TVMeetingParam::set_allocated_record(::mt::TMTTemplateRecord* record) {
  delete record_;
  record_ = record;
  if (record) {
    set_has_record();
  } else {
    clear_has_record();
  }
}

// optional .mt.TMTTemplateSatellite satellite = 16;
inline bool TVMeetingParam::has_satellite() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TVMeetingParam::set_has_satellite() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TVMeetingParam::clear_has_satellite() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TVMeetingParam::clear_satellite() {
  if (satellite_ != NULL) satellite_->::mt::TMTTemplateSatellite::Clear();
  clear_has_satellite();
}
inline const ::mt::TMTTemplateSatellite& TVMeetingParam::satellite() const {
  return satellite_ != NULL ? *satellite_ : *default_instance_->satellite_;
}
inline ::mt::TMTTemplateSatellite* TVMeetingParam::mutable_satellite() {
  set_has_satellite();
  if (satellite_ == NULL) satellite_ = new ::mt::TMTTemplateSatellite;
  return satellite_;
}
inline ::mt::TMTTemplateSatellite* TVMeetingParam::release_satellite() {
  clear_has_satellite();
  ::mt::TMTTemplateSatellite* temp = satellite_;
  satellite_ = NULL;
  return temp;
}
inline void TVMeetingParam::set_allocated_satellite(::mt::TMTTemplateSatellite* satellite) {
  delete satellite_;
  satellite_ = satellite;
  if (satellite) {
    set_has_satellite();
  } else {
    clear_has_satellite();
  }
}

// optional .mt.TMTTemplateAccount speaker = 17;
inline bool TVMeetingParam::has_speaker() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TVMeetingParam::set_has_speaker() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TVMeetingParam::clear_has_speaker() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TVMeetingParam::clear_speaker() {
  if (speaker_ != NULL) speaker_->::mt::TMTTemplateAccount::Clear();
  clear_has_speaker();
}
inline const ::mt::TMTTemplateAccount& TVMeetingParam::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::mt::TMTTemplateAccount* TVMeetingParam::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::mt::TMTTemplateAccount;
  return speaker_;
}
inline ::mt::TMTTemplateAccount* TVMeetingParam::release_speaker() {
  clear_has_speaker();
  ::mt::TMTTemplateAccount* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void TVMeetingParam::set_allocated_speaker(::mt::TMTTemplateAccount* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional .mt.TMTTemplateAccount admin = 18;
inline bool TVMeetingParam::has_admin() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TVMeetingParam::set_has_admin() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TVMeetingParam::clear_has_admin() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TVMeetingParam::clear_admin() {
  if (admin_ != NULL) admin_->::mt::TMTTemplateAccount::Clear();
  clear_has_admin();
}
inline const ::mt::TMTTemplateAccount& TVMeetingParam::admin() const {
  return admin_ != NULL ? *admin_ : *default_instance_->admin_;
}
inline ::mt::TMTTemplateAccount* TVMeetingParam::mutable_admin() {
  set_has_admin();
  if (admin_ == NULL) admin_ = new ::mt::TMTTemplateAccount;
  return admin_;
}
inline ::mt::TMTTemplateAccount* TVMeetingParam::release_admin() {
  clear_has_admin();
  ::mt::TMTTemplateAccount* temp = admin_;
  admin_ = NULL;
  return temp;
}
inline void TVMeetingParam::set_allocated_admin(::mt::TMTTemplateAccount* admin) {
  delete admin_;
  admin_ = admin;
  if (admin) {
    set_has_admin();
  } else {
    clear_has_admin();
  }
}

// repeated .mt.TMTVideoFormatList videoformatlist = 19;
inline int TVMeetingParam::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TVMeetingParam::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TVMeetingParam::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TVMeetingParam::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TVMeetingParam::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TVMeetingParam::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TVMeetingParam::mutable_videoformatlist() {
  return &videoformatlist_;
}

// repeated .mt.TMTDualFormatList dualformatlist = 20;
inline int TVMeetingParam::dualformatlist_size() const {
  return dualformatlist_.size();
}
inline void TVMeetingParam::clear_dualformatlist() {
  dualformatlist_.Clear();
}
inline const ::mt::TMTDualFormatList& TVMeetingParam::dualformatlist(int index) const {
  return dualformatlist_.Get(index);
}
inline ::mt::TMTDualFormatList* TVMeetingParam::mutable_dualformatlist(int index) {
  return dualformatlist_.Mutable(index);
}
inline ::mt::TMTDualFormatList* TVMeetingParam::add_dualformatlist() {
  return dualformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
TVMeetingParam::dualformatlist() const {
  return dualformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
TVMeetingParam::mutable_dualformatlist() {
  return &dualformatlist_;
}

// repeated .mt.TMTAudioFormatList audioformatlist = 21;
inline int TVMeetingParam::audioformatlist_size() const {
  return audioformatlist_.size();
}
inline void TVMeetingParam::clear_audioformatlist() {
  audioformatlist_.Clear();
}
inline const ::mt::TMTAudioFormatList& TVMeetingParam::audioformatlist(int index) const {
  return audioformatlist_.Get(index);
}
inline ::mt::TMTAudioFormatList* TVMeetingParam::mutable_audioformatlist(int index) {
  return audioformatlist_.Mutable(index);
}
inline ::mt::TMTAudioFormatList* TVMeetingParam::add_audioformatlist() {
  return audioformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
TVMeetingParam::audioformatlist() const {
  return audioformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
TVMeetingParam::mutable_audioformatlist() {
  return &audioformatlist_;
}

// optional .mt.TMTSetMixInfo mixinfo = 22;
inline bool TVMeetingParam::has_mixinfo() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TVMeetingParam::set_has_mixinfo() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TVMeetingParam::clear_has_mixinfo() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TVMeetingParam::clear_mixinfo() {
  if (mixinfo_ != NULL) mixinfo_->::mt::TMTSetMixInfo::Clear();
  clear_has_mixinfo();
}
inline const ::mt::TMTSetMixInfo& TVMeetingParam::mixinfo() const {
  return mixinfo_ != NULL ? *mixinfo_ : *default_instance_->mixinfo_;
}
inline ::mt::TMTSetMixInfo* TVMeetingParam::mutable_mixinfo() {
  set_has_mixinfo();
  if (mixinfo_ == NULL) mixinfo_ = new ::mt::TMTSetMixInfo;
  return mixinfo_;
}
inline ::mt::TMTSetMixInfo* TVMeetingParam::release_mixinfo() {
  clear_has_mixinfo();
  ::mt::TMTSetMixInfo* temp = mixinfo_;
  mixinfo_ = NULL;
  return temp;
}
inline void TVMeetingParam::set_allocated_mixinfo(::mt::TMTSetMixInfo* mixinfo) {
  delete mixinfo_;
  mixinfo_ = mixinfo;
  if (mixinfo) {
    set_has_mixinfo();
  } else {
    clear_has_mixinfo();
  }
}

// optional .mt.TMTTemplateVmp vmp = 23;
inline bool TVMeetingParam::has_vmp() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TVMeetingParam::set_has_vmp() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TVMeetingParam::clear_has_vmp() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TVMeetingParam::clear_vmp() {
  if (vmp_ != NULL) vmp_->::mt::TMTTemplateVmp::Clear();
  clear_has_vmp();
}
inline const ::mt::TMTTemplateVmp& TVMeetingParam::vmp() const {
  return vmp_ != NULL ? *vmp_ : *default_instance_->vmp_;
}
inline ::mt::TMTTemplateVmp* TVMeetingParam::mutable_vmp() {
  set_has_vmp();
  if (vmp_ == NULL) vmp_ = new ::mt::TMTTemplateVmp;
  return vmp_;
}
inline ::mt::TMTTemplateVmp* TVMeetingParam::release_vmp() {
  clear_has_vmp();
  ::mt::TMTTemplateVmp* temp = vmp_;
  vmp_ = NULL;
  return temp;
}
inline void TVMeetingParam::set_allocated_vmp(::mt::TMTTemplateVmp* vmp) {
  delete vmp_;
  vmp_ = vmp;
  if (vmp) {
    set_has_vmp();
  } else {
    clear_has_vmp();
  }
}

// optional .mt.TMTTemplatePoll poll = 24;
inline bool TVMeetingParam::has_poll() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TVMeetingParam::set_has_poll() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TVMeetingParam::clear_has_poll() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TVMeetingParam::clear_poll() {
  if (poll_ != NULL) poll_->::mt::TMTTemplatePoll::Clear();
  clear_has_poll();
}
inline const ::mt::TMTTemplatePoll& TVMeetingParam::poll() const {
  return poll_ != NULL ? *poll_ : *default_instance_->poll_;
}
inline ::mt::TMTTemplatePoll* TVMeetingParam::mutable_poll() {
  set_has_poll();
  if (poll_ == NULL) poll_ = new ::mt::TMTTemplatePoll;
  return poll_;
}
inline ::mt::TMTTemplatePoll* TVMeetingParam::release_poll() {
  clear_has_poll();
  ::mt::TMTTemplatePoll* temp = poll_;
  poll_ = NULL;
  return temp;
}
inline void TVMeetingParam::set_allocated_poll(::mt::TMTTemplatePoll* poll) {
  delete poll_;
  poll_ = poll;
  if (poll) {
    set_has_poll();
  } else {
    clear_has_poll();
  }
}

// -------------------------------------------------------------------

// TMTAddMeeting

// optional string subject = 1;
inline bool TMTAddMeeting::has_subject() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTAddMeeting::set_has_subject() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTAddMeeting::clear_has_subject() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTAddMeeting::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTAddMeeting::subject() const {
  return *subject_;
}
inline void TMTAddMeeting::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTAddMeeting::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTAddMeeting::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddMeeting::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTAddMeeting::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddMeeting::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string day = 2;
inline bool TMTAddMeeting::has_day() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTAddMeeting::set_has_day() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTAddMeeting::clear_has_day() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTAddMeeting::clear_day() {
  if (day_ != &::google::protobuf::internal::kEmptyString) {
    day_->clear();
  }
  clear_has_day();
}
inline const ::std::string& TMTAddMeeting::day() const {
  return *day_;
}
inline void TMTAddMeeting::set_day(const ::std::string& value) {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  day_->assign(value);
}
inline void TMTAddMeeting::set_day(const char* value) {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  day_->assign(value);
}
inline void TMTAddMeeting::set_day(const char* value, size_t size) {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  day_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddMeeting::mutable_day() {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  return day_;
}
inline ::std::string* TMTAddMeeting::release_day() {
  clear_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = day_;
    day_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddMeeting::set_allocated_day(::std::string* day) {
  if (day_ != &::google::protobuf::internal::kEmptyString) {
    delete day_;
  }
  if (day) {
    set_has_day();
    day_ = day;
  } else {
    clear_has_day();
    day_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string startshorttime = 3;
inline bool TMTAddMeeting::has_startshorttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTAddMeeting::set_has_startshorttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTAddMeeting::clear_has_startshorttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTAddMeeting::clear_startshorttime() {
  if (startshorttime_ != &::google::protobuf::internal::kEmptyString) {
    startshorttime_->clear();
  }
  clear_has_startshorttime();
}
inline const ::std::string& TMTAddMeeting::startshorttime() const {
  return *startshorttime_;
}
inline void TMTAddMeeting::set_startshorttime(const ::std::string& value) {
  set_has_startshorttime();
  if (startshorttime_ == &::google::protobuf::internal::kEmptyString) {
    startshorttime_ = new ::std::string;
  }
  startshorttime_->assign(value);
}
inline void TMTAddMeeting::set_startshorttime(const char* value) {
  set_has_startshorttime();
  if (startshorttime_ == &::google::protobuf::internal::kEmptyString) {
    startshorttime_ = new ::std::string;
  }
  startshorttime_->assign(value);
}
inline void TMTAddMeeting::set_startshorttime(const char* value, size_t size) {
  set_has_startshorttime();
  if (startshorttime_ == &::google::protobuf::internal::kEmptyString) {
    startshorttime_ = new ::std::string;
  }
  startshorttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddMeeting::mutable_startshorttime() {
  set_has_startshorttime();
  if (startshorttime_ == &::google::protobuf::internal::kEmptyString) {
    startshorttime_ = new ::std::string;
  }
  return startshorttime_;
}
inline ::std::string* TMTAddMeeting::release_startshorttime() {
  clear_has_startshorttime();
  if (startshorttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startshorttime_;
    startshorttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddMeeting::set_allocated_startshorttime(::std::string* startshorttime) {
  if (startshorttime_ != &::google::protobuf::internal::kEmptyString) {
    delete startshorttime_;
  }
  if (startshorttime) {
    set_has_startshorttime();
    startshorttime_ = startshorttime;
  } else {
    clear_has_startshorttime();
    startshorttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endshorttime = 4;
inline bool TMTAddMeeting::has_endshorttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTAddMeeting::set_has_endshorttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTAddMeeting::clear_has_endshorttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTAddMeeting::clear_endshorttime() {
  if (endshorttime_ != &::google::protobuf::internal::kEmptyString) {
    endshorttime_->clear();
  }
  clear_has_endshorttime();
}
inline const ::std::string& TMTAddMeeting::endshorttime() const {
  return *endshorttime_;
}
inline void TMTAddMeeting::set_endshorttime(const ::std::string& value) {
  set_has_endshorttime();
  if (endshorttime_ == &::google::protobuf::internal::kEmptyString) {
    endshorttime_ = new ::std::string;
  }
  endshorttime_->assign(value);
}
inline void TMTAddMeeting::set_endshorttime(const char* value) {
  set_has_endshorttime();
  if (endshorttime_ == &::google::protobuf::internal::kEmptyString) {
    endshorttime_ = new ::std::string;
  }
  endshorttime_->assign(value);
}
inline void TMTAddMeeting::set_endshorttime(const char* value, size_t size) {
  set_has_endshorttime();
  if (endshorttime_ == &::google::protobuf::internal::kEmptyString) {
    endshorttime_ = new ::std::string;
  }
  endshorttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddMeeting::mutable_endshorttime() {
  set_has_endshorttime();
  if (endshorttime_ == &::google::protobuf::internal::kEmptyString) {
    endshorttime_ = new ::std::string;
  }
  return endshorttime_;
}
inline ::std::string* TMTAddMeeting::release_endshorttime() {
  clear_has_endshorttime();
  if (endshorttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endshorttime_;
    endshorttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddMeeting::set_allocated_endshorttime(::std::string* endshorttime) {
  if (endshorttime_ != &::google::protobuf::internal::kEmptyString) {
    delete endshorttime_;
  }
  if (endshorttime) {
    set_has_endshorttime();
    endshorttime_ = endshorttime;
  } else {
    clear_has_endshorttime();
    endshorttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 rooms = 5;
inline bool TMTAddMeeting::has_rooms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTAddMeeting::set_has_rooms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTAddMeeting::clear_has_rooms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTAddMeeting::clear_rooms() {
  rooms_ = 0u;
  clear_has_rooms();
}
inline ::google::protobuf::uint32 TMTAddMeeting::rooms() const {
  return rooms_;
}
inline void TMTAddMeeting::set_rooms(::google::protobuf::uint32 value) {
  set_has_rooms();
  rooms_ = value;
}

// optional string phone = 6;
inline bool TMTAddMeeting::has_phone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTAddMeeting::set_has_phone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTAddMeeting::clear_has_phone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTAddMeeting::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& TMTAddMeeting::phone() const {
  return *phone_;
}
inline void TMTAddMeeting::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTAddMeeting::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTAddMeeting::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddMeeting::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* TMTAddMeeting::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddMeeting::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobile = 7;
inline bool TMTAddMeeting::has_mobile() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTAddMeeting::set_has_mobile() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTAddMeeting::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTAddMeeting::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& TMTAddMeeting::mobile() const {
  return *mobile_;
}
inline void TMTAddMeeting::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTAddMeeting::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTAddMeeting::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddMeeting::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* TMTAddMeeting::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddMeeting::set_allocated_mobile(::std::string* mobile) {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_;
  }
  if (mobile) {
    set_has_mobile();
    mobile_ = mobile;
  } else {
    clear_has_mobile();
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 participantcnt = 8;
inline bool TMTAddMeeting::has_participantcnt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTAddMeeting::set_has_participantcnt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTAddMeeting::clear_has_participantcnt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTAddMeeting::clear_participantcnt() {
  participantcnt_ = 0u;
  clear_has_participantcnt();
}
inline ::google::protobuf::uint32 TMTAddMeeting::participantcnt() const {
  return participantcnt_;
}
inline void TMTAddMeeting::set_participantcnt(::google::protobuf::uint32 value) {
  set_has_participantcnt();
  participantcnt_ = value;
}

// repeated string participants = 9;
inline int TMTAddMeeting::participants_size() const {
  return participants_.size();
}
inline void TMTAddMeeting::clear_participants() {
  participants_.Clear();
}
inline const ::std::string& TMTAddMeeting::participants(int index) const {
  return participants_.Get(index);
}
inline ::std::string* TMTAddMeeting::mutable_participants(int index) {
  return participants_.Mutable(index);
}
inline void TMTAddMeeting::set_participants(int index, const ::std::string& value) {
  participants_.Mutable(index)->assign(value);
}
inline void TMTAddMeeting::set_participants(int index, const char* value) {
  participants_.Mutable(index)->assign(value);
}
inline void TMTAddMeeting::set_participants(int index, const char* value, size_t size) {
  participants_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddMeeting::add_participants() {
  return participants_.Add();
}
inline void TMTAddMeeting::add_participants(const ::std::string& value) {
  participants_.Add()->assign(value);
}
inline void TMTAddMeeting::add_participants(const char* value) {
  participants_.Add()->assign(value);
}
inline void TMTAddMeeting::add_participants(const char* value, size_t size) {
  participants_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TMTAddMeeting::participants() const {
  return participants_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TMTAddMeeting::mutable_participants() {
  return &participants_;
}

// optional string brief = 10;
inline bool TMTAddMeeting::has_brief() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTAddMeeting::set_has_brief() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTAddMeeting::clear_has_brief() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTAddMeeting::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TMTAddMeeting::brief() const {
  return *brief_;
}
inline void TMTAddMeeting::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTAddMeeting::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTAddMeeting::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddMeeting::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TMTAddMeeting::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddMeeting::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 isvideomeeting = 11;
inline bool TMTAddMeeting::has_isvideomeeting() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTAddMeeting::set_has_isvideomeeting() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTAddMeeting::clear_has_isvideomeeting() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTAddMeeting::clear_isvideomeeting() {
  isvideomeeting_ = 0u;
  clear_has_isvideomeeting();
}
inline ::google::protobuf::uint32 TMTAddMeeting::isvideomeeting() const {
  return isvideomeeting_;
}
inline void TMTAddMeeting::set_isvideomeeting(::google::protobuf::uint32 value) {
  set_has_isvideomeeting();
  isvideomeeting_ = value;
}

// optional uint32 isautocall = 12;
inline bool TMTAddMeeting::has_isautocall() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTAddMeeting::set_has_isautocall() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTAddMeeting::clear_has_isautocall() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTAddMeeting::clear_isautocall() {
  isautocall_ = 0u;
  clear_has_isautocall();
}
inline ::google::protobuf::uint32 TMTAddMeeting::isautocall() const {
  return isautocall_;
}
inline void TMTAddMeeting::set_isautocall(::google::protobuf::uint32 value) {
  set_has_isautocall();
  isautocall_ = value;
}

// optional string templateid = 13;
inline bool TMTAddMeeting::has_templateid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTAddMeeting::set_has_templateid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTAddMeeting::clear_has_templateid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTAddMeeting::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTAddMeeting::templateid() const {
  return *templateid_;
}
inline void TMTAddMeeting::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTAddMeeting::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTAddMeeting::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddMeeting::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTAddMeeting::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddMeeting::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 vroomid = 14;
inline bool TMTAddMeeting::has_vroomid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTAddMeeting::set_has_vroomid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTAddMeeting::clear_has_vroomid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTAddMeeting::clear_vroomid() {
  vroomid_ = 0u;
  clear_has_vroomid();
}
inline ::google::protobuf::uint32 TMTAddMeeting::vroomid() const {
  return vroomid_;
}
inline void TMTAddMeeting::set_vroomid(::google::protobuf::uint32 value) {
  set_has_vroomid();
  vroomid_ = value;
}

// optional uint32 notifytype = 15;
inline bool TMTAddMeeting::has_notifytype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTAddMeeting::set_has_notifytype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTAddMeeting::clear_has_notifytype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTAddMeeting::clear_notifytype() {
  notifytype_ = 0u;
  clear_has_notifytype();
}
inline ::google::protobuf::uint32 TMTAddMeeting::notifytype() const {
  return notifytype_;
}
inline void TMTAddMeeting::set_notifytype(::google::protobuf::uint32 value) {
  set_has_notifytype();
  notifytype_ = value;
}

// optional string meetingformkey = 16;
inline bool TMTAddMeeting::has_meetingformkey() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTAddMeeting::set_has_meetingformkey() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTAddMeeting::clear_has_meetingformkey() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTAddMeeting::clear_meetingformkey() {
  if (meetingformkey_ != &::google::protobuf::internal::kEmptyString) {
    meetingformkey_->clear();
  }
  clear_has_meetingformkey();
}
inline const ::std::string& TMTAddMeeting::meetingformkey() const {
  return *meetingformkey_;
}
inline void TMTAddMeeting::set_meetingformkey(const ::std::string& value) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(value);
}
inline void TMTAddMeeting::set_meetingformkey(const char* value) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(value);
}
inline void TMTAddMeeting::set_meetingformkey(const char* value, size_t size) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddMeeting::mutable_meetingformkey() {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  return meetingformkey_;
}
inline ::std::string* TMTAddMeeting::release_meetingformkey() {
  clear_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetingformkey_;
    meetingformkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddMeeting::set_allocated_meetingformkey(::std::string* meetingformkey) {
  if (meetingformkey_ != &::google::protobuf::internal::kEmptyString) {
    delete meetingformkey_;
  }
  if (meetingformkey) {
    set_has_meetingformkey();
    meetingformkey_ = meetingformkey;
  } else {
    clear_has_meetingformkey();
    meetingformkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool issendsms = 17;
inline bool TMTAddMeeting::has_issendsms() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTAddMeeting::set_has_issendsms() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTAddMeeting::clear_has_issendsms() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTAddMeeting::clear_issendsms() {
  issendsms_ = false;
  clear_has_issendsms();
}
inline bool TMTAddMeeting::issendsms() const {
  return issendsms_;
}
inline void TMTAddMeeting::set_issendsms(bool value) {
  set_has_issendsms();
  issendsms_ = value;
}

// optional .mt.TVMeetingParam vmeetingparam = 18;
inline bool TMTAddMeeting::has_vmeetingparam() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTAddMeeting::set_has_vmeetingparam() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTAddMeeting::clear_has_vmeetingparam() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTAddMeeting::clear_vmeetingparam() {
  if (vmeetingparam_ != NULL) vmeetingparam_->::mt::TVMeetingParam::Clear();
  clear_has_vmeetingparam();
}
inline const ::mt::TVMeetingParam& TMTAddMeeting::vmeetingparam() const {
  return vmeetingparam_ != NULL ? *vmeetingparam_ : *default_instance_->vmeetingparam_;
}
inline ::mt::TVMeetingParam* TMTAddMeeting::mutable_vmeetingparam() {
  set_has_vmeetingparam();
  if (vmeetingparam_ == NULL) vmeetingparam_ = new ::mt::TVMeetingParam;
  return vmeetingparam_;
}
inline ::mt::TVMeetingParam* TMTAddMeeting::release_vmeetingparam() {
  clear_has_vmeetingparam();
  ::mt::TVMeetingParam* temp = vmeetingparam_;
  vmeetingparam_ = NULL;
  return temp;
}
inline void TMTAddMeeting::set_allocated_vmeetingparam(::mt::TVMeetingParam* vmeetingparam) {
  delete vmeetingparam_;
  vmeetingparam_ = vmeetingparam;
  if (vmeetingparam) {
    set_has_vmeetingparam();
  } else {
    clear_has_vmeetingparam();
  }
}

// -------------------------------------------------------------------

// TMTModifyMeeting

// optional uint32 meetingid = 1;
inline bool TMTModifyMeeting::has_meetingid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTModifyMeeting::set_has_meetingid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTModifyMeeting::clear_has_meetingid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTModifyMeeting::clear_meetingid() {
  meetingid_ = 0u;
  clear_has_meetingid();
}
inline ::google::protobuf::uint32 TMTModifyMeeting::meetingid() const {
  return meetingid_;
}
inline void TMTModifyMeeting::set_meetingid(::google::protobuf::uint32 value) {
  set_has_meetingid();
  meetingid_ = value;
}

// optional string subject = 2;
inline bool TMTModifyMeeting::has_subject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTModifyMeeting::set_has_subject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTModifyMeeting::clear_has_subject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTModifyMeeting::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTModifyMeeting::subject() const {
  return *subject_;
}
inline void TMTModifyMeeting::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTModifyMeeting::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTModifyMeeting::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyMeeting::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTModifyMeeting::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyMeeting::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string day = 3;
inline bool TMTModifyMeeting::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTModifyMeeting::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTModifyMeeting::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTModifyMeeting::clear_day() {
  if (day_ != &::google::protobuf::internal::kEmptyString) {
    day_->clear();
  }
  clear_has_day();
}
inline const ::std::string& TMTModifyMeeting::day() const {
  return *day_;
}
inline void TMTModifyMeeting::set_day(const ::std::string& value) {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  day_->assign(value);
}
inline void TMTModifyMeeting::set_day(const char* value) {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  day_->assign(value);
}
inline void TMTModifyMeeting::set_day(const char* value, size_t size) {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  day_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyMeeting::mutable_day() {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  return day_;
}
inline ::std::string* TMTModifyMeeting::release_day() {
  clear_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = day_;
    day_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyMeeting::set_allocated_day(::std::string* day) {
  if (day_ != &::google::protobuf::internal::kEmptyString) {
    delete day_;
  }
  if (day) {
    set_has_day();
    day_ = day;
  } else {
    clear_has_day();
    day_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string startshorttime = 4;
inline bool TMTModifyMeeting::has_startshorttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTModifyMeeting::set_has_startshorttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTModifyMeeting::clear_has_startshorttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTModifyMeeting::clear_startshorttime() {
  if (startshorttime_ != &::google::protobuf::internal::kEmptyString) {
    startshorttime_->clear();
  }
  clear_has_startshorttime();
}
inline const ::std::string& TMTModifyMeeting::startshorttime() const {
  return *startshorttime_;
}
inline void TMTModifyMeeting::set_startshorttime(const ::std::string& value) {
  set_has_startshorttime();
  if (startshorttime_ == &::google::protobuf::internal::kEmptyString) {
    startshorttime_ = new ::std::string;
  }
  startshorttime_->assign(value);
}
inline void TMTModifyMeeting::set_startshorttime(const char* value) {
  set_has_startshorttime();
  if (startshorttime_ == &::google::protobuf::internal::kEmptyString) {
    startshorttime_ = new ::std::string;
  }
  startshorttime_->assign(value);
}
inline void TMTModifyMeeting::set_startshorttime(const char* value, size_t size) {
  set_has_startshorttime();
  if (startshorttime_ == &::google::protobuf::internal::kEmptyString) {
    startshorttime_ = new ::std::string;
  }
  startshorttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyMeeting::mutable_startshorttime() {
  set_has_startshorttime();
  if (startshorttime_ == &::google::protobuf::internal::kEmptyString) {
    startshorttime_ = new ::std::string;
  }
  return startshorttime_;
}
inline ::std::string* TMTModifyMeeting::release_startshorttime() {
  clear_has_startshorttime();
  if (startshorttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startshorttime_;
    startshorttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyMeeting::set_allocated_startshorttime(::std::string* startshorttime) {
  if (startshorttime_ != &::google::protobuf::internal::kEmptyString) {
    delete startshorttime_;
  }
  if (startshorttime) {
    set_has_startshorttime();
    startshorttime_ = startshorttime;
  } else {
    clear_has_startshorttime();
    startshorttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endshorttime = 5;
inline bool TMTModifyMeeting::has_endshorttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTModifyMeeting::set_has_endshorttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTModifyMeeting::clear_has_endshorttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTModifyMeeting::clear_endshorttime() {
  if (endshorttime_ != &::google::protobuf::internal::kEmptyString) {
    endshorttime_->clear();
  }
  clear_has_endshorttime();
}
inline const ::std::string& TMTModifyMeeting::endshorttime() const {
  return *endshorttime_;
}
inline void TMTModifyMeeting::set_endshorttime(const ::std::string& value) {
  set_has_endshorttime();
  if (endshorttime_ == &::google::protobuf::internal::kEmptyString) {
    endshorttime_ = new ::std::string;
  }
  endshorttime_->assign(value);
}
inline void TMTModifyMeeting::set_endshorttime(const char* value) {
  set_has_endshorttime();
  if (endshorttime_ == &::google::protobuf::internal::kEmptyString) {
    endshorttime_ = new ::std::string;
  }
  endshorttime_->assign(value);
}
inline void TMTModifyMeeting::set_endshorttime(const char* value, size_t size) {
  set_has_endshorttime();
  if (endshorttime_ == &::google::protobuf::internal::kEmptyString) {
    endshorttime_ = new ::std::string;
  }
  endshorttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyMeeting::mutable_endshorttime() {
  set_has_endshorttime();
  if (endshorttime_ == &::google::protobuf::internal::kEmptyString) {
    endshorttime_ = new ::std::string;
  }
  return endshorttime_;
}
inline ::std::string* TMTModifyMeeting::release_endshorttime() {
  clear_has_endshorttime();
  if (endshorttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endshorttime_;
    endshorttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyMeeting::set_allocated_endshorttime(::std::string* endshorttime) {
  if (endshorttime_ != &::google::protobuf::internal::kEmptyString) {
    delete endshorttime_;
  }
  if (endshorttime) {
    set_has_endshorttime();
    endshorttime_ = endshorttime;
  } else {
    clear_has_endshorttime();
    endshorttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 rooms = 6;
inline bool TMTModifyMeeting::has_rooms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTModifyMeeting::set_has_rooms() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTModifyMeeting::clear_has_rooms() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTModifyMeeting::clear_rooms() {
  rooms_ = 0u;
  clear_has_rooms();
}
inline ::google::protobuf::uint32 TMTModifyMeeting::rooms() const {
  return rooms_;
}
inline void TMTModifyMeeting::set_rooms(::google::protobuf::uint32 value) {
  set_has_rooms();
  rooms_ = value;
}

// optional string phone = 7;
inline bool TMTModifyMeeting::has_phone() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTModifyMeeting::set_has_phone() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTModifyMeeting::clear_has_phone() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTModifyMeeting::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& TMTModifyMeeting::phone() const {
  return *phone_;
}
inline void TMTModifyMeeting::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTModifyMeeting::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTModifyMeeting::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyMeeting::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* TMTModifyMeeting::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyMeeting::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobile = 8;
inline bool TMTModifyMeeting::has_mobile() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTModifyMeeting::set_has_mobile() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTModifyMeeting::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTModifyMeeting::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& TMTModifyMeeting::mobile() const {
  return *mobile_;
}
inline void TMTModifyMeeting::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTModifyMeeting::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTModifyMeeting::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyMeeting::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* TMTModifyMeeting::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyMeeting::set_allocated_mobile(::std::string* mobile) {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_;
  }
  if (mobile) {
    set_has_mobile();
    mobile_ = mobile;
  } else {
    clear_has_mobile();
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brief = 9;
inline bool TMTModifyMeeting::has_brief() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTModifyMeeting::set_has_brief() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTModifyMeeting::clear_has_brief() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTModifyMeeting::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TMTModifyMeeting::brief() const {
  return *brief_;
}
inline void TMTModifyMeeting::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTModifyMeeting::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTModifyMeeting::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyMeeting::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TMTModifyMeeting::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyMeeting::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 isvideomeeting = 10;
inline bool TMTModifyMeeting::has_isvideomeeting() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTModifyMeeting::set_has_isvideomeeting() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTModifyMeeting::clear_has_isvideomeeting() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTModifyMeeting::clear_isvideomeeting() {
  isvideomeeting_ = 0u;
  clear_has_isvideomeeting();
}
inline ::google::protobuf::uint32 TMTModifyMeeting::isvideomeeting() const {
  return isvideomeeting_;
}
inline void TMTModifyMeeting::set_isvideomeeting(::google::protobuf::uint32 value) {
  set_has_isvideomeeting();
  isvideomeeting_ = value;
}

// optional uint32 isautocall = 11;
inline bool TMTModifyMeeting::has_isautocall() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTModifyMeeting::set_has_isautocall() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTModifyMeeting::clear_has_isautocall() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTModifyMeeting::clear_isautocall() {
  isautocall_ = 0u;
  clear_has_isautocall();
}
inline ::google::protobuf::uint32 TMTModifyMeeting::isautocall() const {
  return isautocall_;
}
inline void TMTModifyMeeting::set_isautocall(::google::protobuf::uint32 value) {
  set_has_isautocall();
  isautocall_ = value;
}

// optional string templateid = 12;
inline bool TMTModifyMeeting::has_templateid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTModifyMeeting::set_has_templateid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTModifyMeeting::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTModifyMeeting::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTModifyMeeting::templateid() const {
  return *templateid_;
}
inline void TMTModifyMeeting::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTModifyMeeting::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTModifyMeeting::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyMeeting::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTModifyMeeting::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyMeeting::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 vroomId = 13;
inline bool TMTModifyMeeting::has_vroomid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTModifyMeeting::set_has_vroomid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTModifyMeeting::clear_has_vroomid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTModifyMeeting::clear_vroomid() {
  vroomid_ = 0u;
  clear_has_vroomid();
}
inline ::google::protobuf::uint32 TMTModifyMeeting::vroomid() const {
  return vroomid_;
}
inline void TMTModifyMeeting::set_vroomid(::google::protobuf::uint32 value) {
  set_has_vroomid();
  vroomid_ = value;
}

// optional uint32 notifytype = 14;
inline bool TMTModifyMeeting::has_notifytype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTModifyMeeting::set_has_notifytype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTModifyMeeting::clear_has_notifytype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTModifyMeeting::clear_notifytype() {
  notifytype_ = 0u;
  clear_has_notifytype();
}
inline ::google::protobuf::uint32 TMTModifyMeeting::notifytype() const {
  return notifytype_;
}
inline void TMTModifyMeeting::set_notifytype(::google::protobuf::uint32 value) {
  set_has_notifytype();
  notifytype_ = value;
}

// optional string meetingformkey = 15;
inline bool TMTModifyMeeting::has_meetingformkey() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTModifyMeeting::set_has_meetingformkey() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTModifyMeeting::clear_has_meetingformkey() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTModifyMeeting::clear_meetingformkey() {
  if (meetingformkey_ != &::google::protobuf::internal::kEmptyString) {
    meetingformkey_->clear();
  }
  clear_has_meetingformkey();
}
inline const ::std::string& TMTModifyMeeting::meetingformkey() const {
  return *meetingformkey_;
}
inline void TMTModifyMeeting::set_meetingformkey(const ::std::string& value) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(value);
}
inline void TMTModifyMeeting::set_meetingformkey(const char* value) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(value);
}
inline void TMTModifyMeeting::set_meetingformkey(const char* value, size_t size) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyMeeting::mutable_meetingformkey() {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  return meetingformkey_;
}
inline ::std::string* TMTModifyMeeting::release_meetingformkey() {
  clear_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetingformkey_;
    meetingformkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyMeeting::set_allocated_meetingformkey(::std::string* meetingformkey) {
  if (meetingformkey_ != &::google::protobuf::internal::kEmptyString) {
    delete meetingformkey_;
  }
  if (meetingformkey) {
    set_has_meetingformkey();
    meetingformkey_ = meetingformkey;
  } else {
    clear_has_meetingformkey();
    meetingformkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isSendsms = 16;
inline bool TMTModifyMeeting::has_issendsms() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTModifyMeeting::set_has_issendsms() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTModifyMeeting::clear_has_issendsms() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTModifyMeeting::clear_issendsms() {
  issendsms_ = false;
  clear_has_issendsms();
}
inline bool TMTModifyMeeting::issendsms() const {
  return issendsms_;
}
inline void TMTModifyMeeting::set_issendsms(bool value) {
  set_has_issendsms();
  issendsms_ = value;
}

// optional .mt.TVMeetingParam vMeetingParam = 17;
inline bool TMTModifyMeeting::has_vmeetingparam() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTModifyMeeting::set_has_vmeetingparam() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTModifyMeeting::clear_has_vmeetingparam() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTModifyMeeting::clear_vmeetingparam() {
  if (vmeetingparam_ != NULL) vmeetingparam_->::mt::TVMeetingParam::Clear();
  clear_has_vmeetingparam();
}
inline const ::mt::TVMeetingParam& TMTModifyMeeting::vmeetingparam() const {
  return vmeetingparam_ != NULL ? *vmeetingparam_ : *default_instance_->vmeetingparam_;
}
inline ::mt::TVMeetingParam* TMTModifyMeeting::mutable_vmeetingparam() {
  set_has_vmeetingparam();
  if (vmeetingparam_ == NULL) vmeetingparam_ = new ::mt::TVMeetingParam;
  return vmeetingparam_;
}
inline ::mt::TVMeetingParam* TMTModifyMeeting::release_vmeetingparam() {
  clear_has_vmeetingparam();
  ::mt::TVMeetingParam* temp = vmeetingparam_;
  vmeetingparam_ = NULL;
  return temp;
}
inline void TMTModifyMeeting::set_allocated_vmeetingparam(::mt::TVMeetingParam* vmeetingparam) {
  delete vmeetingparam_;
  vmeetingparam_ = vmeetingparam;
  if (vmeetingparam) {
    set_has_vmeetingparam();
  } else {
    clear_has_vmeetingparam();
  }
}

// -------------------------------------------------------------------

// TMTModifyMeetingParticipants

// repeated string participants = 1;
inline int TMTModifyMeetingParticipants::participants_size() const {
  return participants_.size();
}
inline void TMTModifyMeetingParticipants::clear_participants() {
  participants_.Clear();
}
inline const ::std::string& TMTModifyMeetingParticipants::participants(int index) const {
  return participants_.Get(index);
}
inline ::std::string* TMTModifyMeetingParticipants::mutable_participants(int index) {
  return participants_.Mutable(index);
}
inline void TMTModifyMeetingParticipants::set_participants(int index, const ::std::string& value) {
  participants_.Mutable(index)->assign(value);
}
inline void TMTModifyMeetingParticipants::set_participants(int index, const char* value) {
  participants_.Mutable(index)->assign(value);
}
inline void TMTModifyMeetingParticipants::set_participants(int index, const char* value, size_t size) {
  participants_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyMeetingParticipants::add_participants() {
  return participants_.Add();
}
inline void TMTModifyMeetingParticipants::add_participants(const ::std::string& value) {
  participants_.Add()->assign(value);
}
inline void TMTModifyMeetingParticipants::add_participants(const char* value) {
  participants_.Add()->assign(value);
}
inline void TMTModifyMeetingParticipants::add_participants(const char* value, size_t size) {
  participants_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TMTModifyMeetingParticipants::participants() const {
  return participants_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TMTModifyMeetingParticipants::mutable_participants() {
  return &participants_;
}

// -------------------------------------------------------------------

// TMTMeetingFeed

// optional uint32 meetingid = 1;
inline bool TMTMeetingFeed::has_meetingid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTMeetingFeed::set_has_meetingid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTMeetingFeed::clear_has_meetingid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTMeetingFeed::clear_meetingid() {
  meetingid_ = 0u;
  clear_has_meetingid();
}
inline ::google::protobuf::uint32 TMTMeetingFeed::meetingid() const {
  return meetingid_;
}
inline void TMTMeetingFeed::set_meetingid(::google::protobuf::uint32 value) {
  set_has_meetingid();
  meetingid_ = value;
}

// optional uint32 accept = 2;
inline bool TMTMeetingFeed::has_accept() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTMeetingFeed::set_has_accept() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTMeetingFeed::clear_has_accept() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTMeetingFeed::clear_accept() {
  accept_ = 0u;
  clear_has_accept();
}
inline ::google::protobuf::uint32 TMTMeetingFeed::accept() const {
  return accept_;
}
inline void TMTMeetingFeed::set_accept(::google::protobuf::uint32 value) {
  set_has_accept();
  accept_ = value;
}

// optional uint32 jointype = 3;
inline bool TMTMeetingFeed::has_jointype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTMeetingFeed::set_has_jointype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTMeetingFeed::clear_has_jointype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTMeetingFeed::clear_jointype() {
  jointype_ = 0u;
  clear_has_jointype();
}
inline ::google::protobuf::uint32 TMTMeetingFeed::jointype() const {
  return jointype_;
}
inline void TMTMeetingFeed::set_jointype(::google::protobuf::uint32 value) {
  set_has_jointype();
  jointype_ = value;
}

// optional string participateno = 4;
inline bool TMTMeetingFeed::has_participateno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTMeetingFeed::set_has_participateno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTMeetingFeed::clear_has_participateno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTMeetingFeed::clear_participateno() {
  if (participateno_ != &::google::protobuf::internal::kEmptyString) {
    participateno_->clear();
  }
  clear_has_participateno();
}
inline const ::std::string& TMTMeetingFeed::participateno() const {
  return *participateno_;
}
inline void TMTMeetingFeed::set_participateno(const ::std::string& value) {
  set_has_participateno();
  if (participateno_ == &::google::protobuf::internal::kEmptyString) {
    participateno_ = new ::std::string;
  }
  participateno_->assign(value);
}
inline void TMTMeetingFeed::set_participateno(const char* value) {
  set_has_participateno();
  if (participateno_ == &::google::protobuf::internal::kEmptyString) {
    participateno_ = new ::std::string;
  }
  participateno_->assign(value);
}
inline void TMTMeetingFeed::set_participateno(const char* value, size_t size) {
  set_has_participateno();
  if (participateno_ == &::google::protobuf::internal::kEmptyString) {
    participateno_ = new ::std::string;
  }
  participateno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMeetingFeed::mutable_participateno() {
  set_has_participateno();
  if (participateno_ == &::google::protobuf::internal::kEmptyString) {
    participateno_ = new ::std::string;
  }
  return participateno_;
}
inline ::std::string* TMTMeetingFeed::release_participateno() {
  clear_has_participateno();
  if (participateno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = participateno_;
    participateno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMeetingFeed::set_allocated_participateno(::std::string* participateno) {
  if (participateno_ != &::google::protobuf::internal::kEmptyString) {
    delete participateno_;
  }
  if (participateno) {
    set_has_participateno();
    participateno_ = participateno;
  } else {
    clear_has_participateno();
    participateno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 reasonid = 5;
inline bool TMTMeetingFeed::has_reasonid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTMeetingFeed::set_has_reasonid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTMeetingFeed::clear_has_reasonid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTMeetingFeed::clear_reasonid() {
  reasonid_ = 0u;
  clear_has_reasonid();
}
inline ::google::protobuf::uint32 TMTMeetingFeed::reasonid() const {
  return reasonid_;
}
inline void TMTMeetingFeed::set_reasonid(::google::protobuf::uint32 value) {
  set_has_reasonid();
  reasonid_ = value;
}

// -------------------------------------------------------------------

// TMTQueryFreeRooms

// optional string starttime = 1;
inline bool TMTQueryFreeRooms::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTQueryFreeRooms::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTQueryFreeRooms::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTQueryFreeRooms::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTQueryFreeRooms::starttime() const {
  return *starttime_;
}
inline void TMTQueryFreeRooms::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTQueryFreeRooms::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTQueryFreeRooms::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTQueryFreeRooms::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTQueryFreeRooms::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTQueryFreeRooms::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 rooms = 2;
inline int TMTQueryFreeRooms::rooms_size() const {
  return rooms_.size();
}
inline void TMTQueryFreeRooms::clear_rooms() {
  rooms_.Clear();
}
inline ::google::protobuf::uint32 TMTQueryFreeRooms::rooms(int index) const {
  return rooms_.Get(index);
}
inline void TMTQueryFreeRooms::set_rooms(int index, ::google::protobuf::uint32 value) {
  rooms_.Set(index, value);
}
inline void TMTQueryFreeRooms::add_rooms(::google::protobuf::uint32 value) {
  rooms_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TMTQueryFreeRooms::rooms() const {
  return rooms_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TMTQueryFreeRooms::mutable_rooms() {
  return &rooms_;
}

// optional string endtime = 3;
inline bool TMTQueryFreeRooms::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTQueryFreeRooms::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTQueryFreeRooms::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTQueryFreeRooms::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTQueryFreeRooms::endtime() const {
  return *endtime_;
}
inline void TMTQueryFreeRooms::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTQueryFreeRooms::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTQueryFreeRooms::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTQueryFreeRooms::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTQueryFreeRooms::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTQueryFreeRooms::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 start = 4;
inline bool TMTQueryFreeRooms::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTQueryFreeRooms::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTQueryFreeRooms::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTQueryFreeRooms::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTQueryFreeRooms::start() const {
  return start_;
}
inline void TMTQueryFreeRooms::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 5;
inline bool TMTQueryFreeRooms::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTQueryFreeRooms::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTQueryFreeRooms::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTQueryFreeRooms::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTQueryFreeRooms::count() const {
  return count_;
}
inline void TMTQueryFreeRooms::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 6;
inline bool TMTQueryFreeRooms::has_order() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTQueryFreeRooms::set_has_order() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTQueryFreeRooms::clear_has_order() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTQueryFreeRooms::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTQueryFreeRooms::order() const {
  return order_;
}
inline void TMTQueryFreeRooms::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// optional uint32 peopleadmint = 7;
inline bool TMTQueryFreeRooms::has_peopleadmint() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTQueryFreeRooms::set_has_peopleadmint() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTQueryFreeRooms::clear_has_peopleadmint() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTQueryFreeRooms::clear_peopleadmint() {
  peopleadmint_ = 0u;
  clear_has_peopleadmint();
}
inline ::google::protobuf::uint32 TMTQueryFreeRooms::peopleadmint() const {
  return peopleadmint_;
}
inline void TMTQueryFreeRooms::set_peopleadmint(::google::protobuf::uint32 value) {
  set_has_peopleadmint();
  peopleadmint_ = value;
}

// optional uint32 deviceidmask = 8;
inline bool TMTQueryFreeRooms::has_deviceidmask() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTQueryFreeRooms::set_has_deviceidmask() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTQueryFreeRooms::clear_has_deviceidmask() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTQueryFreeRooms::clear_deviceidmask() {
  deviceidmask_ = 0u;
  clear_has_deviceidmask();
}
inline ::google::protobuf::uint32 TMTQueryFreeRooms::deviceidmask() const {
  return deviceidmask_;
}
inline void TMTQueryFreeRooms::set_deviceidmask(::google::protobuf::uint32 value) {
  set_has_deviceidmask();
  deviceidmask_ = value;
}

// repeated uint32 regionids = 9;
inline int TMTQueryFreeRooms::regionids_size() const {
  return regionids_.size();
}
inline void TMTQueryFreeRooms::clear_regionids() {
  regionids_.Clear();
}
inline ::google::protobuf::uint32 TMTQueryFreeRooms::regionids(int index) const {
  return regionids_.Get(index);
}
inline void TMTQueryFreeRooms::set_regionids(int index, ::google::protobuf::uint32 value) {
  regionids_.Set(index, value);
}
inline void TMTQueryFreeRooms::add_regionids(::google::protobuf::uint32 value) {
  regionids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TMTQueryFreeRooms::regionids() const {
  return regionids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TMTQueryFreeRooms::mutable_regionids() {
  return &regionids_;
}

// -------------------------------------------------------------------

// TMTRecommendedVirtualRoom

// optional string starttime = 1;
inline bool TMTRecommendedVirtualRoom::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRecommendedVirtualRoom::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRecommendedVirtualRoom::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRecommendedVirtualRoom::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTRecommendedVirtualRoom::starttime() const {
  return *starttime_;
}
inline void TMTRecommendedVirtualRoom::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTRecommendedVirtualRoom::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTRecommendedVirtualRoom::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRecommendedVirtualRoom::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTRecommendedVirtualRoom::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRecommendedVirtualRoom::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 2;
inline bool TMTRecommendedVirtualRoom::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRecommendedVirtualRoom::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRecommendedVirtualRoom::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRecommendedVirtualRoom::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTRecommendedVirtualRoom::endtime() const {
  return *endtime_;
}
inline void TMTRecommendedVirtualRoom::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTRecommendedVirtualRoom::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTRecommendedVirtualRoom::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRecommendedVirtualRoom::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTRecommendedVirtualRoom::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRecommendedVirtualRoom::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTNormalRooms

// optional uint32 start = 1;
inline bool TMTNormalRooms::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTNormalRooms::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTNormalRooms::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTNormalRooms::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTNormalRooms::start() const {
  return start_;
}
inline void TMTNormalRooms::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 2;
inline bool TMTNormalRooms::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTNormalRooms::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTNormalRooms::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTNormalRooms::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTNormalRooms::count() const {
  return count_;
}
inline void TMTNormalRooms::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 3;
inline bool TMTNormalRooms::has_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTNormalRooms::set_has_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTNormalRooms::clear_has_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTNormalRooms::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTNormalRooms::order() const {
  return order_;
}
inline void TMTNormalRooms::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// -------------------------------------------------------------------

// TMTRoomListByName

// optional uint32 start = 1;
inline bool TMTRoomListByName::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRoomListByName::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRoomListByName::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRoomListByName::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTRoomListByName::start() const {
  return start_;
}
inline void TMTRoomListByName::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 2;
inline bool TMTRoomListByName::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRoomListByName::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRoomListByName::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRoomListByName::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTRoomListByName::count() const {
  return count_;
}
inline void TMTRoomListByName::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 3;
inline bool TMTRoomListByName::has_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRoomListByName::set_has_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRoomListByName::clear_has_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRoomListByName::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTRoomListByName::order() const {
  return order_;
}
inline void TMTRoomListByName::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// optional string name = 4;
inline bool TMTRoomListByName::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTRoomListByName::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTRoomListByName::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTRoomListByName::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTRoomListByName::name() const {
  return *name_;
}
inline void TMTRoomListByName::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRoomListByName::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRoomListByName::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomListByName::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTRoomListByName::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomListByName::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTQueryRooms

// optional uint32 start = 1;
inline bool TMTQueryRooms::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTQueryRooms::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTQueryRooms::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTQueryRooms::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTQueryRooms::start() const {
  return start_;
}
inline void TMTQueryRooms::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 2;
inline bool TMTQueryRooms::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTQueryRooms::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTQueryRooms::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTQueryRooms::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTQueryRooms::count() const {
  return count_;
}
inline void TMTQueryRooms::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 3;
inline bool TMTQueryRooms::has_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTQueryRooms::set_has_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTQueryRooms::clear_has_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTQueryRooms::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTQueryRooms::order() const {
  return order_;
}
inline void TMTQueryRooms::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// optional uint32 peopleadmit = 4;
inline bool TMTQueryRooms::has_peopleadmit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTQueryRooms::set_has_peopleadmit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTQueryRooms::clear_has_peopleadmit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTQueryRooms::clear_peopleadmit() {
  peopleadmit_ = 0u;
  clear_has_peopleadmit();
}
inline ::google::protobuf::uint32 TMTQueryRooms::peopleadmit() const {
  return peopleadmit_;
}
inline void TMTQueryRooms::set_peopleadmit(::google::protobuf::uint32 value) {
  set_has_peopleadmit();
  peopleadmit_ = value;
}

// optional uint32 deviceidmask = 5;
inline bool TMTQueryRooms::has_deviceidmask() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTQueryRooms::set_has_deviceidmask() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTQueryRooms::clear_has_deviceidmask() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTQueryRooms::clear_deviceidmask() {
  deviceidmask_ = 0u;
  clear_has_deviceidmask();
}
inline ::google::protobuf::uint32 TMTQueryRooms::deviceidmask() const {
  return deviceidmask_;
}
inline void TMTQueryRooms::set_deviceidmask(::google::protobuf::uint32 value) {
  set_has_deviceidmask();
  deviceidmask_ = value;
}

// -------------------------------------------------------------------

// TMTCreateMeetingNotify

// optional uint32 id = 1;
inline bool TMTCreateMeetingNotify::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCreateMeetingNotify::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCreateMeetingNotify::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCreateMeetingNotify::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTCreateMeetingNotify::id() const {
  return id_;
}
inline void TMTCreateMeetingNotify::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 notifymask = 2;
inline bool TMTCreateMeetingNotify::has_notifymask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCreateMeetingNotify::set_has_notifymask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCreateMeetingNotify::clear_has_notifymask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCreateMeetingNotify::clear_notifymask() {
  notifymask_ = 0u;
  clear_has_notifymask();
}
inline ::google::protobuf::uint32 TMTCreateMeetingNotify::notifymask() const {
  return notifymask_;
}
inline void TMTCreateMeetingNotify::set_notifymask(::google::protobuf::uint32 value) {
  set_has_notifymask();
  notifymask_ = value;
}

// optional uint32 titletype = 3;
inline bool TMTCreateMeetingNotify::has_titletype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTCreateMeetingNotify::set_has_titletype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTCreateMeetingNotify::clear_has_titletype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTCreateMeetingNotify::clear_titletype() {
  titletype_ = 0u;
  clear_has_titletype();
}
inline ::google::protobuf::uint32 TMTCreateMeetingNotify::titletype() const {
  return titletype_;
}
inline void TMTCreateMeetingNotify::set_titletype(::google::protobuf::uint32 value) {
  set_has_titletype();
  titletype_ = value;
}

// -------------------------------------------------------------------

// TMTLockRoom

// optional uint32 roomid = 1;
inline bool TMTLockRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTLockRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTLockRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTLockRoom::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 TMTLockRoom::roomid() const {
  return roomid_;
}
inline void TMTLockRoom::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional string starttime = 2;
inline bool TMTLockRoom::has_starttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTLockRoom::set_has_starttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTLockRoom::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTLockRoom::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTLockRoom::starttime() const {
  return *starttime_;
}
inline void TMTLockRoom::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTLockRoom::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTLockRoom::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTLockRoom::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTLockRoom::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTLockRoom::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 3;
inline bool TMTLockRoom::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTLockRoom::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTLockRoom::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTLockRoom::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTLockRoom::endtime() const {
  return *endtime_;
}
inline void TMTLockRoom::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTLockRoom::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTLockRoom::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTLockRoom::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTLockRoom::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTLockRoom::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTLockRooms

// repeated uint32 roomids = 1;
inline int TMTLockRooms::roomids_size() const {
  return roomids_.size();
}
inline void TMTLockRooms::clear_roomids() {
  roomids_.Clear();
}
inline ::google::protobuf::uint32 TMTLockRooms::roomids(int index) const {
  return roomids_.Get(index);
}
inline void TMTLockRooms::set_roomids(int index, ::google::protobuf::uint32 value) {
  roomids_.Set(index, value);
}
inline void TMTLockRooms::add_roomids(::google::protobuf::uint32 value) {
  roomids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TMTLockRooms::roomids() const {
  return roomids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TMTLockRooms::mutable_roomids() {
  return &roomids_;
}

// optional uint32 roomidscnt = 2;
inline bool TMTLockRooms::has_roomidscnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTLockRooms::set_has_roomidscnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTLockRooms::clear_has_roomidscnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTLockRooms::clear_roomidscnt() {
  roomidscnt_ = 0u;
  clear_has_roomidscnt();
}
inline ::google::protobuf::uint32 TMTLockRooms::roomidscnt() const {
  return roomidscnt_;
}
inline void TMTLockRooms::set_roomidscnt(::google::protobuf::uint32 value) {
  set_has_roomidscnt();
  roomidscnt_ = value;
}

// optional string starttime = 3;
inline bool TMTLockRooms::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTLockRooms::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTLockRooms::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTLockRooms::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTLockRooms::starttime() const {
  return *starttime_;
}
inline void TMTLockRooms::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTLockRooms::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTLockRooms::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTLockRooms::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTLockRooms::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTLockRooms::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 4;
inline bool TMTLockRooms::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTLockRooms::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTLockRooms::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTLockRooms::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTLockRooms::endtime() const {
  return *endtime_;
}
inline void TMTLockRooms::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTLockRooms::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTLockRooms::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTLockRooms::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTLockRooms::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTLockRooms::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTShortRoom

// optional uint32 id = 1;
inline bool TMTShortRoom::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTShortRoom::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTShortRoom::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTShortRoom::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTShortRoom::id() const {
  return id_;
}
inline void TMTShortRoom::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool TMTShortRoom::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTShortRoom::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTShortRoom::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTShortRoom::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTShortRoom::name() const {
  return *name_;
}
inline void TMTShortRoom::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTShortRoom::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTShortRoom::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTShortRoom::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTShortRoom::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTShortRoom::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string regionname = 3;
inline bool TMTShortRoom::has_regionname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTShortRoom::set_has_regionname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTShortRoom::clear_has_regionname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTShortRoom::clear_regionname() {
  if (regionname_ != &::google::protobuf::internal::kEmptyString) {
    regionname_->clear();
  }
  clear_has_regionname();
}
inline const ::std::string& TMTShortRoom::regionname() const {
  return *regionname_;
}
inline void TMTShortRoom::set_regionname(const ::std::string& value) {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  regionname_->assign(value);
}
inline void TMTShortRoom::set_regionname(const char* value) {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  regionname_->assign(value);
}
inline void TMTShortRoom::set_regionname(const char* value, size_t size) {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  regionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTShortRoom::mutable_regionname() {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  return regionname_;
}
inline ::std::string* TMTShortRoom::release_regionname() {
  clear_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = regionname_;
    regionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTShortRoom::set_allocated_regionname(::std::string* regionname) {
  if (regionname_ != &::google::protobuf::internal::kEmptyString) {
    delete regionname_;
  }
  if (regionname) {
    set_has_regionname();
    regionname_ = regionname;
  } else {
    clear_has_regionname();
    regionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTRoomIDs

// optional uint32 count = 1;
inline bool TMTRoomIDs::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRoomIDs::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRoomIDs::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRoomIDs::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTRoomIDs::count() const {
  return count_;
}
inline void TMTRoomIDs::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated uint32 items = 2;
inline int TMTRoomIDs::items_size() const {
  return items_.size();
}
inline void TMTRoomIDs::clear_items() {
  items_.Clear();
}
inline ::google::protobuf::uint32 TMTRoomIDs::items(int index) const {
  return items_.Get(index);
}
inline void TMTRoomIDs::set_items(int index, ::google::protobuf::uint32 value) {
  items_.Set(index, value);
}
inline void TMTRoomIDs::add_items(::google::protobuf::uint32 value) {
  items_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TMTRoomIDs::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TMTRoomIDs::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// TMTShortMeeting

// optional uint32 id = 1;
inline bool TMTShortMeeting::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTShortMeeting::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTShortMeeting::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTShortMeeting::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTShortMeeting::id() const {
  return id_;
}
inline void TMTShortMeeting::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string subject = 2;
inline bool TMTShortMeeting::has_subject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTShortMeeting::set_has_subject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTShortMeeting::clear_has_subject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTShortMeeting::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTShortMeeting::subject() const {
  return *subject_;
}
inline void TMTShortMeeting::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTShortMeeting::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTShortMeeting::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTShortMeeting::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTShortMeeting::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTShortMeeting::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string starttime = 3;
inline bool TMTShortMeeting::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTShortMeeting::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTShortMeeting::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTShortMeeting::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTShortMeeting::starttime() const {
  return *starttime_;
}
inline void TMTShortMeeting::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTShortMeeting::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTShortMeeting::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTShortMeeting::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTShortMeeting::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTShortMeeting::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 4;
inline bool TMTShortMeeting::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTShortMeeting::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTShortMeeting::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTShortMeeting::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTShortMeeting::endtime() const {
  return *endtime_;
}
inline void TMTShortMeeting::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTShortMeeting::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTShortMeeting::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTShortMeeting::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTShortMeeting::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTShortMeeting::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizermoid = 5;
inline bool TMTShortMeeting::has_organizermoid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTShortMeeting::set_has_organizermoid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTShortMeeting::clear_has_organizermoid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTShortMeeting::clear_organizermoid() {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    organizermoid_->clear();
  }
  clear_has_organizermoid();
}
inline const ::std::string& TMTShortMeeting::organizermoid() const {
  return *organizermoid_;
}
inline void TMTShortMeeting::set_organizermoid(const ::std::string& value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTShortMeeting::set_organizermoid(const char* value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTShortMeeting::set_organizermoid(const char* value, size_t size) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTShortMeeting::mutable_organizermoid() {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  return organizermoid_;
}
inline ::std::string* TMTShortMeeting::release_organizermoid() {
  clear_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermoid_;
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTShortMeeting::set_allocated_organizermoid(::std::string* organizermoid) {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermoid_;
  }
  if (organizermoid) {
    set_has_organizermoid();
    organizermoid_ = organizermoid;
  } else {
    clear_has_organizermoid();
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 status = 6;
inline bool TMTShortMeeting::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTShortMeeting::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTShortMeeting::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTShortMeeting::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 TMTShortMeeting::status() const {
  return status_;
}
inline void TMTShortMeeting::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 isvideomeeting = 7;
inline bool TMTShortMeeting::has_isvideomeeting() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTShortMeeting::set_has_isvideomeeting() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTShortMeeting::clear_has_isvideomeeting() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTShortMeeting::clear_isvideomeeting() {
  isvideomeeting_ = 0u;
  clear_has_isvideomeeting();
}
inline ::google::protobuf::uint32 TMTShortMeeting::isvideomeeting() const {
  return isvideomeeting_;
}
inline void TMTShortMeeting::set_isvideomeeting(::google::protobuf::uint32 value) {
  set_has_isvideomeeting();
  isvideomeeting_ = value;
}

// optional .mt.EmParticipantResponse feedbackStatus = 8;
inline bool TMTShortMeeting::has_feedbackstatus() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTShortMeeting::set_has_feedbackstatus() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTShortMeeting::clear_has_feedbackstatus() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTShortMeeting::clear_feedbackstatus() {
  feedbackstatus_ = 0;
  clear_has_feedbackstatus();
}
inline ::mt::EmParticipantResponse TMTShortMeeting::feedbackstatus() const {
  return static_cast< ::mt::EmParticipantResponse >(feedbackstatus_);
}
inline void TMTShortMeeting::set_feedbackstatus(::mt::EmParticipantResponse value) {
  assert(::mt::EmParticipantResponse_IsValid(value));
  set_has_feedbackstatus();
  feedbackstatus_ = value;
}

// optional uint32 regularid = 9;
inline bool TMTShortMeeting::has_regularid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTShortMeeting::set_has_regularid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTShortMeeting::clear_has_regularid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTShortMeeting::clear_regularid() {
  regularid_ = 0u;
  clear_has_regularid();
}
inline ::google::protobuf::uint32 TMTShortMeeting::regularid() const {
  return regularid_;
}
inline void TMTShortMeeting::set_regularid(::google::protobuf::uint32 value) {
  set_has_regularid();
  regularid_ = value;
}

// optional .mt.TMTRoomIDs room_ids = 10;
inline bool TMTShortMeeting::has_room_ids() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTShortMeeting::set_has_room_ids() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTShortMeeting::clear_has_room_ids() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTShortMeeting::clear_room_ids() {
  if (room_ids_ != NULL) room_ids_->::mt::TMTRoomIDs::Clear();
  clear_has_room_ids();
}
inline const ::mt::TMTRoomIDs& TMTShortMeeting::room_ids() const {
  return room_ids_ != NULL ? *room_ids_ : *default_instance_->room_ids_;
}
inline ::mt::TMTRoomIDs* TMTShortMeeting::mutable_room_ids() {
  set_has_room_ids();
  if (room_ids_ == NULL) room_ids_ = new ::mt::TMTRoomIDs;
  return room_ids_;
}
inline ::mt::TMTRoomIDs* TMTShortMeeting::release_room_ids() {
  clear_has_room_ids();
  ::mt::TMTRoomIDs* temp = room_ids_;
  room_ids_ = NULL;
  return temp;
}
inline void TMTShortMeeting::set_allocated_room_ids(::mt::TMTRoomIDs* room_ids) {
  delete room_ids_;
  room_ids_ = room_ids;
  if (room_ids) {
    set_has_room_ids();
  } else {
    clear_has_room_ids();
  }
}

// -------------------------------------------------------------------

// TMTShortRooms

// optional uint32 count = 1;
inline bool TMTShortRooms::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTShortRooms::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTShortRooms::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTShortRooms::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTShortRooms::count() const {
  return count_;
}
inline void TMTShortRooms::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTShortRoom items = 2;
inline int TMTShortRooms::items_size() const {
  return items_.size();
}
inline void TMTShortRooms::clear_items() {
  items_.Clear();
}
inline const ::mt::TMTShortRoom& TMTShortRooms::items(int index) const {
  return items_.Get(index);
}
inline ::mt::TMTShortRoom* TMTShortRooms::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::mt::TMTShortRoom* TMTShortRooms::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTShortRoom >&
TMTShortRooms::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTShortRoom >*
TMTShortRooms::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// TMTShortMeetings

// optional uint32 count = 1;
inline bool TMTShortMeetings::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTShortMeetings::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTShortMeetings::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTShortMeetings::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTShortMeetings::count() const {
  return count_;
}
inline void TMTShortMeetings::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTShortMeeting items = 2;
inline int TMTShortMeetings::items_size() const {
  return items_.size();
}
inline void TMTShortMeetings::clear_items() {
  items_.Clear();
}
inline const ::mt::TMTShortMeeting& TMTShortMeetings::items(int index) const {
  return items_.Get(index);
}
inline ::mt::TMTShortMeeting* TMTShortMeetings::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::mt::TMTShortMeeting* TMTShortMeetings::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTShortMeeting >&
TMTShortMeetings::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTShortMeeting >*
TMTShortMeetings::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// TMTMeetingLists

// optional .mt.TMTShortRooms related_rooms = 1;
inline bool TMTMeetingLists::has_related_rooms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTMeetingLists::set_has_related_rooms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTMeetingLists::clear_has_related_rooms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTMeetingLists::clear_related_rooms() {
  if (related_rooms_ != NULL) related_rooms_->::mt::TMTShortRooms::Clear();
  clear_has_related_rooms();
}
inline const ::mt::TMTShortRooms& TMTMeetingLists::related_rooms() const {
  return related_rooms_ != NULL ? *related_rooms_ : *default_instance_->related_rooms_;
}
inline ::mt::TMTShortRooms* TMTMeetingLists::mutable_related_rooms() {
  set_has_related_rooms();
  if (related_rooms_ == NULL) related_rooms_ = new ::mt::TMTShortRooms;
  return related_rooms_;
}
inline ::mt::TMTShortRooms* TMTMeetingLists::release_related_rooms() {
  clear_has_related_rooms();
  ::mt::TMTShortRooms* temp = related_rooms_;
  related_rooms_ = NULL;
  return temp;
}
inline void TMTMeetingLists::set_allocated_related_rooms(::mt::TMTShortRooms* related_rooms) {
  delete related_rooms_;
  related_rooms_ = related_rooms;
  if (related_rooms) {
    set_has_related_rooms();
  } else {
    clear_has_related_rooms();
  }
}

// optional .mt.TMTShortMeetings meetings = 2;
inline bool TMTMeetingLists::has_meetings() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTMeetingLists::set_has_meetings() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTMeetingLists::clear_has_meetings() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTMeetingLists::clear_meetings() {
  if (meetings_ != NULL) meetings_->::mt::TMTShortMeetings::Clear();
  clear_has_meetings();
}
inline const ::mt::TMTShortMeetings& TMTMeetingLists::meetings() const {
  return meetings_ != NULL ? *meetings_ : *default_instance_->meetings_;
}
inline ::mt::TMTShortMeetings* TMTMeetingLists::mutable_meetings() {
  set_has_meetings();
  if (meetings_ == NULL) meetings_ = new ::mt::TMTShortMeetings;
  return meetings_;
}
inline ::mt::TMTShortMeetings* TMTMeetingLists::release_meetings() {
  clear_has_meetings();
  ::mt::TMTShortMeetings* temp = meetings_;
  meetings_ = NULL;
  return temp;
}
inline void TMTMeetingLists::set_allocated_meetings(::mt::TMTShortMeetings* meetings) {
  delete meetings_;
  meetings_ = meetings;
  if (meetings) {
    set_has_meetings();
  } else {
    clear_has_meetings();
  }
}

// -------------------------------------------------------------------

// TMTRoom

// optional uint32 id = 1;
inline bool TMTRoom::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRoom::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRoom::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRoom::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTRoom::id() const {
  return id_;
}
inline void TMTRoom::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool TMTRoom::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRoom::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRoom::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRoom::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTRoom::name() const {
  return *name_;
}
inline void TMTRoom::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRoom::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRoom::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoom::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTRoom::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoom::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string regionname = 3;
inline bool TMTRoom::has_regionname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRoom::set_has_regionname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRoom::clear_has_regionname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRoom::clear_regionname() {
  if (regionname_ != &::google::protobuf::internal::kEmptyString) {
    regionname_->clear();
  }
  clear_has_regionname();
}
inline const ::std::string& TMTRoom::regionname() const {
  return *regionname_;
}
inline void TMTRoom::set_regionname(const ::std::string& value) {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  regionname_->assign(value);
}
inline void TMTRoom::set_regionname(const char* value) {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  regionname_->assign(value);
}
inline void TMTRoom::set_regionname(const char* value, size_t size) {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  regionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoom::mutable_regionname() {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  return regionname_;
}
inline ::std::string* TMTRoom::release_regionname() {
  clear_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = regionname_;
    regionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoom::set_allocated_regionname(::std::string* regionname) {
  if (regionname_ != &::google::protobuf::internal::kEmptyString) {
    delete regionname_;
  }
  if (regionname) {
    set_has_regionname();
    regionname_ = regionname;
  } else {
    clear_has_regionname();
    regionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string starttime = 4;
inline bool TMTRoom::has_starttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTRoom::set_has_starttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTRoom::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTRoom::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTRoom::starttime() const {
  return *starttime_;
}
inline void TMTRoom::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTRoom::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTRoom::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoom::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTRoom::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoom::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 5;
inline bool TMTRoom::has_endtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTRoom::set_has_endtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTRoom::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTRoom::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTRoom::endtime() const {
  return *endtime_;
}
inline void TMTRoom::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTRoom::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTRoom::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoom::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTRoom::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoom::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 peopleadmit = 6;
inline bool TMTRoom::has_peopleadmit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTRoom::set_has_peopleadmit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTRoom::clear_has_peopleadmit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTRoom::clear_peopleadmit() {
  peopleadmit_ = 0u;
  clear_has_peopleadmit();
}
inline ::google::protobuf::uint32 TMTRoom::peopleadmit() const {
  return peopleadmit_;
}
inline void TMTRoom::set_peopleadmit(::google::protobuf::uint32 value) {
  set_has_peopleadmit();
  peopleadmit_ = value;
}

// optional uint32 devicemask = 7;
inline bool TMTRoom::has_devicemask() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTRoom::set_has_devicemask() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTRoom::clear_has_devicemask() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTRoom::clear_devicemask() {
  devicemask_ = 0u;
  clear_has_devicemask();
}
inline ::google::protobuf::uint32 TMTRoom::devicemask() const {
  return devicemask_;
}
inline void TMTRoom::set_devicemask(::google::protobuf::uint32 value) {
  set_has_devicemask();
  devicemask_ = value;
}

// optional uint32 regionid = 8;
inline bool TMTRoom::has_regionid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTRoom::set_has_regionid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTRoom::clear_has_regionid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTRoom::clear_regionid() {
  regionid_ = 0u;
  clear_has_regionid();
}
inline ::google::protobuf::uint32 TMTRoom::regionid() const {
  return regionid_;
}
inline void TMTRoom::set_regionid(::google::protobuf::uint32 value) {
  set_has_regionid();
  regionid_ = value;
}

// -------------------------------------------------------------------

// TMTRooms

// optional uint32 count = 1;
inline bool TMTRooms::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRooms::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRooms::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRooms::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTRooms::count() const {
  return count_;
}
inline void TMTRooms::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTRoom items = 2;
inline int TMTRooms::items_size() const {
  return items_.size();
}
inline void TMTRooms::clear_items() {
  items_.Clear();
}
inline const ::mt::TMTRoom& TMTRooms::items(int index) const {
  return items_.Get(index);
}
inline ::mt::TMTRoom* TMTRooms::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::mt::TMTRoom* TMTRooms::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRoom >&
TMTRooms::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRoom >*
TMTRooms::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// TMTRoomList

// optional .mt.TMTRooms rooms = 1;
inline bool TMTRoomList::has_rooms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRoomList::set_has_rooms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRoomList::clear_has_rooms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRoomList::clear_rooms() {
  if (rooms_ != NULL) rooms_->::mt::TMTRooms::Clear();
  clear_has_rooms();
}
inline const ::mt::TMTRooms& TMTRoomList::rooms() const {
  return rooms_ != NULL ? *rooms_ : *default_instance_->rooms_;
}
inline ::mt::TMTRooms* TMTRoomList::mutable_rooms() {
  set_has_rooms();
  if (rooms_ == NULL) rooms_ = new ::mt::TMTRooms;
  return rooms_;
}
inline ::mt::TMTRooms* TMTRoomList::release_rooms() {
  clear_has_rooms();
  ::mt::TMTRooms* temp = rooms_;
  rooms_ = NULL;
  return temp;
}
inline void TMTRoomList::set_allocated_rooms(::mt::TMTRooms* rooms) {
  delete rooms_;
  rooms_ = rooms;
  if (rooms) {
    set_has_rooms();
  } else {
    clear_has_rooms();
  }
}

// optional uint32 total = 2;
inline bool TMTRoomList::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRoomList::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRoomList::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRoomList::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 TMTRoomList::total() const {
  return total_;
}
inline void TMTRoomList::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// -------------------------------------------------------------------

// TMTNormalRoomList

// optional uint32 start = 1;
inline bool TMTNormalRoomList::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTNormalRoomList::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTNormalRoomList::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTNormalRoomList::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTNormalRoomList::start() const {
  return start_;
}
inline void TMTNormalRoomList::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 2;
inline bool TMTNormalRoomList::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTNormalRoomList::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTNormalRoomList::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTNormalRoomList::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTNormalRoomList::count() const {
  return count_;
}
inline void TMTNormalRoomList::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional .mt.TMTShortRooms rooms = 3;
inline bool TMTNormalRoomList::has_rooms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTNormalRoomList::set_has_rooms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTNormalRoomList::clear_has_rooms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTNormalRoomList::clear_rooms() {
  if (rooms_ != NULL) rooms_->::mt::TMTShortRooms::Clear();
  clear_has_rooms();
}
inline const ::mt::TMTShortRooms& TMTNormalRoomList::rooms() const {
  return rooms_ != NULL ? *rooms_ : *default_instance_->rooms_;
}
inline ::mt::TMTShortRooms* TMTNormalRoomList::mutable_rooms() {
  set_has_rooms();
  if (rooms_ == NULL) rooms_ = new ::mt::TMTShortRooms;
  return rooms_;
}
inline ::mt::TMTShortRooms* TMTNormalRoomList::release_rooms() {
  clear_has_rooms();
  ::mt::TMTShortRooms* temp = rooms_;
  rooms_ = NULL;
  return temp;
}
inline void TMTNormalRoomList::set_allocated_rooms(::mt::TMTShortRooms* rooms) {
  delete rooms_;
  rooms_ = rooms;
  if (rooms) {
    set_has_rooms();
  } else {
    clear_has_rooms();
  }
}

// -------------------------------------------------------------------

// TMTRoomInfo

// optional uint32 id = 1;
inline bool TMTRoomInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRoomInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRoomInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRoomInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTRoomInfo::id() const {
  return id_;
}
inline void TMTRoomInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool TMTRoomInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRoomInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRoomInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRoomInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTRoomInfo::name() const {
  return *name_;
}
inline void TMTRoomInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRoomInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRoomInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTRoomInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string regionname = 3;
inline bool TMTRoomInfo::has_regionname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRoomInfo::set_has_regionname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRoomInfo::clear_has_regionname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRoomInfo::clear_regionname() {
  if (regionname_ != &::google::protobuf::internal::kEmptyString) {
    regionname_->clear();
  }
  clear_has_regionname();
}
inline const ::std::string& TMTRoomInfo::regionname() const {
  return *regionname_;
}
inline void TMTRoomInfo::set_regionname(const ::std::string& value) {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  regionname_->assign(value);
}
inline void TMTRoomInfo::set_regionname(const char* value) {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  regionname_->assign(value);
}
inline void TMTRoomInfo::set_regionname(const char* value, size_t size) {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  regionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomInfo::mutable_regionname() {
  set_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    regionname_ = new ::std::string;
  }
  return regionname_;
}
inline ::std::string* TMTRoomInfo::release_regionname() {
  clear_has_regionname();
  if (regionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = regionname_;
    regionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomInfo::set_allocated_regionname(::std::string* regionname) {
  if (regionname_ != &::google::protobuf::internal::kEmptyString) {
    delete regionname_;
  }
  if (regionname) {
    set_has_regionname();
    regionname_ = regionname;
  } else {
    clear_has_regionname();
    regionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTTemplate

// optional string id = 1;
inline bool TMTTemplate::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplate::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplate::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplate::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TMTTemplate::id() const {
  return *id_;
}
inline void TMTTemplate::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TMTTemplate::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TMTTemplate::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplate::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* TMTTemplate::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplate::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TMTTemplate::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTTemplate::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTTemplate::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTTemplate::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTTemplate::name() const {
  return *name_;
}
inline void TMTTemplate::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTTemplate::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTTemplate::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplate::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTTemplate::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplate::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTTemplates

// optional uint32 count = 1;
inline bool TMTTemplates::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplates::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplates::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplates::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTTemplates::count() const {
  return count_;
}
inline void TMTTemplates::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTTemplate items = 2;
inline int TMTTemplates::items_size() const {
  return items_.size();
}
inline void TMTTemplates::clear_items() {
  items_.Clear();
}
inline const ::mt::TMTTemplate& TMTTemplates::items(int index) const {
  return items_.Get(index);
}
inline ::mt::TMTTemplate* TMTTemplates::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::mt::TMTTemplate* TMTTemplates::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplate >&
TMTTemplates::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplate >*
TMTTemplates::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// TMTTemplateList

// optional .mt.TMTTemplates templates = 1;
inline bool TMTTemplateList::has_templates() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplateList::set_has_templates() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplateList::clear_has_templates() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplateList::clear_templates() {
  if (templates_ != NULL) templates_->::mt::TMTTemplates::Clear();
  clear_has_templates();
}
inline const ::mt::TMTTemplates& TMTTemplateList::templates() const {
  return templates_ != NULL ? *templates_ : *default_instance_->templates_;
}
inline ::mt::TMTTemplates* TMTTemplateList::mutable_templates() {
  set_has_templates();
  if (templates_ == NULL) templates_ = new ::mt::TMTTemplates;
  return templates_;
}
inline ::mt::TMTTemplates* TMTTemplateList::release_templates() {
  clear_has_templates();
  ::mt::TMTTemplates* temp = templates_;
  templates_ = NULL;
  return temp;
}
inline void TMTTemplateList::set_allocated_templates(::mt::TMTTemplates* templates) {
  delete templates_;
  templates_ = templates;
  if (templates) {
    set_has_templates();
  } else {
    clear_has_templates();
  }
}

// -------------------------------------------------------------------

// TMTPerson

// optional string moid = 1;
inline bool TMTPerson::has_moid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPerson::set_has_moid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPerson::clear_has_moid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPerson::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTPerson::moid() const {
  return *moid_;
}
inline void TMTPerson::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTPerson::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTPerson::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerson::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTPerson::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerson::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 2;
inline bool TMTPerson::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPerson::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPerson::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPerson::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& TMTPerson::email() const {
  return *email_;
}
inline void TMTPerson::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTPerson::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTPerson::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerson::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* TMTPerson::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerson::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool TMTPerson::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPerson::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPerson::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPerson::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTPerson::name() const {
  return *name_;
}
inline void TMTPerson::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPerson::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPerson::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerson::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTPerson::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerson::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string participantno = 4;
inline bool TMTPerson::has_participantno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPerson::set_has_participantno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPerson::clear_has_participantno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPerson::clear_participantno() {
  if (participantno_ != &::google::protobuf::internal::kEmptyString) {
    participantno_->clear();
  }
  clear_has_participantno();
}
inline const ::std::string& TMTPerson::participantno() const {
  return *participantno_;
}
inline void TMTPerson::set_participantno(const ::std::string& value) {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  participantno_->assign(value);
}
inline void TMTPerson::set_participantno(const char* value) {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  participantno_->assign(value);
}
inline void TMTPerson::set_participantno(const char* value, size_t size) {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  participantno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerson::mutable_participantno() {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  return participantno_;
}
inline ::std::string* TMTPerson::release_participantno() {
  clear_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = participantno_;
    participantno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerson::set_allocated_participantno(::std::string* participantno) {
  if (participantno_ != &::google::protobuf::internal::kEmptyString) {
    delete participantno_;
  }
  if (participantno) {
    set_has_participantno();
    participantno_ = participantno;
  } else {
    clear_has_participantno();
    participantno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 isparticipant = 5;
inline bool TMTPerson::has_isparticipant() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTPerson::set_has_isparticipant() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTPerson::clear_has_isparticipant() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTPerson::clear_isparticipant() {
  isparticipant_ = 0u;
  clear_has_isparticipant();
}
inline ::google::protobuf::uint32 TMTPerson::isparticipant() const {
  return isparticipant_;
}
inline void TMTPerson::set_isparticipant(::google::protobuf::uint32 value) {
  set_has_isparticipant();
  isparticipant_ = value;
}

// optional uint32 participanttype = 6;
inline bool TMTPerson::has_participanttype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTPerson::set_has_participanttype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTPerson::clear_has_participanttype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTPerson::clear_participanttype() {
  participanttype_ = 0u;
  clear_has_participanttype();
}
inline ::google::protobuf::uint32 TMTPerson::participanttype() const {
  return participanttype_;
}
inline void TMTPerson::set_participanttype(::google::protobuf::uint32 value) {
  set_has_participanttype();
  participanttype_ = value;
}

// -------------------------------------------------------------------

// TMTPersons

// optional uint32 count = 1;
inline bool TMTPersons::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPersons::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPersons::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPersons::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTPersons::count() const {
  return count_;
}
inline void TMTPersons::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTPerson items = 2;
inline int TMTPersons::items_size() const {
  return items_.size();
}
inline void TMTPersons::clear_items() {
  items_.Clear();
}
inline const ::mt::TMTPerson& TMTPersons::items(int index) const {
  return items_.Get(index);
}
inline ::mt::TMTPerson* TMTPersons::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::mt::TMTPerson* TMTPersons::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPerson >&
TMTPersons::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPerson >*
TMTPersons::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// TMTTemplateInfo

// optional string id = 1;
inline bool TMTTemplateInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplateInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplateInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplateInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TMTTemplateInfo::id() const {
  return *id_;
}
inline void TMTTemplateInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TMTTemplateInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TMTTemplateInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplateInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* TMTTemplateInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplateInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TMTTemplateInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTTemplateInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTTemplateInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTTemplateInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTTemplateInfo::name() const {
  return *name_;
}
inline void TMTTemplateInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTTemplateInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTTemplateInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplateInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTTemplateInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplateInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resolution = 3;
inline bool TMTTemplateInfo::has_resolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTTemplateInfo::set_has_resolution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTTemplateInfo::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTTemplateInfo::clear_resolution() {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    resolution_->clear();
  }
  clear_has_resolution();
}
inline const ::std::string& TMTTemplateInfo::resolution() const {
  return *resolution_;
}
inline void TMTTemplateInfo::set_resolution(const ::std::string& value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void TMTTemplateInfo::set_resolution(const char* value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void TMTTemplateInfo::set_resolution(const char* value, size_t size) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplateInfo::mutable_resolution() {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  return resolution_;
}
inline ::std::string* TMTTemplateInfo::release_resolution() {
  clear_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resolution_;
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplateInfo::set_allocated_resolution(::std::string* resolution) {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    delete resolution_;
  }
  if (resolution) {
    set_has_resolution();
    resolution_ = resolution;
  } else {
    clear_has_resolution();
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bandwith = 4;
inline bool TMTTemplateInfo::has_bandwith() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTTemplateInfo::set_has_bandwith() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTTemplateInfo::clear_has_bandwith() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTTemplateInfo::clear_bandwith() {
  if (bandwith_ != &::google::protobuf::internal::kEmptyString) {
    bandwith_->clear();
  }
  clear_has_bandwith();
}
inline const ::std::string& TMTTemplateInfo::bandwith() const {
  return *bandwith_;
}
inline void TMTTemplateInfo::set_bandwith(const ::std::string& value) {
  set_has_bandwith();
  if (bandwith_ == &::google::protobuf::internal::kEmptyString) {
    bandwith_ = new ::std::string;
  }
  bandwith_->assign(value);
}
inline void TMTTemplateInfo::set_bandwith(const char* value) {
  set_has_bandwith();
  if (bandwith_ == &::google::protobuf::internal::kEmptyString) {
    bandwith_ = new ::std::string;
  }
  bandwith_->assign(value);
}
inline void TMTTemplateInfo::set_bandwith(const char* value, size_t size) {
  set_has_bandwith();
  if (bandwith_ == &::google::protobuf::internal::kEmptyString) {
    bandwith_ = new ::std::string;
  }
  bandwith_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplateInfo::mutable_bandwith() {
  set_has_bandwith();
  if (bandwith_ == &::google::protobuf::internal::kEmptyString) {
    bandwith_ = new ::std::string;
  }
  return bandwith_;
}
inline ::std::string* TMTTemplateInfo::release_bandwith() {
  clear_has_bandwith();
  if (bandwith_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bandwith_;
    bandwith_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplateInfo::set_allocated_bandwith(::std::string* bandwith) {
  if (bandwith_ != &::google::protobuf::internal::kEmptyString) {
    delete bandwith_;
  }
  if (bandwith) {
    set_has_bandwith();
    bandwith_ = bandwith;
  } else {
    clear_has_bandwith();
    bandwith_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTPersons persons = 5;
inline bool TMTTemplateInfo::has_persons() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTTemplateInfo::set_has_persons() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTTemplateInfo::clear_has_persons() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTTemplateInfo::clear_persons() {
  if (persons_ != NULL) persons_->::mt::TMTPersons::Clear();
  clear_has_persons();
}
inline const ::mt::TMTPersons& TMTTemplateInfo::persons() const {
  return persons_ != NULL ? *persons_ : *default_instance_->persons_;
}
inline ::mt::TMTPersons* TMTTemplateInfo::mutable_persons() {
  set_has_persons();
  if (persons_ == NULL) persons_ = new ::mt::TMTPersons;
  return persons_;
}
inline ::mt::TMTPersons* TMTTemplateInfo::release_persons() {
  clear_has_persons();
  ::mt::TMTPersons* temp = persons_;
  persons_ = NULL;
  return temp;
}
inline void TMTTemplateInfo::set_allocated_persons(::mt::TMTPersons* persons) {
  delete persons_;
  persons_ = persons;
  if (persons) {
    set_has_persons();
  } else {
    clear_has_persons();
  }
}

// -------------------------------------------------------------------

// TMTMeetingIDs

// optional uint32 count = 1;
inline bool TMTMeetingIDs::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTMeetingIDs::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTMeetingIDs::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTMeetingIDs::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTMeetingIDs::count() const {
  return count_;
}
inline void TMTMeetingIDs::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated uint32 items = 2;
inline int TMTMeetingIDs::items_size() const {
  return items_.size();
}
inline void TMTMeetingIDs::clear_items() {
  items_.Clear();
}
inline ::google::protobuf::uint32 TMTMeetingIDs::items(int index) const {
  return items_.Get(index);
}
inline void TMTMeetingIDs::set_items(int index, ::google::protobuf::uint32 value) {
  items_.Set(index, value);
}
inline void TMTMeetingIDs::add_items(::google::protobuf::uint32 value) {
  items_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TMTMeetingIDs::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TMTMeetingIDs::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// TMTRegularInfo

// optional uint32 id = 1;
inline bool TMTRegularInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRegularInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRegularInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRegularInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTRegularInfo::id() const {
  return id_;
}
inline void TMTRegularInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string subject = 2;
inline bool TMTRegularInfo::has_subject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRegularInfo::set_has_subject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRegularInfo::clear_has_subject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRegularInfo::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTRegularInfo::subject() const {
  return *subject_;
}
inline void TMTRegularInfo::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTRegularInfo::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTRegularInfo::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegularInfo::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTRegularInfo::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegularInfo::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string starttime = 3;
inline bool TMTRegularInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRegularInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRegularInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRegularInfo::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTRegularInfo::starttime() const {
  return *starttime_;
}
inline void TMTRegularInfo::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTRegularInfo::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTRegularInfo::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegularInfo::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTRegularInfo::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegularInfo::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 4;
inline bool TMTRegularInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTRegularInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTRegularInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTRegularInfo::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTRegularInfo::endtime() const {
  return *endtime_;
}
inline void TMTRegularInfo::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTRegularInfo::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTRegularInfo::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegularInfo::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTRegularInfo::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegularInfo::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 status = 5;
inline bool TMTRegularInfo::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTRegularInfo::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTRegularInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTRegularInfo::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 TMTRegularInfo::status() const {
  return status_;
}
inline void TMTRegularInfo::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional string organizer = 6;
inline bool TMTRegularInfo::has_organizer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTRegularInfo::set_has_organizer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTRegularInfo::clear_has_organizer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTRegularInfo::clear_organizer() {
  if (organizer_ != &::google::protobuf::internal::kEmptyString) {
    organizer_->clear();
  }
  clear_has_organizer();
}
inline const ::std::string& TMTRegularInfo::organizer() const {
  return *organizer_;
}
inline void TMTRegularInfo::set_organizer(const ::std::string& value) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(value);
}
inline void TMTRegularInfo::set_organizer(const char* value) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(value);
}
inline void TMTRegularInfo::set_organizer(const char* value, size_t size) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegularInfo::mutable_organizer() {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  return organizer_;
}
inline ::std::string* TMTRegularInfo::release_organizer() {
  clear_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizer_;
    organizer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegularInfo::set_allocated_organizer(::std::string* organizer) {
  if (organizer_ != &::google::protobuf::internal::kEmptyString) {
    delete organizer_;
  }
  if (organizer) {
    set_has_organizer();
    organizer_ = organizer;
  } else {
    clear_has_organizer();
    organizer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizermail = 7;
inline bool TMTRegularInfo::has_organizermail() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTRegularInfo::set_has_organizermail() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTRegularInfo::clear_has_organizermail() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTRegularInfo::clear_organizermail() {
  if (organizermail_ != &::google::protobuf::internal::kEmptyString) {
    organizermail_->clear();
  }
  clear_has_organizermail();
}
inline const ::std::string& TMTRegularInfo::organizermail() const {
  return *organizermail_;
}
inline void TMTRegularInfo::set_organizermail(const ::std::string& value) {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  organizermail_->assign(value);
}
inline void TMTRegularInfo::set_organizermail(const char* value) {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  organizermail_->assign(value);
}
inline void TMTRegularInfo::set_organizermail(const char* value, size_t size) {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  organizermail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegularInfo::mutable_organizermail() {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  return organizermail_;
}
inline ::std::string* TMTRegularInfo::release_organizermail() {
  clear_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermail_;
    organizermail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegularInfo::set_allocated_organizermail(::std::string* organizermail) {
  if (organizermail_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermail_;
  }
  if (organizermail) {
    set_has_organizermail();
    organizermail_ = organizermail;
  } else {
    clear_has_organizermail();
    organizermail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 8;
inline bool TMTRegularInfo::has_phone() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTRegularInfo::set_has_phone() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTRegularInfo::clear_has_phone() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTRegularInfo::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& TMTRegularInfo::phone() const {
  return *phone_;
}
inline void TMTRegularInfo::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTRegularInfo::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTRegularInfo::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegularInfo::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* TMTRegularInfo::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegularInfo::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobile = 9;
inline bool TMTRegularInfo::has_mobile() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTRegularInfo::set_has_mobile() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTRegularInfo::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTRegularInfo::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& TMTRegularInfo::mobile() const {
  return *mobile_;
}
inline void TMTRegularInfo::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTRegularInfo::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTRegularInfo::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegularInfo::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* TMTRegularInfo::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegularInfo::set_allocated_mobile(::std::string* mobile) {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_;
  }
  if (mobile) {
    set_has_mobile();
    mobile_ = mobile;
  } else {
    clear_has_mobile();
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brief = 10;
inline bool TMTRegularInfo::has_brief() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTRegularInfo::set_has_brief() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTRegularInfo::clear_has_brief() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTRegularInfo::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TMTRegularInfo::brief() const {
  return *brief_;
}
inline void TMTRegularInfo::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTRegularInfo::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTRegularInfo::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegularInfo::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TMTRegularInfo::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegularInfo::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 isvideo = 11;
inline bool TMTRegularInfo::has_isvideo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTRegularInfo::set_has_isvideo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTRegularInfo::clear_has_isvideo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTRegularInfo::clear_isvideo() {
  isvideo_ = 0u;
  clear_has_isvideo();
}
inline ::google::protobuf::uint32 TMTRegularInfo::isvideo() const {
  return isvideo_;
}
inline void TMTRegularInfo::set_isvideo(::google::protobuf::uint32 value) {
  set_has_isvideo();
  isvideo_ = value;
}

// optional string startdate = 12;
inline bool TMTRegularInfo::has_startdate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTRegularInfo::set_has_startdate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTRegularInfo::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTRegularInfo::clear_startdate() {
  if (startdate_ != &::google::protobuf::internal::kEmptyString) {
    startdate_->clear();
  }
  clear_has_startdate();
}
inline const ::std::string& TMTRegularInfo::startdate() const {
  return *startdate_;
}
inline void TMTRegularInfo::set_startdate(const ::std::string& value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
}
inline void TMTRegularInfo::set_startdate(const char* value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
}
inline void TMTRegularInfo::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegularInfo::mutable_startdate() {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  return startdate_;
}
inline ::std::string* TMTRegularInfo::release_startdate() {
  clear_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startdate_;
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegularInfo::set_allocated_startdate(::std::string* startdate) {
  if (startdate_ != &::google::protobuf::internal::kEmptyString) {
    delete startdate_;
  }
  if (startdate) {
    set_has_startdate();
    startdate_ = startdate;
  } else {
    clear_has_startdate();
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string enddate = 13;
inline bool TMTRegularInfo::has_enddate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTRegularInfo::set_has_enddate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTRegularInfo::clear_has_enddate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTRegularInfo::clear_enddate() {
  if (enddate_ != &::google::protobuf::internal::kEmptyString) {
    enddate_->clear();
  }
  clear_has_enddate();
}
inline const ::std::string& TMTRegularInfo::enddate() const {
  return *enddate_;
}
inline void TMTRegularInfo::set_enddate(const ::std::string& value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
}
inline void TMTRegularInfo::set_enddate(const char* value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
}
inline void TMTRegularInfo::set_enddate(const char* value, size_t size) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegularInfo::mutable_enddate() {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  return enddate_;
}
inline ::std::string* TMTRegularInfo::release_enddate() {
  clear_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enddate_;
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegularInfo::set_allocated_enddate(::std::string* enddate) {
  if (enddate_ != &::google::protobuf::internal::kEmptyString) {
    delete enddate_;
  }
  if (enddate) {
    set_has_enddate();
    enddate_ = enddate;
  } else {
    clear_has_enddate();
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 repeattype = 14;
inline bool TMTRegularInfo::has_repeattype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTRegularInfo::set_has_repeattype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTRegularInfo::clear_has_repeattype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTRegularInfo::clear_repeattype() {
  repeattype_ = 0u;
  clear_has_repeattype();
}
inline ::google::protobuf::uint32 TMTRegularInfo::repeattype() const {
  return repeattype_;
}
inline void TMTRegularInfo::set_repeattype(::google::protobuf::uint32 value) {
  set_has_repeattype();
  repeattype_ = value;
}

// optional uint32 frequency = 15;
inline bool TMTRegularInfo::has_frequency() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTRegularInfo::set_has_frequency() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTRegularInfo::clear_has_frequency() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTRegularInfo::clear_frequency() {
  frequency_ = 0u;
  clear_has_frequency();
}
inline ::google::protobuf::uint32 TMTRegularInfo::frequency() const {
  return frequency_;
}
inline void TMTRegularInfo::set_frequency(::google::protobuf::uint32 value) {
  set_has_frequency();
  frequency_ = value;
}

// optional string weekdays = 16;
inline bool TMTRegularInfo::has_weekdays() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTRegularInfo::set_has_weekdays() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTRegularInfo::clear_has_weekdays() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTRegularInfo::clear_weekdays() {
  if (weekdays_ != &::google::protobuf::internal::kEmptyString) {
    weekdays_->clear();
  }
  clear_has_weekdays();
}
inline const ::std::string& TMTRegularInfo::weekdays() const {
  return *weekdays_;
}
inline void TMTRegularInfo::set_weekdays(const ::std::string& value) {
  set_has_weekdays();
  if (weekdays_ == &::google::protobuf::internal::kEmptyString) {
    weekdays_ = new ::std::string;
  }
  weekdays_->assign(value);
}
inline void TMTRegularInfo::set_weekdays(const char* value) {
  set_has_weekdays();
  if (weekdays_ == &::google::protobuf::internal::kEmptyString) {
    weekdays_ = new ::std::string;
  }
  weekdays_->assign(value);
}
inline void TMTRegularInfo::set_weekdays(const char* value, size_t size) {
  set_has_weekdays();
  if (weekdays_ == &::google::protobuf::internal::kEmptyString) {
    weekdays_ = new ::std::string;
  }
  weekdays_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegularInfo::mutable_weekdays() {
  set_has_weekdays();
  if (weekdays_ == &::google::protobuf::internal::kEmptyString) {
    weekdays_ = new ::std::string;
  }
  return weekdays_;
}
inline ::std::string* TMTRegularInfo::release_weekdays() {
  clear_has_weekdays();
  if (weekdays_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weekdays_;
    weekdays_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegularInfo::set_allocated_weekdays(::std::string* weekdays) {
  if (weekdays_ != &::google::protobuf::internal::kEmptyString) {
    delete weekdays_;
  }
  if (weekdays) {
    set_has_weekdays();
    weekdays_ = weekdays;
  } else {
    clear_has_weekdays();
    weekdays_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTMeetingIDs meeting_ids = 17;
inline bool TMTRegularInfo::has_meeting_ids() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTRegularInfo::set_has_meeting_ids() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTRegularInfo::clear_has_meeting_ids() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTRegularInfo::clear_meeting_ids() {
  if (meeting_ids_ != NULL) meeting_ids_->::mt::TMTMeetingIDs::Clear();
  clear_has_meeting_ids();
}
inline const ::mt::TMTMeetingIDs& TMTRegularInfo::meeting_ids() const {
  return meeting_ids_ != NULL ? *meeting_ids_ : *default_instance_->meeting_ids_;
}
inline ::mt::TMTMeetingIDs* TMTRegularInfo::mutable_meeting_ids() {
  set_has_meeting_ids();
  if (meeting_ids_ == NULL) meeting_ids_ = new ::mt::TMTMeetingIDs;
  return meeting_ids_;
}
inline ::mt::TMTMeetingIDs* TMTRegularInfo::release_meeting_ids() {
  clear_has_meeting_ids();
  ::mt::TMTMeetingIDs* temp = meeting_ids_;
  meeting_ids_ = NULL;
  return temp;
}
inline void TMTRegularInfo::set_allocated_meeting_ids(::mt::TMTMeetingIDs* meeting_ids) {
  delete meeting_ids_;
  meeting_ids_ = meeting_ids;
  if (meeting_ids) {
    set_has_meeting_ids();
  } else {
    clear_has_meeting_ids();
  }
}

// -------------------------------------------------------------------

// TMTRegion

// optional uint32 id = 1;
inline bool TMTRegion::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRegion::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRegion::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRegion::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTRegion::id() const {
  return id_;
}
inline void TMTRegion::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool TMTRegion::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRegion::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRegion::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRegion::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTRegion::name() const {
  return *name_;
}
inline void TMTRegion::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRegion::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRegion::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegion::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTRegion::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegion::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTRegions

// optional uint32 count = 1;
inline bool TMTRegions::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRegions::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRegions::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRegions::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTRegions::count() const {
  return count_;
}
inline void TMTRegions::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTRegion items = 2;
inline int TMTRegions::items_size() const {
  return items_.size();
}
inline void TMTRegions::clear_items() {
  items_.Clear();
}
inline const ::mt::TMTRegion& TMTRegions::items(int index) const {
  return items_.Get(index);
}
inline ::mt::TMTRegion* TMTRegions::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::mt::TMTRegion* TMTRegions::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRegion >&
TMTRegions::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRegion >*
TMTRegions::mutable_items() {
  return &items_;
}

// optional string companyid = 3;
inline bool TMTRegions::has_companyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRegions::set_has_companyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRegions::clear_has_companyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRegions::clear_companyid() {
  if (companyid_ != &::google::protobuf::internal::kEmptyString) {
    companyid_->clear();
  }
  clear_has_companyid();
}
inline const ::std::string& TMTRegions::companyid() const {
  return *companyid_;
}
inline void TMTRegions::set_companyid(const ::std::string& value) {
  set_has_companyid();
  if (companyid_ == &::google::protobuf::internal::kEmptyString) {
    companyid_ = new ::std::string;
  }
  companyid_->assign(value);
}
inline void TMTRegions::set_companyid(const char* value) {
  set_has_companyid();
  if (companyid_ == &::google::protobuf::internal::kEmptyString) {
    companyid_ = new ::std::string;
  }
  companyid_->assign(value);
}
inline void TMTRegions::set_companyid(const char* value, size_t size) {
  set_has_companyid();
  if (companyid_ == &::google::protobuf::internal::kEmptyString) {
    companyid_ = new ::std::string;
  }
  companyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRegions::mutable_companyid() {
  set_has_companyid();
  if (companyid_ == &::google::protobuf::internal::kEmptyString) {
    companyid_ = new ::std::string;
  }
  return companyid_;
}
inline ::std::string* TMTRegions::release_companyid() {
  clear_has_companyid();
  if (companyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = companyid_;
    companyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRegions::set_allocated_companyid(::std::string* companyid) {
  if (companyid_ != &::google::protobuf::internal::kEmptyString) {
    delete companyid_;
  }
  if (companyid) {
    set_has_companyid();
    companyid_ = companyid;
  } else {
    clear_has_companyid();
    companyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTRoomLockResultItem

// optional uint32 id = 1;
inline bool TMTRoomLockResultItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRoomLockResultItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRoomLockResultItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRoomLockResultItem::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTRoomLockResultItem::id() const {
  return id_;
}
inline void TMTRoomLockResultItem::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool TMTRoomLockResultItem::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRoomLockResultItem::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRoomLockResultItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRoomLockResultItem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTRoomLockResultItem::name() const {
  return *name_;
}
inline void TMTRoomLockResultItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRoomLockResultItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRoomLockResultItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomLockResultItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTRoomLockResultItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomLockResultItem::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 result = 3;
inline bool TMTRoomLockResultItem::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRoomLockResultItem::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRoomLockResultItem::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRoomLockResultItem::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 TMTRoomLockResultItem::result() const {
  return result_;
}
inline void TMTRoomLockResultItem::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// TMTRoomLockResultItems

// optional uint32 count = 1;
inline bool TMTRoomLockResultItems::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRoomLockResultItems::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRoomLockResultItems::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRoomLockResultItems::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTRoomLockResultItems::count() const {
  return count_;
}
inline void TMTRoomLockResultItems::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTRoomLockResultItem items = 2;
inline int TMTRoomLockResultItems::items_size() const {
  return items_.size();
}
inline void TMTRoomLockResultItems::clear_items() {
  items_.Clear();
}
inline const ::mt::TMTRoomLockResultItem& TMTRoomLockResultItems::items(int index) const {
  return items_.Get(index);
}
inline ::mt::TMTRoomLockResultItem* TMTRoomLockResultItems::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::mt::TMTRoomLockResultItem* TMTRoomLockResultItems::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRoomLockResultItem >&
TMTRoomLockResultItems::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRoomLockResultItem >*
TMTRoomLockResultItems::mutable_items() {
  return &items_;
}

// optional uint32 success = 3;
inline bool TMTRoomLockResultItems::has_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRoomLockResultItems::set_has_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRoomLockResultItems::clear_has_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRoomLockResultItems::clear_success() {
  success_ = 0u;
  clear_has_success();
}
inline ::google::protobuf::uint32 TMTRoomLockResultItems::success() const {
  return success_;
}
inline void TMTRoomLockResultItems::set_success(::google::protobuf::uint32 value) {
  set_has_success();
  success_ = value;
}

// optional string meetingformkey = 4;
inline bool TMTRoomLockResultItems::has_meetingformkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTRoomLockResultItems::set_has_meetingformkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTRoomLockResultItems::clear_has_meetingformkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTRoomLockResultItems::clear_meetingformkey() {
  if (meetingformkey_ != &::google::protobuf::internal::kEmptyString) {
    meetingformkey_->clear();
  }
  clear_has_meetingformkey();
}
inline const ::std::string& TMTRoomLockResultItems::meetingformkey() const {
  return *meetingformkey_;
}
inline void TMTRoomLockResultItems::set_meetingformkey(const ::std::string& value) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(value);
}
inline void TMTRoomLockResultItems::set_meetingformkey(const char* value) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(value);
}
inline void TMTRoomLockResultItems::set_meetingformkey(const char* value, size_t size) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomLockResultItems::mutable_meetingformkey() {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  return meetingformkey_;
}
inline ::std::string* TMTRoomLockResultItems::release_meetingformkey() {
  clear_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetingformkey_;
    meetingformkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomLockResultItems::set_allocated_meetingformkey(::std::string* meetingformkey) {
  if (meetingformkey_ != &::google::protobuf::internal::kEmptyString) {
    delete meetingformkey_;
  }
  if (meetingformkey) {
    set_has_meetingformkey();
    meetingformkey_ = meetingformkey;
  } else {
    clear_has_meetingformkey();
    meetingformkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string starttime = 5;
inline bool TMTRoomLockResultItems::has_starttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTRoomLockResultItems::set_has_starttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTRoomLockResultItems::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTRoomLockResultItems::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTRoomLockResultItems::starttime() const {
  return *starttime_;
}
inline void TMTRoomLockResultItems::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTRoomLockResultItems::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTRoomLockResultItems::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomLockResultItems::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTRoomLockResultItems::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomLockResultItems::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 6;
inline bool TMTRoomLockResultItems::has_endtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTRoomLockResultItems::set_has_endtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTRoomLockResultItems::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTRoomLockResultItems::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTRoomLockResultItems::endtime() const {
  return *endtime_;
}
inline void TMTRoomLockResultItems::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTRoomLockResultItems::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTRoomLockResultItems::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomLockResultItems::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTRoomLockResultItems::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomLockResultItems::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMeetingNotify

// optional .mt.EmRestMeetingNotifyType notifytype = 1;
inline bool TMeetingNotify::has_notifytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMeetingNotify::set_has_notifytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMeetingNotify::clear_has_notifytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMeetingNotify::clear_notifytype() {
  notifytype_ = 0;
  clear_has_notifytype();
}
inline ::mt::EmRestMeetingNotifyType TMeetingNotify::notifytype() const {
  return static_cast< ::mt::EmRestMeetingNotifyType >(notifytype_);
}
inline void TMeetingNotify::set_notifytype(::mt::EmRestMeetingNotifyType value) {
  assert(::mt::EmRestMeetingNotifyType_IsValid(value));
  set_has_notifytype();
  notifytype_ = value;
}

// optional string moid = 2;
inline bool TMeetingNotify::has_moid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMeetingNotify::set_has_moid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMeetingNotify::clear_has_moid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMeetingNotify::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMeetingNotify::moid() const {
  return *moid_;
}
inline void TMeetingNotify::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMeetingNotify::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMeetingNotify::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMeetingNotify::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMeetingNotify::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMeetingNotify::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 notifyid = 3;
inline bool TMeetingNotify::has_notifyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMeetingNotify::set_has_notifyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMeetingNotify::clear_has_notifyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMeetingNotify::clear_notifyid() {
  notifyid_ = 0u;
  clear_has_notifyid();
}
inline ::google::protobuf::uint32 TMeetingNotify::notifyid() const {
  return notifyid_;
}
inline void TMeetingNotify::set_notifyid(::google::protobuf::uint32 value) {
  set_has_notifyid();
  notifyid_ = value;
}

// optional uint32 num = 4;
inline bool TMeetingNotify::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMeetingNotify::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMeetingNotify::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMeetingNotify::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 TMeetingNotify::num() const {
  return num_;
}
inline void TMeetingNotify::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// TMTWbParse_Keda_UserProfile

// optional string userid = 1;
inline bool TMTWbParse_Keda_UserProfile::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParse_Keda_UserProfile::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParse_Keda_UserProfile::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParse_Keda_UserProfile::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& TMTWbParse_Keda_UserProfile::userid() const {
  return *userid_;
}
inline void TMTWbParse_Keda_UserProfile::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void TMTWbParse_Keda_UserProfile::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void TMTWbParse_Keda_UserProfile::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_UserProfile::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* TMTWbParse_Keda_UserProfile::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_UserProfile::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jobtitle = 2;
inline bool TMTWbParse_Keda_UserProfile::has_jobtitle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTWbParse_Keda_UserProfile::set_has_jobtitle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTWbParse_Keda_UserProfile::clear_has_jobtitle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTWbParse_Keda_UserProfile::clear_jobtitle() {
  if (jobtitle_ != &::google::protobuf::internal::kEmptyString) {
    jobtitle_->clear();
  }
  clear_has_jobtitle();
}
inline const ::std::string& TMTWbParse_Keda_UserProfile::jobtitle() const {
  return *jobtitle_;
}
inline void TMTWbParse_Keda_UserProfile::set_jobtitle(const ::std::string& value) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::kEmptyString) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(value);
}
inline void TMTWbParse_Keda_UserProfile::set_jobtitle(const char* value) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::kEmptyString) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(value);
}
inline void TMTWbParse_Keda_UserProfile::set_jobtitle(const char* value, size_t size) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::kEmptyString) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_UserProfile::mutable_jobtitle() {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::kEmptyString) {
    jobtitle_ = new ::std::string;
  }
  return jobtitle_;
}
inline ::std::string* TMTWbParse_Keda_UserProfile::release_jobtitle() {
  clear_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jobtitle_;
    jobtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_UserProfile::set_allocated_jobtitle(::std::string* jobtitle) {
  if (jobtitle_ != &::google::protobuf::internal::kEmptyString) {
    delete jobtitle_;
  }
  if (jobtitle) {
    set_has_jobtitle();
    jobtitle_ = jobtitle;
  } else {
    clear_has_jobtitle();
    jobtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location = 3;
inline bool TMTWbParse_Keda_UserProfile::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTWbParse_Keda_UserProfile::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTWbParse_Keda_UserProfile::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTWbParse_Keda_UserProfile::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& TMTWbParse_Keda_UserProfile::location() const {
  return *location_;
}
inline void TMTWbParse_Keda_UserProfile::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void TMTWbParse_Keda_UserProfile::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void TMTWbParse_Keda_UserProfile::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_UserProfile::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* TMTWbParse_Keda_UserProfile::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_UserProfile::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string workphone = 4;
inline bool TMTWbParse_Keda_UserProfile::has_workphone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTWbParse_Keda_UserProfile::set_has_workphone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTWbParse_Keda_UserProfile::clear_has_workphone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTWbParse_Keda_UserProfile::clear_workphone() {
  if (workphone_ != &::google::protobuf::internal::kEmptyString) {
    workphone_->clear();
  }
  clear_has_workphone();
}
inline const ::std::string& TMTWbParse_Keda_UserProfile::workphone() const {
  return *workphone_;
}
inline void TMTWbParse_Keda_UserProfile::set_workphone(const ::std::string& value) {
  set_has_workphone();
  if (workphone_ == &::google::protobuf::internal::kEmptyString) {
    workphone_ = new ::std::string;
  }
  workphone_->assign(value);
}
inline void TMTWbParse_Keda_UserProfile::set_workphone(const char* value) {
  set_has_workphone();
  if (workphone_ == &::google::protobuf::internal::kEmptyString) {
    workphone_ = new ::std::string;
  }
  workphone_->assign(value);
}
inline void TMTWbParse_Keda_UserProfile::set_workphone(const char* value, size_t size) {
  set_has_workphone();
  if (workphone_ == &::google::protobuf::internal::kEmptyString) {
    workphone_ = new ::std::string;
  }
  workphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_UserProfile::mutable_workphone() {
  set_has_workphone();
  if (workphone_ == &::google::protobuf::internal::kEmptyString) {
    workphone_ = new ::std::string;
  }
  return workphone_;
}
inline ::std::string* TMTWbParse_Keda_UserProfile::release_workphone() {
  clear_has_workphone();
  if (workphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = workphone_;
    workphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_UserProfile::set_allocated_workphone(::std::string* workphone) {
  if (workphone_ != &::google::protobuf::internal::kEmptyString) {
    delete workphone_;
  }
  if (workphone) {
    set_has_workphone();
    workphone_ = workphone;
  } else {
    clear_has_workphone();
    workphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobilephone = 5;
inline bool TMTWbParse_Keda_UserProfile::has_mobilephone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTWbParse_Keda_UserProfile::set_has_mobilephone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTWbParse_Keda_UserProfile::clear_has_mobilephone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTWbParse_Keda_UserProfile::clear_mobilephone() {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    mobilephone_->clear();
  }
  clear_has_mobilephone();
}
inline const ::std::string& TMTWbParse_Keda_UserProfile::mobilephone() const {
  return *mobilephone_;
}
inline void TMTWbParse_Keda_UserProfile::set_mobilephone(const ::std::string& value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void TMTWbParse_Keda_UserProfile::set_mobilephone(const char* value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void TMTWbParse_Keda_UserProfile::set_mobilephone(const char* value, size_t size) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_UserProfile::mutable_mobilephone() {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  return mobilephone_;
}
inline ::std::string* TMTWbParse_Keda_UserProfile::release_mobilephone() {
  clear_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilephone_;
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_UserProfile::set_allocated_mobilephone(::std::string* mobilephone) {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    delete mobilephone_;
  }
  if (mobilephone) {
    set_has_mobilephone();
    mobilephone_ = mobilephone;
  } else {
    clear_has_mobilephone();
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTWbParse_Keda_User

// optional string moid = 1;
inline bool TMTWbParse_Keda_User::has_moid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_moid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParse_Keda_User::clear_has_moid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParse_Keda_User::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTWbParse_Keda_User::moid() const {
  return *moid_;
}
inline void TMTWbParse_Keda_User::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTWbParse_Keda_User::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTWbParse_Keda_User::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTWbParse_Keda_User::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jid = 2;
inline bool TMTWbParse_Keda_User::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTWbParse_Keda_User::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTWbParse_Keda_User::clear_jid() {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    jid_->clear();
  }
  clear_has_jid();
}
inline const ::std::string& TMTWbParse_Keda_User::jid() const {
  return *jid_;
}
inline void TMTWbParse_Keda_User::set_jid(const ::std::string& value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTWbParse_Keda_User::set_jid(const char* value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTWbParse_Keda_User::set_jid(const char* value, size_t size) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_jid() {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  return jid_;
}
inline ::std::string* TMTWbParse_Keda_User::release_jid() {
  clear_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jid_;
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_jid(::std::string* jid) {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    delete jid_;
  }
  if (jid) {
    set_has_jid();
    jid_ = jid;
  } else {
    clear_has_jid();
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 3;
inline bool TMTWbParse_Keda_User::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTWbParse_Keda_User::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTWbParse_Keda_User::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTWbParse_Keda_User::account() const {
  return *account_;
}
inline void TMTWbParse_Keda_User::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTWbParse_Keda_User::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTWbParse_Keda_User::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTWbParse_Keda_User::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 4;
inline bool TMTWbParse_Keda_User::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTWbParse_Keda_User::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTWbParse_Keda_User::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& TMTWbParse_Keda_User::email() const {
  return *email_;
}
inline void TMTWbParse_Keda_User::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTWbParse_Keda_User::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTWbParse_Keda_User::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* TMTWbParse_Keda_User::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 5;
inline bool TMTWbParse_Keda_User::has_e164() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_e164() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTWbParse_Keda_User::clear_has_e164() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTWbParse_Keda_User::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTWbParse_Keda_User::e164() const {
  return *e164_;
}
inline void TMTWbParse_Keda_User::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTWbParse_Keda_User::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTWbParse_Keda_User::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTWbParse_Keda_User::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobile = 6;
inline bool TMTWbParse_Keda_User::has_mobile() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_mobile() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTWbParse_Keda_User::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTWbParse_Keda_User::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& TMTWbParse_Keda_User::mobile() const {
  return *mobile_;
}
inline void TMTWbParse_Keda_User::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTWbParse_Keda_User::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTWbParse_Keda_User::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* TMTWbParse_Keda_User::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_mobile(::std::string* mobile) {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_;
  }
  if (mobile) {
    set_has_mobile();
    mobile_ = mobile;
  } else {
    clear_has_mobile();
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string devicetype = 7;
inline bool TMTWbParse_Keda_User::has_devicetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_devicetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTWbParse_Keda_User::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTWbParse_Keda_User::clear_devicetype() {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    devicetype_->clear();
  }
  clear_has_devicetype();
}
inline const ::std::string& TMTWbParse_Keda_User::devicetype() const {
  return *devicetype_;
}
inline void TMTWbParse_Keda_User::set_devicetype(const ::std::string& value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void TMTWbParse_Keda_User::set_devicetype(const char* value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void TMTWbParse_Keda_User::set_devicetype(const char* value, size_t size) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_devicetype() {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  return devicetype_;
}
inline ::std::string* TMTWbParse_Keda_User::release_devicetype() {
  clear_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicetype_;
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    delete devicetype_;
  }
  if (devicetype) {
    set_has_devicetype();
    devicetype_ = devicetype;
  } else {
    clear_has_devicetype();
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 8;
inline bool TMTWbParse_Keda_User::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTWbParse_Keda_User::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTWbParse_Keda_User::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTWbParse_Keda_User::name() const {
  return *name_;
}
inline void TMTWbParse_Keda_User::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTWbParse_Keda_User::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTWbParse_Keda_User::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTWbParse_Keda_User::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extnum = 9;
inline bool TMTWbParse_Keda_User::has_extnum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_extnum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTWbParse_Keda_User::clear_has_extnum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTWbParse_Keda_User::clear_extnum() {
  if (extnum_ != &::google::protobuf::internal::kEmptyString) {
    extnum_->clear();
  }
  clear_has_extnum();
}
inline const ::std::string& TMTWbParse_Keda_User::extnum() const {
  return *extnum_;
}
inline void TMTWbParse_Keda_User::set_extnum(const ::std::string& value) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(value);
}
inline void TMTWbParse_Keda_User::set_extnum(const char* value) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(value);
}
inline void TMTWbParse_Keda_User::set_extnum(const char* value, size_t size) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_extnum() {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  return extnum_;
}
inline ::std::string* TMTWbParse_Keda_User::release_extnum() {
  clear_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extnum_;
    extnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_extnum(::std::string* extnum) {
  if (extnum_ != &::google::protobuf::internal::kEmptyString) {
    delete extnum_;
  }
  if (extnum) {
    set_has_extnum();
    extnum_ = extnum;
  } else {
    clear_has_extnum();
    extnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string seat = 10;
inline bool TMTWbParse_Keda_User::has_seat() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_seat() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTWbParse_Keda_User::clear_has_seat() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTWbParse_Keda_User::clear_seat() {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    seat_->clear();
  }
  clear_has_seat();
}
inline const ::std::string& TMTWbParse_Keda_User::seat() const {
  return *seat_;
}
inline void TMTWbParse_Keda_User::set_seat(const ::std::string& value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void TMTWbParse_Keda_User::set_seat(const char* value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void TMTWbParse_Keda_User::set_seat(const char* value, size_t size) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_seat() {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  return seat_;
}
inline ::std::string* TMTWbParse_Keda_User::release_seat() {
  clear_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seat_;
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_seat(::std::string* seat) {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    delete seat_;
  }
  if (seat) {
    set_has_seat();
    seat_ = seat;
  } else {
    clear_has_seat();
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brief = 11;
inline bool TMTWbParse_Keda_User::has_brief() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_brief() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTWbParse_Keda_User::clear_has_brief() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTWbParse_Keda_User::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TMTWbParse_Keda_User::brief() const {
  return *brief_;
}
inline void TMTWbParse_Keda_User::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTWbParse_Keda_User::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTWbParse_Keda_User::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TMTWbParse_Keda_User::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portrait40 = 12;
inline bool TMTWbParse_Keda_User::has_portrait40() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_portrait40() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTWbParse_Keda_User::clear_has_portrait40() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTWbParse_Keda_User::clear_portrait40() {
  if (portrait40_ != &::google::protobuf::internal::kEmptyString) {
    portrait40_->clear();
  }
  clear_has_portrait40();
}
inline const ::std::string& TMTWbParse_Keda_User::portrait40() const {
  return *portrait40_;
}
inline void TMTWbParse_Keda_User::set_portrait40(const ::std::string& value) {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  portrait40_->assign(value);
}
inline void TMTWbParse_Keda_User::set_portrait40(const char* value) {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  portrait40_->assign(value);
}
inline void TMTWbParse_Keda_User::set_portrait40(const char* value, size_t size) {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  portrait40_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_portrait40() {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  return portrait40_;
}
inline ::std::string* TMTWbParse_Keda_User::release_portrait40() {
  clear_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portrait40_;
    portrait40_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_portrait40(::std::string* portrait40) {
  if (portrait40_ != &::google::protobuf::internal::kEmptyString) {
    delete portrait40_;
  }
  if (portrait40) {
    set_has_portrait40();
    portrait40_ = portrait40;
  } else {
    clear_has_portrait40();
    portrait40_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portrait64 = 13;
inline bool TMTWbParse_Keda_User::has_portrait64() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_portrait64() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTWbParse_Keda_User::clear_has_portrait64() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTWbParse_Keda_User::clear_portrait64() {
  if (portrait64_ != &::google::protobuf::internal::kEmptyString) {
    portrait64_->clear();
  }
  clear_has_portrait64();
}
inline const ::std::string& TMTWbParse_Keda_User::portrait64() const {
  return *portrait64_;
}
inline void TMTWbParse_Keda_User::set_portrait64(const ::std::string& value) {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  portrait64_->assign(value);
}
inline void TMTWbParse_Keda_User::set_portrait64(const char* value) {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  portrait64_->assign(value);
}
inline void TMTWbParse_Keda_User::set_portrait64(const char* value, size_t size) {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  portrait64_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_portrait64() {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  return portrait64_;
}
inline ::std::string* TMTWbParse_Keda_User::release_portrait64() {
  clear_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portrait64_;
    portrait64_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_portrait64(::std::string* portrait64) {
  if (portrait64_ != &::google::protobuf::internal::kEmptyString) {
    delete portrait64_;
  }
  if (portrait64) {
    set_has_portrait64();
    portrait64_ = portrait64;
  } else {
    clear_has_portrait64();
    portrait64_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portrait128 = 14;
inline bool TMTWbParse_Keda_User::has_portrait128() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_portrait128() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTWbParse_Keda_User::clear_has_portrait128() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTWbParse_Keda_User::clear_portrait128() {
  if (portrait128_ != &::google::protobuf::internal::kEmptyString) {
    portrait128_->clear();
  }
  clear_has_portrait128();
}
inline const ::std::string& TMTWbParse_Keda_User::portrait128() const {
  return *portrait128_;
}
inline void TMTWbParse_Keda_User::set_portrait128(const ::std::string& value) {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  portrait128_->assign(value);
}
inline void TMTWbParse_Keda_User::set_portrait128(const char* value) {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  portrait128_->assign(value);
}
inline void TMTWbParse_Keda_User::set_portrait128(const char* value, size_t size) {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  portrait128_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_User::mutable_portrait128() {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  return portrait128_;
}
inline ::std::string* TMTWbParse_Keda_User::release_portrait128() {
  clear_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portrait128_;
    portrait128_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_User::set_allocated_portrait128(::std::string* portrait128) {
  if (portrait128_ != &::google::protobuf::internal::kEmptyString) {
    delete portrait128_;
  }
  if (portrait128) {
    set_has_portrait128();
    portrait128_ = portrait128;
  } else {
    clear_has_portrait128();
    portrait128_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 departmentid = 15;
inline bool TMTWbParse_Keda_User::has_departmentid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTWbParse_Keda_User::set_has_departmentid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTWbParse_Keda_User::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTWbParse_Keda_User::clear_departmentid() {
  departmentid_ = 0u;
  clear_has_departmentid();
}
inline ::google::protobuf::uint32 TMTWbParse_Keda_User::departmentid() const {
  return departmentid_;
}
inline void TMTWbParse_Keda_User::set_departmentid(::google::protobuf::uint32 value) {
  set_has_departmentid();
  departmentid_ = value;
}

// -------------------------------------------------------------------

// TMTWbParse_Keda_departmentUsers

// optional uint32 userNum = 1;
inline bool TMTWbParse_Keda_departmentUsers::has_usernum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParse_Keda_departmentUsers::set_has_usernum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParse_Keda_departmentUsers::clear_has_usernum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParse_Keda_departmentUsers::clear_usernum() {
  usernum_ = 0u;
  clear_has_usernum();
}
inline ::google::protobuf::uint32 TMTWbParse_Keda_departmentUsers::usernum() const {
  return usernum_;
}
inline void TMTWbParse_Keda_departmentUsers::set_usernum(::google::protobuf::uint32 value) {
  set_has_usernum();
  usernum_ = value;
}

// repeated .mt.TMTWbParse_Keda_User user = 2;
inline int TMTWbParse_Keda_departmentUsers::user_size() const {
  return user_.size();
}
inline void TMTWbParse_Keda_departmentUsers::clear_user() {
  user_.Clear();
}
inline const ::mt::TMTWbParse_Keda_User& TMTWbParse_Keda_departmentUsers::user(int index) const {
  return user_.Get(index);
}
inline ::mt::TMTWbParse_Keda_User* TMTWbParse_Keda_departmentUsers::mutable_user(int index) {
  return user_.Mutable(index);
}
inline ::mt::TMTWbParse_Keda_User* TMTWbParse_Keda_departmentUsers::add_user() {
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_User >&
TMTWbParse_Keda_departmentUsers::user() const {
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_User >*
TMTWbParse_Keda_departmentUsers::mutable_user() {
  return &user_;
}

// -------------------------------------------------------------------

// TMTWbParse_Keda_Department

// optional string moid = 1;
inline bool TMTWbParse_Keda_Department::has_moid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParse_Keda_Department::set_has_moid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParse_Keda_Department::clear_has_moid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParse_Keda_Department::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTWbParse_Keda_Department::moid() const {
  return *moid_;
}
inline void TMTWbParse_Keda_Department::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTWbParse_Keda_Department::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTWbParse_Keda_Department::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_Department::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTWbParse_Keda_Department::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_Department::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 departmentid = 2;
inline bool TMTWbParse_Keda_Department::has_departmentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTWbParse_Keda_Department::set_has_departmentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTWbParse_Keda_Department::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTWbParse_Keda_Department::clear_departmentid() {
  departmentid_ = 0u;
  clear_has_departmentid();
}
inline ::google::protobuf::uint32 TMTWbParse_Keda_Department::departmentid() const {
  return departmentid_;
}
inline void TMTWbParse_Keda_Department::set_departmentid(::google::protobuf::uint32 value) {
  set_has_departmentid();
  departmentid_ = value;
}

// optional string departmentname = 3;
inline bool TMTWbParse_Keda_Department::has_departmentname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTWbParse_Keda_Department::set_has_departmentname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTWbParse_Keda_Department::clear_has_departmentname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTWbParse_Keda_Department::clear_departmentname() {
  if (departmentname_ != &::google::protobuf::internal::kEmptyString) {
    departmentname_->clear();
  }
  clear_has_departmentname();
}
inline const ::std::string& TMTWbParse_Keda_Department::departmentname() const {
  return *departmentname_;
}
inline void TMTWbParse_Keda_Department::set_departmentname(const ::std::string& value) {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  departmentname_->assign(value);
}
inline void TMTWbParse_Keda_Department::set_departmentname(const char* value) {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  departmentname_->assign(value);
}
inline void TMTWbParse_Keda_Department::set_departmentname(const char* value, size_t size) {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  departmentname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_Department::mutable_departmentname() {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  return departmentname_;
}
inline ::std::string* TMTWbParse_Keda_Department::release_departmentname() {
  clear_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentname_;
    departmentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_Department::set_allocated_departmentname(::std::string* departmentname) {
  if (departmentname_ != &::google::protobuf::internal::kEmptyString) {
    delete departmentname_;
  }
  if (departmentname) {
    set_has_departmentname();
    departmentname_ = departmentname;
  } else {
    clear_has_departmentname();
    departmentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 parentid = 4;
inline bool TMTWbParse_Keda_Department::has_parentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTWbParse_Keda_Department::set_has_parentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTWbParse_Keda_Department::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTWbParse_Keda_Department::clear_parentid() {
  parentid_ = 0u;
  clear_has_parentid();
}
inline ::google::protobuf::uint32 TMTWbParse_Keda_Department::parentid() const {
  return parentid_;
}
inline void TMTWbParse_Keda_Department::set_parentid(::google::protobuf::uint32 value) {
  set_has_parentid();
  parentid_ = value;
}

// optional string leaf = 5;
inline bool TMTWbParse_Keda_Department::has_leaf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTWbParse_Keda_Department::set_has_leaf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTWbParse_Keda_Department::clear_has_leaf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTWbParse_Keda_Department::clear_leaf() {
  if (leaf_ != &::google::protobuf::internal::kEmptyString) {
    leaf_->clear();
  }
  clear_has_leaf();
}
inline const ::std::string& TMTWbParse_Keda_Department::leaf() const {
  return *leaf_;
}
inline void TMTWbParse_Keda_Department::set_leaf(const ::std::string& value) {
  set_has_leaf();
  if (leaf_ == &::google::protobuf::internal::kEmptyString) {
    leaf_ = new ::std::string;
  }
  leaf_->assign(value);
}
inline void TMTWbParse_Keda_Department::set_leaf(const char* value) {
  set_has_leaf();
  if (leaf_ == &::google::protobuf::internal::kEmptyString) {
    leaf_ = new ::std::string;
  }
  leaf_->assign(value);
}
inline void TMTWbParse_Keda_Department::set_leaf(const char* value, size_t size) {
  set_has_leaf();
  if (leaf_ == &::google::protobuf::internal::kEmptyString) {
    leaf_ = new ::std::string;
  }
  leaf_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_Department::mutable_leaf() {
  set_has_leaf();
  if (leaf_ == &::google::protobuf::internal::kEmptyString) {
    leaf_ = new ::std::string;
  }
  return leaf_;
}
inline ::std::string* TMTWbParse_Keda_Department::release_leaf() {
  clear_has_leaf();
  if (leaf_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leaf_;
    leaf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_Department::set_allocated_leaf(::std::string* leaf) {
  if (leaf_ != &::google::protobuf::internal::kEmptyString) {
    delete leaf_;
  }
  if (leaf) {
    set_has_leaf();
    leaf_ = leaf;
  } else {
    clear_has_leaf();
    leaf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 seqnumber = 6;
inline bool TMTWbParse_Keda_Department::has_seqnumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTWbParse_Keda_Department::set_has_seqnumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTWbParse_Keda_Department::clear_has_seqnumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTWbParse_Keda_Department::clear_seqnumber() {
  seqnumber_ = 0u;
  clear_has_seqnumber();
}
inline ::google::protobuf::uint32 TMTWbParse_Keda_Department::seqnumber() const {
  return seqnumber_;
}
inline void TMTWbParse_Keda_Department::set_seqnumber(::google::protobuf::uint32 value) {
  set_has_seqnumber();
  seqnumber_ = value;
}

// -------------------------------------------------------------------

// TMTWbParse_Keda_Departments

// optional uint32 departmentnum = 1;
inline bool TMTWbParse_Keda_Departments::has_departmentnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParse_Keda_Departments::set_has_departmentnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParse_Keda_Departments::clear_has_departmentnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParse_Keda_Departments::clear_departmentnum() {
  departmentnum_ = 0u;
  clear_has_departmentnum();
}
inline ::google::protobuf::uint32 TMTWbParse_Keda_Departments::departmentnum() const {
  return departmentnum_;
}
inline void TMTWbParse_Keda_Departments::set_departmentnum(::google::protobuf::uint32 value) {
  set_has_departmentnum();
  departmentnum_ = value;
}

// repeated .mt.TMTWbParse_Keda_Department department = 2;
inline int TMTWbParse_Keda_Departments::department_size() const {
  return department_.size();
}
inline void TMTWbParse_Keda_Departments::clear_department() {
  department_.Clear();
}
inline const ::mt::TMTWbParse_Keda_Department& TMTWbParse_Keda_Departments::department(int index) const {
  return department_.Get(index);
}
inline ::mt::TMTWbParse_Keda_Department* TMTWbParse_Keda_Departments::mutable_department(int index) {
  return department_.Mutable(index);
}
inline ::mt::TMTWbParse_Keda_Department* TMTWbParse_Keda_Departments::add_department() {
  return department_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_Department >&
TMTWbParse_Keda_Departments::department() const {
  return department_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_Department >*
TMTWbParse_Keda_Departments::mutable_department() {
  return &department_;
}

// -------------------------------------------------------------------

// TMTWeiboLogin

// optional string username = 1;
inline bool TMTWeiboLogin::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWeiboLogin::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWeiboLogin::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWeiboLogin::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMTWeiboLogin::username() const {
  return *username_;
}
inline void TMTWeiboLogin::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTWeiboLogin::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTWeiboLogin::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWeiboLogin::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMTWeiboLogin::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWeiboLogin::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool TMTWeiboLogin::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTWeiboLogin::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTWeiboLogin::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTWeiboLogin::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTWeiboLogin::password() const {
  return *password_;
}
inline void TMTWeiboLogin::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTWeiboLogin::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTWeiboLogin::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWeiboLogin::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTWeiboLogin::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWeiboLogin::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TOauth

// optional string oauth_consumer_key = 1;
inline bool TOauth::has_oauth_consumer_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOauth::set_has_oauth_consumer_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOauth::clear_has_oauth_consumer_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOauth::clear_oauth_consumer_key() {
  if (oauth_consumer_key_ != &::google::protobuf::internal::kEmptyString) {
    oauth_consumer_key_->clear();
  }
  clear_has_oauth_consumer_key();
}
inline const ::std::string& TOauth::oauth_consumer_key() const {
  return *oauth_consumer_key_;
}
inline void TOauth::set_oauth_consumer_key(const ::std::string& value) {
  set_has_oauth_consumer_key();
  if (oauth_consumer_key_ == &::google::protobuf::internal::kEmptyString) {
    oauth_consumer_key_ = new ::std::string;
  }
  oauth_consumer_key_->assign(value);
}
inline void TOauth::set_oauth_consumer_key(const char* value) {
  set_has_oauth_consumer_key();
  if (oauth_consumer_key_ == &::google::protobuf::internal::kEmptyString) {
    oauth_consumer_key_ = new ::std::string;
  }
  oauth_consumer_key_->assign(value);
}
inline void TOauth::set_oauth_consumer_key(const char* value, size_t size) {
  set_has_oauth_consumer_key();
  if (oauth_consumer_key_ == &::google::protobuf::internal::kEmptyString) {
    oauth_consumer_key_ = new ::std::string;
  }
  oauth_consumer_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TOauth::mutable_oauth_consumer_key() {
  set_has_oauth_consumer_key();
  if (oauth_consumer_key_ == &::google::protobuf::internal::kEmptyString) {
    oauth_consumer_key_ = new ::std::string;
  }
  return oauth_consumer_key_;
}
inline ::std::string* TOauth::release_oauth_consumer_key() {
  clear_has_oauth_consumer_key();
  if (oauth_consumer_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oauth_consumer_key_;
    oauth_consumer_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TOauth::set_allocated_oauth_consumer_key(::std::string* oauth_consumer_key) {
  if (oauth_consumer_key_ != &::google::protobuf::internal::kEmptyString) {
    delete oauth_consumer_key_;
  }
  if (oauth_consumer_key) {
    set_has_oauth_consumer_key();
    oauth_consumer_key_ = oauth_consumer_key;
  } else {
    clear_has_oauth_consumer_key();
    oauth_consumer_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string oauth_consumer_secret = 2;
inline bool TOauth::has_oauth_consumer_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TOauth::set_has_oauth_consumer_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TOauth::clear_has_oauth_consumer_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TOauth::clear_oauth_consumer_secret() {
  if (oauth_consumer_secret_ != &::google::protobuf::internal::kEmptyString) {
    oauth_consumer_secret_->clear();
  }
  clear_has_oauth_consumer_secret();
}
inline const ::std::string& TOauth::oauth_consumer_secret() const {
  return *oauth_consumer_secret_;
}
inline void TOauth::set_oauth_consumer_secret(const ::std::string& value) {
  set_has_oauth_consumer_secret();
  if (oauth_consumer_secret_ == &::google::protobuf::internal::kEmptyString) {
    oauth_consumer_secret_ = new ::std::string;
  }
  oauth_consumer_secret_->assign(value);
}
inline void TOauth::set_oauth_consumer_secret(const char* value) {
  set_has_oauth_consumer_secret();
  if (oauth_consumer_secret_ == &::google::protobuf::internal::kEmptyString) {
    oauth_consumer_secret_ = new ::std::string;
  }
  oauth_consumer_secret_->assign(value);
}
inline void TOauth::set_oauth_consumer_secret(const char* value, size_t size) {
  set_has_oauth_consumer_secret();
  if (oauth_consumer_secret_ == &::google::protobuf::internal::kEmptyString) {
    oauth_consumer_secret_ = new ::std::string;
  }
  oauth_consumer_secret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TOauth::mutable_oauth_consumer_secret() {
  set_has_oauth_consumer_secret();
  if (oauth_consumer_secret_ == &::google::protobuf::internal::kEmptyString) {
    oauth_consumer_secret_ = new ::std::string;
  }
  return oauth_consumer_secret_;
}
inline ::std::string* TOauth::release_oauth_consumer_secret() {
  clear_has_oauth_consumer_secret();
  if (oauth_consumer_secret_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oauth_consumer_secret_;
    oauth_consumer_secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TOauth::set_allocated_oauth_consumer_secret(::std::string* oauth_consumer_secret) {
  if (oauth_consumer_secret_ != &::google::protobuf::internal::kEmptyString) {
    delete oauth_consumer_secret_;
  }
  if (oauth_consumer_secret) {
    set_has_oauth_consumer_secret();
    oauth_consumer_secret_ = oauth_consumer_secret;
  } else {
    clear_has_oauth_consumer_secret();
    oauth_consumer_secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string server_ip = 3;
inline bool TOauth::has_server_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TOauth::set_has_server_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TOauth::clear_has_server_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TOauth::clear_server_ip() {
  if (server_ip_ != &::google::protobuf::internal::kEmptyString) {
    server_ip_->clear();
  }
  clear_has_server_ip();
}
inline const ::std::string& TOauth::server_ip() const {
  return *server_ip_;
}
inline void TOauth::set_server_ip(const ::std::string& value) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(value);
}
inline void TOauth::set_server_ip(const char* value) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(value);
}
inline void TOauth::set_server_ip(const char* value, size_t size) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TOauth::mutable_server_ip() {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  return server_ip_;
}
inline ::std::string* TOauth::release_server_ip() {
  clear_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_ip_;
    server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TOauth::set_allocated_server_ip(::std::string* server_ip) {
  if (server_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete server_ip_;
  }
  if (server_ip) {
    set_has_server_ip();
    server_ip_ = server_ip;
  } else {
    clear_has_server_ip();
    server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTWbParse_Keda_EntConfig

// optional string xmppdomain = 1;
inline bool TMTWbParse_Keda_EntConfig::has_xmppdomain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParse_Keda_EntConfig::set_has_xmppdomain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParse_Keda_EntConfig::clear_has_xmppdomain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParse_Keda_EntConfig::clear_xmppdomain() {
  if (xmppdomain_ != &::google::protobuf::internal::kEmptyString) {
    xmppdomain_->clear();
  }
  clear_has_xmppdomain();
}
inline const ::std::string& TMTWbParse_Keda_EntConfig::xmppdomain() const {
  return *xmppdomain_;
}
inline void TMTWbParse_Keda_EntConfig::set_xmppdomain(const ::std::string& value) {
  set_has_xmppdomain();
  if (xmppdomain_ == &::google::protobuf::internal::kEmptyString) {
    xmppdomain_ = new ::std::string;
  }
  xmppdomain_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_xmppdomain(const char* value) {
  set_has_xmppdomain();
  if (xmppdomain_ == &::google::protobuf::internal::kEmptyString) {
    xmppdomain_ = new ::std::string;
  }
  xmppdomain_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_xmppdomain(const char* value, size_t size) {
  set_has_xmppdomain();
  if (xmppdomain_ == &::google::protobuf::internal::kEmptyString) {
    xmppdomain_ = new ::std::string;
  }
  xmppdomain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntConfig::mutable_xmppdomain() {
  set_has_xmppdomain();
  if (xmppdomain_ == &::google::protobuf::internal::kEmptyString) {
    xmppdomain_ = new ::std::string;
  }
  return xmppdomain_;
}
inline ::std::string* TMTWbParse_Keda_EntConfig::release_xmppdomain() {
  clear_has_xmppdomain();
  if (xmppdomain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmppdomain_;
    xmppdomain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntConfig::set_allocated_xmppdomain(::std::string* xmppdomain) {
  if (xmppdomain_ != &::google::protobuf::internal::kEmptyString) {
    delete xmppdomain_;
  }
  if (xmppdomain) {
    set_has_xmppdomain();
    xmppdomain_ = xmppdomain;
  } else {
    clear_has_xmppdomain();
    xmppdomain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string apiurl = 2;
inline bool TMTWbParse_Keda_EntConfig::has_apiurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTWbParse_Keda_EntConfig::set_has_apiurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTWbParse_Keda_EntConfig::clear_has_apiurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTWbParse_Keda_EntConfig::clear_apiurl() {
  if (apiurl_ != &::google::protobuf::internal::kEmptyString) {
    apiurl_->clear();
  }
  clear_has_apiurl();
}
inline const ::std::string& TMTWbParse_Keda_EntConfig::apiurl() const {
  return *apiurl_;
}
inline void TMTWbParse_Keda_EntConfig::set_apiurl(const ::std::string& value) {
  set_has_apiurl();
  if (apiurl_ == &::google::protobuf::internal::kEmptyString) {
    apiurl_ = new ::std::string;
  }
  apiurl_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_apiurl(const char* value) {
  set_has_apiurl();
  if (apiurl_ == &::google::protobuf::internal::kEmptyString) {
    apiurl_ = new ::std::string;
  }
  apiurl_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_apiurl(const char* value, size_t size) {
  set_has_apiurl();
  if (apiurl_ == &::google::protobuf::internal::kEmptyString) {
    apiurl_ = new ::std::string;
  }
  apiurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntConfig::mutable_apiurl() {
  set_has_apiurl();
  if (apiurl_ == &::google::protobuf::internal::kEmptyString) {
    apiurl_ = new ::std::string;
  }
  return apiurl_;
}
inline ::std::string* TMTWbParse_Keda_EntConfig::release_apiurl() {
  clear_has_apiurl();
  if (apiurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = apiurl_;
    apiurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntConfig::set_allocated_apiurl(::std::string* apiurl) {
  if (apiurl_ != &::google::protobuf::internal::kEmptyString) {
    delete apiurl_;
  }
  if (apiurl) {
    set_has_apiurl();
    apiurl_ = apiurl;
  } else {
    clear_has_apiurl();
    apiurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string weibourl = 3;
inline bool TMTWbParse_Keda_EntConfig::has_weibourl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTWbParse_Keda_EntConfig::set_has_weibourl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTWbParse_Keda_EntConfig::clear_has_weibourl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTWbParse_Keda_EntConfig::clear_weibourl() {
  if (weibourl_ != &::google::protobuf::internal::kEmptyString) {
    weibourl_->clear();
  }
  clear_has_weibourl();
}
inline const ::std::string& TMTWbParse_Keda_EntConfig::weibourl() const {
  return *weibourl_;
}
inline void TMTWbParse_Keda_EntConfig::set_weibourl(const ::std::string& value) {
  set_has_weibourl();
  if (weibourl_ == &::google::protobuf::internal::kEmptyString) {
    weibourl_ = new ::std::string;
  }
  weibourl_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_weibourl(const char* value) {
  set_has_weibourl();
  if (weibourl_ == &::google::protobuf::internal::kEmptyString) {
    weibourl_ = new ::std::string;
  }
  weibourl_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_weibourl(const char* value, size_t size) {
  set_has_weibourl();
  if (weibourl_ == &::google::protobuf::internal::kEmptyString) {
    weibourl_ = new ::std::string;
  }
  weibourl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntConfig::mutable_weibourl() {
  set_has_weibourl();
  if (weibourl_ == &::google::protobuf::internal::kEmptyString) {
    weibourl_ = new ::std::string;
  }
  return weibourl_;
}
inline ::std::string* TMTWbParse_Keda_EntConfig::release_weibourl() {
  clear_has_weibourl();
  if (weibourl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weibourl_;
    weibourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntConfig::set_allocated_weibourl(::std::string* weibourl) {
  if (weibourl_ != &::google::protobuf::internal::kEmptyString) {
    delete weibourl_;
  }
  if (weibourl) {
    set_has_weibourl();
    weibourl_ = weibourl;
  } else {
    clear_has_weibourl();
    weibourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string webimUrl = 4;
inline bool TMTWbParse_Keda_EntConfig::has_webimurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTWbParse_Keda_EntConfig::set_has_webimurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTWbParse_Keda_EntConfig::clear_has_webimurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTWbParse_Keda_EntConfig::clear_webimurl() {
  if (webimurl_ != &::google::protobuf::internal::kEmptyString) {
    webimurl_->clear();
  }
  clear_has_webimurl();
}
inline const ::std::string& TMTWbParse_Keda_EntConfig::webimurl() const {
  return *webimurl_;
}
inline void TMTWbParse_Keda_EntConfig::set_webimurl(const ::std::string& value) {
  set_has_webimurl();
  if (webimurl_ == &::google::protobuf::internal::kEmptyString) {
    webimurl_ = new ::std::string;
  }
  webimurl_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_webimurl(const char* value) {
  set_has_webimurl();
  if (webimurl_ == &::google::protobuf::internal::kEmptyString) {
    webimurl_ = new ::std::string;
  }
  webimurl_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_webimurl(const char* value, size_t size) {
  set_has_webimurl();
  if (webimurl_ == &::google::protobuf::internal::kEmptyString) {
    webimurl_ = new ::std::string;
  }
  webimurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntConfig::mutable_webimurl() {
  set_has_webimurl();
  if (webimurl_ == &::google::protobuf::internal::kEmptyString) {
    webimurl_ = new ::std::string;
  }
  return webimurl_;
}
inline ::std::string* TMTWbParse_Keda_EntConfig::release_webimurl() {
  clear_has_webimurl();
  if (webimurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = webimurl_;
    webimurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntConfig::set_allocated_webimurl(::std::string* webimurl) {
  if (webimurl_ != &::google::protobuf::internal::kEmptyString) {
    delete webimurl_;
  }
  if (webimurl) {
    set_has_webimurl();
    webimurl_ = webimurl;
  } else {
    clear_has_webimurl();
    webimurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tcpimUrl = 5;
inline bool TMTWbParse_Keda_EntConfig::has_tcpimurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTWbParse_Keda_EntConfig::set_has_tcpimurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTWbParse_Keda_EntConfig::clear_has_tcpimurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTWbParse_Keda_EntConfig::clear_tcpimurl() {
  if (tcpimurl_ != &::google::protobuf::internal::kEmptyString) {
    tcpimurl_->clear();
  }
  clear_has_tcpimurl();
}
inline const ::std::string& TMTWbParse_Keda_EntConfig::tcpimurl() const {
  return *tcpimurl_;
}
inline void TMTWbParse_Keda_EntConfig::set_tcpimurl(const ::std::string& value) {
  set_has_tcpimurl();
  if (tcpimurl_ == &::google::protobuf::internal::kEmptyString) {
    tcpimurl_ = new ::std::string;
  }
  tcpimurl_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_tcpimurl(const char* value) {
  set_has_tcpimurl();
  if (tcpimurl_ == &::google::protobuf::internal::kEmptyString) {
    tcpimurl_ = new ::std::string;
  }
  tcpimurl_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_tcpimurl(const char* value, size_t size) {
  set_has_tcpimurl();
  if (tcpimurl_ == &::google::protobuf::internal::kEmptyString) {
    tcpimurl_ = new ::std::string;
  }
  tcpimurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntConfig::mutable_tcpimurl() {
  set_has_tcpimurl();
  if (tcpimurl_ == &::google::protobuf::internal::kEmptyString) {
    tcpimurl_ = new ::std::string;
  }
  return tcpimurl_;
}
inline ::std::string* TMTWbParse_Keda_EntConfig::release_tcpimurl() {
  clear_has_tcpimurl();
  if (tcpimurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tcpimurl_;
    tcpimurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntConfig::set_allocated_tcpimurl(::std::string* tcpimurl) {
  if (tcpimurl_ != &::google::protobuf::internal::kEmptyString) {
    delete tcpimurl_;
  }
  if (tcpimurl) {
    set_has_tcpimurl();
    tcpimurl_ = tcpimurl;
  } else {
    clear_has_tcpimurl();
    tcpimurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tcpport = 6;
inline bool TMTWbParse_Keda_EntConfig::has_tcpport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTWbParse_Keda_EntConfig::set_has_tcpport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTWbParse_Keda_EntConfig::clear_has_tcpport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTWbParse_Keda_EntConfig::clear_tcpport() {
  if (tcpport_ != &::google::protobuf::internal::kEmptyString) {
    tcpport_->clear();
  }
  clear_has_tcpport();
}
inline const ::std::string& TMTWbParse_Keda_EntConfig::tcpport() const {
  return *tcpport_;
}
inline void TMTWbParse_Keda_EntConfig::set_tcpport(const ::std::string& value) {
  set_has_tcpport();
  if (tcpport_ == &::google::protobuf::internal::kEmptyString) {
    tcpport_ = new ::std::string;
  }
  tcpport_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_tcpport(const char* value) {
  set_has_tcpport();
  if (tcpport_ == &::google::protobuf::internal::kEmptyString) {
    tcpport_ = new ::std::string;
  }
  tcpport_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_tcpport(const char* value, size_t size) {
  set_has_tcpport();
  if (tcpport_ == &::google::protobuf::internal::kEmptyString) {
    tcpport_ = new ::std::string;
  }
  tcpport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntConfig::mutable_tcpport() {
  set_has_tcpport();
  if (tcpport_ == &::google::protobuf::internal::kEmptyString) {
    tcpport_ = new ::std::string;
  }
  return tcpport_;
}
inline ::std::string* TMTWbParse_Keda_EntConfig::release_tcpport() {
  clear_has_tcpport();
  if (tcpport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tcpport_;
    tcpport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntConfig::set_allocated_tcpport(::std::string* tcpport) {
  if (tcpport_ != &::google::protobuf::internal::kEmptyString) {
    delete tcpport_;
  }
  if (tcpport) {
    set_has_tcpport();
    tcpport_ = tcpport;
  } else {
    clear_has_tcpport();
    tcpport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ulsurl = 7;
inline bool TMTWbParse_Keda_EntConfig::has_ulsurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTWbParse_Keda_EntConfig::set_has_ulsurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTWbParse_Keda_EntConfig::clear_has_ulsurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTWbParse_Keda_EntConfig::clear_ulsurl() {
  if (ulsurl_ != &::google::protobuf::internal::kEmptyString) {
    ulsurl_->clear();
  }
  clear_has_ulsurl();
}
inline const ::std::string& TMTWbParse_Keda_EntConfig::ulsurl() const {
  return *ulsurl_;
}
inline void TMTWbParse_Keda_EntConfig::set_ulsurl(const ::std::string& value) {
  set_has_ulsurl();
  if (ulsurl_ == &::google::protobuf::internal::kEmptyString) {
    ulsurl_ = new ::std::string;
  }
  ulsurl_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_ulsurl(const char* value) {
  set_has_ulsurl();
  if (ulsurl_ == &::google::protobuf::internal::kEmptyString) {
    ulsurl_ = new ::std::string;
  }
  ulsurl_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_ulsurl(const char* value, size_t size) {
  set_has_ulsurl();
  if (ulsurl_ == &::google::protobuf::internal::kEmptyString) {
    ulsurl_ = new ::std::string;
  }
  ulsurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntConfig::mutable_ulsurl() {
  set_has_ulsurl();
  if (ulsurl_ == &::google::protobuf::internal::kEmptyString) {
    ulsurl_ = new ::std::string;
  }
  return ulsurl_;
}
inline ::std::string* TMTWbParse_Keda_EntConfig::release_ulsurl() {
  clear_has_ulsurl();
  if (ulsurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ulsurl_;
    ulsurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntConfig::set_allocated_ulsurl(::std::string* ulsurl) {
  if (ulsurl_ != &::google::protobuf::internal::kEmptyString) {
    delete ulsurl_;
  }
  if (ulsurl) {
    set_has_ulsurl();
    ulsurl_ = ulsurl;
  } else {
    clear_has_ulsurl();
    ulsurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ulsport = 8;
inline bool TMTWbParse_Keda_EntConfig::has_ulsport() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTWbParse_Keda_EntConfig::set_has_ulsport() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTWbParse_Keda_EntConfig::clear_has_ulsport() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTWbParse_Keda_EntConfig::clear_ulsport() {
  if (ulsport_ != &::google::protobuf::internal::kEmptyString) {
    ulsport_->clear();
  }
  clear_has_ulsport();
}
inline const ::std::string& TMTWbParse_Keda_EntConfig::ulsport() const {
  return *ulsport_;
}
inline void TMTWbParse_Keda_EntConfig::set_ulsport(const ::std::string& value) {
  set_has_ulsport();
  if (ulsport_ == &::google::protobuf::internal::kEmptyString) {
    ulsport_ = new ::std::string;
  }
  ulsport_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_ulsport(const char* value) {
  set_has_ulsport();
  if (ulsport_ == &::google::protobuf::internal::kEmptyString) {
    ulsport_ = new ::std::string;
  }
  ulsport_->assign(value);
}
inline void TMTWbParse_Keda_EntConfig::set_ulsport(const char* value, size_t size) {
  set_has_ulsport();
  if (ulsport_ == &::google::protobuf::internal::kEmptyString) {
    ulsport_ = new ::std::string;
  }
  ulsport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_EntConfig::mutable_ulsport() {
  set_has_ulsport();
  if (ulsport_ == &::google::protobuf::internal::kEmptyString) {
    ulsport_ = new ::std::string;
  }
  return ulsport_;
}
inline ::std::string* TMTWbParse_Keda_EntConfig::release_ulsport() {
  clear_has_ulsport();
  if (ulsport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ulsport_;
    ulsport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_EntConfig::set_allocated_ulsport(::std::string* ulsport) {
  if (ulsport_ != &::google::protobuf::internal::kEmptyString) {
    delete ulsport_;
  }
  if (ulsport) {
    set_has_ulsport();
    ulsport_ = ulsport;
  } else {
    clear_has_ulsport();
    ulsport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTWbParse_Keda_Result

// optional .mt.TMTWbParse_Keda_EntUser user = 1;
inline bool TMTWbParse_Keda_Result::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParse_Keda_Result::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParse_Keda_Result::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParse_Keda_Result::clear_user() {
  if (user_ != NULL) user_->::mt::TMTWbParse_Keda_EntUser::Clear();
  clear_has_user();
}
inline const ::mt::TMTWbParse_Keda_EntUser& TMTWbParse_Keda_Result::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::mt::TMTWbParse_Keda_EntUser* TMTWbParse_Keda_Result::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::mt::TMTWbParse_Keda_EntUser;
  return user_;
}
inline ::mt::TMTWbParse_Keda_EntUser* TMTWbParse_Keda_Result::release_user() {
  clear_has_user();
  ::mt::TMTWbParse_Keda_EntUser* temp = user_;
  user_ = NULL;
  return temp;
}
inline void TMTWbParse_Keda_Result::set_allocated_user(::mt::TMTWbParse_Keda_EntUser* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional .mt.TMTWbParse_Keda_EntConfig config = 2;
inline bool TMTWbParse_Keda_Result::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTWbParse_Keda_Result::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTWbParse_Keda_Result::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTWbParse_Keda_Result::clear_config() {
  if (config_ != NULL) config_->::mt::TMTWbParse_Keda_EntConfig::Clear();
  clear_has_config();
}
inline const ::mt::TMTWbParse_Keda_EntConfig& TMTWbParse_Keda_Result::config() const {
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::mt::TMTWbParse_Keda_EntConfig* TMTWbParse_Keda_Result::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::mt::TMTWbParse_Keda_EntConfig;
  return config_;
}
inline ::mt::TMTWbParse_Keda_EntConfig* TMTWbParse_Keda_Result::release_config() {
  clear_has_config();
  ::mt::TMTWbParse_Keda_EntConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void TMTWbParse_Keda_Result::set_allocated_config(::mt::TMTWbParse_Keda_EntConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
}

// -------------------------------------------------------------------

// TListNotifyByMax

// optional uint32 id = 1;
inline bool TListNotifyByMax::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TListNotifyByMax::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TListNotifyByMax::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TListNotifyByMax::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TListNotifyByMax::id() const {
  return id_;
}
inline void TListNotifyByMax::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 messagetype = 2;
inline bool TListNotifyByMax::has_messagetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TListNotifyByMax::set_has_messagetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TListNotifyByMax::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TListNotifyByMax::clear_messagetype() {
  messagetype_ = 0u;
  clear_has_messagetype();
}
inline ::google::protobuf::uint32 TListNotifyByMax::messagetype() const {
  return messagetype_;
}
inline void TListNotifyByMax::set_messagetype(::google::protobuf::uint32 value) {
  set_has_messagetype();
  messagetype_ = value;
}

// -------------------------------------------------------------------

// TIfExistLockByFormkey

// optional string formkey = 1;
inline bool TIfExistLockByFormkey::has_formkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TIfExistLockByFormkey::set_has_formkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TIfExistLockByFormkey::clear_has_formkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TIfExistLockByFormkey::clear_formkey() {
  if (formkey_ != &::google::protobuf::internal::kEmptyString) {
    formkey_->clear();
  }
  clear_has_formkey();
}
inline const ::std::string& TIfExistLockByFormkey::formkey() const {
  return *formkey_;
}
inline void TIfExistLockByFormkey::set_formkey(const ::std::string& value) {
  set_has_formkey();
  if (formkey_ == &::google::protobuf::internal::kEmptyString) {
    formkey_ = new ::std::string;
  }
  formkey_->assign(value);
}
inline void TIfExistLockByFormkey::set_formkey(const char* value) {
  set_has_formkey();
  if (formkey_ == &::google::protobuf::internal::kEmptyString) {
    formkey_ = new ::std::string;
  }
  formkey_->assign(value);
}
inline void TIfExistLockByFormkey::set_formkey(const char* value, size_t size) {
  set_has_formkey();
  if (formkey_ == &::google::protobuf::internal::kEmptyString) {
    formkey_ = new ::std::string;
  }
  formkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TIfExistLockByFormkey::mutable_formkey() {
  set_has_formkey();
  if (formkey_ == &::google::protobuf::internal::kEmptyString) {
    formkey_ = new ::std::string;
  }
  return formkey_;
}
inline ::std::string* TIfExistLockByFormkey::release_formkey() {
  clear_has_formkey();
  if (formkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = formkey_;
    formkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TIfExistLockByFormkey::set_allocated_formkey(::std::string* formkey) {
  if (formkey_ != &::google::protobuf::internal::kEmptyString) {
    delete formkey_;
  }
  if (formkey) {
    set_has_formkey();
    formkey_ = formkey;
  } else {
    clear_has_formkey();
    formkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TAppClearNotify

// optional string notifytype = 1;
inline bool TAppClearNotify::has_notifytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAppClearNotify::set_has_notifytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAppClearNotify::clear_has_notifytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAppClearNotify::clear_notifytype() {
  if (notifytype_ != &::google::protobuf::internal::kEmptyString) {
    notifytype_->clear();
  }
  clear_has_notifytype();
}
inline const ::std::string& TAppClearNotify::notifytype() const {
  return *notifytype_;
}
inline void TAppClearNotify::set_notifytype(const ::std::string& value) {
  set_has_notifytype();
  if (notifytype_ == &::google::protobuf::internal::kEmptyString) {
    notifytype_ = new ::std::string;
  }
  notifytype_->assign(value);
}
inline void TAppClearNotify::set_notifytype(const char* value) {
  set_has_notifytype();
  if (notifytype_ == &::google::protobuf::internal::kEmptyString) {
    notifytype_ = new ::std::string;
  }
  notifytype_->assign(value);
}
inline void TAppClearNotify::set_notifytype(const char* value, size_t size) {
  set_has_notifytype();
  if (notifytype_ == &::google::protobuf::internal::kEmptyString) {
    notifytype_ = new ::std::string;
  }
  notifytype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TAppClearNotify::mutable_notifytype() {
  set_has_notifytype();
  if (notifytype_ == &::google::protobuf::internal::kEmptyString) {
    notifytype_ = new ::std::string;
  }
  return notifytype_;
}
inline ::std::string* TAppClearNotify::release_notifytype() {
  clear_has_notifytype();
  if (notifytype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notifytype_;
    notifytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TAppClearNotify::set_allocated_notifytype(::std::string* notifytype) {
  if (notifytype_ != &::google::protobuf::internal::kEmptyString) {
    delete notifytype_;
  }
  if (notifytype) {
    set_has_notifytype();
    notifytype_ = notifytype;
  } else {
    clear_has_notifytype();
    notifytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMeetingUnlock

// optional string meetingformkey = 1;
inline bool TMeetingUnlock::has_meetingformkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMeetingUnlock::set_has_meetingformkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMeetingUnlock::clear_has_meetingformkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMeetingUnlock::clear_meetingformkey() {
  if (meetingformkey_ != &::google::protobuf::internal::kEmptyString) {
    meetingformkey_->clear();
  }
  clear_has_meetingformkey();
}
inline const ::std::string& TMeetingUnlock::meetingformkey() const {
  return *meetingformkey_;
}
inline void TMeetingUnlock::set_meetingformkey(const ::std::string& value) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(value);
}
inline void TMeetingUnlock::set_meetingformkey(const char* value) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(value);
}
inline void TMeetingUnlock::set_meetingformkey(const char* value, size_t size) {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  meetingformkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMeetingUnlock::mutable_meetingformkey() {
  set_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    meetingformkey_ = new ::std::string;
  }
  return meetingformkey_;
}
inline ::std::string* TMeetingUnlock::release_meetingformkey() {
  clear_has_meetingformkey();
  if (meetingformkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetingformkey_;
    meetingformkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMeetingUnlock::set_allocated_meetingformkey(::std::string* meetingformkey) {
  if (meetingformkey_ != &::google::protobuf::internal::kEmptyString) {
    delete meetingformkey_;
  }
  if (meetingformkey) {
    set_has_meetingformkey();
    meetingformkey_ = meetingformkey;
  } else {
    clear_has_meetingformkey();
    meetingformkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TRegularFeed

// optional uint32 regularid = 1;
inline bool TRegularFeed::has_regularid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRegularFeed::set_has_regularid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRegularFeed::clear_has_regularid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRegularFeed::clear_regularid() {
  regularid_ = 0u;
  clear_has_regularid();
}
inline ::google::protobuf::uint32 TRegularFeed::regularid() const {
  return regularid_;
}
inline void TRegularFeed::set_regularid(::google::protobuf::uint32 value) {
  set_has_regularid();
  regularid_ = value;
}

// optional bool accept = 2;
inline bool TRegularFeed::has_accept() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRegularFeed::set_has_accept() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRegularFeed::clear_has_accept() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRegularFeed::clear_accept() {
  accept_ = false;
  clear_has_accept();
}
inline bool TRegularFeed::accept() const {
  return accept_;
}
inline void TRegularFeed::set_accept(bool value) {
  set_has_accept();
  accept_ = value;
}

// optional uint32 jointype = 3;
inline bool TRegularFeed::has_jointype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TRegularFeed::set_has_jointype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TRegularFeed::clear_has_jointype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TRegularFeed::clear_jointype() {
  jointype_ = 0u;
  clear_has_jointype();
}
inline ::google::protobuf::uint32 TRegularFeed::jointype() const {
  return jointype_;
}
inline void TRegularFeed::set_jointype(::google::protobuf::uint32 value) {
  set_has_jointype();
  jointype_ = value;
}

// optional string participantno = 4;
inline bool TRegularFeed::has_participantno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TRegularFeed::set_has_participantno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TRegularFeed::clear_has_participantno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TRegularFeed::clear_participantno() {
  if (participantno_ != &::google::protobuf::internal::kEmptyString) {
    participantno_->clear();
  }
  clear_has_participantno();
}
inline const ::std::string& TRegularFeed::participantno() const {
  return *participantno_;
}
inline void TRegularFeed::set_participantno(const ::std::string& value) {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  participantno_->assign(value);
}
inline void TRegularFeed::set_participantno(const char* value) {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  participantno_->assign(value);
}
inline void TRegularFeed::set_participantno(const char* value, size_t size) {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  participantno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TRegularFeed::mutable_participantno() {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  return participantno_;
}
inline ::std::string* TRegularFeed::release_participantno() {
  clear_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = participantno_;
    participantno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TRegularFeed::set_allocated_participantno(::std::string* participantno) {
  if (participantno_ != &::google::protobuf::internal::kEmptyString) {
    delete participantno_;
  }
  if (participantno) {
    set_has_participantno();
    participantno_ = participantno;
  } else {
    clear_has_participantno();
    participantno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 rejectreason = 5;
inline bool TRegularFeed::has_rejectreason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TRegularFeed::set_has_rejectreason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TRegularFeed::clear_has_rejectreason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TRegularFeed::clear_rejectreason() {
  rejectreason_ = 0u;
  clear_has_rejectreason();
}
inline ::google::protobuf::uint32 TRegularFeed::rejectreason() const {
  return rejectreason_;
}
inline void TRegularFeed::set_rejectreason(::google::protobuf::uint32 value) {
  set_has_rejectreason();
  rejectreason_ = value;
}

// -------------------------------------------------------------------

// TMTAddressBook

// optional string moid = 1;
inline bool TMTAddressBook::has_moid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTAddressBook::set_has_moid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTAddressBook::clear_has_moid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTAddressBook::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTAddressBook::moid() const {
  return *moid_;
}
inline void TMTAddressBook::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTAddressBook::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTAddressBook::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddressBook::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTAddressBook::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddressBook::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jid = 2;
inline bool TMTAddressBook::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTAddressBook::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTAddressBook::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTAddressBook::clear_jid() {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    jid_->clear();
  }
  clear_has_jid();
}
inline const ::std::string& TMTAddressBook::jid() const {
  return *jid_;
}
inline void TMTAddressBook::set_jid(const ::std::string& value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTAddressBook::set_jid(const char* value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTAddressBook::set_jid(const char* value, size_t size) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddressBook::mutable_jid() {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  return jid_;
}
inline ::std::string* TMTAddressBook::release_jid() {
  clear_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jid_;
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddressBook::set_allocated_jid(::std::string* jid) {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    delete jid_;
  }
  if (jid) {
    set_has_jid();
    jid_ = jid;
  } else {
    clear_has_jid();
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 3;
inline bool TMTAddressBook::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTAddressBook::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTAddressBook::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTAddressBook::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTAddressBook::account() const {
  return *account_;
}
inline void TMTAddressBook::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTAddressBook::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTAddressBook::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddressBook::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTAddressBook::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddressBook::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 4;
inline bool TMTAddressBook::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTAddressBook::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTAddressBook::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTAddressBook::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTAddressBook::name() const {
  return *name_;
}
inline void TMTAddressBook::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTAddressBook::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTAddressBook::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddressBook::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTAddressBook::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddressBook::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 5;
inline bool TMTAddressBook::has_email() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTAddressBook::set_has_email() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTAddressBook::clear_has_email() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTAddressBook::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& TMTAddressBook::email() const {
  return *email_;
}
inline void TMTAddressBook::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTAddressBook::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTAddressBook::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddressBook::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* TMTAddressBook::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddressBook::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 6;
inline bool TMTAddressBook::has_e164() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTAddressBook::set_has_e164() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTAddressBook::clear_has_e164() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTAddressBook::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTAddressBook::e164() const {
  return *e164_;
}
inline void TMTAddressBook::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTAddressBook::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTAddressBook::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddressBook::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTAddressBook::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddressBook::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobilenum = 7;
inline bool TMTAddressBook::has_mobilenum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTAddressBook::set_has_mobilenum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTAddressBook::clear_has_mobilenum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTAddressBook::clear_mobilenum() {
  if (mobilenum_ != &::google::protobuf::internal::kEmptyString) {
    mobilenum_->clear();
  }
  clear_has_mobilenum();
}
inline const ::std::string& TMTAddressBook::mobilenum() const {
  return *mobilenum_;
}
inline void TMTAddressBook::set_mobilenum(const ::std::string& value) {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  mobilenum_->assign(value);
}
inline void TMTAddressBook::set_mobilenum(const char* value) {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  mobilenum_->assign(value);
}
inline void TMTAddressBook::set_mobilenum(const char* value, size_t size) {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  mobilenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddressBook::mutable_mobilenum() {
  set_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    mobilenum_ = new ::std::string;
  }
  return mobilenum_;
}
inline ::std::string* TMTAddressBook::release_mobilenum() {
  clear_has_mobilenum();
  if (mobilenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilenum_;
    mobilenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddressBook::set_allocated_mobilenum(::std::string* mobilenum) {
  if (mobilenum_ != &::google::protobuf::internal::kEmptyString) {
    delete mobilenum_;
  }
  if (mobilenum) {
    set_has_mobilenum();
    mobilenum_ = mobilenum;
  } else {
    clear_has_mobilenum();
    mobilenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extnum = 8;
inline bool TMTAddressBook::has_extnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTAddressBook::set_has_extnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTAddressBook::clear_has_extnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTAddressBook::clear_extnum() {
  if (extnum_ != &::google::protobuf::internal::kEmptyString) {
    extnum_->clear();
  }
  clear_has_extnum();
}
inline const ::std::string& TMTAddressBook::extnum() const {
  return *extnum_;
}
inline void TMTAddressBook::set_extnum(const ::std::string& value) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(value);
}
inline void TMTAddressBook::set_extnum(const char* value) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(value);
}
inline void TMTAddressBook::set_extnum(const char* value, size_t size) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAddressBook::mutable_extnum() {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  return extnum_;
}
inline ::std::string* TMTAddressBook::release_extnum() {
  clear_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extnum_;
    extnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAddressBook::set_allocated_extnum(::std::string* extnum) {
  if (extnum_ != &::google::protobuf::internal::kEmptyString) {
    delete extnum_;
  }
  if (extnum) {
    set_has_extnum();
    extnum_ = extnum;
  } else {
    clear_has_extnum();
    extnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTAddressBooks

// optional uint32 addressNum = 1;
inline bool TMTAddressBooks::has_addressnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTAddressBooks::set_has_addressnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTAddressBooks::clear_has_addressnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTAddressBooks::clear_addressnum() {
  addressnum_ = 0u;
  clear_has_addressnum();
}
inline ::google::protobuf::uint32 TMTAddressBooks::addressnum() const {
  return addressnum_;
}
inline void TMTAddressBooks::set_addressnum(::google::protobuf::uint32 value) {
  set_has_addressnum();
  addressnum_ = value;
}

// repeated .mt.TMTAddressBook address = 2;
inline int TMTAddressBooks::address_size() const {
  return address_.size();
}
inline void TMTAddressBooks::clear_address() {
  address_.Clear();
}
inline const ::mt::TMTAddressBook& TMTAddressBooks::address(int index) const {
  return address_.Get(index);
}
inline ::mt::TMTAddressBook* TMTAddressBooks::mutable_address(int index) {
  return address_.Mutable(index);
}
inline ::mt::TMTAddressBook* TMTAddressBooks::add_address() {
  return address_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAddressBook >&
TMTAddressBooks::address() const {
  return address_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAddressBook >*
TMTAddressBooks::mutable_address() {
  return &address_;
}

// -------------------------------------------------------------------

// TDepartment

// optional string departmentid = 1;
inline bool TDepartment::has_departmentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDepartment::set_has_departmentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDepartment::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDepartment::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& TDepartment::departmentid() const {
  return *departmentid_;
}
inline void TDepartment::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void TDepartment::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void TDepartment::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDepartment::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* TDepartment::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDepartment::set_allocated_departmentid(::std::string* departmentid) {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete departmentid_;
  }
  if (departmentid) {
    set_has_departmentid();
    departmentid_ = departmentid;
  } else {
    clear_has_departmentid();
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string departmentname = 2;
inline bool TDepartment::has_departmentname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDepartment::set_has_departmentname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDepartment::clear_has_departmentname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDepartment::clear_departmentname() {
  if (departmentname_ != &::google::protobuf::internal::kEmptyString) {
    departmentname_->clear();
  }
  clear_has_departmentname();
}
inline const ::std::string& TDepartment::departmentname() const {
  return *departmentname_;
}
inline void TDepartment::set_departmentname(const ::std::string& value) {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  departmentname_->assign(value);
}
inline void TDepartment::set_departmentname(const char* value) {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  departmentname_->assign(value);
}
inline void TDepartment::set_departmentname(const char* value, size_t size) {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  departmentname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDepartment::mutable_departmentname() {
  set_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    departmentname_ = new ::std::string;
  }
  return departmentname_;
}
inline ::std::string* TDepartment::release_departmentname() {
  clear_has_departmentname();
  if (departmentname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentname_;
    departmentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDepartment::set_allocated_departmentname(::std::string* departmentname) {
  if (departmentname_ != &::google::protobuf::internal::kEmptyString) {
    delete departmentname_;
  }
  if (departmentname) {
    set_has_departmentname();
    departmentname_ = departmentname;
  } else {
    clear_has_departmentname();
    departmentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string username = 3;
inline bool TDepartment::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TDepartment::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TDepartment::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TDepartment::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TDepartment::username() const {
  return *username_;
}
inline void TDepartment::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TDepartment::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TDepartment::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDepartment::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TDepartment::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDepartment::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTConditionQuery

// optional string email = 1;
inline bool TMTConditionQuery::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConditionQuery::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConditionQuery::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConditionQuery::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& TMTConditionQuery::email() const {
  return *email_;
}
inline void TMTConditionQuery::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTConditionQuery::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTConditionQuery::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConditionQuery::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* TMTConditionQuery::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConditionQuery::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 2;
inline bool TMTConditionQuery::has_e164() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConditionQuery::set_has_e164() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConditionQuery::clear_has_e164() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConditionQuery::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTConditionQuery::e164() const {
  return *e164_;
}
inline void TMTConditionQuery::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTConditionQuery::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTConditionQuery::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConditionQuery::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTConditionQuery::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConditionQuery::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool TMTConditionQuery::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTConditionQuery::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTConditionQuery::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTConditionQuery::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTConditionQuery::name() const {
  return *name_;
}
inline void TMTConditionQuery::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTConditionQuery::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTConditionQuery::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConditionQuery::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTConditionQuery::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConditionQuery::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 4;
inline bool TMTConditionQuery::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTConditionQuery::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTConditionQuery::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTConditionQuery::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTConditionQuery::account() const {
  return *account_;
}
inline void TMTConditionQuery::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTConditionQuery::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTConditionQuery::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConditionQuery::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTConditionQuery::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConditionQuery::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobilephone = 5;
inline bool TMTConditionQuery::has_mobilephone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTConditionQuery::set_has_mobilephone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTConditionQuery::clear_has_mobilephone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTConditionQuery::clear_mobilephone() {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    mobilephone_->clear();
  }
  clear_has_mobilephone();
}
inline const ::std::string& TMTConditionQuery::mobilephone() const {
  return *mobilephone_;
}
inline void TMTConditionQuery::set_mobilephone(const ::std::string& value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void TMTConditionQuery::set_mobilephone(const char* value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void TMTConditionQuery::set_mobilephone(const char* value, size_t size) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConditionQuery::mutable_mobilephone() {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  return mobilephone_;
}
inline ::std::string* TMTConditionQuery::release_mobilephone() {
  clear_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilephone_;
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConditionQuery::set_allocated_mobilephone(::std::string* mobilephone) {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    delete mobilephone_;
  }
  if (mobilephone) {
    set_has_mobilephone();
    mobilephone_ = mobilephone;
  } else {
    clear_has_mobilephone();
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 inent = 6;
inline bool TMTConditionQuery::has_inent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTConditionQuery::set_has_inent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTConditionQuery::clear_has_inent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTConditionQuery::clear_inent() {
  inent_ = 0u;
  clear_has_inent();
}
inline ::google::protobuf::uint32 TMTConditionQuery::inent() const {
  return inent_;
}
inline void TMTConditionQuery::set_inent(::google::protobuf::uint32 value) {
  set_has_inent();
  inent_ = value;
}

// optional uint32 startrow = 7;
inline bool TMTConditionQuery::has_startrow() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTConditionQuery::set_has_startrow() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTConditionQuery::clear_has_startrow() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTConditionQuery::clear_startrow() {
  startrow_ = 0u;
  clear_has_startrow();
}
inline ::google::protobuf::uint32 TMTConditionQuery::startrow() const {
  return startrow_;
}
inline void TMTConditionQuery::set_startrow(::google::protobuf::uint32 value) {
  set_has_startrow();
  startrow_ = value;
}

// optional uint32 pagesize = 8;
inline bool TMTConditionQuery::has_pagesize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTConditionQuery::set_has_pagesize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTConditionQuery::clear_has_pagesize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTConditionQuery::clear_pagesize() {
  pagesize_ = 0u;
  clear_has_pagesize();
}
inline ::google::protobuf::uint32 TMTConditionQuery::pagesize() const {
  return pagesize_;
}
inline void TMTConditionQuery::set_pagesize(::google::protobuf::uint32 value) {
  set_has_pagesize();
  pagesize_ = value;
}

// -------------------------------------------------------------------

// TMTQueryUser

// optional uint32 usernum = 1;
inline bool TMTQueryUser::has_usernum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTQueryUser::set_has_usernum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTQueryUser::clear_has_usernum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTQueryUser::clear_usernum() {
  usernum_ = 0u;
  clear_has_usernum();
}
inline ::google::protobuf::uint32 TMTQueryUser::usernum() const {
  return usernum_;
}
inline void TMTQueryUser::set_usernum(::google::protobuf::uint32 value) {
  set_has_usernum();
  usernum_ = value;
}

// repeated string userno = 2;
inline int TMTQueryUser::userno_size() const {
  return userno_.size();
}
inline void TMTQueryUser::clear_userno() {
  userno_.Clear();
}
inline const ::std::string& TMTQueryUser::userno(int index) const {
  return userno_.Get(index);
}
inline ::std::string* TMTQueryUser::mutable_userno(int index) {
  return userno_.Mutable(index);
}
inline void TMTQueryUser::set_userno(int index, const ::std::string& value) {
  userno_.Mutable(index)->assign(value);
}
inline void TMTQueryUser::set_userno(int index, const char* value) {
  userno_.Mutable(index)->assign(value);
}
inline void TMTQueryUser::set_userno(int index, const char* value, size_t size) {
  userno_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTQueryUser::add_userno() {
  return userno_.Add();
}
inline void TMTQueryUser::add_userno(const ::std::string& value) {
  userno_.Add()->assign(value);
}
inline void TMTQueryUser::add_userno(const char* value) {
  userno_.Add()->assign(value);
}
inline void TMTQueryUser::add_userno(const char* value, size_t size) {
  userno_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TMTQueryUser::userno() const {
  return userno_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TMTQueryUser::mutable_userno() {
  return &userno_;
}

// -------------------------------------------------------------------

// TMTQueryPortrait

// optional .mt.EmMtPortrait mtportrait = 1;
inline bool TMTQueryPortrait::has_mtportrait() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTQueryPortrait::set_has_mtportrait() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTQueryPortrait::clear_has_mtportrait() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTQueryPortrait::clear_mtportrait() {
  mtportrait_ = 0;
  clear_has_mtportrait();
}
inline ::mt::EmMtPortrait TMTQueryPortrait::mtportrait() const {
  return static_cast< ::mt::EmMtPortrait >(mtportrait_);
}
inline void TMTQueryPortrait::set_mtportrait(::mt::EmMtPortrait value) {
  assert(::mt::EmMtPortrait_IsValid(value));
  set_has_mtportrait();
  mtportrait_ = value;
}

// optional string portraitstr = 2;
inline bool TMTQueryPortrait::has_portraitstr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTQueryPortrait::set_has_portraitstr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTQueryPortrait::clear_has_portraitstr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTQueryPortrait::clear_portraitstr() {
  if (portraitstr_ != &::google::protobuf::internal::kEmptyString) {
    portraitstr_->clear();
  }
  clear_has_portraitstr();
}
inline const ::std::string& TMTQueryPortrait::portraitstr() const {
  return *portraitstr_;
}
inline void TMTQueryPortrait::set_portraitstr(const ::std::string& value) {
  set_has_portraitstr();
  if (portraitstr_ == &::google::protobuf::internal::kEmptyString) {
    portraitstr_ = new ::std::string;
  }
  portraitstr_->assign(value);
}
inline void TMTQueryPortrait::set_portraitstr(const char* value) {
  set_has_portraitstr();
  if (portraitstr_ == &::google::protobuf::internal::kEmptyString) {
    portraitstr_ = new ::std::string;
  }
  portraitstr_->assign(value);
}
inline void TMTQueryPortrait::set_portraitstr(const char* value, size_t size) {
  set_has_portraitstr();
  if (portraitstr_ == &::google::protobuf::internal::kEmptyString) {
    portraitstr_ = new ::std::string;
  }
  portraitstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTQueryPortrait::mutable_portraitstr() {
  set_has_portraitstr();
  if (portraitstr_ == &::google::protobuf::internal::kEmptyString) {
    portraitstr_ = new ::std::string;
  }
  return portraitstr_;
}
inline ::std::string* TMTQueryPortrait::release_portraitstr() {
  clear_has_portraitstr();
  if (portraitstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portraitstr_;
    portraitstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTQueryPortrait::set_allocated_portraitstr(::std::string* portraitstr) {
  if (portraitstr_ != &::google::protobuf::internal::kEmptyString) {
    delete portraitstr_;
  }
  if (portraitstr) {
    set_has_portraitstr();
    portraitstr_ = portraitstr;
  } else {
    clear_has_portraitstr();
    portraitstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string filename = 3;
inline bool TMTQueryPortrait::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTQueryPortrait::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTQueryPortrait::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTQueryPortrait::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& TMTQueryPortrait::filename() const {
  return *filename_;
}
inline void TMTQueryPortrait::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TMTQueryPortrait::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TMTQueryPortrait::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTQueryPortrait::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* TMTQueryPortrait::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTQueryPortrait::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 requestpointer = 4;
inline bool TMTQueryPortrait::has_requestpointer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTQueryPortrait::set_has_requestpointer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTQueryPortrait::clear_has_requestpointer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTQueryPortrait::clear_requestpointer() {
  requestpointer_ = GOOGLE_ULONGLONG(0);
  clear_has_requestpointer();
}
inline ::google::protobuf::uint64 TMTQueryPortrait::requestpointer() const {
  return requestpointer_;
}
inline void TMTQueryPortrait::set_requestpointer(::google::protobuf::uint64 value) {
  set_has_requestpointer();
  requestpointer_ = value;
}

// -------------------------------------------------------------------

// TMTSetAuthMode

// optional string jid = 1;
inline bool TMTSetAuthMode::has_jid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTSetAuthMode::set_has_jid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTSetAuthMode::clear_has_jid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTSetAuthMode::clear_jid() {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    jid_->clear();
  }
  clear_has_jid();
}
inline const ::std::string& TMTSetAuthMode::jid() const {
  return *jid_;
}
inline void TMTSetAuthMode::set_jid(const ::std::string& value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTSetAuthMode::set_jid(const char* value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTSetAuthMode::set_jid(const char* value, size_t size) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTSetAuthMode::mutable_jid() {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  return jid_;
}
inline ::std::string* TMTSetAuthMode::release_jid() {
  clear_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jid_;
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTSetAuthMode::set_allocated_jid(::std::string* jid) {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    delete jid_;
  }
  if (jid) {
    set_has_jid();
    jid_ = jid;
  } else {
    clear_has_jid();
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 authmode = 2;
inline bool TMTSetAuthMode::has_authmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTSetAuthMode::set_has_authmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTSetAuthMode::clear_has_authmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTSetAuthMode::clear_authmode() {
  authmode_ = 0u;
  clear_has_authmode();
}
inline ::google::protobuf::uint32 TMTSetAuthMode::authmode() const {
  return authmode_;
}
inline void TMTSetAuthMode::set_authmode(::google::protobuf::uint32 value) {
  set_has_authmode();
  authmode_ = value;
}

// -------------------------------------------------------------------

// TMTUserListByStr

// optional string username = 1;
inline bool TMTUserListByStr::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUserListByStr::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUserListByStr::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUserListByStr::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMTUserListByStr::username() const {
  return *username_;
}
inline void TMTUserListByStr::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTUserListByStr::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTUserListByStr::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserListByStr::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMTUserListByStr::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserListByStr::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string str = 2;
inline bool TMTUserListByStr::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUserListByStr::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUserListByStr::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUserListByStr::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& TMTUserListByStr::str() const {
  return *str_;
}
inline void TMTUserListByStr::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void TMTUserListByStr::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void TMTUserListByStr::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserListByStr::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* TMTUserListByStr::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserListByStr::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 startrow = 3;
inline bool TMTUserListByStr::has_startrow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTUserListByStr::set_has_startrow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTUserListByStr::clear_has_startrow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTUserListByStr::clear_startrow() {
  startrow_ = 0u;
  clear_has_startrow();
}
inline ::google::protobuf::uint32 TMTUserListByStr::startrow() const {
  return startrow_;
}
inline void TMTUserListByStr::set_startrow(::google::protobuf::uint32 value) {
  set_has_startrow();
  startrow_ = value;
}

// optional uint32 pagesize = 4;
inline bool TMTUserListByStr::has_pagesize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTUserListByStr::set_has_pagesize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTUserListByStr::clear_has_pagesize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTUserListByStr::clear_pagesize() {
  pagesize_ = 0u;
  clear_has_pagesize();
}
inline ::google::protobuf::uint32 TMTUserListByStr::pagesize() const {
  return pagesize_;
}
inline void TMTUserListByStr::set_pagesize(::google::protobuf::uint32 value) {
  set_has_pagesize();
  pagesize_ = value;
}

// -------------------------------------------------------------------

// TMTModifyBrief

// optional string username = 1;
inline bool TMTModifyBrief::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTModifyBrief::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTModifyBrief::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTModifyBrief::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMTModifyBrief::username() const {
  return *username_;
}
inline void TMTModifyBrief::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTModifyBrief::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTModifyBrief::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyBrief::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMTModifyBrief::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyBrief::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brief = 2;
inline bool TMTModifyBrief::has_brief() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTModifyBrief::set_has_brief() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTModifyBrief::clear_has_brief() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTModifyBrief::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TMTModifyBrief::brief() const {
  return *brief_;
}
inline void TMTModifyBrief::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTModifyBrief::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTModifyBrief::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyBrief::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TMTModifyBrief::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyBrief::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTModifyPortrait

// optional uint32 x1 = 1;
inline bool TMTModifyPortrait::has_x1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTModifyPortrait::set_has_x1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTModifyPortrait::clear_has_x1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTModifyPortrait::clear_x1() {
  x1_ = 0u;
  clear_has_x1();
}
inline ::google::protobuf::uint32 TMTModifyPortrait::x1() const {
  return x1_;
}
inline void TMTModifyPortrait::set_x1(::google::protobuf::uint32 value) {
  set_has_x1();
  x1_ = value;
}

// optional uint32 y1 = 2;
inline bool TMTModifyPortrait::has_y1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTModifyPortrait::set_has_y1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTModifyPortrait::clear_has_y1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTModifyPortrait::clear_y1() {
  y1_ = 0u;
  clear_has_y1();
}
inline ::google::protobuf::uint32 TMTModifyPortrait::y1() const {
  return y1_;
}
inline void TMTModifyPortrait::set_y1(::google::protobuf::uint32 value) {
  set_has_y1();
  y1_ = value;
}

// optional uint32 width = 3;
inline bool TMTModifyPortrait::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTModifyPortrait::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTModifyPortrait::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTModifyPortrait::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 TMTModifyPortrait::width() const {
  return width_;
}
inline void TMTModifyPortrait::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional uint32 heith = 4;
inline bool TMTModifyPortrait::has_heith() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTModifyPortrait::set_has_heith() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTModifyPortrait::clear_has_heith() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTModifyPortrait::clear_heith() {
  heith_ = 0u;
  clear_has_heith();
}
inline ::google::protobuf::uint32 TMTModifyPortrait::heith() const {
  return heith_;
}
inline void TMTModifyPortrait::set_heith(::google::protobuf::uint32 value) {
  set_has_heith();
  heith_ = value;
}

// optional uint32 len = 5;
inline bool TMTModifyPortrait::has_len() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTModifyPortrait::set_has_len() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTModifyPortrait::clear_has_len() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTModifyPortrait::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 TMTModifyPortrait::len() const {
  return len_;
}
inline void TMTModifyPortrait::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// optional string path = 6;
inline bool TMTModifyPortrait::has_path() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTModifyPortrait::set_has_path() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTModifyPortrait::clear_has_path() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTModifyPortrait::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TMTModifyPortrait::path() const {
  return *path_;
}
inline void TMTModifyPortrait::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TMTModifyPortrait::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TMTModifyPortrait::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyPortrait::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TMTModifyPortrait::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyPortrait::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTWbParse_Keda_EntUsers

// optional uint32 usernum = 1;
inline bool TMTWbParse_Keda_EntUsers::has_usernum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParse_Keda_EntUsers::set_has_usernum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParse_Keda_EntUsers::clear_has_usernum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParse_Keda_EntUsers::clear_usernum() {
  usernum_ = 0u;
  clear_has_usernum();
}
inline ::google::protobuf::uint32 TMTWbParse_Keda_EntUsers::usernum() const {
  return usernum_;
}
inline void TMTWbParse_Keda_EntUsers::set_usernum(::google::protobuf::uint32 value) {
  set_has_usernum();
  usernum_ = value;
}

// repeated .mt.TMTWbParse_Keda_EntUser user = 2;
inline int TMTWbParse_Keda_EntUsers::user_size() const {
  return user_.size();
}
inline void TMTWbParse_Keda_EntUsers::clear_user() {
  user_.Clear();
}
inline const ::mt::TMTWbParse_Keda_EntUser& TMTWbParse_Keda_EntUsers::user(int index) const {
  return user_.Get(index);
}
inline ::mt::TMTWbParse_Keda_EntUser* TMTWbParse_Keda_EntUsers::mutable_user(int index) {
  return user_.Mutable(index);
}
inline ::mt::TMTWbParse_Keda_EntUser* TMTWbParse_Keda_EntUsers::add_user() {
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_EntUser >&
TMTWbParse_Keda_EntUsers::user() const {
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTWbParse_Keda_EntUser >*
TMTWbParse_Keda_EntUsers::mutable_user() {
  return &user_;
}

// -------------------------------------------------------------------

// TMTWBParse_Keda_QueryUsers

// optional uint32 totalcount = 1;
inline bool TMTWBParse_Keda_QueryUsers::has_totalcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWBParse_Keda_QueryUsers::set_has_totalcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWBParse_Keda_QueryUsers::clear_has_totalcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWBParse_Keda_QueryUsers::clear_totalcount() {
  totalcount_ = 0u;
  clear_has_totalcount();
}
inline ::google::protobuf::uint32 TMTWBParse_Keda_QueryUsers::totalcount() const {
  return totalcount_;
}
inline void TMTWBParse_Keda_QueryUsers::set_totalcount(::google::protobuf::uint32 value) {
  set_has_totalcount();
  totalcount_ = value;
}

// optional .mt.TMTWbParse_Keda_EntUsers users = 2;
inline bool TMTWBParse_Keda_QueryUsers::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTWBParse_Keda_QueryUsers::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTWBParse_Keda_QueryUsers::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTWBParse_Keda_QueryUsers::clear_users() {
  if (users_ != NULL) users_->::mt::TMTWbParse_Keda_EntUsers::Clear();
  clear_has_users();
}
inline const ::mt::TMTWbParse_Keda_EntUsers& TMTWBParse_Keda_QueryUsers::users() const {
  return users_ != NULL ? *users_ : *default_instance_->users_;
}
inline ::mt::TMTWbParse_Keda_EntUsers* TMTWBParse_Keda_QueryUsers::mutable_users() {
  set_has_users();
  if (users_ == NULL) users_ = new ::mt::TMTWbParse_Keda_EntUsers;
  return users_;
}
inline ::mt::TMTWbParse_Keda_EntUsers* TMTWBParse_Keda_QueryUsers::release_users() {
  clear_has_users();
  ::mt::TMTWbParse_Keda_EntUsers* temp = users_;
  users_ = NULL;
  return temp;
}
inline void TMTWBParse_Keda_QueryUsers::set_allocated_users(::mt::TMTWbParse_Keda_EntUsers* users) {
  delete users_;
  users_ = users;
  if (users) {
    set_has_users();
  } else {
    clear_has_users();
  }
}

// -------------------------------------------------------------------

// TMTWbParse_Keda_SearchUsers

// optional uint32 totalcount = 1;
inline bool TMTWbParse_Keda_SearchUsers::has_totalcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTWbParse_Keda_SearchUsers::set_has_totalcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTWbParse_Keda_SearchUsers::clear_has_totalcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTWbParse_Keda_SearchUsers::clear_totalcount() {
  totalcount_ = 0u;
  clear_has_totalcount();
}
inline ::google::protobuf::uint32 TMTWbParse_Keda_SearchUsers::totalcount() const {
  return totalcount_;
}
inline void TMTWbParse_Keda_SearchUsers::set_totalcount(::google::protobuf::uint32 value) {
  set_has_totalcount();
  totalcount_ = value;
}

// optional string str = 2;
inline bool TMTWbParse_Keda_SearchUsers::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTWbParse_Keda_SearchUsers::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTWbParse_Keda_SearchUsers::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTWbParse_Keda_SearchUsers::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& TMTWbParse_Keda_SearchUsers::str() const {
  return *str_;
}
inline void TMTWbParse_Keda_SearchUsers::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void TMTWbParse_Keda_SearchUsers::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void TMTWbParse_Keda_SearchUsers::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTWbParse_Keda_SearchUsers::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* TMTWbParse_Keda_SearchUsers::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTWbParse_Keda_SearchUsers::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTWbParse_Keda_EntUsers users = 3;
inline bool TMTWbParse_Keda_SearchUsers::has_users() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTWbParse_Keda_SearchUsers::set_has_users() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTWbParse_Keda_SearchUsers::clear_has_users() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTWbParse_Keda_SearchUsers::clear_users() {
  if (users_ != NULL) users_->::mt::TMTWbParse_Keda_EntUsers::Clear();
  clear_has_users();
}
inline const ::mt::TMTWbParse_Keda_EntUsers& TMTWbParse_Keda_SearchUsers::users() const {
  return users_ != NULL ? *users_ : *default_instance_->users_;
}
inline ::mt::TMTWbParse_Keda_EntUsers* TMTWbParse_Keda_SearchUsers::mutable_users() {
  set_has_users();
  if (users_ == NULL) users_ = new ::mt::TMTWbParse_Keda_EntUsers;
  return users_;
}
inline ::mt::TMTWbParse_Keda_EntUsers* TMTWbParse_Keda_SearchUsers::release_users() {
  clear_has_users();
  ::mt::TMTWbParse_Keda_EntUsers* temp = users_;
  users_ = NULL;
  return temp;
}
inline void TMTWbParse_Keda_SearchUsers::set_allocated_users(::mt::TMTWbParse_Keda_EntUsers* users) {
  delete users_;
  users_ = users;
  if (users) {
    set_has_users();
  } else {
    clear_has_users();
  }
}

// -------------------------------------------------------------------

// TMTRoomids

// optional uint32 count = 1;
inline bool TMTRoomids::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRoomids::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRoomids::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRoomids::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTRoomids::count() const {
  return count_;
}
inline void TMTRoomids::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated uint32 items = 2;
inline int TMTRoomids::items_size() const {
  return items_.size();
}
inline void TMTRoomids::clear_items() {
  items_.Clear();
}
inline ::google::protobuf::uint32 TMTRoomids::items(int index) const {
  return items_.Get(index);
}
inline void TMTRoomids::set_items(int index, ::google::protobuf::uint32 value) {
  items_.Set(index, value);
}
inline void TMTRoomids::add_items(::google::protobuf::uint32 value) {
  items_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TMTRoomids::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TMTRoomids::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// TMTVideoConferenceInfo

// optional string e164 = 1;
inline bool TMTVideoConferenceInfo::has_e164() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_e164() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVideoConferenceInfo::clear_has_e164() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVideoConferenceInfo::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTVideoConferenceInfo::e164() const {
  return *e164_;
}
inline void TMTVideoConferenceInfo::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTVideoConferenceInfo::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTVideoConferenceInfo::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVideoConferenceInfo::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTVideoConferenceInfo::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVideoConferenceInfo::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string templateid = 2;
inline bool TMTVideoConferenceInfo::has_templateid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_templateid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVideoConferenceInfo::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVideoConferenceInfo::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTVideoConferenceInfo::templateid() const {
  return *templateid_;
}
inline void TMTVideoConferenceInfo::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTVideoConferenceInfo::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTVideoConferenceInfo::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVideoConferenceInfo::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTVideoConferenceInfo::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVideoConferenceInfo::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string templatename = 3;
inline bool TMTVideoConferenceInfo::has_templatename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_templatename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVideoConferenceInfo::clear_has_templatename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVideoConferenceInfo::clear_templatename() {
  if (templatename_ != &::google::protobuf::internal::kEmptyString) {
    templatename_->clear();
  }
  clear_has_templatename();
}
inline const ::std::string& TMTVideoConferenceInfo::templatename() const {
  return *templatename_;
}
inline void TMTVideoConferenceInfo::set_templatename(const ::std::string& value) {
  set_has_templatename();
  if (templatename_ == &::google::protobuf::internal::kEmptyString) {
    templatename_ = new ::std::string;
  }
  templatename_->assign(value);
}
inline void TMTVideoConferenceInfo::set_templatename(const char* value) {
  set_has_templatename();
  if (templatename_ == &::google::protobuf::internal::kEmptyString) {
    templatename_ = new ::std::string;
  }
  templatename_->assign(value);
}
inline void TMTVideoConferenceInfo::set_templatename(const char* value, size_t size) {
  set_has_templatename();
  if (templatename_ == &::google::protobuf::internal::kEmptyString) {
    templatename_ = new ::std::string;
  }
  templatename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVideoConferenceInfo::mutable_templatename() {
  set_has_templatename();
  if (templatename_ == &::google::protobuf::internal::kEmptyString) {
    templatename_ = new ::std::string;
  }
  return templatename_;
}
inline ::std::string* TMTVideoConferenceInfo::release_templatename() {
  clear_has_templatename();
  if (templatename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templatename_;
    templatename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVideoConferenceInfo::set_allocated_templatename(::std::string* templatename) {
  if (templatename_ != &::google::protobuf::internal::kEmptyString) {
    delete templatename_;
  }
  if (templatename) {
    set_has_templatename();
    templatename_ = templatename;
  } else {
    clear_has_templatename();
    templatename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 4;
inline bool TMTVideoConferenceInfo::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTVideoConferenceInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTVideoConferenceInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTVideoConferenceInfo::password() const {
  return *password_;
}
inline void TMTVideoConferenceInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTVideoConferenceInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTVideoConferenceInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVideoConferenceInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTVideoConferenceInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVideoConferenceInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 shortno = 5;
inline bool TMTVideoConferenceInfo::has_shortno() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_shortno() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTVideoConferenceInfo::clear_has_shortno() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTVideoConferenceInfo::clear_shortno() {
  shortno_ = 0u;
  clear_has_shortno();
}
inline ::google::protobuf::uint32 TMTVideoConferenceInfo::shortno() const {
  return shortno_;
}
inline void TMTVideoConferenceInfo::set_shortno(::google::protobuf::uint32 value) {
  set_has_shortno();
  shortno_ = value;
}

// optional uint32 state = 6;
inline bool TMTVideoConferenceInfo::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTVideoConferenceInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTVideoConferenceInfo::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 TMTVideoConferenceInfo::state() const {
  return state_;
}
inline void TMTVideoConferenceInfo::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 isautocall = 7;
inline bool TMTVideoConferenceInfo::has_isautocall() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_isautocall() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTVideoConferenceInfo::clear_has_isautocall() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTVideoConferenceInfo::clear_isautocall() {
  isautocall_ = 0u;
  clear_has_isautocall();
}
inline ::google::protobuf::uint32 TMTVideoConferenceInfo::isautocall() const {
  return isautocall_;
}
inline void TMTVideoConferenceInfo::set_isautocall(::google::protobuf::uint32 value) {
  set_has_isautocall();
  isautocall_ = value;
}

// optional .mt.EmClosedMeeting closedmeeting = 8;
inline bool TMTVideoConferenceInfo::has_closedmeeting() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_closedmeeting() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTVideoConferenceInfo::clear_has_closedmeeting() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTVideoConferenceInfo::clear_closedmeeting() {
  closedmeeting_ = 0;
  clear_has_closedmeeting();
}
inline ::mt::EmClosedMeeting TMTVideoConferenceInfo::closedmeeting() const {
  return static_cast< ::mt::EmClosedMeeting >(closedmeeting_);
}
inline void TMTVideoConferenceInfo::set_closedmeeting(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closedmeeting();
  closedmeeting_ = value;
}

// optional .mt.EmMtOpenMode meetingsafe = 9;
inline bool TMTVideoConferenceInfo::has_meetingsafe() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_meetingsafe() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTVideoConferenceInfo::clear_has_meetingsafe() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTVideoConferenceInfo::clear_meetingsafe() {
  meetingsafe_ = 1;
  clear_has_meetingsafe();
}
inline ::mt::EmMtOpenMode TMTVideoConferenceInfo::meetingsafe() const {
  return static_cast< ::mt::EmMtOpenMode >(meetingsafe_);
}
inline void TMTVideoConferenceInfo::set_meetingsafe(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_meetingsafe();
  meetingsafe_ = value;
}

// optional .mt.EmRestMeetingSafeType meetingtype = 10;
inline bool TMTVideoConferenceInfo::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTVideoConferenceInfo::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTVideoConferenceInfo::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTVideoConferenceInfo::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTVideoConferenceInfo::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional uint32 meetingscale = 11;
inline bool TMTVideoConferenceInfo::has_meetingscale() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_meetingscale() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTVideoConferenceInfo::clear_has_meetingscale() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTVideoConferenceInfo::clear_meetingscale() {
  meetingscale_ = 0u;
  clear_has_meetingscale();
}
inline ::google::protobuf::uint32 TMTVideoConferenceInfo::meetingscale() const {
  return meetingscale_;
}
inline void TMTVideoConferenceInfo::set_meetingscale(::google::protobuf::uint32 value) {
  set_has_meetingscale();
  meetingscale_ = value;
}

// optional uint32 onereforming = 12;
inline bool TMTVideoConferenceInfo::has_onereforming() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_onereforming() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTVideoConferenceInfo::clear_has_onereforming() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTVideoConferenceInfo::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TMTVideoConferenceInfo::onereforming() const {
  return onereforming_;
}
inline void TMTVideoConferenceInfo::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional bool publicmeeting = 13;
inline bool TMTVideoConferenceInfo::has_publicmeeting() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_publicmeeting() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTVideoConferenceInfo::clear_has_publicmeeting() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTVideoConferenceInfo::clear_publicmeeting() {
  publicmeeting_ = false;
  clear_has_publicmeeting();
}
inline bool TMTVideoConferenceInfo::publicmeeting() const {
  return publicmeeting_;
}
inline void TMTVideoConferenceInfo::set_publicmeeting(bool value) {
  set_has_publicmeeting();
  publicmeeting_ = value;
}

// optional .mt.TMTTemplateMember speaker = 14;
inline bool TMTVideoConferenceInfo::has_speaker() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_speaker() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTVideoConferenceInfo::clear_has_speaker() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTVideoConferenceInfo::clear_speaker() {
  if (speaker_ != NULL) speaker_->::mt::TMTTemplateMember::Clear();
  clear_has_speaker();
}
inline const ::mt::TMTTemplateMember& TMTVideoConferenceInfo::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::mt::TMTTemplateMember* TMTVideoConferenceInfo::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::mt::TMTTemplateMember;
  return speaker_;
}
inline ::mt::TMTTemplateMember* TMTVideoConferenceInfo::release_speaker() {
  clear_has_speaker();
  ::mt::TMTTemplateMember* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void TMTVideoConferenceInfo::set_allocated_speaker(::mt::TMTTemplateMember* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional .mt.TMTTemplateMember admin = 15;
inline bool TMTVideoConferenceInfo::has_admin() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_admin() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTVideoConferenceInfo::clear_has_admin() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTVideoConferenceInfo::clear_admin() {
  if (admin_ != NULL) admin_->::mt::TMTTemplateMember::Clear();
  clear_has_admin();
}
inline const ::mt::TMTTemplateMember& TMTVideoConferenceInfo::admin() const {
  return admin_ != NULL ? *admin_ : *default_instance_->admin_;
}
inline ::mt::TMTTemplateMember* TMTVideoConferenceInfo::mutable_admin() {
  set_has_admin();
  if (admin_ == NULL) admin_ = new ::mt::TMTTemplateMember;
  return admin_;
}
inline ::mt::TMTTemplateMember* TMTVideoConferenceInfo::release_admin() {
  clear_has_admin();
  ::mt::TMTTemplateMember* temp = admin_;
  admin_ = NULL;
  return temp;
}
inline void TMTVideoConferenceInfo::set_allocated_admin(::mt::TMTTemplateMember* admin) {
  delete admin_;
  admin_ = admin;
  if (admin) {
    set_has_admin();
  } else {
    clear_has_admin();
  }
}

// optional .mt.TMTGetMixInfo mixinfo = 16;
inline bool TMTVideoConferenceInfo::has_mixinfo() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_mixinfo() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTVideoConferenceInfo::clear_has_mixinfo() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTVideoConferenceInfo::clear_mixinfo() {
  if (mixinfo_ != NULL) mixinfo_->::mt::TMTGetMixInfo::Clear();
  clear_has_mixinfo();
}
inline const ::mt::TMTGetMixInfo& TMTVideoConferenceInfo::mixinfo() const {
  return mixinfo_ != NULL ? *mixinfo_ : *default_instance_->mixinfo_;
}
inline ::mt::TMTGetMixInfo* TMTVideoConferenceInfo::mutable_mixinfo() {
  set_has_mixinfo();
  if (mixinfo_ == NULL) mixinfo_ = new ::mt::TMTGetMixInfo;
  return mixinfo_;
}
inline ::mt::TMTGetMixInfo* TMTVideoConferenceInfo::release_mixinfo() {
  clear_has_mixinfo();
  ::mt::TMTGetMixInfo* temp = mixinfo_;
  mixinfo_ = NULL;
  return temp;
}
inline void TMTVideoConferenceInfo::set_allocated_mixinfo(::mt::TMTGetMixInfo* mixinfo) {
  delete mixinfo_;
  mixinfo_ = mixinfo;
  if (mixinfo) {
    set_has_mixinfo();
  } else {
    clear_has_mixinfo();
  }
}

// optional uint32 calltimes = 17;
inline bool TMTVideoConferenceInfo::has_calltimes() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_calltimes() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTVideoConferenceInfo::clear_has_calltimes() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTVideoConferenceInfo::clear_calltimes() {
  calltimes_ = 0u;
  clear_has_calltimes();
}
inline ::google::protobuf::uint32 TMTVideoConferenceInfo::calltimes() const {
  return calltimes_;
}
inline void TMTVideoConferenceInfo::set_calltimes(::google::protobuf::uint32 value) {
  set_has_calltimes();
  calltimes_ = value;
}

// optional uint32 callinterval = 18;
inline bool TMTVideoConferenceInfo::has_callinterval() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_callinterval() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTVideoConferenceInfo::clear_has_callinterval() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTVideoConferenceInfo::clear_callinterval() {
  callinterval_ = 0u;
  clear_has_callinterval();
}
inline ::google::protobuf::uint32 TMTVideoConferenceInfo::callinterval() const {
  return callinterval_;
}
inline void TMTVideoConferenceInfo::set_callinterval(::google::protobuf::uint32 value) {
  set_has_callinterval();
  callinterval_ = value;
}

// optional bool callchase = 19;
inline bool TMTVideoConferenceInfo::has_callchase() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_callchase() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTVideoConferenceInfo::clear_has_callchase() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTVideoConferenceInfo::clear_callchase() {
  callchase_ = false;
  clear_has_callchase();
}
inline bool TMTVideoConferenceInfo::callchase() const {
  return callchase_;
}
inline void TMTVideoConferenceInfo::set_callchase(bool value) {
  set_has_callchase();
  callchase_ = value;
}

// optional bool initmute = 20;
inline bool TMTVideoConferenceInfo::has_initmute() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_initmute() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTVideoConferenceInfo::clear_has_initmute() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTVideoConferenceInfo::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTVideoConferenceInfo::initmute() const {
  return initmute_;
}
inline void TMTVideoConferenceInfo::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional .mt.EmRestVideoQuality videoquality = 21;
inline bool TMTVideoConferenceInfo::has_videoquality() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_videoquality() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTVideoConferenceInfo::clear_has_videoquality() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTVideoConferenceInfo::clear_videoquality() {
  videoquality_ = 0;
  clear_has_videoquality();
}
inline ::mt::EmRestVideoQuality TMTVideoConferenceInfo::videoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(videoquality_);
}
inline void TMTVideoConferenceInfo::set_videoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_videoquality();
  videoquality_ = value;
}

// optional .mt.EmEncryptArithmetic encryptedtype = 22;
inline bool TMTVideoConferenceInfo::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTVideoConferenceInfo::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTVideoConferenceInfo::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTVideoConferenceInfo::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTVideoConferenceInfo::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional string encryptedkey = 23;
inline bool TMTVideoConferenceInfo::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTVideoConferenceInfo::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTVideoConferenceInfo::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTVideoConferenceInfo::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTVideoConferenceInfo::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTVideoConferenceInfo::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTVideoConferenceInfo::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVideoConferenceInfo::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTVideoConferenceInfo::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVideoConferenceInfo::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestDualMode dualmode = 24;
inline bool TMTVideoConferenceInfo::has_dualmode() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_dualmode() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTVideoConferenceInfo::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTVideoConferenceInfo::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTVideoConferenceInfo::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTVideoConferenceInfo::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool voiceinspireenable = 25;
inline bool TMTVideoConferenceInfo::has_voiceinspireenable() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_voiceinspireenable() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTVideoConferenceInfo::clear_has_voiceinspireenable() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTVideoConferenceInfo::clear_voiceinspireenable() {
  voiceinspireenable_ = false;
  clear_has_voiceinspireenable();
}
inline bool TMTVideoConferenceInfo::voiceinspireenable() const {
  return voiceinspireenable_;
}
inline void TMTVideoConferenceInfo::set_voiceinspireenable(bool value) {
  set_has_voiceinspireenable();
  voiceinspireenable_ = value;
}

// optional uint32 voiceinspiretime = 26;
inline bool TMTVideoConferenceInfo::has_voiceinspiretime() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_voiceinspiretime() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMTVideoConferenceInfo::clear_has_voiceinspiretime() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMTVideoConferenceInfo::clear_voiceinspiretime() {
  voiceinspiretime_ = 0u;
  clear_has_voiceinspiretime();
}
inline ::google::protobuf::uint32 TMTVideoConferenceInfo::voiceinspiretime() const {
  return voiceinspiretime_;
}
inline void TMTVideoConferenceInfo::set_voiceinspiretime(::google::protobuf::uint32 value) {
  set_has_voiceinspiretime();
  voiceinspiretime_ = value;
}

// optional .mt.EmRestCascadeMode cascademode = 27;
inline bool TMTVideoConferenceInfo::has_cascademode() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_cascademode() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMTVideoConferenceInfo::clear_has_cascademode() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMTVideoConferenceInfo::clear_cascademode() {
  cascademode_ = 0;
  clear_has_cascademode();
}
inline ::mt::EmRestCascadeMode TMTVideoConferenceInfo::cascademode() const {
  return static_cast< ::mt::EmRestCascadeMode >(cascademode_);
}
inline void TMTVideoConferenceInfo::set_cascademode(::mt::EmRestCascadeMode value) {
  assert(::mt::EmRestCascadeMode_IsValid(value));
  set_has_cascademode();
  cascademode_ = value;
}

// optional bool cascadeupload = 28;
inline bool TMTVideoConferenceInfo::has_cascadeupload() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_cascadeupload() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTVideoConferenceInfo::clear_has_cascadeupload() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTVideoConferenceInfo::clear_cascadeupload() {
  cascadeupload_ = false;
  clear_has_cascadeupload();
}
inline bool TMTVideoConferenceInfo::cascadeupload() const {
  return cascadeupload_;
}
inline void TMTVideoConferenceInfo::set_cascadeupload(bool value) {
  set_has_cascadeupload();
  cascadeupload_ = value;
}

// optional bool cascadereturn = 29;
inline bool TMTVideoConferenceInfo::has_cascadereturn() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_cascadereturn() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMTVideoConferenceInfo::clear_has_cascadereturn() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMTVideoConferenceInfo::clear_cascadereturn() {
  cascadereturn_ = false;
  clear_has_cascadereturn();
}
inline bool TMTVideoConferenceInfo::cascadereturn() const {
  return cascadereturn_;
}
inline void TMTVideoConferenceInfo::set_cascadereturn(bool value) {
  set_has_cascadereturn();
  cascadereturn_ = value;
}

// optional uint32 cascadereturnpara = 30;
inline bool TMTVideoConferenceInfo::has_cascadereturnpara() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_cascadereturnpara() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMTVideoConferenceInfo::clear_has_cascadereturnpara() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMTVideoConferenceInfo::clear_cascadereturnpara() {
  cascadereturnpara_ = 0u;
  clear_has_cascadereturnpara();
}
inline ::google::protobuf::uint32 TMTVideoConferenceInfo::cascadereturnpara() const {
  return cascadereturnpara_;
}
inline void TMTVideoConferenceInfo::set_cascadereturnpara(::google::protobuf::uint32 value) {
  set_has_cascadereturnpara();
  cascadereturnpara_ = value;
}

// optional .mt.TMTTemplateSatellite satellite = 31;
inline bool TMTVideoConferenceInfo::has_satellite() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_satellite() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TMTVideoConferenceInfo::clear_has_satellite() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TMTVideoConferenceInfo::clear_satellite() {
  if (satellite_ != NULL) satellite_->::mt::TMTTemplateSatellite::Clear();
  clear_has_satellite();
}
inline const ::mt::TMTTemplateSatellite& TMTVideoConferenceInfo::satellite() const {
  return satellite_ != NULL ? *satellite_ : *default_instance_->satellite_;
}
inline ::mt::TMTTemplateSatellite* TMTVideoConferenceInfo::mutable_satellite() {
  set_has_satellite();
  if (satellite_ == NULL) satellite_ = new ::mt::TMTTemplateSatellite;
  return satellite_;
}
inline ::mt::TMTTemplateSatellite* TMTVideoConferenceInfo::release_satellite() {
  clear_has_satellite();
  ::mt::TMTTemplateSatellite* temp = satellite_;
  satellite_ = NULL;
  return temp;
}
inline void TMTVideoConferenceInfo::set_allocated_satellite(::mt::TMTTemplateSatellite* satellite) {
  delete satellite_;
  satellite_ = satellite;
  if (satellite) {
    set_has_satellite();
  } else {
    clear_has_satellite();
  }
}

// optional .mt.TMTTemplateRecord record = 32;
inline bool TMTVideoConferenceInfo::has_record() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_record() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TMTVideoConferenceInfo::clear_has_record() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TMTVideoConferenceInfo::clear_record() {
  if (record_ != NULL) record_->::mt::TMTTemplateRecord::Clear();
  clear_has_record();
}
inline const ::mt::TMTTemplateRecord& TMTVideoConferenceInfo::record() const {
  return record_ != NULL ? *record_ : *default_instance_->record_;
}
inline ::mt::TMTTemplateRecord* TMTVideoConferenceInfo::mutable_record() {
  set_has_record();
  if (record_ == NULL) record_ = new ::mt::TMTTemplateRecord;
  return record_;
}
inline ::mt::TMTTemplateRecord* TMTVideoConferenceInfo::release_record() {
  clear_has_record();
  ::mt::TMTTemplateRecord* temp = record_;
  record_ = NULL;
  return temp;
}
inline void TMTVideoConferenceInfo::set_allocated_record(::mt::TMTTemplateRecord* record) {
  delete record_;
  record_ = record;
  if (record) {
    set_has_record();
  } else {
    clear_has_record();
  }
}

// optional .mt.TMTTemplateMultiCast multicast = 33;
inline bool TMTVideoConferenceInfo::has_multicast() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_multicast() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TMTVideoConferenceInfo::clear_has_multicast() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TMTVideoConferenceInfo::clear_multicast() {
  if (multicast_ != NULL) multicast_->::mt::TMTTemplateMultiCast::Clear();
  clear_has_multicast();
}
inline const ::mt::TMTTemplateMultiCast& TMTVideoConferenceInfo::multicast() const {
  return multicast_ != NULL ? *multicast_ : *default_instance_->multicast_;
}
inline ::mt::TMTTemplateMultiCast* TMTVideoConferenceInfo::mutable_multicast() {
  set_has_multicast();
  if (multicast_ == NULL) multicast_ = new ::mt::TMTTemplateMultiCast;
  return multicast_;
}
inline ::mt::TMTTemplateMultiCast* TMTVideoConferenceInfo::release_multicast() {
  clear_has_multicast();
  ::mt::TMTTemplateMultiCast* temp = multicast_;
  multicast_ = NULL;
  return temp;
}
inline void TMTVideoConferenceInfo::set_allocated_multicast(::mt::TMTTemplateMultiCast* multicast) {
  delete multicast_;
  multicast_ = multicast;
  if (multicast) {
    set_has_multicast();
  } else {
    clear_has_multicast();
  }
}

// repeated .mt.TMTVideoFormatList videoformatlist = 34;
inline int TMTVideoConferenceInfo::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTVideoConferenceInfo::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTVideoConferenceInfo::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTVideoConferenceInfo::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTVideoConferenceInfo::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTVideoConferenceInfo::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTVideoConferenceInfo::mutable_videoformatlist() {
  return &videoformatlist_;
}

// repeated .mt.TMTAudioFormatList audioformatlist = 35;
inline int TMTVideoConferenceInfo::audioformatlist_size() const {
  return audioformatlist_.size();
}
inline void TMTVideoConferenceInfo::clear_audioformatlist() {
  audioformatlist_.Clear();
}
inline const ::mt::TMTAudioFormatList& TMTVideoConferenceInfo::audioformatlist(int index) const {
  return audioformatlist_.Get(index);
}
inline ::mt::TMTAudioFormatList* TMTVideoConferenceInfo::mutable_audioformatlist(int index) {
  return audioformatlist_.Mutable(index);
}
inline ::mt::TMTAudioFormatList* TMTVideoConferenceInfo::add_audioformatlist() {
  return audioformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
TMTVideoConferenceInfo::audioformatlist() const {
  return audioformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
TMTVideoConferenceInfo::mutable_audioformatlist() {
  return &audioformatlist_;
}

// repeated .mt.TMTDualFormatList dualformatlist = 36;
inline int TMTVideoConferenceInfo::dualformatlist_size() const {
  return dualformatlist_.size();
}
inline void TMTVideoConferenceInfo::clear_dualformatlist() {
  dualformatlist_.Clear();
}
inline const ::mt::TMTDualFormatList& TMTVideoConferenceInfo::dualformatlist(int index) const {
  return dualformatlist_.Get(index);
}
inline ::mt::TMTDualFormatList* TMTVideoConferenceInfo::mutable_dualformatlist(int index) {
  return dualformatlist_.Mutable(index);
}
inline ::mt::TMTDualFormatList* TMTVideoConferenceInfo::add_dualformatlist() {
  return dualformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
TMTVideoConferenceInfo::dualformatlist() const {
  return dualformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
TMTVideoConferenceInfo::mutable_dualformatlist() {
  return &dualformatlist_;
}

// optional .mt.TMTTemplateVmp vmp = 37;
inline bool TMTVideoConferenceInfo::has_vmp() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_vmp() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TMTVideoConferenceInfo::clear_has_vmp() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TMTVideoConferenceInfo::clear_vmp() {
  if (vmp_ != NULL) vmp_->::mt::TMTTemplateVmp::Clear();
  clear_has_vmp();
}
inline const ::mt::TMTTemplateVmp& TMTVideoConferenceInfo::vmp() const {
  return vmp_ != NULL ? *vmp_ : *default_instance_->vmp_;
}
inline ::mt::TMTTemplateVmp* TMTVideoConferenceInfo::mutable_vmp() {
  set_has_vmp();
  if (vmp_ == NULL) vmp_ = new ::mt::TMTTemplateVmp;
  return vmp_;
}
inline ::mt::TMTTemplateVmp* TMTVideoConferenceInfo::release_vmp() {
  clear_has_vmp();
  ::mt::TMTTemplateVmp* temp = vmp_;
  vmp_ = NULL;
  return temp;
}
inline void TMTVideoConferenceInfo::set_allocated_vmp(::mt::TMTTemplateVmp* vmp) {
  delete vmp_;
  vmp_ = vmp;
  if (vmp) {
    set_has_vmp();
  } else {
    clear_has_vmp();
  }
}

// repeated .mt.TMTTemplateMember viplist = 38;
inline int TMTVideoConferenceInfo::viplist_size() const {
  return viplist_.size();
}
inline void TMTVideoConferenceInfo::clear_viplist() {
  viplist_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTVideoConferenceInfo::viplist(int index) const {
  return viplist_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTVideoConferenceInfo::mutable_viplist(int index) {
  return viplist_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTVideoConferenceInfo::add_viplist() {
  return viplist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTVideoConferenceInfo::viplist() const {
  return viplist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTVideoConferenceInfo::mutable_viplist() {
  return &viplist_;
}

// optional .mt.TMTTemplatePoll poll = 39;
inline bool TMTVideoConferenceInfo::has_poll() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void TMTVideoConferenceInfo::set_has_poll() {
  _has_bits_[1] |= 0x00000040u;
}
inline void TMTVideoConferenceInfo::clear_has_poll() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void TMTVideoConferenceInfo::clear_poll() {
  if (poll_ != NULL) poll_->::mt::TMTTemplatePoll::Clear();
  clear_has_poll();
}
inline const ::mt::TMTTemplatePoll& TMTVideoConferenceInfo::poll() const {
  return poll_ != NULL ? *poll_ : *default_instance_->poll_;
}
inline ::mt::TMTTemplatePoll* TMTVideoConferenceInfo::mutable_poll() {
  set_has_poll();
  if (poll_ == NULL) poll_ = new ::mt::TMTTemplatePoll;
  return poll_;
}
inline ::mt::TMTTemplatePoll* TMTVideoConferenceInfo::release_poll() {
  clear_has_poll();
  ::mt::TMTTemplatePoll* temp = poll_;
  poll_ = NULL;
  return temp;
}
inline void TMTVideoConferenceInfo::set_allocated_poll(::mt::TMTTemplatePoll* poll) {
  delete poll_;
  poll_ = poll;
  if (poll) {
    set_has_poll();
  } else {
    clear_has_poll();
  }
}

// repeated .mt.TMTTemplateMember callchasememberlist = 40;
inline int TMTVideoConferenceInfo::callchasememberlist_size() const {
  return callchasememberlist_.size();
}
inline void TMTVideoConferenceInfo::clear_callchasememberlist() {
  callchasememberlist_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTVideoConferenceInfo::callchasememberlist(int index) const {
  return callchasememberlist_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTVideoConferenceInfo::mutable_callchasememberlist(int index) {
  return callchasememberlist_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTVideoConferenceInfo::add_callchasememberlist() {
  return callchasememberlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTVideoConferenceInfo::callchasememberlist() const {
  return callchasememberlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTVideoConferenceInfo::mutable_callchasememberlist() {
  return &callchasememberlist_;
}

// -------------------------------------------------------------------

// TMTConfInfoRooms

// optional uint32 roomcount = 1;
inline bool TMTConfInfoRooms::has_roomcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfInfoRooms::set_has_roomcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfInfoRooms::clear_has_roomcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfInfoRooms::clear_roomcount() {
  roomcount_ = 0u;
  clear_has_roomcount();
}
inline ::google::protobuf::uint32 TMTConfInfoRooms::roomcount() const {
  return roomcount_;
}
inline void TMTConfInfoRooms::set_roomcount(::google::protobuf::uint32 value) {
  set_has_roomcount();
  roomcount_ = value;
}

// repeated .mt.TMTRoomInfo roominfo = 2;
inline int TMTConfInfoRooms::roominfo_size() const {
  return roominfo_.size();
}
inline void TMTConfInfoRooms::clear_roominfo() {
  roominfo_.Clear();
}
inline const ::mt::TMTRoomInfo& TMTConfInfoRooms::roominfo(int index) const {
  return roominfo_.Get(index);
}
inline ::mt::TMTRoomInfo* TMTConfInfoRooms::mutable_roominfo(int index) {
  return roominfo_.Mutable(index);
}
inline ::mt::TMTRoomInfo* TMTConfInfoRooms::add_roominfo() {
  return roominfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRoomInfo >&
TMTConfInfoRooms::roominfo() const {
  return roominfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRoomInfo >*
TMTConfInfoRooms::mutable_roominfo() {
  return &roominfo_;
}

// -------------------------------------------------------------------

// TMTConfInfoById

// optional uint32 id = 1;
inline bool TMTConfInfoById::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfInfoById::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfInfoById::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfInfoById::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTConfInfoById::id() const {
  return id_;
}
inline void TMTConfInfoById::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string subject = 2;
inline bool TMTConfInfoById::has_subject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConfInfoById::set_has_subject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConfInfoById::clear_has_subject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConfInfoById::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTConfInfoById::subject() const {
  return *subject_;
}
inline void TMTConfInfoById::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTConfInfoById::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTConfInfoById::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInfoById::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTConfInfoById::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInfoById::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string starttime = 3;
inline bool TMTConfInfoById::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTConfInfoById::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTConfInfoById::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTConfInfoById::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTConfInfoById::starttime() const {
  return *starttime_;
}
inline void TMTConfInfoById::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTConfInfoById::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTConfInfoById::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInfoById::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTConfInfoById::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInfoById::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 4;
inline bool TMTConfInfoById::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTConfInfoById::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTConfInfoById::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTConfInfoById::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTConfInfoById::endtime() const {
  return *endtime_;
}
inline void TMTConfInfoById::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTConfInfoById::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTConfInfoById::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInfoById::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTConfInfoById::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInfoById::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 status = 5;
inline bool TMTConfInfoById::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTConfInfoById::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTConfInfoById::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTConfInfoById::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 TMTConfInfoById::status() const {
  return status_;
}
inline void TMTConfInfoById::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional string organizermoid = 6;
inline bool TMTConfInfoById::has_organizermoid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTConfInfoById::set_has_organizermoid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTConfInfoById::clear_has_organizermoid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTConfInfoById::clear_organizermoid() {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    organizermoid_->clear();
  }
  clear_has_organizermoid();
}
inline const ::std::string& TMTConfInfoById::organizermoid() const {
  return *organizermoid_;
}
inline void TMTConfInfoById::set_organizermoid(const ::std::string& value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTConfInfoById::set_organizermoid(const char* value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTConfInfoById::set_organizermoid(const char* value, size_t size) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInfoById::mutable_organizermoid() {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  return organizermoid_;
}
inline ::std::string* TMTConfInfoById::release_organizermoid() {
  clear_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermoid_;
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInfoById::set_allocated_organizermoid(::std::string* organizermoid) {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermoid_;
  }
  if (organizermoid) {
    set_has_organizermoid();
    organizermoid_ = organizermoid;
  } else {
    clear_has_organizermoid();
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizer = 7;
inline bool TMTConfInfoById::has_organizer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTConfInfoById::set_has_organizer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTConfInfoById::clear_has_organizer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTConfInfoById::clear_organizer() {
  if (organizer_ != &::google::protobuf::internal::kEmptyString) {
    organizer_->clear();
  }
  clear_has_organizer();
}
inline const ::std::string& TMTConfInfoById::organizer() const {
  return *organizer_;
}
inline void TMTConfInfoById::set_organizer(const ::std::string& value) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(value);
}
inline void TMTConfInfoById::set_organizer(const char* value) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(value);
}
inline void TMTConfInfoById::set_organizer(const char* value, size_t size) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInfoById::mutable_organizer() {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  return organizer_;
}
inline ::std::string* TMTConfInfoById::release_organizer() {
  clear_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizer_;
    organizer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInfoById::set_allocated_organizer(::std::string* organizer) {
  if (organizer_ != &::google::protobuf::internal::kEmptyString) {
    delete organizer_;
  }
  if (organizer) {
    set_has_organizer();
    organizer_ = organizer;
  } else {
    clear_has_organizer();
    organizer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizermail = 8;
inline bool TMTConfInfoById::has_organizermail() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTConfInfoById::set_has_organizermail() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTConfInfoById::clear_has_organizermail() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTConfInfoById::clear_organizermail() {
  if (organizermail_ != &::google::protobuf::internal::kEmptyString) {
    organizermail_->clear();
  }
  clear_has_organizermail();
}
inline const ::std::string& TMTConfInfoById::organizermail() const {
  return *organizermail_;
}
inline void TMTConfInfoById::set_organizermail(const ::std::string& value) {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  organizermail_->assign(value);
}
inline void TMTConfInfoById::set_organizermail(const char* value) {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  organizermail_->assign(value);
}
inline void TMTConfInfoById::set_organizermail(const char* value, size_t size) {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  organizermail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInfoById::mutable_organizermail() {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  return organizermail_;
}
inline ::std::string* TMTConfInfoById::release_organizermail() {
  clear_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermail_;
    organizermail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInfoById::set_allocated_organizermail(::std::string* organizermail) {
  if (organizermail_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermail_;
  }
  if (organizermail) {
    set_has_organizermail();
    organizermail_ = organizermail;
  } else {
    clear_has_organizermail();
    organizermail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 9;
inline bool TMTConfInfoById::has_phone() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTConfInfoById::set_has_phone() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTConfInfoById::clear_has_phone() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTConfInfoById::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& TMTConfInfoById::phone() const {
  return *phone_;
}
inline void TMTConfInfoById::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTConfInfoById::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTConfInfoById::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInfoById::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* TMTConfInfoById::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInfoById::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobile = 10;
inline bool TMTConfInfoById::has_mobile() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTConfInfoById::set_has_mobile() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTConfInfoById::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTConfInfoById::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& TMTConfInfoById::mobile() const {
  return *mobile_;
}
inline void TMTConfInfoById::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTConfInfoById::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTConfInfoById::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInfoById::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* TMTConfInfoById::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInfoById::set_allocated_mobile(::std::string* mobile) {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_;
  }
  if (mobile) {
    set_has_mobile();
    mobile_ = mobile;
  } else {
    clear_has_mobile();
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brief = 11;
inline bool TMTConfInfoById::has_brief() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTConfInfoById::set_has_brief() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTConfInfoById::clear_has_brief() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTConfInfoById::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TMTConfInfoById::brief() const {
  return *brief_;
}
inline void TMTConfInfoById::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTConfInfoById::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTConfInfoById::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInfoById::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TMTConfInfoById::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInfoById::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 isvideo = 12;
inline bool TMTConfInfoById::has_isvideo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTConfInfoById::set_has_isvideo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTConfInfoById::clear_has_isvideo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTConfInfoById::clear_isvideo() {
  isvideo_ = 0u;
  clear_has_isvideo();
}
inline ::google::protobuf::uint32 TMTConfInfoById::isvideo() const {
  return isvideo_;
}
inline void TMTConfInfoById::set_isvideo(::google::protobuf::uint32 value) {
  set_has_isvideo();
  isvideo_ = value;
}

// optional .mt.TMTConfInfoRooms confinforooms = 13;
inline bool TMTConfInfoById::has_confinforooms() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTConfInfoById::set_has_confinforooms() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTConfInfoById::clear_has_confinforooms() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTConfInfoById::clear_confinforooms() {
  if (confinforooms_ != NULL) confinforooms_->::mt::TMTConfInfoRooms::Clear();
  clear_has_confinforooms();
}
inline const ::mt::TMTConfInfoRooms& TMTConfInfoById::confinforooms() const {
  return confinforooms_ != NULL ? *confinforooms_ : *default_instance_->confinforooms_;
}
inline ::mt::TMTConfInfoRooms* TMTConfInfoById::mutable_confinforooms() {
  set_has_confinforooms();
  if (confinforooms_ == NULL) confinforooms_ = new ::mt::TMTConfInfoRooms;
  return confinforooms_;
}
inline ::mt::TMTConfInfoRooms* TMTConfInfoById::release_confinforooms() {
  clear_has_confinforooms();
  ::mt::TMTConfInfoRooms* temp = confinforooms_;
  confinforooms_ = NULL;
  return temp;
}
inline void TMTConfInfoById::set_allocated_confinforooms(::mt::TMTConfInfoRooms* confinforooms) {
  delete confinforooms_;
  confinforooms_ = confinforooms;
  if (confinforooms) {
    set_has_confinforooms();
  } else {
    clear_has_confinforooms();
  }
}

// optional .mt.TMTVideoConferenceInfo videoconfinfo = 14;
inline bool TMTConfInfoById::has_videoconfinfo() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTConfInfoById::set_has_videoconfinfo() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTConfInfoById::clear_has_videoconfinfo() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTConfInfoById::clear_videoconfinfo() {
  if (videoconfinfo_ != NULL) videoconfinfo_->::mt::TMTVideoConferenceInfo::Clear();
  clear_has_videoconfinfo();
}
inline const ::mt::TMTVideoConferenceInfo& TMTConfInfoById::videoconfinfo() const {
  return videoconfinfo_ != NULL ? *videoconfinfo_ : *default_instance_->videoconfinfo_;
}
inline ::mt::TMTVideoConferenceInfo* TMTConfInfoById::mutable_videoconfinfo() {
  set_has_videoconfinfo();
  if (videoconfinfo_ == NULL) videoconfinfo_ = new ::mt::TMTVideoConferenceInfo;
  return videoconfinfo_;
}
inline ::mt::TMTVideoConferenceInfo* TMTConfInfoById::release_videoconfinfo() {
  clear_has_videoconfinfo();
  ::mt::TMTVideoConferenceInfo* temp = videoconfinfo_;
  videoconfinfo_ = NULL;
  return temp;
}
inline void TMTConfInfoById::set_allocated_videoconfinfo(::mt::TMTVideoConferenceInfo* videoconfinfo) {
  delete videoconfinfo_;
  videoconfinfo_ = videoconfinfo;
  if (videoconfinfo) {
    set_has_videoconfinfo();
  } else {
    clear_has_videoconfinfo();
  }
}

// -------------------------------------------------------------------

// TMTParticipantInfo

// optional string moid = 1;
inline bool TMTParticipantInfo::has_moid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTParticipantInfo::set_has_moid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTParticipantInfo::clear_has_moid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTParticipantInfo::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTParticipantInfo::moid() const {
  return *moid_;
}
inline void TMTParticipantInfo::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTParticipantInfo::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTParticipantInfo::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTParticipantInfo::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTParticipantInfo::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTParticipantInfo::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 2;
inline bool TMTParticipantInfo::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTParticipantInfo::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTParticipantInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTParticipantInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& TMTParticipantInfo::email() const {
  return *email_;
}
inline void TMTParticipantInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTParticipantInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTParticipantInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTParticipantInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* TMTParticipantInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTParticipantInfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool TMTParticipantInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTParticipantInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTParticipantInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTParticipantInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTParticipantInfo::name() const {
  return *name_;
}
inline void TMTParticipantInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTParticipantInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTParticipantInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTParticipantInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTParticipantInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTParticipantInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string participantNo = 4;
inline bool TMTParticipantInfo::has_participantno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTParticipantInfo::set_has_participantno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTParticipantInfo::clear_has_participantno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTParticipantInfo::clear_participantno() {
  if (participantno_ != &::google::protobuf::internal::kEmptyString) {
    participantno_->clear();
  }
  clear_has_participantno();
}
inline const ::std::string& TMTParticipantInfo::participantno() const {
  return *participantno_;
}
inline void TMTParticipantInfo::set_participantno(const ::std::string& value) {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  participantno_->assign(value);
}
inline void TMTParticipantInfo::set_participantno(const char* value) {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  participantno_->assign(value);
}
inline void TMTParticipantInfo::set_participantno(const char* value, size_t size) {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  participantno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTParticipantInfo::mutable_participantno() {
  set_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    participantno_ = new ::std::string;
  }
  return participantno_;
}
inline ::std::string* TMTParticipantInfo::release_participantno() {
  clear_has_participantno();
  if (participantno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = participantno_;
    participantno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTParticipantInfo::set_allocated_participantno(::std::string* participantno) {
  if (participantno_ != &::google::protobuf::internal::kEmptyString) {
    delete participantno_;
  }
  if (participantno) {
    set_has_participantno();
    participantno_ = participantno;
  } else {
    clear_has_participantno();
    participantno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmParticipantResponse participantresponse = 5;
inline bool TMTParticipantInfo::has_participantresponse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTParticipantInfo::set_has_participantresponse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTParticipantInfo::clear_has_participantresponse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTParticipantInfo::clear_participantresponse() {
  participantresponse_ = 0;
  clear_has_participantresponse();
}
inline ::mt::EmParticipantResponse TMTParticipantInfo::participantresponse() const {
  return static_cast< ::mt::EmParticipantResponse >(participantresponse_);
}
inline void TMTParticipantInfo::set_participantresponse(::mt::EmParticipantResponse value) {
  assert(::mt::EmParticipantResponse_IsValid(value));
  set_has_participantresponse();
  participantresponse_ = value;
}

// optional uint32 participanttype = 6;
inline bool TMTParticipantInfo::has_participanttype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTParticipantInfo::set_has_participanttype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTParticipantInfo::clear_has_participanttype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTParticipantInfo::clear_participanttype() {
  participanttype_ = 0u;
  clear_has_participanttype();
}
inline ::google::protobuf::uint32 TMTParticipantInfo::participanttype() const {
  return participanttype_;
}
inline void TMTParticipantInfo::set_participanttype(::google::protobuf::uint32 value) {
  set_has_participanttype();
  participanttype_ = value;
}

// -------------------------------------------------------------------

// TMTConfInfoParticipants

// optional uint32 participantcount = 1;
inline bool TMTConfInfoParticipants::has_participantcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfInfoParticipants::set_has_participantcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfInfoParticipants::clear_has_participantcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfInfoParticipants::clear_participantcount() {
  participantcount_ = 0u;
  clear_has_participantcount();
}
inline ::google::protobuf::uint32 TMTConfInfoParticipants::participantcount() const {
  return participantcount_;
}
inline void TMTConfInfoParticipants::set_participantcount(::google::protobuf::uint32 value) {
  set_has_participantcount();
  participantcount_ = value;
}

// optional string confe164 = 2;
inline bool TMTConfInfoParticipants::has_confe164() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConfInfoParticipants::set_has_confe164() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConfInfoParticipants::clear_has_confe164() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConfInfoParticipants::clear_confe164() {
  if (confe164_ != &::google::protobuf::internal::kEmptyString) {
    confe164_->clear();
  }
  clear_has_confe164();
}
inline const ::std::string& TMTConfInfoParticipants::confe164() const {
  return *confe164_;
}
inline void TMTConfInfoParticipants::set_confe164(const ::std::string& value) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(value);
}
inline void TMTConfInfoParticipants::set_confe164(const char* value) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(value);
}
inline void TMTConfInfoParticipants::set_confe164(const char* value, size_t size) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInfoParticipants::mutable_confe164() {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  return confe164_;
}
inline ::std::string* TMTConfInfoParticipants::release_confe164() {
  clear_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confe164_;
    confe164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInfoParticipants::set_allocated_confe164(::std::string* confe164) {
  if (confe164_ != &::google::protobuf::internal::kEmptyString) {
    delete confe164_;
  }
  if (confe164) {
    set_has_confe164();
    confe164_ = confe164;
  } else {
    clear_has_confe164();
    confe164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 id = 3;
inline bool TMTConfInfoParticipants::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTConfInfoParticipants::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTConfInfoParticipants::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTConfInfoParticipants::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTConfInfoParticipants::id() const {
  return id_;
}
inline void TMTConfInfoParticipants::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// repeated .mt.TMTParticipantInfo participantinfo = 4;
inline int TMTConfInfoParticipants::participantinfo_size() const {
  return participantinfo_.size();
}
inline void TMTConfInfoParticipants::clear_participantinfo() {
  participantinfo_.Clear();
}
inline const ::mt::TMTParticipantInfo& TMTConfInfoParticipants::participantinfo(int index) const {
  return participantinfo_.Get(index);
}
inline ::mt::TMTParticipantInfo* TMTConfInfoParticipants::mutable_participantinfo(int index) {
  return participantinfo_.Mutable(index);
}
inline ::mt::TMTParticipantInfo* TMTConfInfoParticipants::add_participantinfo() {
  return participantinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTParticipantInfo >&
TMTConfInfoParticipants::participantinfo() const {
  return participantinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTParticipantInfo >*
TMTConfInfoParticipants::mutable_participantinfo() {
  return &participantinfo_;
}

// -------------------------------------------------------------------

// TMTRoomInfoById

// optional uint32 id = 1;
inline bool TMTRoomInfoById::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRoomInfoById::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRoomInfoById::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRoomInfoById::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTRoomInfoById::id() const {
  return id_;
}
inline void TMTRoomInfoById::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool TMTRoomInfoById::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRoomInfoById::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRoomInfoById::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRoomInfoById::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTRoomInfoById::name() const {
  return *name_;
}
inline void TMTRoomInfoById::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRoomInfoById::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTRoomInfoById::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomInfoById::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTRoomInfoById::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomInfoById::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 peopleadmit = 3;
inline bool TMTRoomInfoById::has_peopleadmit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRoomInfoById::set_has_peopleadmit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRoomInfoById::clear_has_peopleadmit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRoomInfoById::clear_peopleadmit() {
  peopleadmit_ = 0u;
  clear_has_peopleadmit();
}
inline ::google::protobuf::uint32 TMTRoomInfoById::peopleadmit() const {
  return peopleadmit_;
}
inline void TMTRoomInfoById::set_peopleadmit(::google::protobuf::uint32 value) {
  set_has_peopleadmit();
  peopleadmit_ = value;
}

// optional uint32 area = 4;
inline bool TMTRoomInfoById::has_area() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTRoomInfoById::set_has_area() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTRoomInfoById::clear_has_area() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTRoomInfoById::clear_area() {
  area_ = 0u;
  clear_has_area();
}
inline ::google::protobuf::uint32 TMTRoomInfoById::area() const {
  return area_;
}
inline void TMTRoomInfoById::set_area(::google::protobuf::uint32 value) {
  set_has_area();
  area_ = value;
}

// optional string phone = 5;
inline bool TMTRoomInfoById::has_phone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTRoomInfoById::set_has_phone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTRoomInfoById::clear_has_phone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTRoomInfoById::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& TMTRoomInfoById::phone() const {
  return *phone_;
}
inline void TMTRoomInfoById::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTRoomInfoById::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTRoomInfoById::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomInfoById::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* TMTRoomInfoById::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomInfoById::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 hasvideo = 6;
inline bool TMTRoomInfoById::has_hasvideo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTRoomInfoById::set_has_hasvideo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTRoomInfoById::clear_has_hasvideo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTRoomInfoById::clear_hasvideo() {
  hasvideo_ = 0u;
  clear_has_hasvideo();
}
inline ::google::protobuf::uint32 TMTRoomInfoById::hasvideo() const {
  return hasvideo_;
}
inline void TMTRoomInfoById::set_hasvideo(::google::protobuf::uint32 value) {
  set_has_hasvideo();
  hasvideo_ = value;
}

// optional string e164 = 7;
inline bool TMTRoomInfoById::has_e164() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTRoomInfoById::set_has_e164() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTRoomInfoById::clear_has_e164() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTRoomInfoById::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTRoomInfoById::e164() const {
  return *e164_;
}
inline void TMTRoomInfoById::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTRoomInfoById::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTRoomInfoById::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomInfoById::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTRoomInfoById::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomInfoById::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceadmin = 8;
inline bool TMTRoomInfoById::has_deviceadmin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTRoomInfoById::set_has_deviceadmin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTRoomInfoById::clear_has_deviceadmin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTRoomInfoById::clear_deviceadmin() {
  if (deviceadmin_ != &::google::protobuf::internal::kEmptyString) {
    deviceadmin_->clear();
  }
  clear_has_deviceadmin();
}
inline const ::std::string& TMTRoomInfoById::deviceadmin() const {
  return *deviceadmin_;
}
inline void TMTRoomInfoById::set_deviceadmin(const ::std::string& value) {
  set_has_deviceadmin();
  if (deviceadmin_ == &::google::protobuf::internal::kEmptyString) {
    deviceadmin_ = new ::std::string;
  }
  deviceadmin_->assign(value);
}
inline void TMTRoomInfoById::set_deviceadmin(const char* value) {
  set_has_deviceadmin();
  if (deviceadmin_ == &::google::protobuf::internal::kEmptyString) {
    deviceadmin_ = new ::std::string;
  }
  deviceadmin_->assign(value);
}
inline void TMTRoomInfoById::set_deviceadmin(const char* value, size_t size) {
  set_has_deviceadmin();
  if (deviceadmin_ == &::google::protobuf::internal::kEmptyString) {
    deviceadmin_ = new ::std::string;
  }
  deviceadmin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomInfoById::mutable_deviceadmin() {
  set_has_deviceadmin();
  if (deviceadmin_ == &::google::protobuf::internal::kEmptyString) {
    deviceadmin_ = new ::std::string;
  }
  return deviceadmin_;
}
inline ::std::string* TMTRoomInfoById::release_deviceadmin() {
  clear_has_deviceadmin();
  if (deviceadmin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceadmin_;
    deviceadmin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomInfoById::set_allocated_deviceadmin(::std::string* deviceadmin) {
  if (deviceadmin_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceadmin_;
  }
  if (deviceadmin) {
    set_has_deviceadmin();
    deviceadmin_ = deviceadmin;
  } else {
    clear_has_deviceadmin();
    deviceadmin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string adminphone = 9;
inline bool TMTRoomInfoById::has_adminphone() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTRoomInfoById::set_has_adminphone() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTRoomInfoById::clear_has_adminphone() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTRoomInfoById::clear_adminphone() {
  if (adminphone_ != &::google::protobuf::internal::kEmptyString) {
    adminphone_->clear();
  }
  clear_has_adminphone();
}
inline const ::std::string& TMTRoomInfoById::adminphone() const {
  return *adminphone_;
}
inline void TMTRoomInfoById::set_adminphone(const ::std::string& value) {
  set_has_adminphone();
  if (adminphone_ == &::google::protobuf::internal::kEmptyString) {
    adminphone_ = new ::std::string;
  }
  adminphone_->assign(value);
}
inline void TMTRoomInfoById::set_adminphone(const char* value) {
  set_has_adminphone();
  if (adminphone_ == &::google::protobuf::internal::kEmptyString) {
    adminphone_ = new ::std::string;
  }
  adminphone_->assign(value);
}
inline void TMTRoomInfoById::set_adminphone(const char* value, size_t size) {
  set_has_adminphone();
  if (adminphone_ == &::google::protobuf::internal::kEmptyString) {
    adminphone_ = new ::std::string;
  }
  adminphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomInfoById::mutable_adminphone() {
  set_has_adminphone();
  if (adminphone_ == &::google::protobuf::internal::kEmptyString) {
    adminphone_ = new ::std::string;
  }
  return adminphone_;
}
inline ::std::string* TMTRoomInfoById::release_adminphone() {
  clear_has_adminphone();
  if (adminphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = adminphone_;
    adminphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomInfoById::set_allocated_adminphone(::std::string* adminphone) {
  if (adminphone_ != &::google::protobuf::internal::kEmptyString) {
    delete adminphone_;
  }
  if (adminphone) {
    set_has_adminphone();
    adminphone_ = adminphone;
  } else {
    clear_has_adminphone();
    adminphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string remark = 10;
inline bool TMTRoomInfoById::has_remark() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTRoomInfoById::set_has_remark() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTRoomInfoById::clear_has_remark() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTRoomInfoById::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& TMTRoomInfoById::remark() const {
  return *remark_;
}
inline void TMTRoomInfoById::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void TMTRoomInfoById::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void TMTRoomInfoById::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRoomInfoById::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* TMTRoomInfoById::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRoomInfoById::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 devicemask = 11;
inline bool TMTRoomInfoById::has_devicemask() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTRoomInfoById::set_has_devicemask() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTRoomInfoById::clear_has_devicemask() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTRoomInfoById::clear_devicemask() {
  devicemask_ = 0u;
  clear_has_devicemask();
}
inline ::google::protobuf::uint32 TMTRoomInfoById::devicemask() const {
  return devicemask_;
}
inline void TMTRoomInfoById::set_devicemask(::google::protobuf::uint32 value) {
  set_has_devicemask();
  devicemask_ = value;
}

// -------------------------------------------------------------------

// TMTCommonConfInfo

// optional uint32 id = 1;
inline bool TMTCommonConfInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCommonConfInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCommonConfInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCommonConfInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTCommonConfInfo::id() const {
  return id_;
}
inline void TMTCommonConfInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string receivermoid = 2;
inline bool TMTCommonConfInfo::has_receivermoid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCommonConfInfo::set_has_receivermoid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCommonConfInfo::clear_has_receivermoid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCommonConfInfo::clear_receivermoid() {
  if (receivermoid_ != &::google::protobuf::internal::kEmptyString) {
    receivermoid_->clear();
  }
  clear_has_receivermoid();
}
inline const ::std::string& TMTCommonConfInfo::receivermoid() const {
  return *receivermoid_;
}
inline void TMTCommonConfInfo::set_receivermoid(const ::std::string& value) {
  set_has_receivermoid();
  if (receivermoid_ == &::google::protobuf::internal::kEmptyString) {
    receivermoid_ = new ::std::string;
  }
  receivermoid_->assign(value);
}
inline void TMTCommonConfInfo::set_receivermoid(const char* value) {
  set_has_receivermoid();
  if (receivermoid_ == &::google::protobuf::internal::kEmptyString) {
    receivermoid_ = new ::std::string;
  }
  receivermoid_->assign(value);
}
inline void TMTCommonConfInfo::set_receivermoid(const char* value, size_t size) {
  set_has_receivermoid();
  if (receivermoid_ == &::google::protobuf::internal::kEmptyString) {
    receivermoid_ = new ::std::string;
  }
  receivermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCommonConfInfo::mutable_receivermoid() {
  set_has_receivermoid();
  if (receivermoid_ == &::google::protobuf::internal::kEmptyString) {
    receivermoid_ = new ::std::string;
  }
  return receivermoid_;
}
inline ::std::string* TMTCommonConfInfo::release_receivermoid() {
  clear_has_receivermoid();
  if (receivermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receivermoid_;
    receivermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCommonConfInfo::set_allocated_receivermoid(::std::string* receivermoid) {
  if (receivermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete receivermoid_;
  }
  if (receivermoid) {
    set_has_receivermoid();
    receivermoid_ = receivermoid;
  } else {
    clear_has_receivermoid();
    receivermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 messagetype = 3;
inline bool TMTCommonConfInfo::has_messagetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTCommonConfInfo::set_has_messagetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTCommonConfInfo::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTCommonConfInfo::clear_messagetype() {
  messagetype_ = 0u;
  clear_has_messagetype();
}
inline ::google::protobuf::uint32 TMTCommonConfInfo::messagetype() const {
  return messagetype_;
}
inline void TMTCommonConfInfo::set_messagetype(::google::protobuf::uint32 value) {
  set_has_messagetype();
  messagetype_ = value;
}

// optional string companymoid = 4;
inline bool TMTCommonConfInfo::has_companymoid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTCommonConfInfo::set_has_companymoid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTCommonConfInfo::clear_has_companymoid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTCommonConfInfo::clear_companymoid() {
  if (companymoid_ != &::google::protobuf::internal::kEmptyString) {
    companymoid_->clear();
  }
  clear_has_companymoid();
}
inline const ::std::string& TMTCommonConfInfo::companymoid() const {
  return *companymoid_;
}
inline void TMTCommonConfInfo::set_companymoid(const ::std::string& value) {
  set_has_companymoid();
  if (companymoid_ == &::google::protobuf::internal::kEmptyString) {
    companymoid_ = new ::std::string;
  }
  companymoid_->assign(value);
}
inline void TMTCommonConfInfo::set_companymoid(const char* value) {
  set_has_companymoid();
  if (companymoid_ == &::google::protobuf::internal::kEmptyString) {
    companymoid_ = new ::std::string;
  }
  companymoid_->assign(value);
}
inline void TMTCommonConfInfo::set_companymoid(const char* value, size_t size) {
  set_has_companymoid();
  if (companymoid_ == &::google::protobuf::internal::kEmptyString) {
    companymoid_ = new ::std::string;
  }
  companymoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCommonConfInfo::mutable_companymoid() {
  set_has_companymoid();
  if (companymoid_ == &::google::protobuf::internal::kEmptyString) {
    companymoid_ = new ::std::string;
  }
  return companymoid_;
}
inline ::std::string* TMTCommonConfInfo::release_companymoid() {
  clear_has_companymoid();
  if (companymoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = companymoid_;
    companymoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCommonConfInfo::set_allocated_companymoid(::std::string* companymoid) {
  if (companymoid_ != &::google::protobuf::internal::kEmptyString) {
    delete companymoid_;
  }
  if (companymoid) {
    set_has_companymoid();
    companymoid_ = companymoid;
  } else {
    clear_has_companymoid();
    companymoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string createtime = 5;
inline bool TMTCommonConfInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTCommonConfInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTCommonConfInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTCommonConfInfo::clear_createtime() {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    createtime_->clear();
  }
  clear_has_createtime();
}
inline const ::std::string& TMTCommonConfInfo::createtime() const {
  return *createtime_;
}
inline void TMTCommonConfInfo::set_createtime(const ::std::string& value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void TMTCommonConfInfo::set_createtime(const char* value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void TMTCommonConfInfo::set_createtime(const char* value, size_t size) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCommonConfInfo::mutable_createtime() {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  return createtime_;
}
inline ::std::string* TMTCommonConfInfo::release_createtime() {
  clear_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createtime_;
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCommonConfInfo::set_allocated_createtime(::std::string* createtime) {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    delete createtime_;
  }
  if (createtime) {
    set_has_createtime();
    createtime_ = createtime;
  } else {
    clear_has_createtime();
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTContentCreateMeeting

// optional uint32 id = 1;
inline bool TMTContentCreateMeeting::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentCreateMeeting::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentCreateMeeting::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentCreateMeeting::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTContentCreateMeeting::id() const {
  return id_;
}
inline void TMTContentCreateMeeting::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string subject = 2;
inline bool TMTContentCreateMeeting::has_subject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTContentCreateMeeting::set_has_subject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTContentCreateMeeting::clear_has_subject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTContentCreateMeeting::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTContentCreateMeeting::subject() const {
  return *subject_;
}
inline void TMTContentCreateMeeting::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentCreateMeeting::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentCreateMeeting::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentCreateMeeting::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTContentCreateMeeting::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentCreateMeeting::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string starttime = 3;
inline bool TMTContentCreateMeeting::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTContentCreateMeeting::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTContentCreateMeeting::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTContentCreateMeeting::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTContentCreateMeeting::starttime() const {
  return *starttime_;
}
inline void TMTContentCreateMeeting::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentCreateMeeting::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentCreateMeeting::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentCreateMeeting::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTContentCreateMeeting::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentCreateMeeting::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 4;
inline bool TMTContentCreateMeeting::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTContentCreateMeeting::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTContentCreateMeeting::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTContentCreateMeeting::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTContentCreateMeeting::endtime() const {
  return *endtime_;
}
inline void TMTContentCreateMeeting::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentCreateMeeting::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentCreateMeeting::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentCreateMeeting::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTContentCreateMeeting::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentCreateMeeting::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isvideomeeting = 5;
inline bool TMTContentCreateMeeting::has_isvideomeeting() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTContentCreateMeeting::set_has_isvideomeeting() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTContentCreateMeeting::clear_has_isvideomeeting() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTContentCreateMeeting::clear_isvideomeeting() {
  isvideomeeting_ = false;
  clear_has_isvideomeeting();
}
inline bool TMTContentCreateMeeting::isvideomeeting() const {
  return isvideomeeting_;
}
inline void TMTContentCreateMeeting::set_isvideomeeting(bool value) {
  set_has_isvideomeeting();
  isvideomeeting_ = value;
}

// optional string phone = 6;
inline bool TMTContentCreateMeeting::has_phone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTContentCreateMeeting::set_has_phone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTContentCreateMeeting::clear_has_phone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTContentCreateMeeting::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& TMTContentCreateMeeting::phone() const {
  return *phone_;
}
inline void TMTContentCreateMeeting::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTContentCreateMeeting::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTContentCreateMeeting::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentCreateMeeting::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* TMTContentCreateMeeting::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentCreateMeeting::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobilephone = 7;
inline bool TMTContentCreateMeeting::has_mobilephone() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTContentCreateMeeting::set_has_mobilephone() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTContentCreateMeeting::clear_has_mobilephone() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTContentCreateMeeting::clear_mobilephone() {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    mobilephone_->clear();
  }
  clear_has_mobilephone();
}
inline const ::std::string& TMTContentCreateMeeting::mobilephone() const {
  return *mobilephone_;
}
inline void TMTContentCreateMeeting::set_mobilephone(const ::std::string& value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void TMTContentCreateMeeting::set_mobilephone(const char* value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void TMTContentCreateMeeting::set_mobilephone(const char* value, size_t size) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentCreateMeeting::mutable_mobilephone() {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  return mobilephone_;
}
inline ::std::string* TMTContentCreateMeeting::release_mobilephone() {
  clear_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilephone_;
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentCreateMeeting::set_allocated_mobilephone(::std::string* mobilephone) {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    delete mobilephone_;
  }
  if (mobilephone) {
    set_has_mobilephone();
    mobilephone_ = mobilephone;
  } else {
    clear_has_mobilephone();
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizer = 8;
inline bool TMTContentCreateMeeting::has_organizer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTContentCreateMeeting::set_has_organizer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTContentCreateMeeting::clear_has_organizer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTContentCreateMeeting::clear_organizer() {
  if (organizer_ != &::google::protobuf::internal::kEmptyString) {
    organizer_->clear();
  }
  clear_has_organizer();
}
inline const ::std::string& TMTContentCreateMeeting::organizer() const {
  return *organizer_;
}
inline void TMTContentCreateMeeting::set_organizer(const ::std::string& value) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(value);
}
inline void TMTContentCreateMeeting::set_organizer(const char* value) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(value);
}
inline void TMTContentCreateMeeting::set_organizer(const char* value, size_t size) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentCreateMeeting::mutable_organizer() {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  return organizer_;
}
inline ::std::string* TMTContentCreateMeeting::release_organizer() {
  clear_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizer_;
    organizer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentCreateMeeting::set_allocated_organizer(::std::string* organizer) {
  if (organizer_ != &::google::protobuf::internal::kEmptyString) {
    delete organizer_;
  }
  if (organizer) {
    set_has_organizer();
    organizer_ = organizer;
  } else {
    clear_has_organizer();
    organizer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizermoid = 9;
inline bool TMTContentCreateMeeting::has_organizermoid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTContentCreateMeeting::set_has_organizermoid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTContentCreateMeeting::clear_has_organizermoid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTContentCreateMeeting::clear_organizermoid() {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    organizermoid_->clear();
  }
  clear_has_organizermoid();
}
inline const ::std::string& TMTContentCreateMeeting::organizermoid() const {
  return *organizermoid_;
}
inline void TMTContentCreateMeeting::set_organizermoid(const ::std::string& value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentCreateMeeting::set_organizermoid(const char* value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentCreateMeeting::set_organizermoid(const char* value, size_t size) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentCreateMeeting::mutable_organizermoid() {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  return organizermoid_;
}
inline ::std::string* TMTContentCreateMeeting::release_organizermoid() {
  clear_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermoid_;
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentCreateMeeting::set_allocated_organizermoid(::std::string* organizermoid) {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermoid_;
  }
  if (organizermoid) {
    set_has_organizermoid();
    organizermoid_ = organizermoid;
  } else {
    clear_has_organizermoid();
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTConfInfoRooms room = 10;
inline bool TMTContentCreateMeeting::has_room() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTContentCreateMeeting::set_has_room() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTContentCreateMeeting::clear_has_room() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTContentCreateMeeting::clear_room() {
  if (room_ != NULL) room_->::mt::TMTConfInfoRooms::Clear();
  clear_has_room();
}
inline const ::mt::TMTConfInfoRooms& TMTContentCreateMeeting::room() const {
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::mt::TMTConfInfoRooms* TMTContentCreateMeeting::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::mt::TMTConfInfoRooms;
  return room_;
}
inline ::mt::TMTConfInfoRooms* TMTContentCreateMeeting::release_room() {
  clear_has_room();
  ::mt::TMTConfInfoRooms* temp = room_;
  room_ = NULL;
  return temp;
}
inline void TMTContentCreateMeeting::set_allocated_room(::mt::TMTConfInfoRooms* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
}

// -------------------------------------------------------------------

// TMTContentUpdateMeeting

// optional uint32 id = 1;
inline bool TMTContentUpdateMeeting::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentUpdateMeeting::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentUpdateMeeting::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentUpdateMeeting::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTContentUpdateMeeting::id() const {
  return id_;
}
inline void TMTContentUpdateMeeting::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string subject = 2;
inline bool TMTContentUpdateMeeting::has_subject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTContentUpdateMeeting::set_has_subject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTContentUpdateMeeting::clear_has_subject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTContentUpdateMeeting::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTContentUpdateMeeting::subject() const {
  return *subject_;
}
inline void TMTContentUpdateMeeting::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentUpdateMeeting::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentUpdateMeeting::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentUpdateMeeting::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTContentUpdateMeeting::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentUpdateMeeting::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string starttime = 3;
inline bool TMTContentUpdateMeeting::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTContentUpdateMeeting::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTContentUpdateMeeting::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTContentUpdateMeeting::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTContentUpdateMeeting::starttime() const {
  return *starttime_;
}
inline void TMTContentUpdateMeeting::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentUpdateMeeting::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentUpdateMeeting::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentUpdateMeeting::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTContentUpdateMeeting::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentUpdateMeeting::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 4;
inline bool TMTContentUpdateMeeting::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTContentUpdateMeeting::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTContentUpdateMeeting::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTContentUpdateMeeting::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTContentUpdateMeeting::endtime() const {
  return *endtime_;
}
inline void TMTContentUpdateMeeting::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentUpdateMeeting::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentUpdateMeeting::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentUpdateMeeting::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTContentUpdateMeeting::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentUpdateMeeting::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizermoid = 5;
inline bool TMTContentUpdateMeeting::has_organizermoid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTContentUpdateMeeting::set_has_organizermoid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTContentUpdateMeeting::clear_has_organizermoid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTContentUpdateMeeting::clear_organizermoid() {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    organizermoid_->clear();
  }
  clear_has_organizermoid();
}
inline const ::std::string& TMTContentUpdateMeeting::organizermoid() const {
  return *organizermoid_;
}
inline void TMTContentUpdateMeeting::set_organizermoid(const ::std::string& value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentUpdateMeeting::set_organizermoid(const char* value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentUpdateMeeting::set_organizermoid(const char* value, size_t size) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentUpdateMeeting::mutable_organizermoid() {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  return organizermoid_;
}
inline ::std::string* TMTContentUpdateMeeting::release_organizermoid() {
  clear_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermoid_;
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentUpdateMeeting::set_allocated_organizermoid(::std::string* organizermoid) {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermoid_;
  }
  if (organizermoid) {
    set_has_organizermoid();
    organizermoid_ = organizermoid;
  } else {
    clear_has_organizermoid();
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brief = 6;
inline bool TMTContentUpdateMeeting::has_brief() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTContentUpdateMeeting::set_has_brief() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTContentUpdateMeeting::clear_has_brief() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTContentUpdateMeeting::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TMTContentUpdateMeeting::brief() const {
  return *brief_;
}
inline void TMTContentUpdateMeeting::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTContentUpdateMeeting::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTContentUpdateMeeting::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentUpdateMeeting::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TMTContentUpdateMeeting::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentUpdateMeeting::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string beforesubject = 7;
inline bool TMTContentUpdateMeeting::has_beforesubject() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTContentUpdateMeeting::set_has_beforesubject() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTContentUpdateMeeting::clear_has_beforesubject() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTContentUpdateMeeting::clear_beforesubject() {
  if (beforesubject_ != &::google::protobuf::internal::kEmptyString) {
    beforesubject_->clear();
  }
  clear_has_beforesubject();
}
inline const ::std::string& TMTContentUpdateMeeting::beforesubject() const {
  return *beforesubject_;
}
inline void TMTContentUpdateMeeting::set_beforesubject(const ::std::string& value) {
  set_has_beforesubject();
  if (beforesubject_ == &::google::protobuf::internal::kEmptyString) {
    beforesubject_ = new ::std::string;
  }
  beforesubject_->assign(value);
}
inline void TMTContentUpdateMeeting::set_beforesubject(const char* value) {
  set_has_beforesubject();
  if (beforesubject_ == &::google::protobuf::internal::kEmptyString) {
    beforesubject_ = new ::std::string;
  }
  beforesubject_->assign(value);
}
inline void TMTContentUpdateMeeting::set_beforesubject(const char* value, size_t size) {
  set_has_beforesubject();
  if (beforesubject_ == &::google::protobuf::internal::kEmptyString) {
    beforesubject_ = new ::std::string;
  }
  beforesubject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentUpdateMeeting::mutable_beforesubject() {
  set_has_beforesubject();
  if (beforesubject_ == &::google::protobuf::internal::kEmptyString) {
    beforesubject_ = new ::std::string;
  }
  return beforesubject_;
}
inline ::std::string* TMTContentUpdateMeeting::release_beforesubject() {
  clear_has_beforesubject();
  if (beforesubject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beforesubject_;
    beforesubject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentUpdateMeeting::set_allocated_beforesubject(::std::string* beforesubject) {
  if (beforesubject_ != &::google::protobuf::internal::kEmptyString) {
    delete beforesubject_;
  }
  if (beforesubject) {
    set_has_beforesubject();
    beforesubject_ = beforesubject;
  } else {
    clear_has_beforesubject();
    beforesubject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTConfInfoRooms room = 8;
inline bool TMTContentUpdateMeeting::has_room() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTContentUpdateMeeting::set_has_room() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTContentUpdateMeeting::clear_has_room() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTContentUpdateMeeting::clear_room() {
  if (room_ != NULL) room_->::mt::TMTConfInfoRooms::Clear();
  clear_has_room();
}
inline const ::mt::TMTConfInfoRooms& TMTContentUpdateMeeting::room() const {
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::mt::TMTConfInfoRooms* TMTContentUpdateMeeting::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::mt::TMTConfInfoRooms;
  return room_;
}
inline ::mt::TMTConfInfoRooms* TMTContentUpdateMeeting::release_room() {
  clear_has_room();
  ::mt::TMTConfInfoRooms* temp = room_;
  room_ = NULL;
  return temp;
}
inline void TMTContentUpdateMeeting::set_allocated_room(::mt::TMTConfInfoRooms* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
}

// -------------------------------------------------------------------

// TMTContentOutMeeting

// optional uint32 id = 1;
inline bool TMTContentOutMeeting::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentOutMeeting::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentOutMeeting::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentOutMeeting::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTContentOutMeeting::id() const {
  return id_;
}
inline void TMTContentOutMeeting::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string subject = 2;
inline bool TMTContentOutMeeting::has_subject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTContentOutMeeting::set_has_subject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTContentOutMeeting::clear_has_subject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTContentOutMeeting::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTContentOutMeeting::subject() const {
  return *subject_;
}
inline void TMTContentOutMeeting::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentOutMeeting::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentOutMeeting::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentOutMeeting::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTContentOutMeeting::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentOutMeeting::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizermoid = 3;
inline bool TMTContentOutMeeting::has_organizermoid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTContentOutMeeting::set_has_organizermoid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTContentOutMeeting::clear_has_organizermoid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTContentOutMeeting::clear_organizermoid() {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    organizermoid_->clear();
  }
  clear_has_organizermoid();
}
inline const ::std::string& TMTContentOutMeeting::organizermoid() const {
  return *organizermoid_;
}
inline void TMTContentOutMeeting::set_organizermoid(const ::std::string& value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentOutMeeting::set_organizermoid(const char* value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentOutMeeting::set_organizermoid(const char* value, size_t size) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentOutMeeting::mutable_organizermoid() {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  return organizermoid_;
}
inline ::std::string* TMTContentOutMeeting::release_organizermoid() {
  clear_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermoid_;
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentOutMeeting::set_allocated_organizermoid(::std::string* organizermoid) {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermoid_;
  }
  if (organizermoid) {
    set_has_organizermoid();
    organizermoid_ = organizermoid;
  } else {
    clear_has_organizermoid();
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTContentNotStartMeeting

// optional uint32 id = 1;
inline bool TMTContentNotStartMeeting::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentNotStartMeeting::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentNotStartMeeting::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentNotStartMeeting::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTContentNotStartMeeting::id() const {
  return id_;
}
inline void TMTContentNotStartMeeting::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string subject = 2;
inline bool TMTContentNotStartMeeting::has_subject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTContentNotStartMeeting::set_has_subject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTContentNotStartMeeting::clear_has_subject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTContentNotStartMeeting::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTContentNotStartMeeting::subject() const {
  return *subject_;
}
inline void TMTContentNotStartMeeting::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentNotStartMeeting::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentNotStartMeeting::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentNotStartMeeting::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTContentNotStartMeeting::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentNotStartMeeting::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string starttime = 3;
inline bool TMTContentNotStartMeeting::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTContentNotStartMeeting::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTContentNotStartMeeting::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTContentNotStartMeeting::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTContentNotStartMeeting::starttime() const {
  return *starttime_;
}
inline void TMTContentNotStartMeeting::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentNotStartMeeting::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentNotStartMeeting::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentNotStartMeeting::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTContentNotStartMeeting::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentNotStartMeeting::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 4;
inline bool TMTContentNotStartMeeting::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTContentNotStartMeeting::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTContentNotStartMeeting::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTContentNotStartMeeting::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTContentNotStartMeeting::endtime() const {
  return *endtime_;
}
inline void TMTContentNotStartMeeting::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentNotStartMeeting::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentNotStartMeeting::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentNotStartMeeting::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTContentNotStartMeeting::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentNotStartMeeting::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizermoid = 5;
inline bool TMTContentNotStartMeeting::has_organizermoid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTContentNotStartMeeting::set_has_organizermoid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTContentNotStartMeeting::clear_has_organizermoid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTContentNotStartMeeting::clear_organizermoid() {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    organizermoid_->clear();
  }
  clear_has_organizermoid();
}
inline const ::std::string& TMTContentNotStartMeeting::organizermoid() const {
  return *organizermoid_;
}
inline void TMTContentNotStartMeeting::set_organizermoid(const ::std::string& value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentNotStartMeeting::set_organizermoid(const char* value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentNotStartMeeting::set_organizermoid(const char* value, size_t size) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentNotStartMeeting::mutable_organizermoid() {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  return organizermoid_;
}
inline ::std::string* TMTContentNotStartMeeting::release_organizermoid() {
  clear_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermoid_;
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentNotStartMeeting::set_allocated_organizermoid(::std::string* organizermoid) {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermoid_;
  }
  if (organizermoid) {
    set_has_organizermoid();
    organizermoid_ = organizermoid;
  } else {
    clear_has_organizermoid();
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTConfInfoRooms room = 6;
inline bool TMTContentNotStartMeeting::has_room() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTContentNotStartMeeting::set_has_room() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTContentNotStartMeeting::clear_has_room() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTContentNotStartMeeting::clear_room() {
  if (room_ != NULL) room_->::mt::TMTConfInfoRooms::Clear();
  clear_has_room();
}
inline const ::mt::TMTConfInfoRooms& TMTContentNotStartMeeting::room() const {
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::mt::TMTConfInfoRooms* TMTContentNotStartMeeting::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::mt::TMTConfInfoRooms;
  return room_;
}
inline ::mt::TMTConfInfoRooms* TMTContentNotStartMeeting::release_room() {
  clear_has_room();
  ::mt::TMTConfInfoRooms* temp = room_;
  room_ = NULL;
  return temp;
}
inline void TMTContentNotStartMeeting::set_allocated_room(::mt::TMTConfInfoRooms* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
}

// -------------------------------------------------------------------

// TMTContentDeadlineChanged

// optional string deadline = 1;
inline bool TMTContentDeadlineChanged::has_deadline() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentDeadlineChanged::set_has_deadline() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentDeadlineChanged::clear_has_deadline() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentDeadlineChanged::clear_deadline() {
  if (deadline_ != &::google::protobuf::internal::kEmptyString) {
    deadline_->clear();
  }
  clear_has_deadline();
}
inline const ::std::string& TMTContentDeadlineChanged::deadline() const {
  return *deadline_;
}
inline void TMTContentDeadlineChanged::set_deadline(const ::std::string& value) {
  set_has_deadline();
  if (deadline_ == &::google::protobuf::internal::kEmptyString) {
    deadline_ = new ::std::string;
  }
  deadline_->assign(value);
}
inline void TMTContentDeadlineChanged::set_deadline(const char* value) {
  set_has_deadline();
  if (deadline_ == &::google::protobuf::internal::kEmptyString) {
    deadline_ = new ::std::string;
  }
  deadline_->assign(value);
}
inline void TMTContentDeadlineChanged::set_deadline(const char* value, size_t size) {
  set_has_deadline();
  if (deadline_ == &::google::protobuf::internal::kEmptyString) {
    deadline_ = new ::std::string;
  }
  deadline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentDeadlineChanged::mutable_deadline() {
  set_has_deadline();
  if (deadline_ == &::google::protobuf::internal::kEmptyString) {
    deadline_ = new ::std::string;
  }
  return deadline_;
}
inline ::std::string* TMTContentDeadlineChanged::release_deadline() {
  clear_has_deadline();
  if (deadline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deadline_;
    deadline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentDeadlineChanged::set_allocated_deadline(::std::string* deadline) {
  if (deadline_ != &::google::protobuf::internal::kEmptyString) {
    delete deadline_;
  }
  if (deadline) {
    set_has_deadline();
    deadline_ = deadline;
  } else {
    clear_has_deadline();
    deadline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTContentRegularMeeting

// optional uint32 regularid = 1;
inline bool TMTContentRegularMeeting::has_regularid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentRegularMeeting::set_has_regularid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentRegularMeeting::clear_has_regularid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentRegularMeeting::clear_regularid() {
  regularid_ = 0u;
  clear_has_regularid();
}
inline ::google::protobuf::uint32 TMTContentRegularMeeting::regularid() const {
  return regularid_;
}
inline void TMTContentRegularMeeting::set_regularid(::google::protobuf::uint32 value) {
  set_has_regularid();
  regularid_ = value;
}

// optional string organizermoid = 2;
inline bool TMTContentRegularMeeting::has_organizermoid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTContentRegularMeeting::set_has_organizermoid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTContentRegularMeeting::clear_has_organizermoid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTContentRegularMeeting::clear_organizermoid() {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    organizermoid_->clear();
  }
  clear_has_organizermoid();
}
inline const ::std::string& TMTContentRegularMeeting::organizermoid() const {
  return *organizermoid_;
}
inline void TMTContentRegularMeeting::set_organizermoid(const ::std::string& value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentRegularMeeting::set_organizermoid(const char* value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentRegularMeeting::set_organizermoid(const char* value, size_t size) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_organizermoid() {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  return organizermoid_;
}
inline ::std::string* TMTContentRegularMeeting::release_organizermoid() {
  clear_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermoid_;
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_organizermoid(::std::string* organizermoid) {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermoid_;
  }
  if (organizermoid) {
    set_has_organizermoid();
    organizermoid_ = organizermoid;
  } else {
    clear_has_organizermoid();
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string subject = 3;
inline bool TMTContentRegularMeeting::has_subject() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTContentRegularMeeting::set_has_subject() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTContentRegularMeeting::clear_has_subject() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTContentRegularMeeting::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTContentRegularMeeting::subject() const {
  return *subject_;
}
inline void TMTContentRegularMeeting::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentRegularMeeting::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentRegularMeeting::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTContentRegularMeeting::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizermail = 4;
inline bool TMTContentRegularMeeting::has_organizermail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTContentRegularMeeting::set_has_organizermail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTContentRegularMeeting::clear_has_organizermail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTContentRegularMeeting::clear_organizermail() {
  if (organizermail_ != &::google::protobuf::internal::kEmptyString) {
    organizermail_->clear();
  }
  clear_has_organizermail();
}
inline const ::std::string& TMTContentRegularMeeting::organizermail() const {
  return *organizermail_;
}
inline void TMTContentRegularMeeting::set_organizermail(const ::std::string& value) {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  organizermail_->assign(value);
}
inline void TMTContentRegularMeeting::set_organizermail(const char* value) {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  organizermail_->assign(value);
}
inline void TMTContentRegularMeeting::set_organizermail(const char* value, size_t size) {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  organizermail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_organizermail() {
  set_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    organizermail_ = new ::std::string;
  }
  return organizermail_;
}
inline ::std::string* TMTContentRegularMeeting::release_organizermail() {
  clear_has_organizermail();
  if (organizermail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermail_;
    organizermail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_organizermail(::std::string* organizermail) {
  if (organizermail_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermail_;
  }
  if (organizermail) {
    set_has_organizermail();
    organizermail_ = organizermail;
  } else {
    clear_has_organizermail();
    organizermail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizer = 5;
inline bool TMTContentRegularMeeting::has_organizer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTContentRegularMeeting::set_has_organizer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTContentRegularMeeting::clear_has_organizer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTContentRegularMeeting::clear_organizer() {
  if (organizer_ != &::google::protobuf::internal::kEmptyString) {
    organizer_->clear();
  }
  clear_has_organizer();
}
inline const ::std::string& TMTContentRegularMeeting::organizer() const {
  return *organizer_;
}
inline void TMTContentRegularMeeting::set_organizer(const ::std::string& value) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(value);
}
inline void TMTContentRegularMeeting::set_organizer(const char* value) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(value);
}
inline void TMTContentRegularMeeting::set_organizer(const char* value, size_t size) {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  organizer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_organizer() {
  set_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    organizer_ = new ::std::string;
  }
  return organizer_;
}
inline ::std::string* TMTContentRegularMeeting::release_organizer() {
  clear_has_organizer();
  if (organizer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizer_;
    organizer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_organizer(::std::string* organizer) {
  if (organizer_ != &::google::protobuf::internal::kEmptyString) {
    delete organizer_;
  }
  if (organizer) {
    set_has_organizer();
    organizer_ = organizer;
  } else {
    clear_has_organizer();
    organizer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 6;
inline bool TMTContentRegularMeeting::has_phone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTContentRegularMeeting::set_has_phone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTContentRegularMeeting::clear_has_phone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTContentRegularMeeting::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& TMTContentRegularMeeting::phone() const {
  return *phone_;
}
inline void TMTContentRegularMeeting::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTContentRegularMeeting::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTContentRegularMeeting::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* TMTContentRegularMeeting::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brief = 7;
inline bool TMTContentRegularMeeting::has_brief() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTContentRegularMeeting::set_has_brief() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTContentRegularMeeting::clear_has_brief() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTContentRegularMeeting::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TMTContentRegularMeeting::brief() const {
  return *brief_;
}
inline void TMTContentRegularMeeting::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTContentRegularMeeting::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTContentRegularMeeting::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TMTContentRegularMeeting::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 status = 8;
inline bool TMTContentRegularMeeting::has_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTContentRegularMeeting::set_has_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTContentRegularMeeting::clear_has_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTContentRegularMeeting::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 TMTContentRegularMeeting::status() const {
  return status_;
}
inline void TMTContentRegularMeeting::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional string mobilephone = 9;
inline bool TMTContentRegularMeeting::has_mobilephone() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTContentRegularMeeting::set_has_mobilephone() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTContentRegularMeeting::clear_has_mobilephone() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTContentRegularMeeting::clear_mobilephone() {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    mobilephone_->clear();
  }
  clear_has_mobilephone();
}
inline const ::std::string& TMTContentRegularMeeting::mobilephone() const {
  return *mobilephone_;
}
inline void TMTContentRegularMeeting::set_mobilephone(const ::std::string& value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void TMTContentRegularMeeting::set_mobilephone(const char* value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void TMTContentRegularMeeting::set_mobilephone(const char* value, size_t size) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_mobilephone() {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  return mobilephone_;
}
inline ::std::string* TMTContentRegularMeeting::release_mobilephone() {
  clear_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilephone_;
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_mobilephone(::std::string* mobilephone) {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    delete mobilephone_;
  }
  if (mobilephone) {
    set_has_mobilephone();
    mobilephone_ = mobilephone;
  } else {
    clear_has_mobilephone();
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isvideomeeting = 10;
inline bool TMTContentRegularMeeting::has_isvideomeeting() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTContentRegularMeeting::set_has_isvideomeeting() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTContentRegularMeeting::clear_has_isvideomeeting() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTContentRegularMeeting::clear_isvideomeeting() {
  isvideomeeting_ = false;
  clear_has_isvideomeeting();
}
inline bool TMTContentRegularMeeting::isvideomeeting() const {
  return isvideomeeting_;
}
inline void TMTContentRegularMeeting::set_isvideomeeting(bool value) {
  set_has_isvideomeeting();
  isvideomeeting_ = value;
}

// optional string starttime = 11;
inline bool TMTContentRegularMeeting::has_starttime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTContentRegularMeeting::set_has_starttime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTContentRegularMeeting::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTContentRegularMeeting::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTContentRegularMeeting::starttime() const {
  return *starttime_;
}
inline void TMTContentRegularMeeting::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentRegularMeeting::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentRegularMeeting::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTContentRegularMeeting::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 12;
inline bool TMTContentRegularMeeting::has_endtime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTContentRegularMeeting::set_has_endtime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTContentRegularMeeting::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTContentRegularMeeting::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTContentRegularMeeting::endtime() const {
  return *endtime_;
}
inline void TMTContentRegularMeeting::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentRegularMeeting::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentRegularMeeting::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTContentRegularMeeting::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string startdate = 13;
inline bool TMTContentRegularMeeting::has_startdate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTContentRegularMeeting::set_has_startdate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTContentRegularMeeting::clear_has_startdate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTContentRegularMeeting::clear_startdate() {
  if (startdate_ != &::google::protobuf::internal::kEmptyString) {
    startdate_->clear();
  }
  clear_has_startdate();
}
inline const ::std::string& TMTContentRegularMeeting::startdate() const {
  return *startdate_;
}
inline void TMTContentRegularMeeting::set_startdate(const ::std::string& value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
}
inline void TMTContentRegularMeeting::set_startdate(const char* value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
}
inline void TMTContentRegularMeeting::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_startdate() {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  return startdate_;
}
inline ::std::string* TMTContentRegularMeeting::release_startdate() {
  clear_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startdate_;
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_startdate(::std::string* startdate) {
  if (startdate_ != &::google::protobuf::internal::kEmptyString) {
    delete startdate_;
  }
  if (startdate) {
    set_has_startdate();
    startdate_ = startdate;
  } else {
    clear_has_startdate();
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 repeattype = 14;
inline bool TMTContentRegularMeeting::has_repeattype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTContentRegularMeeting::set_has_repeattype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTContentRegularMeeting::clear_has_repeattype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTContentRegularMeeting::clear_repeattype() {
  repeattype_ = 0u;
  clear_has_repeattype();
}
inline ::google::protobuf::uint32 TMTContentRegularMeeting::repeattype() const {
  return repeattype_;
}
inline void TMTContentRegularMeeting::set_repeattype(::google::protobuf::uint32 value) {
  set_has_repeattype();
  repeattype_ = value;
}

// optional uint32 frequency = 15;
inline bool TMTContentRegularMeeting::has_frequency() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTContentRegularMeeting::set_has_frequency() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTContentRegularMeeting::clear_has_frequency() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTContentRegularMeeting::clear_frequency() {
  frequency_ = 0u;
  clear_has_frequency();
}
inline ::google::protobuf::uint32 TMTContentRegularMeeting::frequency() const {
  return frequency_;
}
inline void TMTContentRegularMeeting::set_frequency(::google::protobuf::uint32 value) {
  set_has_frequency();
  frequency_ = value;
}

// optional string weekdays = 16;
inline bool TMTContentRegularMeeting::has_weekdays() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTContentRegularMeeting::set_has_weekdays() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTContentRegularMeeting::clear_has_weekdays() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTContentRegularMeeting::clear_weekdays() {
  if (weekdays_ != &::google::protobuf::internal::kEmptyString) {
    weekdays_->clear();
  }
  clear_has_weekdays();
}
inline const ::std::string& TMTContentRegularMeeting::weekdays() const {
  return *weekdays_;
}
inline void TMTContentRegularMeeting::set_weekdays(const ::std::string& value) {
  set_has_weekdays();
  if (weekdays_ == &::google::protobuf::internal::kEmptyString) {
    weekdays_ = new ::std::string;
  }
  weekdays_->assign(value);
}
inline void TMTContentRegularMeeting::set_weekdays(const char* value) {
  set_has_weekdays();
  if (weekdays_ == &::google::protobuf::internal::kEmptyString) {
    weekdays_ = new ::std::string;
  }
  weekdays_->assign(value);
}
inline void TMTContentRegularMeeting::set_weekdays(const char* value, size_t size) {
  set_has_weekdays();
  if (weekdays_ == &::google::protobuf::internal::kEmptyString) {
    weekdays_ = new ::std::string;
  }
  weekdays_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_weekdays() {
  set_has_weekdays();
  if (weekdays_ == &::google::protobuf::internal::kEmptyString) {
    weekdays_ = new ::std::string;
  }
  return weekdays_;
}
inline ::std::string* TMTContentRegularMeeting::release_weekdays() {
  clear_has_weekdays();
  if (weekdays_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weekdays_;
    weekdays_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_weekdays(::std::string* weekdays) {
  if (weekdays_ != &::google::protobuf::internal::kEmptyString) {
    delete weekdays_;
  }
  if (weekdays) {
    set_has_weekdays();
    weekdays_ = weekdays;
  } else {
    clear_has_weekdays();
    weekdays_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string enddate = 17;
inline bool TMTContentRegularMeeting::has_enddate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTContentRegularMeeting::set_has_enddate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTContentRegularMeeting::clear_has_enddate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTContentRegularMeeting::clear_enddate() {
  if (enddate_ != &::google::protobuf::internal::kEmptyString) {
    enddate_->clear();
  }
  clear_has_enddate();
}
inline const ::std::string& TMTContentRegularMeeting::enddate() const {
  return *enddate_;
}
inline void TMTContentRegularMeeting::set_enddate(const ::std::string& value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
}
inline void TMTContentRegularMeeting::set_enddate(const char* value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
}
inline void TMTContentRegularMeeting::set_enddate(const char* value, size_t size) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentRegularMeeting::mutable_enddate() {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  return enddate_;
}
inline ::std::string* TMTContentRegularMeeting::release_enddate() {
  clear_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enddate_;
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentRegularMeeting::set_allocated_enddate(::std::string* enddate) {
  if (enddate_ != &::google::protobuf::internal::kEmptyString) {
    delete enddate_;
  }
  if (enddate) {
    set_has_enddate();
    enddate_ = enddate;
  } else {
    clear_has_enddate();
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 meetingid = 18;
inline int TMTContentRegularMeeting::meetingid_size() const {
  return meetingid_.size();
}
inline void TMTContentRegularMeeting::clear_meetingid() {
  meetingid_.Clear();
}
inline ::google::protobuf::uint32 TMTContentRegularMeeting::meetingid(int index) const {
  return meetingid_.Get(index);
}
inline void TMTContentRegularMeeting::set_meetingid(int index, ::google::protobuf::uint32 value) {
  meetingid_.Set(index, value);
}
inline void TMTContentRegularMeeting::add_meetingid(::google::protobuf::uint32 value) {
  meetingid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TMTContentRegularMeeting::meetingid() const {
  return meetingid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TMTContentRegularMeeting::mutable_meetingid() {
  return &meetingid_;
}

// -------------------------------------------------------------------

// TMTContentRegularId

// optional uint32 regularid = 1;
inline bool TMTContentRegularId::has_regularid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentRegularId::set_has_regularid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentRegularId::clear_has_regularid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentRegularId::clear_regularid() {
  regularid_ = 0u;
  clear_has_regularid();
}
inline ::google::protobuf::uint32 TMTContentRegularId::regularid() const {
  return regularid_;
}
inline void TMTContentRegularId::set_regularid(::google::protobuf::uint32 value) {
  set_has_regularid();
  regularid_ = value;
}

// -------------------------------------------------------------------

// TMTContentFeedback

// optional uint32 id = 1;
inline bool TMTContentFeedback::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentFeedback::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentFeedback::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentFeedback::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTContentFeedback::id() const {
  return id_;
}
inline void TMTContentFeedback::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string moid = 2;
inline bool TMTContentFeedback::has_moid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTContentFeedback::set_has_moid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTContentFeedback::clear_has_moid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTContentFeedback::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTContentFeedback::moid() const {
  return *moid_;
}
inline void TMTContentFeedback::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTContentFeedback::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTContentFeedback::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentFeedback::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTContentFeedback::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentFeedback::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmParticipantResponse isparticipated = 3;
inline bool TMTContentFeedback::has_isparticipated() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTContentFeedback::set_has_isparticipated() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTContentFeedback::clear_has_isparticipated() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTContentFeedback::clear_isparticipated() {
  isparticipated_ = 0;
  clear_has_isparticipated();
}
inline ::mt::EmParticipantResponse TMTContentFeedback::isparticipated() const {
  return static_cast< ::mt::EmParticipantResponse >(isparticipated_);
}
inline void TMTContentFeedback::set_isparticipated(::mt::EmParticipantResponse value) {
  assert(::mt::EmParticipantResponse_IsValid(value));
  set_has_isparticipated();
  isparticipated_ = value;
}

// optional uint32 participatetype = 4;
inline bool TMTContentFeedback::has_participatetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTContentFeedback::set_has_participatetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTContentFeedback::clear_has_participatetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTContentFeedback::clear_participatetype() {
  participatetype_ = 0u;
  clear_has_participatetype();
}
inline ::google::protobuf::uint32 TMTContentFeedback::participatetype() const {
  return participatetype_;
}
inline void TMTContentFeedback::set_participatetype(::google::protobuf::uint32 value) {
  set_has_participatetype();
  participatetype_ = value;
}

// optional uint32 reasonid = 5;
inline bool TMTContentFeedback::has_reasonid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTContentFeedback::set_has_reasonid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTContentFeedback::clear_has_reasonid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTContentFeedback::clear_reasonid() {
  reasonid_ = 0u;
  clear_has_reasonid();
}
inline ::google::protobuf::uint32 TMTContentFeedback::reasonid() const {
  return reasonid_;
}
inline void TMTContentFeedback::set_reasonid(::google::protobuf::uint32 value) {
  set_has_reasonid();
  reasonid_ = value;
}

// optional bool isvideomeeting = 6;
inline bool TMTContentFeedback::has_isvideomeeting() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTContentFeedback::set_has_isvideomeeting() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTContentFeedback::clear_has_isvideomeeting() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTContentFeedback::clear_isvideomeeting() {
  isvideomeeting_ = false;
  clear_has_isvideomeeting();
}
inline bool TMTContentFeedback::isvideomeeting() const {
  return isvideomeeting_;
}
inline void TMTContentFeedback::set_isvideomeeting(bool value) {
  set_has_isvideomeeting();
  isvideomeeting_ = value;
}

// -------------------------------------------------------------------

// TMTContentRoomId

// optional uint32 id = 1;
inline bool TMTContentRoomId::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentRoomId::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentRoomId::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentRoomId::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTContentRoomId::id() const {
  return id_;
}
inline void TMTContentRoomId::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// TMTContentMeetingId

// optional uint32 id = 1;
inline bool TMTContentMeetingId::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentMeetingId::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentMeetingId::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentMeetingId::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTContentMeetingId::id() const {
  return id_;
}
inline void TMTContentMeetingId::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// TMTContentStartMeeting

// optional uint32 id = 1;
inline bool TMTContentStartMeeting::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentStartMeeting::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentStartMeeting::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentStartMeeting::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTContentStartMeeting::id() const {
  return id_;
}
inline void TMTContentStartMeeting::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string subject = 2;
inline bool TMTContentStartMeeting::has_subject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTContentStartMeeting::set_has_subject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTContentStartMeeting::clear_has_subject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTContentStartMeeting::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTContentStartMeeting::subject() const {
  return *subject_;
}
inline void TMTContentStartMeeting::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentStartMeeting::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentStartMeeting::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentStartMeeting::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTContentStartMeeting::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentStartMeeting::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string starttime = 3;
inline bool TMTContentStartMeeting::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTContentStartMeeting::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTContentStartMeeting::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTContentStartMeeting::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTContentStartMeeting::starttime() const {
  return *starttime_;
}
inline void TMTContentStartMeeting::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentStartMeeting::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentStartMeeting::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentStartMeeting::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTContentStartMeeting::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentStartMeeting::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 4;
inline bool TMTContentStartMeeting::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTContentStartMeeting::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTContentStartMeeting::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTContentStartMeeting::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTContentStartMeeting::endtime() const {
  return *endtime_;
}
inline void TMTContentStartMeeting::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentStartMeeting::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentStartMeeting::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentStartMeeting::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTContentStartMeeting::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentStartMeeting::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizermoid = 5;
inline bool TMTContentStartMeeting::has_organizermoid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTContentStartMeeting::set_has_organizermoid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTContentStartMeeting::clear_has_organizermoid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTContentStartMeeting::clear_organizermoid() {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    organizermoid_->clear();
  }
  clear_has_organizermoid();
}
inline const ::std::string& TMTContentStartMeeting::organizermoid() const {
  return *organizermoid_;
}
inline void TMTContentStartMeeting::set_organizermoid(const ::std::string& value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentStartMeeting::set_organizermoid(const char* value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentStartMeeting::set_organizermoid(const char* value, size_t size) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentStartMeeting::mutable_organizermoid() {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  return organizermoid_;
}
inline ::std::string* TMTContentStartMeeting::release_organizermoid() {
  clear_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermoid_;
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentStartMeeting::set_allocated_organizermoid(::std::string* organizermoid) {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermoid_;
  }
  if (organizermoid) {
    set_has_organizermoid();
    organizermoid_ = organizermoid;
  } else {
    clear_has_organizermoid();
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TRegularFeedAck

// optional uint32 regularid = 1;
inline bool TRegularFeedAck::has_regularid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRegularFeedAck::set_has_regularid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRegularFeedAck::clear_has_regularid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRegularFeedAck::clear_regularid() {
  regularid_ = 0u;
  clear_has_regularid();
}
inline ::google::protobuf::uint32 TRegularFeedAck::regularid() const {
  return regularid_;
}
inline void TRegularFeedAck::set_regularid(::google::protobuf::uint32 value) {
  set_has_regularid();
  regularid_ = value;
}

// optional bool accept = 2;
inline bool TRegularFeedAck::has_accept() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRegularFeedAck::set_has_accept() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRegularFeedAck::clear_has_accept() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRegularFeedAck::clear_accept() {
  accept_ = false;
  clear_has_accept();
}
inline bool TRegularFeedAck::accept() const {
  return accept_;
}
inline void TRegularFeedAck::set_accept(bool value) {
  set_has_accept();
  accept_ = value;
}

// optional uint32 jointype = 3;
inline bool TRegularFeedAck::has_jointype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TRegularFeedAck::set_has_jointype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TRegularFeedAck::clear_has_jointype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TRegularFeedAck::clear_jointype() {
  jointype_ = 0u;
  clear_has_jointype();
}
inline ::google::protobuf::uint32 TRegularFeedAck::jointype() const {
  return jointype_;
}
inline void TRegularFeedAck::set_jointype(::google::protobuf::uint32 value) {
  set_has_jointype();
  jointype_ = value;
}

// -------------------------------------------------------------------

// TAppGetAllNotifysAck

// optional uint32 notify_cnt = 1;
inline bool TAppGetAllNotifysAck::has_notify_cnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAppGetAllNotifysAck::set_has_notify_cnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAppGetAllNotifysAck::clear_has_notify_cnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAppGetAllNotifysAck::clear_notify_cnt() {
  notify_cnt_ = 0u;
  clear_has_notify_cnt();
}
inline ::google::protobuf::uint32 TAppGetAllNotifysAck::notify_cnt() const {
  return notify_cnt_;
}
inline void TAppGetAllNotifysAck::set_notify_cnt(::google::protobuf::uint32 value) {
  set_has_notify_cnt();
  notify_cnt_ = value;
}

// optional .mt.EmRestNotifyType notify_type = 2;
inline bool TAppGetAllNotifysAck::has_notify_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAppGetAllNotifysAck::set_has_notify_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAppGetAllNotifysAck::clear_has_notify_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAppGetAllNotifysAck::clear_notify_type() {
  notify_type_ = 0;
  clear_has_notify_type();
}
inline ::mt::EmRestNotifyType TAppGetAllNotifysAck::notify_type() const {
  return static_cast< ::mt::EmRestNotifyType >(notify_type_);
}
inline void TAppGetAllNotifysAck::set_notify_type(::mt::EmRestNotifyType value) {
  assert(::mt::EmRestNotifyType_IsValid(value));
  set_has_notify_type();
  notify_type_ = value;
}

// -------------------------------------------------------------------

// TAppGetAllNotifysAckList

// repeated .mt.TAppGetAllNotifysAck notify_list = 1;
inline int TAppGetAllNotifysAckList::notify_list_size() const {
  return notify_list_.size();
}
inline void TAppGetAllNotifysAckList::clear_notify_list() {
  notify_list_.Clear();
}
inline const ::mt::TAppGetAllNotifysAck& TAppGetAllNotifysAckList::notify_list(int index) const {
  return notify_list_.Get(index);
}
inline ::mt::TAppGetAllNotifysAck* TAppGetAllNotifysAckList::mutable_notify_list(int index) {
  return notify_list_.Mutable(index);
}
inline ::mt::TAppGetAllNotifysAck* TAppGetAllNotifysAckList::add_notify_list() {
  return notify_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAppGetAllNotifysAck >&
TAppGetAllNotifysAckList::notify_list() const {
  return notify_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAppGetAllNotifysAck >*
TAppGetAllNotifysAckList::mutable_notify_list() {
  return &notify_list_;
}

// -------------------------------------------------------------------

// TGetMonitorGroupVersionAck

// optional string version = 1;
inline bool TGetMonitorGroupVersionAck::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGetMonitorGroupVersionAck::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGetMonitorGroupVersionAck::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGetMonitorGroupVersionAck::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TGetMonitorGroupVersionAck::version() const {
  return *version_;
}
inline void TGetMonitorGroupVersionAck::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TGetMonitorGroupVersionAck::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TGetMonitorGroupVersionAck::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TGetMonitorGroupVersionAck::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* TGetMonitorGroupVersionAck::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TGetMonitorGroupVersionAck::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTMonitorGroup

// optional string id = 1;
inline bool TMTMonitorGroup::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTMonitorGroup::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTMonitorGroup::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTMonitorGroup::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TMTMonitorGroup::id() const {
  return *id_;
}
inline void TMTMonitorGroup::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TMTMonitorGroup::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TMTMonitorGroup::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorGroup::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* TMTMonitorGroup::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorGroup::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string groupid = 2;
inline bool TMTMonitorGroup::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTMonitorGroup::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTMonitorGroup::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTMonitorGroup::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& TMTMonitorGroup::groupid() const {
  return *groupid_;
}
inline void TMTMonitorGroup::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void TMTMonitorGroup::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void TMTMonitorGroup::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorGroup::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* TMTMonitorGroup::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorGroup::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string groupname = 3;
inline bool TMTMonitorGroup::has_groupname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTMonitorGroup::set_has_groupname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTMonitorGroup::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTMonitorGroup::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& TMTMonitorGroup::groupname() const {
  return *groupname_;
}
inline void TMTMonitorGroup::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void TMTMonitorGroup::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void TMTMonitorGroup::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorGroup::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* TMTMonitorGroup::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorGroup::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string parentid = 4;
inline bool TMTMonitorGroup::has_parentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTMonitorGroup::set_has_parentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTMonitorGroup::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTMonitorGroup::clear_parentid() {
  if (parentid_ != &::google::protobuf::internal::kEmptyString) {
    parentid_->clear();
  }
  clear_has_parentid();
}
inline const ::std::string& TMTMonitorGroup::parentid() const {
  return *parentid_;
}
inline void TMTMonitorGroup::set_parentid(const ::std::string& value) {
  set_has_parentid();
  if (parentid_ == &::google::protobuf::internal::kEmptyString) {
    parentid_ = new ::std::string;
  }
  parentid_->assign(value);
}
inline void TMTMonitorGroup::set_parentid(const char* value) {
  set_has_parentid();
  if (parentid_ == &::google::protobuf::internal::kEmptyString) {
    parentid_ = new ::std::string;
  }
  parentid_->assign(value);
}
inline void TMTMonitorGroup::set_parentid(const char* value, size_t size) {
  set_has_parentid();
  if (parentid_ == &::google::protobuf::internal::kEmptyString) {
    parentid_ = new ::std::string;
  }
  parentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorGroup::mutable_parentid() {
  set_has_parentid();
  if (parentid_ == &::google::protobuf::internal::kEmptyString) {
    parentid_ = new ::std::string;
  }
  return parentid_;
}
inline ::std::string* TMTMonitorGroup::release_parentid() {
  clear_has_parentid();
  if (parentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parentid_;
    parentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorGroup::set_allocated_parentid(::std::string* parentid) {
  if (parentid_ != &::google::protobuf::internal::kEmptyString) {
    delete parentid_;
  }
  if (parentid) {
    set_has_parentid();
    parentid_ = parentid;
  } else {
    clear_has_parentid();
    parentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string newgroup = 5;
inline bool TMTMonitorGroup::has_newgroup() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTMonitorGroup::set_has_newgroup() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTMonitorGroup::clear_has_newgroup() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTMonitorGroup::clear_newgroup() {
  if (newgroup_ != &::google::protobuf::internal::kEmptyString) {
    newgroup_->clear();
  }
  clear_has_newgroup();
}
inline const ::std::string& TMTMonitorGroup::newgroup() const {
  return *newgroup_;
}
inline void TMTMonitorGroup::set_newgroup(const ::std::string& value) {
  set_has_newgroup();
  if (newgroup_ == &::google::protobuf::internal::kEmptyString) {
    newgroup_ = new ::std::string;
  }
  newgroup_->assign(value);
}
inline void TMTMonitorGroup::set_newgroup(const char* value) {
  set_has_newgroup();
  if (newgroup_ == &::google::protobuf::internal::kEmptyString) {
    newgroup_ = new ::std::string;
  }
  newgroup_->assign(value);
}
inline void TMTMonitorGroup::set_newgroup(const char* value, size_t size) {
  set_has_newgroup();
  if (newgroup_ == &::google::protobuf::internal::kEmptyString) {
    newgroup_ = new ::std::string;
  }
  newgroup_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorGroup::mutable_newgroup() {
  set_has_newgroup();
  if (newgroup_ == &::google::protobuf::internal::kEmptyString) {
    newgroup_ = new ::std::string;
  }
  return newgroup_;
}
inline ::std::string* TMTMonitorGroup::release_newgroup() {
  clear_has_newgroup();
  if (newgroup_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newgroup_;
    newgroup_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorGroup::set_allocated_newgroup(::std::string* newgroup) {
  if (newgroup_ != &::google::protobuf::internal::kEmptyString) {
    delete newgroup_;
  }
  if (newgroup) {
    set_has_newgroup();
    newgroup_ = newgroup;
  } else {
    clear_has_newgroup();
    newgroup_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leaf = 6;
inline bool TMTMonitorGroup::has_leaf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTMonitorGroup::set_has_leaf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTMonitorGroup::clear_has_leaf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTMonitorGroup::clear_leaf() {
  if (leaf_ != &::google::protobuf::internal::kEmptyString) {
    leaf_->clear();
  }
  clear_has_leaf();
}
inline const ::std::string& TMTMonitorGroup::leaf() const {
  return *leaf_;
}
inline void TMTMonitorGroup::set_leaf(const ::std::string& value) {
  set_has_leaf();
  if (leaf_ == &::google::protobuf::internal::kEmptyString) {
    leaf_ = new ::std::string;
  }
  leaf_->assign(value);
}
inline void TMTMonitorGroup::set_leaf(const char* value) {
  set_has_leaf();
  if (leaf_ == &::google::protobuf::internal::kEmptyString) {
    leaf_ = new ::std::string;
  }
  leaf_->assign(value);
}
inline void TMTMonitorGroup::set_leaf(const char* value, size_t size) {
  set_has_leaf();
  if (leaf_ == &::google::protobuf::internal::kEmptyString) {
    leaf_ = new ::std::string;
  }
  leaf_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorGroup::mutable_leaf() {
  set_has_leaf();
  if (leaf_ == &::google::protobuf::internal::kEmptyString) {
    leaf_ = new ::std::string;
  }
  return leaf_;
}
inline ::std::string* TMTMonitorGroup::release_leaf() {
  clear_has_leaf();
  if (leaf_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leaf_;
    leaf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorGroup::set_allocated_leaf(::std::string* leaf) {
  if (leaf_ != &::google::protobuf::internal::kEmptyString) {
    delete leaf_;
  }
  if (leaf) {
    set_has_leaf();
    leaf_ = leaf;
  } else {
    clear_has_leaf();
    leaf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTMonitorGroups

// repeated .mt.TMTMonitorGroup monitorgroup = 1;
inline int TMTMonitorGroups::monitorgroup_size() const {
  return monitorgroup_.size();
}
inline void TMTMonitorGroups::clear_monitorgroup() {
  monitorgroup_.Clear();
}
inline const ::mt::TMTMonitorGroup& TMTMonitorGroups::monitorgroup(int index) const {
  return monitorgroup_.Get(index);
}
inline ::mt::TMTMonitorGroup* TMTMonitorGroups::mutable_monitorgroup(int index) {
  return monitorgroup_.Mutable(index);
}
inline ::mt::TMTMonitorGroup* TMTMonitorGroups::add_monitorgroup() {
  return monitorgroup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTMonitorGroup >&
TMTMonitorGroups::monitorgroup() const {
  return monitorgroup_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTMonitorGroup >*
TMTMonitorGroups::mutable_monitorgroup() {
  return &monitorgroup_;
}

// -------------------------------------------------------------------

// TMTMonitorDevice

// optional string groupid = 1;
inline bool TMTMonitorDevice::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTMonitorDevice::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTMonitorDevice::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTMonitorDevice::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& TMTMonitorDevice::groupid() const {
  return *groupid_;
}
inline void TMTMonitorDevice::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void TMTMonitorDevice::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void TMTMonitorDevice::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorDevice::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* TMTMonitorDevice::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorDevice::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 2;
inline bool TMTMonitorDevice::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTMonitorDevice::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTMonitorDevice::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTMonitorDevice::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TMTMonitorDevice::id() const {
  return *id_;
}
inline void TMTMonitorDevice::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TMTMonitorDevice::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TMTMonitorDevice::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorDevice::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* TMTMonitorDevice::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorDevice::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool TMTMonitorDevice::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTMonitorDevice::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTMonitorDevice::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTMonitorDevice::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTMonitorDevice::name() const {
  return *name_;
}
inline void TMTMonitorDevice::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTMonitorDevice::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTMonitorDevice::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorDevice::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTMonitorDevice::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorDevice::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceguid = 4;
inline bool TMTMonitorDevice::has_deviceguid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTMonitorDevice::set_has_deviceguid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTMonitorDevice::clear_has_deviceguid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTMonitorDevice::clear_deviceguid() {
  if (deviceguid_ != &::google::protobuf::internal::kEmptyString) {
    deviceguid_->clear();
  }
  clear_has_deviceguid();
}
inline const ::std::string& TMTMonitorDevice::deviceguid() const {
  return *deviceguid_;
}
inline void TMTMonitorDevice::set_deviceguid(const ::std::string& value) {
  set_has_deviceguid();
  if (deviceguid_ == &::google::protobuf::internal::kEmptyString) {
    deviceguid_ = new ::std::string;
  }
  deviceguid_->assign(value);
}
inline void TMTMonitorDevice::set_deviceguid(const char* value) {
  set_has_deviceguid();
  if (deviceguid_ == &::google::protobuf::internal::kEmptyString) {
    deviceguid_ = new ::std::string;
  }
  deviceguid_->assign(value);
}
inline void TMTMonitorDevice::set_deviceguid(const char* value, size_t size) {
  set_has_deviceguid();
  if (deviceguid_ == &::google::protobuf::internal::kEmptyString) {
    deviceguid_ = new ::std::string;
  }
  deviceguid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorDevice::mutable_deviceguid() {
  set_has_deviceguid();
  if (deviceguid_ == &::google::protobuf::internal::kEmptyString) {
    deviceguid_ = new ::std::string;
  }
  return deviceguid_;
}
inline ::std::string* TMTMonitorDevice::release_deviceguid() {
  clear_has_deviceguid();
  if (deviceguid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceguid_;
    deviceguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorDevice::set_allocated_deviceguid(::std::string* deviceguid) {
  if (deviceguid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceguid_;
  }
  if (deviceguid) {
    set_has_deviceguid();
    deviceguid_ = deviceguid;
  } else {
    clear_has_deviceguid();
    deviceguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 5;
inline bool TMTMonitorDevice::has_e164() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTMonitorDevice::set_has_e164() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTMonitorDevice::clear_has_e164() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTMonitorDevice::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTMonitorDevice::e164() const {
  return *e164_;
}
inline void TMTMonitorDevice::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTMonitorDevice::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTMonitorDevice::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorDevice::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTMonitorDevice::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorDevice::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string devicetype = 6;
inline bool TMTMonitorDevice::has_devicetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTMonitorDevice::set_has_devicetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTMonitorDevice::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTMonitorDevice::clear_devicetype() {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    devicetype_->clear();
  }
  clear_has_devicetype();
}
inline const ::std::string& TMTMonitorDevice::devicetype() const {
  return *devicetype_;
}
inline void TMTMonitorDevice::set_devicetype(const ::std::string& value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void TMTMonitorDevice::set_devicetype(const char* value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void TMTMonitorDevice::set_devicetype(const char* value, size_t size) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorDevice::mutable_devicetype() {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  return devicetype_;
}
inline ::std::string* TMTMonitorDevice::release_devicetype() {
  clear_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicetype_;
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorDevice::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    delete devicetype_;
  }
  if (devicetype) {
    set_has_devicetype();
    devicetype_ = devicetype;
  } else {
    clear_has_devicetype();
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 7;
inline bool TMTMonitorDevice::has_description() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTMonitorDevice::set_has_description() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTMonitorDevice::clear_has_description() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTMonitorDevice::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& TMTMonitorDevice::description() const {
  return *description_;
}
inline void TMTMonitorDevice::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TMTMonitorDevice::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TMTMonitorDevice::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorDevice::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* TMTMonitorDevice::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorDevice::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string note = 8;
inline bool TMTMonitorDevice::has_note() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTMonitorDevice::set_has_note() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTMonitorDevice::clear_has_note() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTMonitorDevice::clear_note() {
  if (note_ != &::google::protobuf::internal::kEmptyString) {
    note_->clear();
  }
  clear_has_note();
}
inline const ::std::string& TMTMonitorDevice::note() const {
  return *note_;
}
inline void TMTMonitorDevice::set_note(const ::std::string& value) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void TMTMonitorDevice::set_note(const char* value) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void TMTMonitorDevice::set_note(const char* value, size_t size) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTMonitorDevice::mutable_note() {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  return note_;
}
inline ::std::string* TMTMonitorDevice::release_note() {
  clear_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = note_;
    note_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTMonitorDevice::set_allocated_note(::std::string* note) {
  if (note_ != &::google::protobuf::internal::kEmptyString) {
    delete note_;
  }
  if (note) {
    set_has_note();
    note_ = note;
  } else {
    clear_has_note();
    note_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTMonitorDevices

// repeated .mt.TMTMonitorDevice m_atMonitorDevice = 1;
inline int TMTMonitorDevices::m_atmonitordevice_size() const {
  return m_atmonitordevice_.size();
}
inline void TMTMonitorDevices::clear_m_atmonitordevice() {
  m_atmonitordevice_.Clear();
}
inline const ::mt::TMTMonitorDevice& TMTMonitorDevices::m_atmonitordevice(int index) const {
  return m_atmonitordevice_.Get(index);
}
inline ::mt::TMTMonitorDevice* TMTMonitorDevices::mutable_m_atmonitordevice(int index) {
  return m_atmonitordevice_.Mutable(index);
}
inline ::mt::TMTMonitorDevice* TMTMonitorDevices::add_m_atmonitordevice() {
  return m_atmonitordevice_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTMonitorDevice >&
TMTMonitorDevices::m_atmonitordevice() const {
  return m_atmonitordevice_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTMonitorDevice >*
TMTMonitorDevices::mutable_m_atmonitordevice() {
  return &m_atmonitordevice_;
}

// -------------------------------------------------------------------

// TMTGetPerTemplateList

// optional uint32 start = 1;
inline bool TMTGetPerTemplateList::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTGetPerTemplateList::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTGetPerTemplateList::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTGetPerTemplateList::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTGetPerTemplateList::start() const {
  return start_;
}
inline void TMTGetPerTemplateList::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 2;
inline bool TMTGetPerTemplateList::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTGetPerTemplateList::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTGetPerTemplateList::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTGetPerTemplateList::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTGetPerTemplateList::count() const {
  return count_;
}
inline void TMTGetPerTemplateList::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 3;
inline bool TMTGetPerTemplateList::has_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTGetPerTemplateList::set_has_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTGetPerTemplateList::clear_has_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTGetPerTemplateList::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTGetPerTemplateList::order() const {
  return order_;
}
inline void TMTGetPerTemplateList::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// -------------------------------------------------------------------

// TMTTemplateAccount

// optional string account = 1;
inline bool TMTTemplateAccount::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplateAccount::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplateAccount::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplateAccount::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTTemplateAccount::account() const {
  return *account_;
}
inline void TMTTemplateAccount::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTTemplateAccount::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTTemplateAccount::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplateAccount::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTTemplateAccount::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplateAccount::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtAddrType accounttype = 2;
inline bool TMTTemplateAccount::has_accounttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTTemplateAccount::set_has_accounttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTTemplateAccount::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTTemplateAccount::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::mt::EmMtAddrType TMTTemplateAccount::accounttype() const {
  return static_cast< ::mt::EmMtAddrType >(accounttype_);
}
inline void TMTTemplateAccount::set_accounttype(::mt::EmMtAddrType value) {
  assert(::mt::EmMtAddrType_IsValid(value));
  set_has_accounttype();
  accounttype_ = value;
}

// -------------------------------------------------------------------

// TMTTemplateRecord

// optional bool doubleflow = 1;
inline bool TMTTemplateRecord::has_doubleflow() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplateRecord::set_has_doubleflow() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplateRecord::clear_has_doubleflow() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplateRecord::clear_doubleflow() {
  doubleflow_ = false;
  clear_has_doubleflow();
}
inline bool TMTTemplateRecord::doubleflow() const {
  return doubleflow_;
}
inline void TMTTemplateRecord::set_doubleflow(bool value) {
  set_has_doubleflow();
  doubleflow_ = value;
}

// optional bool enable = 2;
inline bool TMTTemplateRecord::has_enable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTTemplateRecord::set_has_enable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTTemplateRecord::clear_has_enable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTTemplateRecord::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTTemplateRecord::enable() const {
  return enable_;
}
inline void TMTTemplateRecord::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional bool main = 3;
inline bool TMTTemplateRecord::has_main() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTTemplateRecord::set_has_main() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTTemplateRecord::clear_has_main() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTTemplateRecord::clear_main() {
  main_ = false;
  clear_has_main();
}
inline bool TMTTemplateRecord::main() const {
  return main_;
}
inline void TMTTemplateRecord::set_main(bool value) {
  set_has_main();
  main_ = value;
}

// optional bool publish = 4;
inline bool TMTTemplateRecord::has_publish() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTTemplateRecord::set_has_publish() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTTemplateRecord::clear_has_publish() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTTemplateRecord::clear_publish() {
  publish_ = false;
  clear_has_publish();
}
inline bool TMTTemplateRecord::publish() const {
  return publish_;
}
inline void TMTTemplateRecord::set_publish(bool value) {
  set_has_publish();
  publish_ = value;
}

// -------------------------------------------------------------------

// TMTTemplateSatellite

// optional bool enable = 1;
inline bool TMTTemplateSatellite::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplateSatellite::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplateSatellite::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplateSatellite::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTTemplateSatellite::enable() const {
  return enable_;
}
inline void TMTTemplateSatellite::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional string multicastaddr = 2;
inline bool TMTTemplateSatellite::has_multicastaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTTemplateSatellite::set_has_multicastaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTTemplateSatellite::clear_has_multicastaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTTemplateSatellite::clear_multicastaddr() {
  if (multicastaddr_ != &::google::protobuf::internal::kEmptyString) {
    multicastaddr_->clear();
  }
  clear_has_multicastaddr();
}
inline const ::std::string& TMTTemplateSatellite::multicastaddr() const {
  return *multicastaddr_;
}
inline void TMTTemplateSatellite::set_multicastaddr(const ::std::string& value) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(value);
}
inline void TMTTemplateSatellite::set_multicastaddr(const char* value) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(value);
}
inline void TMTTemplateSatellite::set_multicastaddr(const char* value, size_t size) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplateSatellite::mutable_multicastaddr() {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  return multicastaddr_;
}
inline ::std::string* TMTTemplateSatellite::release_multicastaddr() {
  clear_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = multicastaddr_;
    multicastaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplateSatellite::set_allocated_multicastaddr(::std::string* multicastaddr) {
  if (multicastaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete multicastaddr_;
  }
  if (multicastaddr) {
    set_has_multicastaddr();
    multicastaddr_ = multicastaddr;
  } else {
    clear_has_multicastaddr();
    multicastaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 3;
inline bool TMTTemplateSatellite::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTTemplateSatellite::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTTemplateSatellite::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTTemplateSatellite::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMTTemplateSatellite::port() const {
  return port_;
}
inline void TMTTemplateSatellite::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional uint32 returnnum = 4;
inline bool TMTTemplateSatellite::has_returnnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTTemplateSatellite::set_has_returnnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTTemplateSatellite::clear_has_returnnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTTemplateSatellite::clear_returnnum() {
  returnnum_ = 0u;
  clear_has_returnnum();
}
inline ::google::protobuf::uint32 TMTTemplateSatellite::returnnum() const {
  return returnnum_;
}
inline void TMTTemplateSatellite::set_returnnum(::google::protobuf::uint32 value) {
  set_has_returnnum();
  returnnum_ = value;
}

// -------------------------------------------------------------------

// TMTDualFormatList

// optional uint32 frame = 1;
inline bool TMTDualFormatList::has_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTDualFormatList::set_has_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTDualFormatList::clear_has_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTDualFormatList::clear_frame() {
  frame_ = 0u;
  clear_has_frame();
}
inline ::google::protobuf::uint32 TMTDualFormatList::frame() const {
  return frame_;
}
inline void TMTDualFormatList::set_frame(::google::protobuf::uint32 value) {
  set_has_frame();
  frame_ = value;
}

// optional .mt.EmMtResolution resolution = 2;
inline bool TMTDualFormatList::has_resolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTDualFormatList::set_has_resolution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTDualFormatList::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTDualFormatList::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::mt::EmMtResolution TMTDualFormatList::resolution() const {
  return static_cast< ::mt::EmMtResolution >(resolution_);
}
inline void TMTDualFormatList::set_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_resolution();
  resolution_ = value;
}

// optional .mt.EmVidFormat videoformat = 3;
inline bool TMTDualFormatList::has_videoformat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTDualFormatList::set_has_videoformat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTDualFormatList::clear_has_videoformat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTDualFormatList::clear_videoformat() {
  videoformat_ = 0;
  clear_has_videoformat();
}
inline ::mt::EmVidFormat TMTDualFormatList::videoformat() const {
  return static_cast< ::mt::EmVidFormat >(videoformat_);
}
inline void TMTDualFormatList::set_videoformat(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_videoformat();
  videoformat_ = value;
}

// -------------------------------------------------------------------

// TMTSetMixInfo

// optional bool enable = 1;
inline bool TMTSetMixInfo::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTSetMixInfo::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTSetMixInfo::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTSetMixInfo::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTSetMixInfo::enable() const {
  return enable_;
}
inline void TMTSetMixInfo::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional .mt.EmMtMixType mode = 2;
inline bool TMTSetMixInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTSetMixInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTSetMixInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTSetMixInfo::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mt::EmMtMixType TMTSetMixInfo::mode() const {
  return static_cast< ::mt::EmMtMixType >(mode_);
}
inline void TMTSetMixInfo::set_mode(::mt::EmMtMixType value) {
  assert(::mt::EmMtMixType_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// repeated .mt.TMTTemplateAccount mixmemberlist = 3;
inline int TMTSetMixInfo::mixmemberlist_size() const {
  return mixmemberlist_.size();
}
inline void TMTSetMixInfo::clear_mixmemberlist() {
  mixmemberlist_.Clear();
}
inline const ::mt::TMTTemplateAccount& TMTSetMixInfo::mixmemberlist(int index) const {
  return mixmemberlist_.Get(index);
}
inline ::mt::TMTTemplateAccount* TMTSetMixInfo::mutable_mixmemberlist(int index) {
  return mixmemberlist_.Mutable(index);
}
inline ::mt::TMTTemplateAccount* TMTSetMixInfo::add_mixmemberlist() {
  return mixmemberlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >&
TMTSetMixInfo::mixmemberlist() const {
  return mixmemberlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >*
TMTSetMixInfo::mutable_mixmemberlist() {
  return &mixmemberlist_;
}

// -------------------------------------------------------------------

// TMTGetMixInfo

// optional bool enable = 1;
inline bool TMTGetMixInfo::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTGetMixInfo::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTGetMixInfo::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTGetMixInfo::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTGetMixInfo::enable() const {
  return enable_;
}
inline void TMTGetMixInfo::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional .mt.EmMtMixType mode = 2;
inline bool TMTGetMixInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTGetMixInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTGetMixInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTGetMixInfo::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mt::EmMtMixType TMTGetMixInfo::mode() const {
  return static_cast< ::mt::EmMtMixType >(mode_);
}
inline void TMTGetMixInfo::set_mode(::mt::EmMtMixType value) {
  assert(::mt::EmMtMixType_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// repeated .mt.TMTTemplateMember mixmemberlist = 3;
inline int TMTGetMixInfo::mixmemberlist_size() const {
  return mixmemberlist_.size();
}
inline void TMTGetMixInfo::clear_mixmemberlist() {
  mixmemberlist_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTGetMixInfo::mixmemberlist(int index) const {
  return mixmemberlist_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTGetMixInfo::mutable_mixmemberlist(int index) {
  return mixmemberlist_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTGetMixInfo::add_mixmemberlist() {
  return mixmemberlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTGetMixInfo::mixmemberlist() const {
  return mixmemberlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTGetMixInfo::mutable_mixmemberlist() {
  return &mixmemberlist_;
}

// -------------------------------------------------------------------

// TMTVideoFormatList

// optional .mt.EmVidFormat videoformat = 1;
inline bool TMTVideoFormatList::has_videoformat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVideoFormatList::set_has_videoformat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVideoFormatList::clear_has_videoformat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVideoFormatList::clear_videoformat() {
  videoformat_ = 0;
  clear_has_videoformat();
}
inline ::mt::EmVidFormat TMTVideoFormatList::videoformat() const {
  return static_cast< ::mt::EmVidFormat >(videoformat_);
}
inline void TMTVideoFormatList::set_videoformat(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_videoformat();
  videoformat_ = value;
}

// optional .mt.EmH264Profile videoprofile = 2;
inline bool TMTVideoFormatList::has_videoprofile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVideoFormatList::set_has_videoprofile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVideoFormatList::clear_has_videoprofile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVideoFormatList::clear_videoprofile() {
  videoprofile_ = 0;
  clear_has_videoprofile();
}
inline ::mt::EmH264Profile TMTVideoFormatList::videoprofile() const {
  return static_cast< ::mt::EmH264Profile >(videoprofile_);
}
inline void TMTVideoFormatList::set_videoprofile(::mt::EmH264Profile value) {
  assert(::mt::EmH264Profile_IsValid(value));
  set_has_videoprofile();
  videoprofile_ = value;
}

// optional .mt.EmMtResolution resolution = 3;
inline bool TMTVideoFormatList::has_resolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVideoFormatList::set_has_resolution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVideoFormatList::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVideoFormatList::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::mt::EmMtResolution TMTVideoFormatList::resolution() const {
  return static_cast< ::mt::EmMtResolution >(resolution_);
}
inline void TMTVideoFormatList::set_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_resolution();
  resolution_ = value;
}

// optional uint32 frame = 4;
inline bool TMTVideoFormatList::has_frame() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTVideoFormatList::set_has_frame() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTVideoFormatList::clear_has_frame() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTVideoFormatList::clear_frame() {
  frame_ = 0u;
  clear_has_frame();
}
inline ::google::protobuf::uint32 TMTVideoFormatList::frame() const {
  return frame_;
}
inline void TMTVideoFormatList::set_frame(::google::protobuf::uint32 value) {
  set_has_frame();
  frame_ = value;
}

// optional uint32 rate = 5;
inline bool TMTVideoFormatList::has_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTVideoFormatList::set_has_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTVideoFormatList::clear_has_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTVideoFormatList::clear_rate() {
  rate_ = 0u;
  clear_has_rate();
}
inline ::google::protobuf::uint32 TMTVideoFormatList::rate() const {
  return rate_;
}
inline void TMTVideoFormatList::set_rate(::google::protobuf::uint32 value) {
  set_has_rate();
  rate_ = value;
}

// -------------------------------------------------------------------

// TMTAudioFormatList

// optional .mt.EmAudFormat audioformat = 1;
inline bool TMTAudioFormatList::has_audioformat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTAudioFormatList::set_has_audioformat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTAudioFormatList::clear_has_audioformat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTAudioFormatList::clear_audioformat() {
  audioformat_ = 0;
  clear_has_audioformat();
}
inline ::mt::EmAudFormat TMTAudioFormatList::audioformat() const {
  return static_cast< ::mt::EmAudFormat >(audioformat_);
}
inline void TMTAudioFormatList::set_audioformat(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_audioformat();
  audioformat_ = value;
}

// optional .mt.EmAacChnlNum aaccnnlnum = 2;
inline bool TMTAudioFormatList::has_aaccnnlnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTAudioFormatList::set_has_aaccnnlnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTAudioFormatList::clear_has_aaccnnlnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTAudioFormatList::clear_aaccnnlnum() {
  aaccnnlnum_ = 0;
  clear_has_aaccnnlnum();
}
inline ::mt::EmAacChnlNum TMTAudioFormatList::aaccnnlnum() const {
  return static_cast< ::mt::EmAacChnlNum >(aaccnnlnum_);
}
inline void TMTAudioFormatList::set_aaccnnlnum(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_aaccnnlnum();
  aaccnnlnum_ = value;
}

// -------------------------------------------------------------------

// TMTTemplateMember

// optional string name = 1;
inline bool TMTTemplateMember::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplateMember::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplateMember::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplateMember::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTTemplateMember::name() const {
  return *name_;
}
inline void TMTTemplateMember::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTTemplateMember::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTTemplateMember::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplateMember::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTTemplateMember::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplateMember::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 2;
inline bool TMTTemplateMember::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTTemplateMember::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTTemplateMember::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTTemplateMember::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTTemplateMember::account() const {
  return *account_;
}
inline void TMTTemplateMember::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTTemplateMember::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTTemplateMember::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplateMember::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTTemplateMember::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplateMember::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtAddrType accounttype = 3;
inline bool TMTTemplateMember::has_accounttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTTemplateMember::set_has_accounttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTTemplateMember::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTTemplateMember::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::mt::EmMtAddrType TMTTemplateMember::accounttype() const {
  return static_cast< ::mt::EmMtAddrType >(accounttype_);
}
inline void TMTTemplateMember::set_accounttype(::mt::EmMtAddrType value) {
  assert(::mt::EmMtAddrType_IsValid(value));
  set_has_accounttype();
  accounttype_ = value;
}

// -------------------------------------------------------------------

// TMTTemplateMultiCast

// optional string multicastAddr = 1;
inline bool TMTTemplateMultiCast::has_multicastaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplateMultiCast::set_has_multicastaddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplateMultiCast::clear_has_multicastaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplateMultiCast::clear_multicastaddr() {
  if (multicastaddr_ != &::google::protobuf::internal::kEmptyString) {
    multicastaddr_->clear();
  }
  clear_has_multicastaddr();
}
inline const ::std::string& TMTTemplateMultiCast::multicastaddr() const {
  return *multicastaddr_;
}
inline void TMTTemplateMultiCast::set_multicastaddr(const ::std::string& value) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(value);
}
inline void TMTTemplateMultiCast::set_multicastaddr(const char* value) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(value);
}
inline void TMTTemplateMultiCast::set_multicastaddr(const char* value, size_t size) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplateMultiCast::mutable_multicastaddr() {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  return multicastaddr_;
}
inline ::std::string* TMTTemplateMultiCast::release_multicastaddr() {
  clear_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = multicastaddr_;
    multicastaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplateMultiCast::set_allocated_multicastaddr(::std::string* multicastaddr) {
  if (multicastaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete multicastaddr_;
  }
  if (multicastaddr) {
    set_has_multicastaddr();
    multicastaddr_ = multicastaddr;
  } else {
    clear_has_multicastaddr();
    multicastaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool enable = 2;
inline bool TMTTemplateMultiCast::has_enable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTTemplateMultiCast::set_has_enable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTTemplateMultiCast::clear_has_enable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTTemplateMultiCast::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTTemplateMultiCast::enable() const {
  return enable_;
}
inline void TMTTemplateMultiCast::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional uint32 port = 3;
inline bool TMTTemplateMultiCast::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTTemplateMultiCast::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTTemplateMultiCast::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTTemplateMultiCast::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMTTemplateMultiCast::port() const {
  return port_;
}
inline void TMTTemplateMultiCast::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMTTemplateVmpMember

// optional string name = 1;
inline bool TMTTemplateVmpMember::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplateVmpMember::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplateVmpMember::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplateVmpMember::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTTemplateVmpMember::name() const {
  return *name_;
}
inline void TMTTemplateVmpMember::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTTemplateVmpMember::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTTemplateVmpMember::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplateVmpMember::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTTemplateVmpMember::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplateVmpMember::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 2;
inline bool TMTTemplateVmpMember::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTTemplateVmpMember::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTTemplateVmpMember::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTTemplateVmpMember::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTTemplateVmpMember::account() const {
  return *account_;
}
inline void TMTTemplateVmpMember::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTTemplateVmpMember::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTTemplateVmpMember::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTTemplateVmpMember::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTTemplateVmpMember::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTTemplateVmpMember::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtAddrType accounttype = 3;
inline bool TMTTemplateVmpMember::has_accounttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTTemplateVmpMember::set_has_accounttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTTemplateVmpMember::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTTemplateVmpMember::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::mt::EmMtAddrType TMTTemplateVmpMember::accounttype() const {
  return static_cast< ::mt::EmMtAddrType >(accounttype_);
}
inline void TMTTemplateVmpMember::set_accounttype(::mt::EmMtAddrType value) {
  assert(::mt::EmMtAddrType_IsValid(value));
  set_has_accounttype();
  accounttype_ = value;
}

// optional .mt.EmMtVMPMmbType followtype = 4;
inline bool TMTTemplateVmpMember::has_followtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTTemplateVmpMember::set_has_followtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTTemplateVmpMember::clear_has_followtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTTemplateVmpMember::clear_followtype() {
  followtype_ = 0;
  clear_has_followtype();
}
inline ::mt::EmMtVMPMmbType TMTTemplateVmpMember::followtype() const {
  return static_cast< ::mt::EmMtVMPMmbType >(followtype_);
}
inline void TMTTemplateVmpMember::set_followtype(::mt::EmMtVMPMmbType value) {
  assert(::mt::EmMtVMPMmbType_IsValid(value));
  set_has_followtype();
  followtype_ = value;
}

// optional uint32 index = 5;
inline bool TMTTemplateVmpMember::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTTemplateVmpMember::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTTemplateVmpMember::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTTemplateVmpMember::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TMTTemplateVmpMember::index() const {
  return index_;
}
inline void TMTTemplateVmpMember::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional .mt.TMTConfPollInfo poll = 6;
inline bool TMTTemplateVmpMember::has_poll() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTTemplateVmpMember::set_has_poll() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTTemplateVmpMember::clear_has_poll() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTTemplateVmpMember::clear_poll() {
  if (poll_ != NULL) poll_->::mt::TMTConfPollInfo::Clear();
  clear_has_poll();
}
inline const ::mt::TMTConfPollInfo& TMTTemplateVmpMember::poll() const {
  return poll_ != NULL ? *poll_ : *default_instance_->poll_;
}
inline ::mt::TMTConfPollInfo* TMTTemplateVmpMember::mutable_poll() {
  set_has_poll();
  if (poll_ == NULL) poll_ = new ::mt::TMTConfPollInfo;
  return poll_;
}
inline ::mt::TMTConfPollInfo* TMTTemplateVmpMember::release_poll() {
  clear_has_poll();
  ::mt::TMTConfPollInfo* temp = poll_;
  poll_ = NULL;
  return temp;
}
inline void TMTTemplateVmpMember::set_allocated_poll(::mt::TMTConfPollInfo* poll) {
  delete poll_;
  poll_ = poll;
  if (poll) {
    set_has_poll();
  } else {
    clear_has_poll();
  }
}

// -------------------------------------------------------------------

// TMTTemplateVmp

// optional bool enable = 1;
inline bool TMTTemplateVmp::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplateVmp::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplateVmp::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplateVmp::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTTemplateVmp::enable() const {
  return enable_;
}
inline void TMTTemplateVmp::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional .mt.EmMtVmpStyle style = 2;
inline bool TMTTemplateVmp::has_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTTemplateVmp::set_has_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTTemplateVmp::clear_has_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTTemplateVmp::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::mt::EmMtVmpStyle TMTTemplateVmp::style() const {
  return static_cast< ::mt::EmMtVmpStyle >(style_);
}
inline void TMTTemplateVmp::set_style(::mt::EmMtVmpStyle value) {
  assert(::mt::EmMtVmpStyle_IsValid(value));
  set_has_style();
  style_ = value;
}

// optional bool voicehint = 3;
inline bool TMTTemplateVmp::has_voicehint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTTemplateVmp::set_has_voicehint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTTemplateVmp::clear_has_voicehint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTTemplateVmp::clear_voicehint() {
  voicehint_ = false;
  clear_has_voicehint();
}
inline bool TMTTemplateVmp::voicehint() const {
  return voicehint_;
}
inline void TMTTemplateVmp::set_voicehint(bool value) {
  set_has_voicehint();
  voicehint_ = value;
}

// optional bool showmtname = 4;
inline bool TMTTemplateVmp::has_showmtname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTTemplateVmp::set_has_showmtname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTTemplateVmp::clear_has_showmtname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTTemplateVmp::clear_showmtname() {
  showmtname_ = false;
  clear_has_showmtname();
}
inline bool TMTTemplateVmp::showmtname() const {
  return showmtname_;
}
inline void TMTTemplateVmp::set_showmtname(bool value) {
  set_has_showmtname();
  showmtname_ = value;
}

// repeated .mt.TMTTemplateVmpMember memberlist = 5;
inline int TMTTemplateVmp::memberlist_size() const {
  return memberlist_.size();
}
inline void TMTTemplateVmp::clear_memberlist() {
  memberlist_.Clear();
}
inline const ::mt::TMTTemplateVmpMember& TMTTemplateVmp::memberlist(int index) const {
  return memberlist_.Get(index);
}
inline ::mt::TMTTemplateVmpMember* TMTTemplateVmp::mutable_memberlist(int index) {
  return memberlist_.Mutable(index);
}
inline ::mt::TMTTemplateVmpMember* TMTTemplateVmp::add_memberlist() {
  return memberlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateVmpMember >&
TMTTemplateVmp::memberlist() const {
  return memberlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateVmpMember >*
TMTTemplateVmp::mutable_memberlist() {
  return &memberlist_;
}

// optional bool broadcast = 6;
inline bool TMTTemplateVmp::has_broadcast() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTTemplateVmp::set_has_broadcast() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTTemplateVmp::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTTemplateVmp::clear_broadcast() {
  broadcast_ = false;
  clear_has_broadcast();
}
inline bool TMTTemplateVmp::broadcast() const {
  return broadcast_;
}
inline void TMTTemplateVmp::set_broadcast(bool value) {
  set_has_broadcast();
  broadcast_ = value;
}

// -------------------------------------------------------------------

// TMTTemplatePoll

// optional bool enable = 1;
inline bool TMTTemplatePoll::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTemplatePoll::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTemplatePoll::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTemplatePoll::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTTemplatePoll::enable() const {
  return enable_;
}
inline void TMTTemplatePoll::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional uint32 num = 2;
inline bool TMTTemplatePoll::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTTemplatePoll::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTTemplatePoll::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTTemplatePoll::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 TMTTemplatePoll::num() const {
  return num_;
}
inline void TMTTemplatePoll::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional uint32 interval = 3;
inline bool TMTTemplatePoll::has_interval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTTemplatePoll::set_has_interval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTTemplatePoll::clear_has_interval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTTemplatePoll::clear_interval() {
  interval_ = 0u;
  clear_has_interval();
}
inline ::google::protobuf::uint32 TMTTemplatePoll::interval() const {
  return interval_;
}
inline void TMTTemplatePoll::set_interval(::google::protobuf::uint32 value) {
  set_has_interval();
  interval_ = value;
}

// optional bool speaker = 4;
inline bool TMTTemplatePoll::has_speaker() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTTemplatePoll::set_has_speaker() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTTemplatePoll::clear_has_speaker() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTTemplatePoll::clear_speaker() {
  speaker_ = false;
  clear_has_speaker();
}
inline bool TMTTemplatePoll::speaker() const {
  return speaker_;
}
inline void TMTTemplatePoll::set_speaker(bool value) {
  set_has_speaker();
  speaker_ = value;
}

// repeated .mt.TMTTemplateMember memberlist = 5;
inline int TMTTemplatePoll::memberlist_size() const {
  return memberlist_.size();
}
inline void TMTTemplatePoll::clear_memberlist() {
  memberlist_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTTemplatePoll::memberlist(int index) const {
  return memberlist_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTTemplatePoll::mutable_memberlist(int index) {
  return memberlist_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTTemplatePoll::add_memberlist() {
  return memberlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTTemplatePoll::memberlist() const {
  return memberlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTTemplatePoll::mutable_memberlist() {
  return &memberlist_;
}

// -------------------------------------------------------------------

// TMTPerTemplateSimpleInfo

// optional uint32 templateid = 1;
inline bool TMTPerTemplateSimpleInfo::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPerTemplateSimpleInfo::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPerTemplateSimpleInfo::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPerTemplateSimpleInfo::clear_templateid() {
  templateid_ = 0u;
  clear_has_templateid();
}
inline ::google::protobuf::uint32 TMTPerTemplateSimpleInfo::templateid() const {
  return templateid_;
}
inline void TMTPerTemplateSimpleInfo::set_templateid(::google::protobuf::uint32 value) {
  set_has_templateid();
  templateid_ = value;
}

// optional string name = 2;
inline bool TMTPerTemplateSimpleInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPerTemplateSimpleInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPerTemplateSimpleInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPerTemplateSimpleInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTPerTemplateSimpleInfo::name() const {
  return *name_;
}
inline void TMTPerTemplateSimpleInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPerTemplateSimpleInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPerTemplateSimpleInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerTemplateSimpleInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTPerTemplateSimpleInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerTemplateSimpleInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 3;
inline bool TMTPerTemplateSimpleInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPerTemplateSimpleInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPerTemplateSimpleInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPerTemplateSimpleInfo::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTPerTemplateSimpleInfo::duration() const {
  return duration_;
}
inline void TMTPerTemplateSimpleInfo::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 bitrate = 4;
inline bool TMTPerTemplateSimpleInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPerTemplateSimpleInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPerTemplateSimpleInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPerTemplateSimpleInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTPerTemplateSimpleInfo::bitrate() const {
  return bitrate_;
}
inline void TMTPerTemplateSimpleInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmMtResolution resolution = 5;
inline bool TMTPerTemplateSimpleInfo::has_resolution() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTPerTemplateSimpleInfo::set_has_resolution() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTPerTemplateSimpleInfo::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTPerTemplateSimpleInfo::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::mt::EmMtResolution TMTPerTemplateSimpleInfo::resolution() const {
  return static_cast< ::mt::EmMtResolution >(resolution_);
}
inline void TMTPerTemplateSimpleInfo::set_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_resolution();
  resolution_ = value;
}

// -------------------------------------------------------------------

// TMTPerTemplateDetail

// optional .mt.TMTPerTemplateSimpleInfo personaltemplate = 1;
inline bool TMTPerTemplateDetail::has_personaltemplate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPerTemplateDetail::set_has_personaltemplate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPerTemplateDetail::clear_has_personaltemplate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPerTemplateDetail::clear_personaltemplate() {
  if (personaltemplate_ != NULL) personaltemplate_->::mt::TMTPerTemplateSimpleInfo::Clear();
  clear_has_personaltemplate();
}
inline const ::mt::TMTPerTemplateSimpleInfo& TMTPerTemplateDetail::personaltemplate() const {
  return personaltemplate_ != NULL ? *personaltemplate_ : *default_instance_->personaltemplate_;
}
inline ::mt::TMTPerTemplateSimpleInfo* TMTPerTemplateDetail::mutable_personaltemplate() {
  set_has_personaltemplate();
  if (personaltemplate_ == NULL) personaltemplate_ = new ::mt::TMTPerTemplateSimpleInfo;
  return personaltemplate_;
}
inline ::mt::TMTPerTemplateSimpleInfo* TMTPerTemplateDetail::release_personaltemplate() {
  clear_has_personaltemplate();
  ::mt::TMTPerTemplateSimpleInfo* temp = personaltemplate_;
  personaltemplate_ = NULL;
  return temp;
}
inline void TMTPerTemplateDetail::set_allocated_personaltemplate(::mt::TMTPerTemplateSimpleInfo* personaltemplate) {
  delete personaltemplate_;
  personaltemplate_ = personaltemplate;
  if (personaltemplate) {
    set_has_personaltemplate();
  } else {
    clear_has_personaltemplate();
  }
}

// repeated .mt.TMTTemplateMember members = 2;
inline int TMTPerTemplateDetail::members_size() const {
  return members_.size();
}
inline void TMTPerTemplateDetail::clear_members() {
  members_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTPerTemplateDetail::members(int index) const {
  return members_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTPerTemplateDetail::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTPerTemplateDetail::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTPerTemplateDetail::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTPerTemplateDetail::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// TMTPerTemplateList

// repeated .mt.TMTPerTemplateDetail templatedetail = 1;
inline int TMTPerTemplateList::templatedetail_size() const {
  return templatedetail_.size();
}
inline void TMTPerTemplateList::clear_templatedetail() {
  templatedetail_.Clear();
}
inline const ::mt::TMTPerTemplateDetail& TMTPerTemplateList::templatedetail(int index) const {
  return templatedetail_.Get(index);
}
inline ::mt::TMTPerTemplateDetail* TMTPerTemplateList::mutable_templatedetail(int index) {
  return templatedetail_.Mutable(index);
}
inline ::mt::TMTPerTemplateDetail* TMTPerTemplateList::add_templatedetail() {
  return templatedetail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPerTemplateDetail >&
TMTPerTemplateList::templatedetail() const {
  return templatedetail_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPerTemplateDetail >*
TMTPerTemplateList::mutable_templatedetail() {
  return &templatedetail_;
}

// -------------------------------------------------------------------

// TMTPerTemplateInfo

// optional uint32 templateid = 1;
inline bool TMTPerTemplateInfo::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPerTemplateInfo::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPerTemplateInfo::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPerTemplateInfo::clear_templateid() {
  templateid_ = 0u;
  clear_has_templateid();
}
inline ::google::protobuf::uint32 TMTPerTemplateInfo::templateid() const {
  return templateid_;
}
inline void TMTPerTemplateInfo::set_templateid(::google::protobuf::uint32 value) {
  set_has_templateid();
  templateid_ = value;
}

// optional string name = 2;
inline bool TMTPerTemplateInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPerTemplateInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPerTemplateInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPerTemplateInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTPerTemplateInfo::name() const {
  return *name_;
}
inline void TMTPerTemplateInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPerTemplateInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPerTemplateInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerTemplateInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTPerTemplateInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerTemplateInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 3;
inline bool TMTPerTemplateInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPerTemplateInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPerTemplateInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPerTemplateInfo::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTPerTemplateInfo::duration() const {
  return duration_;
}
inline void TMTPerTemplateInfo::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 bitrate = 4;
inline bool TMTPerTemplateInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPerTemplateInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPerTemplateInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPerTemplateInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTPerTemplateInfo::bitrate() const {
  return bitrate_;
}
inline void TMTPerTemplateInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmMtOpenMode meetingsafe = 5;
inline bool TMTPerTemplateInfo::has_meetingsafe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTPerTemplateInfo::set_has_meetingsafe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTPerTemplateInfo::clear_has_meetingsafe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTPerTemplateInfo::clear_meetingsafe() {
  meetingsafe_ = 1;
  clear_has_meetingsafe();
}
inline ::mt::EmMtOpenMode TMTPerTemplateInfo::meetingsafe() const {
  return static_cast< ::mt::EmMtOpenMode >(meetingsafe_);
}
inline void TMTPerTemplateInfo::set_meetingsafe(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_meetingsafe();
  meetingsafe_ = value;
}

// optional string password = 6;
inline bool TMTPerTemplateInfo::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTPerTemplateInfo::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTPerTemplateInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTPerTemplateInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTPerTemplateInfo::password() const {
  return *password_;
}
inline void TMTPerTemplateInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTPerTemplateInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTPerTemplateInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerTemplateInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTPerTemplateInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerTemplateInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmEncryptArithmetic encryptedtype = 7;
inline bool TMTPerTemplateInfo::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTPerTemplateInfo::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTPerTemplateInfo::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTPerTemplateInfo::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTPerTemplateInfo::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTPerTemplateInfo::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional string encryptedkey = 8;
inline bool TMTPerTemplateInfo::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTPerTemplateInfo::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTPerTemplateInfo::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTPerTemplateInfo::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTPerTemplateInfo::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTPerTemplateInfo::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPerTemplateInfo::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPerTemplateInfo::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerTemplateInfo::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTPerTemplateInfo::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerTemplateInfo::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestMeetingSafeType meetingtype = 9;
inline bool TMTPerTemplateInfo::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTPerTemplateInfo::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTPerTemplateInfo::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTPerTemplateInfo::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTPerTemplateInfo::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTPerTemplateInfo::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional .mt.TMTTemplateSatellite satellite = 10;
inline bool TMTPerTemplateInfo::has_satellite() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTPerTemplateInfo::set_has_satellite() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTPerTemplateInfo::clear_has_satellite() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTPerTemplateInfo::clear_satellite() {
  if (satellite_ != NULL) satellite_->::mt::TMTTemplateSatellite::Clear();
  clear_has_satellite();
}
inline const ::mt::TMTTemplateSatellite& TMTPerTemplateInfo::satellite() const {
  return satellite_ != NULL ? *satellite_ : *default_instance_->satellite_;
}
inline ::mt::TMTTemplateSatellite* TMTPerTemplateInfo::mutable_satellite() {
  set_has_satellite();
  if (satellite_ == NULL) satellite_ = new ::mt::TMTTemplateSatellite;
  return satellite_;
}
inline ::mt::TMTTemplateSatellite* TMTPerTemplateInfo::release_satellite() {
  clear_has_satellite();
  ::mt::TMTTemplateSatellite* temp = satellite_;
  satellite_ = NULL;
  return temp;
}
inline void TMTPerTemplateInfo::set_allocated_satellite(::mt::TMTTemplateSatellite* satellite) {
  delete satellite_;
  satellite_ = satellite;
  if (satellite) {
    set_has_satellite();
  } else {
    clear_has_satellite();
  }
}

// optional bool publicmeeting = 11;
inline bool TMTPerTemplateInfo::has_publicmeeting() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTPerTemplateInfo::set_has_publicmeeting() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTPerTemplateInfo::clear_has_publicmeeting() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTPerTemplateInfo::clear_publicmeeting() {
  publicmeeting_ = false;
  clear_has_publicmeeting();
}
inline bool TMTPerTemplateInfo::publicmeeting() const {
  return publicmeeting_;
}
inline void TMTPerTemplateInfo::set_publicmeeting(bool value) {
  set_has_publicmeeting();
  publicmeeting_ = value;
}

// optional .mt.TMTGetMixInfo mixinfo = 12;
inline bool TMTPerTemplateInfo::has_mixinfo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTPerTemplateInfo::set_has_mixinfo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTPerTemplateInfo::clear_has_mixinfo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTPerTemplateInfo::clear_mixinfo() {
  if (mixinfo_ != NULL) mixinfo_->::mt::TMTGetMixInfo::Clear();
  clear_has_mixinfo();
}
inline const ::mt::TMTGetMixInfo& TMTPerTemplateInfo::mixinfo() const {
  return mixinfo_ != NULL ? *mixinfo_ : *default_instance_->mixinfo_;
}
inline ::mt::TMTGetMixInfo* TMTPerTemplateInfo::mutable_mixinfo() {
  set_has_mixinfo();
  if (mixinfo_ == NULL) mixinfo_ = new ::mt::TMTGetMixInfo;
  return mixinfo_;
}
inline ::mt::TMTGetMixInfo* TMTPerTemplateInfo::release_mixinfo() {
  clear_has_mixinfo();
  ::mt::TMTGetMixInfo* temp = mixinfo_;
  mixinfo_ = NULL;
  return temp;
}
inline void TMTPerTemplateInfo::set_allocated_mixinfo(::mt::TMTGetMixInfo* mixinfo) {
  delete mixinfo_;
  mixinfo_ = mixinfo;
  if (mixinfo) {
    set_has_mixinfo();
  } else {
    clear_has_mixinfo();
  }
}

// repeated .mt.TMTVideoFormatList videoformatlist = 13;
inline int TMTPerTemplateInfo::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTPerTemplateInfo::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTPerTemplateInfo::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTPerTemplateInfo::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTPerTemplateInfo::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTPerTemplateInfo::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTPerTemplateInfo::mutable_videoformatlist() {
  return &videoformatlist_;
}

// repeated .mt.TMTAudioFormatList audioformatlist = 14;
inline int TMTPerTemplateInfo::audioformatlist_size() const {
  return audioformatlist_.size();
}
inline void TMTPerTemplateInfo::clear_audioformatlist() {
  audioformatlist_.Clear();
}
inline const ::mt::TMTAudioFormatList& TMTPerTemplateInfo::audioformatlist(int index) const {
  return audioformatlist_.Get(index);
}
inline ::mt::TMTAudioFormatList* TMTPerTemplateInfo::mutable_audioformatlist(int index) {
  return audioformatlist_.Mutable(index);
}
inline ::mt::TMTAudioFormatList* TMTPerTemplateInfo::add_audioformatlist() {
  return audioformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
TMTPerTemplateInfo::audioformatlist() const {
  return audioformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
TMTPerTemplateInfo::mutable_audioformatlist() {
  return &audioformatlist_;
}

// repeated .mt.TMTTemplateMember members = 15;
inline int TMTPerTemplateInfo::members_size() const {
  return members_.size();
}
inline void TMTPerTemplateInfo::clear_members() {
  members_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTPerTemplateInfo::members(int index) const {
  return members_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTPerTemplateInfo::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTPerTemplateInfo::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTPerTemplateInfo::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTPerTemplateInfo::mutable_members() {
  return &members_;
}

// optional .mt.TMTTemplateMember speaker = 16;
inline bool TMTPerTemplateInfo::has_speaker() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_speaker() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTPerTemplateInfo::clear_has_speaker() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTPerTemplateInfo::clear_speaker() {
  if (speaker_ != NULL) speaker_->::mt::TMTTemplateMember::Clear();
  clear_has_speaker();
}
inline const ::mt::TMTTemplateMember& TMTPerTemplateInfo::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::mt::TMTTemplateMember* TMTPerTemplateInfo::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::mt::TMTTemplateMember;
  return speaker_;
}
inline ::mt::TMTTemplateMember* TMTPerTemplateInfo::release_speaker() {
  clear_has_speaker();
  ::mt::TMTTemplateMember* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void TMTPerTemplateInfo::set_allocated_speaker(::mt::TMTTemplateMember* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional .mt.TMTTemplateMember admin = 17;
inline bool TMTPerTemplateInfo::has_admin() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_admin() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTPerTemplateInfo::clear_has_admin() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTPerTemplateInfo::clear_admin() {
  if (admin_ != NULL) admin_->::mt::TMTTemplateMember::Clear();
  clear_has_admin();
}
inline const ::mt::TMTTemplateMember& TMTPerTemplateInfo::admin() const {
  return admin_ != NULL ? *admin_ : *default_instance_->admin_;
}
inline ::mt::TMTTemplateMember* TMTPerTemplateInfo::mutable_admin() {
  set_has_admin();
  if (admin_ == NULL) admin_ = new ::mt::TMTTemplateMember;
  return admin_;
}
inline ::mt::TMTTemplateMember* TMTPerTemplateInfo::release_admin() {
  clear_has_admin();
  ::mt::TMTTemplateMember* temp = admin_;
  admin_ = NULL;
  return temp;
}
inline void TMTPerTemplateInfo::set_allocated_admin(::mt::TMTTemplateMember* admin) {
  delete admin_;
  admin_ = admin;
  if (admin) {
    set_has_admin();
  } else {
    clear_has_admin();
  }
}

// optional uint32 calltimes = 18;
inline bool TMTPerTemplateInfo::has_calltimes() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_calltimes() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTPerTemplateInfo::clear_has_calltimes() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTPerTemplateInfo::clear_calltimes() {
  calltimes_ = 0u;
  clear_has_calltimes();
}
inline ::google::protobuf::uint32 TMTPerTemplateInfo::calltimes() const {
  return calltimes_;
}
inline void TMTPerTemplateInfo::set_calltimes(::google::protobuf::uint32 value) {
  set_has_calltimes();
  calltimes_ = value;
}

// optional uint32 callinterval = 19;
inline bool TMTPerTemplateInfo::has_callinterval() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_callinterval() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTPerTemplateInfo::clear_has_callinterval() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTPerTemplateInfo::clear_callinterval() {
  callinterval_ = 0u;
  clear_has_callinterval();
}
inline ::google::protobuf::uint32 TMTPerTemplateInfo::callinterval() const {
  return callinterval_;
}
inline void TMTPerTemplateInfo::set_callinterval(::google::protobuf::uint32 value) {
  set_has_callinterval();
  callinterval_ = value;
}

// optional bool callchase = 20;
inline bool TMTPerTemplateInfo::has_callchase() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_callchase() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTPerTemplateInfo::clear_has_callchase() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTPerTemplateInfo::clear_callchase() {
  callchase_ = false;
  clear_has_callchase();
}
inline bool TMTPerTemplateInfo::callchase() const {
  return callchase_;
}
inline void TMTPerTemplateInfo::set_callchase(bool value) {
  set_has_callchase();
  callchase_ = value;
}

// optional bool initmute = 21;
inline bool TMTPerTemplateInfo::has_initmute() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_initmute() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTPerTemplateInfo::clear_has_initmute() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTPerTemplateInfo::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTPerTemplateInfo::initmute() const {
  return initmute_;
}
inline void TMTPerTemplateInfo::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional .mt.EmRestVideoQuality videoquality = 22;
inline bool TMTPerTemplateInfo::has_videoquality() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_videoquality() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTPerTemplateInfo::clear_has_videoquality() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTPerTemplateInfo::clear_videoquality() {
  videoquality_ = 0;
  clear_has_videoquality();
}
inline ::mt::EmRestVideoQuality TMTPerTemplateInfo::videoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(videoquality_);
}
inline void TMTPerTemplateInfo::set_videoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_videoquality();
  videoquality_ = value;
}

// optional .mt.EmRestDualMode dualmode = 23;
inline bool TMTPerTemplateInfo::has_dualmode() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_dualmode() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTPerTemplateInfo::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTPerTemplateInfo::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTPerTemplateInfo::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTPerTemplateInfo::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool voiceinspireenable = 24;
inline bool TMTPerTemplateInfo::has_voiceinspireenable() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_voiceinspireenable() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTPerTemplateInfo::clear_has_voiceinspireenable() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTPerTemplateInfo::clear_voiceinspireenable() {
  voiceinspireenable_ = false;
  clear_has_voiceinspireenable();
}
inline bool TMTPerTemplateInfo::voiceinspireenable() const {
  return voiceinspireenable_;
}
inline void TMTPerTemplateInfo::set_voiceinspireenable(bool value) {
  set_has_voiceinspireenable();
  voiceinspireenable_ = value;
}

// optional .mt.EmRestCascadeMode cascademode = 25;
inline bool TMTPerTemplateInfo::has_cascademode() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_cascademode() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTPerTemplateInfo::clear_has_cascademode() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTPerTemplateInfo::clear_cascademode() {
  cascademode_ = 0;
  clear_has_cascademode();
}
inline ::mt::EmRestCascadeMode TMTPerTemplateInfo::cascademode() const {
  return static_cast< ::mt::EmRestCascadeMode >(cascademode_);
}
inline void TMTPerTemplateInfo::set_cascademode(::mt::EmRestCascadeMode value) {
  assert(::mt::EmRestCascadeMode_IsValid(value));
  set_has_cascademode();
  cascademode_ = value;
}

// optional bool cascadeupload = 26;
inline bool TMTPerTemplateInfo::has_cascadeupload() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_cascadeupload() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMTPerTemplateInfo::clear_has_cascadeupload() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMTPerTemplateInfo::clear_cascadeupload() {
  cascadeupload_ = false;
  clear_has_cascadeupload();
}
inline bool TMTPerTemplateInfo::cascadeupload() const {
  return cascadeupload_;
}
inline void TMTPerTemplateInfo::set_cascadeupload(bool value) {
  set_has_cascadeupload();
  cascadeupload_ = value;
}

// optional bool cascadereturn = 27;
inline bool TMTPerTemplateInfo::has_cascadereturn() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_cascadereturn() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMTPerTemplateInfo::clear_has_cascadereturn() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMTPerTemplateInfo::clear_cascadereturn() {
  cascadereturn_ = false;
  clear_has_cascadereturn();
}
inline bool TMTPerTemplateInfo::cascadereturn() const {
  return cascadereturn_;
}
inline void TMTPerTemplateInfo::set_cascadereturn(bool value) {
  set_has_cascadereturn();
  cascadereturn_ = value;
}

// optional uint32 cascadereturnpara = 28;
inline bool TMTPerTemplateInfo::has_cascadereturnpara() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_cascadereturnpara() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTPerTemplateInfo::clear_has_cascadereturnpara() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTPerTemplateInfo::clear_cascadereturnpara() {
  cascadereturnpara_ = 0u;
  clear_has_cascadereturnpara();
}
inline ::google::protobuf::uint32 TMTPerTemplateInfo::cascadereturnpara() const {
  return cascadereturnpara_;
}
inline void TMTPerTemplateInfo::set_cascadereturnpara(::google::protobuf::uint32 value) {
  set_has_cascadereturnpara();
  cascadereturnpara_ = value;
}

// optional .mt.TMTTemplateRecord record = 29;
inline bool TMTPerTemplateInfo::has_record() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_record() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMTPerTemplateInfo::clear_has_record() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMTPerTemplateInfo::clear_record() {
  if (record_ != NULL) record_->::mt::TMTTemplateRecord::Clear();
  clear_has_record();
}
inline const ::mt::TMTTemplateRecord& TMTPerTemplateInfo::record() const {
  return record_ != NULL ? *record_ : *default_instance_->record_;
}
inline ::mt::TMTTemplateRecord* TMTPerTemplateInfo::mutable_record() {
  set_has_record();
  if (record_ == NULL) record_ = new ::mt::TMTTemplateRecord;
  return record_;
}
inline ::mt::TMTTemplateRecord* TMTPerTemplateInfo::release_record() {
  clear_has_record();
  ::mt::TMTTemplateRecord* temp = record_;
  record_ = NULL;
  return temp;
}
inline void TMTPerTemplateInfo::set_allocated_record(::mt::TMTTemplateRecord* record) {
  delete record_;
  record_ = record;
  if (record) {
    set_has_record();
  } else {
    clear_has_record();
  }
}

// optional .mt.TMTTemplateMultiCast multicast = 30;
inline bool TMTPerTemplateInfo::has_multicast() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_multicast() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMTPerTemplateInfo::clear_has_multicast() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMTPerTemplateInfo::clear_multicast() {
  if (multicast_ != NULL) multicast_->::mt::TMTTemplateMultiCast::Clear();
  clear_has_multicast();
}
inline const ::mt::TMTTemplateMultiCast& TMTPerTemplateInfo::multicast() const {
  return multicast_ != NULL ? *multicast_ : *default_instance_->multicast_;
}
inline ::mt::TMTTemplateMultiCast* TMTPerTemplateInfo::mutable_multicast() {
  set_has_multicast();
  if (multicast_ == NULL) multicast_ = new ::mt::TMTTemplateMultiCast;
  return multicast_;
}
inline ::mt::TMTTemplateMultiCast* TMTPerTemplateInfo::release_multicast() {
  clear_has_multicast();
  ::mt::TMTTemplateMultiCast* temp = multicast_;
  multicast_ = NULL;
  return temp;
}
inline void TMTPerTemplateInfo::set_allocated_multicast(::mt::TMTTemplateMultiCast* multicast) {
  delete multicast_;
  multicast_ = multicast;
  if (multicast) {
    set_has_multicast();
  } else {
    clear_has_multicast();
  }
}

// repeated .mt.TMTDualFormatList dualformatlist = 31;
inline int TMTPerTemplateInfo::dualformatlist_size() const {
  return dualformatlist_.size();
}
inline void TMTPerTemplateInfo::clear_dualformatlist() {
  dualformatlist_.Clear();
}
inline const ::mt::TMTDualFormatList& TMTPerTemplateInfo::dualformatlist(int index) const {
  return dualformatlist_.Get(index);
}
inline ::mt::TMTDualFormatList* TMTPerTemplateInfo::mutable_dualformatlist(int index) {
  return dualformatlist_.Mutable(index);
}
inline ::mt::TMTDualFormatList* TMTPerTemplateInfo::add_dualformatlist() {
  return dualformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
TMTPerTemplateInfo::dualformatlist() const {
  return dualformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
TMTPerTemplateInfo::mutable_dualformatlist() {
  return &dualformatlist_;
}

// optional .mt.TMTTemplateVmp vmp = 32;
inline bool TMTPerTemplateInfo::has_vmp() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TMTPerTemplateInfo::set_has_vmp() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TMTPerTemplateInfo::clear_has_vmp() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TMTPerTemplateInfo::clear_vmp() {
  if (vmp_ != NULL) vmp_->::mt::TMTTemplateVmp::Clear();
  clear_has_vmp();
}
inline const ::mt::TMTTemplateVmp& TMTPerTemplateInfo::vmp() const {
  return vmp_ != NULL ? *vmp_ : *default_instance_->vmp_;
}
inline ::mt::TMTTemplateVmp* TMTPerTemplateInfo::mutable_vmp() {
  set_has_vmp();
  if (vmp_ == NULL) vmp_ = new ::mt::TMTTemplateVmp;
  return vmp_;
}
inline ::mt::TMTTemplateVmp* TMTPerTemplateInfo::release_vmp() {
  clear_has_vmp();
  ::mt::TMTTemplateVmp* temp = vmp_;
  vmp_ = NULL;
  return temp;
}
inline void TMTPerTemplateInfo::set_allocated_vmp(::mt::TMTTemplateVmp* vmp) {
  delete vmp_;
  vmp_ = vmp;
  if (vmp) {
    set_has_vmp();
  } else {
    clear_has_vmp();
  }
}

// repeated .mt.TMTTemplateMember viplist = 33;
inline int TMTPerTemplateInfo::viplist_size() const {
  return viplist_.size();
}
inline void TMTPerTemplateInfo::clear_viplist() {
  viplist_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTPerTemplateInfo::viplist(int index) const {
  return viplist_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTPerTemplateInfo::mutable_viplist(int index) {
  return viplist_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTPerTemplateInfo::add_viplist() {
  return viplist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTPerTemplateInfo::viplist() const {
  return viplist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTPerTemplateInfo::mutable_viplist() {
  return &viplist_;
}

// optional .mt.TMTTemplatePoll poll = 34;
inline bool TMTPerTemplateInfo::has_poll() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TMTPerTemplateInfo::set_has_poll() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TMTPerTemplateInfo::clear_has_poll() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TMTPerTemplateInfo::clear_poll() {
  if (poll_ != NULL) poll_->::mt::TMTTemplatePoll::Clear();
  clear_has_poll();
}
inline const ::mt::TMTTemplatePoll& TMTPerTemplateInfo::poll() const {
  return poll_ != NULL ? *poll_ : *default_instance_->poll_;
}
inline ::mt::TMTTemplatePoll* TMTPerTemplateInfo::mutable_poll() {
  set_has_poll();
  if (poll_ == NULL) poll_ = new ::mt::TMTTemplatePoll;
  return poll_;
}
inline ::mt::TMTTemplatePoll* TMTPerTemplateInfo::release_poll() {
  clear_has_poll();
  ::mt::TMTTemplatePoll* temp = poll_;
  poll_ = NULL;
  return temp;
}
inline void TMTPerTemplateInfo::set_allocated_poll(::mt::TMTTemplatePoll* poll) {
  delete poll_;
  poll_ = poll;
  if (poll) {
    set_has_poll();
  } else {
    clear_has_poll();
  }
}

// repeated .mt.TMTTemplateMember callchasememberlist = 35;
inline int TMTPerTemplateInfo::callchasememberlist_size() const {
  return callchasememberlist_.size();
}
inline void TMTPerTemplateInfo::clear_callchasememberlist() {
  callchasememberlist_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTPerTemplateInfo::callchasememberlist(int index) const {
  return callchasememberlist_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTPerTemplateInfo::mutable_callchasememberlist(int index) {
  return callchasememberlist_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTPerTemplateInfo::add_callchasememberlist() {
  return callchasememberlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTPerTemplateInfo::callchasememberlist() const {
  return callchasememberlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTPerTemplateInfo::mutable_callchasememberlist() {
  return &callchasememberlist_;
}

// optional .mt.EmClosedMeeting closedmeeting = 36;
inline bool TMTPerTemplateInfo::has_closedmeeting() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TMTPerTemplateInfo::set_has_closedmeeting() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TMTPerTemplateInfo::clear_has_closedmeeting() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TMTPerTemplateInfo::clear_closedmeeting() {
  closedmeeting_ = 0;
  clear_has_closedmeeting();
}
inline ::mt::EmClosedMeeting TMTPerTemplateInfo::closedmeeting() const {
  return static_cast< ::mt::EmClosedMeeting >(closedmeeting_);
}
inline void TMTPerTemplateInfo::set_closedmeeting(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closedmeeting();
  closedmeeting_ = value;
}

// optional uint32 meetingscale = 37;
inline bool TMTPerTemplateInfo::has_meetingscale() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TMTPerTemplateInfo::set_has_meetingscale() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TMTPerTemplateInfo::clear_has_meetingscale() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TMTPerTemplateInfo::clear_meetingscale() {
  meetingscale_ = 0u;
  clear_has_meetingscale();
}
inline ::google::protobuf::uint32 TMTPerTemplateInfo::meetingscale() const {
  return meetingscale_;
}
inline void TMTPerTemplateInfo::set_meetingscale(::google::protobuf::uint32 value) {
  set_has_meetingscale();
  meetingscale_ = value;
}

// optional uint32 onereforming = 38;
inline bool TMTPerTemplateInfo::has_onereforming() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void TMTPerTemplateInfo::set_has_onereforming() {
  _has_bits_[1] |= 0x00000020u;
}
inline void TMTPerTemplateInfo::clear_has_onereforming() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void TMTPerTemplateInfo::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TMTPerTemplateInfo::onereforming() const {
  return onereforming_;
}
inline void TMTPerTemplateInfo::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional string presetednumber = 39;
inline bool TMTPerTemplateInfo::has_presetednumber() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void TMTPerTemplateInfo::set_has_presetednumber() {
  _has_bits_[1] |= 0x00000040u;
}
inline void TMTPerTemplateInfo::clear_has_presetednumber() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void TMTPerTemplateInfo::clear_presetednumber() {
  if (presetednumber_ != &::google::protobuf::internal::kEmptyString) {
    presetednumber_->clear();
  }
  clear_has_presetednumber();
}
inline const ::std::string& TMTPerTemplateInfo::presetednumber() const {
  return *presetednumber_;
}
inline void TMTPerTemplateInfo::set_presetednumber(const ::std::string& value) {
  set_has_presetednumber();
  if (presetednumber_ == &::google::protobuf::internal::kEmptyString) {
    presetednumber_ = new ::std::string;
  }
  presetednumber_->assign(value);
}
inline void TMTPerTemplateInfo::set_presetednumber(const char* value) {
  set_has_presetednumber();
  if (presetednumber_ == &::google::protobuf::internal::kEmptyString) {
    presetednumber_ = new ::std::string;
  }
  presetednumber_->assign(value);
}
inline void TMTPerTemplateInfo::set_presetednumber(const char* value, size_t size) {
  set_has_presetednumber();
  if (presetednumber_ == &::google::protobuf::internal::kEmptyString) {
    presetednumber_ = new ::std::string;
  }
  presetednumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerTemplateInfo::mutable_presetednumber() {
  set_has_presetednumber();
  if (presetednumber_ == &::google::protobuf::internal::kEmptyString) {
    presetednumber_ = new ::std::string;
  }
  return presetednumber_;
}
inline ::std::string* TMTPerTemplateInfo::release_presetednumber() {
  clear_has_presetednumber();
  if (presetednumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = presetednumber_;
    presetednumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerTemplateInfo::set_allocated_presetednumber(::std::string* presetednumber) {
  if (presetednumber_ != &::google::protobuf::internal::kEmptyString) {
    delete presetednumber_;
  }
  if (presetednumber) {
    set_has_presetednumber();
    presetednumber_ = presetednumber;
  } else {
    clear_has_presetednumber();
    presetednumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 vioceinspiretime = 40;
inline bool TMTPerTemplateInfo::has_vioceinspiretime() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void TMTPerTemplateInfo::set_has_vioceinspiretime() {
  _has_bits_[1] |= 0x00000080u;
}
inline void TMTPerTemplateInfo::clear_has_vioceinspiretime() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void TMTPerTemplateInfo::clear_vioceinspiretime() {
  vioceinspiretime_ = 0u;
  clear_has_vioceinspiretime();
}
inline ::google::protobuf::uint32 TMTPerTemplateInfo::vioceinspiretime() const {
  return vioceinspiretime_;
}
inline void TMTPerTemplateInfo::set_vioceinspiretime(::google::protobuf::uint32 value) {
  set_has_vioceinspiretime();
  vioceinspiretime_ = value;
}

// -------------------------------------------------------------------

// TMTPerTemplate

// optional .mt.TMTTemplateAccount admin = 1;
inline bool TMTPerTemplate::has_admin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPerTemplate::set_has_admin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPerTemplate::clear_has_admin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPerTemplate::clear_admin() {
  if (admin_ != NULL) admin_->::mt::TMTTemplateAccount::Clear();
  clear_has_admin();
}
inline const ::mt::TMTTemplateAccount& TMTPerTemplate::admin() const {
  return admin_ != NULL ? *admin_ : *default_instance_->admin_;
}
inline ::mt::TMTTemplateAccount* TMTPerTemplate::mutable_admin() {
  set_has_admin();
  if (admin_ == NULL) admin_ = new ::mt::TMTTemplateAccount;
  return admin_;
}
inline ::mt::TMTTemplateAccount* TMTPerTemplate::release_admin() {
  clear_has_admin();
  ::mt::TMTTemplateAccount* temp = admin_;
  admin_ = NULL;
  return temp;
}
inline void TMTPerTemplate::set_allocated_admin(::mt::TMTTemplateAccount* admin) {
  delete admin_;
  admin_ = admin;
  if (admin) {
    set_has_admin();
  } else {
    clear_has_admin();
  }
}

// optional uint32 bitrate = 2;
inline bool TMTPerTemplate::has_bitrate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPerTemplate::set_has_bitrate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPerTemplate::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPerTemplate::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTPerTemplate::bitrate() const {
  return bitrate_;
}
inline void TMTPerTemplate::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmRestDualMode dualmode = 3;
inline bool TMTPerTemplate::has_dualmode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPerTemplate::set_has_dualmode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPerTemplate::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPerTemplate::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTPerTemplate::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTPerTemplate::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional string encryptedkey = 4;
inline bool TMTPerTemplate::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPerTemplate::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPerTemplate::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPerTemplate::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTPerTemplate::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTPerTemplate::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPerTemplate::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPerTemplate::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerTemplate::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTPerTemplate::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerTemplate::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 5;
inline bool TMTPerTemplate::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTPerTemplate::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTPerTemplate::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTPerTemplate::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTPerTemplate::duration() const {
  return duration_;
}
inline void TMTPerTemplate::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional .mt.EmEncryptArithmetic encryptedtype = 6;
inline bool TMTPerTemplate::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTPerTemplate::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTPerTemplate::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTPerTemplate::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTPerTemplate::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTPerTemplate::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional bool initmute = 7;
inline bool TMTPerTemplate::has_initmute() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTPerTemplate::set_has_initmute() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTPerTemplate::clear_has_initmute() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTPerTemplate::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTPerTemplate::initmute() const {
  return initmute_;
}
inline void TMTPerTemplate::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional .mt.EmMtOpenMode meetingsafe = 8;
inline bool TMTPerTemplate::has_meetingsafe() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTPerTemplate::set_has_meetingsafe() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTPerTemplate::clear_has_meetingsafe() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTPerTemplate::clear_meetingsafe() {
  meetingsafe_ = 1;
  clear_has_meetingsafe();
}
inline ::mt::EmMtOpenMode TMTPerTemplate::meetingsafe() const {
  return static_cast< ::mt::EmMtOpenMode >(meetingsafe_);
}
inline void TMTPerTemplate::set_meetingsafe(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_meetingsafe();
  meetingsafe_ = value;
}

// optional .mt.EmRestMeetingSafeType meetingtype = 9;
inline bool TMTPerTemplate::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTPerTemplate::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTPerTemplate::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTPerTemplate::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTPerTemplate::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTPerTemplate::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// repeated .mt.TMTTemplateAccount members = 10;
inline int TMTPerTemplate::members_size() const {
  return members_.size();
}
inline void TMTPerTemplate::clear_members() {
  members_.Clear();
}
inline const ::mt::TMTTemplateAccount& TMTPerTemplate::members(int index) const {
  return members_.Get(index);
}
inline ::mt::TMTTemplateAccount* TMTPerTemplate::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::mt::TMTTemplateAccount* TMTPerTemplate::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >&
TMTPerTemplate::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >*
TMTPerTemplate::mutable_members() {
  return &members_;
}

// optional .mt.TMTSetMixInfo mixinfo = 11;
inline bool TMTPerTemplate::has_mixinfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTPerTemplate::set_has_mixinfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTPerTemplate::clear_has_mixinfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTPerTemplate::clear_mixinfo() {
  if (mixinfo_ != NULL) mixinfo_->::mt::TMTSetMixInfo::Clear();
  clear_has_mixinfo();
}
inline const ::mt::TMTSetMixInfo& TMTPerTemplate::mixinfo() const {
  return mixinfo_ != NULL ? *mixinfo_ : *default_instance_->mixinfo_;
}
inline ::mt::TMTSetMixInfo* TMTPerTemplate::mutable_mixinfo() {
  set_has_mixinfo();
  if (mixinfo_ == NULL) mixinfo_ = new ::mt::TMTSetMixInfo;
  return mixinfo_;
}
inline ::mt::TMTSetMixInfo* TMTPerTemplate::release_mixinfo() {
  clear_has_mixinfo();
  ::mt::TMTSetMixInfo* temp = mixinfo_;
  mixinfo_ = NULL;
  return temp;
}
inline void TMTPerTemplate::set_allocated_mixinfo(::mt::TMTSetMixInfo* mixinfo) {
  delete mixinfo_;
  mixinfo_ = mixinfo;
  if (mixinfo) {
    set_has_mixinfo();
  } else {
    clear_has_mixinfo();
  }
}

// optional string name = 12;
inline bool TMTPerTemplate::has_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTPerTemplate::set_has_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTPerTemplate::clear_has_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTPerTemplate::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTPerTemplate::name() const {
  return *name_;
}
inline void TMTPerTemplate::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPerTemplate::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPerTemplate::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerTemplate::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTPerTemplate::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerTemplate::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 13;
inline bool TMTPerTemplate::has_password() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTPerTemplate::set_has_password() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTPerTemplate::clear_has_password() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTPerTemplate::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTPerTemplate::password() const {
  return *password_;
}
inline void TMTPerTemplate::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTPerTemplate::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTPerTemplate::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerTemplate::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTPerTemplate::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerTemplate::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool publicmeeting = 14;
inline bool TMTPerTemplate::has_publicmeeting() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTPerTemplate::set_has_publicmeeting() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTPerTemplate::clear_has_publicmeeting() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTPerTemplate::clear_publicmeeting() {
  publicmeeting_ = false;
  clear_has_publicmeeting();
}
inline bool TMTPerTemplate::publicmeeting() const {
  return publicmeeting_;
}
inline void TMTPerTemplate::set_publicmeeting(bool value) {
  set_has_publicmeeting();
  publicmeeting_ = value;
}

// optional .mt.EmMtResolution resolution = 15;
inline bool TMTPerTemplate::has_resolution() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTPerTemplate::set_has_resolution() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTPerTemplate::clear_has_resolution() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTPerTemplate::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::mt::EmMtResolution TMTPerTemplate::resolution() const {
  return static_cast< ::mt::EmMtResolution >(resolution_);
}
inline void TMTPerTemplate::set_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_resolution();
  resolution_ = value;
}

// optional .mt.TMTTemplateRecord record = 16;
inline bool TMTPerTemplate::has_record() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTPerTemplate::set_has_record() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTPerTemplate::clear_has_record() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTPerTemplate::clear_record() {
  if (record_ != NULL) record_->::mt::TMTTemplateRecord::Clear();
  clear_has_record();
}
inline const ::mt::TMTTemplateRecord& TMTPerTemplate::record() const {
  return record_ != NULL ? *record_ : *default_instance_->record_;
}
inline ::mt::TMTTemplateRecord* TMTPerTemplate::mutable_record() {
  set_has_record();
  if (record_ == NULL) record_ = new ::mt::TMTTemplateRecord;
  return record_;
}
inline ::mt::TMTTemplateRecord* TMTPerTemplate::release_record() {
  clear_has_record();
  ::mt::TMTTemplateRecord* temp = record_;
  record_ = NULL;
  return temp;
}
inline void TMTPerTemplate::set_allocated_record(::mt::TMTTemplateRecord* record) {
  delete record_;
  record_ = record;
  if (record) {
    set_has_record();
  } else {
    clear_has_record();
  }
}

// optional .mt.TMTTemplateSatellite satellite = 17;
inline bool TMTPerTemplate::has_satellite() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTPerTemplate::set_has_satellite() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTPerTemplate::clear_has_satellite() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTPerTemplate::clear_satellite() {
  if (satellite_ != NULL) satellite_->::mt::TMTTemplateSatellite::Clear();
  clear_has_satellite();
}
inline const ::mt::TMTTemplateSatellite& TMTPerTemplate::satellite() const {
  return satellite_ != NULL ? *satellite_ : *default_instance_->satellite_;
}
inline ::mt::TMTTemplateSatellite* TMTPerTemplate::mutable_satellite() {
  set_has_satellite();
  if (satellite_ == NULL) satellite_ = new ::mt::TMTTemplateSatellite;
  return satellite_;
}
inline ::mt::TMTTemplateSatellite* TMTPerTemplate::release_satellite() {
  clear_has_satellite();
  ::mt::TMTTemplateSatellite* temp = satellite_;
  satellite_ = NULL;
  return temp;
}
inline void TMTPerTemplate::set_allocated_satellite(::mt::TMTTemplateSatellite* satellite) {
  delete satellite_;
  satellite_ = satellite;
  if (satellite) {
    set_has_satellite();
  } else {
    clear_has_satellite();
  }
}

// optional .mt.TMTTemplateAccount speaker = 18;
inline bool TMTPerTemplate::has_speaker() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTPerTemplate::set_has_speaker() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTPerTemplate::clear_has_speaker() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTPerTemplate::clear_speaker() {
  if (speaker_ != NULL) speaker_->::mt::TMTTemplateAccount::Clear();
  clear_has_speaker();
}
inline const ::mt::TMTTemplateAccount& TMTPerTemplate::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::mt::TMTTemplateAccount* TMTPerTemplate::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::mt::TMTTemplateAccount;
  return speaker_;
}
inline ::mt::TMTTemplateAccount* TMTPerTemplate::release_speaker() {
  clear_has_speaker();
  ::mt::TMTTemplateAccount* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void TMTPerTemplate::set_allocated_speaker(::mt::TMTTemplateAccount* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional uint32 templateid = 19;
inline bool TMTPerTemplate::has_templateid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTPerTemplate::set_has_templateid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTPerTemplate::clear_has_templateid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTPerTemplate::clear_templateid() {
  templateid_ = 0u;
  clear_has_templateid();
}
inline ::google::protobuf::uint32 TMTPerTemplate::templateid() const {
  return templateid_;
}
inline void TMTPerTemplate::set_templateid(::google::protobuf::uint32 value) {
  set_has_templateid();
  templateid_ = value;
}

// repeated .mt.TMTVideoFormatList videoformatlist = 20;
inline int TMTPerTemplate::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTPerTemplate::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTPerTemplate::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTPerTemplate::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTPerTemplate::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTPerTemplate::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTPerTemplate::mutable_videoformatlist() {
  return &videoformatlist_;
}

// repeated .mt.TMTAudioFormatList audioformatlist = 21;
inline int TMTPerTemplate::audioformatlist_size() const {
  return audioformatlist_.size();
}
inline void TMTPerTemplate::clear_audioformatlist() {
  audioformatlist_.Clear();
}
inline const ::mt::TMTAudioFormatList& TMTPerTemplate::audioformatlist(int index) const {
  return audioformatlist_.Get(index);
}
inline ::mt::TMTAudioFormatList* TMTPerTemplate::mutable_audioformatlist(int index) {
  return audioformatlist_.Mutable(index);
}
inline ::mt::TMTAudioFormatList* TMTPerTemplate::add_audioformatlist() {
  return audioformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
TMTPerTemplate::audioformatlist() const {
  return audioformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
TMTPerTemplate::mutable_audioformatlist() {
  return &audioformatlist_;
}

// repeated .mt.TMTDualFormatList dualformatlist = 22;
inline int TMTPerTemplate::dualformatlist_size() const {
  return dualformatlist_.size();
}
inline void TMTPerTemplate::clear_dualformatlist() {
  dualformatlist_.Clear();
}
inline const ::mt::TMTDualFormatList& TMTPerTemplate::dualformatlist(int index) const {
  return dualformatlist_.Get(index);
}
inline ::mt::TMTDualFormatList* TMTPerTemplate::mutable_dualformatlist(int index) {
  return dualformatlist_.Mutable(index);
}
inline ::mt::TMTDualFormatList* TMTPerTemplate::add_dualformatlist() {
  return dualformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
TMTPerTemplate::dualformatlist() const {
  return dualformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
TMTPerTemplate::mutable_dualformatlist() {
  return &dualformatlist_;
}

// repeated .mt.TMTTemplateAccount viplist = 23;
inline int TMTPerTemplate::viplist_size() const {
  return viplist_.size();
}
inline void TMTPerTemplate::clear_viplist() {
  viplist_.Clear();
}
inline const ::mt::TMTTemplateAccount& TMTPerTemplate::viplist(int index) const {
  return viplist_.Get(index);
}
inline ::mt::TMTTemplateAccount* TMTPerTemplate::mutable_viplist(int index) {
  return viplist_.Mutable(index);
}
inline ::mt::TMTTemplateAccount* TMTPerTemplate::add_viplist() {
  return viplist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >&
TMTPerTemplate::viplist() const {
  return viplist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateAccount >*
TMTPerTemplate::mutable_viplist() {
  return &viplist_;
}

// optional .mt.EmClosedMeeting closedmeeting = 24;
inline bool TMTPerTemplate::has_closedmeeting() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTPerTemplate::set_has_closedmeeting() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTPerTemplate::clear_has_closedmeeting() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTPerTemplate::clear_closedmeeting() {
  closedmeeting_ = 0;
  clear_has_closedmeeting();
}
inline ::mt::EmClosedMeeting TMTPerTemplate::closedmeeting() const {
  return static_cast< ::mt::EmClosedMeeting >(closedmeeting_);
}
inline void TMTPerTemplate::set_closedmeeting(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closedmeeting();
  closedmeeting_ = value;
}

// optional .mt.TMTTemplateVmp vmp = 25;
inline bool TMTPerTemplate::has_vmp() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTPerTemplate::set_has_vmp() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTPerTemplate::clear_has_vmp() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTPerTemplate::clear_vmp() {
  if (vmp_ != NULL) vmp_->::mt::TMTTemplateVmp::Clear();
  clear_has_vmp();
}
inline const ::mt::TMTTemplateVmp& TMTPerTemplate::vmp() const {
  return vmp_ != NULL ? *vmp_ : *default_instance_->vmp_;
}
inline ::mt::TMTTemplateVmp* TMTPerTemplate::mutable_vmp() {
  set_has_vmp();
  if (vmp_ == NULL) vmp_ = new ::mt::TMTTemplateVmp;
  return vmp_;
}
inline ::mt::TMTTemplateVmp* TMTPerTemplate::release_vmp() {
  clear_has_vmp();
  ::mt::TMTTemplateVmp* temp = vmp_;
  vmp_ = NULL;
  return temp;
}
inline void TMTPerTemplate::set_allocated_vmp(::mt::TMTTemplateVmp* vmp) {
  delete vmp_;
  vmp_ = vmp;
  if (vmp) {
    set_has_vmp();
  } else {
    clear_has_vmp();
  }
}

// optional uint32 meetingscale = 26;
inline bool TMTPerTemplate::has_meetingscale() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMTPerTemplate::set_has_meetingscale() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMTPerTemplate::clear_has_meetingscale() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMTPerTemplate::clear_meetingscale() {
  meetingscale_ = 0u;
  clear_has_meetingscale();
}
inline ::google::protobuf::uint32 TMTPerTemplate::meetingscale() const {
  return meetingscale_;
}
inline void TMTPerTemplate::set_meetingscale(::google::protobuf::uint32 value) {
  set_has_meetingscale();
  meetingscale_ = value;
}

// optional uint32 onereforming = 27;
inline bool TMTPerTemplate::has_onereforming() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMTPerTemplate::set_has_onereforming() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMTPerTemplate::clear_has_onereforming() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMTPerTemplate::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TMTPerTemplate::onereforming() const {
  return onereforming_;
}
inline void TMTPerTemplate::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional bool voiceinspireenable = 28;
inline bool TMTPerTemplate::has_voiceinspireenable() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTPerTemplate::set_has_voiceinspireenable() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTPerTemplate::clear_has_voiceinspireenable() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTPerTemplate::clear_voiceinspireenable() {
  voiceinspireenable_ = false;
  clear_has_voiceinspireenable();
}
inline bool TMTPerTemplate::voiceinspireenable() const {
  return voiceinspireenable_;
}
inline void TMTPerTemplate::set_voiceinspireenable(bool value) {
  set_has_voiceinspireenable();
  voiceinspireenable_ = value;
}

// optional uint32 vioceinspiretime = 29;
inline bool TMTPerTemplate::has_vioceinspiretime() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMTPerTemplate::set_has_vioceinspiretime() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMTPerTemplate::clear_has_vioceinspiretime() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMTPerTemplate::clear_vioceinspiretime() {
  vioceinspiretime_ = 0u;
  clear_has_vioceinspiretime();
}
inline ::google::protobuf::uint32 TMTPerTemplate::vioceinspiretime() const {
  return vioceinspiretime_;
}
inline void TMTPerTemplate::set_vioceinspiretime(::google::protobuf::uint32 value) {
  set_has_vioceinspiretime();
  vioceinspiretime_ = value;
}

// -------------------------------------------------------------------

// TMTGetPubTemplateList

// optional uint32 start = 1;
inline bool TMTGetPubTemplateList::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTGetPubTemplateList::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTGetPubTemplateList::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTGetPubTemplateList::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTGetPubTemplateList::start() const {
  return start_;
}
inline void TMTGetPubTemplateList::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 2;
inline bool TMTGetPubTemplateList::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTGetPubTemplateList::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTGetPubTemplateList::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTGetPubTemplateList::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTGetPubTemplateList::count() const {
  return count_;
}
inline void TMTGetPubTemplateList::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 3;
inline bool TMTGetPubTemplateList::has_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTGetPubTemplateList::set_has_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTGetPubTemplateList::clear_has_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTGetPubTemplateList::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTGetPubTemplateList::order() const {
  return order_;
}
inline void TMTGetPubTemplateList::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// -------------------------------------------------------------------

// TMTPubTemplateSimpleInfo

// optional string templatekey = 1;
inline bool TMTPubTemplateSimpleInfo::has_templatekey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPubTemplateSimpleInfo::set_has_templatekey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPubTemplateSimpleInfo::clear_has_templatekey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPubTemplateSimpleInfo::clear_templatekey() {
  if (templatekey_ != &::google::protobuf::internal::kEmptyString) {
    templatekey_->clear();
  }
  clear_has_templatekey();
}
inline const ::std::string& TMTPubTemplateSimpleInfo::templatekey() const {
  return *templatekey_;
}
inline void TMTPubTemplateSimpleInfo::set_templatekey(const ::std::string& value) {
  set_has_templatekey();
  if (templatekey_ == &::google::protobuf::internal::kEmptyString) {
    templatekey_ = new ::std::string;
  }
  templatekey_->assign(value);
}
inline void TMTPubTemplateSimpleInfo::set_templatekey(const char* value) {
  set_has_templatekey();
  if (templatekey_ == &::google::protobuf::internal::kEmptyString) {
    templatekey_ = new ::std::string;
  }
  templatekey_->assign(value);
}
inline void TMTPubTemplateSimpleInfo::set_templatekey(const char* value, size_t size) {
  set_has_templatekey();
  if (templatekey_ == &::google::protobuf::internal::kEmptyString) {
    templatekey_ = new ::std::string;
  }
  templatekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPubTemplateSimpleInfo::mutable_templatekey() {
  set_has_templatekey();
  if (templatekey_ == &::google::protobuf::internal::kEmptyString) {
    templatekey_ = new ::std::string;
  }
  return templatekey_;
}
inline ::std::string* TMTPubTemplateSimpleInfo::release_templatekey() {
  clear_has_templatekey();
  if (templatekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templatekey_;
    templatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPubTemplateSimpleInfo::set_allocated_templatekey(::std::string* templatekey) {
  if (templatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete templatekey_;
  }
  if (templatekey) {
    set_has_templatekey();
    templatekey_ = templatekey;
  } else {
    clear_has_templatekey();
    templatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TMTPubTemplateSimpleInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPubTemplateSimpleInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPubTemplateSimpleInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPubTemplateSimpleInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTPubTemplateSimpleInfo::name() const {
  return *name_;
}
inline void TMTPubTemplateSimpleInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPubTemplateSimpleInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPubTemplateSimpleInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPubTemplateSimpleInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTPubTemplateSimpleInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPubTemplateSimpleInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 3;
inline bool TMTPubTemplateSimpleInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPubTemplateSimpleInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPubTemplateSimpleInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPubTemplateSimpleInfo::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTPubTemplateSimpleInfo::duration() const {
  return duration_;
}
inline void TMTPubTemplateSimpleInfo::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 bitrate = 4;
inline bool TMTPubTemplateSimpleInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPubTemplateSimpleInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPubTemplateSimpleInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPubTemplateSimpleInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTPubTemplateSimpleInfo::bitrate() const {
  return bitrate_;
}
inline void TMTPubTemplateSimpleInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmMtResolution resolution = 5;
inline bool TMTPubTemplateSimpleInfo::has_resolution() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTPubTemplateSimpleInfo::set_has_resolution() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTPubTemplateSimpleInfo::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTPubTemplateSimpleInfo::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::mt::EmMtResolution TMTPubTemplateSimpleInfo::resolution() const {
  return static_cast< ::mt::EmMtResolution >(resolution_);
}
inline void TMTPubTemplateSimpleInfo::set_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_resolution();
  resolution_ = value;
}

// -------------------------------------------------------------------

// TMTPubTemplateList

// repeated .mt.TMTPubTemplateSimpleInfo pubtemplatesimpleinfo = 1;
inline int TMTPubTemplateList::pubtemplatesimpleinfo_size() const {
  return pubtemplatesimpleinfo_.size();
}
inline void TMTPubTemplateList::clear_pubtemplatesimpleinfo() {
  pubtemplatesimpleinfo_.Clear();
}
inline const ::mt::TMTPubTemplateSimpleInfo& TMTPubTemplateList::pubtemplatesimpleinfo(int index) const {
  return pubtemplatesimpleinfo_.Get(index);
}
inline ::mt::TMTPubTemplateSimpleInfo* TMTPubTemplateList::mutable_pubtemplatesimpleinfo(int index) {
  return pubtemplatesimpleinfo_.Mutable(index);
}
inline ::mt::TMTPubTemplateSimpleInfo* TMTPubTemplateList::add_pubtemplatesimpleinfo() {
  return pubtemplatesimpleinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPubTemplateSimpleInfo >&
TMTPubTemplateList::pubtemplatesimpleinfo() const {
  return pubtemplatesimpleinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPubTemplateSimpleInfo >*
TMTPubTemplateList::mutable_pubtemplatesimpleinfo() {
  return &pubtemplatesimpleinfo_;
}

// -------------------------------------------------------------------

// TMTPubTemplateInfo

// optional string templatekey = 1;
inline bool TMTPubTemplateInfo::has_templatekey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPubTemplateInfo::set_has_templatekey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPubTemplateInfo::clear_has_templatekey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPubTemplateInfo::clear_templatekey() {
  if (templatekey_ != &::google::protobuf::internal::kEmptyString) {
    templatekey_->clear();
  }
  clear_has_templatekey();
}
inline const ::std::string& TMTPubTemplateInfo::templatekey() const {
  return *templatekey_;
}
inline void TMTPubTemplateInfo::set_templatekey(const ::std::string& value) {
  set_has_templatekey();
  if (templatekey_ == &::google::protobuf::internal::kEmptyString) {
    templatekey_ = new ::std::string;
  }
  templatekey_->assign(value);
}
inline void TMTPubTemplateInfo::set_templatekey(const char* value) {
  set_has_templatekey();
  if (templatekey_ == &::google::protobuf::internal::kEmptyString) {
    templatekey_ = new ::std::string;
  }
  templatekey_->assign(value);
}
inline void TMTPubTemplateInfo::set_templatekey(const char* value, size_t size) {
  set_has_templatekey();
  if (templatekey_ == &::google::protobuf::internal::kEmptyString) {
    templatekey_ = new ::std::string;
  }
  templatekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPubTemplateInfo::mutable_templatekey() {
  set_has_templatekey();
  if (templatekey_ == &::google::protobuf::internal::kEmptyString) {
    templatekey_ = new ::std::string;
  }
  return templatekey_;
}
inline ::std::string* TMTPubTemplateInfo::release_templatekey() {
  clear_has_templatekey();
  if (templatekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templatekey_;
    templatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPubTemplateInfo::set_allocated_templatekey(::std::string* templatekey) {
  if (templatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete templatekey_;
  }
  if (templatekey) {
    set_has_templatekey();
    templatekey_ = templatekey;
  } else {
    clear_has_templatekey();
    templatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TMTPubTemplateInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPubTemplateInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPubTemplateInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPubTemplateInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTPubTemplateInfo::name() const {
  return *name_;
}
inline void TMTPubTemplateInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPubTemplateInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPubTemplateInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPubTemplateInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTPubTemplateInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPubTemplateInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 3;
inline bool TMTPubTemplateInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPubTemplateInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPubTemplateInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPubTemplateInfo::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTPubTemplateInfo::duration() const {
  return duration_;
}
inline void TMTPubTemplateInfo::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 bitrate = 4;
inline bool TMTPubTemplateInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPubTemplateInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPubTemplateInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPubTemplateInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTPubTemplateInfo::bitrate() const {
  return bitrate_;
}
inline void TMTPubTemplateInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmMtOpenMode meetingsafe = 5;
inline bool TMTPubTemplateInfo::has_meetingsafe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTPubTemplateInfo::set_has_meetingsafe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTPubTemplateInfo::clear_has_meetingsafe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTPubTemplateInfo::clear_meetingsafe() {
  meetingsafe_ = 1;
  clear_has_meetingsafe();
}
inline ::mt::EmMtOpenMode TMTPubTemplateInfo::meetingsafe() const {
  return static_cast< ::mt::EmMtOpenMode >(meetingsafe_);
}
inline void TMTPubTemplateInfo::set_meetingsafe(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_meetingsafe();
  meetingsafe_ = value;
}

// optional string password = 6;
inline bool TMTPubTemplateInfo::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTPubTemplateInfo::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTPubTemplateInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTPubTemplateInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTPubTemplateInfo::password() const {
  return *password_;
}
inline void TMTPubTemplateInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTPubTemplateInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTPubTemplateInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPubTemplateInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTPubTemplateInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPubTemplateInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmEncryptArithmetic encryptedtype = 7;
inline bool TMTPubTemplateInfo::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTPubTemplateInfo::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTPubTemplateInfo::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTPubTemplateInfo::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTPubTemplateInfo::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTPubTemplateInfo::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional string encryptedkey = 8;
inline bool TMTPubTemplateInfo::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTPubTemplateInfo::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTPubTemplateInfo::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTPubTemplateInfo::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTPubTemplateInfo::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTPubTemplateInfo::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPubTemplateInfo::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPubTemplateInfo::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPubTemplateInfo::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTPubTemplateInfo::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPubTemplateInfo::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestMeetingSafeType meetingtype = 9;
inline bool TMTPubTemplateInfo::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTPubTemplateInfo::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTPubTemplateInfo::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTPubTemplateInfo::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTPubTemplateInfo::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTPubTemplateInfo::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional .mt.TMTTemplateSatellite satellite = 10;
inline bool TMTPubTemplateInfo::has_satellite() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTPubTemplateInfo::set_has_satellite() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTPubTemplateInfo::clear_has_satellite() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTPubTemplateInfo::clear_satellite() {
  if (satellite_ != NULL) satellite_->::mt::TMTTemplateSatellite::Clear();
  clear_has_satellite();
}
inline const ::mt::TMTTemplateSatellite& TMTPubTemplateInfo::satellite() const {
  return satellite_ != NULL ? *satellite_ : *default_instance_->satellite_;
}
inline ::mt::TMTTemplateSatellite* TMTPubTemplateInfo::mutable_satellite() {
  set_has_satellite();
  if (satellite_ == NULL) satellite_ = new ::mt::TMTTemplateSatellite;
  return satellite_;
}
inline ::mt::TMTTemplateSatellite* TMTPubTemplateInfo::release_satellite() {
  clear_has_satellite();
  ::mt::TMTTemplateSatellite* temp = satellite_;
  satellite_ = NULL;
  return temp;
}
inline void TMTPubTemplateInfo::set_allocated_satellite(::mt::TMTTemplateSatellite* satellite) {
  delete satellite_;
  satellite_ = satellite;
  if (satellite) {
    set_has_satellite();
  } else {
    clear_has_satellite();
  }
}

// optional bool publicmeeting = 11;
inline bool TMTPubTemplateInfo::has_publicmeeting() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTPubTemplateInfo::set_has_publicmeeting() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTPubTemplateInfo::clear_has_publicmeeting() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTPubTemplateInfo::clear_publicmeeting() {
  publicmeeting_ = false;
  clear_has_publicmeeting();
}
inline bool TMTPubTemplateInfo::publicmeeting() const {
  return publicmeeting_;
}
inline void TMTPubTemplateInfo::set_publicmeeting(bool value) {
  set_has_publicmeeting();
  publicmeeting_ = value;
}

// optional .mt.EmMtMixType mixmode = 12;
inline bool TMTPubTemplateInfo::has_mixmode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTPubTemplateInfo::set_has_mixmode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTPubTemplateInfo::clear_has_mixmode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTPubTemplateInfo::clear_mixmode() {
  mixmode_ = 0;
  clear_has_mixmode();
}
inline ::mt::EmMtMixType TMTPubTemplateInfo::mixmode() const {
  return static_cast< ::mt::EmMtMixType >(mixmode_);
}
inline void TMTPubTemplateInfo::set_mixmode(::mt::EmMtMixType value) {
  assert(::mt::EmMtMixType_IsValid(value));
  set_has_mixmode();
  mixmode_ = value;
}

// repeated .mt.TMTVideoFormatList videoformatlist = 13;
inline int TMTPubTemplateInfo::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTPubTemplateInfo::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTPubTemplateInfo::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTPubTemplateInfo::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTPubTemplateInfo::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTPubTemplateInfo::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTPubTemplateInfo::mutable_videoformatlist() {
  return &videoformatlist_;
}

// repeated .mt.TMTAudioFormatList audioformatlist = 14;
inline int TMTPubTemplateInfo::audioformatlist_size() const {
  return audioformatlist_.size();
}
inline void TMTPubTemplateInfo::clear_audioformatlist() {
  audioformatlist_.Clear();
}
inline const ::mt::TMTAudioFormatList& TMTPubTemplateInfo::audioformatlist(int index) const {
  return audioformatlist_.Get(index);
}
inline ::mt::TMTAudioFormatList* TMTPubTemplateInfo::mutable_audioformatlist(int index) {
  return audioformatlist_.Mutable(index);
}
inline ::mt::TMTAudioFormatList* TMTPubTemplateInfo::add_audioformatlist() {
  return audioformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
TMTPubTemplateInfo::audioformatlist() const {
  return audioformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
TMTPubTemplateInfo::mutable_audioformatlist() {
  return &audioformatlist_;
}

// optional uint32 calltimes = 15;
inline bool TMTPubTemplateInfo::has_calltimes() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_calltimes() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTPubTemplateInfo::clear_has_calltimes() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTPubTemplateInfo::clear_calltimes() {
  calltimes_ = 0u;
  clear_has_calltimes();
}
inline ::google::protobuf::uint32 TMTPubTemplateInfo::calltimes() const {
  return calltimes_;
}
inline void TMTPubTemplateInfo::set_calltimes(::google::protobuf::uint32 value) {
  set_has_calltimes();
  calltimes_ = value;
}

// optional uint32 callinterval = 16;
inline bool TMTPubTemplateInfo::has_callinterval() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_callinterval() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTPubTemplateInfo::clear_has_callinterval() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTPubTemplateInfo::clear_callinterval() {
  callinterval_ = 0u;
  clear_has_callinterval();
}
inline ::google::protobuf::uint32 TMTPubTemplateInfo::callinterval() const {
  return callinterval_;
}
inline void TMTPubTemplateInfo::set_callinterval(::google::protobuf::uint32 value) {
  set_has_callinterval();
  callinterval_ = value;
}

// optional bool initmute = 17;
inline bool TMTPubTemplateInfo::has_initmute() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_initmute() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTPubTemplateInfo::clear_has_initmute() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTPubTemplateInfo::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTPubTemplateInfo::initmute() const {
  return initmute_;
}
inline void TMTPubTemplateInfo::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional .mt.EmRestVideoQuality videoquality = 18;
inline bool TMTPubTemplateInfo::has_videoquality() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_videoquality() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTPubTemplateInfo::clear_has_videoquality() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTPubTemplateInfo::clear_videoquality() {
  videoquality_ = 0;
  clear_has_videoquality();
}
inline ::mt::EmRestVideoQuality TMTPubTemplateInfo::videoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(videoquality_);
}
inline void TMTPubTemplateInfo::set_videoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_videoquality();
  videoquality_ = value;
}

// optional .mt.EmRestDualMode dualmode = 19;
inline bool TMTPubTemplateInfo::has_dualmode() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_dualmode() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTPubTemplateInfo::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTPubTemplateInfo::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTPubTemplateInfo::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTPubTemplateInfo::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool voiceinspireenable = 20;
inline bool TMTPubTemplateInfo::has_voiceinspireenable() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_voiceinspireenable() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTPubTemplateInfo::clear_has_voiceinspireenable() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTPubTemplateInfo::clear_voiceinspireenable() {
  voiceinspireenable_ = false;
  clear_has_voiceinspireenable();
}
inline bool TMTPubTemplateInfo::voiceinspireenable() const {
  return voiceinspireenable_;
}
inline void TMTPubTemplateInfo::set_voiceinspireenable(bool value) {
  set_has_voiceinspireenable();
  voiceinspireenable_ = value;
}

// optional .mt.EmRestCascadeMode cascademode = 21;
inline bool TMTPubTemplateInfo::has_cascademode() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_cascademode() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTPubTemplateInfo::clear_has_cascademode() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTPubTemplateInfo::clear_cascademode() {
  cascademode_ = 0;
  clear_has_cascademode();
}
inline ::mt::EmRestCascadeMode TMTPubTemplateInfo::cascademode() const {
  return static_cast< ::mt::EmRestCascadeMode >(cascademode_);
}
inline void TMTPubTemplateInfo::set_cascademode(::mt::EmRestCascadeMode value) {
  assert(::mt::EmRestCascadeMode_IsValid(value));
  set_has_cascademode();
  cascademode_ = value;
}

// optional bool cascadeupload = 22;
inline bool TMTPubTemplateInfo::has_cascadeupload() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_cascadeupload() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTPubTemplateInfo::clear_has_cascadeupload() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTPubTemplateInfo::clear_cascadeupload() {
  cascadeupload_ = false;
  clear_has_cascadeupload();
}
inline bool TMTPubTemplateInfo::cascadeupload() const {
  return cascadeupload_;
}
inline void TMTPubTemplateInfo::set_cascadeupload(bool value) {
  set_has_cascadeupload();
  cascadeupload_ = value;
}

// optional bool cascadereturn = 23;
inline bool TMTPubTemplateInfo::has_cascadereturn() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_cascadereturn() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTPubTemplateInfo::clear_has_cascadereturn() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTPubTemplateInfo::clear_cascadereturn() {
  cascadereturn_ = false;
  clear_has_cascadereturn();
}
inline bool TMTPubTemplateInfo::cascadereturn() const {
  return cascadereturn_;
}
inline void TMTPubTemplateInfo::set_cascadereturn(bool value) {
  set_has_cascadereturn();
  cascadereturn_ = value;
}

// optional uint32 cascadereturnpara = 24;
inline bool TMTPubTemplateInfo::has_cascadereturnpara() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_cascadereturnpara() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTPubTemplateInfo::clear_has_cascadereturnpara() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTPubTemplateInfo::clear_cascadereturnpara() {
  cascadereturnpara_ = 0u;
  clear_has_cascadereturnpara();
}
inline ::google::protobuf::uint32 TMTPubTemplateInfo::cascadereturnpara() const {
  return cascadereturnpara_;
}
inline void TMTPubTemplateInfo::set_cascadereturnpara(::google::protobuf::uint32 value) {
  set_has_cascadereturnpara();
  cascadereturnpara_ = value;
}

// optional .mt.TMTTemplateRecord record = 25;
inline bool TMTPubTemplateInfo::has_record() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_record() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTPubTemplateInfo::clear_has_record() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTPubTemplateInfo::clear_record() {
  if (record_ != NULL) record_->::mt::TMTTemplateRecord::Clear();
  clear_has_record();
}
inline const ::mt::TMTTemplateRecord& TMTPubTemplateInfo::record() const {
  return record_ != NULL ? *record_ : *default_instance_->record_;
}
inline ::mt::TMTTemplateRecord* TMTPubTemplateInfo::mutable_record() {
  set_has_record();
  if (record_ == NULL) record_ = new ::mt::TMTTemplateRecord;
  return record_;
}
inline ::mt::TMTTemplateRecord* TMTPubTemplateInfo::release_record() {
  clear_has_record();
  ::mt::TMTTemplateRecord* temp = record_;
  record_ = NULL;
  return temp;
}
inline void TMTPubTemplateInfo::set_allocated_record(::mt::TMTTemplateRecord* record) {
  delete record_;
  record_ = record;
  if (record) {
    set_has_record();
  } else {
    clear_has_record();
  }
}

// optional .mt.TMTTemplateMultiCast multicast = 26;
inline bool TMTPubTemplateInfo::has_multicast() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_multicast() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMTPubTemplateInfo::clear_has_multicast() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMTPubTemplateInfo::clear_multicast() {
  if (multicast_ != NULL) multicast_->::mt::TMTTemplateMultiCast::Clear();
  clear_has_multicast();
}
inline const ::mt::TMTTemplateMultiCast& TMTPubTemplateInfo::multicast() const {
  return multicast_ != NULL ? *multicast_ : *default_instance_->multicast_;
}
inline ::mt::TMTTemplateMultiCast* TMTPubTemplateInfo::mutable_multicast() {
  set_has_multicast();
  if (multicast_ == NULL) multicast_ = new ::mt::TMTTemplateMultiCast;
  return multicast_;
}
inline ::mt::TMTTemplateMultiCast* TMTPubTemplateInfo::release_multicast() {
  clear_has_multicast();
  ::mt::TMTTemplateMultiCast* temp = multicast_;
  multicast_ = NULL;
  return temp;
}
inline void TMTPubTemplateInfo::set_allocated_multicast(::mt::TMTTemplateMultiCast* multicast) {
  delete multicast_;
  multicast_ = multicast;
  if (multicast) {
    set_has_multicast();
  } else {
    clear_has_multicast();
  }
}

// repeated .mt.TMTDualFormatList dualformatlist = 27;
inline int TMTPubTemplateInfo::dualformatlist_size() const {
  return dualformatlist_.size();
}
inline void TMTPubTemplateInfo::clear_dualformatlist() {
  dualformatlist_.Clear();
}
inline const ::mt::TMTDualFormatList& TMTPubTemplateInfo::dualformatlist(int index) const {
  return dualformatlist_.Get(index);
}
inline ::mt::TMTDualFormatList* TMTPubTemplateInfo::mutable_dualformatlist(int index) {
  return dualformatlist_.Mutable(index);
}
inline ::mt::TMTDualFormatList* TMTPubTemplateInfo::add_dualformatlist() {
  return dualformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
TMTPubTemplateInfo::dualformatlist() const {
  return dualformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
TMTPubTemplateInfo::mutable_dualformatlist() {
  return &dualformatlist_;
}

// optional .mt.EmClosedMeeting closedmeeting = 28;
inline bool TMTPubTemplateInfo::has_closedmeeting() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_closedmeeting() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTPubTemplateInfo::clear_has_closedmeeting() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTPubTemplateInfo::clear_closedmeeting() {
  closedmeeting_ = 0;
  clear_has_closedmeeting();
}
inline ::mt::EmClosedMeeting TMTPubTemplateInfo::closedmeeting() const {
  return static_cast< ::mt::EmClosedMeeting >(closedmeeting_);
}
inline void TMTPubTemplateInfo::set_closedmeeting(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closedmeeting();
  closedmeeting_ = value;
}

// optional uint32 voiceinspiretime = 29;
inline bool TMTPubTemplateInfo::has_voiceinspiretime() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_voiceinspiretime() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMTPubTemplateInfo::clear_has_voiceinspiretime() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMTPubTemplateInfo::clear_voiceinspiretime() {
  voiceinspiretime_ = 0u;
  clear_has_voiceinspiretime();
}
inline ::google::protobuf::uint32 TMTPubTemplateInfo::voiceinspiretime() const {
  return voiceinspiretime_;
}
inline void TMTPubTemplateInfo::set_voiceinspiretime(::google::protobuf::uint32 value) {
  set_has_voiceinspiretime();
  voiceinspiretime_ = value;
}

// optional uint32 meetingscale = 30;
inline bool TMTPubTemplateInfo::has_meetingscale() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_meetingscale() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMTPubTemplateInfo::clear_has_meetingscale() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMTPubTemplateInfo::clear_meetingscale() {
  meetingscale_ = 0u;
  clear_has_meetingscale();
}
inline ::google::protobuf::uint32 TMTPubTemplateInfo::meetingscale() const {
  return meetingscale_;
}
inline void TMTPubTemplateInfo::set_meetingscale(::google::protobuf::uint32 value) {
  set_has_meetingscale();
  meetingscale_ = value;
}

// optional bool onereforming = 31;
inline bool TMTPubTemplateInfo::has_onereforming() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TMTPubTemplateInfo::set_has_onereforming() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TMTPubTemplateInfo::clear_has_onereforming() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TMTPubTemplateInfo::clear_onereforming() {
  onereforming_ = false;
  clear_has_onereforming();
}
inline bool TMTPubTemplateInfo::onereforming() const {
  return onereforming_;
}
inline void TMTPubTemplateInfo::set_onereforming(bool value) {
  set_has_onereforming();
  onereforming_ = value;
}

// -------------------------------------------------------------------

// TMTPubTemplate

// optional string name = 1;
inline bool TMTPubTemplate::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPubTemplate::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPubTemplate::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPubTemplate::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTPubTemplate::name() const {
  return *name_;
}
inline void TMTPubTemplate::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPubTemplate::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPubTemplate::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPubTemplate::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTPubTemplate::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPubTemplate::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestMeetingSafeType meetingtype = 2;
inline bool TMTPubTemplate::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPubTemplate::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPubTemplate::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPubTemplate::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTPubTemplate::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTPubTemplate::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional uint32 bitrate = 3;
inline bool TMTPubTemplate::has_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPubTemplate::set_has_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPubTemplate::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPubTemplate::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTPubTemplate::bitrate() const {
  return bitrate_;
}
inline void TMTPubTemplate::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmMtResolution resolution = 4;
inline bool TMTPubTemplate::has_resolution() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPubTemplate::set_has_resolution() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPubTemplate::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPubTemplate::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::mt::EmMtResolution TMTPubTemplate::resolution() const {
  return static_cast< ::mt::EmMtResolution >(resolution_);
}
inline void TMTPubTemplate::set_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_resolution();
  resolution_ = value;
}

// optional .mt.EmMtOpenMode meetingsafe = 5;
inline bool TMTPubTemplate::has_meetingsafe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTPubTemplate::set_has_meetingsafe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTPubTemplate::clear_has_meetingsafe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTPubTemplate::clear_meetingsafe() {
  meetingsafe_ = 1;
  clear_has_meetingsafe();
}
inline ::mt::EmMtOpenMode TMTPubTemplate::meetingsafe() const {
  return static_cast< ::mt::EmMtOpenMode >(meetingsafe_);
}
inline void TMTPubTemplate::set_meetingsafe(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_meetingsafe();
  meetingsafe_ = value;
}

// optional .mt.EmEncryptArithmetic encryptedtype = 6;
inline bool TMTPubTemplate::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTPubTemplate::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTPubTemplate::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTPubTemplate::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTPubTemplate::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTPubTemplate::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional string encryptedkey = 7;
inline bool TMTPubTemplate::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTPubTemplate::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTPubTemplate::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTPubTemplate::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTPubTemplate::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTPubTemplate::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPubTemplate::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPubTemplate::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPubTemplate::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTPubTemplate::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPubTemplate::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestDualMode dualmode = 8;
inline bool TMTPubTemplate::has_dualmode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTPubTemplate::set_has_dualmode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTPubTemplate::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTPubTemplate::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTPubTemplate::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTPubTemplate::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional uint32 duration = 9;
inline bool TMTPubTemplate::has_duration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTPubTemplate::set_has_duration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTPubTemplate::clear_has_duration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTPubTemplate::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTPubTemplate::duration() const {
  return duration_;
}
inline void TMTPubTemplate::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional .mt.EmMtMixType mixmode = 10;
inline bool TMTPubTemplate::has_mixmode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTPubTemplate::set_has_mixmode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTPubTemplate::clear_has_mixmode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTPubTemplate::clear_mixmode() {
  mixmode_ = 0;
  clear_has_mixmode();
}
inline ::mt::EmMtMixType TMTPubTemplate::mixmode() const {
  return static_cast< ::mt::EmMtMixType >(mixmode_);
}
inline void TMTPubTemplate::set_mixmode(::mt::EmMtMixType value) {
  assert(::mt::EmMtMixType_IsValid(value));
  set_has_mixmode();
  mixmode_ = value;
}

// optional .mt.TMTTemplateSatellite satellite = 11;
inline bool TMTPubTemplate::has_satellite() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTPubTemplate::set_has_satellite() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTPubTemplate::clear_has_satellite() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTPubTemplate::clear_satellite() {
  if (satellite_ != NULL) satellite_->::mt::TMTTemplateSatellite::Clear();
  clear_has_satellite();
}
inline const ::mt::TMTTemplateSatellite& TMTPubTemplate::satellite() const {
  return satellite_ != NULL ? *satellite_ : *default_instance_->satellite_;
}
inline ::mt::TMTTemplateSatellite* TMTPubTemplate::mutable_satellite() {
  set_has_satellite();
  if (satellite_ == NULL) satellite_ = new ::mt::TMTTemplateSatellite;
  return satellite_;
}
inline ::mt::TMTTemplateSatellite* TMTPubTemplate::release_satellite() {
  clear_has_satellite();
  ::mt::TMTTemplateSatellite* temp = satellite_;
  satellite_ = NULL;
  return temp;
}
inline void TMTPubTemplate::set_allocated_satellite(::mt::TMTTemplateSatellite* satellite) {
  delete satellite_;
  satellite_ = satellite;
  if (satellite) {
    set_has_satellite();
  } else {
    clear_has_satellite();
  }
}

// optional bool publicmeeting = 12;
inline bool TMTPubTemplate::has_publicmeeting() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTPubTemplate::set_has_publicmeeting() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTPubTemplate::clear_has_publicmeeting() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTPubTemplate::clear_publicmeeting() {
  publicmeeting_ = false;
  clear_has_publicmeeting();
}
inline bool TMTPubTemplate::publicmeeting() const {
  return publicmeeting_;
}
inline void TMTPubTemplate::set_publicmeeting(bool value) {
  set_has_publicmeeting();
  publicmeeting_ = value;
}

// repeated .mt.TMTVideoFormatList videoformatlist = 13;
inline int TMTPubTemplate::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTPubTemplate::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTPubTemplate::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTPubTemplate::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTPubTemplate::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTPubTemplate::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTPubTemplate::mutable_videoformatlist() {
  return &videoformatlist_;
}

// repeated .mt.TMTDualFormatList dualformatlist = 14;
inline int TMTPubTemplate::dualformatlist_size() const {
  return dualformatlist_.size();
}
inline void TMTPubTemplate::clear_dualformatlist() {
  dualformatlist_.Clear();
}
inline const ::mt::TMTDualFormatList& TMTPubTemplate::dualformatlist(int index) const {
  return dualformatlist_.Get(index);
}
inline ::mt::TMTDualFormatList* TMTPubTemplate::mutable_dualformatlist(int index) {
  return dualformatlist_.Mutable(index);
}
inline ::mt::TMTDualFormatList* TMTPubTemplate::add_dualformatlist() {
  return dualformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >&
TMTPubTemplate::dualformatlist() const {
  return dualformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTDualFormatList >*
TMTPubTemplate::mutable_dualformatlist() {
  return &dualformatlist_;
}

// repeated .mt.TMTAudioFormatList audioformatlist = 15;
inline int TMTPubTemplate::audioformatlist_size() const {
  return audioformatlist_.size();
}
inline void TMTPubTemplate::clear_audioformatlist() {
  audioformatlist_.Clear();
}
inline const ::mt::TMTAudioFormatList& TMTPubTemplate::audioformatlist(int index) const {
  return audioformatlist_.Get(index);
}
inline ::mt::TMTAudioFormatList* TMTPubTemplate::mutable_audioformatlist(int index) {
  return audioformatlist_.Mutable(index);
}
inline ::mt::TMTAudioFormatList* TMTPubTemplate::add_audioformatlist() {
  return audioformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >&
TMTPubTemplate::audioformatlist() const {
  return audioformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTAudioFormatList >*
TMTPubTemplate::mutable_audioformatlist() {
  return &audioformatlist_;
}

// optional .mt.EmClosedMeeting closedmeeting = 16;
inline bool TMTPubTemplate::has_closedmeeting() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTPubTemplate::set_has_closedmeeting() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTPubTemplate::clear_has_closedmeeting() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTPubTemplate::clear_closedmeeting() {
  closedmeeting_ = 0;
  clear_has_closedmeeting();
}
inline ::mt::EmClosedMeeting TMTPubTemplate::closedmeeting() const {
  return static_cast< ::mt::EmClosedMeeting >(closedmeeting_);
}
inline void TMTPubTemplate::set_closedmeeting(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closedmeeting();
  closedmeeting_ = value;
}

// optional bool encrypted_auth = 17;
inline bool TMTPubTemplate::has_encrypted_auth() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTPubTemplate::set_has_encrypted_auth() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTPubTemplate::clear_has_encrypted_auth() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTPubTemplate::clear_encrypted_auth() {
  encrypted_auth_ = false;
  clear_has_encrypted_auth();
}
inline bool TMTPubTemplate::encrypted_auth() const {
  return encrypted_auth_;
}
inline void TMTPubTemplate::set_encrypted_auth(bool value) {
  set_has_encrypted_auth();
  encrypted_auth_ = value;
}

// -------------------------------------------------------------------

// TMTCometdMessage

// optional .mt.EmRestMeetingNotifyType messagetype = 1;
inline bool TMTCometdMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCometdMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCometdMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCometdMessage::clear_messagetype() {
  messagetype_ = 0;
  clear_has_messagetype();
}
inline ::mt::EmRestMeetingNotifyType TMTCometdMessage::messagetype() const {
  return static_cast< ::mt::EmRestMeetingNotifyType >(messagetype_);
}
inline void TMTCometdMessage::set_messagetype(::mt::EmRestMeetingNotifyType value) {
  assert(::mt::EmRestMeetingNotifyType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
}

// optional uint32 notifyid = 2;
inline bool TMTCometdMessage::has_notifyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCometdMessage::set_has_notifyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCometdMessage::clear_has_notifyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCometdMessage::clear_notifyid() {
  notifyid_ = 0u;
  clear_has_notifyid();
}
inline ::google::protobuf::uint32 TMTCometdMessage::notifyid() const {
  return notifyid_;
}
inline void TMTCometdMessage::set_notifyid(::google::protobuf::uint32 value) {
  set_has_notifyid();
  notifyid_ = value;
}

// optional uint32 num = 3;
inline bool TMTCometdMessage::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTCometdMessage::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTCometdMessage::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTCometdMessage::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 TMTCometdMessage::num() const {
  return num_;
}
inline void TMTCometdMessage::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// TMTCometdMessageList

// repeated .mt.TMTCometdMessage cometdmessagelist = 1;
inline int TMTCometdMessageList::cometdmessagelist_size() const {
  return cometdmessagelist_.size();
}
inline void TMTCometdMessageList::clear_cometdmessagelist() {
  cometdmessagelist_.Clear();
}
inline const ::mt::TMTCometdMessage& TMTCometdMessageList::cometdmessagelist(int index) const {
  return cometdmessagelist_.Get(index);
}
inline ::mt::TMTCometdMessage* TMTCometdMessageList::mutable_cometdmessagelist(int index) {
  return cometdmessagelist_.Mutable(index);
}
inline ::mt::TMTCometdMessage* TMTCometdMessageList::add_cometdmessagelist() {
  return cometdmessagelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTCometdMessage >&
TMTCometdMessageList::cometdmessagelist() const {
  return cometdmessagelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTCometdMessage >*
TMTCometdMessageList::mutable_cometdmessagelist() {
  return &cometdmessagelist_;
}

// -------------------------------------------------------------------

// TMTConfMixInfo

// optional .mt.EmMtMixType mode = 1;
inline bool TMTConfMixInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfMixInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfMixInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfMixInfo::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mt::EmMtMixType TMTConfMixInfo::mode() const {
  return static_cast< ::mt::EmMtMixType >(mode_);
}
inline void TMTConfMixInfo::set_mode(::mt::EmMtMixType value) {
  assert(::mt::EmMtMixType_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// repeated .mt.TMTTemplateMember mixmemberlist = 2;
inline int TMTConfMixInfo::mixmemberlist_size() const {
  return mixmemberlist_.size();
}
inline void TMTConfMixInfo::clear_mixmemberlist() {
  mixmemberlist_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTConfMixInfo::mixmemberlist(int index) const {
  return mixmemberlist_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTConfMixInfo::mutable_mixmemberlist(int index) {
  return mixmemberlist_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTConfMixInfo::add_mixmemberlist() {
  return mixmemberlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTConfMixInfo::mixmemberlist() const {
  return mixmemberlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTConfMixInfo::mutable_mixmemberlist() {
  return &mixmemberlist_;
}

// -------------------------------------------------------------------

// TMTConfMixBrief

// optional .mt.EmMtMixType mode = 1;
inline bool TMTConfMixBrief::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfMixBrief::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfMixBrief::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfMixBrief::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mt::EmMtMixType TMTConfMixBrief::mode() const {
  return static_cast< ::mt::EmMtMixType >(mode_);
}
inline void TMTConfMixBrief::set_mode(::mt::EmMtMixType value) {
  assert(::mt::EmMtMixType_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// TMTConfSatelliteInfo

// optional string multicastaddr = 1;
inline bool TMTConfSatelliteInfo::has_multicastaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfSatelliteInfo::set_has_multicastaddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfSatelliteInfo::clear_has_multicastaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfSatelliteInfo::clear_multicastaddr() {
  if (multicastaddr_ != &::google::protobuf::internal::kEmptyString) {
    multicastaddr_->clear();
  }
  clear_has_multicastaddr();
}
inline const ::std::string& TMTConfSatelliteInfo::multicastaddr() const {
  return *multicastaddr_;
}
inline void TMTConfSatelliteInfo::set_multicastaddr(const ::std::string& value) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(value);
}
inline void TMTConfSatelliteInfo::set_multicastaddr(const char* value) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(value);
}
inline void TMTConfSatelliteInfo::set_multicastaddr(const char* value, size_t size) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfSatelliteInfo::mutable_multicastaddr() {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  return multicastaddr_;
}
inline ::std::string* TMTConfSatelliteInfo::release_multicastaddr() {
  clear_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = multicastaddr_;
    multicastaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfSatelliteInfo::set_allocated_multicastaddr(::std::string* multicastaddr) {
  if (multicastaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete multicastaddr_;
  }
  if (multicastaddr) {
    set_has_multicastaddr();
    multicastaddr_ = multicastaddr;
  } else {
    clear_has_multicastaddr();
    multicastaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 2;
inline bool TMTConfSatelliteInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConfSatelliteInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConfSatelliteInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConfSatelliteInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMTConfSatelliteInfo::port() const {
  return port_;
}
inline void TMTConfSatelliteInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional uint32 returnnum = 3;
inline bool TMTConfSatelliteInfo::has_returnnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTConfSatelliteInfo::set_has_returnnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTConfSatelliteInfo::clear_has_returnnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTConfSatelliteInfo::clear_returnnum() {
  returnnum_ = 0u;
  clear_has_returnnum();
}
inline ::google::protobuf::uint32 TMTConfSatelliteInfo::returnnum() const {
  return returnnum_;
}
inline void TMTConfSatelliteInfo::set_returnnum(::google::protobuf::uint32 value) {
  set_has_returnnum();
  returnnum_ = value;
}

// -------------------------------------------------------------------

// TMTConfRecordInfo

// optional bool doubleflow = 1;
inline bool TMTConfRecordInfo::has_doubleflow() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfRecordInfo::set_has_doubleflow() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfRecordInfo::clear_has_doubleflow() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfRecordInfo::clear_doubleflow() {
  doubleflow_ = false;
  clear_has_doubleflow();
}
inline bool TMTConfRecordInfo::doubleflow() const {
  return doubleflow_;
}
inline void TMTConfRecordInfo::set_doubleflow(bool value) {
  set_has_doubleflow();
  doubleflow_ = value;
}

// optional bool main = 2;
inline bool TMTConfRecordInfo::has_main() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConfRecordInfo::set_has_main() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConfRecordInfo::clear_has_main() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConfRecordInfo::clear_main() {
  main_ = false;
  clear_has_main();
}
inline bool TMTConfRecordInfo::main() const {
  return main_;
}
inline void TMTConfRecordInfo::set_main(bool value) {
  set_has_main();
  main_ = value;
}

// optional bool publish = 3;
inline bool TMTConfRecordInfo::has_publish() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTConfRecordInfo::set_has_publish() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTConfRecordInfo::clear_has_publish() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTConfRecordInfo::clear_publish() {
  publish_ = false;
  clear_has_publish();
}
inline bool TMTConfRecordInfo::publish() const {
  return publish_;
}
inline void TMTConfRecordInfo::set_publish(bool value) {
  set_has_publish();
  publish_ = value;
}

// -------------------------------------------------------------------

// TMTConfMultiCastInfo

// optional string multicastAddr = 1;
inline bool TMTConfMultiCastInfo::has_multicastaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfMultiCastInfo::set_has_multicastaddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfMultiCastInfo::clear_has_multicastaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfMultiCastInfo::clear_multicastaddr() {
  if (multicastaddr_ != &::google::protobuf::internal::kEmptyString) {
    multicastaddr_->clear();
  }
  clear_has_multicastaddr();
}
inline const ::std::string& TMTConfMultiCastInfo::multicastaddr() const {
  return *multicastaddr_;
}
inline void TMTConfMultiCastInfo::set_multicastaddr(const ::std::string& value) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(value);
}
inline void TMTConfMultiCastInfo::set_multicastaddr(const char* value) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(value);
}
inline void TMTConfMultiCastInfo::set_multicastaddr(const char* value, size_t size) {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  multicastaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfMultiCastInfo::mutable_multicastaddr() {
  set_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    multicastaddr_ = new ::std::string;
  }
  return multicastaddr_;
}
inline ::std::string* TMTConfMultiCastInfo::release_multicastaddr() {
  clear_has_multicastaddr();
  if (multicastaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = multicastaddr_;
    multicastaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfMultiCastInfo::set_allocated_multicastaddr(::std::string* multicastaddr) {
  if (multicastaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete multicastaddr_;
  }
  if (multicastaddr) {
    set_has_multicastaddr();
    multicastaddr_ = multicastaddr;
  } else {
    clear_has_multicastaddr();
    multicastaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 2;
inline bool TMTConfMultiCastInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConfMultiCastInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConfMultiCastInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConfMultiCastInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMTConfMultiCastInfo::port() const {
  return port_;
}
inline void TMTConfMultiCastInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMTConfVMPInfo

// optional .mt.EmMtVmpStyle style = 1;
inline bool TMTConfVMPInfo::has_style() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfVMPInfo::set_has_style() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfVMPInfo::clear_has_style() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfVMPInfo::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::mt::EmMtVmpStyle TMTConfVMPInfo::style() const {
  return static_cast< ::mt::EmMtVmpStyle >(style_);
}
inline void TMTConfVMPInfo::set_style(::mt::EmMtVmpStyle value) {
  assert(::mt::EmMtVmpStyle_IsValid(value));
  set_has_style();
  style_ = value;
}

// optional bool voicehint = 2;
inline bool TMTConfVMPInfo::has_voicehint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConfVMPInfo::set_has_voicehint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConfVMPInfo::clear_has_voicehint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConfVMPInfo::clear_voicehint() {
  voicehint_ = false;
  clear_has_voicehint();
}
inline bool TMTConfVMPInfo::voicehint() const {
  return voicehint_;
}
inline void TMTConfVMPInfo::set_voicehint(bool value) {
  set_has_voicehint();
  voicehint_ = value;
}

// optional bool showmtname = 3;
inline bool TMTConfVMPInfo::has_showmtname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTConfVMPInfo::set_has_showmtname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTConfVMPInfo::clear_has_showmtname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTConfVMPInfo::clear_showmtname() {
  showmtname_ = false;
  clear_has_showmtname();
}
inline bool TMTConfVMPInfo::showmtname() const {
  return showmtname_;
}
inline void TMTConfVMPInfo::set_showmtname(bool value) {
  set_has_showmtname();
  showmtname_ = value;
}

// repeated .mt.TMTTemplateVmpMember memberlist = 4;
inline int TMTConfVMPInfo::memberlist_size() const {
  return memberlist_.size();
}
inline void TMTConfVMPInfo::clear_memberlist() {
  memberlist_.Clear();
}
inline const ::mt::TMTTemplateVmpMember& TMTConfVMPInfo::memberlist(int index) const {
  return memberlist_.Get(index);
}
inline ::mt::TMTTemplateVmpMember* TMTConfVMPInfo::mutable_memberlist(int index) {
  return memberlist_.Mutable(index);
}
inline ::mt::TMTTemplateVmpMember* TMTConfVMPInfo::add_memberlist() {
  return memberlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateVmpMember >&
TMTConfVMPInfo::memberlist() const {
  return memberlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateVmpMember >*
TMTConfVMPInfo::mutable_memberlist() {
  return &memberlist_;
}

// optional bool broadcast = 5;
inline bool TMTConfVMPInfo::has_broadcast() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTConfVMPInfo::set_has_broadcast() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTConfVMPInfo::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTConfVMPInfo::clear_broadcast() {
  broadcast_ = false;
  clear_has_broadcast();
}
inline bool TMTConfVMPInfo::broadcast() const {
  return broadcast_;
}
inline void TMTConfVMPInfo::set_broadcast(bool value) {
  set_has_broadcast();
  broadcast_ = value;
}

// optional bool enable = 6;
inline bool TMTConfVMPInfo::has_enable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTConfVMPInfo::set_has_enable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTConfVMPInfo::clear_has_enable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTConfVMPInfo::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTConfVMPInfo::enable() const {
  return enable_;
}
inline void TMTConfVMPInfo::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional .mt.EmVmpMode mode = 7;
inline bool TMTConfVMPInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTConfVMPInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTConfVMPInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTConfVMPInfo::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mt::EmVmpMode TMTConfVMPInfo::mode() const {
  return static_cast< ::mt::EmVmpMode >(mode_);
}
inline void TMTConfVMPInfo::set_mode(::mt::EmVmpMode value) {
  assert(::mt::EmVmpMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// optional .mt.TMTVMtNameStyle mtnamestyle = 8;
inline bool TMTConfVMPInfo::has_mtnamestyle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTConfVMPInfo::set_has_mtnamestyle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTConfVMPInfo::clear_has_mtnamestyle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTConfVMPInfo::clear_mtnamestyle() {
  if (mtnamestyle_ != NULL) mtnamestyle_->::mt::TMTVMtNameStyle::Clear();
  clear_has_mtnamestyle();
}
inline const ::mt::TMTVMtNameStyle& TMTConfVMPInfo::mtnamestyle() const {
  return mtnamestyle_ != NULL ? *mtnamestyle_ : *default_instance_->mtnamestyle_;
}
inline ::mt::TMTVMtNameStyle* TMTConfVMPInfo::mutable_mtnamestyle() {
  set_has_mtnamestyle();
  if (mtnamestyle_ == NULL) mtnamestyle_ = new ::mt::TMTVMtNameStyle;
  return mtnamestyle_;
}
inline ::mt::TMTVMtNameStyle* TMTConfVMPInfo::release_mtnamestyle() {
  clear_has_mtnamestyle();
  ::mt::TMTVMtNameStyle* temp = mtnamestyle_;
  mtnamestyle_ = NULL;
  return temp;
}
inline void TMTConfVMPInfo::set_allocated_mtnamestyle(::mt::TMTVMtNameStyle* mtnamestyle) {
  delete mtnamestyle_;
  mtnamestyle_ = mtnamestyle;
  if (mtnamestyle) {
    set_has_mtnamestyle();
  } else {
    clear_has_mtnamestyle();
  }
}

// -------------------------------------------------------------------

// TMTConfVMPBrief

// optional bool enable = 1;
inline bool TMTConfVMPBrief::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfVMPBrief::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfVMPBrief::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfVMPBrief::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTConfVMPBrief::enable() const {
  return enable_;
}
inline void TMTConfVMPBrief::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional .mt.EmVmpMode mode = 2;
inline bool TMTConfVMPBrief::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConfVMPBrief::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConfVMPBrief::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConfVMPBrief::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mt::EmVmpMode TMTConfVMPBrief::mode() const {
  return static_cast< ::mt::EmVmpMode >(mode_);
}
inline void TMTConfVMPBrief::set_mode(::mt::EmVmpMode value) {
  assert(::mt::EmVmpMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// TMTConfPollInfo

// optional uint32 num = 1;
inline bool TMTConfPollInfo::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfPollInfo::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfPollInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfPollInfo::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 TMTConfPollInfo::num() const {
  return num_;
}
inline void TMTConfPollInfo::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional uint32 interval = 2;
inline bool TMTConfPollInfo::has_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConfPollInfo::set_has_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConfPollInfo::clear_has_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConfPollInfo::clear_interval() {
  interval_ = 0u;
  clear_has_interval();
}
inline ::google::protobuf::uint32 TMTConfPollInfo::interval() const {
  return interval_;
}
inline void TMTConfPollInfo::set_interval(::google::protobuf::uint32 value) {
  set_has_interval();
  interval_ = value;
}

// repeated .mt.TMTTemplateMember memberlist = 3;
inline int TMTConfPollInfo::memberlist_size() const {
  return memberlist_.size();
}
inline void TMTConfPollInfo::clear_memberlist() {
  memberlist_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTConfPollInfo::memberlist(int index) const {
  return memberlist_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTConfPollInfo::mutable_memberlist(int index) {
  return memberlist_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTConfPollInfo::add_memberlist() {
  return memberlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTConfPollInfo::memberlist() const {
  return memberlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTConfPollInfo::mutable_memberlist() {
  return &memberlist_;
}

// optional bool enable = 4;
inline bool TMTConfPollInfo::has_enable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTConfPollInfo::set_has_enable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTConfPollInfo::clear_has_enable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTConfPollInfo::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTConfPollInfo::enable() const {
  return enable_;
}
inline void TMTConfPollInfo::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional .mt.EmPollMode mode = 5;
inline bool TMTConfPollInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTConfPollInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTConfPollInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTConfPollInfo::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mt::EmPollMode TMTConfPollInfo::mode() const {
  return static_cast< ::mt::EmPollMode >(mode_);
}
inline void TMTConfPollInfo::set_mode(::mt::EmPollMode value) {
  assert(::mt::EmPollMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// TMTRecordAttribute

// optional .mt.EmPublishMode emPublishMode = 1;
inline bool TMTRecordAttribute::has_empublishmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRecordAttribute::set_has_empublishmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRecordAttribute::clear_has_empublishmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRecordAttribute::clear_empublishmode() {
  empublishmode_ = 0;
  clear_has_empublishmode();
}
inline ::mt::EmPublishMode TMTRecordAttribute::empublishmode() const {
  return static_cast< ::mt::EmPublishMode >(empublishmode_);
}
inline void TMTRecordAttribute::set_empublishmode(::mt::EmPublishMode value) {
  assert(::mt::EmPublishMode_IsValid(value));
  set_has_empublishmode();
  empublishmode_ = value;
}

// optional .mt.EmRecordMode emRecordMode = 2;
inline bool TMTRecordAttribute::has_emrecordmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRecordAttribute::set_has_emrecordmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRecordAttribute::clear_has_emrecordmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRecordAttribute::clear_emrecordmode() {
  emrecordmode_ = 0;
  clear_has_emrecordmode();
}
inline ::mt::EmRecordMode TMTRecordAttribute::emrecordmode() const {
  return static_cast< ::mt::EmRecordMode >(emrecordmode_);
}
inline void TMTRecordAttribute::set_emrecordmode(::mt::EmRecordMode value) {
  assert(::mt::EmRecordMode_IsValid(value));
  set_has_emrecordmode();
  emrecordmode_ = value;
}

// optional bool bAnonymous = 3;
inline bool TMTRecordAttribute::has_banonymous() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRecordAttribute::set_has_banonymous() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRecordAttribute::clear_has_banonymous() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRecordAttribute::clear_banonymous() {
  banonymous_ = false;
  clear_has_banonymous();
}
inline bool TMTRecordAttribute::banonymous() const {
  return banonymous_;
}
inline void TMTRecordAttribute::set_banonymous(bool value) {
  set_has_banonymous();
  banonymous_ = value;
}

// optional bool bDualStream = 4;
inline bool TMTRecordAttribute::has_bdualstream() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTRecordAttribute::set_has_bdualstream() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTRecordAttribute::clear_has_bdualstream() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTRecordAttribute::clear_bdualstream() {
  bdualstream_ = false;
  clear_has_bdualstream();
}
inline bool TMTRecordAttribute::bdualstream() const {
  return bdualstream_;
}
inline void TMTRecordAttribute::set_bdualstream(bool value) {
  set_has_bdualstream();
  bdualstream_ = value;
}

// optional string vrsId = 5;
inline bool TMTRecordAttribute::has_vrsid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTRecordAttribute::set_has_vrsid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTRecordAttribute::clear_has_vrsid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTRecordAttribute::clear_vrsid() {
  if (vrsid_ != &::google::protobuf::internal::kEmptyString) {
    vrsid_->clear();
  }
  clear_has_vrsid();
}
inline const ::std::string& TMTRecordAttribute::vrsid() const {
  return *vrsid_;
}
inline void TMTRecordAttribute::set_vrsid(const ::std::string& value) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(value);
}
inline void TMTRecordAttribute::set_vrsid(const char* value) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(value);
}
inline void TMTRecordAttribute::set_vrsid(const char* value, size_t size) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRecordAttribute::mutable_vrsid() {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  return vrsid_;
}
inline ::std::string* TMTRecordAttribute::release_vrsid() {
  clear_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vrsid_;
    vrsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRecordAttribute::set_allocated_vrsid(::std::string* vrsid) {
  if (vrsid_ != &::google::protobuf::internal::kEmptyString) {
    delete vrsid_;
  }
  if (vrsid) {
    set_has_vrsid();
    vrsid_ = vrsid;
  } else {
    clear_has_vrsid();
    vrsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTRecordAttributeBrief

// optional .mt.EmRecordMode emRecordMode = 1;
inline bool TMTRecordAttributeBrief::has_emrecordmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRecordAttributeBrief::set_has_emrecordmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRecordAttributeBrief::clear_has_emrecordmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRecordAttributeBrief::clear_emrecordmode() {
  emrecordmode_ = 0;
  clear_has_emrecordmode();
}
inline ::mt::EmRecordMode TMTRecordAttributeBrief::emrecordmode() const {
  return static_cast< ::mt::EmRecordMode >(emrecordmode_);
}
inline void TMTRecordAttributeBrief::set_emrecordmode(::mt::EmRecordMode value) {
  assert(::mt::EmRecordMode_IsValid(value));
  set_has_emrecordmode();
  emrecordmode_ = value;
}

// optional string vrsId = 2;
inline bool TMTRecordAttributeBrief::has_vrsid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRecordAttributeBrief::set_has_vrsid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRecordAttributeBrief::clear_has_vrsid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRecordAttributeBrief::clear_vrsid() {
  if (vrsid_ != &::google::protobuf::internal::kEmptyString) {
    vrsid_->clear();
  }
  clear_has_vrsid();
}
inline const ::std::string& TMTRecordAttributeBrief::vrsid() const {
  return *vrsid_;
}
inline void TMTRecordAttributeBrief::set_vrsid(const ::std::string& value) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(value);
}
inline void TMTRecordAttributeBrief::set_vrsid(const char* value) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(value);
}
inline void TMTRecordAttributeBrief::set_vrsid(const char* value, size_t size) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRecordAttributeBrief::mutable_vrsid() {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  return vrsid_;
}
inline ::std::string* TMTRecordAttributeBrief::release_vrsid() {
  clear_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vrsid_;
    vrsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRecordAttributeBrief::set_allocated_vrsid(::std::string* vrsid) {
  if (vrsid_ != &::google::protobuf::internal::kEmptyString) {
    delete vrsid_;
  }
  if (vrsid) {
    set_has_vrsid();
    vrsid_ = vrsid;
  } else {
    clear_has_vrsid();
    vrsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTDCSAttribute

// optional .mt.EmMtDcsConfMode emDCSMode = 1;
inline bool TMTDCSAttribute::has_emdcsmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTDCSAttribute::set_has_emdcsmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTDCSAttribute::clear_has_emdcsmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTDCSAttribute::clear_emdcsmode() {
  emdcsmode_ = 0;
  clear_has_emdcsmode();
}
inline ::mt::EmMtDcsConfMode TMTDCSAttribute::emdcsmode() const {
  return static_cast< ::mt::EmMtDcsConfMode >(emdcsmode_);
}
inline void TMTDCSAttribute::set_emdcsmode(::mt::EmMtDcsConfMode value) {
  assert(::mt::EmMtDcsConfMode_IsValid(value));
  set_has_emdcsmode();
  emdcsmode_ = value;
}

// -------------------------------------------------------------------

// TMTInviteMember

// optional string name = 1;
inline bool TMTInviteMember::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTInviteMember::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTInviteMember::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTInviteMember::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTInviteMember::name() const {
  return *name_;
}
inline void TMTInviteMember::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTInviteMember::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTInviteMember::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInviteMember::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTInviteMember::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInviteMember::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 2;
inline bool TMTInviteMember::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTInviteMember::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTInviteMember::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTInviteMember::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTInviteMember::account() const {
  return *account_;
}
inline void TMTInviteMember::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTInviteMember::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTInviteMember::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInviteMember::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTInviteMember::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInviteMember::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtAddrType accounttype = 3;
inline bool TMTInviteMember::has_accounttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTInviteMember::set_has_accounttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTInviteMember::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTInviteMember::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::mt::EmMtAddrType TMTInviteMember::accounttype() const {
  return static_cast< ::mt::EmMtAddrType >(accounttype_);
}
inline void TMTInviteMember::set_accounttype(::mt::EmMtAddrType value) {
  assert(::mt::EmMtAddrType_IsValid(value));
  set_has_accounttype();
  accounttype_ = value;
}

// optional .mt.EmConfProtocol protocol = 4;
inline bool TMTInviteMember::has_protocol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTInviteMember::set_has_protocol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTInviteMember::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTInviteMember::clear_protocol() {
  protocol_ = 0;
  clear_has_protocol();
}
inline ::mt::EmConfProtocol TMTInviteMember::protocol() const {
  return static_cast< ::mt::EmConfProtocol >(protocol_);
}
inline void TMTInviteMember::set_protocol(::mt::EmConfProtocol value) {
  assert(::mt::EmConfProtocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
}

// -------------------------------------------------------------------

// TMTPeronalTemplate

// optional string name = 1;
inline bool TMTPeronalTemplate::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPeronalTemplate::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPeronalTemplate::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPeronalTemplate::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTPeronalTemplate::name() const {
  return *name_;
}
inline void TMTPeronalTemplate::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPeronalTemplate::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPeronalTemplate::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPeronalTemplate::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTPeronalTemplate::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPeronalTemplate::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 bitrate = 2;
inline bool TMTPeronalTemplate::has_bitrate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPeronalTemplate::set_has_bitrate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPeronalTemplate::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPeronalTemplate::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTPeronalTemplate::bitrate() const {
  return bitrate_;
}
inline void TMTPeronalTemplate::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmClosedMeeting closeConf = 3;
inline bool TMTPeronalTemplate::has_closeconf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPeronalTemplate::set_has_closeconf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPeronalTemplate::clear_has_closeconf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPeronalTemplate::clear_closeconf() {
  closeconf_ = 0;
  clear_has_closeconf();
}
inline ::mt::EmClosedMeeting TMTPeronalTemplate::closeconf() const {
  return static_cast< ::mt::EmClosedMeeting >(closeconf_);
}
inline void TMTPeronalTemplate::set_closeconf(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closeconf();
  closeconf_ = value;
}

// optional .mt.EmMtOpenMode safeConf = 4;
inline bool TMTPeronalTemplate::has_safeconf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPeronalTemplate::set_has_safeconf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPeronalTemplate::clear_has_safeconf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPeronalTemplate::clear_safeconf() {
  safeconf_ = 1;
  clear_has_safeconf();
}
inline ::mt::EmMtOpenMode TMTPeronalTemplate::safeconf() const {
  return static_cast< ::mt::EmMtOpenMode >(safeconf_);
}
inline void TMTPeronalTemplate::set_safeconf(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_safeconf();
  safeconf_ = value;
}

// optional string password = 5;
inline bool TMTPeronalTemplate::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTPeronalTemplate::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTPeronalTemplate::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTPeronalTemplate::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTPeronalTemplate::password() const {
  return *password_;
}
inline void TMTPeronalTemplate::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTPeronalTemplate::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTPeronalTemplate::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPeronalTemplate::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTPeronalTemplate::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPeronalTemplate::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmEncryptArithmetic encryptedtype = 6;
inline bool TMTPeronalTemplate::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTPeronalTemplate::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTPeronalTemplate::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTPeronalTemplate::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTPeronalTemplate::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTPeronalTemplate::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional .mt.EmRestMeetingSafeType meetingtype = 7;
inline bool TMTPeronalTemplate::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTPeronalTemplate::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTPeronalTemplate::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTPeronalTemplate::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTPeronalTemplate::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTPeronalTemplate::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional uint32 callTimes = 8;
inline bool TMTPeronalTemplate::has_calltimes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTPeronalTemplate::set_has_calltimes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTPeronalTemplate::clear_has_calltimes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTPeronalTemplate::clear_calltimes() {
  calltimes_ = 0u;
  clear_has_calltimes();
}
inline ::google::protobuf::uint32 TMTPeronalTemplate::calltimes() const {
  return calltimes_;
}
inline void TMTPeronalTemplate::set_calltimes(::google::protobuf::uint32 value) {
  set_has_calltimes();
  calltimes_ = value;
}

// optional uint32 callInterval = 9;
inline bool TMTPeronalTemplate::has_callinterval() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTPeronalTemplate::set_has_callinterval() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTPeronalTemplate::clear_has_callinterval() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTPeronalTemplate::clear_callinterval() {
  callinterval_ = 0u;
  clear_has_callinterval();
}
inline ::google::protobuf::uint32 TMTPeronalTemplate::callinterval() const {
  return callinterval_;
}
inline void TMTPeronalTemplate::set_callinterval(::google::protobuf::uint32 value) {
  set_has_callinterval();
  callinterval_ = value;
}

// optional bool initmute = 10;
inline bool TMTPeronalTemplate::has_initmute() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTPeronalTemplate::set_has_initmute() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTPeronalTemplate::clear_has_initmute() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTPeronalTemplate::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTPeronalTemplate::initmute() const {
  return initmute_;
}
inline void TMTPeronalTemplate::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional bool initSilence = 11;
inline bool TMTPeronalTemplate::has_initsilence() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTPeronalTemplate::set_has_initsilence() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTPeronalTemplate::clear_has_initsilence() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTPeronalTemplate::clear_initsilence() {
  initsilence_ = false;
  clear_has_initsilence();
}
inline bool TMTPeronalTemplate::initsilence() const {
  return initsilence_;
}
inline void TMTPeronalTemplate::set_initsilence(bool value) {
  set_has_initsilence();
  initsilence_ = value;
}

// optional .mt.EmRestVideoQuality vidoQuality = 12;
inline bool TMTPeronalTemplate::has_vidoquality() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTPeronalTemplate::set_has_vidoquality() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTPeronalTemplate::clear_has_vidoquality() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTPeronalTemplate::clear_vidoquality() {
  vidoquality_ = 0;
  clear_has_vidoquality();
}
inline ::mt::EmRestVideoQuality TMTPeronalTemplate::vidoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(vidoquality_);
}
inline void TMTPeronalTemplate::set_vidoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_vidoquality();
  vidoquality_ = value;
}

// optional uint32 oneReforming = 13;
inline bool TMTPeronalTemplate::has_onereforming() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTPeronalTemplate::set_has_onereforming() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTPeronalTemplate::clear_has_onereforming() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTPeronalTemplate::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TMTPeronalTemplate::onereforming() const {
  return onereforming_;
}
inline void TMTPeronalTemplate::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional string encryptedkey = 14;
inline bool TMTPeronalTemplate::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTPeronalTemplate::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTPeronalTemplate::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTPeronalTemplate::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTPeronalTemplate::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTPeronalTemplate::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPeronalTemplate::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPeronalTemplate::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPeronalTemplate::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTPeronalTemplate::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPeronalTemplate::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestDualMode dualmode = 15;
inline bool TMTPeronalTemplate::has_dualmode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTPeronalTemplate::set_has_dualmode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTPeronalTemplate::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTPeronalTemplate::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTPeronalTemplate::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTPeronalTemplate::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool voiceActivityDetection = 16;
inline bool TMTPeronalTemplate::has_voiceactivitydetection() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTPeronalTemplate::set_has_voiceactivitydetection() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTPeronalTemplate::clear_has_voiceactivitydetection() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTPeronalTemplate::clear_voiceactivitydetection() {
  voiceactivitydetection_ = false;
  clear_has_voiceactivitydetection();
}
inline bool TMTPeronalTemplate::voiceactivitydetection() const {
  return voiceactivitydetection_;
}
inline void TMTPeronalTemplate::set_voiceactivitydetection(bool value) {
  set_has_voiceactivitydetection();
  voiceactivitydetection_ = value;
}

// optional uint32 vacinterval = 17;
inline bool TMTPeronalTemplate::has_vacinterval() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTPeronalTemplate::set_has_vacinterval() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTPeronalTemplate::clear_has_vacinterval() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTPeronalTemplate::clear_vacinterval() {
  vacinterval_ = 0u;
  clear_has_vacinterval();
}
inline ::google::protobuf::uint32 TMTPeronalTemplate::vacinterval() const {
  return vacinterval_;
}
inline void TMTPeronalTemplate::set_vacinterval(::google::protobuf::uint32 value) {
  set_has_vacinterval();
  vacinterval_ = value;
}

// optional .mt.EmRestCascadeMode emCascadeMode = 18;
inline bool TMTPeronalTemplate::has_emcascademode() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTPeronalTemplate::set_has_emcascademode() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTPeronalTemplate::clear_has_emcascademode() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTPeronalTemplate::clear_emcascademode() {
  emcascademode_ = 0;
  clear_has_emcascademode();
}
inline ::mt::EmRestCascadeMode TMTPeronalTemplate::emcascademode() const {
  return static_cast< ::mt::EmRestCascadeMode >(emcascademode_);
}
inline void TMTPeronalTemplate::set_emcascademode(::mt::EmRestCascadeMode value) {
  assert(::mt::EmRestCascadeMode_IsValid(value));
  set_has_emcascademode();
  emcascademode_ = value;
}

// optional bool cascadeUpload = 19;
inline bool TMTPeronalTemplate::has_cascadeupload() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTPeronalTemplate::set_has_cascadeupload() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTPeronalTemplate::clear_has_cascadeupload() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTPeronalTemplate::clear_cascadeupload() {
  cascadeupload_ = false;
  clear_has_cascadeupload();
}
inline bool TMTPeronalTemplate::cascadeupload() const {
  return cascadeupload_;
}
inline void TMTPeronalTemplate::set_cascadeupload(bool value) {
  set_has_cascadeupload();
  cascadeupload_ = value;
}

// optional bool cascadeReturn = 20;
inline bool TMTPeronalTemplate::has_cascadereturn() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTPeronalTemplate::set_has_cascadereturn() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTPeronalTemplate::clear_has_cascadereturn() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTPeronalTemplate::clear_cascadereturn() {
  cascadereturn_ = false;
  clear_has_cascadereturn();
}
inline bool TMTPeronalTemplate::cascadereturn() const {
  return cascadereturn_;
}
inline void TMTPeronalTemplate::set_cascadereturn(bool value) {
  set_has_cascadereturn();
  cascadereturn_ = value;
}

// optional uint32 cascadeReturnPara = 21;
inline bool TMTPeronalTemplate::has_cascadereturnpara() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTPeronalTemplate::set_has_cascadereturnpara() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTPeronalTemplate::clear_has_cascadereturnpara() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTPeronalTemplate::clear_cascadereturnpara() {
  cascadereturnpara_ = 0u;
  clear_has_cascadereturnpara();
}
inline ::google::protobuf::uint32 TMTPeronalTemplate::cascadereturnpara() const {
  return cascadereturnpara_;
}
inline void TMTPeronalTemplate::set_cascadereturnpara(::google::protobuf::uint32 value) {
  set_has_cascadereturnpara();
  cascadereturnpara_ = value;
}

// optional bool publicConf = 22;
inline bool TMTPeronalTemplate::has_publicconf() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTPeronalTemplate::set_has_publicconf() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTPeronalTemplate::clear_has_publicconf() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTPeronalTemplate::clear_publicconf() {
  publicconf_ = false;
  clear_has_publicconf();
}
inline bool TMTPeronalTemplate::publicconf() const {
  return publicconf_;
}
inline void TMTPeronalTemplate::set_publicconf(bool value) {
  set_has_publicconf();
  publicconf_ = value;
}

// optional uint32 maxJoinMt = 23;
inline bool TMTPeronalTemplate::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTPeronalTemplate::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTPeronalTemplate::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTPeronalTemplate::clear_maxjoinmt() {
  maxjoinmt_ = 0u;
  clear_has_maxjoinmt();
}
inline ::google::protobuf::uint32 TMTPeronalTemplate::maxjoinmt() const {
  return maxjoinmt_;
}
inline void TMTPeronalTemplate::set_maxjoinmt(::google::protobuf::uint32 value) {
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional bool autoEnd = 24;
inline bool TMTPeronalTemplate::has_autoend() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTPeronalTemplate::set_has_autoend() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTPeronalTemplate::clear_has_autoend() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTPeronalTemplate::clear_autoend() {
  autoend_ = false;
  clear_has_autoend();
}
inline bool TMTPeronalTemplate::autoend() const {
  return autoend_;
}
inline void TMTPeronalTemplate::set_autoend(bool value) {
  set_has_autoend();
  autoend_ = value;
}

// optional bool preoccpuyResouce = 25;
inline bool TMTPeronalTemplate::has_preoccpuyresouce() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTPeronalTemplate::set_has_preoccpuyresouce() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTPeronalTemplate::clear_has_preoccpuyresouce() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTPeronalTemplate::clear_preoccpuyresouce() {
  preoccpuyresouce_ = false;
  clear_has_preoccpuyresouce();
}
inline bool TMTPeronalTemplate::preoccpuyresouce() const {
  return preoccpuyresouce_;
}
inline void TMTPeronalTemplate::set_preoccpuyresouce(bool value) {
  set_has_preoccpuyresouce();
  preoccpuyresouce_ = value;
}

// optional .mt.TMTTemplateMember speaker = 26;
inline bool TMTPeronalTemplate::has_speaker() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMTPeronalTemplate::set_has_speaker() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMTPeronalTemplate::clear_has_speaker() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMTPeronalTemplate::clear_speaker() {
  if (speaker_ != NULL) speaker_->::mt::TMTTemplateMember::Clear();
  clear_has_speaker();
}
inline const ::mt::TMTTemplateMember& TMTPeronalTemplate::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::mt::TMTTemplateMember* TMTPeronalTemplate::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::mt::TMTTemplateMember;
  return speaker_;
}
inline ::mt::TMTTemplateMember* TMTPeronalTemplate::release_speaker() {
  clear_has_speaker();
  ::mt::TMTTemplateMember* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void TMTPeronalTemplate::set_allocated_speaker(::mt::TMTTemplateMember* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional .mt.TMTTemplateMember chairman = 27;
inline bool TMTPeronalTemplate::has_chairman() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMTPeronalTemplate::set_has_chairman() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMTPeronalTemplate::clear_has_chairman() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMTPeronalTemplate::clear_chairman() {
  if (chairman_ != NULL) chairman_->::mt::TMTTemplateMember::Clear();
  clear_has_chairman();
}
inline const ::mt::TMTTemplateMember& TMTPeronalTemplate::chairman() const {
  return chairman_ != NULL ? *chairman_ : *default_instance_->chairman_;
}
inline ::mt::TMTTemplateMember* TMTPeronalTemplate::mutable_chairman() {
  set_has_chairman();
  if (chairman_ == NULL) chairman_ = new ::mt::TMTTemplateMember;
  return chairman_;
}
inline ::mt::TMTTemplateMember* TMTPeronalTemplate::release_chairman() {
  clear_has_chairman();
  ::mt::TMTTemplateMember* temp = chairman_;
  chairman_ = NULL;
  return temp;
}
inline void TMTPeronalTemplate::set_allocated_chairman(::mt::TMTTemplateMember* chairman) {
  delete chairman_;
  chairman_ = chairman;
  if (chairman) {
    set_has_chairman();
  } else {
    clear_has_chairman();
  }
}

// optional .mt.TMTConfMixInfo mix = 28;
inline bool TMTPeronalTemplate::has_mix() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTPeronalTemplate::set_has_mix() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTPeronalTemplate::clear_has_mix() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTPeronalTemplate::clear_mix() {
  if (mix_ != NULL) mix_->::mt::TMTConfMixInfo::Clear();
  clear_has_mix();
}
inline const ::mt::TMTConfMixInfo& TMTPeronalTemplate::mix() const {
  return mix_ != NULL ? *mix_ : *default_instance_->mix_;
}
inline ::mt::TMTConfMixInfo* TMTPeronalTemplate::mutable_mix() {
  set_has_mix();
  if (mix_ == NULL) mix_ = new ::mt::TMTConfMixInfo;
  return mix_;
}
inline ::mt::TMTConfMixInfo* TMTPeronalTemplate::release_mix() {
  clear_has_mix();
  ::mt::TMTConfMixInfo* temp = mix_;
  mix_ = NULL;
  return temp;
}
inline void TMTPeronalTemplate::set_allocated_mix(::mt::TMTConfMixInfo* mix) {
  delete mix_;
  mix_ = mix;
  if (mix) {
    set_has_mix();
  } else {
    clear_has_mix();
  }
}

// repeated .mt.TMTVideoFormatList videoFormatList = 29;
inline int TMTPeronalTemplate::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTPeronalTemplate::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTPeronalTemplate::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTPeronalTemplate::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTPeronalTemplate::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTPeronalTemplate::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTPeronalTemplate::mutable_videoformatlist() {
  return &videoformatlist_;
}

// repeated .mt.TMTInviteMember inviteMembers = 30;
inline int TMTPeronalTemplate::invitemembers_size() const {
  return invitemembers_.size();
}
inline void TMTPeronalTemplate::clear_invitemembers() {
  invitemembers_.Clear();
}
inline const ::mt::TMTInviteMember& TMTPeronalTemplate::invitemembers(int index) const {
  return invitemembers_.Get(index);
}
inline ::mt::TMTInviteMember* TMTPeronalTemplate::mutable_invitemembers(int index) {
  return invitemembers_.Mutable(index);
}
inline ::mt::TMTInviteMember* TMTPeronalTemplate::add_invitemembers() {
  return invitemembers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >&
TMTPeronalTemplate::invitemembers() const {
  return invitemembers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >*
TMTPeronalTemplate::mutable_invitemembers() {
  return &invitemembers_;
}

// optional .mt.TMTConfVMPInfo vmp = 31;
inline bool TMTPeronalTemplate::has_vmp() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TMTPeronalTemplate::set_has_vmp() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TMTPeronalTemplate::clear_has_vmp() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TMTPeronalTemplate::clear_vmp() {
  if (vmp_ != NULL) vmp_->::mt::TMTConfVMPInfo::Clear();
  clear_has_vmp();
}
inline const ::mt::TMTConfVMPInfo& TMTPeronalTemplate::vmp() const {
  return vmp_ != NULL ? *vmp_ : *default_instance_->vmp_;
}
inline ::mt::TMTConfVMPInfo* TMTPeronalTemplate::mutable_vmp() {
  set_has_vmp();
  if (vmp_ == NULL) vmp_ = new ::mt::TMTConfVMPInfo;
  return vmp_;
}
inline ::mt::TMTConfVMPInfo* TMTPeronalTemplate::release_vmp() {
  clear_has_vmp();
  ::mt::TMTConfVMPInfo* temp = vmp_;
  vmp_ = NULL;
  return temp;
}
inline void TMTPeronalTemplate::set_allocated_vmp(::mt::TMTConfVMPInfo* vmp) {
  delete vmp_;
  vmp_ = vmp;
  if (vmp) {
    set_has_vmp();
  } else {
    clear_has_vmp();
  }
}

// repeated .mt.TMTTemplateMember viplist = 32;
inline int TMTPeronalTemplate::viplist_size() const {
  return viplist_.size();
}
inline void TMTPeronalTemplate::clear_viplist() {
  viplist_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTPeronalTemplate::viplist(int index) const {
  return viplist_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTPeronalTemplate::mutable_viplist(int index) {
  return viplist_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTPeronalTemplate::add_viplist() {
  return viplist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTPeronalTemplate::viplist() const {
  return viplist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTPeronalTemplate::mutable_viplist() {
  return &viplist_;
}

// optional .mt.TMTConfPollInfo poll = 33;
inline bool TMTPeronalTemplate::has_poll() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TMTPeronalTemplate::set_has_poll() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TMTPeronalTemplate::clear_has_poll() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TMTPeronalTemplate::clear_poll() {
  if (poll_ != NULL) poll_->::mt::TMTConfPollInfo::Clear();
  clear_has_poll();
}
inline const ::mt::TMTConfPollInfo& TMTPeronalTemplate::poll() const {
  return poll_ != NULL ? *poll_ : *default_instance_->poll_;
}
inline ::mt::TMTConfPollInfo* TMTPeronalTemplate::mutable_poll() {
  set_has_poll();
  if (poll_ == NULL) poll_ = new ::mt::TMTConfPollInfo;
  return poll_;
}
inline ::mt::TMTConfPollInfo* TMTPeronalTemplate::release_poll() {
  clear_has_poll();
  ::mt::TMTConfPollInfo* temp = poll_;
  poll_ = NULL;
  return temp;
}
inline void TMTPeronalTemplate::set_allocated_poll(::mt::TMTConfPollInfo* poll) {
  delete poll_;
  poll_ = poll;
  if (poll) {
    set_has_poll();
  } else {
    clear_has_poll();
  }
}

// optional string templateID = 34;
inline bool TMTPeronalTemplate::has_templateid() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TMTPeronalTemplate::set_has_templateid() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TMTPeronalTemplate::clear_has_templateid() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TMTPeronalTemplate::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTPeronalTemplate::templateid() const {
  return *templateid_;
}
inline void TMTPeronalTemplate::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTPeronalTemplate::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTPeronalTemplate::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPeronalTemplate::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTPeronalTemplate::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPeronalTemplate::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool encrypted_auth = 35;
inline bool TMTPeronalTemplate::has_encrypted_auth() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TMTPeronalTemplate::set_has_encrypted_auth() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TMTPeronalTemplate::clear_has_encrypted_auth() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TMTPeronalTemplate::clear_encrypted_auth() {
  encrypted_auth_ = false;
  clear_has_encrypted_auth();
}
inline bool TMTPeronalTemplate::encrypted_auth() const {
  return encrypted_auth_;
}
inline void TMTPeronalTemplate::set_encrypted_auth(bool value) {
  set_has_encrypted_auth();
  encrypted_auth_ = value;
}

// optional .mt.EmCallMode emCallMode = 36;
inline bool TMTPeronalTemplate::has_emcallmode() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TMTPeronalTemplate::set_has_emcallmode() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TMTPeronalTemplate::clear_has_emcallmode() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TMTPeronalTemplate::clear_emcallmode() {
  emcallmode_ = 0;
  clear_has_emcallmode();
}
inline ::mt::EmCallMode TMTPeronalTemplate::emcallmode() const {
  return static_cast< ::mt::EmCallMode >(emcallmode_);
}
inline void TMTPeronalTemplate::set_emcallmode(::mt::EmCallMode value) {
  assert(::mt::EmCallMode_IsValid(value));
  set_has_emcallmode();
  emcallmode_ = value;
}

// optional .mt.TMTRecordAttribute recordattr = 37;
inline bool TMTPeronalTemplate::has_recordattr() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TMTPeronalTemplate::set_has_recordattr() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TMTPeronalTemplate::clear_has_recordattr() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TMTPeronalTemplate::clear_recordattr() {
  if (recordattr_ != NULL) recordattr_->::mt::TMTRecordAttribute::Clear();
  clear_has_recordattr();
}
inline const ::mt::TMTRecordAttribute& TMTPeronalTemplate::recordattr() const {
  return recordattr_ != NULL ? *recordattr_ : *default_instance_->recordattr_;
}
inline ::mt::TMTRecordAttribute* TMTPeronalTemplate::mutable_recordattr() {
  set_has_recordattr();
  if (recordattr_ == NULL) recordattr_ = new ::mt::TMTRecordAttribute;
  return recordattr_;
}
inline ::mt::TMTRecordAttribute* TMTPeronalTemplate::release_recordattr() {
  clear_has_recordattr();
  ::mt::TMTRecordAttribute* temp = recordattr_;
  recordattr_ = NULL;
  return temp;
}
inline void TMTPeronalTemplate::set_allocated_recordattr(::mt::TMTRecordAttribute* recordattr) {
  delete recordattr_;
  recordattr_ = recordattr;
  if (recordattr) {
    set_has_recordattr();
  } else {
    clear_has_recordattr();
  }
}

// optional .mt.TMTDCSAttribute dcsattr = 38;
inline bool TMTPeronalTemplate::has_dcsattr() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void TMTPeronalTemplate::set_has_dcsattr() {
  _has_bits_[1] |= 0x00000020u;
}
inline void TMTPeronalTemplate::clear_has_dcsattr() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void TMTPeronalTemplate::clear_dcsattr() {
  if (dcsattr_ != NULL) dcsattr_->::mt::TMTDCSAttribute::Clear();
  clear_has_dcsattr();
}
inline const ::mt::TMTDCSAttribute& TMTPeronalTemplate::dcsattr() const {
  return dcsattr_ != NULL ? *dcsattr_ : *default_instance_->dcsattr_;
}
inline ::mt::TMTDCSAttribute* TMTPeronalTemplate::mutable_dcsattr() {
  set_has_dcsattr();
  if (dcsattr_ == NULL) dcsattr_ = new ::mt::TMTDCSAttribute;
  return dcsattr_;
}
inline ::mt::TMTDCSAttribute* TMTPeronalTemplate::release_dcsattr() {
  clear_has_dcsattr();
  ::mt::TMTDCSAttribute* temp = dcsattr_;
  dcsattr_ = NULL;
  return temp;
}
inline void TMTPeronalTemplate::set_allocated_dcsattr(::mt::TMTDCSAttribute* dcsattr) {
  delete dcsattr_;
  dcsattr_ = dcsattr;
  if (dcsattr) {
    set_has_dcsattr();
  } else {
    clear_has_dcsattr();
  }
}

// optional .mt.EmMtFecMode fecmode = 39;
inline bool TMTPeronalTemplate::has_fecmode() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void TMTPeronalTemplate::set_has_fecmode() {
  _has_bits_[1] |= 0x00000040u;
}
inline void TMTPeronalTemplate::clear_has_fecmode() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void TMTPeronalTemplate::clear_fecmode() {
  fecmode_ = 0;
  clear_has_fecmode();
}
inline ::mt::EmMtFecMode TMTPeronalTemplate::fecmode() const {
  return static_cast< ::mt::EmMtFecMode >(fecmode_);
}
inline void TMTPeronalTemplate::set_fecmode(::mt::EmMtFecMode value) {
  assert(::mt::EmMtFecMode_IsValid(value));
  set_has_fecmode();
  fecmode_ = value;
}

// optional bool mutefilter = 40;
inline bool TMTPeronalTemplate::has_mutefilter() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void TMTPeronalTemplate::set_has_mutefilter() {
  _has_bits_[1] |= 0x00000080u;
}
inline void TMTPeronalTemplate::clear_has_mutefilter() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void TMTPeronalTemplate::clear_mutefilter() {
  mutefilter_ = false;
  clear_has_mutefilter();
}
inline bool TMTPeronalTemplate::mutefilter() const {
  return mutefilter_;
}
inline void TMTPeronalTemplate::set_mutefilter(bool value) {
  set_has_mutefilter();
  mutefilter_ = value;
}

// optional bool doubleflow = 41;
inline bool TMTPeronalTemplate::has_doubleflow() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void TMTPeronalTemplate::set_has_doubleflow() {
  _has_bits_[1] |= 0x00000100u;
}
inline void TMTPeronalTemplate::clear_has_doubleflow() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void TMTPeronalTemplate::clear_doubleflow() {
  doubleflow_ = false;
  clear_has_doubleflow();
}
inline bool TMTPeronalTemplate::doubleflow() const {
  return doubleflow_;
}
inline void TMTPeronalTemplate::set_doubleflow(bool value) {
  set_has_doubleflow();
  doubleflow_ = value;
}

// optional uint32 duration = 42;
inline bool TMTPeronalTemplate::has_duration() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void TMTPeronalTemplate::set_has_duration() {
  _has_bits_[1] |= 0x00000200u;
}
inline void TMTPeronalTemplate::clear_has_duration() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void TMTPeronalTemplate::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTPeronalTemplate::duration() const {
  return duration_;
}
inline void TMTPeronalTemplate::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// repeated .mt.TMTTemplateMember keepcallingmembers = 43;
inline int TMTPeronalTemplate::keepcallingmembers_size() const {
  return keepcallingmembers_.size();
}
inline void TMTPeronalTemplate::clear_keepcallingmembers() {
  keepcallingmembers_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTPeronalTemplate::keepcallingmembers(int index) const {
  return keepcallingmembers_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTPeronalTemplate::mutable_keepcallingmembers(int index) {
  return keepcallingmembers_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTPeronalTemplate::add_keepcallingmembers() {
  return keepcallingmembers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTPeronalTemplate::keepcallingmembers() const {
  return keepcallingmembers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTPeronalTemplate::mutable_keepcallingmembers() {
  return &keepcallingmembers_;
}

// -------------------------------------------------------------------

// TMTPersonalTemplateMember

// optional string templateID = 1;
inline bool TMTPersonalTemplateMember::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPersonalTemplateMember::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPersonalTemplateMember::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTPersonalTemplateMember::templateid() const {
  return *templateid_;
}
inline void TMTPersonalTemplateMember::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTPersonalTemplateMember::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTPersonalTemplateMember::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPersonalTemplateMember::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTPersonalTemplateMember::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPersonalTemplateMember::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TMTPersonalTemplateMember::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPersonalTemplateMember::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPersonalTemplateMember::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTPersonalTemplateMember::name() const {
  return *name_;
}
inline void TMTPersonalTemplateMember::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPersonalTemplateMember::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPersonalTemplateMember::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPersonalTemplateMember::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTPersonalTemplateMember::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPersonalTemplateMember::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 bitrate = 3;
inline bool TMTPersonalTemplateMember::has_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPersonalTemplateMember::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPersonalTemplateMember::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTPersonalTemplateMember::bitrate() const {
  return bitrate_;
}
inline void TMTPersonalTemplateMember::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmClosedMeeting closeConf = 4;
inline bool TMTPersonalTemplateMember::has_closeconf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_closeconf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPersonalTemplateMember::clear_has_closeconf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPersonalTemplateMember::clear_closeconf() {
  closeconf_ = 0;
  clear_has_closeconf();
}
inline ::mt::EmClosedMeeting TMTPersonalTemplateMember::closeconf() const {
  return static_cast< ::mt::EmClosedMeeting >(closeconf_);
}
inline void TMTPersonalTemplateMember::set_closeconf(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closeconf();
  closeconf_ = value;
}

// optional .mt.EmMtOpenMode safeConf = 5;
inline bool TMTPersonalTemplateMember::has_safeconf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_safeconf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTPersonalTemplateMember::clear_has_safeconf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTPersonalTemplateMember::clear_safeconf() {
  safeconf_ = 1;
  clear_has_safeconf();
}
inline ::mt::EmMtOpenMode TMTPersonalTemplateMember::safeconf() const {
  return static_cast< ::mt::EmMtOpenMode >(safeconf_);
}
inline void TMTPersonalTemplateMember::set_safeconf(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_safeconf();
  safeconf_ = value;
}

// optional .mt.EmEncryptArithmetic encryptedtype = 6;
inline bool TMTPersonalTemplateMember::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTPersonalTemplateMember::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTPersonalTemplateMember::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTPersonalTemplateMember::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTPersonalTemplateMember::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional .mt.EmRestMeetingSafeType meetingtype = 7;
inline bool TMTPersonalTemplateMember::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTPersonalTemplateMember::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTPersonalTemplateMember::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTPersonalTemplateMember::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTPersonalTemplateMember::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional bool initmute = 8;
inline bool TMTPersonalTemplateMember::has_initmute() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_initmute() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTPersonalTemplateMember::clear_has_initmute() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTPersonalTemplateMember::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTPersonalTemplateMember::initmute() const {
  return initmute_;
}
inline void TMTPersonalTemplateMember::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional bool initSilence = 9;
inline bool TMTPersonalTemplateMember::has_initsilence() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_initsilence() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTPersonalTemplateMember::clear_has_initsilence() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTPersonalTemplateMember::clear_initsilence() {
  initsilence_ = false;
  clear_has_initsilence();
}
inline bool TMTPersonalTemplateMember::initsilence() const {
  return initsilence_;
}
inline void TMTPersonalTemplateMember::set_initsilence(bool value) {
  set_has_initsilence();
  initsilence_ = value;
}

// optional .mt.EmRestVideoQuality vidoQuality = 10;
inline bool TMTPersonalTemplateMember::has_vidoquality() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_vidoquality() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTPersonalTemplateMember::clear_has_vidoquality() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTPersonalTemplateMember::clear_vidoquality() {
  vidoquality_ = 0;
  clear_has_vidoquality();
}
inline ::mt::EmRestVideoQuality TMTPersonalTemplateMember::vidoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(vidoquality_);
}
inline void TMTPersonalTemplateMember::set_vidoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_vidoquality();
  vidoquality_ = value;
}

// optional uint32 oneReforming = 11;
inline bool TMTPersonalTemplateMember::has_onereforming() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_onereforming() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTPersonalTemplateMember::clear_has_onereforming() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTPersonalTemplateMember::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TMTPersonalTemplateMember::onereforming() const {
  return onereforming_;
}
inline void TMTPersonalTemplateMember::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional string encryptedkey = 12;
inline bool TMTPersonalTemplateMember::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTPersonalTemplateMember::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTPersonalTemplateMember::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTPersonalTemplateMember::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTPersonalTemplateMember::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPersonalTemplateMember::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTPersonalTemplateMember::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPersonalTemplateMember::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTPersonalTemplateMember::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPersonalTemplateMember::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestDualMode dualmode = 13;
inline bool TMTPersonalTemplateMember::has_dualmode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_dualmode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTPersonalTemplateMember::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTPersonalTemplateMember::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTPersonalTemplateMember::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTPersonalTemplateMember::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool voiceActivityDetection = 14;
inline bool TMTPersonalTemplateMember::has_voiceactivitydetection() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_voiceactivitydetection() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTPersonalTemplateMember::clear_has_voiceactivitydetection() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTPersonalTemplateMember::clear_voiceactivitydetection() {
  voiceactivitydetection_ = false;
  clear_has_voiceactivitydetection();
}
inline bool TMTPersonalTemplateMember::voiceactivitydetection() const {
  return voiceactivitydetection_;
}
inline void TMTPersonalTemplateMember::set_voiceactivitydetection(bool value) {
  set_has_voiceactivitydetection();
  voiceactivitydetection_ = value;
}

// optional bool publicConf = 15;
inline bool TMTPersonalTemplateMember::has_publicconf() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_publicconf() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTPersonalTemplateMember::clear_has_publicconf() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTPersonalTemplateMember::clear_publicconf() {
  publicconf_ = false;
  clear_has_publicconf();
}
inline bool TMTPersonalTemplateMember::publicconf() const {
  return publicconf_;
}
inline void TMTPersonalTemplateMember::set_publicconf(bool value) {
  set_has_publicconf();
  publicconf_ = value;
}

// optional .mt.EmMtResolution resolution = 16;
inline bool TMTPersonalTemplateMember::has_resolution() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_resolution() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTPersonalTemplateMember::clear_has_resolution() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTPersonalTemplateMember::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::mt::EmMtResolution TMTPersonalTemplateMember::resolution() const {
  return static_cast< ::mt::EmMtResolution >(resolution_);
}
inline void TMTPersonalTemplateMember::set_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_resolution();
  resolution_ = value;
}

// optional uint32 maxJoinMt = 17;
inline bool TMTPersonalTemplateMember::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTPersonalTemplateMember::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTPersonalTemplateMember::clear_maxjoinmt() {
  maxjoinmt_ = 0u;
  clear_has_maxjoinmt();
}
inline ::google::protobuf::uint32 TMTPersonalTemplateMember::maxjoinmt() const {
  return maxjoinmt_;
}
inline void TMTPersonalTemplateMember::set_maxjoinmt(::google::protobuf::uint32 value) {
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional bool encrypted_auth = 18;
inline bool TMTPersonalTemplateMember::has_encrypted_auth() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTPersonalTemplateMember::set_has_encrypted_auth() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTPersonalTemplateMember::clear_has_encrypted_auth() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTPersonalTemplateMember::clear_encrypted_auth() {
  encrypted_auth_ = false;
  clear_has_encrypted_auth();
}
inline bool TMTPersonalTemplateMember::encrypted_auth() const {
  return encrypted_auth_;
}
inline void TMTPersonalTemplateMember::set_encrypted_auth(bool value) {
  set_has_encrypted_auth();
  encrypted_auth_ = value;
}

// -------------------------------------------------------------------

// TMTPersonalTemplatesList

// optional uint32 dwCount = 1;
inline bool TMTPersonalTemplatesList::has_dwcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPersonalTemplatesList::set_has_dwcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPersonalTemplatesList::clear_has_dwcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPersonalTemplatesList::clear_dwcount() {
  dwcount_ = 0u;
  clear_has_dwcount();
}
inline ::google::protobuf::uint32 TMTPersonalTemplatesList::dwcount() const {
  return dwcount_;
}
inline void TMTPersonalTemplatesList::set_dwcount(::google::protobuf::uint32 value) {
  set_has_dwcount();
  dwcount_ = value;
}

// repeated .mt.TMTPersonalTemplateMember personalTemplateMember = 2;
inline int TMTPersonalTemplatesList::personaltemplatemember_size() const {
  return personaltemplatemember_.size();
}
inline void TMTPersonalTemplatesList::clear_personaltemplatemember() {
  personaltemplatemember_.Clear();
}
inline const ::mt::TMTPersonalTemplateMember& TMTPersonalTemplatesList::personaltemplatemember(int index) const {
  return personaltemplatemember_.Get(index);
}
inline ::mt::TMTPersonalTemplateMember* TMTPersonalTemplatesList::mutable_personaltemplatemember(int index) {
  return personaltemplatemember_.Mutable(index);
}
inline ::mt::TMTPersonalTemplateMember* TMTPersonalTemplatesList::add_personaltemplatemember() {
  return personaltemplatemember_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPersonalTemplateMember >&
TMTPersonalTemplatesList::personaltemplatemember() const {
  return personaltemplatemember_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPersonalTemplateMember >*
TMTPersonalTemplatesList::mutable_personaltemplatemember() {
  return &personaltemplatemember_;
}

// -------------------------------------------------------------------

// TMTSimplePeronalTemplate

// optional string templateID = 1;
inline bool TMTSimplePeronalTemplate::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTSimplePeronalTemplate::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTSimplePeronalTemplate::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTSimplePeronalTemplate::templateid() const {
  return *templateid_;
}
inline void TMTSimplePeronalTemplate::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTSimplePeronalTemplate::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTSimplePeronalTemplate::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTSimplePeronalTemplate::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTSimplePeronalTemplate::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTSimplePeronalTemplate::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TMTSimplePeronalTemplate::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTSimplePeronalTemplate::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTSimplePeronalTemplate::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTSimplePeronalTemplate::name() const {
  return *name_;
}
inline void TMTSimplePeronalTemplate::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTSimplePeronalTemplate::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTSimplePeronalTemplate::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTSimplePeronalTemplate::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTSimplePeronalTemplate::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTSimplePeronalTemplate::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 bitrate = 3;
inline bool TMTSimplePeronalTemplate::has_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTSimplePeronalTemplate::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTSimplePeronalTemplate::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTSimplePeronalTemplate::bitrate() const {
  return bitrate_;
}
inline void TMTSimplePeronalTemplate::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmClosedMeeting closeConf = 4;
inline bool TMTSimplePeronalTemplate::has_closeconf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_closeconf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTSimplePeronalTemplate::clear_has_closeconf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTSimplePeronalTemplate::clear_closeconf() {
  closeconf_ = 0;
  clear_has_closeconf();
}
inline ::mt::EmClosedMeeting TMTSimplePeronalTemplate::closeconf() const {
  return static_cast< ::mt::EmClosedMeeting >(closeconf_);
}
inline void TMTSimplePeronalTemplate::set_closeconf(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closeconf();
  closeconf_ = value;
}

// optional .mt.EmMtOpenMode safeConf = 5;
inline bool TMTSimplePeronalTemplate::has_safeconf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_safeconf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTSimplePeronalTemplate::clear_has_safeconf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTSimplePeronalTemplate::clear_safeconf() {
  safeconf_ = 1;
  clear_has_safeconf();
}
inline ::mt::EmMtOpenMode TMTSimplePeronalTemplate::safeconf() const {
  return static_cast< ::mt::EmMtOpenMode >(safeconf_);
}
inline void TMTSimplePeronalTemplate::set_safeconf(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_safeconf();
  safeconf_ = value;
}

// optional string password = 6;
inline bool TMTSimplePeronalTemplate::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTSimplePeronalTemplate::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTSimplePeronalTemplate::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTSimplePeronalTemplate::password() const {
  return *password_;
}
inline void TMTSimplePeronalTemplate::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTSimplePeronalTemplate::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTSimplePeronalTemplate::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTSimplePeronalTemplate::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTSimplePeronalTemplate::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTSimplePeronalTemplate::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmEncryptArithmetic encryptedtype = 7;
inline bool TMTSimplePeronalTemplate::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTSimplePeronalTemplate::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTSimplePeronalTemplate::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTSimplePeronalTemplate::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTSimplePeronalTemplate::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional .mt.EmRestMeetingSafeType meetingtype = 8;
inline bool TMTSimplePeronalTemplate::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTSimplePeronalTemplate::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTSimplePeronalTemplate::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTSimplePeronalTemplate::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTSimplePeronalTemplate::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional uint32 callTimes = 9;
inline bool TMTSimplePeronalTemplate::has_calltimes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_calltimes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTSimplePeronalTemplate::clear_has_calltimes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTSimplePeronalTemplate::clear_calltimes() {
  calltimes_ = 0u;
  clear_has_calltimes();
}
inline ::google::protobuf::uint32 TMTSimplePeronalTemplate::calltimes() const {
  return calltimes_;
}
inline void TMTSimplePeronalTemplate::set_calltimes(::google::protobuf::uint32 value) {
  set_has_calltimes();
  calltimes_ = value;
}

// optional uint32 callInterval = 10;
inline bool TMTSimplePeronalTemplate::has_callinterval() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_callinterval() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTSimplePeronalTemplate::clear_has_callinterval() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTSimplePeronalTemplate::clear_callinterval() {
  callinterval_ = 0u;
  clear_has_callinterval();
}
inline ::google::protobuf::uint32 TMTSimplePeronalTemplate::callinterval() const {
  return callinterval_;
}
inline void TMTSimplePeronalTemplate::set_callinterval(::google::protobuf::uint32 value) {
  set_has_callinterval();
  callinterval_ = value;
}

// optional bool callChase = 11;
inline bool TMTSimplePeronalTemplate::has_callchase() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_callchase() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTSimplePeronalTemplate::clear_has_callchase() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTSimplePeronalTemplate::clear_callchase() {
  callchase_ = false;
  clear_has_callchase();
}
inline bool TMTSimplePeronalTemplate::callchase() const {
  return callchase_;
}
inline void TMTSimplePeronalTemplate::set_callchase(bool value) {
  set_has_callchase();
  callchase_ = value;
}

// optional bool initmute = 12;
inline bool TMTSimplePeronalTemplate::has_initmute() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_initmute() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTSimplePeronalTemplate::clear_has_initmute() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTSimplePeronalTemplate::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTSimplePeronalTemplate::initmute() const {
  return initmute_;
}
inline void TMTSimplePeronalTemplate::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional bool initSilence = 13;
inline bool TMTSimplePeronalTemplate::has_initsilence() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_initsilence() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTSimplePeronalTemplate::clear_has_initsilence() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTSimplePeronalTemplate::clear_initsilence() {
  initsilence_ = false;
  clear_has_initsilence();
}
inline bool TMTSimplePeronalTemplate::initsilence() const {
  return initsilence_;
}
inline void TMTSimplePeronalTemplate::set_initsilence(bool value) {
  set_has_initsilence();
  initsilence_ = value;
}

// optional .mt.EmRestVideoQuality vidoQuality = 14;
inline bool TMTSimplePeronalTemplate::has_vidoquality() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_vidoquality() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTSimplePeronalTemplate::clear_has_vidoquality() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTSimplePeronalTemplate::clear_vidoquality() {
  vidoquality_ = 0;
  clear_has_vidoquality();
}
inline ::mt::EmRestVideoQuality TMTSimplePeronalTemplate::vidoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(vidoquality_);
}
inline void TMTSimplePeronalTemplate::set_vidoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_vidoquality();
  vidoquality_ = value;
}

// optional uint32 oneReforming = 15;
inline bool TMTSimplePeronalTemplate::has_onereforming() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_onereforming() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTSimplePeronalTemplate::clear_has_onereforming() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTSimplePeronalTemplate::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TMTSimplePeronalTemplate::onereforming() const {
  return onereforming_;
}
inline void TMTSimplePeronalTemplate::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional string encryptedkey = 16;
inline bool TMTSimplePeronalTemplate::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTSimplePeronalTemplate::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTSimplePeronalTemplate::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTSimplePeronalTemplate::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTSimplePeronalTemplate::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTSimplePeronalTemplate::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTSimplePeronalTemplate::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTSimplePeronalTemplate::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTSimplePeronalTemplate::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTSimplePeronalTemplate::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestDualMode dualmode = 17;
inline bool TMTSimplePeronalTemplate::has_dualmode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_dualmode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTSimplePeronalTemplate::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTSimplePeronalTemplate::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTSimplePeronalTemplate::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTSimplePeronalTemplate::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool voiceActivityDetection = 18;
inline bool TMTSimplePeronalTemplate::has_voiceactivitydetection() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_voiceactivitydetection() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTSimplePeronalTemplate::clear_has_voiceactivitydetection() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTSimplePeronalTemplate::clear_voiceactivitydetection() {
  voiceactivitydetection_ = false;
  clear_has_voiceactivitydetection();
}
inline bool TMTSimplePeronalTemplate::voiceactivitydetection() const {
  return voiceactivitydetection_;
}
inline void TMTSimplePeronalTemplate::set_voiceactivitydetection(bool value) {
  set_has_voiceactivitydetection();
  voiceactivitydetection_ = value;
}

// optional .mt.EmRestCascadeMode emCascadeMode = 19;
inline bool TMTSimplePeronalTemplate::has_emcascademode() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_emcascademode() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTSimplePeronalTemplate::clear_has_emcascademode() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTSimplePeronalTemplate::clear_emcascademode() {
  emcascademode_ = 0;
  clear_has_emcascademode();
}
inline ::mt::EmRestCascadeMode TMTSimplePeronalTemplate::emcascademode() const {
  return static_cast< ::mt::EmRestCascadeMode >(emcascademode_);
}
inline void TMTSimplePeronalTemplate::set_emcascademode(::mt::EmRestCascadeMode value) {
  assert(::mt::EmRestCascadeMode_IsValid(value));
  set_has_emcascademode();
  emcascademode_ = value;
}

// optional bool cascadeUpload = 20;
inline bool TMTSimplePeronalTemplate::has_cascadeupload() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_cascadeupload() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTSimplePeronalTemplate::clear_has_cascadeupload() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTSimplePeronalTemplate::clear_cascadeupload() {
  cascadeupload_ = false;
  clear_has_cascadeupload();
}
inline bool TMTSimplePeronalTemplate::cascadeupload() const {
  return cascadeupload_;
}
inline void TMTSimplePeronalTemplate::set_cascadeupload(bool value) {
  set_has_cascadeupload();
  cascadeupload_ = value;
}

// optional bool cascadeReturn = 21;
inline bool TMTSimplePeronalTemplate::has_cascadereturn() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_cascadereturn() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTSimplePeronalTemplate::clear_has_cascadereturn() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTSimplePeronalTemplate::clear_cascadereturn() {
  cascadereturn_ = false;
  clear_has_cascadereturn();
}
inline bool TMTSimplePeronalTemplate::cascadereturn() const {
  return cascadereturn_;
}
inline void TMTSimplePeronalTemplate::set_cascadereturn(bool value) {
  set_has_cascadereturn();
  cascadereturn_ = value;
}

// optional uint32 cascadeReturnPara = 22;
inline bool TMTSimplePeronalTemplate::has_cascadereturnpara() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_cascadereturnpara() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTSimplePeronalTemplate::clear_has_cascadereturnpara() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTSimplePeronalTemplate::clear_cascadereturnpara() {
  cascadereturnpara_ = 0u;
  clear_has_cascadereturnpara();
}
inline ::google::protobuf::uint32 TMTSimplePeronalTemplate::cascadereturnpara() const {
  return cascadereturnpara_;
}
inline void TMTSimplePeronalTemplate::set_cascadereturnpara(::google::protobuf::uint32 value) {
  set_has_cascadereturnpara();
  cascadereturnpara_ = value;
}

// optional uint32 maxJoinMt = 23;
inline bool TMTSimplePeronalTemplate::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTSimplePeronalTemplate::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTSimplePeronalTemplate::clear_maxjoinmt() {
  maxjoinmt_ = 0u;
  clear_has_maxjoinmt();
}
inline ::google::protobuf::uint32 TMTSimplePeronalTemplate::maxjoinmt() const {
  return maxjoinmt_;
}
inline void TMTSimplePeronalTemplate::set_maxjoinmt(::google::protobuf::uint32 value) {
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional uint32 inviteNum = 24;
inline bool TMTSimplePeronalTemplate::has_invitenum() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_invitenum() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTSimplePeronalTemplate::clear_has_invitenum() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTSimplePeronalTemplate::clear_invitenum() {
  invitenum_ = 0u;
  clear_has_invitenum();
}
inline ::google::protobuf::uint32 TMTSimplePeronalTemplate::invitenum() const {
  return invitenum_;
}
inline void TMTSimplePeronalTemplate::set_invitenum(::google::protobuf::uint32 value) {
  set_has_invitenum();
  invitenum_ = value;
}

// optional uint32 mixNum = 25;
inline bool TMTSimplePeronalTemplate::has_mixnum() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_mixnum() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTSimplePeronalTemplate::clear_has_mixnum() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTSimplePeronalTemplate::clear_mixnum() {
  mixnum_ = 0u;
  clear_has_mixnum();
}
inline ::google::protobuf::uint32 TMTSimplePeronalTemplate::mixnum() const {
  return mixnum_;
}
inline void TMTSimplePeronalTemplate::set_mixnum(::google::protobuf::uint32 value) {
  set_has_mixnum();
  mixnum_ = value;
}

// optional uint32 vmpNum = 26;
inline bool TMTSimplePeronalTemplate::has_vmpnum() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_vmpnum() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMTSimplePeronalTemplate::clear_has_vmpnum() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMTSimplePeronalTemplate::clear_vmpnum() {
  vmpnum_ = 0u;
  clear_has_vmpnum();
}
inline ::google::protobuf::uint32 TMTSimplePeronalTemplate::vmpnum() const {
  return vmpnum_;
}
inline void TMTSimplePeronalTemplate::set_vmpnum(::google::protobuf::uint32 value) {
  set_has_vmpnum();
  vmpnum_ = value;
}

// optional uint32 vipNum = 27;
inline bool TMTSimplePeronalTemplate::has_vipnum() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_vipnum() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMTSimplePeronalTemplate::clear_has_vipnum() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMTSimplePeronalTemplate::clear_vipnum() {
  vipnum_ = 0u;
  clear_has_vipnum();
}
inline ::google::protobuf::uint32 TMTSimplePeronalTemplate::vipnum() const {
  return vipnum_;
}
inline void TMTSimplePeronalTemplate::set_vipnum(::google::protobuf::uint32 value) {
  set_has_vipnum();
  vipnum_ = value;
}

// optional uint32 pollNum = 28;
inline bool TMTSimplePeronalTemplate::has_pollnum() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_pollnum() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTSimplePeronalTemplate::clear_has_pollnum() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTSimplePeronalTemplate::clear_pollnum() {
  pollnum_ = 0u;
  clear_has_pollnum();
}
inline ::google::protobuf::uint32 TMTSimplePeronalTemplate::pollnum() const {
  return pollnum_;
}
inline void TMTSimplePeronalTemplate::set_pollnum(::google::protobuf::uint32 value) {
  set_has_pollnum();
  pollnum_ = value;
}

// optional .mt.TMTTemplateMember speaker = 29;
inline bool TMTSimplePeronalTemplate::has_speaker() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_speaker() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMTSimplePeronalTemplate::clear_has_speaker() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMTSimplePeronalTemplate::clear_speaker() {
  if (speaker_ != NULL) speaker_->::mt::TMTTemplateMember::Clear();
  clear_has_speaker();
}
inline const ::mt::TMTTemplateMember& TMTSimplePeronalTemplate::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::mt::TMTTemplateMember* TMTSimplePeronalTemplate::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::mt::TMTTemplateMember;
  return speaker_;
}
inline ::mt::TMTTemplateMember* TMTSimplePeronalTemplate::release_speaker() {
  clear_has_speaker();
  ::mt::TMTTemplateMember* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void TMTSimplePeronalTemplate::set_allocated_speaker(::mt::TMTTemplateMember* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional .mt.TMTTemplateMember chairman = 30;
inline bool TMTSimplePeronalTemplate::has_chairman() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_chairman() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMTSimplePeronalTemplate::clear_has_chairman() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMTSimplePeronalTemplate::clear_chairman() {
  if (chairman_ != NULL) chairman_->::mt::TMTTemplateMember::Clear();
  clear_has_chairman();
}
inline const ::mt::TMTTemplateMember& TMTSimplePeronalTemplate::chairman() const {
  return chairman_ != NULL ? *chairman_ : *default_instance_->chairman_;
}
inline ::mt::TMTTemplateMember* TMTSimplePeronalTemplate::mutable_chairman() {
  set_has_chairman();
  if (chairman_ == NULL) chairman_ = new ::mt::TMTTemplateMember;
  return chairman_;
}
inline ::mt::TMTTemplateMember* TMTSimplePeronalTemplate::release_chairman() {
  clear_has_chairman();
  ::mt::TMTTemplateMember* temp = chairman_;
  chairman_ = NULL;
  return temp;
}
inline void TMTSimplePeronalTemplate::set_allocated_chairman(::mt::TMTTemplateMember* chairman) {
  delete chairman_;
  chairman_ = chairman;
  if (chairman) {
    set_has_chairman();
  } else {
    clear_has_chairman();
  }
}

// optional bool publicConf = 31;
inline bool TMTSimplePeronalTemplate::has_publicconf() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_publicconf() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TMTSimplePeronalTemplate::clear_has_publicconf() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TMTSimplePeronalTemplate::clear_publicconf() {
  publicconf_ = false;
  clear_has_publicconf();
}
inline bool TMTSimplePeronalTemplate::publicconf() const {
  return publicconf_;
}
inline void TMTSimplePeronalTemplate::set_publicconf(bool value) {
  set_has_publicconf();
  publicconf_ = value;
}

// repeated .mt.TMTVideoFormatList videoFormatList = 32;
inline int TMTSimplePeronalTemplate::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTSimplePeronalTemplate::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTSimplePeronalTemplate::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTSimplePeronalTemplate::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTSimplePeronalTemplate::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTSimplePeronalTemplate::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTSimplePeronalTemplate::mutable_videoformatlist() {
  return &videoformatlist_;
}

// optional .mt.EmCallMode emCallMode = 33;
inline bool TMTSimplePeronalTemplate::has_emcallmode() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_emcallmode() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TMTSimplePeronalTemplate::clear_has_emcallmode() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TMTSimplePeronalTemplate::clear_emcallmode() {
  emcallmode_ = 0;
  clear_has_emcallmode();
}
inline ::mt::EmCallMode TMTSimplePeronalTemplate::emcallmode() const {
  return static_cast< ::mt::EmCallMode >(emcallmode_);
}
inline void TMTSimplePeronalTemplate::set_emcallmode(::mt::EmCallMode value) {
  assert(::mt::EmCallMode_IsValid(value));
  set_has_emcallmode();
  emcallmode_ = value;
}

// optional .mt.EmMtFecMode fecmode = 34;
inline bool TMTSimplePeronalTemplate::has_fecmode() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_fecmode() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TMTSimplePeronalTemplate::clear_has_fecmode() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TMTSimplePeronalTemplate::clear_fecmode() {
  fecmode_ = 0;
  clear_has_fecmode();
}
inline ::mt::EmMtFecMode TMTSimplePeronalTemplate::fecmode() const {
  return static_cast< ::mt::EmMtFecMode >(fecmode_);
}
inline void TMTSimplePeronalTemplate::set_fecmode(::mt::EmMtFecMode value) {
  assert(::mt::EmMtFecMode_IsValid(value));
  set_has_fecmode();
  fecmode_ = value;
}

// optional bool mutefilter = 35;
inline bool TMTSimplePeronalTemplate::has_mutefilter() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_mutefilter() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TMTSimplePeronalTemplate::clear_has_mutefilter() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TMTSimplePeronalTemplate::clear_mutefilter() {
  mutefilter_ = false;
  clear_has_mutefilter();
}
inline bool TMTSimplePeronalTemplate::mutefilter() const {
  return mutefilter_;
}
inline void TMTSimplePeronalTemplate::set_mutefilter(bool value) {
  set_has_mutefilter();
  mutefilter_ = value;
}

// optional bool encrypted_auth = 36;
inline bool TMTSimplePeronalTemplate::has_encrypted_auth() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_encrypted_auth() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TMTSimplePeronalTemplate::clear_has_encrypted_auth() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TMTSimplePeronalTemplate::clear_encrypted_auth() {
  encrypted_auth_ = false;
  clear_has_encrypted_auth();
}
inline bool TMTSimplePeronalTemplate::encrypted_auth() const {
  return encrypted_auth_;
}
inline void TMTSimplePeronalTemplate::set_encrypted_auth(bool value) {
  set_has_encrypted_auth();
  encrypted_auth_ = value;
}

// optional bool doubleflow = 37;
inline bool TMTSimplePeronalTemplate::has_doubleflow() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TMTSimplePeronalTemplate::set_has_doubleflow() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TMTSimplePeronalTemplate::clear_has_doubleflow() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TMTSimplePeronalTemplate::clear_doubleflow() {
  doubleflow_ = false;
  clear_has_doubleflow();
}
inline bool TMTSimplePeronalTemplate::doubleflow() const {
  return doubleflow_;
}
inline void TMTSimplePeronalTemplate::set_doubleflow(bool value) {
  set_has_doubleflow();
  doubleflow_ = value;
}

// -------------------------------------------------------------------

// TMTPerInviteMemberList

// optional string templateID = 1;
inline bool TMTPerInviteMemberList::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPerInviteMemberList::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPerInviteMemberList::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPerInviteMemberList::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTPerInviteMemberList::templateid() const {
  return *templateid_;
}
inline void TMTPerInviteMemberList::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTPerInviteMemberList::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTPerInviteMemberList::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPerInviteMemberList::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTPerInviteMemberList::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPerInviteMemberList::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 count = 2;
inline bool TMTPerInviteMemberList::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPerInviteMemberList::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPerInviteMemberList::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPerInviteMemberList::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTPerInviteMemberList::count() const {
  return count_;
}
inline void TMTPerInviteMemberList::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTInviteMember inviteMembers = 3;
inline int TMTPerInviteMemberList::invitemembers_size() const {
  return invitemembers_.size();
}
inline void TMTPerInviteMemberList::clear_invitemembers() {
  invitemembers_.Clear();
}
inline const ::mt::TMTInviteMember& TMTPerInviteMemberList::invitemembers(int index) const {
  return invitemembers_.Get(index);
}
inline ::mt::TMTInviteMember* TMTPerInviteMemberList::mutable_invitemembers(int index) {
  return invitemembers_.Mutable(index);
}
inline ::mt::TMTInviteMember* TMTPerInviteMemberList::add_invitemembers() {
  return invitemembers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >&
TMTPerInviteMemberList::invitemembers() const {
  return invitemembers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >*
TMTPerInviteMemberList::mutable_invitemembers() {
  return &invitemembers_;
}

// -------------------------------------------------------------------

// TMTGetPerMixInfo

// optional string templateID = 1;
inline bool TMTGetPerMixInfo::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTGetPerMixInfo::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTGetPerMixInfo::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTGetPerMixInfo::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTGetPerMixInfo::templateid() const {
  return *templateid_;
}
inline void TMTGetPerMixInfo::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTGetPerMixInfo::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTGetPerMixInfo::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTGetPerMixInfo::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTGetPerMixInfo::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTGetPerMixInfo::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTConfMixInfo mix = 2;
inline bool TMTGetPerMixInfo::has_mix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTGetPerMixInfo::set_has_mix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTGetPerMixInfo::clear_has_mix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTGetPerMixInfo::clear_mix() {
  if (mix_ != NULL) mix_->::mt::TMTConfMixInfo::Clear();
  clear_has_mix();
}
inline const ::mt::TMTConfMixInfo& TMTGetPerMixInfo::mix() const {
  return mix_ != NULL ? *mix_ : *default_instance_->mix_;
}
inline ::mt::TMTConfMixInfo* TMTGetPerMixInfo::mutable_mix() {
  set_has_mix();
  if (mix_ == NULL) mix_ = new ::mt::TMTConfMixInfo;
  return mix_;
}
inline ::mt::TMTConfMixInfo* TMTGetPerMixInfo::release_mix() {
  clear_has_mix();
  ::mt::TMTConfMixInfo* temp = mix_;
  mix_ = NULL;
  return temp;
}
inline void TMTGetPerMixInfo::set_allocated_mix(::mt::TMTConfMixInfo* mix) {
  delete mix_;
  mix_ = mix;
  if (mix) {
    set_has_mix();
  } else {
    clear_has_mix();
  }
}

// -------------------------------------------------------------------

// TMTGetPerVMPInfo

// optional string templateID = 1;
inline bool TMTGetPerVMPInfo::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTGetPerVMPInfo::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTGetPerVMPInfo::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTGetPerVMPInfo::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTGetPerVMPInfo::templateid() const {
  return *templateid_;
}
inline void TMTGetPerVMPInfo::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTGetPerVMPInfo::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTGetPerVMPInfo::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTGetPerVMPInfo::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTGetPerVMPInfo::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTGetPerVMPInfo::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTConfVMPInfo VMP = 2;
inline bool TMTGetPerVMPInfo::has_vmp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTGetPerVMPInfo::set_has_vmp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTGetPerVMPInfo::clear_has_vmp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTGetPerVMPInfo::clear_vmp() {
  if (vmp_ != NULL) vmp_->::mt::TMTConfVMPInfo::Clear();
  clear_has_vmp();
}
inline const ::mt::TMTConfVMPInfo& TMTGetPerVMPInfo::vmp() const {
  return vmp_ != NULL ? *vmp_ : *default_instance_->vmp_;
}
inline ::mt::TMTConfVMPInfo* TMTGetPerVMPInfo::mutable_vmp() {
  set_has_vmp();
  if (vmp_ == NULL) vmp_ = new ::mt::TMTConfVMPInfo;
  return vmp_;
}
inline ::mt::TMTConfVMPInfo* TMTGetPerVMPInfo::release_vmp() {
  clear_has_vmp();
  ::mt::TMTConfVMPInfo* temp = vmp_;
  vmp_ = NULL;
  return temp;
}
inline void TMTGetPerVMPInfo::set_allocated_vmp(::mt::TMTConfVMPInfo* vmp) {
  delete vmp_;
  vmp_ = vmp;
  if (vmp) {
    set_has_vmp();
  } else {
    clear_has_vmp();
  }
}

// -------------------------------------------------------------------

// TMTGetPerPollInfo

// optional string templateID = 1;
inline bool TMTGetPerPollInfo::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTGetPerPollInfo::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTGetPerPollInfo::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTGetPerPollInfo::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTGetPerPollInfo::templateid() const {
  return *templateid_;
}
inline void TMTGetPerPollInfo::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTGetPerPollInfo::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTGetPerPollInfo::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTGetPerPollInfo::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTGetPerPollInfo::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTGetPerPollInfo::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTConfPollInfo poll = 2;
inline bool TMTGetPerPollInfo::has_poll() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTGetPerPollInfo::set_has_poll() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTGetPerPollInfo::clear_has_poll() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTGetPerPollInfo::clear_poll() {
  if (poll_ != NULL) poll_->::mt::TMTConfPollInfo::Clear();
  clear_has_poll();
}
inline const ::mt::TMTConfPollInfo& TMTGetPerPollInfo::poll() const {
  return poll_ != NULL ? *poll_ : *default_instance_->poll_;
}
inline ::mt::TMTConfPollInfo* TMTGetPerPollInfo::mutable_poll() {
  set_has_poll();
  if (poll_ == NULL) poll_ = new ::mt::TMTConfPollInfo;
  return poll_;
}
inline ::mt::TMTConfPollInfo* TMTGetPerPollInfo::release_poll() {
  clear_has_poll();
  ::mt::TMTConfPollInfo* temp = poll_;
  poll_ = NULL;
  return temp;
}
inline void TMTGetPerPollInfo::set_allocated_poll(::mt::TMTConfPollInfo* poll) {
  delete poll_;
  poll_ = poll;
  if (poll) {
    set_has_poll();
  } else {
    clear_has_poll();
  }
}

// -------------------------------------------------------------------

// TMTGetPerVIPInfo

// optional string templateID = 1;
inline bool TMTGetPerVIPInfo::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTGetPerVIPInfo::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTGetPerVIPInfo::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTGetPerVIPInfo::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTGetPerVIPInfo::templateid() const {
  return *templateid_;
}
inline void TMTGetPerVIPInfo::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTGetPerVIPInfo::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTGetPerVIPInfo::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTGetPerVIPInfo::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTGetPerVIPInfo::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTGetPerVIPInfo::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 dwCount = 2;
inline bool TMTGetPerVIPInfo::has_dwcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTGetPerVIPInfo::set_has_dwcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTGetPerVIPInfo::clear_has_dwcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTGetPerVIPInfo::clear_dwcount() {
  dwcount_ = 0u;
  clear_has_dwcount();
}
inline ::google::protobuf::uint32 TMTGetPerVIPInfo::dwcount() const {
  return dwcount_;
}
inline void TMTGetPerVIPInfo::set_dwcount(::google::protobuf::uint32 value) {
  set_has_dwcount();
  dwcount_ = value;
}

// repeated .mt.TMTTemplateMember vip = 3;
inline int TMTGetPerVIPInfo::vip_size() const {
  return vip_.size();
}
inline void TMTGetPerVIPInfo::clear_vip() {
  vip_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTGetPerVIPInfo::vip(int index) const {
  return vip_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTGetPerVIPInfo::mutable_vip(int index) {
  return vip_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTGetPerVIPInfo::add_vip() {
  return vip_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTGetPerVIPInfo::vip() const {
  return vip_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTGetPerVIPInfo::mutable_vip() {
  return &vip_;
}

// -------------------------------------------------------------------

// TMTGetPerTemplateInfo

// optional string templateID = 1;
inline bool TMTGetPerTemplateInfo::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTGetPerTemplateInfo::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTGetPerTemplateInfo::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTGetPerTemplateInfo::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTGetPerTemplateInfo::templateid() const {
  return *templateid_;
}
inline void TMTGetPerTemplateInfo::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTGetPerTemplateInfo::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTGetPerTemplateInfo::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTGetPerTemplateInfo::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTGetPerTemplateInfo::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTGetPerTemplateInfo::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 start = 2;
inline bool TMTGetPerTemplateInfo::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTGetPerTemplateInfo::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTGetPerTemplateInfo::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTGetPerTemplateInfo::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTGetPerTemplateInfo::start() const {
  return start_;
}
inline void TMTGetPerTemplateInfo::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 3;
inline bool TMTGetPerTemplateInfo::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTGetPerTemplateInfo::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTGetPerTemplateInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTGetPerTemplateInfo::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTGetPerTemplateInfo::count() const {
  return count_;
}
inline void TMTGetPerTemplateInfo::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 4;
inline bool TMTGetPerTemplateInfo::has_order() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTGetPerTemplateInfo::set_has_order() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTGetPerTemplateInfo::clear_has_order() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTGetPerTemplateInfo::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTGetPerTemplateInfo::order() const {
  return order_;
}
inline void TMTGetPerTemplateInfo::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// -------------------------------------------------------------------

// TMTCommonTemplate

// optional string templateID = 1;
inline bool TMTCommonTemplate::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCommonTemplate::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCommonTemplate::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCommonTemplate::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTCommonTemplate::templateid() const {
  return *templateid_;
}
inline void TMTCommonTemplate::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTCommonTemplate::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTCommonTemplate::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCommonTemplate::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTCommonTemplate::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCommonTemplate::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TMTCommonTemplate::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCommonTemplate::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCommonTemplate::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCommonTemplate::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTCommonTemplate::name() const {
  return *name_;
}
inline void TMTCommonTemplate::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTCommonTemplate::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTCommonTemplate::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCommonTemplate::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTCommonTemplate::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCommonTemplate::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 bitrate = 4;
inline bool TMTCommonTemplate::has_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTCommonTemplate::set_has_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTCommonTemplate::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTCommonTemplate::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTCommonTemplate::bitrate() const {
  return bitrate_;
}
inline void TMTCommonTemplate::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmClosedMeeting closeConf = 5;
inline bool TMTCommonTemplate::has_closeconf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTCommonTemplate::set_has_closeconf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTCommonTemplate::clear_has_closeconf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTCommonTemplate::clear_closeconf() {
  closeconf_ = 0;
  clear_has_closeconf();
}
inline ::mt::EmClosedMeeting TMTCommonTemplate::closeconf() const {
  return static_cast< ::mt::EmClosedMeeting >(closeconf_);
}
inline void TMTCommonTemplate::set_closeconf(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closeconf();
  closeconf_ = value;
}

// optional .mt.EmMtOpenMode safeConf = 6;
inline bool TMTCommonTemplate::has_safeconf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTCommonTemplate::set_has_safeconf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTCommonTemplate::clear_has_safeconf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTCommonTemplate::clear_safeconf() {
  safeconf_ = 1;
  clear_has_safeconf();
}
inline ::mt::EmMtOpenMode TMTCommonTemplate::safeconf() const {
  return static_cast< ::mt::EmMtOpenMode >(safeconf_);
}
inline void TMTCommonTemplate::set_safeconf(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_safeconf();
  safeconf_ = value;
}

// optional string password = 7;
inline bool TMTCommonTemplate::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTCommonTemplate::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTCommonTemplate::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTCommonTemplate::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTCommonTemplate::password() const {
  return *password_;
}
inline void TMTCommonTemplate::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTCommonTemplate::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTCommonTemplate::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCommonTemplate::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTCommonTemplate::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCommonTemplate::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmEncryptArithmetic encryptedtype = 8;
inline bool TMTCommonTemplate::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTCommonTemplate::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTCommonTemplate::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTCommonTemplate::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTCommonTemplate::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTCommonTemplate::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional .mt.EmRestMeetingSafeType meetingtype = 9;
inline bool TMTCommonTemplate::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTCommonTemplate::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTCommonTemplate::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTCommonTemplate::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTCommonTemplate::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTCommonTemplate::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional bool publicConf = 10;
inline bool TMTCommonTemplate::has_publicconf() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTCommonTemplate::set_has_publicconf() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTCommonTemplate::clear_has_publicconf() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTCommonTemplate::clear_publicconf() {
  publicconf_ = false;
  clear_has_publicconf();
}
inline bool TMTCommonTemplate::publicconf() const {
  return publicconf_;
}
inline void TMTCommonTemplate::set_publicconf(bool value) {
  set_has_publicconf();
  publicconf_ = value;
}

// optional uint32 callTimes = 11;
inline bool TMTCommonTemplate::has_calltimes() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTCommonTemplate::set_has_calltimes() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTCommonTemplate::clear_has_calltimes() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTCommonTemplate::clear_calltimes() {
  calltimes_ = 0u;
  clear_has_calltimes();
}
inline ::google::protobuf::uint32 TMTCommonTemplate::calltimes() const {
  return calltimes_;
}
inline void TMTCommonTemplate::set_calltimes(::google::protobuf::uint32 value) {
  set_has_calltimes();
  calltimes_ = value;
}

// optional uint32 callInterval = 12;
inline bool TMTCommonTemplate::has_callinterval() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTCommonTemplate::set_has_callinterval() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTCommonTemplate::clear_has_callinterval() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTCommonTemplate::clear_callinterval() {
  callinterval_ = 0u;
  clear_has_callinterval();
}
inline ::google::protobuf::uint32 TMTCommonTemplate::callinterval() const {
  return callinterval_;
}
inline void TMTCommonTemplate::set_callinterval(::google::protobuf::uint32 value) {
  set_has_callinterval();
  callinterval_ = value;
}

// optional bool initmute = 13;
inline bool TMTCommonTemplate::has_initmute() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTCommonTemplate::set_has_initmute() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTCommonTemplate::clear_has_initmute() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTCommonTemplate::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTCommonTemplate::initmute() const {
  return initmute_;
}
inline void TMTCommonTemplate::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional bool initSilence = 14;
inline bool TMTCommonTemplate::has_initsilence() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTCommonTemplate::set_has_initsilence() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTCommonTemplate::clear_has_initsilence() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTCommonTemplate::clear_initsilence() {
  initsilence_ = false;
  clear_has_initsilence();
}
inline bool TMTCommonTemplate::initsilence() const {
  return initsilence_;
}
inline void TMTCommonTemplate::set_initsilence(bool value) {
  set_has_initsilence();
  initsilence_ = value;
}

// optional .mt.EmRestVideoQuality vidoQuality = 15;
inline bool TMTCommonTemplate::has_vidoquality() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTCommonTemplate::set_has_vidoquality() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTCommonTemplate::clear_has_vidoquality() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTCommonTemplate::clear_vidoquality() {
  vidoquality_ = 0;
  clear_has_vidoquality();
}
inline ::mt::EmRestVideoQuality TMTCommonTemplate::vidoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(vidoquality_);
}
inline void TMTCommonTemplate::set_vidoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_vidoquality();
  vidoquality_ = value;
}

// optional uint32 oneReforming = 16;
inline bool TMTCommonTemplate::has_onereforming() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTCommonTemplate::set_has_onereforming() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTCommonTemplate::clear_has_onereforming() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTCommonTemplate::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TMTCommonTemplate::onereforming() const {
  return onereforming_;
}
inline void TMTCommonTemplate::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional string encryptedkey = 17;
inline bool TMTCommonTemplate::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTCommonTemplate::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTCommonTemplate::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTCommonTemplate::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTCommonTemplate::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTCommonTemplate::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTCommonTemplate::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTCommonTemplate::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCommonTemplate::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTCommonTemplate::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCommonTemplate::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestDualMode dualmode = 18;
inline bool TMTCommonTemplate::has_dualmode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTCommonTemplate::set_has_dualmode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTCommonTemplate::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTCommonTemplate::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTCommonTemplate::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTCommonTemplate::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool voiceActivityDetection = 19;
inline bool TMTCommonTemplate::has_voiceactivitydetection() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTCommonTemplate::set_has_voiceactivitydetection() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTCommonTemplate::clear_has_voiceactivitydetection() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTCommonTemplate::clear_voiceactivitydetection() {
  voiceactivitydetection_ = false;
  clear_has_voiceactivitydetection();
}
inline bool TMTCommonTemplate::voiceactivitydetection() const {
  return voiceactivitydetection_;
}
inline void TMTCommonTemplate::set_voiceactivitydetection(bool value) {
  set_has_voiceactivitydetection();
  voiceactivitydetection_ = value;
}

// optional .mt.EmRestCascadeMode emCascadeMode = 20;
inline bool TMTCommonTemplate::has_emcascademode() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTCommonTemplate::set_has_emcascademode() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTCommonTemplate::clear_has_emcascademode() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTCommonTemplate::clear_emcascademode() {
  emcascademode_ = 0;
  clear_has_emcascademode();
}
inline ::mt::EmRestCascadeMode TMTCommonTemplate::emcascademode() const {
  return static_cast< ::mt::EmRestCascadeMode >(emcascademode_);
}
inline void TMTCommonTemplate::set_emcascademode(::mt::EmRestCascadeMode value) {
  assert(::mt::EmRestCascadeMode_IsValid(value));
  set_has_emcascademode();
  emcascademode_ = value;
}

// optional bool cascadeUpload = 21;
inline bool TMTCommonTemplate::has_cascadeupload() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTCommonTemplate::set_has_cascadeupload() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTCommonTemplate::clear_has_cascadeupload() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTCommonTemplate::clear_cascadeupload() {
  cascadeupload_ = false;
  clear_has_cascadeupload();
}
inline bool TMTCommonTemplate::cascadeupload() const {
  return cascadeupload_;
}
inline void TMTCommonTemplate::set_cascadeupload(bool value) {
  set_has_cascadeupload();
  cascadeupload_ = value;
}

// optional bool cascadeReturn = 22;
inline bool TMTCommonTemplate::has_cascadereturn() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTCommonTemplate::set_has_cascadereturn() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTCommonTemplate::clear_has_cascadereturn() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTCommonTemplate::clear_cascadereturn() {
  cascadereturn_ = false;
  clear_has_cascadereturn();
}
inline bool TMTCommonTemplate::cascadereturn() const {
  return cascadereturn_;
}
inline void TMTCommonTemplate::set_cascadereturn(bool value) {
  set_has_cascadereturn();
  cascadereturn_ = value;
}

// optional uint32 cascadeReturnPara = 23;
inline bool TMTCommonTemplate::has_cascadereturnpara() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTCommonTemplate::set_has_cascadereturnpara() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTCommonTemplate::clear_has_cascadereturnpara() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTCommonTemplate::clear_cascadereturnpara() {
  cascadereturnpara_ = 0u;
  clear_has_cascadereturnpara();
}
inline ::google::protobuf::uint32 TMTCommonTemplate::cascadereturnpara() const {
  return cascadereturnpara_;
}
inline void TMTCommonTemplate::set_cascadereturnpara(::google::protobuf::uint32 value) {
  set_has_cascadereturnpara();
  cascadereturnpara_ = value;
}

// optional uint32 maxJoinMt = 24;
inline bool TMTCommonTemplate::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTCommonTemplate::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTCommonTemplate::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTCommonTemplate::clear_maxjoinmt() {
  maxjoinmt_ = 0u;
  clear_has_maxjoinmt();
}
inline ::google::protobuf::uint32 TMTCommonTemplate::maxjoinmt() const {
  return maxjoinmt_;
}
inline void TMTCommonTemplate::set_maxjoinmt(::google::protobuf::uint32 value) {
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional bool autoEnd = 25;
inline bool TMTCommonTemplate::has_autoend() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTCommonTemplate::set_has_autoend() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTCommonTemplate::clear_has_autoend() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTCommonTemplate::clear_autoend() {
  autoend_ = false;
  clear_has_autoend();
}
inline bool TMTCommonTemplate::autoend() const {
  return autoend_;
}
inline void TMTCommonTemplate::set_autoend(bool value) {
  set_has_autoend();
  autoend_ = value;
}

// optional bool preoccpuyResouce = 26;
inline bool TMTCommonTemplate::has_preoccpuyresouce() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTCommonTemplate::set_has_preoccpuyresouce() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTCommonTemplate::clear_has_preoccpuyresouce() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTCommonTemplate::clear_preoccpuyresouce() {
  preoccpuyresouce_ = false;
  clear_has_preoccpuyresouce();
}
inline bool TMTCommonTemplate::preoccpuyresouce() const {
  return preoccpuyresouce_;
}
inline void TMTCommonTemplate::set_preoccpuyresouce(bool value) {
  set_has_preoccpuyresouce();
  preoccpuyresouce_ = value;
}

// repeated .mt.TMTVideoFormatList videoFormatList = 27;
inline int TMTCommonTemplate::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTCommonTemplate::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTCommonTemplate::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTCommonTemplate::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTCommonTemplate::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTCommonTemplate::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTCommonTemplate::mutable_videoformatlist() {
  return &videoformatlist_;
}

// optional uint32 vacinterval = 28;
inline bool TMTCommonTemplate::has_vacinterval() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMTCommonTemplate::set_has_vacinterval() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMTCommonTemplate::clear_has_vacinterval() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMTCommonTemplate::clear_vacinterval() {
  vacinterval_ = 0u;
  clear_has_vacinterval();
}
inline ::google::protobuf::uint32 TMTCommonTemplate::vacinterval() const {
  return vacinterval_;
}
inline void TMTCommonTemplate::set_vacinterval(::google::protobuf::uint32 value) {
  set_has_vacinterval();
  vacinterval_ = value;
}

// optional bool encrypted_auth = 29;
inline bool TMTCommonTemplate::has_encrypted_auth() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTCommonTemplate::set_has_encrypted_auth() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTCommonTemplate::clear_has_encrypted_auth() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTCommonTemplate::clear_encrypted_auth() {
  encrypted_auth_ = false;
  clear_has_encrypted_auth();
}
inline bool TMTCommonTemplate::encrypted_auth() const {
  return encrypted_auth_;
}
inline void TMTCommonTemplate::set_encrypted_auth(bool value) {
  set_has_encrypted_auth();
  encrypted_auth_ = value;
}

// optional .mt.TMTDCSAttribute dcsattr = 30;
inline bool TMTCommonTemplate::has_dcsattr() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMTCommonTemplate::set_has_dcsattr() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMTCommonTemplate::clear_has_dcsattr() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMTCommonTemplate::clear_dcsattr() {
  if (dcsattr_ != NULL) dcsattr_->::mt::TMTDCSAttribute::Clear();
  clear_has_dcsattr();
}
inline const ::mt::TMTDCSAttribute& TMTCommonTemplate::dcsattr() const {
  return dcsattr_ != NULL ? *dcsattr_ : *default_instance_->dcsattr_;
}
inline ::mt::TMTDCSAttribute* TMTCommonTemplate::mutable_dcsattr() {
  set_has_dcsattr();
  if (dcsattr_ == NULL) dcsattr_ = new ::mt::TMTDCSAttribute;
  return dcsattr_;
}
inline ::mt::TMTDCSAttribute* TMTCommonTemplate::release_dcsattr() {
  clear_has_dcsattr();
  ::mt::TMTDCSAttribute* temp = dcsattr_;
  dcsattr_ = NULL;
  return temp;
}
inline void TMTCommonTemplate::set_allocated_dcsattr(::mt::TMTDCSAttribute* dcsattr) {
  delete dcsattr_;
  dcsattr_ = dcsattr;
  if (dcsattr) {
    set_has_dcsattr();
  } else {
    clear_has_dcsattr();
  }
}

// optional .mt.EmMtFecMode fecmode = 31;
inline bool TMTCommonTemplate::has_fecmode() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMTCommonTemplate::set_has_fecmode() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMTCommonTemplate::clear_has_fecmode() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMTCommonTemplate::clear_fecmode() {
  fecmode_ = 0;
  clear_has_fecmode();
}
inline ::mt::EmMtFecMode TMTCommonTemplate::fecmode() const {
  return static_cast< ::mt::EmMtFecMode >(fecmode_);
}
inline void TMTCommonTemplate::set_fecmode(::mt::EmMtFecMode value) {
  assert(::mt::EmMtFecMode_IsValid(value));
  set_has_fecmode();
  fecmode_ = value;
}

// optional .mt.TMTConfVMPBrief vmp = 32;
inline bool TMTCommonTemplate::has_vmp() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TMTCommonTemplate::set_has_vmp() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TMTCommonTemplate::clear_has_vmp() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TMTCommonTemplate::clear_vmp() {
  if (vmp_ != NULL) vmp_->::mt::TMTConfVMPBrief::Clear();
  clear_has_vmp();
}
inline const ::mt::TMTConfVMPBrief& TMTCommonTemplate::vmp() const {
  return vmp_ != NULL ? *vmp_ : *default_instance_->vmp_;
}
inline ::mt::TMTConfVMPBrief* TMTCommonTemplate::mutable_vmp() {
  set_has_vmp();
  if (vmp_ == NULL) vmp_ = new ::mt::TMTConfVMPBrief;
  return vmp_;
}
inline ::mt::TMTConfVMPBrief* TMTCommonTemplate::release_vmp() {
  clear_has_vmp();
  ::mt::TMTConfVMPBrief* temp = vmp_;
  vmp_ = NULL;
  return temp;
}
inline void TMTCommonTemplate::set_allocated_vmp(::mt::TMTConfVMPBrief* vmp) {
  delete vmp_;
  vmp_ = vmp;
  if (vmp) {
    set_has_vmp();
  } else {
    clear_has_vmp();
  }
}

// optional .mt.TMTConfMixBrief mix = 33;
inline bool TMTCommonTemplate::has_mix() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TMTCommonTemplate::set_has_mix() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TMTCommonTemplate::clear_has_mix() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TMTCommonTemplate::clear_mix() {
  if (mix_ != NULL) mix_->::mt::TMTConfMixBrief::Clear();
  clear_has_mix();
}
inline const ::mt::TMTConfMixBrief& TMTCommonTemplate::mix() const {
  return mix_ != NULL ? *mix_ : *default_instance_->mix_;
}
inline ::mt::TMTConfMixBrief* TMTCommonTemplate::mutable_mix() {
  set_has_mix();
  if (mix_ == NULL) mix_ = new ::mt::TMTConfMixBrief;
  return mix_;
}
inline ::mt::TMTConfMixBrief* TMTCommonTemplate::release_mix() {
  clear_has_mix();
  ::mt::TMTConfMixBrief* temp = mix_;
  mix_ = NULL;
  return temp;
}
inline void TMTCommonTemplate::set_allocated_mix(::mt::TMTConfMixBrief* mix) {
  delete mix_;
  mix_ = mix;
  if (mix) {
    set_has_mix();
  } else {
    clear_has_mix();
  }
}

// optional bool mutefilter = 34;
inline bool TMTCommonTemplate::has_mutefilter() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TMTCommonTemplate::set_has_mutefilter() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TMTCommonTemplate::clear_has_mutefilter() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TMTCommonTemplate::clear_mutefilter() {
  mutefilter_ = false;
  clear_has_mutefilter();
}
inline bool TMTCommonTemplate::mutefilter() const {
  return mutefilter_;
}
inline void TMTCommonTemplate::set_mutefilter(bool value) {
  set_has_mutefilter();
  mutefilter_ = value;
}

// optional bool doubleflow = 35;
inline bool TMTCommonTemplate::has_doubleflow() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TMTCommonTemplate::set_has_doubleflow() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TMTCommonTemplate::clear_has_doubleflow() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TMTCommonTemplate::clear_doubleflow() {
  doubleflow_ = false;
  clear_has_doubleflow();
}
inline bool TMTCommonTemplate::doubleflow() const {
  return doubleflow_;
}
inline void TMTCommonTemplate::set_doubleflow(bool value) {
  set_has_doubleflow();
  doubleflow_ = value;
}

// optional uint32 duration = 36;
inline bool TMTCommonTemplate::has_duration() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TMTCommonTemplate::set_has_duration() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TMTCommonTemplate::clear_has_duration() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TMTCommonTemplate::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTCommonTemplate::duration() const {
  return duration_;
}
inline void TMTCommonTemplate::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional .mt.EmCallMode emCallMode = 37;
inline bool TMTCommonTemplate::has_emcallmode() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TMTCommonTemplate::set_has_emcallmode() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TMTCommonTemplate::clear_has_emcallmode() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TMTCommonTemplate::clear_emcallmode() {
  emcallmode_ = 0;
  clear_has_emcallmode();
}
inline ::mt::EmCallMode TMTCommonTemplate::emcallmode() const {
  return static_cast< ::mt::EmCallMode >(emcallmode_);
}
inline void TMTCommonTemplate::set_emcallmode(::mt::EmCallMode value) {
  assert(::mt::EmCallMode_IsValid(value));
  set_has_emcallmode();
  emcallmode_ = value;
}

// optional .mt.TMTRecordAttributeBrief recordattr = 38;
inline bool TMTCommonTemplate::has_recordattr() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TMTCommonTemplate::set_has_recordattr() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TMTCommonTemplate::clear_has_recordattr() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TMTCommonTemplate::clear_recordattr() {
  if (recordattr_ != NULL) recordattr_->::mt::TMTRecordAttributeBrief::Clear();
  clear_has_recordattr();
}
inline const ::mt::TMTRecordAttributeBrief& TMTCommonTemplate::recordattr() const {
  return recordattr_ != NULL ? *recordattr_ : *default_instance_->recordattr_;
}
inline ::mt::TMTRecordAttributeBrief* TMTCommonTemplate::mutable_recordattr() {
  set_has_recordattr();
  if (recordattr_ == NULL) recordattr_ = new ::mt::TMTRecordAttributeBrief;
  return recordattr_;
}
inline ::mt::TMTRecordAttributeBrief* TMTCommonTemplate::release_recordattr() {
  clear_has_recordattr();
  ::mt::TMTRecordAttributeBrief* temp = recordattr_;
  recordattr_ = NULL;
  return temp;
}
inline void TMTCommonTemplate::set_allocated_recordattr(::mt::TMTRecordAttributeBrief* recordattr) {
  delete recordattr_;
  recordattr_ = recordattr;
  if (recordattr) {
    set_has_recordattr();
  } else {
    clear_has_recordattr();
  }
}

// -------------------------------------------------------------------

// TMTCommonTemplateMember

// optional string templateID = 1;
inline bool TMTCommonTemplateMember::has_templateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCommonTemplateMember::set_has_templateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCommonTemplateMember::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCommonTemplateMember::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTCommonTemplateMember::templateid() const {
  return *templateid_;
}
inline void TMTCommonTemplateMember::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTCommonTemplateMember::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTCommonTemplateMember::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCommonTemplateMember::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTCommonTemplateMember::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCommonTemplateMember::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TMTCommonTemplateMember::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCommonTemplateMember::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCommonTemplateMember::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCommonTemplateMember::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTCommonTemplateMember::name() const {
  return *name_;
}
inline void TMTCommonTemplateMember::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTCommonTemplateMember::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTCommonTemplateMember::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCommonTemplateMember::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTCommonTemplateMember::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCommonTemplateMember::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 bitrate = 3;
inline bool TMTCommonTemplateMember::has_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTCommonTemplateMember::set_has_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTCommonTemplateMember::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTCommonTemplateMember::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTCommonTemplateMember::bitrate() const {
  return bitrate_;
}
inline void TMTCommonTemplateMember::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmClosedMeeting closeConf = 4;
inline bool TMTCommonTemplateMember::has_closeconf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTCommonTemplateMember::set_has_closeconf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTCommonTemplateMember::clear_has_closeconf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTCommonTemplateMember::clear_closeconf() {
  closeconf_ = 0;
  clear_has_closeconf();
}
inline ::mt::EmClosedMeeting TMTCommonTemplateMember::closeconf() const {
  return static_cast< ::mt::EmClosedMeeting >(closeconf_);
}
inline void TMTCommonTemplateMember::set_closeconf(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closeconf();
  closeconf_ = value;
}

// optional .mt.EmMtOpenMode safeConf = 5;
inline bool TMTCommonTemplateMember::has_safeconf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTCommonTemplateMember::set_has_safeconf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTCommonTemplateMember::clear_has_safeconf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTCommonTemplateMember::clear_safeconf() {
  safeconf_ = 1;
  clear_has_safeconf();
}
inline ::mt::EmMtOpenMode TMTCommonTemplateMember::safeconf() const {
  return static_cast< ::mt::EmMtOpenMode >(safeconf_);
}
inline void TMTCommonTemplateMember::set_safeconf(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_safeconf();
  safeconf_ = value;
}

// optional .mt.EmEncryptArithmetic encryptedtype = 6;
inline bool TMTCommonTemplateMember::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTCommonTemplateMember::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTCommonTemplateMember::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTCommonTemplateMember::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTCommonTemplateMember::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTCommonTemplateMember::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional .mt.EmRestMeetingSafeType meetingtype = 7;
inline bool TMTCommonTemplateMember::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTCommonTemplateMember::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTCommonTemplateMember::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTCommonTemplateMember::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTCommonTemplateMember::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTCommonTemplateMember::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional bool initmute = 8;
inline bool TMTCommonTemplateMember::has_initmute() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTCommonTemplateMember::set_has_initmute() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTCommonTemplateMember::clear_has_initmute() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTCommonTemplateMember::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTCommonTemplateMember::initmute() const {
  return initmute_;
}
inline void TMTCommonTemplateMember::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional bool initSilence = 9;
inline bool TMTCommonTemplateMember::has_initsilence() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTCommonTemplateMember::set_has_initsilence() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTCommonTemplateMember::clear_has_initsilence() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTCommonTemplateMember::clear_initsilence() {
  initsilence_ = false;
  clear_has_initsilence();
}
inline bool TMTCommonTemplateMember::initsilence() const {
  return initsilence_;
}
inline void TMTCommonTemplateMember::set_initsilence(bool value) {
  set_has_initsilence();
  initsilence_ = value;
}

// optional .mt.EmRestVideoQuality vidoQuality = 10;
inline bool TMTCommonTemplateMember::has_vidoquality() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTCommonTemplateMember::set_has_vidoquality() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTCommonTemplateMember::clear_has_vidoquality() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTCommonTemplateMember::clear_vidoquality() {
  vidoquality_ = 0;
  clear_has_vidoquality();
}
inline ::mt::EmRestVideoQuality TMTCommonTemplateMember::vidoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(vidoquality_);
}
inline void TMTCommonTemplateMember::set_vidoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_vidoquality();
  vidoquality_ = value;
}

// optional uint32 oneReforming = 11;
inline bool TMTCommonTemplateMember::has_onereforming() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTCommonTemplateMember::set_has_onereforming() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTCommonTemplateMember::clear_has_onereforming() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTCommonTemplateMember::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TMTCommonTemplateMember::onereforming() const {
  return onereforming_;
}
inline void TMTCommonTemplateMember::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional string encryptedkey = 12;
inline bool TMTCommonTemplateMember::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTCommonTemplateMember::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTCommonTemplateMember::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTCommonTemplateMember::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTCommonTemplateMember::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTCommonTemplateMember::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTCommonTemplateMember::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTCommonTemplateMember::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCommonTemplateMember::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTCommonTemplateMember::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCommonTemplateMember::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestDualMode dualmode = 13;
inline bool TMTCommonTemplateMember::has_dualmode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTCommonTemplateMember::set_has_dualmode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTCommonTemplateMember::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTCommonTemplateMember::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTCommonTemplateMember::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTCommonTemplateMember::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool voiceActivityDetection = 14;
inline bool TMTCommonTemplateMember::has_voiceactivitydetection() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTCommonTemplateMember::set_has_voiceactivitydetection() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTCommonTemplateMember::clear_has_voiceactivitydetection() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTCommonTemplateMember::clear_voiceactivitydetection() {
  voiceactivitydetection_ = false;
  clear_has_voiceactivitydetection();
}
inline bool TMTCommonTemplateMember::voiceactivitydetection() const {
  return voiceactivitydetection_;
}
inline void TMTCommonTemplateMember::set_voiceactivitydetection(bool value) {
  set_has_voiceactivitydetection();
  voiceactivitydetection_ = value;
}

// optional bool publicConf = 15;
inline bool TMTCommonTemplateMember::has_publicconf() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTCommonTemplateMember::set_has_publicconf() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTCommonTemplateMember::clear_has_publicconf() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTCommonTemplateMember::clear_publicconf() {
  publicconf_ = false;
  clear_has_publicconf();
}
inline bool TMTCommonTemplateMember::publicconf() const {
  return publicconf_;
}
inline void TMTCommonTemplateMember::set_publicconf(bool value) {
  set_has_publicconf();
  publicconf_ = value;
}

// optional .mt.EmMtResolution resolution = 16;
inline bool TMTCommonTemplateMember::has_resolution() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTCommonTemplateMember::set_has_resolution() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTCommonTemplateMember::clear_has_resolution() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTCommonTemplateMember::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::mt::EmMtResolution TMTCommonTemplateMember::resolution() const {
  return static_cast< ::mt::EmMtResolution >(resolution_);
}
inline void TMTCommonTemplateMember::set_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_resolution();
  resolution_ = value;
}

// optional uint32 maxJoinMt = 17;
inline bool TMTCommonTemplateMember::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTCommonTemplateMember::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTCommonTemplateMember::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTCommonTemplateMember::clear_maxjoinmt() {
  maxjoinmt_ = 0u;
  clear_has_maxjoinmt();
}
inline ::google::protobuf::uint32 TMTCommonTemplateMember::maxjoinmt() const {
  return maxjoinmt_;
}
inline void TMTCommonTemplateMember::set_maxjoinmt(::google::protobuf::uint32 value) {
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional bool encrypted_auth = 18;
inline bool TMTCommonTemplateMember::has_encrypted_auth() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTCommonTemplateMember::set_has_encrypted_auth() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTCommonTemplateMember::clear_has_encrypted_auth() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTCommonTemplateMember::clear_encrypted_auth() {
  encrypted_auth_ = false;
  clear_has_encrypted_auth();
}
inline bool TMTCommonTemplateMember::encrypted_auth() const {
  return encrypted_auth_;
}
inline void TMTCommonTemplateMember::set_encrypted_auth(bool value) {
  set_has_encrypted_auth();
  encrypted_auth_ = value;
}

// -------------------------------------------------------------------

// TMTCommonTemplatesList

// optional uint32 dwCount = 1;
inline bool TMTCommonTemplatesList::has_dwcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCommonTemplatesList::set_has_dwcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCommonTemplatesList::clear_has_dwcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCommonTemplatesList::clear_dwcount() {
  dwcount_ = 0u;
  clear_has_dwcount();
}
inline ::google::protobuf::uint32 TMTCommonTemplatesList::dwcount() const {
  return dwcount_;
}
inline void TMTCommonTemplatesList::set_dwcount(::google::protobuf::uint32 value) {
  set_has_dwcount();
  dwcount_ = value;
}

// repeated .mt.TMTCommonTemplateMember commonTemplateMember = 2;
inline int TMTCommonTemplatesList::commontemplatemember_size() const {
  return commontemplatemember_.size();
}
inline void TMTCommonTemplatesList::clear_commontemplatemember() {
  commontemplatemember_.Clear();
}
inline const ::mt::TMTCommonTemplateMember& TMTCommonTemplatesList::commontemplatemember(int index) const {
  return commontemplatemember_.Get(index);
}
inline ::mt::TMTCommonTemplateMember* TMTCommonTemplatesList::mutable_commontemplatemember(int index) {
  return commontemplatemember_.Mutable(index);
}
inline ::mt::TMTCommonTemplateMember* TMTCommonTemplatesList::add_commontemplatemember() {
  return commontemplatemember_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTCommonTemplateMember >&
TMTCommonTemplatesList::commontemplatemember() const {
  return commontemplatemember_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTCommonTemplateMember >*
TMTCommonTemplatesList::mutable_commontemplatemember() {
  return &commontemplatemember_;
}

// -------------------------------------------------------------------

// TMTConfInitiator

// optional string name = 1;
inline bool TMTConfInitiator::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfInitiator::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfInitiator::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfInitiator::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTConfInitiator::name() const {
  return *name_;
}
inline void TMTConfInitiator::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTConfInitiator::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTConfInitiator::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInitiator::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTConfInitiator::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInitiator::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 2;
inline bool TMTConfInitiator::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConfInitiator::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConfInitiator::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConfInitiator::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTConfInitiator::account() const {
  return *account_;
}
inline void TMTConfInitiator::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTConfInitiator::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTConfInitiator::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInitiator::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTConfInitiator::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInitiator::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtAddrType accounttype = 3;
inline bool TMTConfInitiator::has_accounttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTConfInitiator::set_has_accounttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTConfInitiator::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTConfInitiator::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::mt::EmMtAddrType TMTConfInitiator::accounttype() const {
  return static_cast< ::mt::EmMtAddrType >(accounttype_);
}
inline void TMTConfInitiator::set_accounttype(::mt::EmMtAddrType value) {
  assert(::mt::EmMtAddrType_IsValid(value));
  set_has_accounttype();
  accounttype_ = value;
}

// optional string telephone = 4;
inline bool TMTConfInitiator::has_telephone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTConfInitiator::set_has_telephone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTConfInitiator::clear_has_telephone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTConfInitiator::clear_telephone() {
  if (telephone_ != &::google::protobuf::internal::kEmptyString) {
    telephone_->clear();
  }
  clear_has_telephone();
}
inline const ::std::string& TMTConfInitiator::telephone() const {
  return *telephone_;
}
inline void TMTConfInitiator::set_telephone(const ::std::string& value) {
  set_has_telephone();
  if (telephone_ == &::google::protobuf::internal::kEmptyString) {
    telephone_ = new ::std::string;
  }
  telephone_->assign(value);
}
inline void TMTConfInitiator::set_telephone(const char* value) {
  set_has_telephone();
  if (telephone_ == &::google::protobuf::internal::kEmptyString) {
    telephone_ = new ::std::string;
  }
  telephone_->assign(value);
}
inline void TMTConfInitiator::set_telephone(const char* value, size_t size) {
  set_has_telephone();
  if (telephone_ == &::google::protobuf::internal::kEmptyString) {
    telephone_ = new ::std::string;
  }
  telephone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInitiator::mutable_telephone() {
  set_has_telephone();
  if (telephone_ == &::google::protobuf::internal::kEmptyString) {
    telephone_ = new ::std::string;
  }
  return telephone_;
}
inline ::std::string* TMTConfInitiator::release_telephone() {
  clear_has_telephone();
  if (telephone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = telephone_;
    telephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInitiator::set_allocated_telephone(::std::string* telephone) {
  if (telephone_ != &::google::protobuf::internal::kEmptyString) {
    delete telephone_;
  }
  if (telephone) {
    set_has_telephone();
    telephone_ = telephone;
  } else {
    clear_has_telephone();
    telephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobile = 5;
inline bool TMTConfInitiator::has_mobile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTConfInitiator::set_has_mobile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTConfInitiator::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTConfInitiator::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& TMTConfInitiator::mobile() const {
  return *mobile_;
}
inline void TMTConfInitiator::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTConfInitiator::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTConfInitiator::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfInitiator::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* TMTConfInitiator::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfInitiator::set_allocated_mobile(::std::string* mobile) {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_;
  }
  if (mobile) {
    set_has_mobile();
    mobile_ = mobile;
  } else {
    clear_has_mobile();
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTConferenceElement

// optional string name = 1;
inline bool TMTConferenceElement::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConferenceElement::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConferenceElement::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConferenceElement::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTConferenceElement::name() const {
  return *name_;
}
inline void TMTConferenceElement::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTConferenceElement::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTConferenceElement::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConferenceElement::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTConferenceElement::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConferenceElement::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string confID = 2;
inline bool TMTConferenceElement::has_confid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConferenceElement::set_has_confid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConferenceElement::clear_has_confid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConferenceElement::clear_confid() {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    confid_->clear();
  }
  clear_has_confid();
}
inline const ::std::string& TMTConferenceElement::confid() const {
  return *confid_;
}
inline void TMTConferenceElement::set_confid(const ::std::string& value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTConferenceElement::set_confid(const char* value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTConferenceElement::set_confid(const char* value, size_t size) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConferenceElement::mutable_confid() {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  return confid_;
}
inline ::std::string* TMTConferenceElement::release_confid() {
  clear_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confid_;
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConferenceElement::set_allocated_confid(::std::string* confid) {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    delete confid_;
  }
  if (confid) {
    set_has_confid();
    confid_ = confid;
  } else {
    clear_has_confid();
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestMeetingSafeType confType = 3;
inline bool TMTConferenceElement::has_conftype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTConferenceElement::set_has_conftype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTConferenceElement::clear_has_conftype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTConferenceElement::clear_conftype() {
  conftype_ = 0;
  clear_has_conftype();
}
inline ::mt::EmRestMeetingSafeType TMTConferenceElement::conftype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(conftype_);
}
inline void TMTConferenceElement::set_conftype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_conftype();
  conftype_ = value;
}

// optional string starTime = 4;
inline bool TMTConferenceElement::has_startime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTConferenceElement::set_has_startime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTConferenceElement::clear_has_startime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTConferenceElement::clear_startime() {
  if (startime_ != &::google::protobuf::internal::kEmptyString) {
    startime_->clear();
  }
  clear_has_startime();
}
inline const ::std::string& TMTConferenceElement::startime() const {
  return *startime_;
}
inline void TMTConferenceElement::set_startime(const ::std::string& value) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(value);
}
inline void TMTConferenceElement::set_startime(const char* value) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(value);
}
inline void TMTConferenceElement::set_startime(const char* value, size_t size) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConferenceElement::mutable_startime() {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  return startime_;
}
inline ::std::string* TMTConferenceElement::release_startime() {
  clear_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startime_;
    startime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConferenceElement::set_allocated_startime(::std::string* startime) {
  if (startime_ != &::google::protobuf::internal::kEmptyString) {
    delete startime_;
  }
  if (startime) {
    set_has_startime();
    startime_ = startime;
  } else {
    clear_has_startime();
    startime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endTime = 5;
inline bool TMTConferenceElement::has_endtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTConferenceElement::set_has_endtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTConferenceElement::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTConferenceElement::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTConferenceElement::endtime() const {
  return *endtime_;
}
inline void TMTConferenceElement::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTConferenceElement::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTConferenceElement::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConferenceElement::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTConferenceElement::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConferenceElement::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 6;
inline bool TMTConferenceElement::has_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTConferenceElement::set_has_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTConferenceElement::clear_has_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTConferenceElement::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTConferenceElement::duration() const {
  return duration_;
}
inline void TMTConferenceElement::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 bitrate = 7;
inline bool TMTConferenceElement::has_bitrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTConferenceElement::set_has_bitrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTConferenceElement::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTConferenceElement::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTConferenceElement::bitrate() const {
  return bitrate_;
}
inline void TMTConferenceElement::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmClosedMeeting closeConf = 8;
inline bool TMTConferenceElement::has_closeconf() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTConferenceElement::set_has_closeconf() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTConferenceElement::clear_has_closeconf() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTConferenceElement::clear_closeconf() {
  closeconf_ = 0;
  clear_has_closeconf();
}
inline ::mt::EmClosedMeeting TMTConferenceElement::closeconf() const {
  return static_cast< ::mt::EmClosedMeeting >(closeconf_);
}
inline void TMTConferenceElement::set_closeconf(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closeconf();
  closeconf_ = value;
}

// optional .mt.EmMtOpenMode safeConf = 9;
inline bool TMTConferenceElement::has_safeconf() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTConferenceElement::set_has_safeconf() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTConferenceElement::clear_has_safeconf() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTConferenceElement::clear_safeconf() {
  safeconf_ = 1;
  clear_has_safeconf();
}
inline ::mt::EmMtOpenMode TMTConferenceElement::safeconf() const {
  return static_cast< ::mt::EmMtOpenMode >(safeconf_);
}
inline void TMTConferenceElement::set_safeconf(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_safeconf();
  safeconf_ = value;
}

// optional .mt.EmEncryptArithmetic encryptedtype = 10;
inline bool TMTConferenceElement::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTConferenceElement::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTConferenceElement::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTConferenceElement::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTConferenceElement::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTConferenceElement::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional string password = 11;
inline bool TMTConferenceElement::has_password() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTConferenceElement::set_has_password() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTConferenceElement::clear_has_password() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTConferenceElement::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTConferenceElement::password() const {
  return *password_;
}
inline void TMTConferenceElement::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTConferenceElement::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTConferenceElement::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConferenceElement::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTConferenceElement::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConferenceElement::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool initmute = 12;
inline bool TMTConferenceElement::has_initmute() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTConferenceElement::set_has_initmute() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTConferenceElement::clear_has_initmute() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTConferenceElement::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTConferenceElement::initmute() const {
  return initmute_;
}
inline void TMTConferenceElement::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional bool initSilence = 13;
inline bool TMTConferenceElement::has_initsilence() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTConferenceElement::set_has_initsilence() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTConferenceElement::clear_has_initsilence() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTConferenceElement::clear_initsilence() {
  initsilence_ = false;
  clear_has_initsilence();
}
inline bool TMTConferenceElement::initsilence() const {
  return initsilence_;
}
inline void TMTConferenceElement::set_initsilence(bool value) {
  set_has_initsilence();
  initsilence_ = value;
}

// optional .mt.EmRestVideoQuality vidoQuality = 14;
inline bool TMTConferenceElement::has_vidoquality() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTConferenceElement::set_has_vidoquality() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTConferenceElement::clear_has_vidoquality() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTConferenceElement::clear_vidoquality() {
  vidoquality_ = 0;
  clear_has_vidoquality();
}
inline ::mt::EmRestVideoQuality TMTConferenceElement::vidoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(vidoquality_);
}
inline void TMTConferenceElement::set_vidoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_vidoquality();
  vidoquality_ = value;
}

// optional uint32 oneReforming = 15;
inline bool TMTConferenceElement::has_onereforming() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTConferenceElement::set_has_onereforming() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTConferenceElement::clear_has_onereforming() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTConferenceElement::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TMTConferenceElement::onereforming() const {
  return onereforming_;
}
inline void TMTConferenceElement::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional string encryptedkey = 16;
inline bool TMTConferenceElement::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTConferenceElement::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTConferenceElement::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTConferenceElement::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTConferenceElement::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTConferenceElement::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTConferenceElement::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTConferenceElement::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConferenceElement::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTConferenceElement::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConferenceElement::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestDualMode dualmode = 17;
inline bool TMTConferenceElement::has_dualmode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTConferenceElement::set_has_dualmode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTConferenceElement::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTConferenceElement::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTConferenceElement::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTConferenceElement::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool voiceActivityDetection = 18;
inline bool TMTConferenceElement::has_voiceactivitydetection() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTConferenceElement::set_has_voiceactivitydetection() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTConferenceElement::clear_has_voiceactivitydetection() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTConferenceElement::clear_voiceactivitydetection() {
  voiceactivitydetection_ = false;
  clear_has_voiceactivitydetection();
}
inline bool TMTConferenceElement::voiceactivitydetection() const {
  return voiceactivitydetection_;
}
inline void TMTConferenceElement::set_voiceactivitydetection(bool value) {
  set_has_voiceactivitydetection();
  voiceactivitydetection_ = value;
}

// optional bool publicConf = 19;
inline bool TMTConferenceElement::has_publicconf() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTConferenceElement::set_has_publicconf() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTConferenceElement::clear_has_publicconf() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTConferenceElement::clear_publicconf() {
  publicconf_ = false;
  clear_has_publicconf();
}
inline bool TMTConferenceElement::publicconf() const {
  return publicconf_;
}
inline void TMTConferenceElement::set_publicconf(bool value) {
  set_has_publicconf();
  publicconf_ = value;
}

// optional uint32 invitedMtNum = 20;
inline bool TMTConferenceElement::has_invitedmtnum() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTConferenceElement::set_has_invitedmtnum() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTConferenceElement::clear_has_invitedmtnum() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTConferenceElement::clear_invitedmtnum() {
  invitedmtnum_ = 0u;
  clear_has_invitedmtnum();
}
inline ::google::protobuf::uint32 TMTConferenceElement::invitedmtnum() const {
  return invitedmtnum_;
}
inline void TMTConferenceElement::set_invitedmtnum(::google::protobuf::uint32 value) {
  set_has_invitedmtnum();
  invitedmtnum_ = value;
}

// optional uint32 maxJoinMt = 21;
inline bool TMTConferenceElement::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTConferenceElement::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTConferenceElement::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTConferenceElement::clear_maxjoinmt() {
  maxjoinmt_ = 0u;
  clear_has_maxjoinmt();
}
inline ::google::protobuf::uint32 TMTConferenceElement::maxjoinmt() const {
  return maxjoinmt_;
}
inline void TMTConferenceElement::set_maxjoinmt(::google::protobuf::uint32 value) {
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional .mt.TMTConfInitiator confInitiator = 22;
inline bool TMTConferenceElement::has_confinitiator() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTConferenceElement::set_has_confinitiator() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTConferenceElement::clear_has_confinitiator() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTConferenceElement::clear_confinitiator() {
  if (confinitiator_ != NULL) confinitiator_->::mt::TMTConfInitiator::Clear();
  clear_has_confinitiator();
}
inline const ::mt::TMTConfInitiator& TMTConferenceElement::confinitiator() const {
  return confinitiator_ != NULL ? *confinitiator_ : *default_instance_->confinitiator_;
}
inline ::mt::TMTConfInitiator* TMTConferenceElement::mutable_confinitiator() {
  set_has_confinitiator();
  if (confinitiator_ == NULL) confinitiator_ = new ::mt::TMTConfInitiator;
  return confinitiator_;
}
inline ::mt::TMTConfInitiator* TMTConferenceElement::release_confinitiator() {
  clear_has_confinitiator();
  ::mt::TMTConfInitiator* temp = confinitiator_;
  confinitiator_ = NULL;
  return temp;
}
inline void TMTConferenceElement::set_allocated_confinitiator(::mt::TMTConfInitiator* confinitiator) {
  delete confinitiator_;
  confinitiator_ = confinitiator;
  if (confinitiator) {
    set_has_confinitiator();
  } else {
    clear_has_confinitiator();
  }
}

// optional bool encrypted_auth = 23;
inline bool TMTConferenceElement::has_encrypted_auth() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTConferenceElement::set_has_encrypted_auth() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTConferenceElement::clear_has_encrypted_auth() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTConferenceElement::clear_encrypted_auth() {
  encrypted_auth_ = false;
  clear_has_encrypted_auth();
}
inline bool TMTConferenceElement::encrypted_auth() const {
  return encrypted_auth_;
}
inline void TMTConferenceElement::set_encrypted_auth(bool value) {
  set_has_encrypted_auth();
  encrypted_auth_ = value;
}

// -------------------------------------------------------------------

// TMTBookConferenceList

// optional uint32 total = 1;
inline bool TMTBookConferenceList::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTBookConferenceList::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTBookConferenceList::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTBookConferenceList::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 TMTBookConferenceList::total() const {
  return total_;
}
inline void TMTBookConferenceList::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional uint32 count = 2;
inline bool TMTBookConferenceList::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTBookConferenceList::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTBookConferenceList::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTBookConferenceList::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTBookConferenceList::count() const {
  return count_;
}
inline void TMTBookConferenceList::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTConferenceElement bookConfList = 3;
inline int TMTBookConferenceList::bookconflist_size() const {
  return bookconflist_.size();
}
inline void TMTBookConferenceList::clear_bookconflist() {
  bookconflist_.Clear();
}
inline const ::mt::TMTConferenceElement& TMTBookConferenceList::bookconflist(int index) const {
  return bookconflist_.Get(index);
}
inline ::mt::TMTConferenceElement* TMTBookConferenceList::mutable_bookconflist(int index) {
  return bookconflist_.Mutable(index);
}
inline ::mt::TMTConferenceElement* TMTBookConferenceList::add_bookconflist() {
  return bookconflist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTConferenceElement >&
TMTBookConferenceList::bookconflist() const {
  return bookconflist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTConferenceElement >*
TMTBookConferenceList::mutable_bookconflist() {
  return &bookconflist_;
}

// -------------------------------------------------------------------

// TMTInstantConfElement

// optional string name = 1;
inline bool TMTInstantConfElement::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTInstantConfElement::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTInstantConfElement::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTInstantConfElement::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTInstantConfElement::name() const {
  return *name_;
}
inline void TMTInstantConfElement::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTInstantConfElement::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTInstantConfElement::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConfElement::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTInstantConfElement::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConfElement::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string confID = 2;
inline bool TMTInstantConfElement::has_confid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTInstantConfElement::set_has_confid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTInstantConfElement::clear_has_confid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTInstantConfElement::clear_confid() {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    confid_->clear();
  }
  clear_has_confid();
}
inline const ::std::string& TMTInstantConfElement::confid() const {
  return *confid_;
}
inline void TMTInstantConfElement::set_confid(const ::std::string& value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTInstantConfElement::set_confid(const char* value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTInstantConfElement::set_confid(const char* value, size_t size) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConfElement::mutable_confid() {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  return confid_;
}
inline ::std::string* TMTInstantConfElement::release_confid() {
  clear_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confid_;
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConfElement::set_allocated_confid(::std::string* confid) {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    delete confid_;
  }
  if (confid) {
    set_has_confid();
    confid_ = confid;
  } else {
    clear_has_confid();
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool voiceInspireEnable = 3;
inline bool TMTInstantConfElement::has_voiceinspireenable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTInstantConfElement::set_has_voiceinspireenable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTInstantConfElement::clear_has_voiceinspireenable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTInstantConfElement::clear_voiceinspireenable() {
  voiceinspireenable_ = false;
  clear_has_voiceinspireenable();
}
inline bool TMTInstantConfElement::voiceinspireenable() const {
  return voiceinspireenable_;
}
inline void TMTInstantConfElement::set_voiceinspireenable(bool value) {
  set_has_voiceinspireenable();
  voiceinspireenable_ = value;
}

// optional .mt.EmRestMeetingSafeType confType = 4;
inline bool TMTInstantConfElement::has_conftype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTInstantConfElement::set_has_conftype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTInstantConfElement::clear_has_conftype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTInstantConfElement::clear_conftype() {
  conftype_ = 0;
  clear_has_conftype();
}
inline ::mt::EmRestMeetingSafeType TMTInstantConfElement::conftype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(conftype_);
}
inline void TMTInstantConfElement::set_conftype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_conftype();
  conftype_ = value;
}

// optional string startTime = 5;
inline bool TMTInstantConfElement::has_starttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTInstantConfElement::set_has_starttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTInstantConfElement::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTInstantConfElement::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTInstantConfElement::starttime() const {
  return *starttime_;
}
inline void TMTInstantConfElement::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTInstantConfElement::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTInstantConfElement::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConfElement::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTInstantConfElement::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConfElement::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endTime = 6;
inline bool TMTInstantConfElement::has_endtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTInstantConfElement::set_has_endtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTInstantConfElement::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTInstantConfElement::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTInstantConfElement::endtime() const {
  return *endtime_;
}
inline void TMTInstantConfElement::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTInstantConfElement::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTInstantConfElement::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConfElement::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTInstantConfElement::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConfElement::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 7;
inline bool TMTInstantConfElement::has_duration() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTInstantConfElement::set_has_duration() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTInstantConfElement::clear_has_duration() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTInstantConfElement::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTInstantConfElement::duration() const {
  return duration_;
}
inline void TMTInstantConfElement::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 bitrate = 8;
inline bool TMTInstantConfElement::has_bitrate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTInstantConfElement::set_has_bitrate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTInstantConfElement::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTInstantConfElement::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTInstantConfElement::bitrate() const {
  return bitrate_;
}
inline void TMTInstantConfElement::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmClosedMeeting closeConf = 9;
inline bool TMTInstantConfElement::has_closeconf() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTInstantConfElement::set_has_closeconf() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTInstantConfElement::clear_has_closeconf() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTInstantConfElement::clear_closeconf() {
  closeconf_ = 0;
  clear_has_closeconf();
}
inline ::mt::EmClosedMeeting TMTInstantConfElement::closeconf() const {
  return static_cast< ::mt::EmClosedMeeting >(closeconf_);
}
inline void TMTInstantConfElement::set_closeconf(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closeconf();
  closeconf_ = value;
}

// optional .mt.EmMtOpenMode safeConf = 10;
inline bool TMTInstantConfElement::has_safeconf() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTInstantConfElement::set_has_safeconf() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTInstantConfElement::clear_has_safeconf() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTInstantConfElement::clear_safeconf() {
  safeconf_ = 1;
  clear_has_safeconf();
}
inline ::mt::EmMtOpenMode TMTInstantConfElement::safeconf() const {
  return static_cast< ::mt::EmMtOpenMode >(safeconf_);
}
inline void TMTInstantConfElement::set_safeconf(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_safeconf();
  safeconf_ = value;
}

// optional bool autoEnd = 11;
inline bool TMTInstantConfElement::has_autoend() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTInstantConfElement::set_has_autoend() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTInstantConfElement::clear_has_autoend() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTInstantConfElement::clear_autoend() {
  autoend_ = false;
  clear_has_autoend();
}
inline bool TMTInstantConfElement::autoend() const {
  return autoend_;
}
inline void TMTInstantConfElement::set_autoend(bool value) {
  set_has_autoend();
  autoend_ = value;
}

// optional bool preoccupyResource = 12;
inline bool TMTInstantConfElement::has_preoccupyresource() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTInstantConfElement::set_has_preoccupyresource() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTInstantConfElement::clear_has_preoccupyresource() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTInstantConfElement::clear_preoccupyresource() {
  preoccupyresource_ = false;
  clear_has_preoccupyresource();
}
inline bool TMTInstantConfElement::preoccupyresource() const {
  return preoccupyresource_;
}
inline void TMTInstantConfElement::set_preoccupyresource(bool value) {
  set_has_preoccupyresource();
  preoccupyresource_ = value;
}

// optional .mt.EmEncryptArithmetic encryptedtype = 13;
inline bool TMTInstantConfElement::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTInstantConfElement::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTInstantConfElement::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTInstantConfElement::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTInstantConfElement::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTInstantConfElement::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional bool initmute = 14;
inline bool TMTInstantConfElement::has_initmute() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTInstantConfElement::set_has_initmute() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTInstantConfElement::clear_has_initmute() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTInstantConfElement::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTInstantConfElement::initmute() const {
  return initmute_;
}
inline void TMTInstantConfElement::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional bool initSilence = 15;
inline bool TMTInstantConfElement::has_initsilence() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTInstantConfElement::set_has_initsilence() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTInstantConfElement::clear_has_initsilence() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTInstantConfElement::clear_initsilence() {
  initsilence_ = false;
  clear_has_initsilence();
}
inline bool TMTInstantConfElement::initsilence() const {
  return initsilence_;
}
inline void TMTInstantConfElement::set_initsilence(bool value) {
  set_has_initsilence();
  initsilence_ = value;
}

// optional .mt.EmRestVideoQuality vidoQuality = 16;
inline bool TMTInstantConfElement::has_vidoquality() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTInstantConfElement::set_has_vidoquality() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTInstantConfElement::clear_has_vidoquality() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTInstantConfElement::clear_vidoquality() {
  vidoquality_ = 0;
  clear_has_vidoquality();
}
inline ::mt::EmRestVideoQuality TMTInstantConfElement::vidoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(vidoquality_);
}
inline void TMTInstantConfElement::set_vidoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_vidoquality();
  vidoquality_ = value;
}

// optional string encryptedkey = 17;
inline bool TMTInstantConfElement::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTInstantConfElement::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTInstantConfElement::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTInstantConfElement::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTInstantConfElement::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTInstantConfElement::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTInstantConfElement::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTInstantConfElement::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConfElement::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTInstantConfElement::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConfElement::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestDualMode dualmode = 18;
inline bool TMTInstantConfElement::has_dualmode() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTInstantConfElement::set_has_dualmode() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTInstantConfElement::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTInstantConfElement::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTInstantConfElement::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTInstantConfElement::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool publicConf = 19;
inline bool TMTInstantConfElement::has_publicconf() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTInstantConfElement::set_has_publicconf() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTInstantConfElement::clear_has_publicconf() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTInstantConfElement::clear_publicconf() {
  publicconf_ = false;
  clear_has_publicconf();
}
inline bool TMTInstantConfElement::publicconf() const {
  return publicconf_;
}
inline void TMTInstantConfElement::set_publicconf(bool value) {
  set_has_publicconf();
  publicconf_ = value;
}

// optional uint32 maxJoinMt = 20;
inline bool TMTInstantConfElement::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTInstantConfElement::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTInstantConfElement::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTInstantConfElement::clear_maxjoinmt() {
  maxjoinmt_ = 0u;
  clear_has_maxjoinmt();
}
inline ::google::protobuf::uint32 TMTInstantConfElement::maxjoinmt() const {
  return maxjoinmt_;
}
inline void TMTInstantConfElement::set_maxjoinmt(::google::protobuf::uint32 value) {
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional .mt.TMTConfInitiator confInitiator = 21;
inline bool TMTInstantConfElement::has_confinitiator() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTInstantConfElement::set_has_confinitiator() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTInstantConfElement::clear_has_confinitiator() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTInstantConfElement::clear_confinitiator() {
  if (confinitiator_ != NULL) confinitiator_->::mt::TMTConfInitiator::Clear();
  clear_has_confinitiator();
}
inline const ::mt::TMTConfInitiator& TMTInstantConfElement::confinitiator() const {
  return confinitiator_ != NULL ? *confinitiator_ : *default_instance_->confinitiator_;
}
inline ::mt::TMTConfInitiator* TMTInstantConfElement::mutable_confinitiator() {
  set_has_confinitiator();
  if (confinitiator_ == NULL) confinitiator_ = new ::mt::TMTConfInitiator;
  return confinitiator_;
}
inline ::mt::TMTConfInitiator* TMTInstantConfElement::release_confinitiator() {
  clear_has_confinitiator();
  ::mt::TMTConfInitiator* temp = confinitiator_;
  confinitiator_ = NULL;
  return temp;
}
inline void TMTInstantConfElement::set_allocated_confinitiator(::mt::TMTConfInitiator* confinitiator) {
  delete confinitiator_;
  confinitiator_ = confinitiator;
  if (confinitiator) {
    set_has_confinitiator();
  } else {
    clear_has_confinitiator();
  }
}

// optional uint32 vacinterval = 22;
inline bool TMTInstantConfElement::has_vacinterval() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTInstantConfElement::set_has_vacinterval() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTInstantConfElement::clear_has_vacinterval() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTInstantConfElement::clear_vacinterval() {
  vacinterval_ = 0u;
  clear_has_vacinterval();
}
inline ::google::protobuf::uint32 TMTInstantConfElement::vacinterval() const {
  return vacinterval_;
}
inline void TMTInstantConfElement::set_vacinterval(::google::protobuf::uint32 value) {
  set_has_vacinterval();
  vacinterval_ = value;
}

// optional uint32 conflevel = 23;
inline bool TMTInstantConfElement::has_conflevel() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTInstantConfElement::set_has_conflevel() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTInstantConfElement::clear_has_conflevel() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTInstantConfElement::clear_conflevel() {
  conflevel_ = 0u;
  clear_has_conflevel();
}
inline ::google::protobuf::uint32 TMTInstantConfElement::conflevel() const {
  return conflevel_;
}
inline void TMTInstantConfElement::set_conflevel(::google::protobuf::uint32 value) {
  set_has_conflevel();
  conflevel_ = value;
}

// optional bool needPassword = 24;
inline bool TMTInstantConfElement::has_needpassword() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTInstantConfElement::set_has_needpassword() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTInstantConfElement::clear_has_needpassword() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTInstantConfElement::clear_needpassword() {
  needpassword_ = false;
  clear_has_needpassword();
}
inline bool TMTInstantConfElement::needpassword() const {
  return needpassword_;
}
inline void TMTInstantConfElement::set_needpassword(bool value) {
  set_has_needpassword();
  needpassword_ = value;
}

// optional bool forcebroadcast = 25;
inline bool TMTInstantConfElement::has_forcebroadcast() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTInstantConfElement::set_has_forcebroadcast() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTInstantConfElement::clear_has_forcebroadcast() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTInstantConfElement::clear_forcebroadcast() {
  forcebroadcast_ = false;
  clear_has_forcebroadcast();
}
inline bool TMTInstantConfElement::forcebroadcast() const {
  return forcebroadcast_;
}
inline void TMTInstantConfElement::set_forcebroadcast(bool value) {
  set_has_forcebroadcast();
  forcebroadcast_ = value;
}

// optional bool encrypted_auth = 26;
inline bool TMTInstantConfElement::has_encrypted_auth() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMTInstantConfElement::set_has_encrypted_auth() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMTInstantConfElement::clear_has_encrypted_auth() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMTInstantConfElement::clear_encrypted_auth() {
  encrypted_auth_ = false;
  clear_has_encrypted_auth();
}
inline bool TMTInstantConfElement::encrypted_auth() const {
  return encrypted_auth_;
}
inline void TMTInstantConfElement::set_encrypted_auth(bool value) {
  set_has_encrypted_auth();
  encrypted_auth_ = value;
}

// optional .mt.EmMtFecMode fecmode = 27;
inline bool TMTInstantConfElement::has_fecmode() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMTInstantConfElement::set_has_fecmode() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMTInstantConfElement::clear_has_fecmode() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMTInstantConfElement::clear_fecmode() {
  fecmode_ = 0;
  clear_has_fecmode();
}
inline ::mt::EmMtFecMode TMTInstantConfElement::fecmode() const {
  return static_cast< ::mt::EmMtFecMode >(fecmode_);
}
inline void TMTInstantConfElement::set_fecmode(::mt::EmMtFecMode value) {
  assert(::mt::EmMtFecMode_IsValid(value));
  set_has_fecmode();
  fecmode_ = value;
}

// optional string MeetingRoomName = 28;
inline bool TMTInstantConfElement::has_meetingroomname() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTInstantConfElement::set_has_meetingroomname() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTInstantConfElement::clear_has_meetingroomname() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTInstantConfElement::clear_meetingroomname() {
  if (meetingroomname_ != &::google::protobuf::internal::kEmptyString) {
    meetingroomname_->clear();
  }
  clear_has_meetingroomname();
}
inline const ::std::string& TMTInstantConfElement::meetingroomname() const {
  return *meetingroomname_;
}
inline void TMTInstantConfElement::set_meetingroomname(const ::std::string& value) {
  set_has_meetingroomname();
  if (meetingroomname_ == &::google::protobuf::internal::kEmptyString) {
    meetingroomname_ = new ::std::string;
  }
  meetingroomname_->assign(value);
}
inline void TMTInstantConfElement::set_meetingroomname(const char* value) {
  set_has_meetingroomname();
  if (meetingroomname_ == &::google::protobuf::internal::kEmptyString) {
    meetingroomname_ = new ::std::string;
  }
  meetingroomname_->assign(value);
}
inline void TMTInstantConfElement::set_meetingroomname(const char* value, size_t size) {
  set_has_meetingroomname();
  if (meetingroomname_ == &::google::protobuf::internal::kEmptyString) {
    meetingroomname_ = new ::std::string;
  }
  meetingroomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConfElement::mutable_meetingroomname() {
  set_has_meetingroomname();
  if (meetingroomname_ == &::google::protobuf::internal::kEmptyString) {
    meetingroomname_ = new ::std::string;
  }
  return meetingroomname_;
}
inline ::std::string* TMTInstantConfElement::release_meetingroomname() {
  clear_has_meetingroomname();
  if (meetingroomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetingroomname_;
    meetingroomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConfElement::set_allocated_meetingroomname(::std::string* meetingroomname) {
  if (meetingroomname_ != &::google::protobuf::internal::kEmptyString) {
    delete meetingroomname_;
  }
  if (meetingroomname) {
    set_has_meetingroomname();
    meetingroomname_ = meetingroomname;
  } else {
    clear_has_meetingroomname();
    meetingroomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool doubleflow = 29;
inline bool TMTInstantConfElement::has_doubleflow() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMTInstantConfElement::set_has_doubleflow() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMTInstantConfElement::clear_has_doubleflow() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMTInstantConfElement::clear_doubleflow() {
  doubleflow_ = false;
  clear_has_doubleflow();
}
inline bool TMTInstantConfElement::doubleflow() const {
  return doubleflow_;
}
inline void TMTInstantConfElement::set_doubleflow(bool value) {
  set_has_doubleflow();
  doubleflow_ = value;
}

// optional bool mutefilter = 30;
inline bool TMTInstantConfElement::has_mutefilter() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMTInstantConfElement::set_has_mutefilter() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMTInstantConfElement::clear_has_mutefilter() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMTInstantConfElement::clear_mutefilter() {
  mutefilter_ = false;
  clear_has_mutefilter();
}
inline bool TMTInstantConfElement::mutefilter() const {
  return mutefilter_;
}
inline void TMTInstantConfElement::set_mutefilter(bool value) {
  set_has_mutefilter();
  mutefilter_ = value;
}

// -------------------------------------------------------------------

// TMTInstantConferenceList

// optional uint32 total = 1;
inline bool TMTInstantConferenceList::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTInstantConferenceList::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTInstantConferenceList::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTInstantConferenceList::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 TMTInstantConferenceList::total() const {
  return total_;
}
inline void TMTInstantConferenceList::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional uint32 count = 2;
inline bool TMTInstantConferenceList::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTInstantConferenceList::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTInstantConferenceList::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTInstantConferenceList::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTInstantConferenceList::count() const {
  return count_;
}
inline void TMTInstantConferenceList::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTInstantConfElement instantConfList = 3;
inline int TMTInstantConferenceList::instantconflist_size() const {
  return instantconflist_.size();
}
inline void TMTInstantConferenceList::clear_instantconflist() {
  instantconflist_.Clear();
}
inline const ::mt::TMTInstantConfElement& TMTInstantConferenceList::instantconflist(int index) const {
  return instantconflist_.Get(index);
}
inline ::mt::TMTInstantConfElement* TMTInstantConferenceList::mutable_instantconflist(int index) {
  return instantconflist_.Mutable(index);
}
inline ::mt::TMTInstantConfElement* TMTInstantConferenceList::add_instantconflist() {
  return instantconflist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTInstantConfElement >&
TMTInstantConferenceList::instantconflist() const {
  return instantconflist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTInstantConfElement >*
TMTInstantConferenceList::mutable_instantconflist() {
  return &instantconflist_;
}

// -------------------------------------------------------------------

// TMTConditionOfConfList

// optional string starTime = 1;
inline bool TMTConditionOfConfList::has_startime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConditionOfConfList::set_has_startime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConditionOfConfList::clear_has_startime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConditionOfConfList::clear_startime() {
  if (startime_ != &::google::protobuf::internal::kEmptyString) {
    startime_->clear();
  }
  clear_has_startime();
}
inline const ::std::string& TMTConditionOfConfList::startime() const {
  return *startime_;
}
inline void TMTConditionOfConfList::set_startime(const ::std::string& value) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(value);
}
inline void TMTConditionOfConfList::set_startime(const char* value) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(value);
}
inline void TMTConditionOfConfList::set_startime(const char* value, size_t size) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConditionOfConfList::mutable_startime() {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  return startime_;
}
inline ::std::string* TMTConditionOfConfList::release_startime() {
  clear_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startime_;
    startime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConditionOfConfList::set_allocated_startime(::std::string* startime) {
  if (startime_ != &::google::protobuf::internal::kEmptyString) {
    delete startime_;
  }
  if (startime) {
    set_has_startime();
    startime_ = startime;
  } else {
    clear_has_startime();
    startime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endTime = 2;
inline bool TMTConditionOfConfList::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConditionOfConfList::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConditionOfConfList::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConditionOfConfList::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTConditionOfConfList::endtime() const {
  return *endtime_;
}
inline void TMTConditionOfConfList::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTConditionOfConfList::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTConditionOfConfList::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConditionOfConfList::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTConditionOfConfList::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConditionOfConfList::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 start = 3;
inline bool TMTConditionOfConfList::has_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTConditionOfConfList::set_has_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTConditionOfConfList::clear_has_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTConditionOfConfList::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTConditionOfConfList::start() const {
  return start_;
}
inline void TMTConditionOfConfList::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 4;
inline bool TMTConditionOfConfList::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTConditionOfConfList::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTConditionOfConfList::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTConditionOfConfList::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTConditionOfConfList::count() const {
  return count_;
}
inline void TMTConditionOfConfList::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 5;
inline bool TMTConditionOfConfList::has_order() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTConditionOfConfList::set_has_order() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTConditionOfConfList::clear_has_order() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTConditionOfConfList::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTConditionOfConfList::order() const {
  return order_;
}
inline void TMTConditionOfConfList::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// -------------------------------------------------------------------

// TMTBookConferenceInfo

// optional string name = 1;
inline bool TMTBookConferenceInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTBookConferenceInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTBookConferenceInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTBookConferenceInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTBookConferenceInfo::name() const {
  return *name_;
}
inline void TMTBookConferenceInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTBookConferenceInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTBookConferenceInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBookConferenceInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTBookConferenceInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBookConferenceInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string confID = 2;
inline bool TMTBookConferenceInfo::has_confid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTBookConferenceInfo::set_has_confid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTBookConferenceInfo::clear_has_confid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTBookConferenceInfo::clear_confid() {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    confid_->clear();
  }
  clear_has_confid();
}
inline const ::std::string& TMTBookConferenceInfo::confid() const {
  return *confid_;
}
inline void TMTBookConferenceInfo::set_confid(const ::std::string& value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTBookConferenceInfo::set_confid(const char* value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTBookConferenceInfo::set_confid(const char* value, size_t size) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBookConferenceInfo::mutable_confid() {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  return confid_;
}
inline ::std::string* TMTBookConferenceInfo::release_confid() {
  clear_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confid_;
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBookConferenceInfo::set_allocated_confid(::std::string* confid) {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    delete confid_;
  }
  if (confid) {
    set_has_confid();
    confid_ = confid;
  } else {
    clear_has_confid();
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestMeetingSafeType confType = 3;
inline bool TMTBookConferenceInfo::has_conftype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTBookConferenceInfo::set_has_conftype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTBookConferenceInfo::clear_has_conftype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTBookConferenceInfo::clear_conftype() {
  conftype_ = 0;
  clear_has_conftype();
}
inline ::mt::EmRestMeetingSafeType TMTBookConferenceInfo::conftype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(conftype_);
}
inline void TMTBookConferenceInfo::set_conftype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_conftype();
  conftype_ = value;
}

// optional string starTime = 4;
inline bool TMTBookConferenceInfo::has_startime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTBookConferenceInfo::set_has_startime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTBookConferenceInfo::clear_has_startime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTBookConferenceInfo::clear_startime() {
  if (startime_ != &::google::protobuf::internal::kEmptyString) {
    startime_->clear();
  }
  clear_has_startime();
}
inline const ::std::string& TMTBookConferenceInfo::startime() const {
  return *startime_;
}
inline void TMTBookConferenceInfo::set_startime(const ::std::string& value) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(value);
}
inline void TMTBookConferenceInfo::set_startime(const char* value) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(value);
}
inline void TMTBookConferenceInfo::set_startime(const char* value, size_t size) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBookConferenceInfo::mutable_startime() {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  return startime_;
}
inline ::std::string* TMTBookConferenceInfo::release_startime() {
  clear_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startime_;
    startime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBookConferenceInfo::set_allocated_startime(::std::string* startime) {
  if (startime_ != &::google::protobuf::internal::kEmptyString) {
    delete startime_;
  }
  if (startime) {
    set_has_startime();
    startime_ = startime;
  } else {
    clear_has_startime();
    startime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endTime = 5;
inline bool TMTBookConferenceInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTBookConferenceInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTBookConferenceInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTBookConferenceInfo::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTBookConferenceInfo::endtime() const {
  return *endtime_;
}
inline void TMTBookConferenceInfo::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTBookConferenceInfo::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTBookConferenceInfo::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBookConferenceInfo::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTBookConferenceInfo::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBookConferenceInfo::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 6;
inline bool TMTBookConferenceInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTBookConferenceInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTBookConferenceInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTBookConferenceInfo::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTBookConferenceInfo::duration() const {
  return duration_;
}
inline void TMTBookConferenceInfo::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 bitrate = 7;
inline bool TMTBookConferenceInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTBookConferenceInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTBookConferenceInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTBookConferenceInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTBookConferenceInfo::bitrate() const {
  return bitrate_;
}
inline void TMTBookConferenceInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmClosedMeeting closeConf = 8;
inline bool TMTBookConferenceInfo::has_closeconf() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTBookConferenceInfo::set_has_closeconf() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTBookConferenceInfo::clear_has_closeconf() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTBookConferenceInfo::clear_closeconf() {
  closeconf_ = 0;
  clear_has_closeconf();
}
inline ::mt::EmClosedMeeting TMTBookConferenceInfo::closeconf() const {
  return static_cast< ::mt::EmClosedMeeting >(closeconf_);
}
inline void TMTBookConferenceInfo::set_closeconf(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closeconf();
  closeconf_ = value;
}

// optional .mt.EmMtOpenMode safeConf = 9;
inline bool TMTBookConferenceInfo::has_safeconf() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTBookConferenceInfo::set_has_safeconf() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTBookConferenceInfo::clear_has_safeconf() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTBookConferenceInfo::clear_safeconf() {
  safeconf_ = 1;
  clear_has_safeconf();
}
inline ::mt::EmMtOpenMode TMTBookConferenceInfo::safeconf() const {
  return static_cast< ::mt::EmMtOpenMode >(safeconf_);
}
inline void TMTBookConferenceInfo::set_safeconf(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_safeconf();
  safeconf_ = value;
}

// optional string password = 10;
inline bool TMTBookConferenceInfo::has_password() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTBookConferenceInfo::set_has_password() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTBookConferenceInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTBookConferenceInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTBookConferenceInfo::password() const {
  return *password_;
}
inline void TMTBookConferenceInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTBookConferenceInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTBookConferenceInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBookConferenceInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTBookConferenceInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBookConferenceInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmEncryptArithmetic encryptedtype = 11;
inline bool TMTBookConferenceInfo::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTBookConferenceInfo::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTBookConferenceInfo::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTBookConferenceInfo::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTBookConferenceInfo::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTBookConferenceInfo::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional string encryptedkey = 12;
inline bool TMTBookConferenceInfo::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTBookConferenceInfo::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTBookConferenceInfo::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTBookConferenceInfo::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTBookConferenceInfo::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTBookConferenceInfo::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTBookConferenceInfo::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTBookConferenceInfo::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBookConferenceInfo::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTBookConferenceInfo::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBookConferenceInfo::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 callTimes = 13;
inline bool TMTBookConferenceInfo::has_calltimes() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_calltimes() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTBookConferenceInfo::clear_has_calltimes() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTBookConferenceInfo::clear_calltimes() {
  calltimes_ = 0u;
  clear_has_calltimes();
}
inline ::google::protobuf::uint32 TMTBookConferenceInfo::calltimes() const {
  return calltimes_;
}
inline void TMTBookConferenceInfo::set_calltimes(::google::protobuf::uint32 value) {
  set_has_calltimes();
  calltimes_ = value;
}

// optional uint32 callInterval = 14;
inline bool TMTBookConferenceInfo::has_callinterval() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_callinterval() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTBookConferenceInfo::clear_has_callinterval() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTBookConferenceInfo::clear_callinterval() {
  callinterval_ = 0u;
  clear_has_callinterval();
}
inline ::google::protobuf::uint32 TMTBookConferenceInfo::callinterval() const {
  return callinterval_;
}
inline void TMTBookConferenceInfo::set_callinterval(::google::protobuf::uint32 value) {
  set_has_callinterval();
  callinterval_ = value;
}

// optional bool initmute = 15;
inline bool TMTBookConferenceInfo::has_initmute() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_initmute() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTBookConferenceInfo::clear_has_initmute() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTBookConferenceInfo::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTBookConferenceInfo::initmute() const {
  return initmute_;
}
inline void TMTBookConferenceInfo::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional bool initSilence = 16;
inline bool TMTBookConferenceInfo::has_initsilence() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_initsilence() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTBookConferenceInfo::clear_has_initsilence() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTBookConferenceInfo::clear_initsilence() {
  initsilence_ = false;
  clear_has_initsilence();
}
inline bool TMTBookConferenceInfo::initsilence() const {
  return initsilence_;
}
inline void TMTBookConferenceInfo::set_initsilence(bool value) {
  set_has_initsilence();
  initsilence_ = value;
}

// optional .mt.EmRestVideoQuality vidoQuality = 17;
inline bool TMTBookConferenceInfo::has_vidoquality() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_vidoquality() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTBookConferenceInfo::clear_has_vidoquality() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTBookConferenceInfo::clear_vidoquality() {
  vidoquality_ = 0;
  clear_has_vidoquality();
}
inline ::mt::EmRestVideoQuality TMTBookConferenceInfo::vidoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(vidoquality_);
}
inline void TMTBookConferenceInfo::set_vidoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_vidoquality();
  vidoquality_ = value;
}

// optional .mt.EmRestDualMode dualmode = 18;
inline bool TMTBookConferenceInfo::has_dualmode() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_dualmode() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTBookConferenceInfo::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTBookConferenceInfo::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTBookConferenceInfo::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTBookConferenceInfo::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool voiceActivityDetection = 19;
inline bool TMTBookConferenceInfo::has_voiceactivitydetection() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_voiceactivitydetection() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTBookConferenceInfo::clear_has_voiceactivitydetection() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTBookConferenceInfo::clear_voiceactivitydetection() {
  voiceactivitydetection_ = false;
  clear_has_voiceactivitydetection();
}
inline bool TMTBookConferenceInfo::voiceactivitydetection() const {
  return voiceactivitydetection_;
}
inline void TMTBookConferenceInfo::set_voiceactivitydetection(bool value) {
  set_has_voiceactivitydetection();
  voiceactivitydetection_ = value;
}

// optional .mt.EmRestCascadeMode emCascadeMode = 20;
inline bool TMTBookConferenceInfo::has_emcascademode() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_emcascademode() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTBookConferenceInfo::clear_has_emcascademode() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTBookConferenceInfo::clear_emcascademode() {
  emcascademode_ = 0;
  clear_has_emcascademode();
}
inline ::mt::EmRestCascadeMode TMTBookConferenceInfo::emcascademode() const {
  return static_cast< ::mt::EmRestCascadeMode >(emcascademode_);
}
inline void TMTBookConferenceInfo::set_emcascademode(::mt::EmRestCascadeMode value) {
  assert(::mt::EmRestCascadeMode_IsValid(value));
  set_has_emcascademode();
  emcascademode_ = value;
}

// optional bool cascadeUpload = 21;
inline bool TMTBookConferenceInfo::has_cascadeupload() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_cascadeupload() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTBookConferenceInfo::clear_has_cascadeupload() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTBookConferenceInfo::clear_cascadeupload() {
  cascadeupload_ = false;
  clear_has_cascadeupload();
}
inline bool TMTBookConferenceInfo::cascadeupload() const {
  return cascadeupload_;
}
inline void TMTBookConferenceInfo::set_cascadeupload(bool value) {
  set_has_cascadeupload();
  cascadeupload_ = value;
}

// optional bool cascadeReturn = 22;
inline bool TMTBookConferenceInfo::has_cascadereturn() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_cascadereturn() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTBookConferenceInfo::clear_has_cascadereturn() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTBookConferenceInfo::clear_cascadereturn() {
  cascadereturn_ = false;
  clear_has_cascadereturn();
}
inline bool TMTBookConferenceInfo::cascadereturn() const {
  return cascadereturn_;
}
inline void TMTBookConferenceInfo::set_cascadereturn(bool value) {
  set_has_cascadereturn();
  cascadereturn_ = value;
}

// optional uint32 cascadeReturnPara = 23;
inline bool TMTBookConferenceInfo::has_cascadereturnpara() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_cascadereturnpara() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTBookConferenceInfo::clear_has_cascadereturnpara() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTBookConferenceInfo::clear_cascadereturnpara() {
  cascadereturnpara_ = 0u;
  clear_has_cascadereturnpara();
}
inline ::google::protobuf::uint32 TMTBookConferenceInfo::cascadereturnpara() const {
  return cascadereturnpara_;
}
inline void TMTBookConferenceInfo::set_cascadereturnpara(::google::protobuf::uint32 value) {
  set_has_cascadereturnpara();
  cascadereturnpara_ = value;
}

// optional bool publicConf = 24;
inline bool TMTBookConferenceInfo::has_publicconf() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_publicconf() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTBookConferenceInfo::clear_has_publicconf() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTBookConferenceInfo::clear_publicconf() {
  publicconf_ = false;
  clear_has_publicconf();
}
inline bool TMTBookConferenceInfo::publicconf() const {
  return publicconf_;
}
inline void TMTBookConferenceInfo::set_publicconf(bool value) {
  set_has_publicconf();
  publicconf_ = value;
}

// optional bool vmpEnable = 25;
inline bool TMTBookConferenceInfo::has_vmpenable() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_vmpenable() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTBookConferenceInfo::clear_has_vmpenable() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTBookConferenceInfo::clear_vmpenable() {
  vmpenable_ = false;
  clear_has_vmpenable();
}
inline bool TMTBookConferenceInfo::vmpenable() const {
  return vmpenable_;
}
inline void TMTBookConferenceInfo::set_vmpenable(bool value) {
  set_has_vmpenable();
  vmpenable_ = value;
}

// optional bool mixEnable = 26;
inline bool TMTBookConferenceInfo::has_mixenable() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_mixenable() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMTBookConferenceInfo::clear_has_mixenable() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMTBookConferenceInfo::clear_mixenable() {
  mixenable_ = false;
  clear_has_mixenable();
}
inline bool TMTBookConferenceInfo::mixenable() const {
  return mixenable_;
}
inline void TMTBookConferenceInfo::set_mixenable(bool value) {
  set_has_mixenable();
  mixenable_ = value;
}

// optional bool pollEnable = 27;
inline bool TMTBookConferenceInfo::has_pollenable() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_pollenable() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMTBookConferenceInfo::clear_has_pollenable() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMTBookConferenceInfo::clear_pollenable() {
  pollenable_ = false;
  clear_has_pollenable();
}
inline bool TMTBookConferenceInfo::pollenable() const {
  return pollenable_;
}
inline void TMTBookConferenceInfo::set_pollenable(bool value) {
  set_has_pollenable();
  pollenable_ = value;
}

// optional uint32 invitedMtNum = 28;
inline bool TMTBookConferenceInfo::has_invitedmtnum() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_invitedmtnum() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTBookConferenceInfo::clear_has_invitedmtnum() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTBookConferenceInfo::clear_invitedmtnum() {
  invitedmtnum_ = 0u;
  clear_has_invitedmtnum();
}
inline ::google::protobuf::uint32 TMTBookConferenceInfo::invitedmtnum() const {
  return invitedmtnum_;
}
inline void TMTBookConferenceInfo::set_invitedmtnum(::google::protobuf::uint32 value) {
  set_has_invitedmtnum();
  invitedmtnum_ = value;
}

// optional uint32 maxJoinMt = 29;
inline bool TMTBookConferenceInfo::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMTBookConferenceInfo::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMTBookConferenceInfo::clear_maxjoinmt() {
  maxjoinmt_ = 0u;
  clear_has_maxjoinmt();
}
inline ::google::protobuf::uint32 TMTBookConferenceInfo::maxjoinmt() const {
  return maxjoinmt_;
}
inline void TMTBookConferenceInfo::set_maxjoinmt(::google::protobuf::uint32 value) {
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional .mt.TMTConfInitiator confInitiator = 30;
inline bool TMTBookConferenceInfo::has_confinitiator() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_confinitiator() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMTBookConferenceInfo::clear_has_confinitiator() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMTBookConferenceInfo::clear_confinitiator() {
  if (confinitiator_ != NULL) confinitiator_->::mt::TMTConfInitiator::Clear();
  clear_has_confinitiator();
}
inline const ::mt::TMTConfInitiator& TMTBookConferenceInfo::confinitiator() const {
  return confinitiator_ != NULL ? *confinitiator_ : *default_instance_->confinitiator_;
}
inline ::mt::TMTConfInitiator* TMTBookConferenceInfo::mutable_confinitiator() {
  set_has_confinitiator();
  if (confinitiator_ == NULL) confinitiator_ = new ::mt::TMTConfInitiator;
  return confinitiator_;
}
inline ::mt::TMTConfInitiator* TMTBookConferenceInfo::release_confinitiator() {
  clear_has_confinitiator();
  ::mt::TMTConfInitiator* temp = confinitiator_;
  confinitiator_ = NULL;
  return temp;
}
inline void TMTBookConferenceInfo::set_allocated_confinitiator(::mt::TMTConfInitiator* confinitiator) {
  delete confinitiator_;
  confinitiator_ = confinitiator;
  if (confinitiator) {
    set_has_confinitiator();
  } else {
    clear_has_confinitiator();
  }
}

// optional .mt.TMTTemplateMember speaker = 31;
inline bool TMTBookConferenceInfo::has_speaker() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_speaker() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TMTBookConferenceInfo::clear_has_speaker() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TMTBookConferenceInfo::clear_speaker() {
  if (speaker_ != NULL) speaker_->::mt::TMTTemplateMember::Clear();
  clear_has_speaker();
}
inline const ::mt::TMTTemplateMember& TMTBookConferenceInfo::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::mt::TMTTemplateMember* TMTBookConferenceInfo::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::mt::TMTTemplateMember;
  return speaker_;
}
inline ::mt::TMTTemplateMember* TMTBookConferenceInfo::release_speaker() {
  clear_has_speaker();
  ::mt::TMTTemplateMember* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void TMTBookConferenceInfo::set_allocated_speaker(::mt::TMTTemplateMember* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional .mt.TMTTemplateMember chairman = 32;
inline bool TMTBookConferenceInfo::has_chairman() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TMTBookConferenceInfo::set_has_chairman() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TMTBookConferenceInfo::clear_has_chairman() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TMTBookConferenceInfo::clear_chairman() {
  if (chairman_ != NULL) chairman_->::mt::TMTTemplateMember::Clear();
  clear_has_chairman();
}
inline const ::mt::TMTTemplateMember& TMTBookConferenceInfo::chairman() const {
  return chairman_ != NULL ? *chairman_ : *default_instance_->chairman_;
}
inline ::mt::TMTTemplateMember* TMTBookConferenceInfo::mutable_chairman() {
  set_has_chairman();
  if (chairman_ == NULL) chairman_ = new ::mt::TMTTemplateMember;
  return chairman_;
}
inline ::mt::TMTTemplateMember* TMTBookConferenceInfo::release_chairman() {
  clear_has_chairman();
  ::mt::TMTTemplateMember* temp = chairman_;
  chairman_ = NULL;
  return temp;
}
inline void TMTBookConferenceInfo::set_allocated_chairman(::mt::TMTTemplateMember* chairman) {
  delete chairman_;
  chairman_ = chairman;
  if (chairman) {
    set_has_chairman();
  } else {
    clear_has_chairman();
  }
}

// repeated .mt.TMTVideoFormatList videoFormatList = 33;
inline int TMTBookConferenceInfo::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTBookConferenceInfo::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTBookConferenceInfo::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTBookConferenceInfo::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTBookConferenceInfo::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTBookConferenceInfo::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTBookConferenceInfo::mutable_videoformatlist() {
  return &videoformatlist_;
}

// optional uint32 oneReforming = 34;
inline bool TMTBookConferenceInfo::has_onereforming() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TMTBookConferenceInfo::set_has_onereforming() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TMTBookConferenceInfo::clear_has_onereforming() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TMTBookConferenceInfo::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TMTBookConferenceInfo::onereforming() const {
  return onereforming_;
}
inline void TMTBookConferenceInfo::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional bool autoEnd = 35;
inline bool TMTBookConferenceInfo::has_autoend() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TMTBookConferenceInfo::set_has_autoend() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TMTBookConferenceInfo::clear_has_autoend() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TMTBookConferenceInfo::clear_autoend() {
  autoend_ = false;
  clear_has_autoend();
}
inline bool TMTBookConferenceInfo::autoend() const {
  return autoend_;
}
inline void TMTBookConferenceInfo::set_autoend(bool value) {
  set_has_autoend();
  autoend_ = value;
}

// optional bool preoccpuyResouce = 36;
inline bool TMTBookConferenceInfo::has_preoccpuyresouce() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TMTBookConferenceInfo::set_has_preoccpuyresouce() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TMTBookConferenceInfo::clear_has_preoccpuyresouce() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TMTBookConferenceInfo::clear_preoccpuyresouce() {
  preoccpuyresouce_ = false;
  clear_has_preoccpuyresouce();
}
inline bool TMTBookConferenceInfo::preoccpuyresouce() const {
  return preoccpuyresouce_;
}
inline void TMTBookConferenceInfo::set_preoccpuyresouce(bool value) {
  set_has_preoccpuyresouce();
  preoccpuyresouce_ = value;
}

// optional bool encrypted_auth = 37;
inline bool TMTBookConferenceInfo::has_encrypted_auth() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TMTBookConferenceInfo::set_has_encrypted_auth() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TMTBookConferenceInfo::clear_has_encrypted_auth() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TMTBookConferenceInfo::clear_encrypted_auth() {
  encrypted_auth_ = false;
  clear_has_encrypted_auth();
}
inline bool TMTBookConferenceInfo::encrypted_auth() const {
  return encrypted_auth_;
}
inline void TMTBookConferenceInfo::set_encrypted_auth(bool value) {
  set_has_encrypted_auth();
  encrypted_auth_ = value;
}

// optional .mt.EmMtFecMode fecmode = 38;
inline bool TMTBookConferenceInfo::has_fecmode() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void TMTBookConferenceInfo::set_has_fecmode() {
  _has_bits_[1] |= 0x00000020u;
}
inline void TMTBookConferenceInfo::clear_has_fecmode() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void TMTBookConferenceInfo::clear_fecmode() {
  fecmode_ = 0;
  clear_has_fecmode();
}
inline ::mt::EmMtFecMode TMTBookConferenceInfo::fecmode() const {
  return static_cast< ::mt::EmMtFecMode >(fecmode_);
}
inline void TMTBookConferenceInfo::set_fecmode(::mt::EmMtFecMode value) {
  assert(::mt::EmMtFecMode_IsValid(value));
  set_has_fecmode();
  fecmode_ = value;
}

// optional bool doubleflow = 39;
inline bool TMTBookConferenceInfo::has_doubleflow() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void TMTBookConferenceInfo::set_has_doubleflow() {
  _has_bits_[1] |= 0x00000040u;
}
inline void TMTBookConferenceInfo::clear_has_doubleflow() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void TMTBookConferenceInfo::clear_doubleflow() {
  doubleflow_ = false;
  clear_has_doubleflow();
}
inline bool TMTBookConferenceInfo::doubleflow() const {
  return doubleflow_;
}
inline void TMTBookConferenceInfo::set_doubleflow(bool value) {
  set_has_doubleflow();
  doubleflow_ = value;
}

// optional bool mutefilter = 40;
inline bool TMTBookConferenceInfo::has_mutefilter() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void TMTBookConferenceInfo::set_has_mutefilter() {
  _has_bits_[1] |= 0x00000080u;
}
inline void TMTBookConferenceInfo::clear_has_mutefilter() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void TMTBookConferenceInfo::clear_mutefilter() {
  mutefilter_ = false;
  clear_has_mutefilter();
}
inline bool TMTBookConferenceInfo::mutefilter() const {
  return mutefilter_;
}
inline void TMTBookConferenceInfo::set_mutefilter(bool value) {
  set_has_mutefilter();
  mutefilter_ = value;
}

// -------------------------------------------------------------------

// TMTInstantConference

// optional string name = 1;
inline bool TMTInstantConference::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTInstantConference::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTInstantConference::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTInstantConference::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTInstantConference::name() const {
  return *name_;
}
inline void TMTInstantConference::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTInstantConference::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTInstantConference::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConference::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTInstantConference::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConference::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 2;
inline bool TMTInstantConference::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTInstantConference::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTInstantConference::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTInstantConference::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTInstantConference::duration() const {
  return duration_;
}
inline void TMTInstantConference::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 bitrate = 3;
inline bool TMTInstantConference::has_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTInstantConference::set_has_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTInstantConference::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTInstantConference::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTInstantConference::bitrate() const {
  return bitrate_;
}
inline void TMTInstantConference::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmClosedMeeting closeConf = 4;
inline bool TMTInstantConference::has_closeconf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTInstantConference::set_has_closeconf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTInstantConference::clear_has_closeconf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTInstantConference::clear_closeconf() {
  closeconf_ = 0;
  clear_has_closeconf();
}
inline ::mt::EmClosedMeeting TMTInstantConference::closeconf() const {
  return static_cast< ::mt::EmClosedMeeting >(closeconf_);
}
inline void TMTInstantConference::set_closeconf(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closeconf();
  closeconf_ = value;
}

// optional .mt.EmMtOpenMode safeConf = 5;
inline bool TMTInstantConference::has_safeconf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTInstantConference::set_has_safeconf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTInstantConference::clear_has_safeconf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTInstantConference::clear_safeconf() {
  safeconf_ = 1;
  clear_has_safeconf();
}
inline ::mt::EmMtOpenMode TMTInstantConference::safeconf() const {
  return static_cast< ::mt::EmMtOpenMode >(safeconf_);
}
inline void TMTInstantConference::set_safeconf(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_safeconf();
  safeconf_ = value;
}

// optional string password = 6;
inline bool TMTInstantConference::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTInstantConference::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTInstantConference::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTInstantConference::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTInstantConference::password() const {
  return *password_;
}
inline void TMTInstantConference::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTInstantConference::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTInstantConference::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConference::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTInstantConference::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConference::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmEncryptArithmetic encryptedtype = 7;
inline bool TMTInstantConference::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTInstantConference::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTInstantConference::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTInstantConference::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTInstantConference::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTInstantConference::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional .mt.EmRestMeetingSafeType meetingtype = 8;
inline bool TMTInstantConference::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTInstantConference::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTInstantConference::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTInstantConference::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTInstantConference::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTInstantConference::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional uint32 callTimes = 9;
inline bool TMTInstantConference::has_calltimes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTInstantConference::set_has_calltimes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTInstantConference::clear_has_calltimes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTInstantConference::clear_calltimes() {
  calltimes_ = 0u;
  clear_has_calltimes();
}
inline ::google::protobuf::uint32 TMTInstantConference::calltimes() const {
  return calltimes_;
}
inline void TMTInstantConference::set_calltimes(::google::protobuf::uint32 value) {
  set_has_calltimes();
  calltimes_ = value;
}

// optional uint32 callInterval = 10;
inline bool TMTInstantConference::has_callinterval() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTInstantConference::set_has_callinterval() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTInstantConference::clear_has_callinterval() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTInstantConference::clear_callinterval() {
  callinterval_ = 0u;
  clear_has_callinterval();
}
inline ::google::protobuf::uint32 TMTInstantConference::callinterval() const {
  return callinterval_;
}
inline void TMTInstantConference::set_callinterval(::google::protobuf::uint32 value) {
  set_has_callinterval();
  callinterval_ = value;
}

// optional bool initmute = 11;
inline bool TMTInstantConference::has_initmute() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTInstantConference::set_has_initmute() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTInstantConference::clear_has_initmute() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTInstantConference::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTInstantConference::initmute() const {
  return initmute_;
}
inline void TMTInstantConference::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional bool initSilence = 12;
inline bool TMTInstantConference::has_initsilence() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTInstantConference::set_has_initsilence() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTInstantConference::clear_has_initsilence() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTInstantConference::clear_initsilence() {
  initsilence_ = false;
  clear_has_initsilence();
}
inline bool TMTInstantConference::initsilence() const {
  return initsilence_;
}
inline void TMTInstantConference::set_initsilence(bool value) {
  set_has_initsilence();
  initsilence_ = value;
}

// optional .mt.EmRestVideoQuality vidoQuality = 13;
inline bool TMTInstantConference::has_vidoquality() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTInstantConference::set_has_vidoquality() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTInstantConference::clear_has_vidoquality() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTInstantConference::clear_vidoquality() {
  vidoquality_ = 0;
  clear_has_vidoquality();
}
inline ::mt::EmRestVideoQuality TMTInstantConference::vidoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(vidoquality_);
}
inline void TMTInstantConference::set_vidoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_vidoquality();
  vidoquality_ = value;
}

// optional string encryptedkey = 14;
inline bool TMTInstantConference::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTInstantConference::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTInstantConference::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTInstantConference::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTInstantConference::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTInstantConference::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTInstantConference::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTInstantConference::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConference::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTInstantConference::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConference::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestDualMode dualmode = 15;
inline bool TMTInstantConference::has_dualmode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTInstantConference::set_has_dualmode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTInstantConference::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTInstantConference::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTInstantConference::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTInstantConference::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool voiceActivityDetection = 16;
inline bool TMTInstantConference::has_voiceactivitydetection() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTInstantConference::set_has_voiceactivitydetection() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTInstantConference::clear_has_voiceactivitydetection() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTInstantConference::clear_voiceactivitydetection() {
  voiceactivitydetection_ = false;
  clear_has_voiceactivitydetection();
}
inline bool TMTInstantConference::voiceactivitydetection() const {
  return voiceactivitydetection_;
}
inline void TMTInstantConference::set_voiceactivitydetection(bool value) {
  set_has_voiceactivitydetection();
  voiceactivitydetection_ = value;
}

// optional .mt.EmRestCascadeMode emCascadeMode = 17;
inline bool TMTInstantConference::has_emcascademode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTInstantConference::set_has_emcascademode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTInstantConference::clear_has_emcascademode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTInstantConference::clear_emcascademode() {
  emcascademode_ = 0;
  clear_has_emcascademode();
}
inline ::mt::EmRestCascadeMode TMTInstantConference::emcascademode() const {
  return static_cast< ::mt::EmRestCascadeMode >(emcascademode_);
}
inline void TMTInstantConference::set_emcascademode(::mt::EmRestCascadeMode value) {
  assert(::mt::EmRestCascadeMode_IsValid(value));
  set_has_emcascademode();
  emcascademode_ = value;
}

// optional bool cascadeUpload = 18;
inline bool TMTInstantConference::has_cascadeupload() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTInstantConference::set_has_cascadeupload() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTInstantConference::clear_has_cascadeupload() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTInstantConference::clear_cascadeupload() {
  cascadeupload_ = false;
  clear_has_cascadeupload();
}
inline bool TMTInstantConference::cascadeupload() const {
  return cascadeupload_;
}
inline void TMTInstantConference::set_cascadeupload(bool value) {
  set_has_cascadeupload();
  cascadeupload_ = value;
}

// optional bool cascadeReturn = 19;
inline bool TMTInstantConference::has_cascadereturn() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTInstantConference::set_has_cascadereturn() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTInstantConference::clear_has_cascadereturn() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTInstantConference::clear_cascadereturn() {
  cascadereturn_ = false;
  clear_has_cascadereturn();
}
inline bool TMTInstantConference::cascadereturn() const {
  return cascadereturn_;
}
inline void TMTInstantConference::set_cascadereturn(bool value) {
  set_has_cascadereturn();
  cascadereturn_ = value;
}

// optional uint32 cascadeReturnPara = 20;
inline bool TMTInstantConference::has_cascadereturnpara() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTInstantConference::set_has_cascadereturnpara() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTInstantConference::clear_has_cascadereturnpara() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTInstantConference::clear_cascadereturnpara() {
  cascadereturnpara_ = 0u;
  clear_has_cascadereturnpara();
}
inline ::google::protobuf::uint32 TMTInstantConference::cascadereturnpara() const {
  return cascadereturnpara_;
}
inline void TMTInstantConference::set_cascadereturnpara(::google::protobuf::uint32 value) {
  set_has_cascadereturnpara();
  cascadereturnpara_ = value;
}

// optional uint32 maxJoinMt = 21;
inline bool TMTInstantConference::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTInstantConference::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTInstantConference::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTInstantConference::clear_maxjoinmt() {
  maxjoinmt_ = 0u;
  clear_has_maxjoinmt();
}
inline ::google::protobuf::uint32 TMTInstantConference::maxjoinmt() const {
  return maxjoinmt_;
}
inline void TMTInstantConference::set_maxjoinmt(::google::protobuf::uint32 value) {
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional .mt.TMTTemplateMember speaker = 22;
inline bool TMTInstantConference::has_speaker() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTInstantConference::set_has_speaker() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTInstantConference::clear_has_speaker() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTInstantConference::clear_speaker() {
  if (speaker_ != NULL) speaker_->::mt::TMTTemplateMember::Clear();
  clear_has_speaker();
}
inline const ::mt::TMTTemplateMember& TMTInstantConference::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::mt::TMTTemplateMember* TMTInstantConference::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::mt::TMTTemplateMember;
  return speaker_;
}
inline ::mt::TMTTemplateMember* TMTInstantConference::release_speaker() {
  clear_has_speaker();
  ::mt::TMTTemplateMember* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void TMTInstantConference::set_allocated_speaker(::mt::TMTTemplateMember* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional .mt.TMTTemplateMember chairman = 23;
inline bool TMTInstantConference::has_chairman() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTInstantConference::set_has_chairman() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTInstantConference::clear_has_chairman() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTInstantConference::clear_chairman() {
  if (chairman_ != NULL) chairman_->::mt::TMTTemplateMember::Clear();
  clear_has_chairman();
}
inline const ::mt::TMTTemplateMember& TMTInstantConference::chairman() const {
  return chairman_ != NULL ? *chairman_ : *default_instance_->chairman_;
}
inline ::mt::TMTTemplateMember* TMTInstantConference::mutable_chairman() {
  set_has_chairman();
  if (chairman_ == NULL) chairman_ = new ::mt::TMTTemplateMember;
  return chairman_;
}
inline ::mt::TMTTemplateMember* TMTInstantConference::release_chairman() {
  clear_has_chairman();
  ::mt::TMTTemplateMember* temp = chairman_;
  chairman_ = NULL;
  return temp;
}
inline void TMTInstantConference::set_allocated_chairman(::mt::TMTTemplateMember* chairman) {
  delete chairman_;
  chairman_ = chairman;
  if (chairman) {
    set_has_chairman();
  } else {
    clear_has_chairman();
  }
}

// optional bool publicConf = 24;
inline bool TMTInstantConference::has_publicconf() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTInstantConference::set_has_publicconf() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTInstantConference::clear_has_publicconf() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTInstantConference::clear_publicconf() {
  publicconf_ = false;
  clear_has_publicconf();
}
inline bool TMTInstantConference::publicconf() const {
  return publicconf_;
}
inline void TMTInstantConference::set_publicconf(bool value) {
  set_has_publicconf();
  publicconf_ = value;
}

// optional .mt.TMTConfMixInfo mix = 25;
inline bool TMTInstantConference::has_mix() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTInstantConference::set_has_mix() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTInstantConference::clear_has_mix() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTInstantConference::clear_mix() {
  if (mix_ != NULL) mix_->::mt::TMTConfMixInfo::Clear();
  clear_has_mix();
}
inline const ::mt::TMTConfMixInfo& TMTInstantConference::mix() const {
  return mix_ != NULL ? *mix_ : *default_instance_->mix_;
}
inline ::mt::TMTConfMixInfo* TMTInstantConference::mutable_mix() {
  set_has_mix();
  if (mix_ == NULL) mix_ = new ::mt::TMTConfMixInfo;
  return mix_;
}
inline ::mt::TMTConfMixInfo* TMTInstantConference::release_mix() {
  clear_has_mix();
  ::mt::TMTConfMixInfo* temp = mix_;
  mix_ = NULL;
  return temp;
}
inline void TMTInstantConference::set_allocated_mix(::mt::TMTConfMixInfo* mix) {
  delete mix_;
  mix_ = mix;
  if (mix) {
    set_has_mix();
  } else {
    clear_has_mix();
  }
}

// repeated .mt.TMTVideoFormatList videoFormatList = 26;
inline int TMTInstantConference::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTInstantConference::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTInstantConference::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTInstantConference::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTInstantConference::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTInstantConference::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTInstantConference::mutable_videoformatlist() {
  return &videoformatlist_;
}

// repeated .mt.TMTInviteMember inviteMembers = 27;
inline int TMTInstantConference::invitemembers_size() const {
  return invitemembers_.size();
}
inline void TMTInstantConference::clear_invitemembers() {
  invitemembers_.Clear();
}
inline const ::mt::TMTInviteMember& TMTInstantConference::invitemembers(int index) const {
  return invitemembers_.Get(index);
}
inline ::mt::TMTInviteMember* TMTInstantConference::mutable_invitemembers(int index) {
  return invitemembers_.Mutable(index);
}
inline ::mt::TMTInviteMember* TMTInstantConference::add_invitemembers() {
  return invitemembers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >&
TMTInstantConference::invitemembers() const {
  return invitemembers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTInviteMember >*
TMTInstantConference::mutable_invitemembers() {
  return &invitemembers_;
}

// optional .mt.TMTConfVMPInfo vmp = 28;
inline bool TMTInstantConference::has_vmp() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTInstantConference::set_has_vmp() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTInstantConference::clear_has_vmp() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTInstantConference::clear_vmp() {
  if (vmp_ != NULL) vmp_->::mt::TMTConfVMPInfo::Clear();
  clear_has_vmp();
}
inline const ::mt::TMTConfVMPInfo& TMTInstantConference::vmp() const {
  return vmp_ != NULL ? *vmp_ : *default_instance_->vmp_;
}
inline ::mt::TMTConfVMPInfo* TMTInstantConference::mutable_vmp() {
  set_has_vmp();
  if (vmp_ == NULL) vmp_ = new ::mt::TMTConfVMPInfo;
  return vmp_;
}
inline ::mt::TMTConfVMPInfo* TMTInstantConference::release_vmp() {
  clear_has_vmp();
  ::mt::TMTConfVMPInfo* temp = vmp_;
  vmp_ = NULL;
  return temp;
}
inline void TMTInstantConference::set_allocated_vmp(::mt::TMTConfVMPInfo* vmp) {
  delete vmp_;
  vmp_ = vmp;
  if (vmp) {
    set_has_vmp();
  } else {
    clear_has_vmp();
  }
}

// repeated .mt.TMTTemplateMember viplist = 29;
inline int TMTInstantConference::viplist_size() const {
  return viplist_.size();
}
inline void TMTInstantConference::clear_viplist() {
  viplist_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTInstantConference::viplist(int index) const {
  return viplist_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTInstantConference::mutable_viplist(int index) {
  return viplist_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTInstantConference::add_viplist() {
  return viplist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTInstantConference::viplist() const {
  return viplist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTInstantConference::mutable_viplist() {
  return &viplist_;
}

// optional .mt.TMTConfPollInfo poll = 30;
inline bool TMTInstantConference::has_poll() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMTInstantConference::set_has_poll() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMTInstantConference::clear_has_poll() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMTInstantConference::clear_poll() {
  if (poll_ != NULL) poll_->::mt::TMTConfPollInfo::Clear();
  clear_has_poll();
}
inline const ::mt::TMTConfPollInfo& TMTInstantConference::poll() const {
  return poll_ != NULL ? *poll_ : *default_instance_->poll_;
}
inline ::mt::TMTConfPollInfo* TMTInstantConference::mutable_poll() {
  set_has_poll();
  if (poll_ == NULL) poll_ = new ::mt::TMTConfPollInfo;
  return poll_;
}
inline ::mt::TMTConfPollInfo* TMTInstantConference::release_poll() {
  clear_has_poll();
  ::mt::TMTConfPollInfo* temp = poll_;
  poll_ = NULL;
  return temp;
}
inline void TMTInstantConference::set_allocated_poll(::mt::TMTConfPollInfo* poll) {
  delete poll_;
  poll_ = poll;
  if (poll) {
    set_has_poll();
  } else {
    clear_has_poll();
  }
}

// optional bool autoEnd = 31;
inline bool TMTInstantConference::has_autoend() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TMTInstantConference::set_has_autoend() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TMTInstantConference::clear_has_autoend() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TMTInstantConference::clear_autoend() {
  autoend_ = false;
  clear_has_autoend();
}
inline bool TMTInstantConference::autoend() const {
  return autoend_;
}
inline void TMTInstantConference::set_autoend(bool value) {
  set_has_autoend();
  autoend_ = value;
}

// optional bool preoccpuyResouce = 32;
inline bool TMTInstantConference::has_preoccpuyresouce() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TMTInstantConference::set_has_preoccpuyresouce() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TMTInstantConference::clear_has_preoccpuyresouce() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TMTInstantConference::clear_preoccpuyresouce() {
  preoccpuyresouce_ = false;
  clear_has_preoccpuyresouce();
}
inline bool TMTInstantConference::preoccpuyresouce() const {
  return preoccpuyresouce_;
}
inline void TMTInstantConference::set_preoccpuyresouce(bool value) {
  set_has_preoccpuyresouce();
  preoccpuyresouce_ = value;
}

// optional uint32 vacinterval = 33;
inline bool TMTInstantConference::has_vacinterval() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TMTInstantConference::set_has_vacinterval() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TMTInstantConference::clear_has_vacinterval() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TMTInstantConference::clear_vacinterval() {
  vacinterval_ = 0u;
  clear_has_vacinterval();
}
inline ::google::protobuf::uint32 TMTInstantConference::vacinterval() const {
  return vacinterval_;
}
inline void TMTInstantConference::set_vacinterval(::google::protobuf::uint32 value) {
  set_has_vacinterval();
  vacinterval_ = value;
}

// optional .mt.TMTRecordAttribute recordattr = 34;
inline bool TMTInstantConference::has_recordattr() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TMTInstantConference::set_has_recordattr() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TMTInstantConference::clear_has_recordattr() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TMTInstantConference::clear_recordattr() {
  if (recordattr_ != NULL) recordattr_->::mt::TMTRecordAttribute::Clear();
  clear_has_recordattr();
}
inline const ::mt::TMTRecordAttribute& TMTInstantConference::recordattr() const {
  return recordattr_ != NULL ? *recordattr_ : *default_instance_->recordattr_;
}
inline ::mt::TMTRecordAttribute* TMTInstantConference::mutable_recordattr() {
  set_has_recordattr();
  if (recordattr_ == NULL) recordattr_ = new ::mt::TMTRecordAttribute;
  return recordattr_;
}
inline ::mt::TMTRecordAttribute* TMTInstantConference::release_recordattr() {
  clear_has_recordattr();
  ::mt::TMTRecordAttribute* temp = recordattr_;
  recordattr_ = NULL;
  return temp;
}
inline void TMTInstantConference::set_allocated_recordattr(::mt::TMTRecordAttribute* recordattr) {
  delete recordattr_;
  recordattr_ = recordattr;
  if (recordattr) {
    set_has_recordattr();
  } else {
    clear_has_recordattr();
  }
}

// optional bool encrypted_auth = 35;
inline bool TMTInstantConference::has_encrypted_auth() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TMTInstantConference::set_has_encrypted_auth() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TMTInstantConference::clear_has_encrypted_auth() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TMTInstantConference::clear_encrypted_auth() {
  encrypted_auth_ = false;
  clear_has_encrypted_auth();
}
inline bool TMTInstantConference::encrypted_auth() const {
  return encrypted_auth_;
}
inline void TMTInstantConference::set_encrypted_auth(bool value) {
  set_has_encrypted_auth();
  encrypted_auth_ = value;
}

// optional .mt.EmCallMode emCallMode = 36;
inline bool TMTInstantConference::has_emcallmode() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TMTInstantConference::set_has_emcallmode() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TMTInstantConference::clear_has_emcallmode() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TMTInstantConference::clear_emcallmode() {
  emcallmode_ = 0;
  clear_has_emcallmode();
}
inline ::mt::EmCallMode TMTInstantConference::emcallmode() const {
  return static_cast< ::mt::EmCallMode >(emcallmode_);
}
inline void TMTInstantConference::set_emcallmode(::mt::EmCallMode value) {
  assert(::mt::EmCallMode_IsValid(value));
  set_has_emcallmode();
  emcallmode_ = value;
}

// optional .mt.TMTDCSAttribute dcsattr = 37;
inline bool TMTInstantConference::has_dcsattr() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TMTInstantConference::set_has_dcsattr() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TMTInstantConference::clear_has_dcsattr() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TMTInstantConference::clear_dcsattr() {
  if (dcsattr_ != NULL) dcsattr_->::mt::TMTDCSAttribute::Clear();
  clear_has_dcsattr();
}
inline const ::mt::TMTDCSAttribute& TMTInstantConference::dcsattr() const {
  return dcsattr_ != NULL ? *dcsattr_ : *default_instance_->dcsattr_;
}
inline ::mt::TMTDCSAttribute* TMTInstantConference::mutable_dcsattr() {
  set_has_dcsattr();
  if (dcsattr_ == NULL) dcsattr_ = new ::mt::TMTDCSAttribute;
  return dcsattr_;
}
inline ::mt::TMTDCSAttribute* TMTInstantConference::release_dcsattr() {
  clear_has_dcsattr();
  ::mt::TMTDCSAttribute* temp = dcsattr_;
  dcsattr_ = NULL;
  return temp;
}
inline void TMTInstantConference::set_allocated_dcsattr(::mt::TMTDCSAttribute* dcsattr) {
  delete dcsattr_;
  dcsattr_ = dcsattr;
  if (dcsattr) {
    set_has_dcsattr();
  } else {
    clear_has_dcsattr();
  }
}

// optional .mt.EmVConfCreateType vconfcreatetype = 38;
inline bool TMTInstantConference::has_vconfcreatetype() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void TMTInstantConference::set_has_vconfcreatetype() {
  _has_bits_[1] |= 0x00000020u;
}
inline void TMTInstantConference::clear_has_vconfcreatetype() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void TMTInstantConference::clear_vconfcreatetype() {
  vconfcreatetype_ = 0;
  clear_has_vconfcreatetype();
}
inline ::mt::EmVConfCreateType TMTInstantConference::vconfcreatetype() const {
  return static_cast< ::mt::EmVConfCreateType >(vconfcreatetype_);
}
inline void TMTInstantConference::set_vconfcreatetype(::mt::EmVConfCreateType value) {
  assert(::mt::EmVConfCreateType_IsValid(value));
  set_has_vconfcreatetype();
  vconfcreatetype_ = value;
}

// optional string vconfid = 39;
inline bool TMTInstantConference::has_vconfid() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void TMTInstantConference::set_has_vconfid() {
  _has_bits_[1] |= 0x00000040u;
}
inline void TMTInstantConference::clear_has_vconfid() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void TMTInstantConference::clear_vconfid() {
  if (vconfid_ != &::google::protobuf::internal::kEmptyString) {
    vconfid_->clear();
  }
  clear_has_vconfid();
}
inline const ::std::string& TMTInstantConference::vconfid() const {
  return *vconfid_;
}
inline void TMTInstantConference::set_vconfid(const ::std::string& value) {
  set_has_vconfid();
  if (vconfid_ == &::google::protobuf::internal::kEmptyString) {
    vconfid_ = new ::std::string;
  }
  vconfid_->assign(value);
}
inline void TMTInstantConference::set_vconfid(const char* value) {
  set_has_vconfid();
  if (vconfid_ == &::google::protobuf::internal::kEmptyString) {
    vconfid_ = new ::std::string;
  }
  vconfid_->assign(value);
}
inline void TMTInstantConference::set_vconfid(const char* value, size_t size) {
  set_has_vconfid();
  if (vconfid_ == &::google::protobuf::internal::kEmptyString) {
    vconfid_ = new ::std::string;
  }
  vconfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConference::mutable_vconfid() {
  set_has_vconfid();
  if (vconfid_ == &::google::protobuf::internal::kEmptyString) {
    vconfid_ = new ::std::string;
  }
  return vconfid_;
}
inline ::std::string* TMTInstantConference::release_vconfid() {
  clear_has_vconfid();
  if (vconfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vconfid_;
    vconfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConference::set_allocated_vconfid(::std::string* vconfid) {
  if (vconfid_ != &::google::protobuf::internal::kEmptyString) {
    delete vconfid_;
  }
  if (vconfid) {
    set_has_vconfid();
    vconfid_ = vconfid;
  } else {
    clear_has_vconfid();
    vconfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtFecMode fecmode = 40;
inline bool TMTInstantConference::has_fecmode() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void TMTInstantConference::set_has_fecmode() {
  _has_bits_[1] |= 0x00000080u;
}
inline void TMTInstantConference::clear_has_fecmode() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void TMTInstantConference::clear_fecmode() {
  fecmode_ = 0;
  clear_has_fecmode();
}
inline ::mt::EmMtFecMode TMTInstantConference::fecmode() const {
  return static_cast< ::mt::EmMtFecMode >(fecmode_);
}
inline void TMTInstantConference::set_fecmode(::mt::EmMtFecMode value) {
  assert(::mt::EmMtFecMode_IsValid(value));
  set_has_fecmode();
  fecmode_ = value;
}

// optional bool doubleflow = 41;
inline bool TMTInstantConference::has_doubleflow() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void TMTInstantConference::set_has_doubleflow() {
  _has_bits_[1] |= 0x00000100u;
}
inline void TMTInstantConference::clear_has_doubleflow() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void TMTInstantConference::clear_doubleflow() {
  doubleflow_ = false;
  clear_has_doubleflow();
}
inline bool TMTInstantConference::doubleflow() const {
  return doubleflow_;
}
inline void TMTInstantConference::set_doubleflow(bool value) {
  set_has_doubleflow();
  doubleflow_ = value;
}

// optional bool mutefilter = 42;
inline bool TMTInstantConference::has_mutefilter() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void TMTInstantConference::set_has_mutefilter() {
  _has_bits_[1] |= 0x00000200u;
}
inline void TMTInstantConference::clear_has_mutefilter() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void TMTInstantConference::clear_mutefilter() {
  mutefilter_ = false;
  clear_has_mutefilter();
}
inline bool TMTInstantConference::mutefilter() const {
  return mutefilter_;
}
inline void TMTInstantConference::set_mutefilter(bool value) {
  set_has_mutefilter();
  mutefilter_ = value;
}

// repeated .mt.TMTTemplateMember keepcallingmembers = 43;
inline int TMTInstantConference::keepcallingmembers_size() const {
  return keepcallingmembers_.size();
}
inline void TMTInstantConference::clear_keepcallingmembers() {
  keepcallingmembers_.Clear();
}
inline const ::mt::TMTTemplateMember& TMTInstantConference::keepcallingmembers(int index) const {
  return keepcallingmembers_.Get(index);
}
inline ::mt::TMTTemplateMember* TMTInstantConference::mutable_keepcallingmembers(int index) {
  return keepcallingmembers_.Mutable(index);
}
inline ::mt::TMTTemplateMember* TMTInstantConference::add_keepcallingmembers() {
  return keepcallingmembers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >&
TMTInstantConference::keepcallingmembers() const {
  return keepcallingmembers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTTemplateMember >*
TMTInstantConference::mutable_keepcallingmembers() {
  return &keepcallingmembers_;
}

// -------------------------------------------------------------------

// TMTInstantConferenceInfo

// optional string name = 1;
inline bool TMTInstantConferenceInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTInstantConferenceInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTInstantConferenceInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTInstantConferenceInfo::name() const {
  return *name_;
}
inline void TMTInstantConferenceInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTInstantConferenceInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTInstantConferenceInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConferenceInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTInstantConferenceInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConferenceInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string confID = 2;
inline bool TMTInstantConferenceInfo::has_confid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_confid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTInstantConferenceInfo::clear_has_confid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTInstantConferenceInfo::clear_confid() {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    confid_->clear();
  }
  clear_has_confid();
}
inline const ::std::string& TMTInstantConferenceInfo::confid() const {
  return *confid_;
}
inline void TMTInstantConferenceInfo::set_confid(const ::std::string& value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTInstantConferenceInfo::set_confid(const char* value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTInstantConferenceInfo::set_confid(const char* value, size_t size) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConferenceInfo::mutable_confid() {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  return confid_;
}
inline ::std::string* TMTInstantConferenceInfo::release_confid() {
  clear_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confid_;
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConferenceInfo::set_allocated_confid(::std::string* confid) {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    delete confid_;
  }
  if (confid) {
    set_has_confid();
    confid_ = confid;
  } else {
    clear_has_confid();
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestMeetingSafeType confType = 3;
inline bool TMTInstantConferenceInfo::has_conftype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_conftype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTInstantConferenceInfo::clear_has_conftype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTInstantConferenceInfo::clear_conftype() {
  conftype_ = 0;
  clear_has_conftype();
}
inline ::mt::EmRestMeetingSafeType TMTInstantConferenceInfo::conftype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(conftype_);
}
inline void TMTInstantConferenceInfo::set_conftype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_conftype();
  conftype_ = value;
}

// optional string starTime = 4;
inline bool TMTInstantConferenceInfo::has_startime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_startime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTInstantConferenceInfo::clear_has_startime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTInstantConferenceInfo::clear_startime() {
  if (startime_ != &::google::protobuf::internal::kEmptyString) {
    startime_->clear();
  }
  clear_has_startime();
}
inline const ::std::string& TMTInstantConferenceInfo::startime() const {
  return *startime_;
}
inline void TMTInstantConferenceInfo::set_startime(const ::std::string& value) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(value);
}
inline void TMTInstantConferenceInfo::set_startime(const char* value) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(value);
}
inline void TMTInstantConferenceInfo::set_startime(const char* value, size_t size) {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  startime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConferenceInfo::mutable_startime() {
  set_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    startime_ = new ::std::string;
  }
  return startime_;
}
inline ::std::string* TMTInstantConferenceInfo::release_startime() {
  clear_has_startime();
  if (startime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startime_;
    startime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConferenceInfo::set_allocated_startime(::std::string* startime) {
  if (startime_ != &::google::protobuf::internal::kEmptyString) {
    delete startime_;
  }
  if (startime) {
    set_has_startime();
    startime_ = startime;
  } else {
    clear_has_startime();
    startime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endTime = 5;
inline bool TMTInstantConferenceInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTInstantConferenceInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTInstantConferenceInfo::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTInstantConferenceInfo::endtime() const {
  return *endtime_;
}
inline void TMTInstantConferenceInfo::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTInstantConferenceInfo::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTInstantConferenceInfo::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConferenceInfo::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTInstantConferenceInfo::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConferenceInfo::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 6;
inline bool TMTInstantConferenceInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTInstantConferenceInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTInstantConferenceInfo::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTInstantConferenceInfo::duration() const {
  return duration_;
}
inline void TMTInstantConferenceInfo::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 bitrate = 7;
inline bool TMTInstantConferenceInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTInstantConferenceInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTInstantConferenceInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTInstantConferenceInfo::bitrate() const {
  return bitrate_;
}
inline void TMTInstantConferenceInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmClosedMeeting closeConf = 8;
inline bool TMTInstantConferenceInfo::has_closeconf() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_closeconf() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTInstantConferenceInfo::clear_has_closeconf() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTInstantConferenceInfo::clear_closeconf() {
  closeconf_ = 0;
  clear_has_closeconf();
}
inline ::mt::EmClosedMeeting TMTInstantConferenceInfo::closeconf() const {
  return static_cast< ::mt::EmClosedMeeting >(closeconf_);
}
inline void TMTInstantConferenceInfo::set_closeconf(::mt::EmClosedMeeting value) {
  assert(::mt::EmClosedMeeting_IsValid(value));
  set_has_closeconf();
  closeconf_ = value;
}

// optional .mt.EmMtOpenMode safeConf = 9;
inline bool TMTInstantConferenceInfo::has_safeconf() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_safeconf() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTInstantConferenceInfo::clear_has_safeconf() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTInstantConferenceInfo::clear_safeconf() {
  safeconf_ = 1;
  clear_has_safeconf();
}
inline ::mt::EmMtOpenMode TMTInstantConferenceInfo::safeconf() const {
  return static_cast< ::mt::EmMtOpenMode >(safeconf_);
}
inline void TMTInstantConferenceInfo::set_safeconf(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_safeconf();
  safeconf_ = value;
}

// optional .mt.EmEncryptArithmetic encryptedtype = 10;
inline bool TMTInstantConferenceInfo::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTInstantConferenceInfo::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTInstantConferenceInfo::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTInstantConferenceInfo::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTInstantConferenceInfo::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional uint32 callTimes = 11;
inline bool TMTInstantConferenceInfo::has_calltimes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_calltimes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTInstantConferenceInfo::clear_has_calltimes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTInstantConferenceInfo::clear_calltimes() {
  calltimes_ = 0u;
  clear_has_calltimes();
}
inline ::google::protobuf::uint32 TMTInstantConferenceInfo::calltimes() const {
  return calltimes_;
}
inline void TMTInstantConferenceInfo::set_calltimes(::google::protobuf::uint32 value) {
  set_has_calltimes();
  calltimes_ = value;
}

// optional uint32 callInterval = 12;
inline bool TMTInstantConferenceInfo::has_callinterval() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_callinterval() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTInstantConferenceInfo::clear_has_callinterval() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTInstantConferenceInfo::clear_callinterval() {
  callinterval_ = 0u;
  clear_has_callinterval();
}
inline ::google::protobuf::uint32 TMTInstantConferenceInfo::callinterval() const {
  return callinterval_;
}
inline void TMTInstantConferenceInfo::set_callinterval(::google::protobuf::uint32 value) {
  set_has_callinterval();
  callinterval_ = value;
}

// optional bool forcebroadcast = 13;
inline bool TMTInstantConferenceInfo::has_forcebroadcast() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_forcebroadcast() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTInstantConferenceInfo::clear_has_forcebroadcast() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTInstantConferenceInfo::clear_forcebroadcast() {
  forcebroadcast_ = false;
  clear_has_forcebroadcast();
}
inline bool TMTInstantConferenceInfo::forcebroadcast() const {
  return forcebroadcast_;
}
inline void TMTInstantConferenceInfo::set_forcebroadcast(bool value) {
  set_has_forcebroadcast();
  forcebroadcast_ = value;
}

// optional bool initmute = 14;
inline bool TMTInstantConferenceInfo::has_initmute() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_initmute() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTInstantConferenceInfo::clear_has_initmute() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTInstantConferenceInfo::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTInstantConferenceInfo::initmute() const {
  return initmute_;
}
inline void TMTInstantConferenceInfo::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional bool initSilence = 15;
inline bool TMTInstantConferenceInfo::has_initsilence() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_initsilence() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTInstantConferenceInfo::clear_has_initsilence() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTInstantConferenceInfo::clear_initsilence() {
  initsilence_ = false;
  clear_has_initsilence();
}
inline bool TMTInstantConferenceInfo::initsilence() const {
  return initsilence_;
}
inline void TMTInstantConferenceInfo::set_initsilence(bool value) {
  set_has_initsilence();
  initsilence_ = value;
}

// optional .mt.EmRestVideoQuality vidoQuality = 16;
inline bool TMTInstantConferenceInfo::has_vidoquality() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_vidoquality() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTInstantConferenceInfo::clear_has_vidoquality() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTInstantConferenceInfo::clear_vidoquality() {
  vidoquality_ = 0;
  clear_has_vidoquality();
}
inline ::mt::EmRestVideoQuality TMTInstantConferenceInfo::vidoquality() const {
  return static_cast< ::mt::EmRestVideoQuality >(vidoquality_);
}
inline void TMTInstantConferenceInfo::set_vidoquality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_vidoquality();
  vidoquality_ = value;
}

// optional string encryptedkey = 17;
inline bool TMTInstantConferenceInfo::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTInstantConferenceInfo::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTInstantConferenceInfo::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTInstantConferenceInfo::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTInstantConferenceInfo::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTInstantConferenceInfo::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTInstantConferenceInfo::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConferenceInfo::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTInstantConferenceInfo::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConferenceInfo::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestDualMode dualmode = 18;
inline bool TMTInstantConferenceInfo::has_dualmode() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_dualmode() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTInstantConferenceInfo::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTInstantConferenceInfo::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmRestDualMode TMTInstantConferenceInfo::dualmode() const {
  return static_cast< ::mt::EmRestDualMode >(dualmode_);
}
inline void TMTInstantConferenceInfo::set_dualmode(::mt::EmRestDualMode value) {
  assert(::mt::EmRestDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional bool publicConf = 19;
inline bool TMTInstantConferenceInfo::has_publicconf() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_publicconf() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTInstantConferenceInfo::clear_has_publicconf() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTInstantConferenceInfo::clear_publicconf() {
  publicconf_ = false;
  clear_has_publicconf();
}
inline bool TMTInstantConferenceInfo::publicconf() const {
  return publicconf_;
}
inline void TMTInstantConferenceInfo::set_publicconf(bool value) {
  set_has_publicconf();
  publicconf_ = value;
}

// optional bool autoEnd = 20;
inline bool TMTInstantConferenceInfo::has_autoend() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_autoend() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTInstantConferenceInfo::clear_has_autoend() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTInstantConferenceInfo::clear_autoend() {
  autoend_ = false;
  clear_has_autoend();
}
inline bool TMTInstantConferenceInfo::autoend() const {
  return autoend_;
}
inline void TMTInstantConferenceInfo::set_autoend(bool value) {
  set_has_autoend();
  autoend_ = value;
}

// optional bool preoccpuyResouce = 21;
inline bool TMTInstantConferenceInfo::has_preoccpuyresouce() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_preoccpuyresouce() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTInstantConferenceInfo::clear_has_preoccpuyresouce() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTInstantConferenceInfo::clear_preoccpuyresouce() {
  preoccpuyresouce_ = false;
  clear_has_preoccpuyresouce();
}
inline bool TMTInstantConferenceInfo::preoccpuyresouce() const {
  return preoccpuyresouce_;
}
inline void TMTInstantConferenceInfo::set_preoccpuyresouce(bool value) {
  set_has_preoccpuyresouce();
  preoccpuyresouce_ = value;
}

// optional uint32 maxJoinMt = 22;
inline bool TMTInstantConferenceInfo::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTInstantConferenceInfo::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTInstantConferenceInfo::clear_maxjoinmt() {
  maxjoinmt_ = 0u;
  clear_has_maxjoinmt();
}
inline ::google::protobuf::uint32 TMTInstantConferenceInfo::maxjoinmt() const {
  return maxjoinmt_;
}
inline void TMTInstantConferenceInfo::set_maxjoinmt(::google::protobuf::uint32 value) {
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional bool voiceInspireEnable = 23;
inline bool TMTInstantConferenceInfo::has_voiceinspireenable() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_voiceinspireenable() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTInstantConferenceInfo::clear_has_voiceinspireenable() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTInstantConferenceInfo::clear_voiceinspireenable() {
  voiceinspireenable_ = false;
  clear_has_voiceinspireenable();
}
inline bool TMTInstantConferenceInfo::voiceinspireenable() const {
  return voiceinspireenable_;
}
inline void TMTInstantConferenceInfo::set_voiceinspireenable(bool value) {
  set_has_voiceinspireenable();
  voiceinspireenable_ = value;
}

// optional .mt.TMTConfInitiator confInitiator = 24;
inline bool TMTInstantConferenceInfo::has_confinitiator() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_confinitiator() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTInstantConferenceInfo::clear_has_confinitiator() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTInstantConferenceInfo::clear_confinitiator() {
  if (confinitiator_ != NULL) confinitiator_->::mt::TMTConfInitiator::Clear();
  clear_has_confinitiator();
}
inline const ::mt::TMTConfInitiator& TMTInstantConferenceInfo::confinitiator() const {
  return confinitiator_ != NULL ? *confinitiator_ : *default_instance_->confinitiator_;
}
inline ::mt::TMTConfInitiator* TMTInstantConferenceInfo::mutable_confinitiator() {
  set_has_confinitiator();
  if (confinitiator_ == NULL) confinitiator_ = new ::mt::TMTConfInitiator;
  return confinitiator_;
}
inline ::mt::TMTConfInitiator* TMTInstantConferenceInfo::release_confinitiator() {
  clear_has_confinitiator();
  ::mt::TMTConfInitiator* temp = confinitiator_;
  confinitiator_ = NULL;
  return temp;
}
inline void TMTInstantConferenceInfo::set_allocated_confinitiator(::mt::TMTConfInitiator* confinitiator) {
  delete confinitiator_;
  confinitiator_ = confinitiator;
  if (confinitiator) {
    set_has_confinitiator();
  } else {
    clear_has_confinitiator();
  }
}

// repeated .mt.TMTVideoFormatList videoFormatList = 25;
inline int TMTInstantConferenceInfo::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTInstantConferenceInfo::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTInstantConferenceInfo::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTInstantConferenceInfo::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTInstantConferenceInfo::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTInstantConferenceInfo::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTInstantConferenceInfo::mutable_videoformatlist() {
  return &videoformatlist_;
}

// optional bool vmpEnable = 26;
inline bool TMTInstantConferenceInfo::has_vmpenable() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_vmpenable() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMTInstantConferenceInfo::clear_has_vmpenable() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMTInstantConferenceInfo::clear_vmpenable() {
  vmpenable_ = false;
  clear_has_vmpenable();
}
inline bool TMTInstantConferenceInfo::vmpenable() const {
  return vmpenable_;
}
inline void TMTInstantConferenceInfo::set_vmpenable(bool value) {
  set_has_vmpenable();
  vmpenable_ = value;
}

// optional bool mixEnable = 27;
inline bool TMTInstantConferenceInfo::has_mixenable() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_mixenable() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMTInstantConferenceInfo::clear_has_mixenable() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMTInstantConferenceInfo::clear_mixenable() {
  mixenable_ = false;
  clear_has_mixenable();
}
inline bool TMTInstantConferenceInfo::mixenable() const {
  return mixenable_;
}
inline void TMTInstantConferenceInfo::set_mixenable(bool value) {
  set_has_mixenable();
  mixenable_ = value;
}

// optional bool pollEnable = 28;
inline bool TMTInstantConferenceInfo::has_pollenable() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_pollenable() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTInstantConferenceInfo::clear_has_pollenable() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTInstantConferenceInfo::clear_pollenable() {
  pollenable_ = false;
  clear_has_pollenable();
}
inline bool TMTInstantConferenceInfo::pollenable() const {
  return pollenable_;
}
inline void TMTInstantConferenceInfo::set_pollenable(bool value) {
  set_has_pollenable();
  pollenable_ = value;
}

// optional bool needPassword = 29;
inline bool TMTInstantConferenceInfo::has_needpassword() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_needpassword() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMTInstantConferenceInfo::clear_has_needpassword() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMTInstantConferenceInfo::clear_needpassword() {
  needpassword_ = false;
  clear_has_needpassword();
}
inline bool TMTInstantConferenceInfo::needpassword() const {
  return needpassword_;
}
inline void TMTInstantConferenceInfo::set_needpassword(bool value) {
  set_has_needpassword();
  needpassword_ = value;
}

// optional .mt.EmRestCascadeMode emCascadeMode = 30;
inline bool TMTInstantConferenceInfo::has_emcascademode() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_emcascademode() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMTInstantConferenceInfo::clear_has_emcascademode() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMTInstantConferenceInfo::clear_emcascademode() {
  emcascademode_ = 0;
  clear_has_emcascademode();
}
inline ::mt::EmRestCascadeMode TMTInstantConferenceInfo::emcascademode() const {
  return static_cast< ::mt::EmRestCascadeMode >(emcascademode_);
}
inline void TMTInstantConferenceInfo::set_emcascademode(::mt::EmRestCascadeMode value) {
  assert(::mt::EmRestCascadeMode_IsValid(value));
  set_has_emcascademode();
  emcascademode_ = value;
}

// optional bool cascadeUpload = 31;
inline bool TMTInstantConferenceInfo::has_cascadeupload() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_cascadeupload() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TMTInstantConferenceInfo::clear_has_cascadeupload() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TMTInstantConferenceInfo::clear_cascadeupload() {
  cascadeupload_ = false;
  clear_has_cascadeupload();
}
inline bool TMTInstantConferenceInfo::cascadeupload() const {
  return cascadeupload_;
}
inline void TMTInstantConferenceInfo::set_cascadeupload(bool value) {
  set_has_cascadeupload();
  cascadeupload_ = value;
}

// optional bool cascadeReturn = 32;
inline bool TMTInstantConferenceInfo::has_cascadereturn() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_cascadereturn() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TMTInstantConferenceInfo::clear_has_cascadereturn() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TMTInstantConferenceInfo::clear_cascadereturn() {
  cascadereturn_ = false;
  clear_has_cascadereturn();
}
inline bool TMTInstantConferenceInfo::cascadereturn() const {
  return cascadereturn_;
}
inline void TMTInstantConferenceInfo::set_cascadereturn(bool value) {
  set_has_cascadereturn();
  cascadereturn_ = value;
}

// optional uint32 cascadeReturnPara = 33;
inline bool TMTInstantConferenceInfo::has_cascadereturnpara() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_cascadereturnpara() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TMTInstantConferenceInfo::clear_has_cascadereturnpara() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TMTInstantConferenceInfo::clear_cascadereturnpara() {
  cascadereturnpara_ = 0u;
  clear_has_cascadereturnpara();
}
inline ::google::protobuf::uint32 TMTInstantConferenceInfo::cascadereturnpara() const {
  return cascadereturnpara_;
}
inline void TMTInstantConferenceInfo::set_cascadereturnpara(::google::protobuf::uint32 value) {
  set_has_cascadereturnpara();
  cascadereturnpara_ = value;
}

// optional uint32 vacinterval = 34;
inline bool TMTInstantConferenceInfo::has_vacinterval() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_vacinterval() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TMTInstantConferenceInfo::clear_has_vacinterval() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TMTInstantConferenceInfo::clear_vacinterval() {
  vacinterval_ = 0u;
  clear_has_vacinterval();
}
inline ::google::protobuf::uint32 TMTInstantConferenceInfo::vacinterval() const {
  return vacinterval_;
}
inline void TMTInstantConferenceInfo::set_vacinterval(::google::protobuf::uint32 value) {
  set_has_vacinterval();
  vacinterval_ = value;
}

// optional uint32 conflevel = 35;
inline bool TMTInstantConferenceInfo::has_conflevel() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_conflevel() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TMTInstantConferenceInfo::clear_has_conflevel() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TMTInstantConferenceInfo::clear_conflevel() {
  conflevel_ = 0u;
  clear_has_conflevel();
}
inline ::google::protobuf::uint32 TMTInstantConferenceInfo::conflevel() const {
  return conflevel_;
}
inline void TMTInstantConferenceInfo::set_conflevel(::google::protobuf::uint32 value) {
  set_has_conflevel();
  conflevel_ = value;
}

// optional bool encrypted_auth = 36;
inline bool TMTInstantConferenceInfo::has_encrypted_auth() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_encrypted_auth() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TMTInstantConferenceInfo::clear_has_encrypted_auth() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TMTInstantConferenceInfo::clear_encrypted_auth() {
  encrypted_auth_ = false;
  clear_has_encrypted_auth();
}
inline bool TMTInstantConferenceInfo::encrypted_auth() const {
  return encrypted_auth_;
}
inline void TMTInstantConferenceInfo::set_encrypted_auth(bool value) {
  set_has_encrypted_auth();
  encrypted_auth_ = value;
}

// optional .mt.EmCallMode emCallMode = 37;
inline bool TMTInstantConferenceInfo::has_emcallmode() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_emcallmode() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TMTInstantConferenceInfo::clear_has_emcallmode() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TMTInstantConferenceInfo::clear_emcallmode() {
  emcallmode_ = 0;
  clear_has_emcallmode();
}
inline ::mt::EmCallMode TMTInstantConferenceInfo::emcallmode() const {
  return static_cast< ::mt::EmCallMode >(emcallmode_);
}
inline void TMTInstantConferenceInfo::set_emcallmode(::mt::EmCallMode value) {
  assert(::mt::EmCallMode_IsValid(value));
  set_has_emcallmode();
  emcallmode_ = value;
}

// optional .mt.EmMtFecMode fecmode = 38;
inline bool TMTInstantConferenceInfo::has_fecmode() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_fecmode() {
  _has_bits_[1] |= 0x00000020u;
}
inline void TMTInstantConferenceInfo::clear_has_fecmode() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void TMTInstantConferenceInfo::clear_fecmode() {
  fecmode_ = 0;
  clear_has_fecmode();
}
inline ::mt::EmMtFecMode TMTInstantConferenceInfo::fecmode() const {
  return static_cast< ::mt::EmMtFecMode >(fecmode_);
}
inline void TMTInstantConferenceInfo::set_fecmode(::mt::EmMtFecMode value) {
  assert(::mt::EmMtFecMode_IsValid(value));
  set_has_fecmode();
  fecmode_ = value;
}

// optional string MeetingRoomName = 39;
inline bool TMTInstantConferenceInfo::has_meetingroomname() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_meetingroomname() {
  _has_bits_[1] |= 0x00000040u;
}
inline void TMTInstantConferenceInfo::clear_has_meetingroomname() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void TMTInstantConferenceInfo::clear_meetingroomname() {
  if (meetingroomname_ != &::google::protobuf::internal::kEmptyString) {
    meetingroomname_->clear();
  }
  clear_has_meetingroomname();
}
inline const ::std::string& TMTInstantConferenceInfo::meetingroomname() const {
  return *meetingroomname_;
}
inline void TMTInstantConferenceInfo::set_meetingroomname(const ::std::string& value) {
  set_has_meetingroomname();
  if (meetingroomname_ == &::google::protobuf::internal::kEmptyString) {
    meetingroomname_ = new ::std::string;
  }
  meetingroomname_->assign(value);
}
inline void TMTInstantConferenceInfo::set_meetingroomname(const char* value) {
  set_has_meetingroomname();
  if (meetingroomname_ == &::google::protobuf::internal::kEmptyString) {
    meetingroomname_ = new ::std::string;
  }
  meetingroomname_->assign(value);
}
inline void TMTInstantConferenceInfo::set_meetingroomname(const char* value, size_t size) {
  set_has_meetingroomname();
  if (meetingroomname_ == &::google::protobuf::internal::kEmptyString) {
    meetingroomname_ = new ::std::string;
  }
  meetingroomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTInstantConferenceInfo::mutable_meetingroomname() {
  set_has_meetingroomname();
  if (meetingroomname_ == &::google::protobuf::internal::kEmptyString) {
    meetingroomname_ = new ::std::string;
  }
  return meetingroomname_;
}
inline ::std::string* TMTInstantConferenceInfo::release_meetingroomname() {
  clear_has_meetingroomname();
  if (meetingroomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetingroomname_;
    meetingroomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTInstantConferenceInfo::set_allocated_meetingroomname(::std::string* meetingroomname) {
  if (meetingroomname_ != &::google::protobuf::internal::kEmptyString) {
    delete meetingroomname_;
  }
  if (meetingroomname) {
    set_has_meetingroomname();
    meetingroomname_ = meetingroomname;
  } else {
    clear_has_meetingroomname();
    meetingroomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool doubleflow = 40;
inline bool TMTInstantConferenceInfo::has_doubleflow() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_doubleflow() {
  _has_bits_[1] |= 0x00000080u;
}
inline void TMTInstantConferenceInfo::clear_has_doubleflow() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void TMTInstantConferenceInfo::clear_doubleflow() {
  doubleflow_ = false;
  clear_has_doubleflow();
}
inline bool TMTInstantConferenceInfo::doubleflow() const {
  return doubleflow_;
}
inline void TMTInstantConferenceInfo::set_doubleflow(bool value) {
  set_has_doubleflow();
  doubleflow_ = value;
}

// optional bool mutefilter = 41;
inline bool TMTInstantConferenceInfo::has_mutefilter() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void TMTInstantConferenceInfo::set_has_mutefilter() {
  _has_bits_[1] |= 0x00000100u;
}
inline void TMTInstantConferenceInfo::clear_has_mutefilter() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void TMTInstantConferenceInfo::clear_mutefilter() {
  mutefilter_ = false;
  clear_has_mutefilter();
}
inline bool TMTInstantConferenceInfo::mutefilter() const {
  return mutefilter_;
}
inline void TMTInstantConferenceInfo::set_mutefilter(bool value) {
  set_has_mutefilter();
  mutefilter_ = value;
}

// -------------------------------------------------------------------

// TMTGetIntanceConfList

// optional uint32 start = 1;
inline bool TMTGetIntanceConfList::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTGetIntanceConfList::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTGetIntanceConfList::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTGetIntanceConfList::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTGetIntanceConfList::start() const {
  return start_;
}
inline void TMTGetIntanceConfList::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 count = 2;
inline bool TMTGetIntanceConfList::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTGetIntanceConfList::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTGetIntanceConfList::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTGetIntanceConfList::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTGetIntanceConfList::count() const {
  return count_;
}
inline void TMTGetIntanceConfList::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// TMTRecordMembers

// optional string mtID = 1;
inline bool TMTRecordMembers::has_mtid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRecordMembers::set_has_mtid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRecordMembers::clear_has_mtid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRecordMembers::clear_mtid() {
  if (mtid_ != &::google::protobuf::internal::kEmptyString) {
    mtid_->clear();
  }
  clear_has_mtid();
}
inline const ::std::string& TMTRecordMembers::mtid() const {
  return *mtid_;
}
inline void TMTRecordMembers::set_mtid(const ::std::string& value) {
  set_has_mtid();
  if (mtid_ == &::google::protobuf::internal::kEmptyString) {
    mtid_ = new ::std::string;
  }
  mtid_->assign(value);
}
inline void TMTRecordMembers::set_mtid(const char* value) {
  set_has_mtid();
  if (mtid_ == &::google::protobuf::internal::kEmptyString) {
    mtid_ = new ::std::string;
  }
  mtid_->assign(value);
}
inline void TMTRecordMembers::set_mtid(const char* value, size_t size) {
  set_has_mtid();
  if (mtid_ == &::google::protobuf::internal::kEmptyString) {
    mtid_ = new ::std::string;
  }
  mtid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRecordMembers::mutable_mtid() {
  set_has_mtid();
  if (mtid_ == &::google::protobuf::internal::kEmptyString) {
    mtid_ = new ::std::string;
  }
  return mtid_;
}
inline ::std::string* TMTRecordMembers::release_mtid() {
  clear_has_mtid();
  if (mtid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mtid_;
    mtid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRecordMembers::set_allocated_mtid(::std::string* mtid) {
  if (mtid_ != &::google::protobuf::internal::kEmptyString) {
    delete mtid_;
  }
  if (mtid) {
    set_has_mtid();
    mtid_ = mtid;
  } else {
    clear_has_mtid();
    mtid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTStartRecord

// optional string confID = 1;
inline bool TMTStartRecord::has_confid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTStartRecord::set_has_confid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTStartRecord::clear_has_confid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTStartRecord::clear_confid() {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    confid_->clear();
  }
  clear_has_confid();
}
inline const ::std::string& TMTStartRecord::confid() const {
  return *confid_;
}
inline void TMTStartRecord::set_confid(const ::std::string& value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTStartRecord::set_confid(const char* value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTStartRecord::set_confid(const char* value, size_t size) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTStartRecord::mutable_confid() {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  return confid_;
}
inline ::std::string* TMTStartRecord::release_confid() {
  clear_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confid_;
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTStartRecord::set_allocated_confid(::std::string* confid) {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    delete confid_;
  }
  if (confid) {
    set_has_confid();
    confid_ = confid;
  } else {
    clear_has_confid();
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string videoName = 2;
inline bool TMTStartRecord::has_videoname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTStartRecord::set_has_videoname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTStartRecord::clear_has_videoname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTStartRecord::clear_videoname() {
  if (videoname_ != &::google::protobuf::internal::kEmptyString) {
    videoname_->clear();
  }
  clear_has_videoname();
}
inline const ::std::string& TMTStartRecord::videoname() const {
  return *videoname_;
}
inline void TMTStartRecord::set_videoname(const ::std::string& value) {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  videoname_->assign(value);
}
inline void TMTStartRecord::set_videoname(const char* value) {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  videoname_->assign(value);
}
inline void TMTStartRecord::set_videoname(const char* value, size_t size) {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  videoname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTStartRecord::mutable_videoname() {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  return videoname_;
}
inline ::std::string* TMTStartRecord::release_videoname() {
  clear_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = videoname_;
    videoname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTStartRecord::set_allocated_videoname(::std::string* videoname) {
  if (videoname_ != &::google::protobuf::internal::kEmptyString) {
    delete videoname_;
  }
  if (videoname) {
    set_has_videoname();
    videoname_ = videoname;
  } else {
    clear_has_videoname();
    videoname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRecordType emRecordType = 3;
inline bool TMTStartRecord::has_emrecordtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTStartRecord::set_has_emrecordtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTStartRecord::clear_has_emrecordtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTStartRecord::clear_emrecordtype() {
  emrecordtype_ = 0;
  clear_has_emrecordtype();
}
inline ::mt::EmRecordType TMTStartRecord::emrecordtype() const {
  return static_cast< ::mt::EmRecordType >(emrecordtype_);
}
inline void TMTStartRecord::set_emrecordtype(::mt::EmRecordType value) {
  assert(::mt::EmRecordType_IsValid(value));
  set_has_emrecordtype();
  emrecordtype_ = value;
}

// optional .mt.EmPublishMode emPublishMode = 4;
inline bool TMTStartRecord::has_empublishmode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTStartRecord::set_has_empublishmode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTStartRecord::clear_has_empublishmode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTStartRecord::clear_empublishmode() {
  empublishmode_ = 0;
  clear_has_empublishmode();
}
inline ::mt::EmPublishMode TMTStartRecord::empublishmode() const {
  return static_cast< ::mt::EmPublishMode >(empublishmode_);
}
inline void TMTStartRecord::set_empublishmode(::mt::EmPublishMode value) {
  assert(::mt::EmPublishMode_IsValid(value));
  set_has_empublishmode();
  empublishmode_ = value;
}

// optional .mt.EmRecordMode emRecordMode = 5;
inline bool TMTStartRecord::has_emrecordmode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTStartRecord::set_has_emrecordmode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTStartRecord::clear_has_emrecordmode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTStartRecord::clear_emrecordmode() {
  emrecordmode_ = 0;
  clear_has_emrecordmode();
}
inline ::mt::EmRecordMode TMTStartRecord::emrecordmode() const {
  return static_cast< ::mt::EmRecordMode >(emrecordmode_);
}
inline void TMTStartRecord::set_emrecordmode(::mt::EmRecordMode value) {
  assert(::mt::EmRecordMode_IsValid(value));
  set_has_emrecordmode();
  emrecordmode_ = value;
}

// optional bool bAnonymous = 6;
inline bool TMTStartRecord::has_banonymous() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTStartRecord::set_has_banonymous() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTStartRecord::clear_has_banonymous() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTStartRecord::clear_banonymous() {
  banonymous_ = false;
  clear_has_banonymous();
}
inline bool TMTStartRecord::banonymous() const {
  return banonymous_;
}
inline void TMTStartRecord::set_banonymous(bool value) {
  set_has_banonymous();
  banonymous_ = value;
}

// optional bool bMainStream = 7;
inline bool TMTStartRecord::has_bmainstream() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTStartRecord::set_has_bmainstream() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTStartRecord::clear_has_bmainstream() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTStartRecord::clear_bmainstream() {
  bmainstream_ = false;
  clear_has_bmainstream();
}
inline bool TMTStartRecord::bmainstream() const {
  return bmainstream_;
}
inline void TMTStartRecord::set_bmainstream(bool value) {
  set_has_bmainstream();
  bmainstream_ = value;
}

// optional bool bDualStream = 8;
inline bool TMTStartRecord::has_bdualstream() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTStartRecord::set_has_bdualstream() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTStartRecord::clear_has_bdualstream() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTStartRecord::clear_bdualstream() {
  bdualstream_ = false;
  clear_has_bdualstream();
}
inline bool TMTStartRecord::bdualstream() const {
  return bdualstream_;
}
inline void TMTStartRecord::set_bdualstream(bool value) {
  set_has_bdualstream();
  bdualstream_ = value;
}

// repeated .mt.TMTRecordMembers recordMembers = 9;
inline int TMTStartRecord::recordmembers_size() const {
  return recordmembers_.size();
}
inline void TMTStartRecord::clear_recordmembers() {
  recordmembers_.Clear();
}
inline const ::mt::TMTRecordMembers& TMTStartRecord::recordmembers(int index) const {
  return recordmembers_.Get(index);
}
inline ::mt::TMTRecordMembers* TMTStartRecord::mutable_recordmembers(int index) {
  return recordmembers_.Mutable(index);
}
inline ::mt::TMTRecordMembers* TMTStartRecord::add_recordmembers() {
  return recordmembers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >&
TMTStartRecord::recordmembers() const {
  return recordmembers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >*
TMTStartRecord::mutable_recordmembers() {
  return &recordmembers_;
}

// optional string vrsId = 10;
inline bool TMTStartRecord::has_vrsid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTStartRecord::set_has_vrsid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTStartRecord::clear_has_vrsid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTStartRecord::clear_vrsid() {
  if (vrsid_ != &::google::protobuf::internal::kEmptyString) {
    vrsid_->clear();
  }
  clear_has_vrsid();
}
inline const ::std::string& TMTStartRecord::vrsid() const {
  return *vrsid_;
}
inline void TMTStartRecord::set_vrsid(const ::std::string& value) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(value);
}
inline void TMTStartRecord::set_vrsid(const char* value) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(value);
}
inline void TMTStartRecord::set_vrsid(const char* value, size_t size) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTStartRecord::mutable_vrsid() {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  return vrsid_;
}
inline ::std::string* TMTStartRecord::release_vrsid() {
  clear_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vrsid_;
    vrsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTStartRecord::set_allocated_vrsid(::std::string* vrsid) {
  if (vrsid_ != &::google::protobuf::internal::kEmptyString) {
    delete vrsid_;
  }
  if (vrsid) {
    set_has_vrsid();
    vrsid_ = vrsid;
  } else {
    clear_has_vrsid();
    vrsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTStopRecord

// optional string confID = 1;
inline bool TMTStopRecord::has_confid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTStopRecord::set_has_confid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTStopRecord::clear_has_confid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTStopRecord::clear_confid() {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    confid_->clear();
  }
  clear_has_confid();
}
inline const ::std::string& TMTStopRecord::confid() const {
  return *confid_;
}
inline void TMTStopRecord::set_confid(const ::std::string& value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTStopRecord::set_confid(const char* value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTStopRecord::set_confid(const char* value, size_t size) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTStopRecord::mutable_confid() {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  return confid_;
}
inline ::std::string* TMTStopRecord::release_confid() {
  clear_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confid_;
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTStopRecord::set_allocated_confid(::std::string* confid) {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    delete confid_;
  }
  if (confid) {
    set_has_confid();
    confid_ = confid;
  } else {
    clear_has_confid();
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string recordID = 2;
inline bool TMTStopRecord::has_recordid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTStopRecord::set_has_recordid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTStopRecord::clear_has_recordid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTStopRecord::clear_recordid() {
  if (recordid_ != &::google::protobuf::internal::kEmptyString) {
    recordid_->clear();
  }
  clear_has_recordid();
}
inline const ::std::string& TMTStopRecord::recordid() const {
  return *recordid_;
}
inline void TMTStopRecord::set_recordid(const ::std::string& value) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(value);
}
inline void TMTStopRecord::set_recordid(const char* value) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(value);
}
inline void TMTStopRecord::set_recordid(const char* value, size_t size) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTStopRecord::mutable_recordid() {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  return recordid_;
}
inline ::std::string* TMTStopRecord::release_recordid() {
  clear_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recordid_;
    recordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTStopRecord::set_allocated_recordid(::std::string* recordid) {
  if (recordid_ != &::google::protobuf::internal::kEmptyString) {
    delete recordid_;
  }
  if (recordid) {
    set_has_recordid();
    recordid_ = recordid;
  } else {
    clear_has_recordid();
    recordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRecordMode emRecordMode = 3;
inline bool TMTStopRecord::has_emrecordmode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTStopRecord::set_has_emrecordmode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTStopRecord::clear_has_emrecordmode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTStopRecord::clear_emrecordmode() {
  emrecordmode_ = 0;
  clear_has_emrecordmode();
}
inline ::mt::EmRecordMode TMTStopRecord::emrecordmode() const {
  return static_cast< ::mt::EmRecordMode >(emrecordmode_);
}
inline void TMTStopRecord::set_emrecordmode(::mt::EmRecordMode value) {
  assert(::mt::EmRecordMode_IsValid(value));
  set_has_emrecordmode();
  emrecordmode_ = value;
}

// -------------------------------------------------------------------

// TMTRecordStateInfo

// optional string videoName = 1;
inline bool TMTRecordStateInfo::has_videoname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRecordStateInfo::set_has_videoname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRecordStateInfo::clear_has_videoname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRecordStateInfo::clear_videoname() {
  if (videoname_ != &::google::protobuf::internal::kEmptyString) {
    videoname_->clear();
  }
  clear_has_videoname();
}
inline const ::std::string& TMTRecordStateInfo::videoname() const {
  return *videoname_;
}
inline void TMTRecordStateInfo::set_videoname(const ::std::string& value) {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  videoname_->assign(value);
}
inline void TMTRecordStateInfo::set_videoname(const char* value) {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  videoname_->assign(value);
}
inline void TMTRecordStateInfo::set_videoname(const char* value, size_t size) {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  videoname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRecordStateInfo::mutable_videoname() {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  return videoname_;
}
inline ::std::string* TMTRecordStateInfo::release_videoname() {
  clear_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = videoname_;
    videoname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRecordStateInfo::set_allocated_videoname(::std::string* videoname) {
  if (videoname_ != &::google::protobuf::internal::kEmptyString) {
    delete videoname_;
  }
  if (videoname) {
    set_has_videoname();
    videoname_ = videoname;
  } else {
    clear_has_videoname();
    videoname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRecordType emRecordType = 2;
inline bool TMTRecordStateInfo::has_emrecordtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRecordStateInfo::set_has_emrecordtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRecordStateInfo::clear_has_emrecordtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRecordStateInfo::clear_emrecordtype() {
  emrecordtype_ = 0;
  clear_has_emrecordtype();
}
inline ::mt::EmRecordType TMTRecordStateInfo::emrecordtype() const {
  return static_cast< ::mt::EmRecordType >(emrecordtype_);
}
inline void TMTRecordStateInfo::set_emrecordtype(::mt::EmRecordType value) {
  assert(::mt::EmRecordType_IsValid(value));
  set_has_emrecordtype();
  emrecordtype_ = value;
}

// optional .mt.EmRecordState emRecordState = 3;
inline bool TMTRecordStateInfo::has_emrecordstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRecordStateInfo::set_has_emrecordstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRecordStateInfo::clear_has_emrecordstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRecordStateInfo::clear_emrecordstate() {
  emrecordstate_ = 0;
  clear_has_emrecordstate();
}
inline ::mt::EmRecordState TMTRecordStateInfo::emrecordstate() const {
  return static_cast< ::mt::EmRecordState >(emrecordstate_);
}
inline void TMTRecordStateInfo::set_emrecordstate(::mt::EmRecordState value) {
  assert(::mt::EmRecordState_IsValid(value));
  set_has_emrecordstate();
  emrecordstate_ = value;
}

// optional .mt.EmPublishMode emPublishMode = 4;
inline bool TMTRecordStateInfo::has_empublishmode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTRecordStateInfo::set_has_empublishmode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTRecordStateInfo::clear_has_empublishmode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTRecordStateInfo::clear_empublishmode() {
  empublishmode_ = 0;
  clear_has_empublishmode();
}
inline ::mt::EmPublishMode TMTRecordStateInfo::empublishmode() const {
  return static_cast< ::mt::EmPublishMode >(empublishmode_);
}
inline void TMTRecordStateInfo::set_empublishmode(::mt::EmPublishMode value) {
  assert(::mt::EmPublishMode_IsValid(value));
  set_has_empublishmode();
  empublishmode_ = value;
}

// optional .mt.EmRecordMode emRecordMode = 5;
inline bool TMTRecordStateInfo::has_emrecordmode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTRecordStateInfo::set_has_emrecordmode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTRecordStateInfo::clear_has_emrecordmode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTRecordStateInfo::clear_emrecordmode() {
  emrecordmode_ = 0;
  clear_has_emrecordmode();
}
inline ::mt::EmRecordMode TMTRecordStateInfo::emrecordmode() const {
  return static_cast< ::mt::EmRecordMode >(emrecordmode_);
}
inline void TMTRecordStateInfo::set_emrecordmode(::mt::EmRecordMode value) {
  assert(::mt::EmRecordMode_IsValid(value));
  set_has_emrecordmode();
  emrecordmode_ = value;
}

// optional bool bAnonymous = 6;
inline bool TMTRecordStateInfo::has_banonymous() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTRecordStateInfo::set_has_banonymous() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTRecordStateInfo::clear_has_banonymous() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTRecordStateInfo::clear_banonymous() {
  banonymous_ = false;
  clear_has_banonymous();
}
inline bool TMTRecordStateInfo::banonymous() const {
  return banonymous_;
}
inline void TMTRecordStateInfo::set_banonymous(bool value) {
  set_has_banonymous();
  banonymous_ = value;
}

// optional bool bMainStream = 7;
inline bool TMTRecordStateInfo::has_bmainstream() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTRecordStateInfo::set_has_bmainstream() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTRecordStateInfo::clear_has_bmainstream() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTRecordStateInfo::clear_bmainstream() {
  bmainstream_ = false;
  clear_has_bmainstream();
}
inline bool TMTRecordStateInfo::bmainstream() const {
  return bmainstream_;
}
inline void TMTRecordStateInfo::set_bmainstream(bool value) {
  set_has_bmainstream();
  bmainstream_ = value;
}

// optional bool bDualStream = 8;
inline bool TMTRecordStateInfo::has_bdualstream() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTRecordStateInfo::set_has_bdualstream() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTRecordStateInfo::clear_has_bdualstream() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTRecordStateInfo::clear_bdualstream() {
  bdualstream_ = false;
  clear_has_bdualstream();
}
inline bool TMTRecordStateInfo::bdualstream() const {
  return bdualstream_;
}
inline void TMTRecordStateInfo::set_bdualstream(bool value) {
  set_has_bdualstream();
  bdualstream_ = value;
}

// optional uint32 CurrentProgress = 9;
inline bool TMTRecordStateInfo::has_currentprogress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTRecordStateInfo::set_has_currentprogress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTRecordStateInfo::clear_has_currentprogress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTRecordStateInfo::clear_currentprogress() {
  currentprogress_ = 0u;
  clear_has_currentprogress();
}
inline ::google::protobuf::uint32 TMTRecordStateInfo::currentprogress() const {
  return currentprogress_;
}
inline void TMTRecordStateInfo::set_currentprogress(::google::protobuf::uint32 value) {
  set_has_currentprogress();
  currentprogress_ = value;
}

// repeated .mt.TMTRecordMembers recordMembers = 10;
inline int TMTRecordStateInfo::recordmembers_size() const {
  return recordmembers_.size();
}
inline void TMTRecordStateInfo::clear_recordmembers() {
  recordmembers_.Clear();
}
inline const ::mt::TMTRecordMembers& TMTRecordStateInfo::recordmembers(int index) const {
  return recordmembers_.Get(index);
}
inline ::mt::TMTRecordMembers* TMTRecordStateInfo::mutable_recordmembers(int index) {
  return recordmembers_.Mutable(index);
}
inline ::mt::TMTRecordMembers* TMTRecordStateInfo::add_recordmembers() {
  return recordmembers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >&
TMTRecordStateInfo::recordmembers() const {
  return recordmembers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >*
TMTRecordStateInfo::mutable_recordmembers() {
  return &recordmembers_;
}

// -------------------------------------------------------------------

// TMTModifyRecordState

// optional string confID = 1;
inline bool TMTModifyRecordState::has_confid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTModifyRecordState::set_has_confid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTModifyRecordState::clear_has_confid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTModifyRecordState::clear_confid() {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    confid_->clear();
  }
  clear_has_confid();
}
inline const ::std::string& TMTModifyRecordState::confid() const {
  return *confid_;
}
inline void TMTModifyRecordState::set_confid(const ::std::string& value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTModifyRecordState::set_confid(const char* value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTModifyRecordState::set_confid(const char* value, size_t size) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyRecordState::mutable_confid() {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  return confid_;
}
inline ::std::string* TMTModifyRecordState::release_confid() {
  clear_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confid_;
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyRecordState::set_allocated_confid(::std::string* confid) {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    delete confid_;
  }
  if (confid) {
    set_has_confid();
    confid_ = confid;
  } else {
    clear_has_confid();
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string recordID = 2;
inline bool TMTModifyRecordState::has_recordid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTModifyRecordState::set_has_recordid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTModifyRecordState::clear_has_recordid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTModifyRecordState::clear_recordid() {
  if (recordid_ != &::google::protobuf::internal::kEmptyString) {
    recordid_->clear();
  }
  clear_has_recordid();
}
inline const ::std::string& TMTModifyRecordState::recordid() const {
  return *recordid_;
}
inline void TMTModifyRecordState::set_recordid(const ::std::string& value) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(value);
}
inline void TMTModifyRecordState::set_recordid(const char* value) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(value);
}
inline void TMTModifyRecordState::set_recordid(const char* value, size_t size) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTModifyRecordState::mutable_recordid() {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  return recordid_;
}
inline ::std::string* TMTModifyRecordState::release_recordid() {
  clear_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recordid_;
    recordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTModifyRecordState::set_allocated_recordid(::std::string* recordid) {
  if (recordid_ != &::google::protobuf::internal::kEmptyString) {
    delete recordid_;
  }
  if (recordid) {
    set_has_recordid();
    recordid_ = recordid;
  } else {
    clear_has_recordid();
    recordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRecordMode emRecordMode = 3;
inline bool TMTModifyRecordState::has_emrecordmode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTModifyRecordState::set_has_emrecordmode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTModifyRecordState::clear_has_emrecordmode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTModifyRecordState::clear_emrecordmode() {
  emrecordmode_ = 0;
  clear_has_emrecordmode();
}
inline ::mt::EmRecordMode TMTModifyRecordState::emrecordmode() const {
  return static_cast< ::mt::EmRecordMode >(emrecordmode_);
}
inline void TMTModifyRecordState::set_emrecordmode(::mt::EmRecordMode value) {
  assert(::mt::EmRecordMode_IsValid(value));
  set_has_emrecordmode();
  emrecordmode_ = value;
}

// optional .mt.EmRecordCmd emRecordCmd = 4;
inline bool TMTModifyRecordState::has_emrecordcmd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTModifyRecordState::set_has_emrecordcmd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTModifyRecordState::clear_has_emrecordcmd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTModifyRecordState::clear_emrecordcmd() {
  emrecordcmd_ = 0;
  clear_has_emrecordcmd();
}
inline ::mt::EmRecordCmd TMTModifyRecordState::emrecordcmd() const {
  return static_cast< ::mt::EmRecordCmd >(emrecordcmd_);
}
inline void TMTModifyRecordState::set_emrecordcmd(::mt::EmRecordCmd value) {
  assert(::mt::EmRecordCmd_IsValid(value));
  set_has_emrecordcmd();
  emrecordcmd_ = value;
}

// -------------------------------------------------------------------

// TMTRecordListMember

// optional string videoName = 1;
inline bool TMTRecordListMember::has_videoname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRecordListMember::set_has_videoname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRecordListMember::clear_has_videoname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRecordListMember::clear_videoname() {
  if (videoname_ != &::google::protobuf::internal::kEmptyString) {
    videoname_->clear();
  }
  clear_has_videoname();
}
inline const ::std::string& TMTRecordListMember::videoname() const {
  return *videoname_;
}
inline void TMTRecordListMember::set_videoname(const ::std::string& value) {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  videoname_->assign(value);
}
inline void TMTRecordListMember::set_videoname(const char* value) {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  videoname_->assign(value);
}
inline void TMTRecordListMember::set_videoname(const char* value, size_t size) {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  videoname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRecordListMember::mutable_videoname() {
  set_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    videoname_ = new ::std::string;
  }
  return videoname_;
}
inline ::std::string* TMTRecordListMember::release_videoname() {
  clear_has_videoname();
  if (videoname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = videoname_;
    videoname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRecordListMember::set_allocated_videoname(::std::string* videoname) {
  if (videoname_ != &::google::protobuf::internal::kEmptyString) {
    delete videoname_;
  }
  if (videoname) {
    set_has_videoname();
    videoname_ = videoname;
  } else {
    clear_has_videoname();
    videoname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRecordType emRecordType = 2;
inline bool TMTRecordListMember::has_emrecordtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRecordListMember::set_has_emrecordtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRecordListMember::clear_has_emrecordtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRecordListMember::clear_emrecordtype() {
  emrecordtype_ = 0;
  clear_has_emrecordtype();
}
inline ::mt::EmRecordType TMTRecordListMember::emrecordtype() const {
  return static_cast< ::mt::EmRecordType >(emrecordtype_);
}
inline void TMTRecordListMember::set_emrecordtype(::mt::EmRecordType value) {
  assert(::mt::EmRecordType_IsValid(value));
  set_has_emrecordtype();
  emrecordtype_ = value;
}

// optional .mt.EmRecordState emRecordState = 3;
inline bool TMTRecordListMember::has_emrecordstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRecordListMember::set_has_emrecordstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRecordListMember::clear_has_emrecordstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRecordListMember::clear_emrecordstate() {
  emrecordstate_ = 0;
  clear_has_emrecordstate();
}
inline ::mt::EmRecordState TMTRecordListMember::emrecordstate() const {
  return static_cast< ::mt::EmRecordState >(emrecordstate_);
}
inline void TMTRecordListMember::set_emrecordstate(::mt::EmRecordState value) {
  assert(::mt::EmRecordState_IsValid(value));
  set_has_emrecordstate();
  emrecordstate_ = value;
}

// optional .mt.EmPublishMode emPublishMode = 4;
inline bool TMTRecordListMember::has_empublishmode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTRecordListMember::set_has_empublishmode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTRecordListMember::clear_has_empublishmode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTRecordListMember::clear_empublishmode() {
  empublishmode_ = 0;
  clear_has_empublishmode();
}
inline ::mt::EmPublishMode TMTRecordListMember::empublishmode() const {
  return static_cast< ::mt::EmPublishMode >(empublishmode_);
}
inline void TMTRecordListMember::set_empublishmode(::mt::EmPublishMode value) {
  assert(::mt::EmPublishMode_IsValid(value));
  set_has_empublishmode();
  empublishmode_ = value;
}

// optional .mt.EmRecordMode emRecordMode = 5;
inline bool TMTRecordListMember::has_emrecordmode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTRecordListMember::set_has_emrecordmode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTRecordListMember::clear_has_emrecordmode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTRecordListMember::clear_emrecordmode() {
  emrecordmode_ = 0;
  clear_has_emrecordmode();
}
inline ::mt::EmRecordMode TMTRecordListMember::emrecordmode() const {
  return static_cast< ::mt::EmRecordMode >(emrecordmode_);
}
inline void TMTRecordListMember::set_emrecordmode(::mt::EmRecordMode value) {
  assert(::mt::EmRecordMode_IsValid(value));
  set_has_emrecordmode();
  emrecordmode_ = value;
}

// optional bool bAnonymous = 6;
inline bool TMTRecordListMember::has_banonymous() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTRecordListMember::set_has_banonymous() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTRecordListMember::clear_has_banonymous() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTRecordListMember::clear_banonymous() {
  banonymous_ = false;
  clear_has_banonymous();
}
inline bool TMTRecordListMember::banonymous() const {
  return banonymous_;
}
inline void TMTRecordListMember::set_banonymous(bool value) {
  set_has_banonymous();
  banonymous_ = value;
}

// optional bool bMainStream = 7;
inline bool TMTRecordListMember::has_bmainstream() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTRecordListMember::set_has_bmainstream() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTRecordListMember::clear_has_bmainstream() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTRecordListMember::clear_bmainstream() {
  bmainstream_ = false;
  clear_has_bmainstream();
}
inline bool TMTRecordListMember::bmainstream() const {
  return bmainstream_;
}
inline void TMTRecordListMember::set_bmainstream(bool value) {
  set_has_bmainstream();
  bmainstream_ = value;
}

// optional bool bDualStream = 8;
inline bool TMTRecordListMember::has_bdualstream() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTRecordListMember::set_has_bdualstream() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTRecordListMember::clear_has_bdualstream() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTRecordListMember::clear_bdualstream() {
  bdualstream_ = false;
  clear_has_bdualstream();
}
inline bool TMTRecordListMember::bdualstream() const {
  return bdualstream_;
}
inline void TMTRecordListMember::set_bdualstream(bool value) {
  set_has_bdualstream();
  bdualstream_ = value;
}

// optional uint32 CurrentProgress = 9;
inline bool TMTRecordListMember::has_currentprogress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTRecordListMember::set_has_currentprogress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTRecordListMember::clear_has_currentprogress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTRecordListMember::clear_currentprogress() {
  currentprogress_ = 0u;
  clear_has_currentprogress();
}
inline ::google::protobuf::uint32 TMTRecordListMember::currentprogress() const {
  return currentprogress_;
}
inline void TMTRecordListMember::set_currentprogress(::google::protobuf::uint32 value) {
  set_has_currentprogress();
  currentprogress_ = value;
}

// repeated .mt.TMTRecordMembers recordMembers = 10;
inline int TMTRecordListMember::recordmembers_size() const {
  return recordmembers_.size();
}
inline void TMTRecordListMember::clear_recordmembers() {
  recordmembers_.Clear();
}
inline const ::mt::TMTRecordMembers& TMTRecordListMember::recordmembers(int index) const {
  return recordmembers_.Get(index);
}
inline ::mt::TMTRecordMembers* TMTRecordListMember::mutable_recordmembers(int index) {
  return recordmembers_.Mutable(index);
}
inline ::mt::TMTRecordMembers* TMTRecordListMember::add_recordmembers() {
  return recordmembers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >&
TMTRecordListMember::recordmembers() const {
  return recordmembers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordMembers >*
TMTRecordListMember::mutable_recordmembers() {
  return &recordmembers_;
}

// optional string recordID = 11;
inline bool TMTRecordListMember::has_recordid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTRecordListMember::set_has_recordid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTRecordListMember::clear_has_recordid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTRecordListMember::clear_recordid() {
  if (recordid_ != &::google::protobuf::internal::kEmptyString) {
    recordid_->clear();
  }
  clear_has_recordid();
}
inline const ::std::string& TMTRecordListMember::recordid() const {
  return *recordid_;
}
inline void TMTRecordListMember::set_recordid(const ::std::string& value) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(value);
}
inline void TMTRecordListMember::set_recordid(const char* value) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(value);
}
inline void TMTRecordListMember::set_recordid(const char* value, size_t size) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRecordListMember::mutable_recordid() {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  return recordid_;
}
inline ::std::string* TMTRecordListMember::release_recordid() {
  clear_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recordid_;
    recordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRecordListMember::set_allocated_recordid(::std::string* recordid) {
  if (recordid_ != &::google::protobuf::internal::kEmptyString) {
    delete recordid_;
  }
  if (recordid) {
    set_has_recordid();
    recordid_ = recordid;
  } else {
    clear_has_recordid();
    recordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTRecordList

// repeated .mt.TMTRecordListMember recordlist = 1;
inline int TMTRecordList::recordlist_size() const {
  return recordlist_.size();
}
inline void TMTRecordList::clear_recordlist() {
  recordlist_.Clear();
}
inline const ::mt::TMTRecordListMember& TMTRecordList::recordlist(int index) const {
  return recordlist_.Get(index);
}
inline ::mt::TMTRecordListMember* TMTRecordList::mutable_recordlist(int index) {
  return recordlist_.Mutable(index);
}
inline ::mt::TMTRecordListMember* TMTRecordList::add_recordlist() {
  return recordlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordListMember >&
TMTRecordList::recordlist() const {
  return recordlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTRecordListMember >*
TMTRecordList::mutable_recordlist() {
  return &recordlist_;
}

// -------------------------------------------------------------------

// TMTConfTerminalInfo

// optional string alias = 1;
inline bool TMTConfTerminalInfo::has_alias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTConfTerminalInfo::set_has_alias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTConfTerminalInfo::clear_has_alias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTConfTerminalInfo::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& TMTConfTerminalInfo::alias() const {
  return *alias_;
}
inline void TMTConfTerminalInfo::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMTConfTerminalInfo::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMTConfTerminalInfo::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfTerminalInfo::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* TMTConfTerminalInfo::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfTerminalInfo::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mtid = 2;
inline bool TMTConfTerminalInfo::has_mtid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTConfTerminalInfo::set_has_mtid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTConfTerminalInfo::clear_has_mtid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTConfTerminalInfo::clear_mtid() {
  if (mtid_ != &::google::protobuf::internal::kEmptyString) {
    mtid_->clear();
  }
  clear_has_mtid();
}
inline const ::std::string& TMTConfTerminalInfo::mtid() const {
  return *mtid_;
}
inline void TMTConfTerminalInfo::set_mtid(const ::std::string& value) {
  set_has_mtid();
  if (mtid_ == &::google::protobuf::internal::kEmptyString) {
    mtid_ = new ::std::string;
  }
  mtid_->assign(value);
}
inline void TMTConfTerminalInfo::set_mtid(const char* value) {
  set_has_mtid();
  if (mtid_ == &::google::protobuf::internal::kEmptyString) {
    mtid_ = new ::std::string;
  }
  mtid_->assign(value);
}
inline void TMTConfTerminalInfo::set_mtid(const char* value, size_t size) {
  set_has_mtid();
  if (mtid_ == &::google::protobuf::internal::kEmptyString) {
    mtid_ = new ::std::string;
  }
  mtid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfTerminalInfo::mutable_mtid() {
  set_has_mtid();
  if (mtid_ == &::google::protobuf::internal::kEmptyString) {
    mtid_ = new ::std::string;
  }
  return mtid_;
}
inline ::std::string* TMTConfTerminalInfo::release_mtid() {
  clear_has_mtid();
  if (mtid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mtid_;
    mtid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfTerminalInfo::set_allocated_mtid(::std::string* mtid) {
  if (mtid_ != &::google::protobuf::internal::kEmptyString) {
    delete mtid_;
  }
  if (mtid) {
    set_has_mtid();
    mtid_ = mtid;
  } else {
    clear_has_mtid();
    mtid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 3;
inline bool TMTConfTerminalInfo::has_e164() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTConfTerminalInfo::set_has_e164() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTConfTerminalInfo::clear_has_e164() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTConfTerminalInfo::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTConfTerminalInfo::e164() const {
  return *e164_;
}
inline void TMTConfTerminalInfo::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTConfTerminalInfo::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTConfTerminalInfo::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfTerminalInfo::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTConfTerminalInfo::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfTerminalInfo::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 bitrate = 4;
inline bool TMTConfTerminalInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTConfTerminalInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTConfTerminalInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTConfTerminalInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTConfTerminalInfo::bitrate() const {
  return bitrate_;
}
inline void TMTConfTerminalInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional bool online = 5;
inline bool TMTConfTerminalInfo::has_online() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTConfTerminalInfo::set_has_online() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTConfTerminalInfo::clear_has_online() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTConfTerminalInfo::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool TMTConfTerminalInfo::online() const {
  return online_;
}
inline void TMTConfTerminalInfo::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// optional bool silence = 6;
inline bool TMTConfTerminalInfo::has_silence() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTConfTerminalInfo::set_has_silence() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTConfTerminalInfo::clear_has_silence() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTConfTerminalInfo::clear_silence() {
  silence_ = false;
  clear_has_silence();
}
inline bool TMTConfTerminalInfo::silence() const {
  return silence_;
}
inline void TMTConfTerminalInfo::set_silence(bool value) {
  set_has_silence();
  silence_ = value;
}

// optional bool mute = 7;
inline bool TMTConfTerminalInfo::has_mute() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTConfTerminalInfo::set_has_mute() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTConfTerminalInfo::clear_has_mute() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTConfTerminalInfo::clear_mute() {
  mute_ = false;
  clear_has_mute();
}
inline bool TMTConfTerminalInfo::mute() const {
  return mute_;
}
inline void TMTConfTerminalInfo::set_mute(bool value) {
  set_has_mute();
  mute_ = value;
}

// optional bool dual = 8;
inline bool TMTConfTerminalInfo::has_dual() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTConfTerminalInfo::set_has_dual() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTConfTerminalInfo::clear_has_dual() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTConfTerminalInfo::clear_dual() {
  dual_ = false;
  clear_has_dual();
}
inline bool TMTConfTerminalInfo::dual() const {
  return dual_;
}
inline void TMTConfTerminalInfo::set_dual(bool value) {
  set_has_dual();
  dual_ = value;
}

// optional bool mix = 9;
inline bool TMTConfTerminalInfo::has_mix() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTConfTerminalInfo::set_has_mix() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTConfTerminalInfo::clear_has_mix() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTConfTerminalInfo::clear_mix() {
  mix_ = false;
  clear_has_mix();
}
inline bool TMTConfTerminalInfo::mix() const {
  return mix_;
}
inline void TMTConfTerminalInfo::set_mix(bool value) {
  set_has_mix();
  mix_ = value;
}

// optional bool vmp = 10;
inline bool TMTConfTerminalInfo::has_vmp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTConfTerminalInfo::set_has_vmp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTConfTerminalInfo::clear_has_vmp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTConfTerminalInfo::clear_vmp() {
  vmp_ = false;
  clear_has_vmp();
}
inline bool TMTConfTerminalInfo::vmp() const {
  return vmp_;
}
inline void TMTConfTerminalInfo::set_vmp(bool value) {
  set_has_vmp();
  vmp_ = value;
}

// optional bool inspection = 11;
inline bool TMTConfTerminalInfo::has_inspection() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTConfTerminalInfo::set_has_inspection() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTConfTerminalInfo::clear_has_inspection() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTConfTerminalInfo::clear_inspection() {
  inspection_ = false;
  clear_has_inspection();
}
inline bool TMTConfTerminalInfo::inspection() const {
  return inspection_;
}
inline void TMTConfTerminalInfo::set_inspection(bool value) {
  set_has_inspection();
  inspection_ = value;
}

// optional bool record = 12;
inline bool TMTConfTerminalInfo::has_record() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTConfTerminalInfo::set_has_record() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTConfTerminalInfo::clear_has_record() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTConfTerminalInfo::clear_record() {
  record_ = false;
  clear_has_record();
}
inline bool TMTConfTerminalInfo::record() const {
  return record_;
}
inline void TMTConfTerminalInfo::set_record(bool value) {
  set_has_record();
  record_ = value;
}

// optional bool poll = 13;
inline bool TMTConfTerminalInfo::has_poll() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTConfTerminalInfo::set_has_poll() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTConfTerminalInfo::clear_has_poll() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTConfTerminalInfo::clear_poll() {
  poll_ = false;
  clear_has_poll();
}
inline bool TMTConfTerminalInfo::poll() const {
  return poll_;
}
inline void TMTConfTerminalInfo::set_poll(bool value) {
  set_has_poll();
  poll_ = value;
}

// optional bool upload = 14;
inline bool TMTConfTerminalInfo::has_upload() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTConfTerminalInfo::set_has_upload() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTConfTerminalInfo::clear_has_upload() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTConfTerminalInfo::clear_upload() {
  upload_ = false;
  clear_has_upload();
}
inline bool TMTConfTerminalInfo::upload() const {
  return upload_;
}
inline void TMTConfTerminalInfo::set_upload(bool value) {
  set_has_upload();
  upload_ = value;
}

// optional .mt.EmMtType emMtType = 15;
inline bool TMTConfTerminalInfo::has_emmttype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTConfTerminalInfo::set_has_emmttype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTConfTerminalInfo::clear_has_emmttype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTConfTerminalInfo::clear_emmttype() {
  emmttype_ = 0;
  clear_has_emmttype();
}
inline ::mt::EmMtType TMTConfTerminalInfo::emmttype() const {
  return static_cast< ::mt::EmMtType >(emmttype_);
}
inline void TMTConfTerminalInfo::set_emmttype(::mt::EmMtType value) {
  assert(::mt::EmMtType_IsValid(value));
  set_has_emmttype();
  emmttype_ = value;
}

// optional .mt.EmCallMode emCallMode = 16;
inline bool TMTConfTerminalInfo::has_emcallmode() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTConfTerminalInfo::set_has_emcallmode() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTConfTerminalInfo::clear_has_emcallmode() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTConfTerminalInfo::clear_emcallmode() {
  emcallmode_ = 0;
  clear_has_emcallmode();
}
inline ::mt::EmCallMode TMTConfTerminalInfo::emcallmode() const {
  return static_cast< ::mt::EmCallMode >(emcallmode_);
}
inline void TMTConfTerminalInfo::set_emcallmode(::mt::EmCallMode value) {
  assert(::mt::EmCallMode_IsValid(value));
  set_has_emcallmode();
  emcallmode_ = value;
}

// optional .mt.EmConfProtocol emProtocol = 17;
inline bool TMTConfTerminalInfo::has_emprotocol() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTConfTerminalInfo::set_has_emprotocol() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTConfTerminalInfo::clear_has_emprotocol() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTConfTerminalInfo::clear_emprotocol() {
  emprotocol_ = 0;
  clear_has_emprotocol();
}
inline ::mt::EmConfProtocol TMTConfTerminalInfo::emprotocol() const {
  return static_cast< ::mt::EmConfProtocol >(emprotocol_);
}
inline void TMTConfTerminalInfo::set_emprotocol(::mt::EmConfProtocol value) {
  assert(::mt::EmConfProtocol_IsValid(value));
  set_has_emprotocol();
  emprotocol_ = value;
}

// optional string ip = 18;
inline bool TMTConfTerminalInfo::has_ip() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTConfTerminalInfo::set_has_ip() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTConfTerminalInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTConfTerminalInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& TMTConfTerminalInfo::ip() const {
  return *ip_;
}
inline void TMTConfTerminalInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TMTConfTerminalInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TMTConfTerminalInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTConfTerminalInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* TMTConfTerminalInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTConfTerminalInfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTConfTerminalList

// repeated .mt.TMTConfTerminalInfo confTerminalList = 1;
inline int TMTConfTerminalList::confterminallist_size() const {
  return confterminallist_.size();
}
inline void TMTConfTerminalList::clear_confterminallist() {
  confterminallist_.Clear();
}
inline const ::mt::TMTConfTerminalInfo& TMTConfTerminalList::confterminallist(int index) const {
  return confterminallist_.Get(index);
}
inline ::mt::TMTConfTerminalInfo* TMTConfTerminalList::mutable_confterminallist(int index) {
  return confterminallist_.Mutable(index);
}
inline ::mt::TMTConfTerminalInfo* TMTConfTerminalList::add_confterminallist() {
  return confterminallist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTConfTerminalInfo >&
TMTConfTerminalList::confterminallist() const {
  return confterminallist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTConfTerminalInfo >*
TMTConfTerminalList::mutable_confterminallist() {
  return &confterminallist_;
}

// -------------------------------------------------------------------

// TMTUserDomainInfo

// optional string moid = 1;
inline bool TMTUserDomainInfo::has_moid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUserDomainInfo::set_has_moid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUserDomainInfo::clear_has_moid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUserDomainInfo::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTUserDomainInfo::moid() const {
  return *moid_;
}
inline void TMTUserDomainInfo::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTUserDomainInfo::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTUserDomainInfo::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserDomainInfo::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTUserDomainInfo::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserDomainInfo::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TMTUserDomainInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUserDomainInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUserDomainInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUserDomainInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTUserDomainInfo::name() const {
  return *name_;
}
inline void TMTUserDomainInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTUserDomainInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTUserDomainInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserDomainInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTUserDomainInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserDomainInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string group_name = 3;
inline bool TMTUserDomainInfo::has_group_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTUserDomainInfo::set_has_group_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTUserDomainInfo::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTUserDomainInfo::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& TMTUserDomainInfo::group_name() const {
  return *group_name_;
}
inline void TMTUserDomainInfo::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void TMTUserDomainInfo::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void TMTUserDomainInfo::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserDomainInfo::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* TMTUserDomainInfo::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserDomainInfo::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string parent_id = 4;
inline bool TMTUserDomainInfo::has_parent_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTUserDomainInfo::set_has_parent_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTUserDomainInfo::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTUserDomainInfo::clear_parent_id() {
  if (parent_id_ != &::google::protobuf::internal::kEmptyString) {
    parent_id_->clear();
  }
  clear_has_parent_id();
}
inline const ::std::string& TMTUserDomainInfo::parent_id() const {
  return *parent_id_;
}
inline void TMTUserDomainInfo::set_parent_id(const ::std::string& value) {
  set_has_parent_id();
  if (parent_id_ == &::google::protobuf::internal::kEmptyString) {
    parent_id_ = new ::std::string;
  }
  parent_id_->assign(value);
}
inline void TMTUserDomainInfo::set_parent_id(const char* value) {
  set_has_parent_id();
  if (parent_id_ == &::google::protobuf::internal::kEmptyString) {
    parent_id_ = new ::std::string;
  }
  parent_id_->assign(value);
}
inline void TMTUserDomainInfo::set_parent_id(const char* value, size_t size) {
  set_has_parent_id();
  if (parent_id_ == &::google::protobuf::internal::kEmptyString) {
    parent_id_ = new ::std::string;
  }
  parent_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserDomainInfo::mutable_parent_id() {
  set_has_parent_id();
  if (parent_id_ == &::google::protobuf::internal::kEmptyString) {
    parent_id_ = new ::std::string;
  }
  return parent_id_;
}
inline ::std::string* TMTUserDomainInfo::release_parent_id() {
  clear_has_parent_id();
  if (parent_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parent_id_;
    parent_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserDomainInfo::set_allocated_parent_id(::std::string* parent_id) {
  if (parent_id_ != &::google::protobuf::internal::kEmptyString) {
    delete parent_id_;
  }
  if (parent_id) {
    set_has_parent_id();
    parent_id_ = parent_id;
  } else {
    clear_has_parent_id();
    parent_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 version = 5;
inline bool TMTUserDomainInfo::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTUserDomainInfo::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTUserDomainInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTUserDomainInfo::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 TMTUserDomainInfo::version() const {
  return version_;
}
inline void TMTUserDomainInfo::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// TMTUserDomains

// optional uint32 count = 1;
inline bool TMTUserDomains::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUserDomains::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUserDomains::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUserDomains::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTUserDomains::count() const {
  return count_;
}
inline void TMTUserDomains::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTUserDomainInfo user_domain_info = 2;
inline int TMTUserDomains::user_domain_info_size() const {
  return user_domain_info_.size();
}
inline void TMTUserDomains::clear_user_domain_info() {
  user_domain_info_.Clear();
}
inline const ::mt::TMTUserDomainInfo& TMTUserDomains::user_domain_info(int index) const {
  return user_domain_info_.Get(index);
}
inline ::mt::TMTUserDomainInfo* TMTUserDomains::mutable_user_domain_info(int index) {
  return user_domain_info_.Mutable(index);
}
inline ::mt::TMTUserDomainInfo* TMTUserDomains::add_user_domain_info() {
  return user_domain_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUserDomainInfo >&
TMTUserDomains::user_domain_info() const {
  return user_domain_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUserDomainInfo >*
TMTUserDomains::mutable_user_domain_info() {
  return &user_domain_info_;
}

// -------------------------------------------------------------------

// TMTUserDomainDepartmentInfo

// optional string moid = 1;
inline bool TMTUserDomainDepartmentInfo::has_moid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUserDomainDepartmentInfo::set_has_moid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUserDomainDepartmentInfo::clear_has_moid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUserDomainDepartmentInfo::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTUserDomainDepartmentInfo::moid() const {
  return *moid_;
}
inline void TMTUserDomainDepartmentInfo::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTUserDomainDepartmentInfo::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTUserDomainDepartmentInfo::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserDomainDepartmentInfo::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTUserDomainDepartmentInfo::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserDomainDepartmentInfo::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 department_id = 2;
inline bool TMTUserDomainDepartmentInfo::has_department_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUserDomainDepartmentInfo::set_has_department_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUserDomainDepartmentInfo::clear_has_department_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUserDomainDepartmentInfo::clear_department_id() {
  department_id_ = 0u;
  clear_has_department_id();
}
inline ::google::protobuf::uint32 TMTUserDomainDepartmentInfo::department_id() const {
  return department_id_;
}
inline void TMTUserDomainDepartmentInfo::set_department_id(::google::protobuf::uint32 value) {
  set_has_department_id();
  department_id_ = value;
}

// optional string department_name = 3;
inline bool TMTUserDomainDepartmentInfo::has_department_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTUserDomainDepartmentInfo::set_has_department_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTUserDomainDepartmentInfo::clear_has_department_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTUserDomainDepartmentInfo::clear_department_name() {
  if (department_name_ != &::google::protobuf::internal::kEmptyString) {
    department_name_->clear();
  }
  clear_has_department_name();
}
inline const ::std::string& TMTUserDomainDepartmentInfo::department_name() const {
  return *department_name_;
}
inline void TMTUserDomainDepartmentInfo::set_department_name(const ::std::string& value) {
  set_has_department_name();
  if (department_name_ == &::google::protobuf::internal::kEmptyString) {
    department_name_ = new ::std::string;
  }
  department_name_->assign(value);
}
inline void TMTUserDomainDepartmentInfo::set_department_name(const char* value) {
  set_has_department_name();
  if (department_name_ == &::google::protobuf::internal::kEmptyString) {
    department_name_ = new ::std::string;
  }
  department_name_->assign(value);
}
inline void TMTUserDomainDepartmentInfo::set_department_name(const char* value, size_t size) {
  set_has_department_name();
  if (department_name_ == &::google::protobuf::internal::kEmptyString) {
    department_name_ = new ::std::string;
  }
  department_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserDomainDepartmentInfo::mutable_department_name() {
  set_has_department_name();
  if (department_name_ == &::google::protobuf::internal::kEmptyString) {
    department_name_ = new ::std::string;
  }
  return department_name_;
}
inline ::std::string* TMTUserDomainDepartmentInfo::release_department_name() {
  clear_has_department_name();
  if (department_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = department_name_;
    department_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserDomainDepartmentInfo::set_allocated_department_name(::std::string* department_name) {
  if (department_name_ != &::google::protobuf::internal::kEmptyString) {
    delete department_name_;
  }
  if (department_name) {
    set_has_department_name();
    department_name_ = department_name;
  } else {
    clear_has_department_name();
    department_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 parent_id = 4;
inline bool TMTUserDomainDepartmentInfo::has_parent_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTUserDomainDepartmentInfo::set_has_parent_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTUserDomainDepartmentInfo::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTUserDomainDepartmentInfo::clear_parent_id() {
  parent_id_ = 0u;
  clear_has_parent_id();
}
inline ::google::protobuf::uint32 TMTUserDomainDepartmentInfo::parent_id() const {
  return parent_id_;
}
inline void TMTUserDomainDepartmentInfo::set_parent_id(::google::protobuf::uint32 value) {
  set_has_parent_id();
  parent_id_ = value;
}

// optional bool leaf = 5;
inline bool TMTUserDomainDepartmentInfo::has_leaf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTUserDomainDepartmentInfo::set_has_leaf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTUserDomainDepartmentInfo::clear_has_leaf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTUserDomainDepartmentInfo::clear_leaf() {
  leaf_ = false;
  clear_has_leaf();
}
inline bool TMTUserDomainDepartmentInfo::leaf() const {
  return leaf_;
}
inline void TMTUserDomainDepartmentInfo::set_leaf(bool value) {
  set_has_leaf();
  leaf_ = value;
}

// -------------------------------------------------------------------

// TMTUserDomainDepartments

// optional uint32 count = 1;
inline bool TMTUserDomainDepartments::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUserDomainDepartments::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUserDomainDepartments::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUserDomainDepartments::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTUserDomainDepartments::count() const {
  return count_;
}
inline void TMTUserDomainDepartments::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .mt.TMTUserDomainDepartmentInfo user_domain_dept_info = 2;
inline int TMTUserDomainDepartments::user_domain_dept_info_size() const {
  return user_domain_dept_info_.size();
}
inline void TMTUserDomainDepartments::clear_user_domain_dept_info() {
  user_domain_dept_info_.Clear();
}
inline const ::mt::TMTUserDomainDepartmentInfo& TMTUserDomainDepartments::user_domain_dept_info(int index) const {
  return user_domain_dept_info_.Get(index);
}
inline ::mt::TMTUserDomainDepartmentInfo* TMTUserDomainDepartments::mutable_user_domain_dept_info(int index) {
  return user_domain_dept_info_.Mutable(index);
}
inline ::mt::TMTUserDomainDepartmentInfo* TMTUserDomainDepartments::add_user_domain_dept_info() {
  return user_domain_dept_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUserDomainDepartmentInfo >&
TMTUserDomainDepartments::user_domain_dept_info() const {
  return user_domain_dept_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUserDomainDepartmentInfo >*
TMTUserDomainDepartments::mutable_user_domain_dept_info() {
  return &user_domain_dept_info_;
}

// -------------------------------------------------------------------

// TMTPublicGroupInfo

// optional string moid = 1;
inline bool TMTPublicGroupInfo::has_moid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPublicGroupInfo::set_has_moid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPublicGroupInfo::clear_has_moid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPublicGroupInfo::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTPublicGroupInfo::moid() const {
  return *moid_;
}
inline void TMTPublicGroupInfo::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTPublicGroupInfo::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTPublicGroupInfo::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupInfo::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTPublicGroupInfo::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupInfo::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TMTPublicGroupInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPublicGroupInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPublicGroupInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPublicGroupInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTPublicGroupInfo::name() const {
  return *name_;
}
inline void TMTPublicGroupInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPublicGroupInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPublicGroupInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTPublicGroupInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string parent_moid = 3;
inline bool TMTPublicGroupInfo::has_parent_moid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPublicGroupInfo::set_has_parent_moid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPublicGroupInfo::clear_has_parent_moid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPublicGroupInfo::clear_parent_moid() {
  if (parent_moid_ != &::google::protobuf::internal::kEmptyString) {
    parent_moid_->clear();
  }
  clear_has_parent_moid();
}
inline const ::std::string& TMTPublicGroupInfo::parent_moid() const {
  return *parent_moid_;
}
inline void TMTPublicGroupInfo::set_parent_moid(const ::std::string& value) {
  set_has_parent_moid();
  if (parent_moid_ == &::google::protobuf::internal::kEmptyString) {
    parent_moid_ = new ::std::string;
  }
  parent_moid_->assign(value);
}
inline void TMTPublicGroupInfo::set_parent_moid(const char* value) {
  set_has_parent_moid();
  if (parent_moid_ == &::google::protobuf::internal::kEmptyString) {
    parent_moid_ = new ::std::string;
  }
  parent_moid_->assign(value);
}
inline void TMTPublicGroupInfo::set_parent_moid(const char* value, size_t size) {
  set_has_parent_moid();
  if (parent_moid_ == &::google::protobuf::internal::kEmptyString) {
    parent_moid_ = new ::std::string;
  }
  parent_moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupInfo::mutable_parent_moid() {
  set_has_parent_moid();
  if (parent_moid_ == &::google::protobuf::internal::kEmptyString) {
    parent_moid_ = new ::std::string;
  }
  return parent_moid_;
}
inline ::std::string* TMTPublicGroupInfo::release_parent_moid() {
  clear_has_parent_moid();
  if (parent_moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parent_moid_;
    parent_moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupInfo::set_allocated_parent_moid(::std::string* parent_moid) {
  if (parent_moid_ != &::google::protobuf::internal::kEmptyString) {
    delete parent_moid_;
  }
  if (parent_moid) {
    set_has_parent_moid();
    parent_moid_ = parent_moid;
  } else {
    clear_has_parent_moid();
    parent_moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTPublicGroups

// repeated .mt.TMTPublicGroupInfo group_info = 1;
inline int TMTPublicGroups::group_info_size() const {
  return group_info_.size();
}
inline void TMTPublicGroups::clear_group_info() {
  group_info_.Clear();
}
inline const ::mt::TMTPublicGroupInfo& TMTPublicGroups::group_info(int index) const {
  return group_info_.Get(index);
}
inline ::mt::TMTPublicGroupInfo* TMTPublicGroups::mutable_group_info(int index) {
  return group_info_.Mutable(index);
}
inline ::mt::TMTPublicGroupInfo* TMTPublicGroups::add_group_info() {
  return group_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPublicGroupInfo >&
TMTPublicGroups::group_info() const {
  return group_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPublicGroupInfo >*
TMTPublicGroups::mutable_group_info() {
  return &group_info_;
}

// -------------------------------------------------------------------

// TMTPublicGroupUserInfo

// optional string moid = 1;
inline bool TMTPublicGroupUserInfo::has_moid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_moid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPublicGroupUserInfo::clear_has_moid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPublicGroupUserInfo::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTPublicGroupUserInfo::moid() const {
  return *moid_;
}
inline void TMTPublicGroupUserInfo::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jid = 2;
inline bool TMTPublicGroupUserInfo::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPublicGroupUserInfo::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPublicGroupUserInfo::clear_jid() {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    jid_->clear();
  }
  clear_has_jid();
}
inline const ::std::string& TMTPublicGroupUserInfo::jid() const {
  return *jid_;
}
inline void TMTPublicGroupUserInfo::set_jid(const ::std::string& value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_jid(const char* value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_jid(const char* value, size_t size) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_jid() {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  return jid_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_jid() {
  clear_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jid_;
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_jid(::std::string* jid) {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    delete jid_;
  }
  if (jid) {
    set_has_jid();
    jid_ = jid;
  } else {
    clear_has_jid();
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 3;
inline bool TMTPublicGroupUserInfo::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPublicGroupUserInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPublicGroupUserInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTPublicGroupUserInfo::account() const {
  return *account_;
}
inline void TMTPublicGroupUserInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 4;
inline bool TMTPublicGroupUserInfo::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPublicGroupUserInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPublicGroupUserInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& TMTPublicGroupUserInfo::email() const {
  return *email_;
}
inline void TMTPublicGroupUserInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 5;
inline bool TMTPublicGroupUserInfo::has_e164() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_e164() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTPublicGroupUserInfo::clear_has_e164() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTPublicGroupUserInfo::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTPublicGroupUserInfo::e164() const {
  return *e164_;
}
inline void TMTPublicGroupUserInfo::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobile = 6;
inline bool TMTPublicGroupUserInfo::has_mobile() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_mobile() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTPublicGroupUserInfo::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTPublicGroupUserInfo::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& TMTPublicGroupUserInfo::mobile() const {
  return *mobile_;
}
inline void TMTPublicGroupUserInfo::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_mobile(::std::string* mobile) {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_;
  }
  if (mobile) {
    set_has_mobile();
    mobile_ = mobile;
  } else {
    clear_has_mobile();
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string group_moid = 7;
inline bool TMTPublicGroupUserInfo::has_group_moid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_group_moid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTPublicGroupUserInfo::clear_has_group_moid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTPublicGroupUserInfo::clear_group_moid() {
  if (group_moid_ != &::google::protobuf::internal::kEmptyString) {
    group_moid_->clear();
  }
  clear_has_group_moid();
}
inline const ::std::string& TMTPublicGroupUserInfo::group_moid() const {
  return *group_moid_;
}
inline void TMTPublicGroupUserInfo::set_group_moid(const ::std::string& value) {
  set_has_group_moid();
  if (group_moid_ == &::google::protobuf::internal::kEmptyString) {
    group_moid_ = new ::std::string;
  }
  group_moid_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_group_moid(const char* value) {
  set_has_group_moid();
  if (group_moid_ == &::google::protobuf::internal::kEmptyString) {
    group_moid_ = new ::std::string;
  }
  group_moid_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_group_moid(const char* value, size_t size) {
  set_has_group_moid();
  if (group_moid_ == &::google::protobuf::internal::kEmptyString) {
    group_moid_ = new ::std::string;
  }
  group_moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_group_moid() {
  set_has_group_moid();
  if (group_moid_ == &::google::protobuf::internal::kEmptyString) {
    group_moid_ = new ::std::string;
  }
  return group_moid_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_group_moid() {
  clear_has_group_moid();
  if (group_moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_moid_;
    group_moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_group_moid(::std::string* group_moid) {
  if (group_moid_ != &::google::protobuf::internal::kEmptyString) {
    delete group_moid_;
  }
  if (group_moid) {
    set_has_group_moid();
    group_moid_ = group_moid;
  } else {
    clear_has_group_moid();
    group_moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 8;
inline bool TMTPublicGroupUserInfo::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTPublicGroupUserInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTPublicGroupUserInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTPublicGroupUserInfo::name() const {
  return *name_;
}
inline void TMTPublicGroupUserInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extnum = 9;
inline bool TMTPublicGroupUserInfo::has_extnum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_extnum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTPublicGroupUserInfo::clear_has_extnum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTPublicGroupUserInfo::clear_extnum() {
  if (extnum_ != &::google::protobuf::internal::kEmptyString) {
    extnum_->clear();
  }
  clear_has_extnum();
}
inline const ::std::string& TMTPublicGroupUserInfo::extnum() const {
  return *extnum_;
}
inline void TMTPublicGroupUserInfo::set_extnum(const ::std::string& value) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_extnum(const char* value) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_extnum(const char* value, size_t size) {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  extnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_extnum() {
  set_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    extnum_ = new ::std::string;
  }
  return extnum_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_extnum() {
  clear_has_extnum();
  if (extnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extnum_;
    extnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_extnum(::std::string* extnum) {
  if (extnum_ != &::google::protobuf::internal::kEmptyString) {
    delete extnum_;
  }
  if (extnum) {
    set_has_extnum();
    extnum_ = extnum;
  } else {
    clear_has_extnum();
    extnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string seat = 10;
inline bool TMTPublicGroupUserInfo::has_seat() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_seat() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTPublicGroupUserInfo::clear_has_seat() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTPublicGroupUserInfo::clear_seat() {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    seat_->clear();
  }
  clear_has_seat();
}
inline const ::std::string& TMTPublicGroupUserInfo::seat() const {
  return *seat_;
}
inline void TMTPublicGroupUserInfo::set_seat(const ::std::string& value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_seat(const char* value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_seat(const char* value, size_t size) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_seat() {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  return seat_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_seat() {
  clear_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seat_;
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_seat(::std::string* seat) {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    delete seat_;
  }
  if (seat) {
    set_has_seat();
    seat_ = seat;
  } else {
    clear_has_seat();
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brief = 11;
inline bool TMTPublicGroupUserInfo::has_brief() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_brief() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTPublicGroupUserInfo::clear_has_brief() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTPublicGroupUserInfo::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TMTPublicGroupUserInfo::brief() const {
  return *brief_;
}
inline void TMTPublicGroupUserInfo::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portrait40 = 12;
inline bool TMTPublicGroupUserInfo::has_portrait40() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_portrait40() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTPublicGroupUserInfo::clear_has_portrait40() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTPublicGroupUserInfo::clear_portrait40() {
  if (portrait40_ != &::google::protobuf::internal::kEmptyString) {
    portrait40_->clear();
  }
  clear_has_portrait40();
}
inline const ::std::string& TMTPublicGroupUserInfo::portrait40() const {
  return *portrait40_;
}
inline void TMTPublicGroupUserInfo::set_portrait40(const ::std::string& value) {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  portrait40_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_portrait40(const char* value) {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  portrait40_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_portrait40(const char* value, size_t size) {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  portrait40_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_portrait40() {
  set_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    portrait40_ = new ::std::string;
  }
  return portrait40_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_portrait40() {
  clear_has_portrait40();
  if (portrait40_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portrait40_;
    portrait40_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_portrait40(::std::string* portrait40) {
  if (portrait40_ != &::google::protobuf::internal::kEmptyString) {
    delete portrait40_;
  }
  if (portrait40) {
    set_has_portrait40();
    portrait40_ = portrait40;
  } else {
    clear_has_portrait40();
    portrait40_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portrait64 = 13;
inline bool TMTPublicGroupUserInfo::has_portrait64() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_portrait64() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTPublicGroupUserInfo::clear_has_portrait64() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTPublicGroupUserInfo::clear_portrait64() {
  if (portrait64_ != &::google::protobuf::internal::kEmptyString) {
    portrait64_->clear();
  }
  clear_has_portrait64();
}
inline const ::std::string& TMTPublicGroupUserInfo::portrait64() const {
  return *portrait64_;
}
inline void TMTPublicGroupUserInfo::set_portrait64(const ::std::string& value) {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  portrait64_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_portrait64(const char* value) {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  portrait64_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_portrait64(const char* value, size_t size) {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  portrait64_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_portrait64() {
  set_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    portrait64_ = new ::std::string;
  }
  return portrait64_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_portrait64() {
  clear_has_portrait64();
  if (portrait64_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portrait64_;
    portrait64_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_portrait64(::std::string* portrait64) {
  if (portrait64_ != &::google::protobuf::internal::kEmptyString) {
    delete portrait64_;
  }
  if (portrait64) {
    set_has_portrait64();
    portrait64_ = portrait64;
  } else {
    clear_has_portrait64();
    portrait64_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portrait128 = 14;
inline bool TMTPublicGroupUserInfo::has_portrait128() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTPublicGroupUserInfo::set_has_portrait128() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTPublicGroupUserInfo::clear_has_portrait128() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTPublicGroupUserInfo::clear_portrait128() {
  if (portrait128_ != &::google::protobuf::internal::kEmptyString) {
    portrait128_->clear();
  }
  clear_has_portrait128();
}
inline const ::std::string& TMTPublicGroupUserInfo::portrait128() const {
  return *portrait128_;
}
inline void TMTPublicGroupUserInfo::set_portrait128(const ::std::string& value) {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  portrait128_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_portrait128(const char* value) {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  portrait128_->assign(value);
}
inline void TMTPublicGroupUserInfo::set_portrait128(const char* value, size_t size) {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  portrait128_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPublicGroupUserInfo::mutable_portrait128() {
  set_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    portrait128_ = new ::std::string;
  }
  return portrait128_;
}
inline ::std::string* TMTPublicGroupUserInfo::release_portrait128() {
  clear_has_portrait128();
  if (portrait128_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portrait128_;
    portrait128_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPublicGroupUserInfo::set_allocated_portrait128(::std::string* portrait128) {
  if (portrait128_ != &::google::protobuf::internal::kEmptyString) {
    delete portrait128_;
  }
  if (portrait128) {
    set_has_portrait128();
    portrait128_ = portrait128;
  } else {
    clear_has_portrait128();
    portrait128_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTPublicGroupUsers

// repeated .mt.TMTPublicGroupUserInfo user_info = 1;
inline int TMTPublicGroupUsers::user_info_size() const {
  return user_info_.size();
}
inline void TMTPublicGroupUsers::clear_user_info() {
  user_info_.Clear();
}
inline const ::mt::TMTPublicGroupUserInfo& TMTPublicGroupUsers::user_info(int index) const {
  return user_info_.Get(index);
}
inline ::mt::TMTPublicGroupUserInfo* TMTPublicGroupUsers::mutable_user_info(int index) {
  return user_info_.Mutable(index);
}
inline ::mt::TMTPublicGroupUserInfo* TMTPublicGroupUsers::add_user_info() {
  return user_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPublicGroupUserInfo >&
TMTPublicGroupUsers::user_info() const {
  return user_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPublicGroupUserInfo >*
TMTPublicGroupUsers::mutable_user_info() {
  return &user_info_;
}

// -------------------------------------------------------------------

// TMTPushSrvReq

// optional string username = 1;
inline bool TMTPushSrvReq::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPushSrvReq::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPushSrvReq::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPushSrvReq::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMTPushSrvReq::username() const {
  return *username_;
}
inline void TMTPushSrvReq::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTPushSrvReq::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTPushSrvReq::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMTPushSrvReq::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool TMTPushSrvReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPushSrvReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPushSrvReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPushSrvReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTPushSrvReq::password() const {
  return *password_;
}
inline void TMTPushSrvReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTPushSrvReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTPushSrvReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTPushSrvReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 3;
inline bool TMTPushSrvReq::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPushSrvReq::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPushSrvReq::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPushSrvReq::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TMTPushSrvReq::version() const {
  return *version_;
}
inline void TMTPushSrvReq::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TMTPushSrvReq::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TMTPushSrvReq::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* TMTPushSrvReq::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string usermoid = 4;
inline bool TMTPushSrvReq::has_usermoid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPushSrvReq::set_has_usermoid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPushSrvReq::clear_has_usermoid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPushSrvReq::clear_usermoid() {
  if (usermoid_ != &::google::protobuf::internal::kEmptyString) {
    usermoid_->clear();
  }
  clear_has_usermoid();
}
inline const ::std::string& TMTPushSrvReq::usermoid() const {
  return *usermoid_;
}
inline void TMTPushSrvReq::set_usermoid(const ::std::string& value) {
  set_has_usermoid();
  if (usermoid_ == &::google::protobuf::internal::kEmptyString) {
    usermoid_ = new ::std::string;
  }
  usermoid_->assign(value);
}
inline void TMTPushSrvReq::set_usermoid(const char* value) {
  set_has_usermoid();
  if (usermoid_ == &::google::protobuf::internal::kEmptyString) {
    usermoid_ = new ::std::string;
  }
  usermoid_->assign(value);
}
inline void TMTPushSrvReq::set_usermoid(const char* value, size_t size) {
  set_has_usermoid();
  if (usermoid_ == &::google::protobuf::internal::kEmptyString) {
    usermoid_ = new ::std::string;
  }
  usermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_usermoid() {
  set_has_usermoid();
  if (usermoid_ == &::google::protobuf::internal::kEmptyString) {
    usermoid_ = new ::std::string;
  }
  return usermoid_;
}
inline ::std::string* TMTPushSrvReq::release_usermoid() {
  clear_has_usermoid();
  if (usermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usermoid_;
    usermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_usermoid(::std::string* usermoid) {
  if (usermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete usermoid_;
  }
  if (usermoid) {
    set_has_usermoid();
    usermoid_ = usermoid;
  } else {
    clear_has_usermoid();
    usermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 5;
inline bool TMTPushSrvReq::has_e164() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTPushSrvReq::set_has_e164() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTPushSrvReq::clear_has_e164() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTPushSrvReq::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTPushSrvReq::e164() const {
  return *e164_;
}
inline void TMTPushSrvReq::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTPushSrvReq::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTPushSrvReq::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTPushSrvReq::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mttype = 6;
inline bool TMTPushSrvReq::has_mttype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTPushSrvReq::set_has_mttype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTPushSrvReq::clear_has_mttype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTPushSrvReq::clear_mttype() {
  if (mttype_ != &::google::protobuf::internal::kEmptyString) {
    mttype_->clear();
  }
  clear_has_mttype();
}
inline const ::std::string& TMTPushSrvReq::mttype() const {
  return *mttype_;
}
inline void TMTPushSrvReq::set_mttype(const ::std::string& value) {
  set_has_mttype();
  if (mttype_ == &::google::protobuf::internal::kEmptyString) {
    mttype_ = new ::std::string;
  }
  mttype_->assign(value);
}
inline void TMTPushSrvReq::set_mttype(const char* value) {
  set_has_mttype();
  if (mttype_ == &::google::protobuf::internal::kEmptyString) {
    mttype_ = new ::std::string;
  }
  mttype_->assign(value);
}
inline void TMTPushSrvReq::set_mttype(const char* value, size_t size) {
  set_has_mttype();
  if (mttype_ == &::google::protobuf::internal::kEmptyString) {
    mttype_ = new ::std::string;
  }
  mttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_mttype() {
  set_has_mttype();
  if (mttype_ == &::google::protobuf::internal::kEmptyString) {
    mttype_ = new ::std::string;
  }
  return mttype_;
}
inline ::std::string* TMTPushSrvReq::release_mttype() {
  clear_has_mttype();
  if (mttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mttype_;
    mttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_mttype(::std::string* mttype) {
  if (mttype_ != &::google::protobuf::internal::kEmptyString) {
    delete mttype_;
  }
  if (mttype) {
    set_has_mttype();
    mttype_ = mttype;
  } else {
    clear_has_mttype();
    mttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alideviceid = 7;
inline bool TMTPushSrvReq::has_alideviceid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTPushSrvReq::set_has_alideviceid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTPushSrvReq::clear_has_alideviceid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTPushSrvReq::clear_alideviceid() {
  if (alideviceid_ != &::google::protobuf::internal::kEmptyString) {
    alideviceid_->clear();
  }
  clear_has_alideviceid();
}
inline const ::std::string& TMTPushSrvReq::alideviceid() const {
  return *alideviceid_;
}
inline void TMTPushSrvReq::set_alideviceid(const ::std::string& value) {
  set_has_alideviceid();
  if (alideviceid_ == &::google::protobuf::internal::kEmptyString) {
    alideviceid_ = new ::std::string;
  }
  alideviceid_->assign(value);
}
inline void TMTPushSrvReq::set_alideviceid(const char* value) {
  set_has_alideviceid();
  if (alideviceid_ == &::google::protobuf::internal::kEmptyString) {
    alideviceid_ = new ::std::string;
  }
  alideviceid_->assign(value);
}
inline void TMTPushSrvReq::set_alideviceid(const char* value, size_t size) {
  set_has_alideviceid();
  if (alideviceid_ == &::google::protobuf::internal::kEmptyString) {
    alideviceid_ = new ::std::string;
  }
  alideviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_alideviceid() {
  set_has_alideviceid();
  if (alideviceid_ == &::google::protobuf::internal::kEmptyString) {
    alideviceid_ = new ::std::string;
  }
  return alideviceid_;
}
inline ::std::string* TMTPushSrvReq::release_alideviceid() {
  clear_has_alideviceid();
  if (alideviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alideviceid_;
    alideviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_alideviceid(::std::string* alideviceid) {
  if (alideviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete alideviceid_;
  }
  if (alideviceid) {
    set_has_alideviceid();
    alideviceid_ = alideviceid;
  } else {
    clear_has_alideviceid();
    alideviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string aliappkey = 8;
inline bool TMTPushSrvReq::has_aliappkey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTPushSrvReq::set_has_aliappkey() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTPushSrvReq::clear_has_aliappkey() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTPushSrvReq::clear_aliappkey() {
  if (aliappkey_ != &::google::protobuf::internal::kEmptyString) {
    aliappkey_->clear();
  }
  clear_has_aliappkey();
}
inline const ::std::string& TMTPushSrvReq::aliappkey() const {
  return *aliappkey_;
}
inline void TMTPushSrvReq::set_aliappkey(const ::std::string& value) {
  set_has_aliappkey();
  if (aliappkey_ == &::google::protobuf::internal::kEmptyString) {
    aliappkey_ = new ::std::string;
  }
  aliappkey_->assign(value);
}
inline void TMTPushSrvReq::set_aliappkey(const char* value) {
  set_has_aliappkey();
  if (aliappkey_ == &::google::protobuf::internal::kEmptyString) {
    aliappkey_ = new ::std::string;
  }
  aliappkey_->assign(value);
}
inline void TMTPushSrvReq::set_aliappkey(const char* value, size_t size) {
  set_has_aliappkey();
  if (aliappkey_ == &::google::protobuf::internal::kEmptyString) {
    aliappkey_ = new ::std::string;
  }
  aliappkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_aliappkey() {
  set_has_aliappkey();
  if (aliappkey_ == &::google::protobuf::internal::kEmptyString) {
    aliappkey_ = new ::std::string;
  }
  return aliappkey_;
}
inline ::std::string* TMTPushSrvReq::release_aliappkey() {
  clear_has_aliappkey();
  if (aliappkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = aliappkey_;
    aliappkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_aliappkey(::std::string* aliappkey) {
  if (aliappkey_ != &::google::protobuf::internal::kEmptyString) {
    delete aliappkey_;
  }
  if (aliappkey) {
    set_has_aliappkey();
    aliappkey_ = aliappkey;
  } else {
    clear_has_aliappkey();
    aliappkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mtsystype = 9;
inline bool TMTPushSrvReq::has_mtsystype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTPushSrvReq::set_has_mtsystype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTPushSrvReq::clear_has_mtsystype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTPushSrvReq::clear_mtsystype() {
  if (mtsystype_ != &::google::protobuf::internal::kEmptyString) {
    mtsystype_->clear();
  }
  clear_has_mtsystype();
}
inline const ::std::string& TMTPushSrvReq::mtsystype() const {
  return *mtsystype_;
}
inline void TMTPushSrvReq::set_mtsystype(const ::std::string& value) {
  set_has_mtsystype();
  if (mtsystype_ == &::google::protobuf::internal::kEmptyString) {
    mtsystype_ = new ::std::string;
  }
  mtsystype_->assign(value);
}
inline void TMTPushSrvReq::set_mtsystype(const char* value) {
  set_has_mtsystype();
  if (mtsystype_ == &::google::protobuf::internal::kEmptyString) {
    mtsystype_ = new ::std::string;
  }
  mtsystype_->assign(value);
}
inline void TMTPushSrvReq::set_mtsystype(const char* value, size_t size) {
  set_has_mtsystype();
  if (mtsystype_ == &::google::protobuf::internal::kEmptyString) {
    mtsystype_ = new ::std::string;
  }
  mtsystype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_mtsystype() {
  set_has_mtsystype();
  if (mtsystype_ == &::google::protobuf::internal::kEmptyString) {
    mtsystype_ = new ::std::string;
  }
  return mtsystype_;
}
inline ::std::string* TMTPushSrvReq::release_mtsystype() {
  clear_has_mtsystype();
  if (mtsystype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mtsystype_;
    mtsystype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_mtsystype(::std::string* mtsystype) {
  if (mtsystype_ != &::google::protobuf::internal::kEmptyString) {
    delete mtsystype_;
  }
  if (mtsystype) {
    set_has_mtsystype();
    mtsystype_ = mtsystype;
  } else {
    clear_has_mtsystype();
    mtsystype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mtsyslan = 10;
inline bool TMTPushSrvReq::has_mtsyslan() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTPushSrvReq::set_has_mtsyslan() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTPushSrvReq::clear_has_mtsyslan() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTPushSrvReq::clear_mtsyslan() {
  if (mtsyslan_ != &::google::protobuf::internal::kEmptyString) {
    mtsyslan_->clear();
  }
  clear_has_mtsyslan();
}
inline const ::std::string& TMTPushSrvReq::mtsyslan() const {
  return *mtsyslan_;
}
inline void TMTPushSrvReq::set_mtsyslan(const ::std::string& value) {
  set_has_mtsyslan();
  if (mtsyslan_ == &::google::protobuf::internal::kEmptyString) {
    mtsyslan_ = new ::std::string;
  }
  mtsyslan_->assign(value);
}
inline void TMTPushSrvReq::set_mtsyslan(const char* value) {
  set_has_mtsyslan();
  if (mtsyslan_ == &::google::protobuf::internal::kEmptyString) {
    mtsyslan_ = new ::std::string;
  }
  mtsyslan_->assign(value);
}
inline void TMTPushSrvReq::set_mtsyslan(const char* value, size_t size) {
  set_has_mtsyslan();
  if (mtsyslan_ == &::google::protobuf::internal::kEmptyString) {
    mtsyslan_ = new ::std::string;
  }
  mtsyslan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_mtsyslan() {
  set_has_mtsyslan();
  if (mtsyslan_ == &::google::protobuf::internal::kEmptyString) {
    mtsyslan_ = new ::std::string;
  }
  return mtsyslan_;
}
inline ::std::string* TMTPushSrvReq::release_mtsyslan() {
  clear_has_mtsyslan();
  if (mtsyslan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mtsyslan_;
    mtsyslan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_mtsyslan(::std::string* mtsyslan) {
  if (mtsyslan_ != &::google::protobuf::internal::kEmptyString) {
    delete mtsyslan_;
  }
  if (mtsyslan) {
    set_has_mtsyslan();
    mtsyslan_ = mtsyslan;
  } else {
    clear_has_mtsyslan();
    mtsyslan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceid = 11;
inline bool TMTPushSrvReq::has_deviceid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTPushSrvReq::set_has_deviceid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTPushSrvReq::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTPushSrvReq::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& TMTPushSrvReq::deviceid() const {
  return *deviceid_;
}
inline void TMTPushSrvReq::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void TMTPushSrvReq::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void TMTPushSrvReq::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* TMTPushSrvReq::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 srvip = 12;
inline bool TMTPushSrvReq::has_srvip() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTPushSrvReq::set_has_srvip() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTPushSrvReq::clear_has_srvip() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTPushSrvReq::clear_srvip() {
  srvip_ = 0u;
  clear_has_srvip();
}
inline ::google::protobuf::uint32 TMTPushSrvReq::srvip() const {
  return srvip_;
}
inline void TMTPushSrvReq::set_srvip(::google::protobuf::uint32 value) {
  set_has_srvip();
  srvip_ = value;
}

// optional string jid = 13;
inline bool TMTPushSrvReq::has_jid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTPushSrvReq::set_has_jid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTPushSrvReq::clear_has_jid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTPushSrvReq::clear_jid() {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    jid_->clear();
  }
  clear_has_jid();
}
inline const ::std::string& TMTPushSrvReq::jid() const {
  return *jid_;
}
inline void TMTPushSrvReq::set_jid(const ::std::string& value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTPushSrvReq::set_jid(const char* value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTPushSrvReq::set_jid(const char* value, size_t size) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPushSrvReq::mutable_jid() {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  return jid_;
}
inline ::std::string* TMTPushSrvReq::release_jid() {
  clear_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jid_;
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPushSrvReq::set_allocated_jid(::std::string* jid) {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    delete jid_;
  }
  if (jid) {
    set_has_jid();
    jid_ = jid;
  } else {
    clear_has_jid();
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTPushSrvResult

// optional bool success = 1;
inline bool TMTPushSrvResult::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPushSrvResult::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPushSrvResult::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPushSrvResult::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool TMTPushSrvResult::success() const {
  return success_;
}
inline void TMTPushSrvResult::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional uint32 errorcode = 2;
inline bool TMTPushSrvResult::has_errorcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPushSrvResult::set_has_errorcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPushSrvResult::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPushSrvResult::clear_errorcode() {
  errorcode_ = 0u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 TMTPushSrvResult::errorcode() const {
  return errorcode_;
}
inline void TMTPushSrvResult::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// -------------------------------------------------------------------

// TMTVConfMember

// optional string name = 1;
inline bool TMTVConfMember::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVConfMember::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVConfMember::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVConfMember::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTVConfMember::name() const {
  return *name_;
}
inline void TMTVConfMember::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTVConfMember::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTVConfMember::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfMember::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTVConfMember::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfMember::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 2;
inline bool TMTVConfMember::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVConfMember::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVConfMember::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVConfMember::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTVConfMember::account() const {
  return *account_;
}
inline void TMTVConfMember::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTVConfMember::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTVConfMember::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfMember::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTVConfMember::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfMember::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtAddrType accounttype = 3;
inline bool TMTVConfMember::has_accounttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVConfMember::set_has_accounttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVConfMember::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVConfMember::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::mt::EmMtAddrType TMTVConfMember::accounttype() const {
  return static_cast< ::mt::EmMtAddrType >(accounttype_);
}
inline void TMTVConfMember::set_accounttype(::mt::EmMtAddrType value) {
  assert(::mt::EmMtAddrType_IsValid(value));
  set_has_accounttype();
  accounttype_ = value;
}

// optional .mt.EmConfProtocol protocol = 4;
inline bool TMTVConfMember::has_protocol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTVConfMember::set_has_protocol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTVConfMember::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTVConfMember::clear_protocol() {
  protocol_ = 0;
  clear_has_protocol();
}
inline ::mt::EmConfProtocol TMTVConfMember::protocol() const {
  return static_cast< ::mt::EmConfProtocol >(protocol_);
}
inline void TMTVConfMember::set_protocol(::mt::EmConfProtocol value) {
  assert(::mt::EmConfProtocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
}

// -------------------------------------------------------------------

// TMTCreateVConf

// optional uint32 confid = 1;
inline bool TMTCreateVConf::has_confid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCreateVConf::set_has_confid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCreateVConf::clear_has_confid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCreateVConf::clear_confid() {
  confid_ = 0u;
  clear_has_confid();
}
inline ::google::protobuf::uint32 TMTCreateVConf::confid() const {
  return confid_;
}
inline void TMTCreateVConf::set_confid(::google::protobuf::uint32 value) {
  set_has_confid();
  confid_ = value;
}

// optional string confname = 2;
inline bool TMTCreateVConf::has_confname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCreateVConf::set_has_confname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCreateVConf::clear_has_confname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCreateVConf::clear_confname() {
  if (confname_ != &::google::protobuf::internal::kEmptyString) {
    confname_->clear();
  }
  clear_has_confname();
}
inline const ::std::string& TMTCreateVConf::confname() const {
  return *confname_;
}
inline void TMTCreateVConf::set_confname(const ::std::string& value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
}
inline void TMTCreateVConf::set_confname(const char* value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
}
inline void TMTCreateVConf::set_confname(const char* value, size_t size) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTCreateVConf::mutable_confname() {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  return confname_;
}
inline ::std::string* TMTCreateVConf::release_confname() {
  clear_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confname_;
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTCreateVConf::set_allocated_confname(::std::string* confname) {
  if (confname_ != &::google::protobuf::internal::kEmptyString) {
    delete confname_;
  }
  if (confname) {
    set_has_confname();
    confname_ = confname;
  } else {
    clear_has_confname();
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 3;
inline bool TMTCreateVConf::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTCreateVConf::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTCreateVConf::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTCreateVConf::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTCreateVConf::duration() const {
  return duration_;
}
inline void TMTCreateVConf::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// repeated .mt.TMTVConfMember member = 4;
inline int TMTCreateVConf::member_size() const {
  return member_.size();
}
inline void TMTCreateVConf::clear_member() {
  member_.Clear();
}
inline const ::mt::TMTVConfMember& TMTCreateVConf::member(int index) const {
  return member_.Get(index);
}
inline ::mt::TMTVConfMember* TMTCreateVConf::mutable_member(int index) {
  return member_.Mutable(index);
}
inline ::mt::TMTVConfMember* TMTCreateVConf::add_member() {
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >&
TMTCreateVConf::member() const {
  return member_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >*
TMTCreateVConf::mutable_member() {
  return &member_;
}

// -------------------------------------------------------------------

// TMTVConfResult

// optional bool success = 1;
inline bool TMTVConfResult::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVConfResult::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVConfResult::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVConfResult::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool TMTVConfResult::success() const {
  return success_;
}
inline void TMTVConfResult::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional uint32 errorcode = 2;
inline bool TMTVConfResult::has_errorcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVConfResult::set_has_errorcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVConfResult::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVConfResult::clear_errorcode() {
  errorcode_ = 0u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 TMTVConfResult::errorcode() const {
  return errorcode_;
}
inline void TMTVConfResult::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional string description = 3;
inline bool TMTVConfResult::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVConfResult::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVConfResult::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVConfResult::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& TMTVConfResult::description() const {
  return *description_;
}
inline void TMTVConfResult::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TMTVConfResult::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TMTVConfResult::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfResult::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* TMTVConfResult::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfResult::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string templateid = 4;
inline bool TMTVConfResult::has_templateid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTVConfResult::set_has_templateid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTVConfResult::clear_has_templateid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTVConfResult::clear_templateid() {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    templateid_->clear();
  }
  clear_has_templateid();
}
inline const ::std::string& TMTVConfResult::templateid() const {
  return *templateid_;
}
inline void TMTVConfResult::set_templateid(const ::std::string& value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTVConfResult::set_templateid(const char* value) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(value);
}
inline void TMTVConfResult::set_templateid(const char* value, size_t size) {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  templateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfResult::mutable_templateid() {
  set_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    templateid_ = new ::std::string;
  }
  return templateid_;
}
inline ::std::string* TMTVConfResult::release_templateid() {
  clear_has_templateid();
  if (templateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = templateid_;
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfResult::set_allocated_templateid(::std::string* templateid) {
  if (templateid_ != &::google::protobuf::internal::kEmptyString) {
    delete templateid_;
  }
  if (templateid) {
    set_has_templateid();
    templateid_ = templateid;
  } else {
    clear_has_templateid();
    templateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTVConfListReq

// optional uint32 count = 1;
inline bool TMTVConfListReq::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVConfListReq::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVConfListReq::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVConfListReq::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMTVConfListReq::count() const {
  return count_;
}
inline void TMTVConfListReq::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 order = 2;
inline bool TMTVConfListReq::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVConfListReq::set_has_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVConfListReq::clear_has_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVConfListReq::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 TMTVConfListReq::order() const {
  return order_;
}
inline void TMTVConfListReq::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// optional uint32 start = 3;
inline bool TMTVConfListReq::has_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVConfListReq::set_has_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVConfListReq::clear_has_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVConfListReq::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 TMTVConfListReq::start() const {
  return start_;
}
inline void TMTVConfListReq::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// -------------------------------------------------------------------

// TMTVConfInfo

// optional string confid = 1;
inline bool TMTVConfInfo::has_confid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVConfInfo::set_has_confid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVConfInfo::clear_has_confid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVConfInfo::clear_confid() {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    confid_->clear();
  }
  clear_has_confid();
}
inline const ::std::string& TMTVConfInfo::confid() const {
  return *confid_;
}
inline void TMTVConfInfo::set_confid(const ::std::string& value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTVConfInfo::set_confid(const char* value) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(value);
}
inline void TMTVConfInfo::set_confid(const char* value, size_t size) {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  confid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfInfo::mutable_confid() {
  set_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    confid_ = new ::std::string;
  }
  return confid_;
}
inline ::std::string* TMTVConfInfo::release_confid() {
  clear_has_confid();
  if (confid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confid_;
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfInfo::set_allocated_confid(::std::string* confid) {
  if (confid_ != &::google::protobuf::internal::kEmptyString) {
    delete confid_;
  }
  if (confid) {
    set_has_confid();
    confid_ = confid;
  } else {
    clear_has_confid();
    confid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string confe164 = 2;
inline bool TMTVConfInfo::has_confe164() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVConfInfo::set_has_confe164() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVConfInfo::clear_has_confe164() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVConfInfo::clear_confe164() {
  if (confe164_ != &::google::protobuf::internal::kEmptyString) {
    confe164_->clear();
  }
  clear_has_confe164();
}
inline const ::std::string& TMTVConfInfo::confe164() const {
  return *confe164_;
}
inline void TMTVConfInfo::set_confe164(const ::std::string& value) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(value);
}
inline void TMTVConfInfo::set_confe164(const char* value) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(value);
}
inline void TMTVConfInfo::set_confe164(const char* value, size_t size) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfInfo::mutable_confe164() {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  return confe164_;
}
inline ::std::string* TMTVConfInfo::release_confe164() {
  clear_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confe164_;
    confe164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfInfo::set_allocated_confe164(::std::string* confe164) {
  if (confe164_ != &::google::protobuf::internal::kEmptyString) {
    delete confe164_;
  }
  if (confe164) {
    set_has_confe164();
    confe164_ = confe164;
  } else {
    clear_has_confe164();
    confe164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string virualroomname = 3;
inline bool TMTVConfInfo::has_virualroomname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVConfInfo::set_has_virualroomname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVConfInfo::clear_has_virualroomname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVConfInfo::clear_virualroomname() {
  if (virualroomname_ != &::google::protobuf::internal::kEmptyString) {
    virualroomname_->clear();
  }
  clear_has_virualroomname();
}
inline const ::std::string& TMTVConfInfo::virualroomname() const {
  return *virualroomname_;
}
inline void TMTVConfInfo::set_virualroomname(const ::std::string& value) {
  set_has_virualroomname();
  if (virualroomname_ == &::google::protobuf::internal::kEmptyString) {
    virualroomname_ = new ::std::string;
  }
  virualroomname_->assign(value);
}
inline void TMTVConfInfo::set_virualroomname(const char* value) {
  set_has_virualroomname();
  if (virualroomname_ == &::google::protobuf::internal::kEmptyString) {
    virualroomname_ = new ::std::string;
  }
  virualroomname_->assign(value);
}
inline void TMTVConfInfo::set_virualroomname(const char* value, size_t size) {
  set_has_virualroomname();
  if (virualroomname_ == &::google::protobuf::internal::kEmptyString) {
    virualroomname_ = new ::std::string;
  }
  virualroomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfInfo::mutable_virualroomname() {
  set_has_virualroomname();
  if (virualroomname_ == &::google::protobuf::internal::kEmptyString) {
    virualroomname_ = new ::std::string;
  }
  return virualroomname_;
}
inline ::std::string* TMTVConfInfo::release_virualroomname() {
  clear_has_virualroomname();
  if (virualroomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = virualroomname_;
    virualroomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfInfo::set_allocated_virualroomname(::std::string* virualroomname) {
  if (virualroomname_ != &::google::protobuf::internal::kEmptyString) {
    delete virualroomname_;
  }
  if (virualroomname) {
    set_has_virualroomname();
    virualroomname_ = virualroomname;
  } else {
    clear_has_virualroomname();
    virualroomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string confname = 4;
inline bool TMTVConfInfo::has_confname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTVConfInfo::set_has_confname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTVConfInfo::clear_has_confname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTVConfInfo::clear_confname() {
  if (confname_ != &::google::protobuf::internal::kEmptyString) {
    confname_->clear();
  }
  clear_has_confname();
}
inline const ::std::string& TMTVConfInfo::confname() const {
  return *confname_;
}
inline void TMTVConfInfo::set_confname(const ::std::string& value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
}
inline void TMTVConfInfo::set_confname(const char* value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
}
inline void TMTVConfInfo::set_confname(const char* value, size_t size) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfInfo::mutable_confname() {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  return confname_;
}
inline ::std::string* TMTVConfInfo::release_confname() {
  clear_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confname_;
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfInfo::set_allocated_confname(::std::string* confname) {
  if (confname_ != &::google::protobuf::internal::kEmptyString) {
    delete confname_;
  }
  if (confname) {
    set_has_confname();
    confname_ = confname;
  } else {
    clear_has_confname();
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtOpenMode safeconf = 5;
inline bool TMTVConfInfo::has_safeconf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTVConfInfo::set_has_safeconf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTVConfInfo::clear_has_safeconf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTVConfInfo::clear_safeconf() {
  safeconf_ = 1;
  clear_has_safeconf();
}
inline ::mt::EmMtOpenMode TMTVConfInfo::safeconf() const {
  return static_cast< ::mt::EmMtOpenMode >(safeconf_);
}
inline void TMTVConfInfo::set_safeconf(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_safeconf();
  safeconf_ = value;
}

// optional .mt.EmMtVConfStatus confstatus = 6;
inline bool TMTVConfInfo::has_confstatus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTVConfInfo::set_has_confstatus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTVConfInfo::clear_has_confstatus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTVConfInfo::clear_confstatus() {
  confstatus_ = 0;
  clear_has_confstatus();
}
inline ::mt::EmMtVConfStatus TMTVConfInfo::confstatus() const {
  return static_cast< ::mt::EmMtVConfStatus >(confstatus_);
}
inline void TMTVConfInfo::set_confstatus(::mt::EmMtVConfStatus value) {
  assert(::mt::EmMtVConfStatus_IsValid(value));
  set_has_confstatus();
  confstatus_ = value;
}

// optional .mt.EmMtMaxJoinMt maxjoinmt = 7;
inline bool TMTVConfInfo::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTVConfInfo::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTVConfInfo::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTVConfInfo::clear_maxjoinmt() {
  maxjoinmt_ = 0;
  clear_has_maxjoinmt();
}
inline ::mt::EmMtMaxJoinMt TMTVConfInfo::maxjoinmt() const {
  return static_cast< ::mt::EmMtMaxJoinMt >(maxjoinmt_);
}
inline void TMTVConfInfo::set_maxjoinmt(::mt::EmMtMaxJoinMt value) {
  assert(::mt::EmMtMaxJoinMt_IsValid(value));
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional string encryptedkey = 8;
inline bool TMTVConfInfo::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTVConfInfo::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTVConfInfo::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTVConfInfo::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTVConfInfo::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTVConfInfo::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTVConfInfo::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTVConfInfo::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfInfo::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTVConfInfo::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfInfo::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 bitrate = 9;
inline bool TMTVConfInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTVConfInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTVConfInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTVConfInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTVConfInfo::bitrate() const {
  return bitrate_;
}
inline void TMTVConfInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional bool exclusive = 10;
inline bool TMTVConfInfo::has_exclusive() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTVConfInfo::set_has_exclusive() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTVConfInfo::clear_has_exclusive() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTVConfInfo::clear_exclusive() {
  exclusive_ = false;
  clear_has_exclusive();
}
inline bool TMTVConfInfo::exclusive() const {
  return exclusive_;
}
inline void TMTVConfInfo::set_exclusive(bool value) {
  set_has_exclusive();
  exclusive_ = value;
}

// repeated .mt.TMTVConfMember exuser = 11;
inline int TMTVConfInfo::exuser_size() const {
  return exuser_.size();
}
inline void TMTVConfInfo::clear_exuser() {
  exuser_.Clear();
}
inline const ::mt::TMTVConfMember& TMTVConfInfo::exuser(int index) const {
  return exuser_.Get(index);
}
inline ::mt::TMTVConfMember* TMTVConfInfo::mutable_exuser(int index) {
  return exuser_.Mutable(index);
}
inline ::mt::TMTVConfMember* TMTVConfInfo::add_exuser() {
  return exuser_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >&
TMTVConfInfo::exuser() const {
  return exuser_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >*
TMTVConfInfo::mutable_exuser() {
  return &exuser_;
}

// optional .mt.EmMtResolution resolution = 12;
inline bool TMTVConfInfo::has_resolution() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTVConfInfo::set_has_resolution() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTVConfInfo::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTVConfInfo::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::mt::EmMtResolution TMTVConfInfo::resolution() const {
  return static_cast< ::mt::EmMtResolution >(resolution_);
}
inline void TMTVConfInfo::set_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_resolution();
  resolution_ = value;
}

// -------------------------------------------------------------------

// TMTVConfList

// repeated .mt.TMTVConfInfo confinfo = 1;
inline int TMTVConfList::confinfo_size() const {
  return confinfo_.size();
}
inline void TMTVConfList::clear_confinfo() {
  confinfo_.Clear();
}
inline const ::mt::TMTVConfInfo& TMTVConfList::confinfo(int index) const {
  return confinfo_.Get(index);
}
inline ::mt::TMTVConfInfo* TMTVConfList::mutable_confinfo(int index) {
  return confinfo_.Mutable(index);
}
inline ::mt::TMTVConfInfo* TMTVConfList::add_confinfo() {
  return confinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfInfo >&
TMTVConfList::confinfo() const {
  return confinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfInfo >*
TMTVConfList::mutable_confinfo() {
  return &confinfo_;
}

// -------------------------------------------------------------------

// TMTVConfResource

// optional string name = 1;
inline bool TMTVConfResource::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVConfResource::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVConfResource::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVConfResource::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTVConfResource::name() const {
  return *name_;
}
inline void TMTVConfResource::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTVConfResource::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTVConfResource::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfResource::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTVConfResource::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfResource::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 total = 2;
inline bool TMTVConfResource::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVConfResource::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVConfResource::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVConfResource::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 TMTVConfResource::total() const {
  return total_;
}
inline void TMTVConfResource::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional uint32 used = 3;
inline bool TMTVConfResource::has_used() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVConfResource::set_has_used() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVConfResource::clear_has_used() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVConfResource::clear_used() {
  used_ = 0u;
  clear_has_used();
}
inline ::google::protobuf::uint32 TMTVConfResource::used() const {
  return used_;
}
inline void TMTVConfResource::set_used(::google::protobuf::uint32 value) {
  set_has_used();
  used_ = value;
}

// optional .mt.EmMtResolution resolution = 4;
inline bool TMTVConfResource::has_resolution() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTVConfResource::set_has_resolution() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTVConfResource::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTVConfResource::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::mt::EmMtResolution TMTVConfResource::resolution() const {
  return static_cast< ::mt::EmMtResolution >(resolution_);
}
inline void TMTVConfResource::set_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_resolution();
  resolution_ = value;
}

// optional .mt.EmMtMaxJoinMt maxjoinmt = 5;
inline bool TMTVConfResource::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTVConfResource::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTVConfResource::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTVConfResource::clear_maxjoinmt() {
  maxjoinmt_ = 0;
  clear_has_maxjoinmt();
}
inline ::mt::EmMtMaxJoinMt TMTVConfResource::maxjoinmt() const {
  return static_cast< ::mt::EmMtMaxJoinMt >(maxjoinmt_);
}
inline void TMTVConfResource::set_maxjoinmt(::mt::EmMtMaxJoinMt value) {
  assert(::mt::EmMtMaxJoinMt_IsValid(value));
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// -------------------------------------------------------------------

// TMTVConfResources

// repeated .mt.TMTVConfResource resource = 1;
inline int TMTVConfResources::resource_size() const {
  return resource_.size();
}
inline void TMTVConfResources::clear_resource() {
  resource_.Clear();
}
inline const ::mt::TMTVConfResource& TMTVConfResources::resource(int index) const {
  return resource_.Get(index);
}
inline ::mt::TMTVConfResource* TMTVConfResources::mutable_resource(int index) {
  return resource_.Mutable(index);
}
inline ::mt::TMTVConfResource* TMTVConfResources::add_resource() {
  return resource_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfResource >&
TMTVConfResources::resource() const {
  return resource_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfResource >*
TMTVConfResources::mutable_resource() {
  return &resource_;
}

// optional .mt.EmResourceType resourcetype = 2;
inline bool TMTVConfResources::has_resourcetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVConfResources::set_has_resourcetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVConfResources::clear_has_resourcetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVConfResources::clear_resourcetype() {
  resourcetype_ = 0;
  clear_has_resourcetype();
}
inline ::mt::EmResourceType TMTVConfResources::resourcetype() const {
  return static_cast< ::mt::EmResourceType >(resourcetype_);
}
inline void TMTVConfResources::set_resourcetype(::mt::EmResourceType value) {
  assert(::mt::EmResourceType_IsValid(value));
  set_has_resourcetype();
  resourcetype_ = value;
}

// -------------------------------------------------------------------

// TMTVConfRecord

// optional .mt.EmPublishMode publishmode = 1;
inline bool TMTVConfRecord::has_publishmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVConfRecord::set_has_publishmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVConfRecord::clear_has_publishmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVConfRecord::clear_publishmode() {
  publishmode_ = 0;
  clear_has_publishmode();
}
inline ::mt::EmPublishMode TMTVConfRecord::publishmode() const {
  return static_cast< ::mt::EmPublishMode >(publishmode_);
}
inline void TMTVConfRecord::set_publishmode(::mt::EmPublishMode value) {
  assert(::mt::EmPublishMode_IsValid(value));
  set_has_publishmode();
  publishmode_ = value;
}

// optional .mt.EmRecordMode recordmode = 2;
inline bool TMTVConfRecord::has_recordmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVConfRecord::set_has_recordmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVConfRecord::clear_has_recordmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVConfRecord::clear_recordmode() {
  recordmode_ = 0;
  clear_has_recordmode();
}
inline ::mt::EmRecordMode TMTVConfRecord::recordmode() const {
  return static_cast< ::mt::EmRecordMode >(recordmode_);
}
inline void TMTVConfRecord::set_recordmode(::mt::EmRecordMode value) {
  assert(::mt::EmRecordMode_IsValid(value));
  set_has_recordmode();
  recordmode_ = value;
}

// optional bool doubleflow = 3;
inline bool TMTVConfRecord::has_doubleflow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVConfRecord::set_has_doubleflow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVConfRecord::clear_has_doubleflow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVConfRecord::clear_doubleflow() {
  doubleflow_ = false;
  clear_has_doubleflow();
}
inline bool TMTVConfRecord::doubleflow() const {
  return doubleflow_;
}
inline void TMTVConfRecord::set_doubleflow(bool value) {
  set_has_doubleflow();
  doubleflow_ = value;
}

// optional bool anonymous = 4;
inline bool TMTVConfRecord::has_anonymous() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTVConfRecord::set_has_anonymous() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTVConfRecord::clear_has_anonymous() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTVConfRecord::clear_anonymous() {
  anonymous_ = false;
  clear_has_anonymous();
}
inline bool TMTVConfRecord::anonymous() const {
  return anonymous_;
}
inline void TMTVConfRecord::set_anonymous(bool value) {
  set_has_anonymous();
  anonymous_ = value;
}

// optional string vrsid = 5;
inline bool TMTVConfRecord::has_vrsid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTVConfRecord::set_has_vrsid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTVConfRecord::clear_has_vrsid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTVConfRecord::clear_vrsid() {
  if (vrsid_ != &::google::protobuf::internal::kEmptyString) {
    vrsid_->clear();
  }
  clear_has_vrsid();
}
inline const ::std::string& TMTVConfRecord::vrsid() const {
  return *vrsid_;
}
inline void TMTVConfRecord::set_vrsid(const ::std::string& value) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(value);
}
inline void TMTVConfRecord::set_vrsid(const char* value) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(value);
}
inline void TMTVConfRecord::set_vrsid(const char* value, size_t size) {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  vrsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfRecord::mutable_vrsid() {
  set_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    vrsid_ = new ::std::string;
  }
  return vrsid_;
}
inline ::std::string* TMTVConfRecord::release_vrsid() {
  clear_has_vrsid();
  if (vrsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vrsid_;
    vrsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfRecord::set_allocated_vrsid(::std::string* vrsid) {
  if (vrsid_ != &::google::protobuf::internal::kEmptyString) {
    delete vrsid_;
  }
  if (vrsid) {
    set_has_vrsid();
    vrsid_ = vrsid;
  } else {
    clear_has_vrsid();
    vrsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTVConfDetailInfo

// optional string virtualroomname = 1;
inline bool TMTVConfDetailInfo::has_virtualroomname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVConfDetailInfo::set_has_virtualroomname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVConfDetailInfo::clear_has_virtualroomname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVConfDetailInfo::clear_virtualroomname() {
  if (virtualroomname_ != &::google::protobuf::internal::kEmptyString) {
    virtualroomname_->clear();
  }
  clear_has_virtualroomname();
}
inline const ::std::string& TMTVConfDetailInfo::virtualroomname() const {
  return *virtualroomname_;
}
inline void TMTVConfDetailInfo::set_virtualroomname(const ::std::string& value) {
  set_has_virtualroomname();
  if (virtualroomname_ == &::google::protobuf::internal::kEmptyString) {
    virtualroomname_ = new ::std::string;
  }
  virtualroomname_->assign(value);
}
inline void TMTVConfDetailInfo::set_virtualroomname(const char* value) {
  set_has_virtualroomname();
  if (virtualroomname_ == &::google::protobuf::internal::kEmptyString) {
    virtualroomname_ = new ::std::string;
  }
  virtualroomname_->assign(value);
}
inline void TMTVConfDetailInfo::set_virtualroomname(const char* value, size_t size) {
  set_has_virtualroomname();
  if (virtualroomname_ == &::google::protobuf::internal::kEmptyString) {
    virtualroomname_ = new ::std::string;
  }
  virtualroomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfDetailInfo::mutable_virtualroomname() {
  set_has_virtualroomname();
  if (virtualroomname_ == &::google::protobuf::internal::kEmptyString) {
    virtualroomname_ = new ::std::string;
  }
  return virtualroomname_;
}
inline ::std::string* TMTVConfDetailInfo::release_virtualroomname() {
  clear_has_virtualroomname();
  if (virtualroomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = virtualroomname_;
    virtualroomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfDetailInfo::set_allocated_virtualroomname(::std::string* virtualroomname) {
  if (virtualroomname_ != &::google::protobuf::internal::kEmptyString) {
    delete virtualroomname_;
  }
  if (virtualroomname) {
    set_has_virtualroomname();
    virtualroomname_ = virtualroomname;
  } else {
    clear_has_virtualroomname();
    virtualroomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string confe164 = 2;
inline bool TMTVConfDetailInfo::has_confe164() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVConfDetailInfo::set_has_confe164() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVConfDetailInfo::clear_has_confe164() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVConfDetailInfo::clear_confe164() {
  if (confe164_ != &::google::protobuf::internal::kEmptyString) {
    confe164_->clear();
  }
  clear_has_confe164();
}
inline const ::std::string& TMTVConfDetailInfo::confe164() const {
  return *confe164_;
}
inline void TMTVConfDetailInfo::set_confe164(const ::std::string& value) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(value);
}
inline void TMTVConfDetailInfo::set_confe164(const char* value) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(value);
}
inline void TMTVConfDetailInfo::set_confe164(const char* value, size_t size) {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  confe164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfDetailInfo::mutable_confe164() {
  set_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    confe164_ = new ::std::string;
  }
  return confe164_;
}
inline ::std::string* TMTVConfDetailInfo::release_confe164() {
  clear_has_confe164();
  if (confe164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confe164_;
    confe164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfDetailInfo::set_allocated_confe164(::std::string* confe164) {
  if (confe164_ != &::google::protobuf::internal::kEmptyString) {
    delete confe164_;
  }
  if (confe164) {
    set_has_confe164();
    confe164_ = confe164;
  } else {
    clear_has_confe164();
    confe164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 3;
inline bool TMTVConfDetailInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVConfDetailInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVConfDetailInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVConfDetailInfo::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMTVConfDetailInfo::duration() const {
  return duration_;
}
inline void TMTVConfDetailInfo::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 bitrate = 4;
inline bool TMTVConfDetailInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTVConfDetailInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTVConfDetailInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTVConfDetailInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMTVConfDetailInfo::bitrate() const {
  return bitrate_;
}
inline void TMTVConfDetailInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// repeated .mt.TMTVideoFormatList videoformatlist = 5;
inline int TMTVConfDetailInfo::videoformatlist_size() const {
  return videoformatlist_.size();
}
inline void TMTVConfDetailInfo::clear_videoformatlist() {
  videoformatlist_.Clear();
}
inline const ::mt::TMTVideoFormatList& TMTVConfDetailInfo::videoformatlist(int index) const {
  return videoformatlist_.Get(index);
}
inline ::mt::TMTVideoFormatList* TMTVConfDetailInfo::mutable_videoformatlist(int index) {
  return videoformatlist_.Mutable(index);
}
inline ::mt::TMTVideoFormatList* TMTVConfDetailInfo::add_videoformatlist() {
  return videoformatlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >&
TMTVConfDetailInfo::videoformatlist() const {
  return videoformatlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoFormatList >*
TMTVConfDetailInfo::mutable_videoformatlist() {
  return &videoformatlist_;
}

// optional string confname = 6;
inline bool TMTVConfDetailInfo::has_confname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTVConfDetailInfo::set_has_confname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTVConfDetailInfo::clear_has_confname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTVConfDetailInfo::clear_confname() {
  if (confname_ != &::google::protobuf::internal::kEmptyString) {
    confname_->clear();
  }
  clear_has_confname();
}
inline const ::std::string& TMTVConfDetailInfo::confname() const {
  return *confname_;
}
inline void TMTVConfDetailInfo::set_confname(const ::std::string& value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
}
inline void TMTVConfDetailInfo::set_confname(const char* value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
}
inline void TMTVConfDetailInfo::set_confname(const char* value, size_t size) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfDetailInfo::mutable_confname() {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  return confname_;
}
inline ::std::string* TMTVConfDetailInfo::release_confname() {
  clear_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confname_;
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfDetailInfo::set_allocated_confname(::std::string* confname) {
  if (confname_ != &::google::protobuf::internal::kEmptyString) {
    delete confname_;
  }
  if (confname) {
    set_has_confname();
    confname_ = confname;
  } else {
    clear_has_confname();
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmRestMeetingSafeType meetingtype = 7;
inline bool TMTVConfDetailInfo::has_meetingtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTVConfDetailInfo::set_has_meetingtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTVConfDetailInfo::clear_has_meetingtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTVConfDetailInfo::clear_meetingtype() {
  meetingtype_ = 0;
  clear_has_meetingtype();
}
inline ::mt::EmRestMeetingSafeType TMTVConfDetailInfo::meetingtype() const {
  return static_cast< ::mt::EmRestMeetingSafeType >(meetingtype_);
}
inline void TMTVConfDetailInfo::set_meetingtype(::mt::EmRestMeetingSafeType value) {
  assert(::mt::EmRestMeetingSafeType_IsValid(value));
  set_has_meetingtype();
  meetingtype_ = value;
}

// optional .mt.EmMtOpenMode meetingsafe = 8;
inline bool TMTVConfDetailInfo::has_meetingsafe() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTVConfDetailInfo::set_has_meetingsafe() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTVConfDetailInfo::clear_has_meetingsafe() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTVConfDetailInfo::clear_meetingsafe() {
  meetingsafe_ = 1;
  clear_has_meetingsafe();
}
inline ::mt::EmMtOpenMode TMTVConfDetailInfo::meetingsafe() const {
  return static_cast< ::mt::EmMtOpenMode >(meetingsafe_);
}
inline void TMTVConfDetailInfo::set_meetingsafe(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_meetingsafe();
  meetingsafe_ = value;
}

// optional .mt.EmMtVConfStatus confstatus = 9;
inline bool TMTVConfDetailInfo::has_confstatus() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTVConfDetailInfo::set_has_confstatus() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTVConfDetailInfo::clear_has_confstatus() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTVConfDetailInfo::clear_confstatus() {
  confstatus_ = 0;
  clear_has_confstatus();
}
inline ::mt::EmMtVConfStatus TMTVConfDetailInfo::confstatus() const {
  return static_cast< ::mt::EmMtVConfStatus >(confstatus_);
}
inline void TMTVConfDetailInfo::set_confstatus(::mt::EmMtVConfStatus value) {
  assert(::mt::EmMtVConfStatus_IsValid(value));
  set_has_confstatus();
  confstatus_ = value;
}

// optional .mt.EmMtMaxJoinMt maxjoinmt = 10;
inline bool TMTVConfDetailInfo::has_maxjoinmt() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTVConfDetailInfo::set_has_maxjoinmt() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTVConfDetailInfo::clear_has_maxjoinmt() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTVConfDetailInfo::clear_maxjoinmt() {
  maxjoinmt_ = 0;
  clear_has_maxjoinmt();
}
inline ::mt::EmMtMaxJoinMt TMTVConfDetailInfo::maxjoinmt() const {
  return static_cast< ::mt::EmMtMaxJoinMt >(maxjoinmt_);
}
inline void TMTVConfDetailInfo::set_maxjoinmt(::mt::EmMtMaxJoinMt value) {
  assert(::mt::EmMtMaxJoinMt_IsValid(value));
  set_has_maxjoinmt();
  maxjoinmt_ = value;
}

// optional .mt.EmRestCascadeMode cascademode = 11;
inline bool TMTVConfDetailInfo::has_cascademode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTVConfDetailInfo::set_has_cascademode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTVConfDetailInfo::clear_has_cascademode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTVConfDetailInfo::clear_cascademode() {
  cascademode_ = 0;
  clear_has_cascademode();
}
inline ::mt::EmRestCascadeMode TMTVConfDetailInfo::cascademode() const {
  return static_cast< ::mt::EmRestCascadeMode >(cascademode_);
}
inline void TMTVConfDetailInfo::set_cascademode(::mt::EmRestCascadeMode value) {
  assert(::mt::EmRestCascadeMode_IsValid(value));
  set_has_cascademode();
  cascademode_ = value;
}

// optional bool cascadeupload = 12;
inline bool TMTVConfDetailInfo::has_cascadeupload() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTVConfDetailInfo::set_has_cascadeupload() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTVConfDetailInfo::clear_has_cascadeupload() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTVConfDetailInfo::clear_cascadeupload() {
  cascadeupload_ = false;
  clear_has_cascadeupload();
}
inline bool TMTVConfDetailInfo::cascadeupload() const {
  return cascadeupload_;
}
inline void TMTVConfDetailInfo::set_cascadeupload(bool value) {
  set_has_cascadeupload();
  cascadeupload_ = value;
}

// optional bool cascadereturn = 13;
inline bool TMTVConfDetailInfo::has_cascadereturn() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_cascadereturn() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTVConfDetailInfo::clear_has_cascadereturn() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTVConfDetailInfo::clear_cascadereturn() {
  cascadereturn_ = false;
  clear_has_cascadereturn();
}
inline bool TMTVConfDetailInfo::cascadereturn() const {
  return cascadereturn_;
}
inline void TMTVConfDetailInfo::set_cascadereturn(bool value) {
  set_has_cascadereturn();
  cascadereturn_ = value;
}

// optional uint32 cascadereturnpara = 14;
inline bool TMTVConfDetailInfo::has_cascadereturnpara() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_cascadereturnpara() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTVConfDetailInfo::clear_has_cascadereturnpara() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTVConfDetailInfo::clear_cascadereturnpara() {
  cascadereturnpara_ = 0u;
  clear_has_cascadereturnpara();
}
inline ::google::protobuf::uint32 TMTVConfDetailInfo::cascadereturnpara() const {
  return cascadereturnpara_;
}
inline void TMTVConfDetailInfo::set_cascadereturnpara(::google::protobuf::uint32 value) {
  set_has_cascadereturnpara();
  cascadereturnpara_ = value;
}

// optional bool initmute = 15;
inline bool TMTVConfDetailInfo::has_initmute() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_initmute() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTVConfDetailInfo::clear_has_initmute() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTVConfDetailInfo::clear_initmute() {
  initmute_ = false;
  clear_has_initmute();
}
inline bool TMTVConfDetailInfo::initmute() const {
  return initmute_;
}
inline void TMTVConfDetailInfo::set_initmute(bool value) {
  set_has_initmute();
  initmute_ = value;
}

// optional bool mutefilter = 16;
inline bool TMTVConfDetailInfo::has_mutefilter() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_mutefilter() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTVConfDetailInfo::clear_has_mutefilter() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTVConfDetailInfo::clear_mutefilter() {
  mutefilter_ = false;
  clear_has_mutefilter();
}
inline bool TMTVConfDetailInfo::mutefilter() const {
  return mutefilter_;
}
inline void TMTVConfDetailInfo::set_mutefilter(bool value) {
  set_has_mutefilter();
  mutefilter_ = value;
}

// optional .mt.TMTGetMixInfo mixinfo = 17;
inline bool TMTVConfDetailInfo::has_mixinfo() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_mixinfo() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTVConfDetailInfo::clear_has_mixinfo() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTVConfDetailInfo::clear_mixinfo() {
  if (mixinfo_ != NULL) mixinfo_->::mt::TMTGetMixInfo::Clear();
  clear_has_mixinfo();
}
inline const ::mt::TMTGetMixInfo& TMTVConfDetailInfo::mixinfo() const {
  return mixinfo_ != NULL ? *mixinfo_ : *default_instance_->mixinfo_;
}
inline ::mt::TMTGetMixInfo* TMTVConfDetailInfo::mutable_mixinfo() {
  set_has_mixinfo();
  if (mixinfo_ == NULL) mixinfo_ = new ::mt::TMTGetMixInfo;
  return mixinfo_;
}
inline ::mt::TMTGetMixInfo* TMTVConfDetailInfo::release_mixinfo() {
  clear_has_mixinfo();
  ::mt::TMTGetMixInfo* temp = mixinfo_;
  mixinfo_ = NULL;
  return temp;
}
inline void TMTVConfDetailInfo::set_allocated_mixinfo(::mt::TMTGetMixInfo* mixinfo) {
  delete mixinfo_;
  mixinfo_ = mixinfo;
  if (mixinfo) {
    set_has_mixinfo();
  } else {
    clear_has_mixinfo();
  }
}

// optional .mt.EmVmpMode vmp = 18;
inline bool TMTVConfDetailInfo::has_vmp() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_vmp() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTVConfDetailInfo::clear_has_vmp() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTVConfDetailInfo::clear_vmp() {
  vmp_ = 0;
  clear_has_vmp();
}
inline ::mt::EmVmpMode TMTVConfDetailInfo::vmp() const {
  return static_cast< ::mt::EmVmpMode >(vmp_);
}
inline void TMTVConfDetailInfo::set_vmp(::mt::EmVmpMode value) {
  assert(::mt::EmVmpMode_IsValid(value));
  set_has_vmp();
  vmp_ = value;
}

// optional .mt.TMTVConfRecord record = 19;
inline bool TMTVConfDetailInfo::has_record() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_record() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTVConfDetailInfo::clear_has_record() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTVConfDetailInfo::clear_record() {
  if (record_ != NULL) record_->::mt::TMTVConfRecord::Clear();
  clear_has_record();
}
inline const ::mt::TMTVConfRecord& TMTVConfDetailInfo::record() const {
  return record_ != NULL ? *record_ : *default_instance_->record_;
}
inline ::mt::TMTVConfRecord* TMTVConfDetailInfo::mutable_record() {
  set_has_record();
  if (record_ == NULL) record_ = new ::mt::TMTVConfRecord;
  return record_;
}
inline ::mt::TMTVConfRecord* TMTVConfDetailInfo::release_record() {
  clear_has_record();
  ::mt::TMTVConfRecord* temp = record_;
  record_ = NULL;
  return temp;
}
inline void TMTVConfDetailInfo::set_allocated_record(::mt::TMTVConfRecord* record) {
  delete record_;
  record_ = record;
  if (record) {
    set_has_record();
  } else {
    clear_has_record();
  }
}

// optional bool preoccpuyresource = 20;
inline bool TMTVConfDetailInfo::has_preoccpuyresource() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_preoccpuyresource() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTVConfDetailInfo::clear_has_preoccpuyresource() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTVConfDetailInfo::clear_preoccpuyresource() {
  preoccpuyresource_ = false;
  clear_has_preoccpuyresource();
}
inline bool TMTVConfDetailInfo::preoccpuyresource() const {
  return preoccpuyresource_;
}
inline void TMTVConfDetailInfo::set_preoccpuyresource(bool value) {
  set_has_preoccpuyresource();
  preoccpuyresource_ = value;
}

// optional .mt.EmEncryptArithmetic encryptedtype = 21;
inline bool TMTVConfDetailInfo::has_encryptedtype() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_encryptedtype() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTVConfDetailInfo::clear_has_encryptedtype() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTVConfDetailInfo::clear_encryptedtype() {
  encryptedtype_ = 0;
  clear_has_encryptedtype();
}
inline ::mt::EmEncryptArithmetic TMTVConfDetailInfo::encryptedtype() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encryptedtype_);
}
inline void TMTVConfDetailInfo::set_encryptedtype(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encryptedtype();
  encryptedtype_ = value;
}

// optional string encryptedkey = 22;
inline bool TMTVConfDetailInfo::has_encryptedkey() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_encryptedkey() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTVConfDetailInfo::clear_has_encryptedkey() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTVConfDetailInfo::clear_encryptedkey() {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedkey_->clear();
  }
  clear_has_encryptedkey();
}
inline const ::std::string& TMTVConfDetailInfo::encryptedkey() const {
  return *encryptedkey_;
}
inline void TMTVConfDetailInfo::set_encryptedkey(const ::std::string& value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTVConfDetailInfo::set_encryptedkey(const char* value) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(value);
}
inline void TMTVConfDetailInfo::set_encryptedkey(const char* value, size_t size) {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  encryptedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVConfDetailInfo::mutable_encryptedkey() {
  set_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedkey_ = new ::std::string;
  }
  return encryptedkey_;
}
inline ::std::string* TMTVConfDetailInfo::release_encryptedkey() {
  clear_has_encryptedkey();
  if (encryptedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedkey_;
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVConfDetailInfo::set_allocated_encryptedkey(::std::string* encryptedkey) {
  if (encryptedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedkey_;
  }
  if (encryptedkey) {
    set_has_encryptedkey();
    encryptedkey_ = encryptedkey;
  } else {
    clear_has_encryptedkey();
    encryptedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtDualMode dualmode = 23;
inline bool TMTVConfDetailInfo::has_dualmode() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_dualmode() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTVConfDetailInfo::clear_has_dualmode() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTVConfDetailInfo::clear_dualmode() {
  dualmode_ = 0;
  clear_has_dualmode();
}
inline ::mt::EmMtDualMode TMTVConfDetailInfo::dualmode() const {
  return static_cast< ::mt::EmMtDualMode >(dualmode_);
}
inline void TMTVConfDetailInfo::set_dualmode(::mt::EmMtDualMode value) {
  assert(::mt::EmMtDualMode_IsValid(value));
  set_has_dualmode();
  dualmode_ = value;
}

// optional .mt.EmAnswerMode answermode = 24;
inline bool TMTVConfDetailInfo::has_answermode() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_answermode() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTVConfDetailInfo::clear_has_answermode() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTVConfDetailInfo::clear_answermode() {
  answermode_ = 0;
  clear_has_answermode();
}
inline ::mt::EmAnswerMode TMTVConfDetailInfo::answermode() const {
  return static_cast< ::mt::EmAnswerMode >(answermode_);
}
inline void TMTVConfDetailInfo::set_answermode(::mt::EmAnswerMode value) {
  assert(::mt::EmAnswerMode_IsValid(value));
  set_has_answermode();
  answermode_ = value;
}

// optional uint32 calltimes = 25;
inline bool TMTVConfDetailInfo::has_calltimes() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_calltimes() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTVConfDetailInfo::clear_has_calltimes() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTVConfDetailInfo::clear_calltimes() {
  calltimes_ = 0u;
  clear_has_calltimes();
}
inline ::google::protobuf::uint32 TMTVConfDetailInfo::calltimes() const {
  return calltimes_;
}
inline void TMTVConfDetailInfo::set_calltimes(::google::protobuf::uint32 value) {
  set_has_calltimes();
  calltimes_ = value;
}

// optional uint32 callinterval = 26;
inline bool TMTVConfDetailInfo::has_callinterval() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_callinterval() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMTVConfDetailInfo::clear_has_callinterval() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMTVConfDetailInfo::clear_callinterval() {
  callinterval_ = 0u;
  clear_has_callinterval();
}
inline ::google::protobuf::uint32 TMTVConfDetailInfo::callinterval() const {
  return callinterval_;
}
inline void TMTVConfDetailInfo::set_callinterval(::google::protobuf::uint32 value) {
  set_has_callinterval();
  callinterval_ = value;
}

// optional bool voiceinspireenable = 27;
inline bool TMTVConfDetailInfo::has_voiceinspireenable() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_voiceinspireenable() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMTVConfDetailInfo::clear_has_voiceinspireenable() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMTVConfDetailInfo::clear_voiceinspireenable() {
  voiceinspireenable_ = false;
  clear_has_voiceinspireenable();
}
inline bool TMTVConfDetailInfo::voiceinspireenable() const {
  return voiceinspireenable_;
}
inline void TMTVConfDetailInfo::set_voiceinspireenable(bool value) {
  set_has_voiceinspireenable();
  voiceinspireenable_ = value;
}

// optional uint32 onereforming = 28;
inline bool TMTVConfDetailInfo::has_onereforming() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_onereforming() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMTVConfDetailInfo::clear_has_onereforming() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMTVConfDetailInfo::clear_onereforming() {
  onereforming_ = 0u;
  clear_has_onereforming();
}
inline ::google::protobuf::uint32 TMTVConfDetailInfo::onereforming() const {
  return onereforming_;
}
inline void TMTVConfDetailInfo::set_onereforming(::google::protobuf::uint32 value) {
  set_has_onereforming();
  onereforming_ = value;
}

// optional .mt.EmMtFecMode fecmode = 29;
inline bool TMTVConfDetailInfo::has_fecmode() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_fecmode() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMTVConfDetailInfo::clear_has_fecmode() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMTVConfDetailInfo::clear_fecmode() {
  fecmode_ = 0;
  clear_has_fecmode();
}
inline ::mt::EmMtFecMode TMTVConfDetailInfo::fecmode() const {
  return static_cast< ::mt::EmMtFecMode >(fecmode_);
}
inline void TMTVConfDetailInfo::set_fecmode(::mt::EmMtFecMode value) {
  assert(::mt::EmMtFecMode_IsValid(value));
  set_has_fecmode();
  fecmode_ = value;
}

// optional bool exclusive = 30;
inline bool TMTVConfDetailInfo::has_exclusive() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMTVConfDetailInfo::set_has_exclusive() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMTVConfDetailInfo::clear_has_exclusive() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMTVConfDetailInfo::clear_exclusive() {
  exclusive_ = false;
  clear_has_exclusive();
}
inline bool TMTVConfDetailInfo::exclusive() const {
  return exclusive_;
}
inline void TMTVConfDetailInfo::set_exclusive(bool value) {
  set_has_exclusive();
  exclusive_ = value;
}

// repeated .mt.TMTVConfMember exuser = 31;
inline int TMTVConfDetailInfo::exuser_size() const {
  return exuser_.size();
}
inline void TMTVConfDetailInfo::clear_exuser() {
  exuser_.Clear();
}
inline const ::mt::TMTVConfMember& TMTVConfDetailInfo::exuser(int index) const {
  return exuser_.Get(index);
}
inline ::mt::TMTVConfMember* TMTVConfDetailInfo::mutable_exuser(int index) {
  return exuser_.Mutable(index);
}
inline ::mt::TMTVConfMember* TMTVConfDetailInfo::add_exuser() {
  return exuser_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >&
TMTVConfDetailInfo::exuser() const {
  return exuser_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVConfMember >*
TMTVConfDetailInfo::mutable_exuser() {
  return &exuser_;
}

// -------------------------------------------------------------------

// TMTVMtNameStyle

// optional uint32 font_size = 1;
inline bool TMTVMtNameStyle::has_font_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVMtNameStyle::set_has_font_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVMtNameStyle::clear_has_font_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVMtNameStyle::clear_font_size() {
  font_size_ = 0u;
  clear_has_font_size();
}
inline ::google::protobuf::uint32 TMTVMtNameStyle::font_size() const {
  return font_size_;
}
inline void TMTVMtNameStyle::set_font_size(::google::protobuf::uint32 value) {
  set_has_font_size();
  font_size_ = value;
}

// optional uint32 position = 2;
inline bool TMTVMtNameStyle::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVMtNameStyle::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVMtNameStyle::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVMtNameStyle::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 TMTVMtNameStyle::position() const {
  return position_;
}
inline void TMTVMtNameStyle::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
}

// optional string font_color = 3;
inline bool TMTVMtNameStyle::has_font_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVMtNameStyle::set_has_font_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVMtNameStyle::clear_has_font_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVMtNameStyle::clear_font_color() {
  if (font_color_ != &::google::protobuf::internal::kEmptyString) {
    font_color_->clear();
  }
  clear_has_font_color();
}
inline const ::std::string& TMTVMtNameStyle::font_color() const {
  return *font_color_;
}
inline void TMTVMtNameStyle::set_font_color(const ::std::string& value) {
  set_has_font_color();
  if (font_color_ == &::google::protobuf::internal::kEmptyString) {
    font_color_ = new ::std::string;
  }
  font_color_->assign(value);
}
inline void TMTVMtNameStyle::set_font_color(const char* value) {
  set_has_font_color();
  if (font_color_ == &::google::protobuf::internal::kEmptyString) {
    font_color_ = new ::std::string;
  }
  font_color_->assign(value);
}
inline void TMTVMtNameStyle::set_font_color(const char* value, size_t size) {
  set_has_font_color();
  if (font_color_ == &::google::protobuf::internal::kEmptyString) {
    font_color_ = new ::std::string;
  }
  font_color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVMtNameStyle::mutable_font_color() {
  set_has_font_color();
  if (font_color_ == &::google::protobuf::internal::kEmptyString) {
    font_color_ = new ::std::string;
  }
  return font_color_;
}
inline ::std::string* TMTVMtNameStyle::release_font_color() {
  clear_has_font_color();
  if (font_color_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = font_color_;
    font_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVMtNameStyle::set_allocated_font_color(::std::string* font_color) {
  if (font_color_ != &::google::protobuf::internal::kEmptyString) {
    delete font_color_;
  }
  if (font_color) {
    set_has_font_color();
    font_color_ = font_color;
  } else {
    clear_has_font_color();
    font_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTContentLiveURL

// optional uint32 id = 1;
inline bool TMTContentLiveURL::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTContentLiveURL::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTContentLiveURL::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTContentLiveURL::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TMTContentLiveURL::id() const {
  return id_;
}
inline void TMTContentLiveURL::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string subject = 2;
inline bool TMTContentLiveURL::has_subject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTContentLiveURL::set_has_subject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTContentLiveURL::clear_has_subject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTContentLiveURL::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& TMTContentLiveURL::subject() const {
  return *subject_;
}
inline void TMTContentLiveURL::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentLiveURL::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void TMTContentLiveURL::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentLiveURL::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* TMTContentLiveURL::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentLiveURL::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string starttime = 3;
inline bool TMTContentLiveURL::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTContentLiveURL::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTContentLiveURL::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTContentLiveURL::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TMTContentLiveURL::starttime() const {
  return *starttime_;
}
inline void TMTContentLiveURL::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentLiveURL::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TMTContentLiveURL::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentLiveURL::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TMTContentLiveURL::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentLiveURL::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 4;
inline bool TMTContentLiveURL::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTContentLiveURL::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTContentLiveURL::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTContentLiveURL::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& TMTContentLiveURL::endtime() const {
  return *endtime_;
}
inline void TMTContentLiveURL::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentLiveURL::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void TMTContentLiveURL::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentLiveURL::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* TMTContentLiveURL::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentLiveURL::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isvideomeeting = 5;
inline bool TMTContentLiveURL::has_isvideomeeting() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTContentLiveURL::set_has_isvideomeeting() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTContentLiveURL::clear_has_isvideomeeting() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTContentLiveURL::clear_isvideomeeting() {
  isvideomeeting_ = false;
  clear_has_isvideomeeting();
}
inline bool TMTContentLiveURL::isvideomeeting() const {
  return isvideomeeting_;
}
inline void TMTContentLiveURL::set_isvideomeeting(bool value) {
  set_has_isvideomeeting();
  isvideomeeting_ = value;
}

// optional string phone = 6;
inline bool TMTContentLiveURL::has_phone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTContentLiveURL::set_has_phone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTContentLiveURL::clear_has_phone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTContentLiveURL::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& TMTContentLiveURL::phone() const {
  return *phone_;
}
inline void TMTContentLiveURL::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTContentLiveURL::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TMTContentLiveURL::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentLiveURL::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* TMTContentLiveURL::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentLiveURL::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobilephone = 7;
inline bool TMTContentLiveURL::has_mobilephone() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTContentLiveURL::set_has_mobilephone() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTContentLiveURL::clear_has_mobilephone() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTContentLiveURL::clear_mobilephone() {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    mobilephone_->clear();
  }
  clear_has_mobilephone();
}
inline const ::std::string& TMTContentLiveURL::mobilephone() const {
  return *mobilephone_;
}
inline void TMTContentLiveURL::set_mobilephone(const ::std::string& value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void TMTContentLiveURL::set_mobilephone(const char* value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void TMTContentLiveURL::set_mobilephone(const char* value, size_t size) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentLiveURL::mutable_mobilephone() {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  return mobilephone_;
}
inline ::std::string* TMTContentLiveURL::release_mobilephone() {
  clear_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilephone_;
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentLiveURL::set_allocated_mobilephone(::std::string* mobilephone) {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    delete mobilephone_;
  }
  if (mobilephone) {
    set_has_mobilephone();
    mobilephone_ = mobilephone;
  } else {
    clear_has_mobilephone();
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string short_url = 8;
inline bool TMTContentLiveURL::has_short_url() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTContentLiveURL::set_has_short_url() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTContentLiveURL::clear_has_short_url() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTContentLiveURL::clear_short_url() {
  if (short_url_ != &::google::protobuf::internal::kEmptyString) {
    short_url_->clear();
  }
  clear_has_short_url();
}
inline const ::std::string& TMTContentLiveURL::short_url() const {
  return *short_url_;
}
inline void TMTContentLiveURL::set_short_url(const ::std::string& value) {
  set_has_short_url();
  if (short_url_ == &::google::protobuf::internal::kEmptyString) {
    short_url_ = new ::std::string;
  }
  short_url_->assign(value);
}
inline void TMTContentLiveURL::set_short_url(const char* value) {
  set_has_short_url();
  if (short_url_ == &::google::protobuf::internal::kEmptyString) {
    short_url_ = new ::std::string;
  }
  short_url_->assign(value);
}
inline void TMTContentLiveURL::set_short_url(const char* value, size_t size) {
  set_has_short_url();
  if (short_url_ == &::google::protobuf::internal::kEmptyString) {
    short_url_ = new ::std::string;
  }
  short_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentLiveURL::mutable_short_url() {
  set_has_short_url();
  if (short_url_ == &::google::protobuf::internal::kEmptyString) {
    short_url_ = new ::std::string;
  }
  return short_url_;
}
inline ::std::string* TMTContentLiveURL::release_short_url() {
  clear_has_short_url();
  if (short_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = short_url_;
    short_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentLiveURL::set_allocated_short_url(::std::string* short_url) {
  if (short_url_ != &::google::protobuf::internal::kEmptyString) {
    delete short_url_;
  }
  if (short_url) {
    set_has_short_url();
    short_url_ = short_url;
  } else {
    clear_has_short_url();
    short_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organizermoid = 9;
inline bool TMTContentLiveURL::has_organizermoid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTContentLiveURL::set_has_organizermoid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTContentLiveURL::clear_has_organizermoid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTContentLiveURL::clear_organizermoid() {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    organizermoid_->clear();
  }
  clear_has_organizermoid();
}
inline const ::std::string& TMTContentLiveURL::organizermoid() const {
  return *organizermoid_;
}
inline void TMTContentLiveURL::set_organizermoid(const ::std::string& value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentLiveURL::set_organizermoid(const char* value) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(value);
}
inline void TMTContentLiveURL::set_organizermoid(const char* value, size_t size) {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  organizermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTContentLiveURL::mutable_organizermoid() {
  set_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    organizermoid_ = new ::std::string;
  }
  return organizermoid_;
}
inline ::std::string* TMTContentLiveURL::release_organizermoid() {
  clear_has_organizermoid();
  if (organizermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organizermoid_;
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTContentLiveURL::set_allocated_organizermoid(::std::string* organizermoid) {
  if (organizermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete organizermoid_;
  }
  if (organizermoid) {
    set_has_organizermoid();
    organizermoid_ = organizermoid;
  } else {
    clear_has_organizermoid();
    organizermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTConfInfoRooms room = 10;
inline bool TMTContentLiveURL::has_room() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTContentLiveURL::set_has_room() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTContentLiveURL::clear_has_room() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTContentLiveURL::clear_room() {
  if (room_ != NULL) room_->::mt::TMTConfInfoRooms::Clear();
  clear_has_room();
}
inline const ::mt::TMTConfInfoRooms& TMTContentLiveURL::room() const {
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::mt::TMTConfInfoRooms* TMTContentLiveURL::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::mt::TMTConfInfoRooms;
  return room_;
}
inline ::mt::TMTConfInfoRooms* TMTContentLiveURL::release_room() {
  clear_has_room();
  ::mt::TMTConfInfoRooms* temp = room_;
  room_ = NULL;
  return temp;
}
inline void TMTContentLiveURL::set_allocated_room(::mt::TMTConfInfoRooms* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mt

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_structrest_2eproto__INCLUDED
