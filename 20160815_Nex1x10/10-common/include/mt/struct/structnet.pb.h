// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structnet.proto

#ifndef PROTOBUF_structnet_2eproto__INCLUDED
#define PROTOBUF_structnet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "enum.pb.h"
#include "structcommon.pb.h"
// @@protoc_insertion_point(includes)

namespace mt {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_structnet_2eproto();
void protobuf_AssignDesc_structnet_2eproto();
void protobuf_ShutdownFile_structnet_2eproto();

class TEthnetWorkModeList;
class TEthnetInterfaceParam;
class TEthnetInterfaceParamList;
class TDNSParam;
class TDHCPLeaseInfo;
class TDHCPStateInfo;
class TPPPoEConnectParam;
class TPPPoEState;
class TPPPoEStatis;
class TPPPoEVersion;
class TE1SerialInfo;
class TE1SingleChainInfo;
class TE1MultiChainInfo;
class TPingCmdOption;
class TPingTestParam;
class TPingResult;
class TDNSNameToIpInfo;
class TDNSNameToIpResult;
class TNetConfilictedInfo;
class TWifiWorkMode;
class TWifiApConfiguration;
class TWifiConfiguration;
class TWifiScanResult;
class TWifiScanResultList;
class TWifiCurDetailInfo;
class TWifiStatisInfo;
class TWifiConnParam;
class TMobileDataWorkMode;
class TMobileDataCurDetailInfo;
class TMobileDataStatisInfo;
class TRouteItemInfo;
class TRouteItemInfoList;
class TE1RouteItemInfo;
class TE1RouteItemInfoList;
class TNetUsedInfo;
class TMTNTPInfo;
class TMTTimeZoneInfo;
class TMTFtpTelnetAccountInfo;
class TServerTestResult;
class TWifiWirelessScreenInfo;
class TLimitedIpItemInfo;
class TLimitedIpCfg;
class TNetCardStatis;
class TNetCardStatisList;

// ===================================================================

class MTMSG_API TEthnetWorkModeList : public ::google::protobuf::Message {
 public:
  TEthnetWorkModeList();
  virtual ~TEthnetWorkModeList();

  TEthnetWorkModeList(const TEthnetWorkModeList& from);

  inline TEthnetWorkModeList& operator=(const TEthnetWorkModeList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TEthnetWorkModeList& default_instance();

  void Swap(TEthnetWorkModeList* other);

  // implements Message ----------------------------------------------

  TEthnetWorkModeList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TEthnetWorkModeList& from);
  void MergeFrom(const TEthnetWorkModeList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmEthnetWorkMode card1_workmode = 1;
  inline bool has_card1_workmode() const;
  inline void clear_card1_workmode();
  static const int kCard1WorkmodeFieldNumber = 1;
  inline ::mt::EmEthnetWorkMode card1_workmode() const;
  inline void set_card1_workmode(::mt::EmEthnetWorkMode value);

  // optional .mt.EmEthnetWorkMode card2_workmode = 2;
  inline bool has_card2_workmode() const;
  inline void clear_card2_workmode();
  static const int kCard2WorkmodeFieldNumber = 2;
  inline ::mt::EmEthnetWorkMode card2_workmode() const;
  inline void set_card2_workmode(::mt::EmEthnetWorkMode value);

  // @@protoc_insertion_point(class_scope:mt.TEthnetWorkModeList)
 private:
  inline void set_has_card1_workmode();
  inline void clear_has_card1_workmode();
  inline void set_has_card2_workmode();
  inline void clear_has_card2_workmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int card1_workmode_;
  int card2_workmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TEthnetWorkModeList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TEthnetInterfaceParam : public ::google::protobuf::Message {
 public:
  TEthnetInterfaceParam();
  virtual ~TEthnetInterfaceParam();

  TEthnetInterfaceParam(const TEthnetInterfaceParam& from);

  inline TEthnetInterfaceParam& operator=(const TEthnetInterfaceParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TEthnetInterfaceParam& default_instance();

  void Swap(TEthnetInterfaceParam* other);

  // implements Message ----------------------------------------------

  TEthnetInterfaceParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TEthnetInterfaceParam& from);
  void MergeFrom(const TEthnetInterfaceParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 mask = 2;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 2;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);

  // optional string mac = 3;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 3;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // @@protoc_insertion_point(class_scope:mt.TEthnetInterfaceParam)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_mac();
  inline void clear_has_mac();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 mask_;
  ::std::string* mac_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TEthnetInterfaceParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TEthnetInterfaceParamList : public ::google::protobuf::Message {
 public:
  TEthnetInterfaceParamList();
  virtual ~TEthnetInterfaceParamList();

  TEthnetInterfaceParamList(const TEthnetInterfaceParamList& from);

  inline TEthnetInterfaceParamList& operator=(const TEthnetInterfaceParamList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TEthnetInterfaceParamList& default_instance();

  void Swap(TEthnetInterfaceParamList* other);

  // implements Message ----------------------------------------------

  TEthnetInterfaceParamList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TEthnetInterfaceParamList& from);
  void MergeFrom(const TEthnetInterfaceParamList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TEthnetInterfaceParam paramList = 1;
  inline int paramlist_size() const;
  inline void clear_paramlist();
  static const int kParamListFieldNumber = 1;
  inline const ::mt::TEthnetInterfaceParam& paramlist(int index) const;
  inline ::mt::TEthnetInterfaceParam* mutable_paramlist(int index);
  inline ::mt::TEthnetInterfaceParam* add_paramlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TEthnetInterfaceParam >&
      paramlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TEthnetInterfaceParam >*
      mutable_paramlist();

  // @@protoc_insertion_point(class_scope:mt.TEthnetInterfaceParamList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TEthnetInterfaceParam > paramlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TEthnetInterfaceParamList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDNSParam : public ::google::protobuf::Message {
 public:
  TDNSParam();
  virtual ~TDNSParam();

  TDNSParam(const TDNSParam& from);

  inline TDNSParam& operator=(const TDNSParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDNSParam& default_instance();

  void Swap(TDNSParam* other);

  // implements Message ----------------------------------------------

  TDNSParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDNSParam& from);
  void MergeFrom(const TDNSParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 dnsList = 1;
  inline int dnslist_size() const;
  inline void clear_dnslist();
  static const int kDnsListFieldNumber = 1;
  inline ::google::protobuf::uint32 dnslist(int index) const;
  inline void set_dnslist(int index, ::google::protobuf::uint32 value);
  inline void add_dnslist(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dnslist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dnslist();

  // optional bool auto = 2;
  inline bool has_auto_() const;
  inline void clear_auto_();
  static const int kAutoFieldNumber = 2;
  inline bool auto_() const;
  inline void set_auto_(bool value);

  // @@protoc_insertion_point(class_scope:mt.TDNSParam)
 private:
  inline void set_has_auto_();
  inline void clear_has_auto_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dnslist_;
  bool auto__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TDNSParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDHCPLeaseInfo : public ::google::protobuf::Message {
 public:
  TDHCPLeaseInfo();
  virtual ~TDHCPLeaseInfo();

  TDHCPLeaseInfo(const TDHCPLeaseInfo& from);

  inline TDHCPLeaseInfo& operator=(const TDHCPLeaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDHCPLeaseInfo& default_instance();

  void Swap(TDHCPLeaseInfo* other);

  // implements Message ----------------------------------------------

  TDHCPLeaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDHCPLeaseInfo& from);
  void MergeFrom(const TDHCPLeaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ethernetid = 1;
  inline bool has_ethernetid() const;
  inline void clear_ethernetid();
  static const int kEthernetidFieldNumber = 1;
  inline ::google::protobuf::uint32 ethernetid() const;
  inline void set_ethernetid(::google::protobuf::uint32 value);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 mask = 3;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 3;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);

  // optional uint32 gateway = 4;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 4;
  inline ::google::protobuf::uint32 gateway() const;
  inline void set_gateway(::google::protobuf::uint32 value);

  // optional uint32 duration = 5;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 5;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 dnsnum = 6;
  inline bool has_dnsnum() const;
  inline void clear_dnsnum();
  static const int kDnsnumFieldNumber = 6;
  inline ::google::protobuf::uint32 dnsnum() const;
  inline void set_dnsnum(::google::protobuf::uint32 value);

  // repeated uint32 dns_server_list = 7;
  inline int dns_server_list_size() const;
  inline void clear_dns_server_list();
  static const int kDnsServerListFieldNumber = 7;
  inline ::google::protobuf::uint32 dns_server_list(int index) const;
  inline void set_dns_server_list(int index, ::google::protobuf::uint32 value);
  inline void add_dns_server_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dns_server_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dns_server_list();

  // @@protoc_insertion_point(class_scope:mt.TDHCPLeaseInfo)
 private:
  inline void set_has_ethernetid();
  inline void clear_has_ethernetid();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_gateway();
  inline void clear_has_gateway();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_dnsnum();
  inline void clear_has_dnsnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ethernetid_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 mask_;
  ::google::protobuf::uint32 gateway_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 dnsnum_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dns_server_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TDHCPLeaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDHCPStateInfo : public ::google::protobuf::Message {
 public:
  TDHCPStateInfo();
  virtual ~TDHCPStateInfo();

  TDHCPStateInfo(const TDHCPStateInfo& from);

  inline TDHCPStateInfo& operator=(const TDHCPStateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDHCPStateInfo& default_instance();

  void Swap(TDHCPStateInfo* other);

  // implements Message ----------------------------------------------

  TDHCPStateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDHCPStateInfo& from);
  void MergeFrom(const TDHCPStateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt.TDHCPStateInfo)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TDHCPStateInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPPPoEConnectParam : public ::google::protobuf::Message {
 public:
  TPPPoEConnectParam();
  virtual ~TPPPoEConnectParam();

  TPPPoEConnectParam(const TPPPoEConnectParam& from);

  inline TPPPoEConnectParam& operator=(const TPPPoEConnectParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPPPoEConnectParam& default_instance();

  void Swap(TPPPoEConnectParam* other);

  // implements Message ----------------------------------------------

  TPPPoEConnectParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPPPoEConnectParam& from);
  void MergeFrom(const TPPPoEConnectParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ethernetid = 1;
  inline bool has_ethernetid() const;
  inline void clear_ethernetid();
  static const int kEthernetidFieldNumber = 1;
  inline ::google::protobuf::uint32 ethernetid() const;
  inline void set_ethernetid(::google::protobuf::uint32 value);

  // optional string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string servername = 4;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 4;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // optional bool autodial = 5;
  inline bool has_autodial() const;
  inline void clear_autodial();
  static const int kAutodialFieldNumber = 5;
  inline bool autodial() const;
  inline void set_autodial(bool value);

  // optional bool def_route_enable = 6;
  inline bool has_def_route_enable() const;
  inline void clear_def_route_enable();
  static const int kDefRouteEnableFieldNumber = 6;
  inline bool def_route_enable() const;
  inline void set_def_route_enable(bool value);

  // optional bool in_debug = 7;
  inline bool has_in_debug() const;
  inline void clear_in_debug();
  static const int kInDebugFieldNumber = 7;
  inline bool in_debug() const;
  inline void set_in_debug(bool value);

  // optional uint32 autodial_interval = 8;
  inline bool has_autodial_interval() const;
  inline void clear_autodial_interval();
  static const int kAutodialIntervalFieldNumber = 8;
  inline ::google::protobuf::uint32 autodial_interval() const;
  inline void set_autodial_interval(::google::protobuf::uint32 value);

  // optional uint32 dial_retrytimes = 9;
  inline bool has_dial_retrytimes() const;
  inline void clear_dial_retrytimes();
  static const int kDialRetrytimesFieldNumber = 9;
  inline ::google::protobuf::uint32 dial_retrytimes() const;
  inline void set_dial_retrytimes(::google::protobuf::uint32 value);

  // optional uint32 lcpecho_sendInterval = 10;
  inline bool has_lcpecho_sendinterval() const;
  inline void clear_lcpecho_sendinterval();
  static const int kLcpechoSendIntervalFieldNumber = 10;
  inline ::google::protobuf::uint32 lcpecho_sendinterval() const;
  inline void set_lcpecho_sendinterval(::google::protobuf::uint32 value);

  // optional uint32 lcpecho_retrytimes = 11;
  inline bool has_lcpecho_retrytimes() const;
  inline void clear_lcpecho_retrytimes();
  static const int kLcpechoRetrytimesFieldNumber = 11;
  inline ::google::protobuf::uint32 lcpecho_retrytimes() const;
  inline void set_lcpecho_retrytimes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TPPPoEConnectParam)
 private:
  inline void set_has_ethernetid();
  inline void clear_has_ethernetid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_autodial();
  inline void clear_has_autodial();
  inline void set_has_def_route_enable();
  inline void clear_has_def_route_enable();
  inline void set_has_in_debug();
  inline void clear_has_in_debug();
  inline void set_has_autodial_interval();
  inline void clear_has_autodial_interval();
  inline void set_has_dial_retrytimes();
  inline void clear_has_dial_retrytimes();
  inline void set_has_lcpecho_sendinterval();
  inline void clear_has_lcpecho_sendinterval();
  inline void set_has_lcpecho_retrytimes();
  inline void clear_has_lcpecho_retrytimes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;
  ::std::string* servername_;
  ::google::protobuf::uint32 ethernetid_;
  bool autodial_;
  bool def_route_enable_;
  bool in_debug_;
  ::google::protobuf::uint32 autodial_interval_;
  ::google::protobuf::uint32 dial_retrytimes_;
  ::google::protobuf::uint32 lcpecho_sendinterval_;
  ::google::protobuf::uint32 lcpecho_retrytimes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TPPPoEConnectParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPPPoEState : public ::google::protobuf::Message {
 public:
  TPPPoEState();
  virtual ~TPPPoEState();

  TPPPoEState(const TPPPoEState& from);

  inline TPPPoEState& operator=(const TPPPoEState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPPPoEState& default_instance();

  void Swap(TPPPoEState* other);

  // implements Message ----------------------------------------------

  TPPPoEState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPPPoEState& from);
  void MergeFrom(const TPPPoEState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmPPPoELinkState pppoe_running = 1;
  inline bool has_pppoe_running() const;
  inline void clear_pppoe_running();
  static const int kPppoeRunningFieldNumber = 1;
  inline ::mt::EmPPPoELinkState pppoe_running() const;
  inline void set_pppoe_running(::mt::EmPPPoELinkState value);

  // optional string servername = 2;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 2;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // optional uint32 localip = 3;
  inline bool has_localip() const;
  inline void clear_localip();
  static const int kLocalipFieldNumber = 3;
  inline ::google::protobuf::uint32 localip() const;
  inline void set_localip(::google::protobuf::uint32 value);

  // optional uint32 peerip = 4;
  inline bool has_peerip() const;
  inline void clear_peerip();
  static const int kPeeripFieldNumber = 4;
  inline ::google::protobuf::uint32 peerip() const;
  inline void set_peerip(::google::protobuf::uint32 value);

  // optional uint32 mDnsServer1 = 5;
  inline bool has_mdnsserver1() const;
  inline void clear_mdnsserver1();
  static const int kMDnsServer1FieldNumber = 5;
  inline ::google::protobuf::uint32 mdnsserver1() const;
  inline void set_mdnsserver1(::google::protobuf::uint32 value);

  // optional uint32 mDnsServer2 = 6;
  inline bool has_mdnsserver2() const;
  inline void clear_mdnsserver2();
  static const int kMDnsServer2FieldNumber = 6;
  inline ::google::protobuf::uint32 mdnsserver2() const;
  inline void set_mdnsserver2(::google::protobuf::uint32 value);

  // optional .mt.EmPPPoELinkErrReason emReason = 7;
  inline bool has_emreason() const;
  inline void clear_emreason();
  static const int kEmReasonFieldNumber = 7;
  inline ::mt::EmPPPoELinkErrReason emreason() const;
  inline void set_emreason(::mt::EmPPPoELinkErrReason value);

  // @@protoc_insertion_point(class_scope:mt.TPPPoEState)
 private:
  inline void set_has_pppoe_running();
  inline void clear_has_pppoe_running();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_localip();
  inline void clear_has_localip();
  inline void set_has_peerip();
  inline void clear_has_peerip();
  inline void set_has_mdnsserver1();
  inline void clear_has_mdnsserver1();
  inline void set_has_mdnsserver2();
  inline void clear_has_mdnsserver2();
  inline void set_has_emreason();
  inline void clear_has_emreason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* servername_;
  int pppoe_running_;
  ::google::protobuf::uint32 localip_;
  ::google::protobuf::uint32 peerip_;
  ::google::protobuf::uint32 mdnsserver1_;
  ::google::protobuf::uint32 mdnsserver2_;
  int emreason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TPPPoEState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPPPoEStatis : public ::google::protobuf::Message {
 public:
  TPPPoEStatis();
  virtual ~TPPPoEStatis();

  TPPPoEStatis(const TPPPoEStatis& from);

  inline TPPPoEStatis& operator=(const TPPPoEStatis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPPPoEStatis& default_instance();

  void Swap(TPPPoEStatis* other);

  // implements Message ----------------------------------------------

  TPPPoEStatis* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPPPoEStatis& from);
  void MergeFrom(const TPPPoEStatis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 link_keeptime = 1;
  inline bool has_link_keeptime() const;
  inline void clear_link_keeptime();
  static const int kLinkKeeptimeFieldNumber = 1;
  inline ::google::protobuf::uint32 link_keeptime() const;
  inline void set_link_keeptime(::google::protobuf::uint32 value);

  // optional uint32 link_downtimes = 2;
  inline bool has_link_downtimes() const;
  inline void clear_link_downtimes();
  static const int kLinkDowntimesFieldNumber = 2;
  inline ::google::protobuf::uint32 link_downtimes() const;
  inline void set_link_downtimes(::google::protobuf::uint32 value);

  // optional uint32 num_pkgsent = 3;
  inline bool has_num_pkgsent() const;
  inline void clear_num_pkgsent();
  static const int kNumPkgsentFieldNumber = 3;
  inline ::google::protobuf::uint32 num_pkgsent() const;
  inline void set_num_pkgsent(::google::protobuf::uint32 value);

  // optional uint32 num_pkgrecved = 4;
  inline bool has_num_pkgrecved() const;
  inline void clear_num_pkgrecved();
  static const int kNumPkgrecvedFieldNumber = 4;
  inline ::google::protobuf::uint32 num_pkgrecved() const;
  inline void set_num_pkgrecved(::google::protobuf::uint32 value);

  // optional uint32 num_bytessent = 5;
  inline bool has_num_bytessent() const;
  inline void clear_num_bytessent();
  static const int kNumBytessentFieldNumber = 5;
  inline ::google::protobuf::uint32 num_bytessent() const;
  inline void set_num_bytessent(::google::protobuf::uint32 value);

  // optional uint32 num_bytesrecved = 6;
  inline bool has_num_bytesrecved() const;
  inline void clear_num_bytesrecved();
  static const int kNumBytesrecvedFieldNumber = 6;
  inline ::google::protobuf::uint32 num_bytesrecved() const;
  inline void set_num_bytesrecved(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TPPPoEStatis)
 private:
  inline void set_has_link_keeptime();
  inline void clear_has_link_keeptime();
  inline void set_has_link_downtimes();
  inline void clear_has_link_downtimes();
  inline void set_has_num_pkgsent();
  inline void clear_has_num_pkgsent();
  inline void set_has_num_pkgrecved();
  inline void clear_has_num_pkgrecved();
  inline void set_has_num_bytessent();
  inline void clear_has_num_bytessent();
  inline void set_has_num_bytesrecved();
  inline void clear_has_num_bytesrecved();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 link_keeptime_;
  ::google::protobuf::uint32 link_downtimes_;
  ::google::protobuf::uint32 num_pkgsent_;
  ::google::protobuf::uint32 num_pkgrecved_;
  ::google::protobuf::uint32 num_bytessent_;
  ::google::protobuf::uint32 num_bytesrecved_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TPPPoEStatis* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPPPoEVersion : public ::google::protobuf::Message {
 public:
  TPPPoEVersion();
  virtual ~TPPPoEVersion();

  TPPPoEVersion(const TPPPoEVersion& from);

  inline TPPPoEVersion& operator=(const TPPPoEVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPPPoEVersion& default_instance();

  void Swap(TPPPoEVersion* other);

  // implements Message ----------------------------------------------

  TPPPoEVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPPPoEVersion& from);
  void MergeFrom(const TPPPoEVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mt.TPPPoEVersion)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TPPPoEVersion* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TE1SerialInfo : public ::google::protobuf::Message {
 public:
  TE1SerialInfo();
  virtual ~TE1SerialInfo();

  TE1SerialInfo(const TE1SerialInfo& from);

  inline TE1SerialInfo& operator=(const TE1SerialInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TE1SerialInfo& default_instance();

  void Swap(TE1SerialInfo* other);

  // implements Message ----------------------------------------------

  TE1SerialInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TE1SerialInfo& from);
  void MergeFrom(const TE1SerialInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 used_flag = 1;
  inline bool has_used_flag() const;
  inline void clear_used_flag();
  static const int kUsedFlagFieldNumber = 1;
  inline ::google::protobuf::uint32 used_flag() const;
  inline void set_used_flag(::google::protobuf::uint32 value);

  // optional uint32 serialid = 2;
  inline bool has_serialid() const;
  inline void clear_serialid();
  static const int kSerialidFieldNumber = 2;
  inline ::google::protobuf::uint32 serialid() const;
  inline void set_serialid(::google::protobuf::uint32 value);

  // optional uint32 e1id = 3;
  inline bool has_e1id() const;
  inline void clear_e1id();
  static const int kE1IdFieldNumber = 3;
  inline ::google::protobuf::uint32 e1id() const;
  inline void set_e1id(::google::protobuf::uint32 value);

  // optional uint32 e1_ts_mask = 4;
  inline bool has_e1_ts_mask() const;
  inline void clear_e1_ts_mask();
  static const int kE1TsMaskFieldNumber = 4;
  inline ::google::protobuf::uint32 e1_ts_mask() const;
  inline void set_e1_ts_mask(::google::protobuf::uint32 value);

  // optional uint32 e1chan_groupid = 5;
  inline bool has_e1chan_groupid() const;
  inline void clear_e1chan_groupid();
  static const int kE1ChanGroupidFieldNumber = 5;
  inline ::google::protobuf::uint32 e1chan_groupid() const;
  inline void set_e1chan_groupid(::google::protobuf::uint32 value);

  // optional uint32 protocol_type = 6;
  inline bool has_protocol_type() const;
  inline void clear_protocol_type();
  static const int kProtocolTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 protocol_type() const;
  inline void set_protocol_type(::google::protobuf::uint32 value);

  // optional uint32 echo_interval = 7;
  inline bool has_echo_interval() const;
  inline void clear_echo_interval();
  static const int kEchoIntervalFieldNumber = 7;
  inline ::google::protobuf::uint32 echo_interval() const;
  inline void set_echo_interval(::google::protobuf::uint32 value);

  // optional uint32 echo_maxretry = 8;
  inline bool has_echo_maxretry() const;
  inline void clear_echo_maxretry();
  static const int kEchoMaxretryFieldNumber = 8;
  inline ::google::protobuf::uint32 echo_maxretry() const;
  inline void set_echo_maxretry(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TE1SerialInfo)
 private:
  inline void set_has_used_flag();
  inline void clear_has_used_flag();
  inline void set_has_serialid();
  inline void clear_has_serialid();
  inline void set_has_e1id();
  inline void clear_has_e1id();
  inline void set_has_e1_ts_mask();
  inline void clear_has_e1_ts_mask();
  inline void set_has_e1chan_groupid();
  inline void clear_has_e1chan_groupid();
  inline void set_has_protocol_type();
  inline void clear_has_protocol_type();
  inline void set_has_echo_interval();
  inline void clear_has_echo_interval();
  inline void set_has_echo_maxretry();
  inline void clear_has_echo_maxretry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 used_flag_;
  ::google::protobuf::uint32 serialid_;
  ::google::protobuf::uint32 e1id_;
  ::google::protobuf::uint32 e1_ts_mask_;
  ::google::protobuf::uint32 e1chan_groupid_;
  ::google::protobuf::uint32 protocol_type_;
  ::google::protobuf::uint32 echo_interval_;
  ::google::protobuf::uint32 echo_maxretry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TE1SerialInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TE1SingleChainInfo : public ::google::protobuf::Message {
 public:
  TE1SingleChainInfo();
  virtual ~TE1SingleChainInfo();

  TE1SingleChainInfo(const TE1SingleChainInfo& from);

  inline TE1SingleChainInfo& operator=(const TE1SingleChainInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TE1SingleChainInfo& default_instance();

  void Swap(TE1SingleChainInfo* other);

  // implements Message ----------------------------------------------

  TE1SingleChainInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TE1SingleChainInfo& from);
  void MergeFrom(const TE1SingleChainInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 used_flag = 1;
  inline bool has_used_flag() const;
  inline void clear_used_flag();
  static const int kUsedFlagFieldNumber = 1;
  inline ::google::protobuf::uint32 used_flag() const;
  inline void set_used_flag(::google::protobuf::uint32 value);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 mask = 3;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 3;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);

  // optional .mt.TE1SerialInfo serialinfo = 4;
  inline bool has_serialinfo() const;
  inline void clear_serialinfo();
  static const int kSerialinfoFieldNumber = 4;
  inline const ::mt::TE1SerialInfo& serialinfo() const;
  inline ::mt::TE1SerialInfo* mutable_serialinfo();
  inline ::mt::TE1SerialInfo* release_serialinfo();
  inline void set_allocated_serialinfo(::mt::TE1SerialInfo* serialinfo);

  // @@protoc_insertion_point(class_scope:mt.TE1SingleChainInfo)
 private:
  inline void set_has_used_flag();
  inline void clear_has_used_flag();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_serialinfo();
  inline void clear_has_serialinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 used_flag_;
  ::google::protobuf::uint32 ip_;
  ::mt::TE1SerialInfo* serialinfo_;
  ::google::protobuf::uint32 mask_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TE1SingleChainInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TE1MultiChainInfo : public ::google::protobuf::Message {
 public:
  TE1MultiChainInfo();
  virtual ~TE1MultiChainInfo();

  TE1MultiChainInfo(const TE1MultiChainInfo& from);

  inline TE1MultiChainInfo& operator=(const TE1MultiChainInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TE1MultiChainInfo& default_instance();

  void Swap(TE1MultiChainInfo* other);

  // implements Message ----------------------------------------------

  TE1MultiChainInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TE1MultiChainInfo& from);
  void MergeFrom(const TE1MultiChainInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 used_flag = 1;
  inline bool has_used_flag() const;
  inline void clear_used_flag();
  static const int kUsedFlagFieldNumber = 1;
  inline ::google::protobuf::uint32 used_flag() const;
  inline void set_used_flag(::google::protobuf::uint32 value);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 mask = 3;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 3;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);

  // optional uint32 auth_type = 4;
  inline bool has_auth_type() const;
  inline void clear_auth_type();
  static const int kAuthTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 auth_type() const;
  inline void set_auth_type(::google::protobuf::uint32 value);

  // optional uint32 frag_minpackage_len = 5;
  inline bool has_frag_minpackage_len() const;
  inline void clear_frag_minpackage_len();
  static const int kFragMinpackageLenFieldNumber = 5;
  inline ::google::protobuf::uint32 frag_minpackage_len() const;
  inline void set_frag_minpackage_len(::google::protobuf::uint32 value);

  // optional string svr_usrname = 6;
  inline bool has_svr_usrname() const;
  inline void clear_svr_usrname();
  static const int kSvrUsrnameFieldNumber = 6;
  inline const ::std::string& svr_usrname() const;
  inline void set_svr_usrname(const ::std::string& value);
  inline void set_svr_usrname(const char* value);
  inline void set_svr_usrname(const char* value, size_t size);
  inline ::std::string* mutable_svr_usrname();
  inline ::std::string* release_svr_usrname();
  inline void set_allocated_svr_usrname(::std::string* svr_usrname);

  // optional string svr_usrpwd = 7;
  inline bool has_svr_usrpwd() const;
  inline void clear_svr_usrpwd();
  static const int kSvrUsrpwdFieldNumber = 7;
  inline const ::std::string& svr_usrpwd() const;
  inline void set_svr_usrpwd(const ::std::string& value);
  inline void set_svr_usrpwd(const char* value);
  inline void set_svr_usrpwd(const char* value, size_t size);
  inline ::std::string* mutable_svr_usrpwd();
  inline ::std::string* release_svr_usrpwd();
  inline void set_allocated_svr_usrpwd(::std::string* svr_usrpwd);

  // optional string sent_usrname = 8;
  inline bool has_sent_usrname() const;
  inline void clear_sent_usrname();
  static const int kSentUsrnameFieldNumber = 8;
  inline const ::std::string& sent_usrname() const;
  inline void set_sent_usrname(const ::std::string& value);
  inline void set_sent_usrname(const char* value);
  inline void set_sent_usrname(const char* value, size_t size);
  inline ::std::string* mutable_sent_usrname();
  inline ::std::string* release_sent_usrname();
  inline void set_allocated_sent_usrname(::std::string* sent_usrname);

  // optional string sent_usrpwd = 9;
  inline bool has_sent_usrpwd() const;
  inline void clear_sent_usrpwd();
  static const int kSentUsrpwdFieldNumber = 9;
  inline const ::std::string& sent_usrpwd() const;
  inline void set_sent_usrpwd(const ::std::string& value);
  inline void set_sent_usrpwd(const char* value);
  inline void set_sent_usrpwd(const char* value, size_t size);
  inline ::std::string* mutable_sent_usrpwd();
  inline ::std::string* release_sent_usrpwd();
  inline void set_allocated_sent_usrpwd(::std::string* sent_usrpwd);

  // repeated .mt.TE1SerialInfo serialinfolist = 10;
  inline int serialinfolist_size() const;
  inline void clear_serialinfolist();
  static const int kSerialinfolistFieldNumber = 10;
  inline const ::mt::TE1SerialInfo& serialinfolist(int index) const;
  inline ::mt::TE1SerialInfo* mutable_serialinfolist(int index);
  inline ::mt::TE1SerialInfo* add_serialinfolist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TE1SerialInfo >&
      serialinfolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TE1SerialInfo >*
      mutable_serialinfolist();

  // @@protoc_insertion_point(class_scope:mt.TE1MultiChainInfo)
 private:
  inline void set_has_used_flag();
  inline void clear_has_used_flag();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_auth_type();
  inline void clear_has_auth_type();
  inline void set_has_frag_minpackage_len();
  inline void clear_has_frag_minpackage_len();
  inline void set_has_svr_usrname();
  inline void clear_has_svr_usrname();
  inline void set_has_svr_usrpwd();
  inline void clear_has_svr_usrpwd();
  inline void set_has_sent_usrname();
  inline void clear_has_sent_usrname();
  inline void set_has_sent_usrpwd();
  inline void clear_has_sent_usrpwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 used_flag_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 mask_;
  ::google::protobuf::uint32 auth_type_;
  ::std::string* svr_usrname_;
  ::std::string* svr_usrpwd_;
  ::std::string* sent_usrname_;
  ::std::string* sent_usrpwd_;
  ::google::protobuf::RepeatedPtrField< ::mt::TE1SerialInfo > serialinfolist_;
  ::google::protobuf::uint32 frag_minpackage_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TE1MultiChainInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPingCmdOption : public ::google::protobuf::Message {
 public:
  TPingCmdOption();
  virtual ~TPingCmdOption();

  TPingCmdOption(const TPingCmdOption& from);

  inline TPingCmdOption& operator=(const TPingCmdOption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPingCmdOption& default_instance();

  void Swap(TPingCmdOption* other);

  // implements Message ----------------------------------------------

  TPingCmdOption* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPingCmdOption& from);
  void MergeFrom(const TPingCmdOption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 packagesize = 1;
  inline bool has_packagesize() const;
  inline void clear_packagesize();
  static const int kPackagesizeFieldNumber = 1;
  inline ::google::protobuf::uint32 packagesize() const;
  inline void set_packagesize(::google::protobuf::uint32 value);

  // optional uint32 timeout = 2;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional uint32 ttl = 3;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 3;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // optional uint32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TPingCmdOption)
 private:
  inline void set_has_packagesize();
  inline void clear_has_packagesize();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 packagesize_;
  ::google::protobuf::uint32 timeout_;
  ::google::protobuf::uint32 ttl_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TPingCmdOption* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPingTestParam : public ::google::protobuf::Message {
 public:
  TPingTestParam();
  virtual ~TPingTestParam();

  TPingTestParam(const TPingTestParam& from);

  inline TPingTestParam& operator=(const TPingTestParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPingTestParam& default_instance();

  void Swap(TPingTestParam* other);

  // implements Message ----------------------------------------------

  TPingTestParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPingTestParam& from);
  void MergeFrom(const TPingTestParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dst_info = 1;
  inline bool has_dst_info() const;
  inline void clear_dst_info();
  static const int kDstInfoFieldNumber = 1;
  inline const ::std::string& dst_info() const;
  inline void set_dst_info(const ::std::string& value);
  inline void set_dst_info(const char* value);
  inline void set_dst_info(const char* value, size_t size);
  inline ::std::string* mutable_dst_info();
  inline ::std::string* release_dst_info();
  inline void set_allocated_dst_info(::std::string* dst_info);

  // optional .mt.TPingCmdOption ping_option = 2;
  inline bool has_ping_option() const;
  inline void clear_ping_option();
  static const int kPingOptionFieldNumber = 2;
  inline const ::mt::TPingCmdOption& ping_option() const;
  inline ::mt::TPingCmdOption* mutable_ping_option();
  inline ::mt::TPingCmdOption* release_ping_option();
  inline void set_allocated_ping_option(::mt::TPingCmdOption* ping_option);

  // optional uint32 userid = 3;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 3;
  inline ::google::protobuf::uint32 userid() const;
  inline void set_userid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TPingTestParam)
 private:
  inline void set_has_dst_info();
  inline void clear_has_dst_info();
  inline void set_has_ping_option();
  inline void clear_has_ping_option();
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dst_info_;
  ::mt::TPingCmdOption* ping_option_;
  ::google::protobuf::uint32 userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TPingTestParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPingResult : public ::google::protobuf::Message {
 public:
  TPingResult();
  virtual ~TPingResult();

  TPingResult(const TPingResult& from);

  inline TPingResult& operator=(const TPingResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPingResult& default_instance();

  void Swap(TPingResult* other);

  // implements Message ----------------------------------------------

  TPingResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPingResult& from);
  void MergeFrom(const TPingResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmPingErrcode ping_errcode = 1;
  inline bool has_ping_errcode() const;
  inline void clear_ping_errcode();
  static const int kPingErrcodeFieldNumber = 1;
  inline ::mt::EmPingErrcode ping_errcode() const;
  inline void set_ping_errcode(::mt::EmPingErrcode value);

  // optional uint32 ttl = 2;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 2;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // optional uint32 trip_time = 3;
  inline bool has_trip_time() const;
  inline void clear_trip_time();
  static const int kTripTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 trip_time() const;
  inline void set_trip_time(::google::protobuf::uint32 value);

  // optional uint32 userid = 4;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 4;
  inline ::google::protobuf::uint32 userid() const;
  inline void set_userid(::google::protobuf::uint32 value);

  // optional uint32 error_type = 5;
  inline bool has_error_type() const;
  inline void clear_error_type();
  static const int kErrorTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 error_type() const;
  inline void set_error_type(::google::protobuf::uint32 value);

  // optional uint32 error_code = 6;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 6;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TPingResult)
 private:
  inline void set_has_ping_errcode();
  inline void clear_has_ping_errcode();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_trip_time();
  inline void clear_has_trip_time();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_error_type();
  inline void clear_has_error_type();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ping_errcode_;
  ::google::protobuf::uint32 ttl_;
  ::google::protobuf::uint32 trip_time_;
  ::google::protobuf::uint32 userid_;
  ::google::protobuf::uint32 error_type_;
  ::google::protobuf::uint32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TPingResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDNSNameToIpInfo : public ::google::protobuf::Message {
 public:
  TDNSNameToIpInfo();
  virtual ~TDNSNameToIpInfo();

  TDNSNameToIpInfo(const TDNSNameToIpInfo& from);

  inline TDNSNameToIpInfo& operator=(const TDNSNameToIpInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDNSNameToIpInfo& default_instance();

  void Swap(TDNSNameToIpInfo* other);

  // implements Message ----------------------------------------------

  TDNSNameToIpInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDNSNameToIpInfo& from);
  void MergeFrom(const TDNSNameToIpInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dns_name = 1;
  inline bool has_dns_name() const;
  inline void clear_dns_name();
  static const int kDnsNameFieldNumber = 1;
  inline const ::std::string& dns_name() const;
  inline void set_dns_name(const ::std::string& value);
  inline void set_dns_name(const char* value);
  inline void set_dns_name(const char* value, size_t size);
  inline ::std::string* mutable_dns_name();
  inline ::std::string* release_dns_name();
  inline void set_allocated_dns_name(::std::string* dns_name);

  // @@protoc_insertion_point(class_scope:mt.TDNSNameToIpInfo)
 private:
  inline void set_has_dns_name();
  inline void clear_has_dns_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dns_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TDNSNameToIpInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDNSNameToIpResult : public ::google::protobuf::Message {
 public:
  TDNSNameToIpResult();
  virtual ~TDNSNameToIpResult();

  TDNSNameToIpResult(const TDNSNameToIpResult& from);

  inline TDNSNameToIpResult& operator=(const TDNSNameToIpResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDNSNameToIpResult& default_instance();

  void Swap(TDNSNameToIpResult* other);

  // implements Message ----------------------------------------------

  TDNSNameToIpResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDNSNameToIpResult& from);
  void MergeFrom(const TDNSNameToIpResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dns_name = 1;
  inline bool has_dns_name() const;
  inline void clear_dns_name();
  static const int kDnsNameFieldNumber = 1;
  inline const ::std::string& dns_name() const;
  inline void set_dns_name(const ::std::string& value);
  inline void set_dns_name(const char* value);
  inline void set_dns_name(const char* value, size_t size);
  inline ::std::string* mutable_dns_name();
  inline ::std::string* release_dns_name();
  inline void set_allocated_dns_name(::std::string* dns_name);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 error_code = 3;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TDNSNameToIpResult)
 private:
  inline void set_has_dns_name();
  inline void clear_has_dns_name();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dns_name_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TDNSNameToIpResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNetConfilictedInfo : public ::google::protobuf::Message {
 public:
  TNetConfilictedInfo();
  virtual ~TNetConfilictedInfo();

  TNetConfilictedInfo(const TNetConfilictedInfo& from);

  inline TNetConfilictedInfo& operator=(const TNetConfilictedInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNetConfilictedInfo& default_instance();

  void Swap(TNetConfilictedInfo* other);

  // implements Message ----------------------------------------------

  TNetConfilictedInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNetConfilictedInfo& from);
  void MergeFrom(const TNetConfilictedInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmNetConflictType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmNetConflictType type() const;
  inline void set_type(::mt::EmNetConflictType value);

  // optional string mac = 2;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 2;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional uint32 ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TNetConfilictedInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mac_;
  int type_;
  ::google::protobuf::uint32 ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TNetConfilictedInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWifiWorkMode : public ::google::protobuf::Message {
 public:
  TWifiWorkMode();
  virtual ~TWifiWorkMode();

  TWifiWorkMode(const TWifiWorkMode& from);

  inline TWifiWorkMode& operator=(const TWifiWorkMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWifiWorkMode& default_instance();

  void Swap(TWifiWorkMode* other);

  // implements Message ----------------------------------------------

  TWifiWorkMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWifiWorkMode& from);
  void MergeFrom(const TWifiWorkMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmWifiWorkMode wifi_workmode = 1;
  inline bool has_wifi_workmode() const;
  inline void clear_wifi_workmode();
  static const int kWifiWorkmodeFieldNumber = 1;
  inline ::mt::EmWifiWorkMode wifi_workmode() const;
  inline void set_wifi_workmode(::mt::EmWifiWorkMode value);

  // optional .mt.TWifiApConfiguration wifiApConfig = 2;
  inline bool has_wifiapconfig() const;
  inline void clear_wifiapconfig();
  static const int kWifiApConfigFieldNumber = 2;
  inline const ::mt::TWifiApConfiguration& wifiapconfig() const;
  inline ::mt::TWifiApConfiguration* mutable_wifiapconfig();
  inline ::mt::TWifiApConfiguration* release_wifiapconfig();
  inline void set_allocated_wifiapconfig(::mt::TWifiApConfiguration* wifiapconfig);

  // @@protoc_insertion_point(class_scope:mt.TWifiWorkMode)
 private:
  inline void set_has_wifi_workmode();
  inline void clear_has_wifi_workmode();
  inline void set_has_wifiapconfig();
  inline void clear_has_wifiapconfig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TWifiApConfiguration* wifiapconfig_;
  int wifi_workmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TWifiWorkMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWifiApConfiguration : public ::google::protobuf::Message {
 public:
  TWifiApConfiguration();
  virtual ~TWifiApConfiguration();

  TWifiApConfiguration(const TWifiApConfiguration& from);

  inline TWifiApConfiguration& operator=(const TWifiApConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWifiApConfiguration& default_instance();

  void Swap(TWifiApConfiguration* other);

  // implements Message ----------------------------------------------

  TWifiApConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWifiApConfiguration& from);
  void MergeFrom(const TWifiApConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ssid = 1;
  inline bool has_ssid() const;
  inline void clear_ssid();
  static const int kSsidFieldNumber = 1;
  inline const ::std::string& ssid() const;
  inline void set_ssid(const ::std::string& value);
  inline void set_ssid(const char* value);
  inline void set_ssid(const char* value, size_t size);
  inline ::std::string* mutable_ssid();
  inline ::std::string* release_ssid();
  inline void set_allocated_ssid(::std::string* ssid);

  // optional .mt.EmWifiApKeyType capabilities = 2;
  inline bool has_capabilities() const;
  inline void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 2;
  inline ::mt::EmWifiApKeyType capabilities() const;
  inline void set_capabilities(::mt::EmWifiApKeyType value);

  // optional string key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 dhcp_startip = 4;
  inline bool has_dhcp_startip() const;
  inline void clear_dhcp_startip();
  static const int kDhcpStartipFieldNumber = 4;
  inline ::google::protobuf::uint32 dhcp_startip() const;
  inline void set_dhcp_startip(::google::protobuf::uint32 value);

  // optional uint32 dhcp_endip = 5;
  inline bool has_dhcp_endip() const;
  inline void clear_dhcp_endip();
  static const int kDhcpEndipFieldNumber = 5;
  inline ::google::protobuf::uint32 dhcp_endip() const;
  inline void set_dhcp_endip(::google::protobuf::uint32 value);

  // optional uint32 ip = 6;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 6;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 mask = 7;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 7;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);

  // optional .mt.EmWifiFrequencyBandType frequency_band = 8;
  inline bool has_frequency_band() const;
  inline void clear_frequency_band();
  static const int kFrequencyBandFieldNumber = 8;
  inline ::mt::EmWifiFrequencyBandType frequency_band() const;
  inline void set_frequency_band(::mt::EmWifiFrequencyBandType value);

  // @@protoc_insertion_point(class_scope:mt.TWifiApConfiguration)
 private:
  inline void set_has_ssid();
  inline void clear_has_ssid();
  inline void set_has_capabilities();
  inline void clear_has_capabilities();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_dhcp_startip();
  inline void clear_has_dhcp_startip();
  inline void set_has_dhcp_endip();
  inline void clear_has_dhcp_endip();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_frequency_band();
  inline void clear_has_frequency_band();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ssid_;
  ::std::string* key_;
  int capabilities_;
  ::google::protobuf::uint32 dhcp_startip_;
  ::google::protobuf::uint32 dhcp_endip_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 mask_;
  int frequency_band_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TWifiApConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWifiConfiguration : public ::google::protobuf::Message {
 public:
  TWifiConfiguration();
  virtual ~TWifiConfiguration();

  TWifiConfiguration(const TWifiConfiguration& from);

  inline TWifiConfiguration& operator=(const TWifiConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWifiConfiguration& default_instance();

  void Swap(TWifiConfiguration* other);

  // implements Message ----------------------------------------------

  TWifiConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWifiConfiguration& from);
  void MergeFrom(const TWifiConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_autoconn = 1;
  inline bool has_enable_autoconn() const;
  inline void clear_enable_autoconn();
  static const int kEnableAutoconnFieldNumber = 1;
  inline bool enable_autoconn() const;
  inline void set_enable_autoconn(bool value);

  // optional bool enable_autoip = 2;
  inline bool has_enable_autoip() const;
  inline void clear_enable_autoip();
  static const int kEnableAutoipFieldNumber = 2;
  inline bool enable_autoip() const;
  inline void set_enable_autoip(bool value);

  // optional uint32 ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 mask = 4;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 4;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);

  // optional uint32 gateway = 5;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 5;
  inline ::google::protobuf::uint32 gateway() const;
  inline void set_gateway(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TWifiConfiguration)
 private:
  inline void set_has_enable_autoconn();
  inline void clear_has_enable_autoconn();
  inline void set_has_enable_autoip();
  inline void clear_has_enable_autoip();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_gateway();
  inline void clear_has_gateway();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_autoconn_;
  bool enable_autoip_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 mask_;
  ::google::protobuf::uint32 gateway_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TWifiConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWifiScanResult : public ::google::protobuf::Message {
 public:
  TWifiScanResult();
  virtual ~TWifiScanResult();

  TWifiScanResult(const TWifiScanResult& from);

  inline TWifiScanResult& operator=(const TWifiScanResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWifiScanResult& default_instance();

  void Swap(TWifiScanResult* other);

  // implements Message ----------------------------------------------

  TWifiScanResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWifiScanResult& from);
  void MergeFrom(const TWifiScanResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ssid = 1;
  inline bool has_ssid() const;
  inline void clear_ssid();
  static const int kSsidFieldNumber = 1;
  inline const ::std::string& ssid() const;
  inline void set_ssid(const ::std::string& value);
  inline void set_ssid(const char* value);
  inline void set_ssid(const char* value, size_t size);
  inline ::std::string* mutable_ssid();
  inline ::std::string* release_ssid();
  inline void set_allocated_ssid(::std::string* ssid);

  // optional .mt.EmWifiKeyType capabilities = 2;
  inline bool has_capabilities() const;
  inline void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 2;
  inline ::mt::EmWifiKeyType capabilities() const;
  inline void set_capabilities(::mt::EmWifiKeyType value);

  // optional .mt.EmWifiSignalLevel signalLevel = 3;
  inline bool has_signallevel() const;
  inline void clear_signallevel();
  static const int kSignalLevelFieldNumber = 3;
  inline ::mt::EmWifiSignalLevel signallevel() const;
  inline void set_signallevel(::mt::EmWifiSignalLevel value);

  // optional bool issave = 4;
  inline bool has_issave() const;
  inline void clear_issave();
  static const int kIssaveFieldNumber = 4;
  inline bool issave() const;
  inline void set_issave(bool value);

  // optional int32 networkid = 5;
  inline bool has_networkid() const;
  inline void clear_networkid();
  static const int kNetworkidFieldNumber = 5;
  inline ::google::protobuf::int32 networkid() const;
  inline void set_networkid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt.TWifiScanResult)
 private:
  inline void set_has_ssid();
  inline void clear_has_ssid();
  inline void set_has_capabilities();
  inline void clear_has_capabilities();
  inline void set_has_signallevel();
  inline void clear_has_signallevel();
  inline void set_has_issave();
  inline void clear_has_issave();
  inline void set_has_networkid();
  inline void clear_has_networkid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ssid_;
  int capabilities_;
  int signallevel_;
  bool issave_;
  ::google::protobuf::int32 networkid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TWifiScanResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWifiScanResultList : public ::google::protobuf::Message {
 public:
  TWifiScanResultList();
  virtual ~TWifiScanResultList();

  TWifiScanResultList(const TWifiScanResultList& from);

  inline TWifiScanResultList& operator=(const TWifiScanResultList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWifiScanResultList& default_instance();

  void Swap(TWifiScanResultList* other);

  // implements Message ----------------------------------------------

  TWifiScanResultList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWifiScanResultList& from);
  void MergeFrom(const TWifiScanResultList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TWifiScanResult scan_list = 1;
  inline int scan_list_size() const;
  inline void clear_scan_list();
  static const int kScanListFieldNumber = 1;
  inline const ::mt::TWifiScanResult& scan_list(int index) const;
  inline ::mt::TWifiScanResult* mutable_scan_list(int index);
  inline ::mt::TWifiScanResult* add_scan_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TWifiScanResult >&
      scan_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TWifiScanResult >*
      mutable_scan_list();

  // @@protoc_insertion_point(class_scope:mt.TWifiScanResultList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TWifiScanResult > scan_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TWifiScanResultList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWifiCurDetailInfo : public ::google::protobuf::Message {
 public:
  TWifiCurDetailInfo();
  virtual ~TWifiCurDetailInfo();

  TWifiCurDetailInfo(const TWifiCurDetailInfo& from);

  inline TWifiCurDetailInfo& operator=(const TWifiCurDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWifiCurDetailInfo& default_instance();

  void Swap(TWifiCurDetailInfo* other);

  // implements Message ----------------------------------------------

  TWifiCurDetailInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWifiCurDetailInfo& from);
  void MergeFrom(const TWifiCurDetailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmWifiLinkState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::mt::EmWifiLinkState state() const;
  inline void set_state(::mt::EmWifiLinkState value);

  // optional int32 networkid = 2;
  inline bool has_networkid() const;
  inline void clear_networkid();
  static const int kNetworkidFieldNumber = 2;
  inline ::google::protobuf::int32 networkid() const;
  inline void set_networkid(::google::protobuf::int32 value);

  // optional string ssid = 3;
  inline bool has_ssid() const;
  inline void clear_ssid();
  static const int kSsidFieldNumber = 3;
  inline const ::std::string& ssid() const;
  inline void set_ssid(const ::std::string& value);
  inline void set_ssid(const char* value);
  inline void set_ssid(const char* value, size_t size);
  inline ::std::string* mutable_ssid();
  inline ::std::string* release_ssid();
  inline void set_allocated_ssid(::std::string* ssid);

  // optional string bssid = 4;
  inline bool has_bssid() const;
  inline void clear_bssid();
  static const int kBssidFieldNumber = 4;
  inline const ::std::string& bssid() const;
  inline void set_bssid(const ::std::string& value);
  inline void set_bssid(const char* value);
  inline void set_bssid(const char* value, size_t size);
  inline ::std::string* mutable_bssid();
  inline ::std::string* release_bssid();
  inline void set_allocated_bssid(::std::string* bssid);

  // optional string mac_address = 5;
  inline bool has_mac_address() const;
  inline void clear_mac_address();
  static const int kMacAddressFieldNumber = 5;
  inline const ::std::string& mac_address() const;
  inline void set_mac_address(const ::std::string& value);
  inline void set_mac_address(const char* value);
  inline void set_mac_address(const char* value, size_t size);
  inline ::std::string* mutable_mac_address();
  inline ::std::string* release_mac_address();
  inline void set_allocated_mac_address(::std::string* mac_address);

  // optional uint32 ip = 6;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 6;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 mask = 7;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 7;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);

  // optional uint32 gateway = 8;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 8;
  inline ::google::protobuf::uint32 gateway() const;
  inline void set_gateway(::google::protobuf::uint32 value);

  // optional .mt.EmWifiLinkErrReason reason = 9;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 9;
  inline ::mt::EmWifiLinkErrReason reason() const;
  inline void set_reason(::mt::EmWifiLinkErrReason value);

  // @@protoc_insertion_point(class_scope:mt.TWifiCurDetailInfo)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_networkid();
  inline void clear_has_networkid();
  inline void set_has_ssid();
  inline void clear_has_ssid();
  inline void set_has_bssid();
  inline void clear_has_bssid();
  inline void set_has_mac_address();
  inline void clear_has_mac_address();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_gateway();
  inline void clear_has_gateway();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;
  ::google::protobuf::int32 networkid_;
  ::std::string* ssid_;
  ::std::string* bssid_;
  ::std::string* mac_address_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 mask_;
  ::google::protobuf::uint32 gateway_;
  int reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TWifiCurDetailInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWifiStatisInfo : public ::google::protobuf::Message {
 public:
  TWifiStatisInfo();
  virtual ~TWifiStatisInfo();

  TWifiStatisInfo(const TWifiStatisInfo& from);

  inline TWifiStatisInfo& operator=(const TWifiStatisInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWifiStatisInfo& default_instance();

  void Swap(TWifiStatisInfo* other);

  // implements Message ----------------------------------------------

  TWifiStatisInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWifiStatisInfo& from);
  void MergeFrom(const TWifiStatisInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ssid = 1;
  inline bool has_ssid() const;
  inline void clear_ssid();
  static const int kSsidFieldNumber = 1;
  inline const ::std::string& ssid() const;
  inline void set_ssid(const ::std::string& value);
  inline void set_ssid(const char* value);
  inline void set_ssid(const char* value, size_t size);
  inline ::std::string* mutable_ssid();
  inline ::std::string* release_ssid();
  inline void set_allocated_ssid(::std::string* ssid);

  // optional int32 networkid = 2;
  inline bool has_networkid() const;
  inline void clear_networkid();
  static const int kNetworkidFieldNumber = 2;
  inline ::google::protobuf::int32 networkid() const;
  inline void set_networkid(::google::protobuf::int32 value);

  // optional .mt.EmWifiSignalLevel signalLevel = 3;
  inline bool has_signallevel() const;
  inline void clear_signallevel();
  static const int kSignalLevelFieldNumber = 3;
  inline ::mt::EmWifiSignalLevel signallevel() const;
  inline void set_signallevel(::mt::EmWifiSignalLevel value);

  // optional uint32 down_total_bytes = 4;
  inline bool has_down_total_bytes() const;
  inline void clear_down_total_bytes();
  static const int kDownTotalBytesFieldNumber = 4;
  inline ::google::protobuf::uint32 down_total_bytes() const;
  inline void set_down_total_bytes(::google::protobuf::uint32 value);

  // optional uint32 up_total_bytes = 5;
  inline bool has_up_total_bytes() const;
  inline void clear_up_total_bytes();
  static const int kUpTotalBytesFieldNumber = 5;
  inline ::google::protobuf::uint32 up_total_bytes() const;
  inline void set_up_total_bytes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TWifiStatisInfo)
 private:
  inline void set_has_ssid();
  inline void clear_has_ssid();
  inline void set_has_networkid();
  inline void clear_has_networkid();
  inline void set_has_signallevel();
  inline void clear_has_signallevel();
  inline void set_has_down_total_bytes();
  inline void clear_has_down_total_bytes();
  inline void set_has_up_total_bytes();
  inline void clear_has_up_total_bytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ssid_;
  ::google::protobuf::int32 networkid_;
  int signallevel_;
  ::google::protobuf::uint32 down_total_bytes_;
  ::google::protobuf::uint32 up_total_bytes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TWifiStatisInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWifiConnParam : public ::google::protobuf::Message {
 public:
  TWifiConnParam();
  virtual ~TWifiConnParam();

  TWifiConnParam(const TWifiConnParam& from);

  inline TWifiConnParam& operator=(const TWifiConnParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWifiConnParam& default_instance();

  void Swap(TWifiConnParam* other);

  // implements Message ----------------------------------------------

  TWifiConnParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWifiConnParam& from);
  void MergeFrom(const TWifiConnParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool issave = 1;
  inline bool has_issave() const;
  inline void clear_issave();
  static const int kIssaveFieldNumber = 1;
  inline bool issave() const;
  inline void set_issave(bool value);

  // optional string ssid = 2;
  inline bool has_ssid() const;
  inline void clear_ssid();
  static const int kSsidFieldNumber = 2;
  inline const ::std::string& ssid() const;
  inline void set_ssid(const ::std::string& value);
  inline void set_ssid(const char* value);
  inline void set_ssid(const char* value, size_t size);
  inline ::std::string* mutable_ssid();
  inline ::std::string* release_ssid();
  inline void set_allocated_ssid(::std::string* ssid);

  // optional .mt.EmWifiKeyType capabilities = 3;
  inline bool has_capabilities() const;
  inline void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 3;
  inline ::mt::EmWifiKeyType capabilities() const;
  inline void set_capabilities(::mt::EmWifiKeyType value);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional int32 networkid = 5;
  inline bool has_networkid() const;
  inline void clear_networkid();
  static const int kNetworkidFieldNumber = 5;
  inline ::google::protobuf::int32 networkid() const;
  inline void set_networkid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt.TWifiConnParam)
 private:
  inline void set_has_issave();
  inline void clear_has_issave();
  inline void set_has_ssid();
  inline void clear_has_ssid();
  inline void set_has_capabilities();
  inline void clear_has_capabilities();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_networkid();
  inline void clear_has_networkid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ssid_;
  bool issave_;
  int capabilities_;
  ::std::string* password_;
  ::google::protobuf::int32 networkid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TWifiConnParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMobileDataWorkMode : public ::google::protobuf::Message {
 public:
  TMobileDataWorkMode();
  virtual ~TMobileDataWorkMode();

  TMobileDataWorkMode(const TMobileDataWorkMode& from);

  inline TMobileDataWorkMode& operator=(const TMobileDataWorkMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMobileDataWorkMode& default_instance();

  void Swap(TMobileDataWorkMode* other);

  // implements Message ----------------------------------------------

  TMobileDataWorkMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMobileDataWorkMode& from);
  void MergeFrom(const TMobileDataWorkMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMobileDataWorkMode)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TMobileDataWorkMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMobileDataCurDetailInfo : public ::google::protobuf::Message {
 public:
  TMobileDataCurDetailInfo();
  virtual ~TMobileDataCurDetailInfo();

  TMobileDataCurDetailInfo(const TMobileDataCurDetailInfo& from);

  inline TMobileDataCurDetailInfo& operator=(const TMobileDataCurDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMobileDataCurDetailInfo& default_instance();

  void Swap(TMobileDataCurDetailInfo* other);

  // implements Message ----------------------------------------------

  TMobileDataCurDetailInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMobileDataCurDetailInfo& from);
  void MergeFrom(const TMobileDataCurDetailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMobileDataLinkState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::mt::EmMobileDataLinkState state() const;
  inline void set_state(::mt::EmMobileDataLinkState value);

  // optional .mt.EmMobileDataNetType emNetType = 2;
  inline bool has_emnettype() const;
  inline void clear_emnettype();
  static const int kEmNetTypeFieldNumber = 2;
  inline ::mt::EmMobileDataNetType emnettype() const;
  inline void set_emnettype(::mt::EmMobileDataNetType value);

  // optional .mt.EmMobileDataNetGenerationType emGenerationType = 3;
  inline bool has_emgenerationtype() const;
  inline void clear_emgenerationtype();
  static const int kEmGenerationTypeFieldNumber = 3;
  inline ::mt::EmMobileDataNetGenerationType emgenerationtype() const;
  inline void set_emgenerationtype(::mt::EmMobileDataNetGenerationType value);

  // optional string ssid = 4;
  inline bool has_ssid() const;
  inline void clear_ssid();
  static const int kSsidFieldNumber = 4;
  inline const ::std::string& ssid() const;
  inline void set_ssid(const ::std::string& value);
  inline void set_ssid(const char* value);
  inline void set_ssid(const char* value, size_t size);
  inline ::std::string* mutable_ssid();
  inline ::std::string* release_ssid();
  inline void set_allocated_ssid(::std::string* ssid);

  // optional uint32 ip = 5;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 5;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional string conn_time = 6;
  inline bool has_conn_time() const;
  inline void clear_conn_time();
  static const int kConnTimeFieldNumber = 6;
  inline const ::std::string& conn_time() const;
  inline void set_conn_time(const ::std::string& value);
  inline void set_conn_time(const char* value);
  inline void set_conn_time(const char* value, size_t size);
  inline ::std::string* mutable_conn_time();
  inline ::std::string* release_conn_time();
  inline void set_allocated_conn_time(::std::string* conn_time);

  // optional .mt.EmMobileDataLinkErrReason reason = 7;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 7;
  inline ::mt::EmMobileDataLinkErrReason reason() const;
  inline void set_reason(::mt::EmMobileDataLinkErrReason value);

  // @@protoc_insertion_point(class_scope:mt.TMobileDataCurDetailInfo)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_emnettype();
  inline void clear_has_emnettype();
  inline void set_has_emgenerationtype();
  inline void clear_has_emgenerationtype();
  inline void set_has_ssid();
  inline void clear_has_ssid();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_conn_time();
  inline void clear_has_conn_time();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;
  int emnettype_;
  ::std::string* ssid_;
  int emgenerationtype_;
  ::google::protobuf::uint32 ip_;
  ::std::string* conn_time_;
  int reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TMobileDataCurDetailInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMobileDataStatisInfo : public ::google::protobuf::Message {
 public:
  TMobileDataStatisInfo();
  virtual ~TMobileDataStatisInfo();

  TMobileDataStatisInfo(const TMobileDataStatisInfo& from);

  inline TMobileDataStatisInfo& operator=(const TMobileDataStatisInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMobileDataStatisInfo& default_instance();

  void Swap(TMobileDataStatisInfo* other);

  // implements Message ----------------------------------------------

  TMobileDataStatisInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMobileDataStatisInfo& from);
  void MergeFrom(const TMobileDataStatisInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMobileDataSignalLevel signalLevel = 1;
  inline bool has_signallevel() const;
  inline void clear_signallevel();
  static const int kSignalLevelFieldNumber = 1;
  inline ::mt::EmMobileDataSignalLevel signallevel() const;
  inline void set_signallevel(::mt::EmMobileDataSignalLevel value);

  // optional uint32 up_bandwidth = 2;
  inline bool has_up_bandwidth() const;
  inline void clear_up_bandwidth();
  static const int kUpBandwidthFieldNumber = 2;
  inline ::google::protobuf::uint32 up_bandwidth() const;
  inline void set_up_bandwidth(::google::protobuf::uint32 value);

  // optional uint32 down_bandwidth = 3;
  inline bool has_down_bandwidth() const;
  inline void clear_down_bandwidth();
  static const int kDownBandwidthFieldNumber = 3;
  inline ::google::protobuf::uint32 down_bandwidth() const;
  inline void set_down_bandwidth(::google::protobuf::uint32 value);

  // optional uint32 up_bytes = 4;
  inline bool has_up_bytes() const;
  inline void clear_up_bytes();
  static const int kUpBytesFieldNumber = 4;
  inline ::google::protobuf::uint32 up_bytes() const;
  inline void set_up_bytes(::google::protobuf::uint32 value);

  // optional uint32 down_bytes = 5;
  inline bool has_down_bytes() const;
  inline void clear_down_bytes();
  static const int kDownBytesFieldNumber = 5;
  inline ::google::protobuf::uint32 down_bytes() const;
  inline void set_down_bytes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMobileDataStatisInfo)
 private:
  inline void set_has_signallevel();
  inline void clear_has_signallevel();
  inline void set_has_up_bandwidth();
  inline void clear_has_up_bandwidth();
  inline void set_has_down_bandwidth();
  inline void clear_has_down_bandwidth();
  inline void set_has_up_bytes();
  inline void clear_has_up_bytes();
  inline void set_has_down_bytes();
  inline void clear_has_down_bytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int signallevel_;
  ::google::protobuf::uint32 up_bandwidth_;
  ::google::protobuf::uint32 down_bandwidth_;
  ::google::protobuf::uint32 up_bytes_;
  ::google::protobuf::uint32 down_bytes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TMobileDataStatisInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRouteItemInfo : public ::google::protobuf::Message {
 public:
  TRouteItemInfo();
  virtual ~TRouteItemInfo();

  TRouteItemInfo(const TRouteItemInfo& from);

  inline TRouteItemInfo& operator=(const TRouteItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRouteItemInfo& default_instance();

  void Swap(TRouteItemInfo* other);

  // implements Message ----------------------------------------------

  TRouteItemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRouteItemInfo& from);
  void MergeFrom(const TRouteItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 interface = 1;
  inline bool has_interface() const;
  inline void clear_interface();
  static const int kInterfaceFieldNumber = 1;
  inline ::google::protobuf::uint32 interface() const;
  inline void set_interface(::google::protobuf::uint32 value);

  // optional uint32 dest_network = 2;
  inline bool has_dest_network() const;
  inline void clear_dest_network();
  static const int kDestNetworkFieldNumber = 2;
  inline ::google::protobuf::uint32 dest_network() const;
  inline void set_dest_network(::google::protobuf::uint32 value);

  // optional uint32 dest_netmask = 3;
  inline bool has_dest_netmask() const;
  inline void clear_dest_netmask();
  static const int kDestNetmaskFieldNumber = 3;
  inline ::google::protobuf::uint32 dest_netmask() const;
  inline void set_dest_netmask(::google::protobuf::uint32 value);

  // optional uint32 gateway = 4;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 4;
  inline ::google::protobuf::uint32 gateway() const;
  inline void set_gateway(::google::protobuf::uint32 value);

  // optional uint32 priority = 5;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 5;
  inline ::google::protobuf::uint32 priority() const;
  inline void set_priority(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TRouteItemInfo)
 private:
  inline void set_has_interface();
  inline void clear_has_interface();
  inline void set_has_dest_network();
  inline void clear_has_dest_network();
  inline void set_has_dest_netmask();
  inline void clear_has_dest_netmask();
  inline void set_has_gateway();
  inline void clear_has_gateway();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 interface_;
  ::google::protobuf::uint32 dest_network_;
  ::google::protobuf::uint32 dest_netmask_;
  ::google::protobuf::uint32 gateway_;
  ::google::protobuf::uint32 priority_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TRouteItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRouteItemInfoList : public ::google::protobuf::Message {
 public:
  TRouteItemInfoList();
  virtual ~TRouteItemInfoList();

  TRouteItemInfoList(const TRouteItemInfoList& from);

  inline TRouteItemInfoList& operator=(const TRouteItemInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRouteItemInfoList& default_instance();

  void Swap(TRouteItemInfoList* other);

  // implements Message ----------------------------------------------

  TRouteItemInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRouteItemInfoList& from);
  void MergeFrom(const TRouteItemInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TRouteItemInfo route_list = 1;
  inline int route_list_size() const;
  inline void clear_route_list();
  static const int kRouteListFieldNumber = 1;
  inline const ::mt::TRouteItemInfo& route_list(int index) const;
  inline ::mt::TRouteItemInfo* mutable_route_list(int index);
  inline ::mt::TRouteItemInfo* add_route_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TRouteItemInfo >&
      route_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TRouteItemInfo >*
      mutable_route_list();

  // @@protoc_insertion_point(class_scope:mt.TRouteItemInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TRouteItemInfo > route_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TRouteItemInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TE1RouteItemInfo : public ::google::protobuf::Message {
 public:
  TE1RouteItemInfo();
  virtual ~TE1RouteItemInfo();

  TE1RouteItemInfo(const TE1RouteItemInfo& from);

  inline TE1RouteItemInfo& operator=(const TE1RouteItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TE1RouteItemInfo& default_instance();

  void Swap(TE1RouteItemInfo* other);

  // implements Message ----------------------------------------------

  TE1RouteItemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TE1RouteItemInfo& from);
  void MergeFrom(const TE1RouteItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 interface = 1;
  inline bool has_interface() const;
  inline void clear_interface();
  static const int kInterfaceFieldNumber = 1;
  inline ::google::protobuf::uint32 interface() const;
  inline void set_interface(::google::protobuf::uint32 value);

  // optional uint32 dest_network = 2;
  inline bool has_dest_network() const;
  inline void clear_dest_network();
  static const int kDestNetworkFieldNumber = 2;
  inline ::google::protobuf::uint32 dest_network() const;
  inline void set_dest_network(::google::protobuf::uint32 value);

  // optional uint32 dest_netmask = 3;
  inline bool has_dest_netmask() const;
  inline void clear_dest_netmask();
  static const int kDestNetmaskFieldNumber = 3;
  inline ::google::protobuf::uint32 dest_netmask() const;
  inline void set_dest_netmask(::google::protobuf::uint32 value);

  // optional uint32 gateway = 4;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 4;
  inline ::google::protobuf::uint32 gateway() const;
  inline void set_gateway(::google::protobuf::uint32 value);

  // optional uint32 priority = 5;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 5;
  inline ::google::protobuf::uint32 priority() const;
  inline void set_priority(::google::protobuf::uint32 value);

  // optional string ifname = 6;
  inline bool has_ifname() const;
  inline void clear_ifname();
  static const int kIfnameFieldNumber = 6;
  inline const ::std::string& ifname() const;
  inline void set_ifname(const ::std::string& value);
  inline void set_ifname(const char* value);
  inline void set_ifname(const char* value, size_t size);
  inline ::std::string* mutable_ifname();
  inline ::std::string* release_ifname();
  inline void set_allocated_ifname(::std::string* ifname);

  // @@protoc_insertion_point(class_scope:mt.TE1RouteItemInfo)
 private:
  inline void set_has_interface();
  inline void clear_has_interface();
  inline void set_has_dest_network();
  inline void clear_has_dest_network();
  inline void set_has_dest_netmask();
  inline void clear_has_dest_netmask();
  inline void set_has_gateway();
  inline void clear_has_gateway();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_ifname();
  inline void clear_has_ifname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 interface_;
  ::google::protobuf::uint32 dest_network_;
  ::google::protobuf::uint32 dest_netmask_;
  ::google::protobuf::uint32 gateway_;
  ::std::string* ifname_;
  ::google::protobuf::uint32 priority_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TE1RouteItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TE1RouteItemInfoList : public ::google::protobuf::Message {
 public:
  TE1RouteItemInfoList();
  virtual ~TE1RouteItemInfoList();

  TE1RouteItemInfoList(const TE1RouteItemInfoList& from);

  inline TE1RouteItemInfoList& operator=(const TE1RouteItemInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TE1RouteItemInfoList& default_instance();

  void Swap(TE1RouteItemInfoList* other);

  // implements Message ----------------------------------------------

  TE1RouteItemInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TE1RouteItemInfoList& from);
  void MergeFrom(const TE1RouteItemInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TE1RouteItemInfo route_list = 1;
  inline int route_list_size() const;
  inline void clear_route_list();
  static const int kRouteListFieldNumber = 1;
  inline const ::mt::TE1RouteItemInfo& route_list(int index) const;
  inline ::mt::TE1RouteItemInfo* mutable_route_list(int index);
  inline ::mt::TE1RouteItemInfo* add_route_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TE1RouteItemInfo >&
      route_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TE1RouteItemInfo >*
      mutable_route_list();

  // @@protoc_insertion_point(class_scope:mt.TE1RouteItemInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TE1RouteItemInfo > route_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TE1RouteItemInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNetUsedInfo : public ::google::protobuf::Message {
 public:
  TNetUsedInfo();
  virtual ~TNetUsedInfo();

  TNetUsedInfo(const TNetUsedInfo& from);

  inline TNetUsedInfo& operator=(const TNetUsedInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNetUsedInfo& default_instance();

  void Swap(TNetUsedInfo* other);

  // implements Message ----------------------------------------------

  TNetUsedInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNetUsedInfo& from);
  void MergeFrom(const TNetUsedInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmNetAdapterWorkType used_type = 1;
  inline bool has_used_type() const;
  inline void clear_used_type();
  static const int kUsedTypeFieldNumber = 1;
  inline ::mt::EmNetAdapterWorkType used_type() const;
  inline void set_used_type(::mt::EmNetAdapterWorkType value);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 mask = 3;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 3;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);

  // optional uint32 gateway_ip = 4;
  inline bool has_gateway_ip() const;
  inline void clear_gateway_ip();
  static const int kGatewayIpFieldNumber = 4;
  inline ::google::protobuf::uint32 gateway_ip() const;
  inline void set_gateway_ip(::google::protobuf::uint32 value);

  // optional uint32 dns = 5;
  inline bool has_dns() const;
  inline void clear_dns();
  static const int kDnsFieldNumber = 5;
  inline ::google::protobuf::uint32 dns() const;
  inline void set_dns(::google::protobuf::uint32 value);

  // optional uint32 dns_backup = 6;
  inline bool has_dns_backup() const;
  inline void clear_dns_backup();
  static const int kDnsBackupFieldNumber = 6;
  inline ::google::protobuf::uint32 dns_backup() const;
  inline void set_dns_backup(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TNetUsedInfo)
 private:
  inline void set_has_used_type();
  inline void clear_has_used_type();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_gateway_ip();
  inline void clear_has_gateway_ip();
  inline void set_has_dns();
  inline void clear_has_dns();
  inline void set_has_dns_backup();
  inline void clear_has_dns_backup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int used_type_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 mask_;
  ::google::protobuf::uint32 gateway_ip_;
  ::google::protobuf::uint32 dns_;
  ::google::protobuf::uint32 dns_backup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TNetUsedInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTNTPInfo : public ::google::protobuf::Message {
 public:
  TMTNTPInfo();
  virtual ~TMTNTPInfo();

  TMTNTPInfo(const TMTNTPInfo& from);

  inline TMTNTPInfo& operator=(const TMTNTPInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTNTPInfo& default_instance();

  void Swap(TMTNTPInfo* other);

  // implements Message ----------------------------------------------

  TMTNTPInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTNTPInfo& from);
  void MergeFrom(const TMTNTPInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool used_ntp = 1;
  inline bool has_used_ntp() const;
  inline void clear_used_ntp();
  static const int kUsedNtpFieldNumber = 1;
  inline bool used_ntp() const;
  inline void set_used_ntp(bool value);

  // optional string domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 interval = 3;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 3;
  inline ::google::protobuf::uint32 interval() const;
  inline void set_interval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTNTPInfo)
 private:
  inline void set_has_used_ntp();
  inline void clear_has_used_ntp();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_interval();
  inline void clear_has_interval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  bool used_ntp_;
  ::google::protobuf::uint32 interval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TMTNTPInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTimeZoneInfo : public ::google::protobuf::Message {
 public:
  TMTTimeZoneInfo();
  virtual ~TMTTimeZoneInfo();

  TMTTimeZoneInfo(const TMTTimeZoneInfo& from);

  inline TMTTimeZoneInfo& operator=(const TMTTimeZoneInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTimeZoneInfo& default_instance();

  void Swap(TMTTimeZoneInfo* other);

  // implements Message ----------------------------------------------

  TMTTimeZoneInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTimeZoneInfo& from);
  void MergeFrom(const TMTTimeZoneInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmTimeZone time_zone = 1;
  inline bool has_time_zone() const;
  inline void clear_time_zone();
  static const int kTimeZoneFieldNumber = 1;
  inline ::mt::EmTimeZone time_zone() const;
  inline void set_time_zone(::mt::EmTimeZone value);

  // @@protoc_insertion_point(class_scope:mt.TMTTimeZoneInfo)
 private:
  inline void set_has_time_zone();
  inline void clear_has_time_zone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int time_zone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TMTTimeZoneInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTFtpTelnetAccountInfo : public ::google::protobuf::Message {
 public:
  TMTFtpTelnetAccountInfo();
  virtual ~TMTFtpTelnetAccountInfo();

  TMTFtpTelnetAccountInfo(const TMTFtpTelnetAccountInfo& from);

  inline TMTFtpTelnetAccountInfo& operator=(const TMTFtpTelnetAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTFtpTelnetAccountInfo& default_instance();

  void Swap(TMTFtpTelnetAccountInfo* other);

  // implements Message ----------------------------------------------

  TMTFtpTelnetAccountInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTFtpTelnetAccountInfo& from);
  void MergeFrom(const TMTFtpTelnetAccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:mt.TMTFtpTelnetAccountInfo)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TMTFtpTelnetAccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TServerTestResult : public ::google::protobuf::Message {
 public:
  TServerTestResult();
  virtual ~TServerTestResult();

  TServerTestResult(const TServerTestResult& from);

  inline TServerTestResult& operator=(const TServerTestResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TServerTestResult& default_instance();

  void Swap(TServerTestResult* other);

  // implements Message ----------------------------------------------

  TServerTestResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TServerTestResult& from);
  void MergeFrom(const TServerTestResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::uint32 userid() const;
  inline void set_userid(::google::protobuf::uint32 value);

  // optional bool isok = 2;
  inline bool has_isok() const;
  inline void clear_isok();
  static const int kIsokFieldNumber = 2;
  inline bool isok() const;
  inline void set_isok(bool value);

  // @@protoc_insertion_point(class_scope:mt.TServerTestResult)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_isok();
  inline void clear_has_isok();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 userid_;
  bool isok_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TServerTestResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TWifiWirelessScreenInfo : public ::google::protobuf::Message {
 public:
  TWifiWirelessScreenInfo();
  virtual ~TWifiWirelessScreenInfo();

  TWifiWirelessScreenInfo(const TWifiWirelessScreenInfo& from);

  inline TWifiWirelessScreenInfo& operator=(const TWifiWirelessScreenInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TWifiWirelessScreenInfo& default_instance();

  void Swap(TWifiWirelessScreenInfo* other);

  // implements Message ----------------------------------------------

  TWifiWirelessScreenInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TWifiWirelessScreenInfo& from);
  void MergeFrom(const TWifiWirelessScreenInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmWirelessScreenState wirelessScreen_state = 1;
  inline bool has_wirelessscreen_state() const;
  inline void clear_wirelessscreen_state();
  static const int kWirelessScreenStateFieldNumber = 1;
  inline ::mt::EmWirelessScreenState wirelessscreen_state() const;
  inline void set_wirelessscreen_state(::mt::EmWirelessScreenState value);

  // optional uint32 wirelessScreen_deviceNum = 2;
  inline bool has_wirelessscreen_devicenum() const;
  inline void clear_wirelessscreen_devicenum();
  static const int kWirelessScreenDeviceNumFieldNumber = 2;
  inline ::google::protobuf::uint32 wirelessscreen_devicenum() const;
  inline void set_wirelessscreen_devicenum(::google::protobuf::uint32 value);

  // optional .mt.EmWirelessScreenErrReason wirelessScreen_ErrReason = 3;
  inline bool has_wirelessscreen_errreason() const;
  inline void clear_wirelessscreen_errreason();
  static const int kWirelessScreenErrReasonFieldNumber = 3;
  inline ::mt::EmWirelessScreenErrReason wirelessscreen_errreason() const;
  inline void set_wirelessscreen_errreason(::mt::EmWirelessScreenErrReason value);

  // @@protoc_insertion_point(class_scope:mt.TWifiWirelessScreenInfo)
 private:
  inline void set_has_wirelessscreen_state();
  inline void clear_has_wirelessscreen_state();
  inline void set_has_wirelessscreen_devicenum();
  inline void clear_has_wirelessscreen_devicenum();
  inline void set_has_wirelessscreen_errreason();
  inline void clear_has_wirelessscreen_errreason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int wirelessscreen_state_;
  ::google::protobuf::uint32 wirelessscreen_devicenum_;
  int wirelessscreen_errreason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TWifiWirelessScreenInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TLimitedIpItemInfo : public ::google::protobuf::Message {
 public:
  TLimitedIpItemInfo();
  virtual ~TLimitedIpItemInfo();

  TLimitedIpItemInfo(const TLimitedIpItemInfo& from);

  inline TLimitedIpItemInfo& operator=(const TLimitedIpItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLimitedIpItemInfo& default_instance();

  void Swap(TLimitedIpItemInfo* other);

  // implements Message ----------------------------------------------

  TLimitedIpItemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLimitedIpItemInfo& from);
  void MergeFrom(const TLimitedIpItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start_ip = 1;
  inline bool has_start_ip() const;
  inline void clear_start_ip();
  static const int kStartIpFieldNumber = 1;
  inline ::google::protobuf::uint32 start_ip() const;
  inline void set_start_ip(::google::protobuf::uint32 value);

  // optional uint32 end_ip = 2;
  inline bool has_end_ip() const;
  inline void clear_end_ip();
  static const int kEndIpFieldNumber = 2;
  inline ::google::protobuf::uint32 end_ip() const;
  inline void set_end_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TLimitedIpItemInfo)
 private:
  inline void set_has_start_ip();
  inline void clear_has_start_ip();
  inline void set_has_end_ip();
  inline void clear_has_end_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 start_ip_;
  ::google::protobuf::uint32 end_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TLimitedIpItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TLimitedIpCfg : public ::google::protobuf::Message {
 public:
  TLimitedIpCfg();
  virtual ~TLimitedIpCfg();

  TLimitedIpCfg(const TLimitedIpCfg& from);

  inline TLimitedIpCfg& operator=(const TLimitedIpCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLimitedIpCfg& default_instance();

  void Swap(TLimitedIpCfg* other);

  // implements Message ----------------------------------------------

  TLimitedIpCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLimitedIpCfg& from);
  void MergeFrom(const TLimitedIpCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional .mt.EmLimitedIpType limitedIp_type = 2;
  inline bool has_limitedip_type() const;
  inline void clear_limitedip_type();
  static const int kLimitedIpTypeFieldNumber = 2;
  inline ::mt::EmLimitedIpType limitedip_type() const;
  inline void set_limitedip_type(::mt::EmLimitedIpType value);

  // repeated .mt.TLimitedIpItemInfo limitedIp_List = 3;
  inline int limitedip_list_size() const;
  inline void clear_limitedip_list();
  static const int kLimitedIpListFieldNumber = 3;
  inline const ::mt::TLimitedIpItemInfo& limitedip_list(int index) const;
  inline ::mt::TLimitedIpItemInfo* mutable_limitedip_list(int index);
  inline ::mt::TLimitedIpItemInfo* add_limitedip_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TLimitedIpItemInfo >&
      limitedip_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TLimitedIpItemInfo >*
      mutable_limitedip_list();

  // @@protoc_insertion_point(class_scope:mt.TLimitedIpCfg)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_limitedip_type();
  inline void clear_has_limitedip_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  int limitedip_type_;
  ::google::protobuf::RepeatedPtrField< ::mt::TLimitedIpItemInfo > limitedip_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TLimitedIpCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNetCardStatis : public ::google::protobuf::Message {
 public:
  TNetCardStatis();
  virtual ~TNetCardStatis();

  TNetCardStatis(const TNetCardStatis& from);

  inline TNetCardStatis& operator=(const TNetCardStatis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNetCardStatis& default_instance();

  void Swap(TNetCardStatis* other);

  // implements Message ----------------------------------------------

  TNetCardStatis* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNetCardStatis& from);
  void MergeFrom(const TNetCardStatis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string netcard_name = 1;
  inline bool has_netcard_name() const;
  inline void clear_netcard_name();
  static const int kNetcardNameFieldNumber = 1;
  inline const ::std::string& netcard_name() const;
  inline void set_netcard_name(const ::std::string& value);
  inline void set_netcard_name(const char* value);
  inline void set_netcard_name(const char* value, size_t size);
  inline ::std::string* mutable_netcard_name();
  inline ::std::string* release_netcard_name();
  inline void set_allocated_netcard_name(::std::string* netcard_name);

  // optional uint32 send_flow_amount = 2;
  inline bool has_send_flow_amount() const;
  inline void clear_send_flow_amount();
  static const int kSendFlowAmountFieldNumber = 2;
  inline ::google::protobuf::uint32 send_flow_amount() const;
  inline void set_send_flow_amount(::google::protobuf::uint32 value);

  // optional uint32 recv_flow_amount = 3;
  inline bool has_recv_flow_amount() const;
  inline void clear_recv_flow_amount();
  static const int kRecvFlowAmountFieldNumber = 3;
  inline ::google::protobuf::uint32 recv_flow_amount() const;
  inline void set_recv_flow_amount(::google::protobuf::uint32 value);

  // optional .mt.EmNetAdapterWorkType netcard_type = 4;
  inline bool has_netcard_type() const;
  inline void clear_netcard_type();
  static const int kNetcardTypeFieldNumber = 4;
  inline ::mt::EmNetAdapterWorkType netcard_type() const;
  inline void set_netcard_type(::mt::EmNetAdapterWorkType value);

  // @@protoc_insertion_point(class_scope:mt.TNetCardStatis)
 private:
  inline void set_has_netcard_name();
  inline void clear_has_netcard_name();
  inline void set_has_send_flow_amount();
  inline void clear_has_send_flow_amount();
  inline void set_has_recv_flow_amount();
  inline void clear_has_recv_flow_amount();
  inline void set_has_netcard_type();
  inline void clear_has_netcard_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* netcard_name_;
  ::google::protobuf::uint32 send_flow_amount_;
  ::google::protobuf::uint32 recv_flow_amount_;
  int netcard_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TNetCardStatis* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNetCardStatisList : public ::google::protobuf::Message {
 public:
  TNetCardStatisList();
  virtual ~TNetCardStatisList();

  TNetCardStatisList(const TNetCardStatisList& from);

  inline TNetCardStatisList& operator=(const TNetCardStatisList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNetCardStatisList& default_instance();

  void Swap(TNetCardStatisList* other);

  // implements Message ----------------------------------------------

  TNetCardStatisList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNetCardStatisList& from);
  void MergeFrom(const TNetCardStatisList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 netcard_num = 1;
  inline bool has_netcard_num() const;
  inline void clear_netcard_num();
  static const int kNetcardNumFieldNumber = 1;
  inline ::google::protobuf::uint32 netcard_num() const;
  inline void set_netcard_num(::google::protobuf::uint32 value);

  // repeated .mt.TNetCardStatis netcard_statis = 2;
  inline int netcard_statis_size() const;
  inline void clear_netcard_statis();
  static const int kNetcardStatisFieldNumber = 2;
  inline const ::mt::TNetCardStatis& netcard_statis(int index) const;
  inline ::mt::TNetCardStatis* mutable_netcard_statis(int index);
  inline ::mt::TNetCardStatis* add_netcard_statis();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TNetCardStatis >&
      netcard_statis() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TNetCardStatis >*
      mutable_netcard_statis();

  // @@protoc_insertion_point(class_scope:mt.TNetCardStatisList)
 private:
  inline void set_has_netcard_num();
  inline void clear_has_netcard_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TNetCardStatis > netcard_statis_;
  ::google::protobuf::uint32 netcard_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structnet_2eproto();
  friend void protobuf_AssignDesc_structnet_2eproto();
  friend void protobuf_ShutdownFile_structnet_2eproto();

  void InitAsDefaultInstance();
  static TNetCardStatisList* default_instance_;
};
// ===================================================================


// ===================================================================

// TEthnetWorkModeList

// optional .mt.EmEthnetWorkMode card1_workmode = 1;
inline bool TEthnetWorkModeList::has_card1_workmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TEthnetWorkModeList::set_has_card1_workmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TEthnetWorkModeList::clear_has_card1_workmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TEthnetWorkModeList::clear_card1_workmode() {
  card1_workmode_ = 0;
  clear_has_card1_workmode();
}
inline ::mt::EmEthnetWorkMode TEthnetWorkModeList::card1_workmode() const {
  return static_cast< ::mt::EmEthnetWorkMode >(card1_workmode_);
}
inline void TEthnetWorkModeList::set_card1_workmode(::mt::EmEthnetWorkMode value) {
  assert(::mt::EmEthnetWorkMode_IsValid(value));
  set_has_card1_workmode();
  card1_workmode_ = value;
}

// optional .mt.EmEthnetWorkMode card2_workmode = 2;
inline bool TEthnetWorkModeList::has_card2_workmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TEthnetWorkModeList::set_has_card2_workmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TEthnetWorkModeList::clear_has_card2_workmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TEthnetWorkModeList::clear_card2_workmode() {
  card2_workmode_ = 0;
  clear_has_card2_workmode();
}
inline ::mt::EmEthnetWorkMode TEthnetWorkModeList::card2_workmode() const {
  return static_cast< ::mt::EmEthnetWorkMode >(card2_workmode_);
}
inline void TEthnetWorkModeList::set_card2_workmode(::mt::EmEthnetWorkMode value) {
  assert(::mt::EmEthnetWorkMode_IsValid(value));
  set_has_card2_workmode();
  card2_workmode_ = value;
}

// -------------------------------------------------------------------

// TEthnetInterfaceParam

// optional uint32 ip = 1;
inline bool TEthnetInterfaceParam::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TEthnetInterfaceParam::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TEthnetInterfaceParam::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TEthnetInterfaceParam::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TEthnetInterfaceParam::ip() const {
  return ip_;
}
inline void TEthnetInterfaceParam::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 mask = 2;
inline bool TEthnetInterfaceParam::has_mask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TEthnetInterfaceParam::set_has_mask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TEthnetInterfaceParam::clear_has_mask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TEthnetInterfaceParam::clear_mask() {
  mask_ = 0u;
  clear_has_mask();
}
inline ::google::protobuf::uint32 TEthnetInterfaceParam::mask() const {
  return mask_;
}
inline void TEthnetInterfaceParam::set_mask(::google::protobuf::uint32 value) {
  set_has_mask();
  mask_ = value;
}

// optional string mac = 3;
inline bool TEthnetInterfaceParam::has_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TEthnetInterfaceParam::set_has_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TEthnetInterfaceParam::clear_has_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TEthnetInterfaceParam::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& TEthnetInterfaceParam::mac() const {
  return *mac_;
}
inline void TEthnetInterfaceParam::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void TEthnetInterfaceParam::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void TEthnetInterfaceParam::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TEthnetInterfaceParam::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* TEthnetInterfaceParam::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TEthnetInterfaceParam::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TEthnetInterfaceParamList

// repeated .mt.TEthnetInterfaceParam paramList = 1;
inline int TEthnetInterfaceParamList::paramlist_size() const {
  return paramlist_.size();
}
inline void TEthnetInterfaceParamList::clear_paramlist() {
  paramlist_.Clear();
}
inline const ::mt::TEthnetInterfaceParam& TEthnetInterfaceParamList::paramlist(int index) const {
  return paramlist_.Get(index);
}
inline ::mt::TEthnetInterfaceParam* TEthnetInterfaceParamList::mutable_paramlist(int index) {
  return paramlist_.Mutable(index);
}
inline ::mt::TEthnetInterfaceParam* TEthnetInterfaceParamList::add_paramlist() {
  return paramlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TEthnetInterfaceParam >&
TEthnetInterfaceParamList::paramlist() const {
  return paramlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TEthnetInterfaceParam >*
TEthnetInterfaceParamList::mutable_paramlist() {
  return &paramlist_;
}

// -------------------------------------------------------------------

// TDNSParam

// repeated uint32 dnsList = 1;
inline int TDNSParam::dnslist_size() const {
  return dnslist_.size();
}
inline void TDNSParam::clear_dnslist() {
  dnslist_.Clear();
}
inline ::google::protobuf::uint32 TDNSParam::dnslist(int index) const {
  return dnslist_.Get(index);
}
inline void TDNSParam::set_dnslist(int index, ::google::protobuf::uint32 value) {
  dnslist_.Set(index, value);
}
inline void TDNSParam::add_dnslist(::google::protobuf::uint32 value) {
  dnslist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TDNSParam::dnslist() const {
  return dnslist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TDNSParam::mutable_dnslist() {
  return &dnslist_;
}

// optional bool auto = 2;
inline bool TDNSParam::has_auto_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDNSParam::set_has_auto_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDNSParam::clear_has_auto_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDNSParam::clear_auto_() {
  auto__ = false;
  clear_has_auto_();
}
inline bool TDNSParam::auto_() const {
  return auto__;
}
inline void TDNSParam::set_auto_(bool value) {
  set_has_auto_();
  auto__ = value;
}

// -------------------------------------------------------------------

// TDHCPLeaseInfo

// optional uint32 ethernetid = 1;
inline bool TDHCPLeaseInfo::has_ethernetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDHCPLeaseInfo::set_has_ethernetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDHCPLeaseInfo::clear_has_ethernetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDHCPLeaseInfo::clear_ethernetid() {
  ethernetid_ = 0u;
  clear_has_ethernetid();
}
inline ::google::protobuf::uint32 TDHCPLeaseInfo::ethernetid() const {
  return ethernetid_;
}
inline void TDHCPLeaseInfo::set_ethernetid(::google::protobuf::uint32 value) {
  set_has_ethernetid();
  ethernetid_ = value;
}

// optional uint32 ip = 2;
inline bool TDHCPLeaseInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDHCPLeaseInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDHCPLeaseInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDHCPLeaseInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TDHCPLeaseInfo::ip() const {
  return ip_;
}
inline void TDHCPLeaseInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 mask = 3;
inline bool TDHCPLeaseInfo::has_mask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TDHCPLeaseInfo::set_has_mask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TDHCPLeaseInfo::clear_has_mask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TDHCPLeaseInfo::clear_mask() {
  mask_ = 0u;
  clear_has_mask();
}
inline ::google::protobuf::uint32 TDHCPLeaseInfo::mask() const {
  return mask_;
}
inline void TDHCPLeaseInfo::set_mask(::google::protobuf::uint32 value) {
  set_has_mask();
  mask_ = value;
}

// optional uint32 gateway = 4;
inline bool TDHCPLeaseInfo::has_gateway() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TDHCPLeaseInfo::set_has_gateway() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TDHCPLeaseInfo::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TDHCPLeaseInfo::clear_gateway() {
  gateway_ = 0u;
  clear_has_gateway();
}
inline ::google::protobuf::uint32 TDHCPLeaseInfo::gateway() const {
  return gateway_;
}
inline void TDHCPLeaseInfo::set_gateway(::google::protobuf::uint32 value) {
  set_has_gateway();
  gateway_ = value;
}

// optional uint32 duration = 5;
inline bool TDHCPLeaseInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TDHCPLeaseInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TDHCPLeaseInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TDHCPLeaseInfo::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TDHCPLeaseInfo::duration() const {
  return duration_;
}
inline void TDHCPLeaseInfo::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 dnsnum = 6;
inline bool TDHCPLeaseInfo::has_dnsnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TDHCPLeaseInfo::set_has_dnsnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TDHCPLeaseInfo::clear_has_dnsnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TDHCPLeaseInfo::clear_dnsnum() {
  dnsnum_ = 0u;
  clear_has_dnsnum();
}
inline ::google::protobuf::uint32 TDHCPLeaseInfo::dnsnum() const {
  return dnsnum_;
}
inline void TDHCPLeaseInfo::set_dnsnum(::google::protobuf::uint32 value) {
  set_has_dnsnum();
  dnsnum_ = value;
}

// repeated uint32 dns_server_list = 7;
inline int TDHCPLeaseInfo::dns_server_list_size() const {
  return dns_server_list_.size();
}
inline void TDHCPLeaseInfo::clear_dns_server_list() {
  dns_server_list_.Clear();
}
inline ::google::protobuf::uint32 TDHCPLeaseInfo::dns_server_list(int index) const {
  return dns_server_list_.Get(index);
}
inline void TDHCPLeaseInfo::set_dns_server_list(int index, ::google::protobuf::uint32 value) {
  dns_server_list_.Set(index, value);
}
inline void TDHCPLeaseInfo::add_dns_server_list(::google::protobuf::uint32 value) {
  dns_server_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TDHCPLeaseInfo::dns_server_list() const {
  return dns_server_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TDHCPLeaseInfo::mutable_dns_server_list() {
  return &dns_server_list_;
}

// -------------------------------------------------------------------

// TDHCPStateInfo

// optional int32 state = 1;
inline bool TDHCPStateInfo::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDHCPStateInfo::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDHCPStateInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDHCPStateInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 TDHCPStateInfo::state() const {
  return state_;
}
inline void TDHCPStateInfo::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// TPPPoEConnectParam

// optional uint32 ethernetid = 1;
inline bool TPPPoEConnectParam::has_ethernetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPPPoEConnectParam::set_has_ethernetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPPPoEConnectParam::clear_has_ethernetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPPPoEConnectParam::clear_ethernetid() {
  ethernetid_ = 0u;
  clear_has_ethernetid();
}
inline ::google::protobuf::uint32 TPPPoEConnectParam::ethernetid() const {
  return ethernetid_;
}
inline void TPPPoEConnectParam::set_ethernetid(::google::protobuf::uint32 value) {
  set_has_ethernetid();
  ethernetid_ = value;
}

// optional string username = 2;
inline bool TPPPoEConnectParam::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TPPPoEConnectParam::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TPPPoEConnectParam::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TPPPoEConnectParam::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TPPPoEConnectParam::username() const {
  return *username_;
}
inline void TPPPoEConnectParam::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TPPPoEConnectParam::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TPPPoEConnectParam::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TPPPoEConnectParam::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TPPPoEConnectParam::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TPPPoEConnectParam::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 3;
inline bool TPPPoEConnectParam::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TPPPoEConnectParam::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TPPPoEConnectParam::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TPPPoEConnectParam::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TPPPoEConnectParam::password() const {
  return *password_;
}
inline void TPPPoEConnectParam::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TPPPoEConnectParam::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TPPPoEConnectParam::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TPPPoEConnectParam::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TPPPoEConnectParam::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TPPPoEConnectParam::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string servername = 4;
inline bool TPPPoEConnectParam::has_servername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TPPPoEConnectParam::set_has_servername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TPPPoEConnectParam::clear_has_servername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TPPPoEConnectParam::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& TPPPoEConnectParam::servername() const {
  return *servername_;
}
inline void TPPPoEConnectParam::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void TPPPoEConnectParam::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void TPPPoEConnectParam::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TPPPoEConnectParam::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* TPPPoEConnectParam::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TPPPoEConnectParam::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool autodial = 5;
inline bool TPPPoEConnectParam::has_autodial() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TPPPoEConnectParam::set_has_autodial() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TPPPoEConnectParam::clear_has_autodial() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TPPPoEConnectParam::clear_autodial() {
  autodial_ = false;
  clear_has_autodial();
}
inline bool TPPPoEConnectParam::autodial() const {
  return autodial_;
}
inline void TPPPoEConnectParam::set_autodial(bool value) {
  set_has_autodial();
  autodial_ = value;
}

// optional bool def_route_enable = 6;
inline bool TPPPoEConnectParam::has_def_route_enable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TPPPoEConnectParam::set_has_def_route_enable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TPPPoEConnectParam::clear_has_def_route_enable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TPPPoEConnectParam::clear_def_route_enable() {
  def_route_enable_ = false;
  clear_has_def_route_enable();
}
inline bool TPPPoEConnectParam::def_route_enable() const {
  return def_route_enable_;
}
inline void TPPPoEConnectParam::set_def_route_enable(bool value) {
  set_has_def_route_enable();
  def_route_enable_ = value;
}

// optional bool in_debug = 7;
inline bool TPPPoEConnectParam::has_in_debug() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TPPPoEConnectParam::set_has_in_debug() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TPPPoEConnectParam::clear_has_in_debug() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TPPPoEConnectParam::clear_in_debug() {
  in_debug_ = false;
  clear_has_in_debug();
}
inline bool TPPPoEConnectParam::in_debug() const {
  return in_debug_;
}
inline void TPPPoEConnectParam::set_in_debug(bool value) {
  set_has_in_debug();
  in_debug_ = value;
}

// optional uint32 autodial_interval = 8;
inline bool TPPPoEConnectParam::has_autodial_interval() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TPPPoEConnectParam::set_has_autodial_interval() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TPPPoEConnectParam::clear_has_autodial_interval() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TPPPoEConnectParam::clear_autodial_interval() {
  autodial_interval_ = 0u;
  clear_has_autodial_interval();
}
inline ::google::protobuf::uint32 TPPPoEConnectParam::autodial_interval() const {
  return autodial_interval_;
}
inline void TPPPoEConnectParam::set_autodial_interval(::google::protobuf::uint32 value) {
  set_has_autodial_interval();
  autodial_interval_ = value;
}

// optional uint32 dial_retrytimes = 9;
inline bool TPPPoEConnectParam::has_dial_retrytimes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TPPPoEConnectParam::set_has_dial_retrytimes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TPPPoEConnectParam::clear_has_dial_retrytimes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TPPPoEConnectParam::clear_dial_retrytimes() {
  dial_retrytimes_ = 0u;
  clear_has_dial_retrytimes();
}
inline ::google::protobuf::uint32 TPPPoEConnectParam::dial_retrytimes() const {
  return dial_retrytimes_;
}
inline void TPPPoEConnectParam::set_dial_retrytimes(::google::protobuf::uint32 value) {
  set_has_dial_retrytimes();
  dial_retrytimes_ = value;
}

// optional uint32 lcpecho_sendInterval = 10;
inline bool TPPPoEConnectParam::has_lcpecho_sendinterval() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TPPPoEConnectParam::set_has_lcpecho_sendinterval() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TPPPoEConnectParam::clear_has_lcpecho_sendinterval() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TPPPoEConnectParam::clear_lcpecho_sendinterval() {
  lcpecho_sendinterval_ = 0u;
  clear_has_lcpecho_sendinterval();
}
inline ::google::protobuf::uint32 TPPPoEConnectParam::lcpecho_sendinterval() const {
  return lcpecho_sendinterval_;
}
inline void TPPPoEConnectParam::set_lcpecho_sendinterval(::google::protobuf::uint32 value) {
  set_has_lcpecho_sendinterval();
  lcpecho_sendinterval_ = value;
}

// optional uint32 lcpecho_retrytimes = 11;
inline bool TPPPoEConnectParam::has_lcpecho_retrytimes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TPPPoEConnectParam::set_has_lcpecho_retrytimes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TPPPoEConnectParam::clear_has_lcpecho_retrytimes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TPPPoEConnectParam::clear_lcpecho_retrytimes() {
  lcpecho_retrytimes_ = 0u;
  clear_has_lcpecho_retrytimes();
}
inline ::google::protobuf::uint32 TPPPoEConnectParam::lcpecho_retrytimes() const {
  return lcpecho_retrytimes_;
}
inline void TPPPoEConnectParam::set_lcpecho_retrytimes(::google::protobuf::uint32 value) {
  set_has_lcpecho_retrytimes();
  lcpecho_retrytimes_ = value;
}

// -------------------------------------------------------------------

// TPPPoEState

// optional .mt.EmPPPoELinkState pppoe_running = 1;
inline bool TPPPoEState::has_pppoe_running() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPPPoEState::set_has_pppoe_running() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPPPoEState::clear_has_pppoe_running() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPPPoEState::clear_pppoe_running() {
  pppoe_running_ = 0;
  clear_has_pppoe_running();
}
inline ::mt::EmPPPoELinkState TPPPoEState::pppoe_running() const {
  return static_cast< ::mt::EmPPPoELinkState >(pppoe_running_);
}
inline void TPPPoEState::set_pppoe_running(::mt::EmPPPoELinkState value) {
  assert(::mt::EmPPPoELinkState_IsValid(value));
  set_has_pppoe_running();
  pppoe_running_ = value;
}

// optional string servername = 2;
inline bool TPPPoEState::has_servername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TPPPoEState::set_has_servername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TPPPoEState::clear_has_servername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TPPPoEState::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& TPPPoEState::servername() const {
  return *servername_;
}
inline void TPPPoEState::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void TPPPoEState::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void TPPPoEState::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TPPPoEState::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* TPPPoEState::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TPPPoEState::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 localip = 3;
inline bool TPPPoEState::has_localip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TPPPoEState::set_has_localip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TPPPoEState::clear_has_localip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TPPPoEState::clear_localip() {
  localip_ = 0u;
  clear_has_localip();
}
inline ::google::protobuf::uint32 TPPPoEState::localip() const {
  return localip_;
}
inline void TPPPoEState::set_localip(::google::protobuf::uint32 value) {
  set_has_localip();
  localip_ = value;
}

// optional uint32 peerip = 4;
inline bool TPPPoEState::has_peerip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TPPPoEState::set_has_peerip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TPPPoEState::clear_has_peerip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TPPPoEState::clear_peerip() {
  peerip_ = 0u;
  clear_has_peerip();
}
inline ::google::protobuf::uint32 TPPPoEState::peerip() const {
  return peerip_;
}
inline void TPPPoEState::set_peerip(::google::protobuf::uint32 value) {
  set_has_peerip();
  peerip_ = value;
}

// optional uint32 mDnsServer1 = 5;
inline bool TPPPoEState::has_mdnsserver1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TPPPoEState::set_has_mdnsserver1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TPPPoEState::clear_has_mdnsserver1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TPPPoEState::clear_mdnsserver1() {
  mdnsserver1_ = 0u;
  clear_has_mdnsserver1();
}
inline ::google::protobuf::uint32 TPPPoEState::mdnsserver1() const {
  return mdnsserver1_;
}
inline void TPPPoEState::set_mdnsserver1(::google::protobuf::uint32 value) {
  set_has_mdnsserver1();
  mdnsserver1_ = value;
}

// optional uint32 mDnsServer2 = 6;
inline bool TPPPoEState::has_mdnsserver2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TPPPoEState::set_has_mdnsserver2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TPPPoEState::clear_has_mdnsserver2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TPPPoEState::clear_mdnsserver2() {
  mdnsserver2_ = 0u;
  clear_has_mdnsserver2();
}
inline ::google::protobuf::uint32 TPPPoEState::mdnsserver2() const {
  return mdnsserver2_;
}
inline void TPPPoEState::set_mdnsserver2(::google::protobuf::uint32 value) {
  set_has_mdnsserver2();
  mdnsserver2_ = value;
}

// optional .mt.EmPPPoELinkErrReason emReason = 7;
inline bool TPPPoEState::has_emreason() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TPPPoEState::set_has_emreason() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TPPPoEState::clear_has_emreason() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TPPPoEState::clear_emreason() {
  emreason_ = 0;
  clear_has_emreason();
}
inline ::mt::EmPPPoELinkErrReason TPPPoEState::emreason() const {
  return static_cast< ::mt::EmPPPoELinkErrReason >(emreason_);
}
inline void TPPPoEState::set_emreason(::mt::EmPPPoELinkErrReason value) {
  assert(::mt::EmPPPoELinkErrReason_IsValid(value));
  set_has_emreason();
  emreason_ = value;
}

// -------------------------------------------------------------------

// TPPPoEStatis

// optional uint32 link_keeptime = 1;
inline bool TPPPoEStatis::has_link_keeptime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPPPoEStatis::set_has_link_keeptime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPPPoEStatis::clear_has_link_keeptime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPPPoEStatis::clear_link_keeptime() {
  link_keeptime_ = 0u;
  clear_has_link_keeptime();
}
inline ::google::protobuf::uint32 TPPPoEStatis::link_keeptime() const {
  return link_keeptime_;
}
inline void TPPPoEStatis::set_link_keeptime(::google::protobuf::uint32 value) {
  set_has_link_keeptime();
  link_keeptime_ = value;
}

// optional uint32 link_downtimes = 2;
inline bool TPPPoEStatis::has_link_downtimes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TPPPoEStatis::set_has_link_downtimes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TPPPoEStatis::clear_has_link_downtimes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TPPPoEStatis::clear_link_downtimes() {
  link_downtimes_ = 0u;
  clear_has_link_downtimes();
}
inline ::google::protobuf::uint32 TPPPoEStatis::link_downtimes() const {
  return link_downtimes_;
}
inline void TPPPoEStatis::set_link_downtimes(::google::protobuf::uint32 value) {
  set_has_link_downtimes();
  link_downtimes_ = value;
}

// optional uint32 num_pkgsent = 3;
inline bool TPPPoEStatis::has_num_pkgsent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TPPPoEStatis::set_has_num_pkgsent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TPPPoEStatis::clear_has_num_pkgsent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TPPPoEStatis::clear_num_pkgsent() {
  num_pkgsent_ = 0u;
  clear_has_num_pkgsent();
}
inline ::google::protobuf::uint32 TPPPoEStatis::num_pkgsent() const {
  return num_pkgsent_;
}
inline void TPPPoEStatis::set_num_pkgsent(::google::protobuf::uint32 value) {
  set_has_num_pkgsent();
  num_pkgsent_ = value;
}

// optional uint32 num_pkgrecved = 4;
inline bool TPPPoEStatis::has_num_pkgrecved() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TPPPoEStatis::set_has_num_pkgrecved() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TPPPoEStatis::clear_has_num_pkgrecved() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TPPPoEStatis::clear_num_pkgrecved() {
  num_pkgrecved_ = 0u;
  clear_has_num_pkgrecved();
}
inline ::google::protobuf::uint32 TPPPoEStatis::num_pkgrecved() const {
  return num_pkgrecved_;
}
inline void TPPPoEStatis::set_num_pkgrecved(::google::protobuf::uint32 value) {
  set_has_num_pkgrecved();
  num_pkgrecved_ = value;
}

// optional uint32 num_bytessent = 5;
inline bool TPPPoEStatis::has_num_bytessent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TPPPoEStatis::set_has_num_bytessent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TPPPoEStatis::clear_has_num_bytessent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TPPPoEStatis::clear_num_bytessent() {
  num_bytessent_ = 0u;
  clear_has_num_bytessent();
}
inline ::google::protobuf::uint32 TPPPoEStatis::num_bytessent() const {
  return num_bytessent_;
}
inline void TPPPoEStatis::set_num_bytessent(::google::protobuf::uint32 value) {
  set_has_num_bytessent();
  num_bytessent_ = value;
}

// optional uint32 num_bytesrecved = 6;
inline bool TPPPoEStatis::has_num_bytesrecved() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TPPPoEStatis::set_has_num_bytesrecved() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TPPPoEStatis::clear_has_num_bytesrecved() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TPPPoEStatis::clear_num_bytesrecved() {
  num_bytesrecved_ = 0u;
  clear_has_num_bytesrecved();
}
inline ::google::protobuf::uint32 TPPPoEStatis::num_bytesrecved() const {
  return num_bytesrecved_;
}
inline void TPPPoEStatis::set_num_bytesrecved(::google::protobuf::uint32 value) {
  set_has_num_bytesrecved();
  num_bytesrecved_ = value;
}

// -------------------------------------------------------------------

// TPPPoEVersion

// optional string version = 1;
inline bool TPPPoEVersion::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPPPoEVersion::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPPPoEVersion::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPPPoEVersion::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TPPPoEVersion::version() const {
  return *version_;
}
inline void TPPPoEVersion::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TPPPoEVersion::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TPPPoEVersion::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TPPPoEVersion::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* TPPPoEVersion::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TPPPoEVersion::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TE1SerialInfo

// optional uint32 used_flag = 1;
inline bool TE1SerialInfo::has_used_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TE1SerialInfo::set_has_used_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TE1SerialInfo::clear_has_used_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TE1SerialInfo::clear_used_flag() {
  used_flag_ = 0u;
  clear_has_used_flag();
}
inline ::google::protobuf::uint32 TE1SerialInfo::used_flag() const {
  return used_flag_;
}
inline void TE1SerialInfo::set_used_flag(::google::protobuf::uint32 value) {
  set_has_used_flag();
  used_flag_ = value;
}

// optional uint32 serialid = 2;
inline bool TE1SerialInfo::has_serialid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TE1SerialInfo::set_has_serialid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TE1SerialInfo::clear_has_serialid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TE1SerialInfo::clear_serialid() {
  serialid_ = 0u;
  clear_has_serialid();
}
inline ::google::protobuf::uint32 TE1SerialInfo::serialid() const {
  return serialid_;
}
inline void TE1SerialInfo::set_serialid(::google::protobuf::uint32 value) {
  set_has_serialid();
  serialid_ = value;
}

// optional uint32 e1id = 3;
inline bool TE1SerialInfo::has_e1id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TE1SerialInfo::set_has_e1id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TE1SerialInfo::clear_has_e1id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TE1SerialInfo::clear_e1id() {
  e1id_ = 0u;
  clear_has_e1id();
}
inline ::google::protobuf::uint32 TE1SerialInfo::e1id() const {
  return e1id_;
}
inline void TE1SerialInfo::set_e1id(::google::protobuf::uint32 value) {
  set_has_e1id();
  e1id_ = value;
}

// optional uint32 e1_ts_mask = 4;
inline bool TE1SerialInfo::has_e1_ts_mask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TE1SerialInfo::set_has_e1_ts_mask() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TE1SerialInfo::clear_has_e1_ts_mask() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TE1SerialInfo::clear_e1_ts_mask() {
  e1_ts_mask_ = 0u;
  clear_has_e1_ts_mask();
}
inline ::google::protobuf::uint32 TE1SerialInfo::e1_ts_mask() const {
  return e1_ts_mask_;
}
inline void TE1SerialInfo::set_e1_ts_mask(::google::protobuf::uint32 value) {
  set_has_e1_ts_mask();
  e1_ts_mask_ = value;
}

// optional uint32 e1chan_groupid = 5;
inline bool TE1SerialInfo::has_e1chan_groupid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TE1SerialInfo::set_has_e1chan_groupid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TE1SerialInfo::clear_has_e1chan_groupid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TE1SerialInfo::clear_e1chan_groupid() {
  e1chan_groupid_ = 0u;
  clear_has_e1chan_groupid();
}
inline ::google::protobuf::uint32 TE1SerialInfo::e1chan_groupid() const {
  return e1chan_groupid_;
}
inline void TE1SerialInfo::set_e1chan_groupid(::google::protobuf::uint32 value) {
  set_has_e1chan_groupid();
  e1chan_groupid_ = value;
}

// optional uint32 protocol_type = 6;
inline bool TE1SerialInfo::has_protocol_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TE1SerialInfo::set_has_protocol_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TE1SerialInfo::clear_has_protocol_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TE1SerialInfo::clear_protocol_type() {
  protocol_type_ = 0u;
  clear_has_protocol_type();
}
inline ::google::protobuf::uint32 TE1SerialInfo::protocol_type() const {
  return protocol_type_;
}
inline void TE1SerialInfo::set_protocol_type(::google::protobuf::uint32 value) {
  set_has_protocol_type();
  protocol_type_ = value;
}

// optional uint32 echo_interval = 7;
inline bool TE1SerialInfo::has_echo_interval() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TE1SerialInfo::set_has_echo_interval() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TE1SerialInfo::clear_has_echo_interval() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TE1SerialInfo::clear_echo_interval() {
  echo_interval_ = 0u;
  clear_has_echo_interval();
}
inline ::google::protobuf::uint32 TE1SerialInfo::echo_interval() const {
  return echo_interval_;
}
inline void TE1SerialInfo::set_echo_interval(::google::protobuf::uint32 value) {
  set_has_echo_interval();
  echo_interval_ = value;
}

// optional uint32 echo_maxretry = 8;
inline bool TE1SerialInfo::has_echo_maxretry() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TE1SerialInfo::set_has_echo_maxretry() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TE1SerialInfo::clear_has_echo_maxretry() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TE1SerialInfo::clear_echo_maxretry() {
  echo_maxretry_ = 0u;
  clear_has_echo_maxretry();
}
inline ::google::protobuf::uint32 TE1SerialInfo::echo_maxretry() const {
  return echo_maxretry_;
}
inline void TE1SerialInfo::set_echo_maxretry(::google::protobuf::uint32 value) {
  set_has_echo_maxretry();
  echo_maxretry_ = value;
}

// -------------------------------------------------------------------

// TE1SingleChainInfo

// optional uint32 used_flag = 1;
inline bool TE1SingleChainInfo::has_used_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TE1SingleChainInfo::set_has_used_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TE1SingleChainInfo::clear_has_used_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TE1SingleChainInfo::clear_used_flag() {
  used_flag_ = 0u;
  clear_has_used_flag();
}
inline ::google::protobuf::uint32 TE1SingleChainInfo::used_flag() const {
  return used_flag_;
}
inline void TE1SingleChainInfo::set_used_flag(::google::protobuf::uint32 value) {
  set_has_used_flag();
  used_flag_ = value;
}

// optional uint32 ip = 2;
inline bool TE1SingleChainInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TE1SingleChainInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TE1SingleChainInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TE1SingleChainInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TE1SingleChainInfo::ip() const {
  return ip_;
}
inline void TE1SingleChainInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 mask = 3;
inline bool TE1SingleChainInfo::has_mask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TE1SingleChainInfo::set_has_mask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TE1SingleChainInfo::clear_has_mask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TE1SingleChainInfo::clear_mask() {
  mask_ = 0u;
  clear_has_mask();
}
inline ::google::protobuf::uint32 TE1SingleChainInfo::mask() const {
  return mask_;
}
inline void TE1SingleChainInfo::set_mask(::google::protobuf::uint32 value) {
  set_has_mask();
  mask_ = value;
}

// optional .mt.TE1SerialInfo serialinfo = 4;
inline bool TE1SingleChainInfo::has_serialinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TE1SingleChainInfo::set_has_serialinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TE1SingleChainInfo::clear_has_serialinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TE1SingleChainInfo::clear_serialinfo() {
  if (serialinfo_ != NULL) serialinfo_->::mt::TE1SerialInfo::Clear();
  clear_has_serialinfo();
}
inline const ::mt::TE1SerialInfo& TE1SingleChainInfo::serialinfo() const {
  return serialinfo_ != NULL ? *serialinfo_ : *default_instance_->serialinfo_;
}
inline ::mt::TE1SerialInfo* TE1SingleChainInfo::mutable_serialinfo() {
  set_has_serialinfo();
  if (serialinfo_ == NULL) serialinfo_ = new ::mt::TE1SerialInfo;
  return serialinfo_;
}
inline ::mt::TE1SerialInfo* TE1SingleChainInfo::release_serialinfo() {
  clear_has_serialinfo();
  ::mt::TE1SerialInfo* temp = serialinfo_;
  serialinfo_ = NULL;
  return temp;
}
inline void TE1SingleChainInfo::set_allocated_serialinfo(::mt::TE1SerialInfo* serialinfo) {
  delete serialinfo_;
  serialinfo_ = serialinfo;
  if (serialinfo) {
    set_has_serialinfo();
  } else {
    clear_has_serialinfo();
  }
}

// -------------------------------------------------------------------

// TE1MultiChainInfo

// optional uint32 used_flag = 1;
inline bool TE1MultiChainInfo::has_used_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TE1MultiChainInfo::set_has_used_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TE1MultiChainInfo::clear_has_used_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TE1MultiChainInfo::clear_used_flag() {
  used_flag_ = 0u;
  clear_has_used_flag();
}
inline ::google::protobuf::uint32 TE1MultiChainInfo::used_flag() const {
  return used_flag_;
}
inline void TE1MultiChainInfo::set_used_flag(::google::protobuf::uint32 value) {
  set_has_used_flag();
  used_flag_ = value;
}

// optional uint32 ip = 2;
inline bool TE1MultiChainInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TE1MultiChainInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TE1MultiChainInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TE1MultiChainInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TE1MultiChainInfo::ip() const {
  return ip_;
}
inline void TE1MultiChainInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 mask = 3;
inline bool TE1MultiChainInfo::has_mask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TE1MultiChainInfo::set_has_mask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TE1MultiChainInfo::clear_has_mask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TE1MultiChainInfo::clear_mask() {
  mask_ = 0u;
  clear_has_mask();
}
inline ::google::protobuf::uint32 TE1MultiChainInfo::mask() const {
  return mask_;
}
inline void TE1MultiChainInfo::set_mask(::google::protobuf::uint32 value) {
  set_has_mask();
  mask_ = value;
}

// optional uint32 auth_type = 4;
inline bool TE1MultiChainInfo::has_auth_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TE1MultiChainInfo::set_has_auth_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TE1MultiChainInfo::clear_has_auth_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TE1MultiChainInfo::clear_auth_type() {
  auth_type_ = 0u;
  clear_has_auth_type();
}
inline ::google::protobuf::uint32 TE1MultiChainInfo::auth_type() const {
  return auth_type_;
}
inline void TE1MultiChainInfo::set_auth_type(::google::protobuf::uint32 value) {
  set_has_auth_type();
  auth_type_ = value;
}

// optional uint32 frag_minpackage_len = 5;
inline bool TE1MultiChainInfo::has_frag_minpackage_len() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TE1MultiChainInfo::set_has_frag_minpackage_len() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TE1MultiChainInfo::clear_has_frag_minpackage_len() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TE1MultiChainInfo::clear_frag_minpackage_len() {
  frag_minpackage_len_ = 0u;
  clear_has_frag_minpackage_len();
}
inline ::google::protobuf::uint32 TE1MultiChainInfo::frag_minpackage_len() const {
  return frag_minpackage_len_;
}
inline void TE1MultiChainInfo::set_frag_minpackage_len(::google::protobuf::uint32 value) {
  set_has_frag_minpackage_len();
  frag_minpackage_len_ = value;
}

// optional string svr_usrname = 6;
inline bool TE1MultiChainInfo::has_svr_usrname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TE1MultiChainInfo::set_has_svr_usrname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TE1MultiChainInfo::clear_has_svr_usrname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TE1MultiChainInfo::clear_svr_usrname() {
  if (svr_usrname_ != &::google::protobuf::internal::kEmptyString) {
    svr_usrname_->clear();
  }
  clear_has_svr_usrname();
}
inline const ::std::string& TE1MultiChainInfo::svr_usrname() const {
  return *svr_usrname_;
}
inline void TE1MultiChainInfo::set_svr_usrname(const ::std::string& value) {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  svr_usrname_->assign(value);
}
inline void TE1MultiChainInfo::set_svr_usrname(const char* value) {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  svr_usrname_->assign(value);
}
inline void TE1MultiChainInfo::set_svr_usrname(const char* value, size_t size) {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  svr_usrname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1MultiChainInfo::mutable_svr_usrname() {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  return svr_usrname_;
}
inline ::std::string* TE1MultiChainInfo::release_svr_usrname() {
  clear_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_usrname_;
    svr_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1MultiChainInfo::set_allocated_svr_usrname(::std::string* svr_usrname) {
  if (svr_usrname_ != &::google::protobuf::internal::kEmptyString) {
    delete svr_usrname_;
  }
  if (svr_usrname) {
    set_has_svr_usrname();
    svr_usrname_ = svr_usrname;
  } else {
    clear_has_svr_usrname();
    svr_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string svr_usrpwd = 7;
inline bool TE1MultiChainInfo::has_svr_usrpwd() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TE1MultiChainInfo::set_has_svr_usrpwd() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TE1MultiChainInfo::clear_has_svr_usrpwd() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TE1MultiChainInfo::clear_svr_usrpwd() {
  if (svr_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_->clear();
  }
  clear_has_svr_usrpwd();
}
inline const ::std::string& TE1MultiChainInfo::svr_usrpwd() const {
  return *svr_usrpwd_;
}
inline void TE1MultiChainInfo::set_svr_usrpwd(const ::std::string& value) {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  svr_usrpwd_->assign(value);
}
inline void TE1MultiChainInfo::set_svr_usrpwd(const char* value) {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  svr_usrpwd_->assign(value);
}
inline void TE1MultiChainInfo::set_svr_usrpwd(const char* value, size_t size) {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  svr_usrpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1MultiChainInfo::mutable_svr_usrpwd() {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  return svr_usrpwd_;
}
inline ::std::string* TE1MultiChainInfo::release_svr_usrpwd() {
  clear_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_usrpwd_;
    svr_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1MultiChainInfo::set_allocated_svr_usrpwd(::std::string* svr_usrpwd) {
  if (svr_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete svr_usrpwd_;
  }
  if (svr_usrpwd) {
    set_has_svr_usrpwd();
    svr_usrpwd_ = svr_usrpwd;
  } else {
    clear_has_svr_usrpwd();
    svr_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sent_usrname = 8;
inline bool TE1MultiChainInfo::has_sent_usrname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TE1MultiChainInfo::set_has_sent_usrname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TE1MultiChainInfo::clear_has_sent_usrname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TE1MultiChainInfo::clear_sent_usrname() {
  if (sent_usrname_ != &::google::protobuf::internal::kEmptyString) {
    sent_usrname_->clear();
  }
  clear_has_sent_usrname();
}
inline const ::std::string& TE1MultiChainInfo::sent_usrname() const {
  return *sent_usrname_;
}
inline void TE1MultiChainInfo::set_sent_usrname(const ::std::string& value) {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  sent_usrname_->assign(value);
}
inline void TE1MultiChainInfo::set_sent_usrname(const char* value) {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  sent_usrname_->assign(value);
}
inline void TE1MultiChainInfo::set_sent_usrname(const char* value, size_t size) {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  sent_usrname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1MultiChainInfo::mutable_sent_usrname() {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  return sent_usrname_;
}
inline ::std::string* TE1MultiChainInfo::release_sent_usrname() {
  clear_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sent_usrname_;
    sent_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1MultiChainInfo::set_allocated_sent_usrname(::std::string* sent_usrname) {
  if (sent_usrname_ != &::google::protobuf::internal::kEmptyString) {
    delete sent_usrname_;
  }
  if (sent_usrname) {
    set_has_sent_usrname();
    sent_usrname_ = sent_usrname;
  } else {
    clear_has_sent_usrname();
    sent_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sent_usrpwd = 9;
inline bool TE1MultiChainInfo::has_sent_usrpwd() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TE1MultiChainInfo::set_has_sent_usrpwd() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TE1MultiChainInfo::clear_has_sent_usrpwd() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TE1MultiChainInfo::clear_sent_usrpwd() {
  if (sent_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_->clear();
  }
  clear_has_sent_usrpwd();
}
inline const ::std::string& TE1MultiChainInfo::sent_usrpwd() const {
  return *sent_usrpwd_;
}
inline void TE1MultiChainInfo::set_sent_usrpwd(const ::std::string& value) {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  sent_usrpwd_->assign(value);
}
inline void TE1MultiChainInfo::set_sent_usrpwd(const char* value) {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  sent_usrpwd_->assign(value);
}
inline void TE1MultiChainInfo::set_sent_usrpwd(const char* value, size_t size) {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  sent_usrpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1MultiChainInfo::mutable_sent_usrpwd() {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  return sent_usrpwd_;
}
inline ::std::string* TE1MultiChainInfo::release_sent_usrpwd() {
  clear_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sent_usrpwd_;
    sent_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1MultiChainInfo::set_allocated_sent_usrpwd(::std::string* sent_usrpwd) {
  if (sent_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete sent_usrpwd_;
  }
  if (sent_usrpwd) {
    set_has_sent_usrpwd();
    sent_usrpwd_ = sent_usrpwd;
  } else {
    clear_has_sent_usrpwd();
    sent_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mt.TE1SerialInfo serialinfolist = 10;
inline int TE1MultiChainInfo::serialinfolist_size() const {
  return serialinfolist_.size();
}
inline void TE1MultiChainInfo::clear_serialinfolist() {
  serialinfolist_.Clear();
}
inline const ::mt::TE1SerialInfo& TE1MultiChainInfo::serialinfolist(int index) const {
  return serialinfolist_.Get(index);
}
inline ::mt::TE1SerialInfo* TE1MultiChainInfo::mutable_serialinfolist(int index) {
  return serialinfolist_.Mutable(index);
}
inline ::mt::TE1SerialInfo* TE1MultiChainInfo::add_serialinfolist() {
  return serialinfolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TE1SerialInfo >&
TE1MultiChainInfo::serialinfolist() const {
  return serialinfolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TE1SerialInfo >*
TE1MultiChainInfo::mutable_serialinfolist() {
  return &serialinfolist_;
}

// -------------------------------------------------------------------

// TPingCmdOption

// optional uint32 packagesize = 1;
inline bool TPingCmdOption::has_packagesize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPingCmdOption::set_has_packagesize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPingCmdOption::clear_has_packagesize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPingCmdOption::clear_packagesize() {
  packagesize_ = 0u;
  clear_has_packagesize();
}
inline ::google::protobuf::uint32 TPingCmdOption::packagesize() const {
  return packagesize_;
}
inline void TPingCmdOption::set_packagesize(::google::protobuf::uint32 value) {
  set_has_packagesize();
  packagesize_ = value;
}

// optional uint32 timeout = 2;
inline bool TPingCmdOption::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TPingCmdOption::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TPingCmdOption::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TPingCmdOption::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TPingCmdOption::timeout() const {
  return timeout_;
}
inline void TPingCmdOption::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional uint32 ttl = 3;
inline bool TPingCmdOption::has_ttl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TPingCmdOption::set_has_ttl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TPingCmdOption::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TPingCmdOption::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 TPingCmdOption::ttl() const {
  return ttl_;
}
inline void TPingCmdOption::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// optional uint32 count = 4;
inline bool TPingCmdOption::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TPingCmdOption::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TPingCmdOption::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TPingCmdOption::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TPingCmdOption::count() const {
  return count_;
}
inline void TPingCmdOption::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// TPingTestParam

// optional string dst_info = 1;
inline bool TPingTestParam::has_dst_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPingTestParam::set_has_dst_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPingTestParam::clear_has_dst_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPingTestParam::clear_dst_info() {
  if (dst_info_ != &::google::protobuf::internal::kEmptyString) {
    dst_info_->clear();
  }
  clear_has_dst_info();
}
inline const ::std::string& TPingTestParam::dst_info() const {
  return *dst_info_;
}
inline void TPingTestParam::set_dst_info(const ::std::string& value) {
  set_has_dst_info();
  if (dst_info_ == &::google::protobuf::internal::kEmptyString) {
    dst_info_ = new ::std::string;
  }
  dst_info_->assign(value);
}
inline void TPingTestParam::set_dst_info(const char* value) {
  set_has_dst_info();
  if (dst_info_ == &::google::protobuf::internal::kEmptyString) {
    dst_info_ = new ::std::string;
  }
  dst_info_->assign(value);
}
inline void TPingTestParam::set_dst_info(const char* value, size_t size) {
  set_has_dst_info();
  if (dst_info_ == &::google::protobuf::internal::kEmptyString) {
    dst_info_ = new ::std::string;
  }
  dst_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TPingTestParam::mutable_dst_info() {
  set_has_dst_info();
  if (dst_info_ == &::google::protobuf::internal::kEmptyString) {
    dst_info_ = new ::std::string;
  }
  return dst_info_;
}
inline ::std::string* TPingTestParam::release_dst_info() {
  clear_has_dst_info();
  if (dst_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dst_info_;
    dst_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TPingTestParam::set_allocated_dst_info(::std::string* dst_info) {
  if (dst_info_ != &::google::protobuf::internal::kEmptyString) {
    delete dst_info_;
  }
  if (dst_info) {
    set_has_dst_info();
    dst_info_ = dst_info;
  } else {
    clear_has_dst_info();
    dst_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TPingCmdOption ping_option = 2;
inline bool TPingTestParam::has_ping_option() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TPingTestParam::set_has_ping_option() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TPingTestParam::clear_has_ping_option() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TPingTestParam::clear_ping_option() {
  if (ping_option_ != NULL) ping_option_->::mt::TPingCmdOption::Clear();
  clear_has_ping_option();
}
inline const ::mt::TPingCmdOption& TPingTestParam::ping_option() const {
  return ping_option_ != NULL ? *ping_option_ : *default_instance_->ping_option_;
}
inline ::mt::TPingCmdOption* TPingTestParam::mutable_ping_option() {
  set_has_ping_option();
  if (ping_option_ == NULL) ping_option_ = new ::mt::TPingCmdOption;
  return ping_option_;
}
inline ::mt::TPingCmdOption* TPingTestParam::release_ping_option() {
  clear_has_ping_option();
  ::mt::TPingCmdOption* temp = ping_option_;
  ping_option_ = NULL;
  return temp;
}
inline void TPingTestParam::set_allocated_ping_option(::mt::TPingCmdOption* ping_option) {
  delete ping_option_;
  ping_option_ = ping_option;
  if (ping_option) {
    set_has_ping_option();
  } else {
    clear_has_ping_option();
  }
}

// optional uint32 userid = 3;
inline bool TPingTestParam::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TPingTestParam::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TPingTestParam::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TPingTestParam::clear_userid() {
  userid_ = 0u;
  clear_has_userid();
}
inline ::google::protobuf::uint32 TPingTestParam::userid() const {
  return userid_;
}
inline void TPingTestParam::set_userid(::google::protobuf::uint32 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// TPingResult

// optional .mt.EmPingErrcode ping_errcode = 1;
inline bool TPingResult::has_ping_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPingResult::set_has_ping_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPingResult::clear_has_ping_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPingResult::clear_ping_errcode() {
  ping_errcode_ = 0;
  clear_has_ping_errcode();
}
inline ::mt::EmPingErrcode TPingResult::ping_errcode() const {
  return static_cast< ::mt::EmPingErrcode >(ping_errcode_);
}
inline void TPingResult::set_ping_errcode(::mt::EmPingErrcode value) {
  assert(::mt::EmPingErrcode_IsValid(value));
  set_has_ping_errcode();
  ping_errcode_ = value;
}

// optional uint32 ttl = 2;
inline bool TPingResult::has_ttl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TPingResult::set_has_ttl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TPingResult::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TPingResult::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 TPingResult::ttl() const {
  return ttl_;
}
inline void TPingResult::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// optional uint32 trip_time = 3;
inline bool TPingResult::has_trip_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TPingResult::set_has_trip_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TPingResult::clear_has_trip_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TPingResult::clear_trip_time() {
  trip_time_ = 0u;
  clear_has_trip_time();
}
inline ::google::protobuf::uint32 TPingResult::trip_time() const {
  return trip_time_;
}
inline void TPingResult::set_trip_time(::google::protobuf::uint32 value) {
  set_has_trip_time();
  trip_time_ = value;
}

// optional uint32 userid = 4;
inline bool TPingResult::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TPingResult::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TPingResult::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TPingResult::clear_userid() {
  userid_ = 0u;
  clear_has_userid();
}
inline ::google::protobuf::uint32 TPingResult::userid() const {
  return userid_;
}
inline void TPingResult::set_userid(::google::protobuf::uint32 value) {
  set_has_userid();
  userid_ = value;
}

// optional uint32 error_type = 5;
inline bool TPingResult::has_error_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TPingResult::set_has_error_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TPingResult::clear_has_error_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TPingResult::clear_error_type() {
  error_type_ = 0u;
  clear_has_error_type();
}
inline ::google::protobuf::uint32 TPingResult::error_type() const {
  return error_type_;
}
inline void TPingResult::set_error_type(::google::protobuf::uint32 value) {
  set_has_error_type();
  error_type_ = value;
}

// optional uint32 error_code = 6;
inline bool TPingResult::has_error_code() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TPingResult::set_has_error_code() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TPingResult::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TPingResult::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 TPingResult::error_code() const {
  return error_code_;
}
inline void TPingResult::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// TDNSNameToIpInfo

// optional string dns_name = 1;
inline bool TDNSNameToIpInfo::has_dns_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDNSNameToIpInfo::set_has_dns_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDNSNameToIpInfo::clear_has_dns_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDNSNameToIpInfo::clear_dns_name() {
  if (dns_name_ != &::google::protobuf::internal::kEmptyString) {
    dns_name_->clear();
  }
  clear_has_dns_name();
}
inline const ::std::string& TDNSNameToIpInfo::dns_name() const {
  return *dns_name_;
}
inline void TDNSNameToIpInfo::set_dns_name(const ::std::string& value) {
  set_has_dns_name();
  if (dns_name_ == &::google::protobuf::internal::kEmptyString) {
    dns_name_ = new ::std::string;
  }
  dns_name_->assign(value);
}
inline void TDNSNameToIpInfo::set_dns_name(const char* value) {
  set_has_dns_name();
  if (dns_name_ == &::google::protobuf::internal::kEmptyString) {
    dns_name_ = new ::std::string;
  }
  dns_name_->assign(value);
}
inline void TDNSNameToIpInfo::set_dns_name(const char* value, size_t size) {
  set_has_dns_name();
  if (dns_name_ == &::google::protobuf::internal::kEmptyString) {
    dns_name_ = new ::std::string;
  }
  dns_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDNSNameToIpInfo::mutable_dns_name() {
  set_has_dns_name();
  if (dns_name_ == &::google::protobuf::internal::kEmptyString) {
    dns_name_ = new ::std::string;
  }
  return dns_name_;
}
inline ::std::string* TDNSNameToIpInfo::release_dns_name() {
  clear_has_dns_name();
  if (dns_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dns_name_;
    dns_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDNSNameToIpInfo::set_allocated_dns_name(::std::string* dns_name) {
  if (dns_name_ != &::google::protobuf::internal::kEmptyString) {
    delete dns_name_;
  }
  if (dns_name) {
    set_has_dns_name();
    dns_name_ = dns_name;
  } else {
    clear_has_dns_name();
    dns_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TDNSNameToIpResult

// optional string dns_name = 1;
inline bool TDNSNameToIpResult::has_dns_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDNSNameToIpResult::set_has_dns_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDNSNameToIpResult::clear_has_dns_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDNSNameToIpResult::clear_dns_name() {
  if (dns_name_ != &::google::protobuf::internal::kEmptyString) {
    dns_name_->clear();
  }
  clear_has_dns_name();
}
inline const ::std::string& TDNSNameToIpResult::dns_name() const {
  return *dns_name_;
}
inline void TDNSNameToIpResult::set_dns_name(const ::std::string& value) {
  set_has_dns_name();
  if (dns_name_ == &::google::protobuf::internal::kEmptyString) {
    dns_name_ = new ::std::string;
  }
  dns_name_->assign(value);
}
inline void TDNSNameToIpResult::set_dns_name(const char* value) {
  set_has_dns_name();
  if (dns_name_ == &::google::protobuf::internal::kEmptyString) {
    dns_name_ = new ::std::string;
  }
  dns_name_->assign(value);
}
inline void TDNSNameToIpResult::set_dns_name(const char* value, size_t size) {
  set_has_dns_name();
  if (dns_name_ == &::google::protobuf::internal::kEmptyString) {
    dns_name_ = new ::std::string;
  }
  dns_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TDNSNameToIpResult::mutable_dns_name() {
  set_has_dns_name();
  if (dns_name_ == &::google::protobuf::internal::kEmptyString) {
    dns_name_ = new ::std::string;
  }
  return dns_name_;
}
inline ::std::string* TDNSNameToIpResult::release_dns_name() {
  clear_has_dns_name();
  if (dns_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dns_name_;
    dns_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TDNSNameToIpResult::set_allocated_dns_name(::std::string* dns_name) {
  if (dns_name_ != &::google::protobuf::internal::kEmptyString) {
    delete dns_name_;
  }
  if (dns_name) {
    set_has_dns_name();
    dns_name_ = dns_name;
  } else {
    clear_has_dns_name();
    dns_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TDNSNameToIpResult::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDNSNameToIpResult::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDNSNameToIpResult::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDNSNameToIpResult::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TDNSNameToIpResult::ip() const {
  return ip_;
}
inline void TDNSNameToIpResult::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 error_code = 3;
inline bool TDNSNameToIpResult::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TDNSNameToIpResult::set_has_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TDNSNameToIpResult::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TDNSNameToIpResult::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 TDNSNameToIpResult::error_code() const {
  return error_code_;
}
inline void TDNSNameToIpResult::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// TNetConfilictedInfo

// optional .mt.EmNetConflictType type = 1;
inline bool TNetConfilictedInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNetConfilictedInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNetConfilictedInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNetConfilictedInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmNetConflictType TNetConfilictedInfo::type() const {
  return static_cast< ::mt::EmNetConflictType >(type_);
}
inline void TNetConfilictedInfo::set_type(::mt::EmNetConflictType value) {
  assert(::mt::EmNetConflictType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string mac = 2;
inline bool TNetConfilictedInfo::has_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNetConfilictedInfo::set_has_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNetConfilictedInfo::clear_has_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNetConfilictedInfo::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& TNetConfilictedInfo::mac() const {
  return *mac_;
}
inline void TNetConfilictedInfo::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void TNetConfilictedInfo::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void TNetConfilictedInfo::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNetConfilictedInfo::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* TNetConfilictedInfo::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNetConfilictedInfo::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 3;
inline bool TNetConfilictedInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNetConfilictedInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNetConfilictedInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNetConfilictedInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TNetConfilictedInfo::ip() const {
  return ip_;
}
inline void TNetConfilictedInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// -------------------------------------------------------------------

// TWifiWorkMode

// optional .mt.EmWifiWorkMode wifi_workmode = 1;
inline bool TWifiWorkMode::has_wifi_workmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWifiWorkMode::set_has_wifi_workmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWifiWorkMode::clear_has_wifi_workmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWifiWorkMode::clear_wifi_workmode() {
  wifi_workmode_ = 0;
  clear_has_wifi_workmode();
}
inline ::mt::EmWifiWorkMode TWifiWorkMode::wifi_workmode() const {
  return static_cast< ::mt::EmWifiWorkMode >(wifi_workmode_);
}
inline void TWifiWorkMode::set_wifi_workmode(::mt::EmWifiWorkMode value) {
  assert(::mt::EmWifiWorkMode_IsValid(value));
  set_has_wifi_workmode();
  wifi_workmode_ = value;
}

// optional .mt.TWifiApConfiguration wifiApConfig = 2;
inline bool TWifiWorkMode::has_wifiapconfig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWifiWorkMode::set_has_wifiapconfig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWifiWorkMode::clear_has_wifiapconfig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWifiWorkMode::clear_wifiapconfig() {
  if (wifiapconfig_ != NULL) wifiapconfig_->::mt::TWifiApConfiguration::Clear();
  clear_has_wifiapconfig();
}
inline const ::mt::TWifiApConfiguration& TWifiWorkMode::wifiapconfig() const {
  return wifiapconfig_ != NULL ? *wifiapconfig_ : *default_instance_->wifiapconfig_;
}
inline ::mt::TWifiApConfiguration* TWifiWorkMode::mutable_wifiapconfig() {
  set_has_wifiapconfig();
  if (wifiapconfig_ == NULL) wifiapconfig_ = new ::mt::TWifiApConfiguration;
  return wifiapconfig_;
}
inline ::mt::TWifiApConfiguration* TWifiWorkMode::release_wifiapconfig() {
  clear_has_wifiapconfig();
  ::mt::TWifiApConfiguration* temp = wifiapconfig_;
  wifiapconfig_ = NULL;
  return temp;
}
inline void TWifiWorkMode::set_allocated_wifiapconfig(::mt::TWifiApConfiguration* wifiapconfig) {
  delete wifiapconfig_;
  wifiapconfig_ = wifiapconfig;
  if (wifiapconfig) {
    set_has_wifiapconfig();
  } else {
    clear_has_wifiapconfig();
  }
}

// -------------------------------------------------------------------

// TWifiApConfiguration

// optional string ssid = 1;
inline bool TWifiApConfiguration::has_ssid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWifiApConfiguration::set_has_ssid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWifiApConfiguration::clear_has_ssid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWifiApConfiguration::clear_ssid() {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    ssid_->clear();
  }
  clear_has_ssid();
}
inline const ::std::string& TWifiApConfiguration::ssid() const {
  return *ssid_;
}
inline void TWifiApConfiguration::set_ssid(const ::std::string& value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TWifiApConfiguration::set_ssid(const char* value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TWifiApConfiguration::set_ssid(const char* value, size_t size) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWifiApConfiguration::mutable_ssid() {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  return ssid_;
}
inline ::std::string* TWifiApConfiguration::release_ssid() {
  clear_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ssid_;
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWifiApConfiguration::set_allocated_ssid(::std::string* ssid) {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    delete ssid_;
  }
  if (ssid) {
    set_has_ssid();
    ssid_ = ssid;
  } else {
    clear_has_ssid();
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmWifiApKeyType capabilities = 2;
inline bool TWifiApConfiguration::has_capabilities() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWifiApConfiguration::set_has_capabilities() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWifiApConfiguration::clear_has_capabilities() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWifiApConfiguration::clear_capabilities() {
  capabilities_ = 0;
  clear_has_capabilities();
}
inline ::mt::EmWifiApKeyType TWifiApConfiguration::capabilities() const {
  return static_cast< ::mt::EmWifiApKeyType >(capabilities_);
}
inline void TWifiApConfiguration::set_capabilities(::mt::EmWifiApKeyType value) {
  assert(::mt::EmWifiApKeyType_IsValid(value));
  set_has_capabilities();
  capabilities_ = value;
}

// optional string key = 3;
inline bool TWifiApConfiguration::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TWifiApConfiguration::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TWifiApConfiguration::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TWifiApConfiguration::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& TWifiApConfiguration::key() const {
  return *key_;
}
inline void TWifiApConfiguration::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TWifiApConfiguration::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TWifiApConfiguration::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWifiApConfiguration::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* TWifiApConfiguration::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWifiApConfiguration::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 dhcp_startip = 4;
inline bool TWifiApConfiguration::has_dhcp_startip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TWifiApConfiguration::set_has_dhcp_startip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TWifiApConfiguration::clear_has_dhcp_startip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TWifiApConfiguration::clear_dhcp_startip() {
  dhcp_startip_ = 0u;
  clear_has_dhcp_startip();
}
inline ::google::protobuf::uint32 TWifiApConfiguration::dhcp_startip() const {
  return dhcp_startip_;
}
inline void TWifiApConfiguration::set_dhcp_startip(::google::protobuf::uint32 value) {
  set_has_dhcp_startip();
  dhcp_startip_ = value;
}

// optional uint32 dhcp_endip = 5;
inline bool TWifiApConfiguration::has_dhcp_endip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TWifiApConfiguration::set_has_dhcp_endip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TWifiApConfiguration::clear_has_dhcp_endip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TWifiApConfiguration::clear_dhcp_endip() {
  dhcp_endip_ = 0u;
  clear_has_dhcp_endip();
}
inline ::google::protobuf::uint32 TWifiApConfiguration::dhcp_endip() const {
  return dhcp_endip_;
}
inline void TWifiApConfiguration::set_dhcp_endip(::google::protobuf::uint32 value) {
  set_has_dhcp_endip();
  dhcp_endip_ = value;
}

// optional uint32 ip = 6;
inline bool TWifiApConfiguration::has_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TWifiApConfiguration::set_has_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TWifiApConfiguration::clear_has_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TWifiApConfiguration::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TWifiApConfiguration::ip() const {
  return ip_;
}
inline void TWifiApConfiguration::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 mask = 7;
inline bool TWifiApConfiguration::has_mask() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TWifiApConfiguration::set_has_mask() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TWifiApConfiguration::clear_has_mask() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TWifiApConfiguration::clear_mask() {
  mask_ = 0u;
  clear_has_mask();
}
inline ::google::protobuf::uint32 TWifiApConfiguration::mask() const {
  return mask_;
}
inline void TWifiApConfiguration::set_mask(::google::protobuf::uint32 value) {
  set_has_mask();
  mask_ = value;
}

// optional .mt.EmWifiFrequencyBandType frequency_band = 8;
inline bool TWifiApConfiguration::has_frequency_band() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TWifiApConfiguration::set_has_frequency_band() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TWifiApConfiguration::clear_has_frequency_band() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TWifiApConfiguration::clear_frequency_band() {
  frequency_band_ = 0;
  clear_has_frequency_band();
}
inline ::mt::EmWifiFrequencyBandType TWifiApConfiguration::frequency_band() const {
  return static_cast< ::mt::EmWifiFrequencyBandType >(frequency_band_);
}
inline void TWifiApConfiguration::set_frequency_band(::mt::EmWifiFrequencyBandType value) {
  assert(::mt::EmWifiFrequencyBandType_IsValid(value));
  set_has_frequency_band();
  frequency_band_ = value;
}

// -------------------------------------------------------------------

// TWifiConfiguration

// optional bool enable_autoconn = 1;
inline bool TWifiConfiguration::has_enable_autoconn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWifiConfiguration::set_has_enable_autoconn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWifiConfiguration::clear_has_enable_autoconn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWifiConfiguration::clear_enable_autoconn() {
  enable_autoconn_ = false;
  clear_has_enable_autoconn();
}
inline bool TWifiConfiguration::enable_autoconn() const {
  return enable_autoconn_;
}
inline void TWifiConfiguration::set_enable_autoconn(bool value) {
  set_has_enable_autoconn();
  enable_autoconn_ = value;
}

// optional bool enable_autoip = 2;
inline bool TWifiConfiguration::has_enable_autoip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWifiConfiguration::set_has_enable_autoip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWifiConfiguration::clear_has_enable_autoip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWifiConfiguration::clear_enable_autoip() {
  enable_autoip_ = false;
  clear_has_enable_autoip();
}
inline bool TWifiConfiguration::enable_autoip() const {
  return enable_autoip_;
}
inline void TWifiConfiguration::set_enable_autoip(bool value) {
  set_has_enable_autoip();
  enable_autoip_ = value;
}

// optional uint32 ip = 3;
inline bool TWifiConfiguration::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TWifiConfiguration::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TWifiConfiguration::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TWifiConfiguration::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TWifiConfiguration::ip() const {
  return ip_;
}
inline void TWifiConfiguration::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 mask = 4;
inline bool TWifiConfiguration::has_mask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TWifiConfiguration::set_has_mask() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TWifiConfiguration::clear_has_mask() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TWifiConfiguration::clear_mask() {
  mask_ = 0u;
  clear_has_mask();
}
inline ::google::protobuf::uint32 TWifiConfiguration::mask() const {
  return mask_;
}
inline void TWifiConfiguration::set_mask(::google::protobuf::uint32 value) {
  set_has_mask();
  mask_ = value;
}

// optional uint32 gateway = 5;
inline bool TWifiConfiguration::has_gateway() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TWifiConfiguration::set_has_gateway() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TWifiConfiguration::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TWifiConfiguration::clear_gateway() {
  gateway_ = 0u;
  clear_has_gateway();
}
inline ::google::protobuf::uint32 TWifiConfiguration::gateway() const {
  return gateway_;
}
inline void TWifiConfiguration::set_gateway(::google::protobuf::uint32 value) {
  set_has_gateway();
  gateway_ = value;
}

// -------------------------------------------------------------------

// TWifiScanResult

// optional string ssid = 1;
inline bool TWifiScanResult::has_ssid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWifiScanResult::set_has_ssid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWifiScanResult::clear_has_ssid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWifiScanResult::clear_ssid() {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    ssid_->clear();
  }
  clear_has_ssid();
}
inline const ::std::string& TWifiScanResult::ssid() const {
  return *ssid_;
}
inline void TWifiScanResult::set_ssid(const ::std::string& value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TWifiScanResult::set_ssid(const char* value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TWifiScanResult::set_ssid(const char* value, size_t size) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWifiScanResult::mutable_ssid() {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  return ssid_;
}
inline ::std::string* TWifiScanResult::release_ssid() {
  clear_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ssid_;
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWifiScanResult::set_allocated_ssid(::std::string* ssid) {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    delete ssid_;
  }
  if (ssid) {
    set_has_ssid();
    ssid_ = ssid;
  } else {
    clear_has_ssid();
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmWifiKeyType capabilities = 2;
inline bool TWifiScanResult::has_capabilities() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWifiScanResult::set_has_capabilities() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWifiScanResult::clear_has_capabilities() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWifiScanResult::clear_capabilities() {
  capabilities_ = 0;
  clear_has_capabilities();
}
inline ::mt::EmWifiKeyType TWifiScanResult::capabilities() const {
  return static_cast< ::mt::EmWifiKeyType >(capabilities_);
}
inline void TWifiScanResult::set_capabilities(::mt::EmWifiKeyType value) {
  assert(::mt::EmWifiKeyType_IsValid(value));
  set_has_capabilities();
  capabilities_ = value;
}

// optional .mt.EmWifiSignalLevel signalLevel = 3;
inline bool TWifiScanResult::has_signallevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TWifiScanResult::set_has_signallevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TWifiScanResult::clear_has_signallevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TWifiScanResult::clear_signallevel() {
  signallevel_ = 0;
  clear_has_signallevel();
}
inline ::mt::EmWifiSignalLevel TWifiScanResult::signallevel() const {
  return static_cast< ::mt::EmWifiSignalLevel >(signallevel_);
}
inline void TWifiScanResult::set_signallevel(::mt::EmWifiSignalLevel value) {
  assert(::mt::EmWifiSignalLevel_IsValid(value));
  set_has_signallevel();
  signallevel_ = value;
}

// optional bool issave = 4;
inline bool TWifiScanResult::has_issave() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TWifiScanResult::set_has_issave() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TWifiScanResult::clear_has_issave() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TWifiScanResult::clear_issave() {
  issave_ = false;
  clear_has_issave();
}
inline bool TWifiScanResult::issave() const {
  return issave_;
}
inline void TWifiScanResult::set_issave(bool value) {
  set_has_issave();
  issave_ = value;
}

// optional int32 networkid = 5;
inline bool TWifiScanResult::has_networkid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TWifiScanResult::set_has_networkid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TWifiScanResult::clear_has_networkid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TWifiScanResult::clear_networkid() {
  networkid_ = 0;
  clear_has_networkid();
}
inline ::google::protobuf::int32 TWifiScanResult::networkid() const {
  return networkid_;
}
inline void TWifiScanResult::set_networkid(::google::protobuf::int32 value) {
  set_has_networkid();
  networkid_ = value;
}

// -------------------------------------------------------------------

// TWifiScanResultList

// repeated .mt.TWifiScanResult scan_list = 1;
inline int TWifiScanResultList::scan_list_size() const {
  return scan_list_.size();
}
inline void TWifiScanResultList::clear_scan_list() {
  scan_list_.Clear();
}
inline const ::mt::TWifiScanResult& TWifiScanResultList::scan_list(int index) const {
  return scan_list_.Get(index);
}
inline ::mt::TWifiScanResult* TWifiScanResultList::mutable_scan_list(int index) {
  return scan_list_.Mutable(index);
}
inline ::mt::TWifiScanResult* TWifiScanResultList::add_scan_list() {
  return scan_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TWifiScanResult >&
TWifiScanResultList::scan_list() const {
  return scan_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TWifiScanResult >*
TWifiScanResultList::mutable_scan_list() {
  return &scan_list_;
}

// -------------------------------------------------------------------

// TWifiCurDetailInfo

// optional .mt.EmWifiLinkState state = 1;
inline bool TWifiCurDetailInfo::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWifiCurDetailInfo::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWifiCurDetailInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWifiCurDetailInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::mt::EmWifiLinkState TWifiCurDetailInfo::state() const {
  return static_cast< ::mt::EmWifiLinkState >(state_);
}
inline void TWifiCurDetailInfo::set_state(::mt::EmWifiLinkState value) {
  assert(::mt::EmWifiLinkState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional int32 networkid = 2;
inline bool TWifiCurDetailInfo::has_networkid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWifiCurDetailInfo::set_has_networkid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWifiCurDetailInfo::clear_has_networkid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWifiCurDetailInfo::clear_networkid() {
  networkid_ = 0;
  clear_has_networkid();
}
inline ::google::protobuf::int32 TWifiCurDetailInfo::networkid() const {
  return networkid_;
}
inline void TWifiCurDetailInfo::set_networkid(::google::protobuf::int32 value) {
  set_has_networkid();
  networkid_ = value;
}

// optional string ssid = 3;
inline bool TWifiCurDetailInfo::has_ssid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TWifiCurDetailInfo::set_has_ssid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TWifiCurDetailInfo::clear_has_ssid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TWifiCurDetailInfo::clear_ssid() {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    ssid_->clear();
  }
  clear_has_ssid();
}
inline const ::std::string& TWifiCurDetailInfo::ssid() const {
  return *ssid_;
}
inline void TWifiCurDetailInfo::set_ssid(const ::std::string& value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TWifiCurDetailInfo::set_ssid(const char* value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TWifiCurDetailInfo::set_ssid(const char* value, size_t size) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWifiCurDetailInfo::mutable_ssid() {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  return ssid_;
}
inline ::std::string* TWifiCurDetailInfo::release_ssid() {
  clear_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ssid_;
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWifiCurDetailInfo::set_allocated_ssid(::std::string* ssid) {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    delete ssid_;
  }
  if (ssid) {
    set_has_ssid();
    ssid_ = ssid;
  } else {
    clear_has_ssid();
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bssid = 4;
inline bool TWifiCurDetailInfo::has_bssid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TWifiCurDetailInfo::set_has_bssid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TWifiCurDetailInfo::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TWifiCurDetailInfo::clear_bssid() {
  if (bssid_ != &::google::protobuf::internal::kEmptyString) {
    bssid_->clear();
  }
  clear_has_bssid();
}
inline const ::std::string& TWifiCurDetailInfo::bssid() const {
  return *bssid_;
}
inline void TWifiCurDetailInfo::set_bssid(const ::std::string& value) {
  set_has_bssid();
  if (bssid_ == &::google::protobuf::internal::kEmptyString) {
    bssid_ = new ::std::string;
  }
  bssid_->assign(value);
}
inline void TWifiCurDetailInfo::set_bssid(const char* value) {
  set_has_bssid();
  if (bssid_ == &::google::protobuf::internal::kEmptyString) {
    bssid_ = new ::std::string;
  }
  bssid_->assign(value);
}
inline void TWifiCurDetailInfo::set_bssid(const char* value, size_t size) {
  set_has_bssid();
  if (bssid_ == &::google::protobuf::internal::kEmptyString) {
    bssid_ = new ::std::string;
  }
  bssid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWifiCurDetailInfo::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == &::google::protobuf::internal::kEmptyString) {
    bssid_ = new ::std::string;
  }
  return bssid_;
}
inline ::std::string* TWifiCurDetailInfo::release_bssid() {
  clear_has_bssid();
  if (bssid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bssid_;
    bssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWifiCurDetailInfo::set_allocated_bssid(::std::string* bssid) {
  if (bssid_ != &::google::protobuf::internal::kEmptyString) {
    delete bssid_;
  }
  if (bssid) {
    set_has_bssid();
    bssid_ = bssid;
  } else {
    clear_has_bssid();
    bssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mac_address = 5;
inline bool TWifiCurDetailInfo::has_mac_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TWifiCurDetailInfo::set_has_mac_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TWifiCurDetailInfo::clear_has_mac_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TWifiCurDetailInfo::clear_mac_address() {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    mac_address_->clear();
  }
  clear_has_mac_address();
}
inline const ::std::string& TWifiCurDetailInfo::mac_address() const {
  return *mac_address_;
}
inline void TWifiCurDetailInfo::set_mac_address(const ::std::string& value) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline void TWifiCurDetailInfo::set_mac_address(const char* value) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline void TWifiCurDetailInfo::set_mac_address(const char* value, size_t size) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWifiCurDetailInfo::mutable_mac_address() {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  return mac_address_;
}
inline ::std::string* TWifiCurDetailInfo::release_mac_address() {
  clear_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_address_;
    mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWifiCurDetailInfo::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_address_;
  }
  if (mac_address) {
    set_has_mac_address();
    mac_address_ = mac_address;
  } else {
    clear_has_mac_address();
    mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 6;
inline bool TWifiCurDetailInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TWifiCurDetailInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TWifiCurDetailInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TWifiCurDetailInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TWifiCurDetailInfo::ip() const {
  return ip_;
}
inline void TWifiCurDetailInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 mask = 7;
inline bool TWifiCurDetailInfo::has_mask() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TWifiCurDetailInfo::set_has_mask() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TWifiCurDetailInfo::clear_has_mask() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TWifiCurDetailInfo::clear_mask() {
  mask_ = 0u;
  clear_has_mask();
}
inline ::google::protobuf::uint32 TWifiCurDetailInfo::mask() const {
  return mask_;
}
inline void TWifiCurDetailInfo::set_mask(::google::protobuf::uint32 value) {
  set_has_mask();
  mask_ = value;
}

// optional uint32 gateway = 8;
inline bool TWifiCurDetailInfo::has_gateway() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TWifiCurDetailInfo::set_has_gateway() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TWifiCurDetailInfo::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TWifiCurDetailInfo::clear_gateway() {
  gateway_ = 0u;
  clear_has_gateway();
}
inline ::google::protobuf::uint32 TWifiCurDetailInfo::gateway() const {
  return gateway_;
}
inline void TWifiCurDetailInfo::set_gateway(::google::protobuf::uint32 value) {
  set_has_gateway();
  gateway_ = value;
}

// optional .mt.EmWifiLinkErrReason reason = 9;
inline bool TWifiCurDetailInfo::has_reason() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TWifiCurDetailInfo::set_has_reason() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TWifiCurDetailInfo::clear_has_reason() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TWifiCurDetailInfo::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::mt::EmWifiLinkErrReason TWifiCurDetailInfo::reason() const {
  return static_cast< ::mt::EmWifiLinkErrReason >(reason_);
}
inline void TWifiCurDetailInfo::set_reason(::mt::EmWifiLinkErrReason value) {
  assert(::mt::EmWifiLinkErrReason_IsValid(value));
  set_has_reason();
  reason_ = value;
}

// -------------------------------------------------------------------

// TWifiStatisInfo

// optional string ssid = 1;
inline bool TWifiStatisInfo::has_ssid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWifiStatisInfo::set_has_ssid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWifiStatisInfo::clear_has_ssid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWifiStatisInfo::clear_ssid() {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    ssid_->clear();
  }
  clear_has_ssid();
}
inline const ::std::string& TWifiStatisInfo::ssid() const {
  return *ssid_;
}
inline void TWifiStatisInfo::set_ssid(const ::std::string& value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TWifiStatisInfo::set_ssid(const char* value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TWifiStatisInfo::set_ssid(const char* value, size_t size) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWifiStatisInfo::mutable_ssid() {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  return ssid_;
}
inline ::std::string* TWifiStatisInfo::release_ssid() {
  clear_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ssid_;
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWifiStatisInfo::set_allocated_ssid(::std::string* ssid) {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    delete ssid_;
  }
  if (ssid) {
    set_has_ssid();
    ssid_ = ssid;
  } else {
    clear_has_ssid();
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 networkid = 2;
inline bool TWifiStatisInfo::has_networkid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWifiStatisInfo::set_has_networkid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWifiStatisInfo::clear_has_networkid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWifiStatisInfo::clear_networkid() {
  networkid_ = 0;
  clear_has_networkid();
}
inline ::google::protobuf::int32 TWifiStatisInfo::networkid() const {
  return networkid_;
}
inline void TWifiStatisInfo::set_networkid(::google::protobuf::int32 value) {
  set_has_networkid();
  networkid_ = value;
}

// optional .mt.EmWifiSignalLevel signalLevel = 3;
inline bool TWifiStatisInfo::has_signallevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TWifiStatisInfo::set_has_signallevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TWifiStatisInfo::clear_has_signallevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TWifiStatisInfo::clear_signallevel() {
  signallevel_ = 0;
  clear_has_signallevel();
}
inline ::mt::EmWifiSignalLevel TWifiStatisInfo::signallevel() const {
  return static_cast< ::mt::EmWifiSignalLevel >(signallevel_);
}
inline void TWifiStatisInfo::set_signallevel(::mt::EmWifiSignalLevel value) {
  assert(::mt::EmWifiSignalLevel_IsValid(value));
  set_has_signallevel();
  signallevel_ = value;
}

// optional uint32 down_total_bytes = 4;
inline bool TWifiStatisInfo::has_down_total_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TWifiStatisInfo::set_has_down_total_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TWifiStatisInfo::clear_has_down_total_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TWifiStatisInfo::clear_down_total_bytes() {
  down_total_bytes_ = 0u;
  clear_has_down_total_bytes();
}
inline ::google::protobuf::uint32 TWifiStatisInfo::down_total_bytes() const {
  return down_total_bytes_;
}
inline void TWifiStatisInfo::set_down_total_bytes(::google::protobuf::uint32 value) {
  set_has_down_total_bytes();
  down_total_bytes_ = value;
}

// optional uint32 up_total_bytes = 5;
inline bool TWifiStatisInfo::has_up_total_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TWifiStatisInfo::set_has_up_total_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TWifiStatisInfo::clear_has_up_total_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TWifiStatisInfo::clear_up_total_bytes() {
  up_total_bytes_ = 0u;
  clear_has_up_total_bytes();
}
inline ::google::protobuf::uint32 TWifiStatisInfo::up_total_bytes() const {
  return up_total_bytes_;
}
inline void TWifiStatisInfo::set_up_total_bytes(::google::protobuf::uint32 value) {
  set_has_up_total_bytes();
  up_total_bytes_ = value;
}

// -------------------------------------------------------------------

// TWifiConnParam

// optional bool issave = 1;
inline bool TWifiConnParam::has_issave() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWifiConnParam::set_has_issave() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWifiConnParam::clear_has_issave() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWifiConnParam::clear_issave() {
  issave_ = false;
  clear_has_issave();
}
inline bool TWifiConnParam::issave() const {
  return issave_;
}
inline void TWifiConnParam::set_issave(bool value) {
  set_has_issave();
  issave_ = value;
}

// optional string ssid = 2;
inline bool TWifiConnParam::has_ssid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWifiConnParam::set_has_ssid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWifiConnParam::clear_has_ssid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWifiConnParam::clear_ssid() {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    ssid_->clear();
  }
  clear_has_ssid();
}
inline const ::std::string& TWifiConnParam::ssid() const {
  return *ssid_;
}
inline void TWifiConnParam::set_ssid(const ::std::string& value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TWifiConnParam::set_ssid(const char* value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TWifiConnParam::set_ssid(const char* value, size_t size) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWifiConnParam::mutable_ssid() {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  return ssid_;
}
inline ::std::string* TWifiConnParam::release_ssid() {
  clear_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ssid_;
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWifiConnParam::set_allocated_ssid(::std::string* ssid) {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    delete ssid_;
  }
  if (ssid) {
    set_has_ssid();
    ssid_ = ssid;
  } else {
    clear_has_ssid();
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmWifiKeyType capabilities = 3;
inline bool TWifiConnParam::has_capabilities() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TWifiConnParam::set_has_capabilities() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TWifiConnParam::clear_has_capabilities() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TWifiConnParam::clear_capabilities() {
  capabilities_ = 0;
  clear_has_capabilities();
}
inline ::mt::EmWifiKeyType TWifiConnParam::capabilities() const {
  return static_cast< ::mt::EmWifiKeyType >(capabilities_);
}
inline void TWifiConnParam::set_capabilities(::mt::EmWifiKeyType value) {
  assert(::mt::EmWifiKeyType_IsValid(value));
  set_has_capabilities();
  capabilities_ = value;
}

// optional string password = 4;
inline bool TWifiConnParam::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TWifiConnParam::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TWifiConnParam::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TWifiConnParam::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TWifiConnParam::password() const {
  return *password_;
}
inline void TWifiConnParam::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TWifiConnParam::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TWifiConnParam::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TWifiConnParam::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TWifiConnParam::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TWifiConnParam::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 networkid = 5;
inline bool TWifiConnParam::has_networkid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TWifiConnParam::set_has_networkid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TWifiConnParam::clear_has_networkid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TWifiConnParam::clear_networkid() {
  networkid_ = 0;
  clear_has_networkid();
}
inline ::google::protobuf::int32 TWifiConnParam::networkid() const {
  return networkid_;
}
inline void TWifiConnParam::set_networkid(::google::protobuf::int32 value) {
  set_has_networkid();
  networkid_ = value;
}

// -------------------------------------------------------------------

// TMobileDataWorkMode

// optional bool enable = 1;
inline bool TMobileDataWorkMode::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMobileDataWorkMode::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMobileDataWorkMode::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMobileDataWorkMode::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMobileDataWorkMode::enable() const {
  return enable_;
}
inline void TMobileDataWorkMode::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// -------------------------------------------------------------------

// TMobileDataCurDetailInfo

// optional .mt.EmMobileDataLinkState state = 1;
inline bool TMobileDataCurDetailInfo::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMobileDataCurDetailInfo::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMobileDataCurDetailInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMobileDataCurDetailInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::mt::EmMobileDataLinkState TMobileDataCurDetailInfo::state() const {
  return static_cast< ::mt::EmMobileDataLinkState >(state_);
}
inline void TMobileDataCurDetailInfo::set_state(::mt::EmMobileDataLinkState value) {
  assert(::mt::EmMobileDataLinkState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .mt.EmMobileDataNetType emNetType = 2;
inline bool TMobileDataCurDetailInfo::has_emnettype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMobileDataCurDetailInfo::set_has_emnettype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMobileDataCurDetailInfo::clear_has_emnettype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMobileDataCurDetailInfo::clear_emnettype() {
  emnettype_ = 0;
  clear_has_emnettype();
}
inline ::mt::EmMobileDataNetType TMobileDataCurDetailInfo::emnettype() const {
  return static_cast< ::mt::EmMobileDataNetType >(emnettype_);
}
inline void TMobileDataCurDetailInfo::set_emnettype(::mt::EmMobileDataNetType value) {
  assert(::mt::EmMobileDataNetType_IsValid(value));
  set_has_emnettype();
  emnettype_ = value;
}

// optional .mt.EmMobileDataNetGenerationType emGenerationType = 3;
inline bool TMobileDataCurDetailInfo::has_emgenerationtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMobileDataCurDetailInfo::set_has_emgenerationtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMobileDataCurDetailInfo::clear_has_emgenerationtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMobileDataCurDetailInfo::clear_emgenerationtype() {
  emgenerationtype_ = 0;
  clear_has_emgenerationtype();
}
inline ::mt::EmMobileDataNetGenerationType TMobileDataCurDetailInfo::emgenerationtype() const {
  return static_cast< ::mt::EmMobileDataNetGenerationType >(emgenerationtype_);
}
inline void TMobileDataCurDetailInfo::set_emgenerationtype(::mt::EmMobileDataNetGenerationType value) {
  assert(::mt::EmMobileDataNetGenerationType_IsValid(value));
  set_has_emgenerationtype();
  emgenerationtype_ = value;
}

// optional string ssid = 4;
inline bool TMobileDataCurDetailInfo::has_ssid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMobileDataCurDetailInfo::set_has_ssid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMobileDataCurDetailInfo::clear_has_ssid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMobileDataCurDetailInfo::clear_ssid() {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    ssid_->clear();
  }
  clear_has_ssid();
}
inline const ::std::string& TMobileDataCurDetailInfo::ssid() const {
  return *ssid_;
}
inline void TMobileDataCurDetailInfo::set_ssid(const ::std::string& value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TMobileDataCurDetailInfo::set_ssid(const char* value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void TMobileDataCurDetailInfo::set_ssid(const char* value, size_t size) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMobileDataCurDetailInfo::mutable_ssid() {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  return ssid_;
}
inline ::std::string* TMobileDataCurDetailInfo::release_ssid() {
  clear_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ssid_;
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMobileDataCurDetailInfo::set_allocated_ssid(::std::string* ssid) {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    delete ssid_;
  }
  if (ssid) {
    set_has_ssid();
    ssid_ = ssid;
  } else {
    clear_has_ssid();
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 5;
inline bool TMobileDataCurDetailInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMobileDataCurDetailInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMobileDataCurDetailInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMobileDataCurDetailInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMobileDataCurDetailInfo::ip() const {
  return ip_;
}
inline void TMobileDataCurDetailInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional string conn_time = 6;
inline bool TMobileDataCurDetailInfo::has_conn_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMobileDataCurDetailInfo::set_has_conn_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMobileDataCurDetailInfo::clear_has_conn_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMobileDataCurDetailInfo::clear_conn_time() {
  if (conn_time_ != &::google::protobuf::internal::kEmptyString) {
    conn_time_->clear();
  }
  clear_has_conn_time();
}
inline const ::std::string& TMobileDataCurDetailInfo::conn_time() const {
  return *conn_time_;
}
inline void TMobileDataCurDetailInfo::set_conn_time(const ::std::string& value) {
  set_has_conn_time();
  if (conn_time_ == &::google::protobuf::internal::kEmptyString) {
    conn_time_ = new ::std::string;
  }
  conn_time_->assign(value);
}
inline void TMobileDataCurDetailInfo::set_conn_time(const char* value) {
  set_has_conn_time();
  if (conn_time_ == &::google::protobuf::internal::kEmptyString) {
    conn_time_ = new ::std::string;
  }
  conn_time_->assign(value);
}
inline void TMobileDataCurDetailInfo::set_conn_time(const char* value, size_t size) {
  set_has_conn_time();
  if (conn_time_ == &::google::protobuf::internal::kEmptyString) {
    conn_time_ = new ::std::string;
  }
  conn_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMobileDataCurDetailInfo::mutable_conn_time() {
  set_has_conn_time();
  if (conn_time_ == &::google::protobuf::internal::kEmptyString) {
    conn_time_ = new ::std::string;
  }
  return conn_time_;
}
inline ::std::string* TMobileDataCurDetailInfo::release_conn_time() {
  clear_has_conn_time();
  if (conn_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conn_time_;
    conn_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMobileDataCurDetailInfo::set_allocated_conn_time(::std::string* conn_time) {
  if (conn_time_ != &::google::protobuf::internal::kEmptyString) {
    delete conn_time_;
  }
  if (conn_time) {
    set_has_conn_time();
    conn_time_ = conn_time;
  } else {
    clear_has_conn_time();
    conn_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMobileDataLinkErrReason reason = 7;
inline bool TMobileDataCurDetailInfo::has_reason() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMobileDataCurDetailInfo::set_has_reason() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMobileDataCurDetailInfo::clear_has_reason() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMobileDataCurDetailInfo::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::mt::EmMobileDataLinkErrReason TMobileDataCurDetailInfo::reason() const {
  return static_cast< ::mt::EmMobileDataLinkErrReason >(reason_);
}
inline void TMobileDataCurDetailInfo::set_reason(::mt::EmMobileDataLinkErrReason value) {
  assert(::mt::EmMobileDataLinkErrReason_IsValid(value));
  set_has_reason();
  reason_ = value;
}

// -------------------------------------------------------------------

// TMobileDataStatisInfo

// optional .mt.EmMobileDataSignalLevel signalLevel = 1;
inline bool TMobileDataStatisInfo::has_signallevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMobileDataStatisInfo::set_has_signallevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMobileDataStatisInfo::clear_has_signallevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMobileDataStatisInfo::clear_signallevel() {
  signallevel_ = 0;
  clear_has_signallevel();
}
inline ::mt::EmMobileDataSignalLevel TMobileDataStatisInfo::signallevel() const {
  return static_cast< ::mt::EmMobileDataSignalLevel >(signallevel_);
}
inline void TMobileDataStatisInfo::set_signallevel(::mt::EmMobileDataSignalLevel value) {
  assert(::mt::EmMobileDataSignalLevel_IsValid(value));
  set_has_signallevel();
  signallevel_ = value;
}

// optional uint32 up_bandwidth = 2;
inline bool TMobileDataStatisInfo::has_up_bandwidth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMobileDataStatisInfo::set_has_up_bandwidth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMobileDataStatisInfo::clear_has_up_bandwidth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMobileDataStatisInfo::clear_up_bandwidth() {
  up_bandwidth_ = 0u;
  clear_has_up_bandwidth();
}
inline ::google::protobuf::uint32 TMobileDataStatisInfo::up_bandwidth() const {
  return up_bandwidth_;
}
inline void TMobileDataStatisInfo::set_up_bandwidth(::google::protobuf::uint32 value) {
  set_has_up_bandwidth();
  up_bandwidth_ = value;
}

// optional uint32 down_bandwidth = 3;
inline bool TMobileDataStatisInfo::has_down_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMobileDataStatisInfo::set_has_down_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMobileDataStatisInfo::clear_has_down_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMobileDataStatisInfo::clear_down_bandwidth() {
  down_bandwidth_ = 0u;
  clear_has_down_bandwidth();
}
inline ::google::protobuf::uint32 TMobileDataStatisInfo::down_bandwidth() const {
  return down_bandwidth_;
}
inline void TMobileDataStatisInfo::set_down_bandwidth(::google::protobuf::uint32 value) {
  set_has_down_bandwidth();
  down_bandwidth_ = value;
}

// optional uint32 up_bytes = 4;
inline bool TMobileDataStatisInfo::has_up_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMobileDataStatisInfo::set_has_up_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMobileDataStatisInfo::clear_has_up_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMobileDataStatisInfo::clear_up_bytes() {
  up_bytes_ = 0u;
  clear_has_up_bytes();
}
inline ::google::protobuf::uint32 TMobileDataStatisInfo::up_bytes() const {
  return up_bytes_;
}
inline void TMobileDataStatisInfo::set_up_bytes(::google::protobuf::uint32 value) {
  set_has_up_bytes();
  up_bytes_ = value;
}

// optional uint32 down_bytes = 5;
inline bool TMobileDataStatisInfo::has_down_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMobileDataStatisInfo::set_has_down_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMobileDataStatisInfo::clear_has_down_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMobileDataStatisInfo::clear_down_bytes() {
  down_bytes_ = 0u;
  clear_has_down_bytes();
}
inline ::google::protobuf::uint32 TMobileDataStatisInfo::down_bytes() const {
  return down_bytes_;
}
inline void TMobileDataStatisInfo::set_down_bytes(::google::protobuf::uint32 value) {
  set_has_down_bytes();
  down_bytes_ = value;
}

// -------------------------------------------------------------------

// TRouteItemInfo

// optional uint32 interface = 1;
inline bool TRouteItemInfo::has_interface() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRouteItemInfo::set_has_interface() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRouteItemInfo::clear_has_interface() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRouteItemInfo::clear_interface() {
  interface_ = 0u;
  clear_has_interface();
}
inline ::google::protobuf::uint32 TRouteItemInfo::interface() const {
  return interface_;
}
inline void TRouteItemInfo::set_interface(::google::protobuf::uint32 value) {
  set_has_interface();
  interface_ = value;
}

// optional uint32 dest_network = 2;
inline bool TRouteItemInfo::has_dest_network() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRouteItemInfo::set_has_dest_network() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRouteItemInfo::clear_has_dest_network() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRouteItemInfo::clear_dest_network() {
  dest_network_ = 0u;
  clear_has_dest_network();
}
inline ::google::protobuf::uint32 TRouteItemInfo::dest_network() const {
  return dest_network_;
}
inline void TRouteItemInfo::set_dest_network(::google::protobuf::uint32 value) {
  set_has_dest_network();
  dest_network_ = value;
}

// optional uint32 dest_netmask = 3;
inline bool TRouteItemInfo::has_dest_netmask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TRouteItemInfo::set_has_dest_netmask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TRouteItemInfo::clear_has_dest_netmask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TRouteItemInfo::clear_dest_netmask() {
  dest_netmask_ = 0u;
  clear_has_dest_netmask();
}
inline ::google::protobuf::uint32 TRouteItemInfo::dest_netmask() const {
  return dest_netmask_;
}
inline void TRouteItemInfo::set_dest_netmask(::google::protobuf::uint32 value) {
  set_has_dest_netmask();
  dest_netmask_ = value;
}

// optional uint32 gateway = 4;
inline bool TRouteItemInfo::has_gateway() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TRouteItemInfo::set_has_gateway() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TRouteItemInfo::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TRouteItemInfo::clear_gateway() {
  gateway_ = 0u;
  clear_has_gateway();
}
inline ::google::protobuf::uint32 TRouteItemInfo::gateway() const {
  return gateway_;
}
inline void TRouteItemInfo::set_gateway(::google::protobuf::uint32 value) {
  set_has_gateway();
  gateway_ = value;
}

// optional uint32 priority = 5;
inline bool TRouteItemInfo::has_priority() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TRouteItemInfo::set_has_priority() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TRouteItemInfo::clear_has_priority() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TRouteItemInfo::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 TRouteItemInfo::priority() const {
  return priority_;
}
inline void TRouteItemInfo::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
}

// -------------------------------------------------------------------

// TRouteItemInfoList

// repeated .mt.TRouteItemInfo route_list = 1;
inline int TRouteItemInfoList::route_list_size() const {
  return route_list_.size();
}
inline void TRouteItemInfoList::clear_route_list() {
  route_list_.Clear();
}
inline const ::mt::TRouteItemInfo& TRouteItemInfoList::route_list(int index) const {
  return route_list_.Get(index);
}
inline ::mt::TRouteItemInfo* TRouteItemInfoList::mutable_route_list(int index) {
  return route_list_.Mutable(index);
}
inline ::mt::TRouteItemInfo* TRouteItemInfoList::add_route_list() {
  return route_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TRouteItemInfo >&
TRouteItemInfoList::route_list() const {
  return route_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TRouteItemInfo >*
TRouteItemInfoList::mutable_route_list() {
  return &route_list_;
}

// -------------------------------------------------------------------

// TE1RouteItemInfo

// optional uint32 interface = 1;
inline bool TE1RouteItemInfo::has_interface() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TE1RouteItemInfo::set_has_interface() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TE1RouteItemInfo::clear_has_interface() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TE1RouteItemInfo::clear_interface() {
  interface_ = 0u;
  clear_has_interface();
}
inline ::google::protobuf::uint32 TE1RouteItemInfo::interface() const {
  return interface_;
}
inline void TE1RouteItemInfo::set_interface(::google::protobuf::uint32 value) {
  set_has_interface();
  interface_ = value;
}

// optional uint32 dest_network = 2;
inline bool TE1RouteItemInfo::has_dest_network() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TE1RouteItemInfo::set_has_dest_network() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TE1RouteItemInfo::clear_has_dest_network() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TE1RouteItemInfo::clear_dest_network() {
  dest_network_ = 0u;
  clear_has_dest_network();
}
inline ::google::protobuf::uint32 TE1RouteItemInfo::dest_network() const {
  return dest_network_;
}
inline void TE1RouteItemInfo::set_dest_network(::google::protobuf::uint32 value) {
  set_has_dest_network();
  dest_network_ = value;
}

// optional uint32 dest_netmask = 3;
inline bool TE1RouteItemInfo::has_dest_netmask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TE1RouteItemInfo::set_has_dest_netmask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TE1RouteItemInfo::clear_has_dest_netmask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TE1RouteItemInfo::clear_dest_netmask() {
  dest_netmask_ = 0u;
  clear_has_dest_netmask();
}
inline ::google::protobuf::uint32 TE1RouteItemInfo::dest_netmask() const {
  return dest_netmask_;
}
inline void TE1RouteItemInfo::set_dest_netmask(::google::protobuf::uint32 value) {
  set_has_dest_netmask();
  dest_netmask_ = value;
}

// optional uint32 gateway = 4;
inline bool TE1RouteItemInfo::has_gateway() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TE1RouteItemInfo::set_has_gateway() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TE1RouteItemInfo::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TE1RouteItemInfo::clear_gateway() {
  gateway_ = 0u;
  clear_has_gateway();
}
inline ::google::protobuf::uint32 TE1RouteItemInfo::gateway() const {
  return gateway_;
}
inline void TE1RouteItemInfo::set_gateway(::google::protobuf::uint32 value) {
  set_has_gateway();
  gateway_ = value;
}

// optional uint32 priority = 5;
inline bool TE1RouteItemInfo::has_priority() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TE1RouteItemInfo::set_has_priority() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TE1RouteItemInfo::clear_has_priority() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TE1RouteItemInfo::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 TE1RouteItemInfo::priority() const {
  return priority_;
}
inline void TE1RouteItemInfo::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
}

// optional string ifname = 6;
inline bool TE1RouteItemInfo::has_ifname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TE1RouteItemInfo::set_has_ifname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TE1RouteItemInfo::clear_has_ifname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TE1RouteItemInfo::clear_ifname() {
  if (ifname_ != &::google::protobuf::internal::kEmptyString) {
    ifname_->clear();
  }
  clear_has_ifname();
}
inline const ::std::string& TE1RouteItemInfo::ifname() const {
  return *ifname_;
}
inline void TE1RouteItemInfo::set_ifname(const ::std::string& value) {
  set_has_ifname();
  if (ifname_ == &::google::protobuf::internal::kEmptyString) {
    ifname_ = new ::std::string;
  }
  ifname_->assign(value);
}
inline void TE1RouteItemInfo::set_ifname(const char* value) {
  set_has_ifname();
  if (ifname_ == &::google::protobuf::internal::kEmptyString) {
    ifname_ = new ::std::string;
  }
  ifname_->assign(value);
}
inline void TE1RouteItemInfo::set_ifname(const char* value, size_t size) {
  set_has_ifname();
  if (ifname_ == &::google::protobuf::internal::kEmptyString) {
    ifname_ = new ::std::string;
  }
  ifname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1RouteItemInfo::mutable_ifname() {
  set_has_ifname();
  if (ifname_ == &::google::protobuf::internal::kEmptyString) {
    ifname_ = new ::std::string;
  }
  return ifname_;
}
inline ::std::string* TE1RouteItemInfo::release_ifname() {
  clear_has_ifname();
  if (ifname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ifname_;
    ifname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1RouteItemInfo::set_allocated_ifname(::std::string* ifname) {
  if (ifname_ != &::google::protobuf::internal::kEmptyString) {
    delete ifname_;
  }
  if (ifname) {
    set_has_ifname();
    ifname_ = ifname;
  } else {
    clear_has_ifname();
    ifname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TE1RouteItemInfoList

// repeated .mt.TE1RouteItemInfo route_list = 1;
inline int TE1RouteItemInfoList::route_list_size() const {
  return route_list_.size();
}
inline void TE1RouteItemInfoList::clear_route_list() {
  route_list_.Clear();
}
inline const ::mt::TE1RouteItemInfo& TE1RouteItemInfoList::route_list(int index) const {
  return route_list_.Get(index);
}
inline ::mt::TE1RouteItemInfo* TE1RouteItemInfoList::mutable_route_list(int index) {
  return route_list_.Mutable(index);
}
inline ::mt::TE1RouteItemInfo* TE1RouteItemInfoList::add_route_list() {
  return route_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TE1RouteItemInfo >&
TE1RouteItemInfoList::route_list() const {
  return route_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TE1RouteItemInfo >*
TE1RouteItemInfoList::mutable_route_list() {
  return &route_list_;
}

// -------------------------------------------------------------------

// TNetUsedInfo

// optional .mt.EmNetAdapterWorkType used_type = 1;
inline bool TNetUsedInfo::has_used_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNetUsedInfo::set_has_used_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNetUsedInfo::clear_has_used_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNetUsedInfo::clear_used_type() {
  used_type_ = 0;
  clear_has_used_type();
}
inline ::mt::EmNetAdapterWorkType TNetUsedInfo::used_type() const {
  return static_cast< ::mt::EmNetAdapterWorkType >(used_type_);
}
inline void TNetUsedInfo::set_used_type(::mt::EmNetAdapterWorkType value) {
  assert(::mt::EmNetAdapterWorkType_IsValid(value));
  set_has_used_type();
  used_type_ = value;
}

// optional uint32 ip = 2;
inline bool TNetUsedInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNetUsedInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNetUsedInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNetUsedInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TNetUsedInfo::ip() const {
  return ip_;
}
inline void TNetUsedInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 mask = 3;
inline bool TNetUsedInfo::has_mask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNetUsedInfo::set_has_mask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNetUsedInfo::clear_has_mask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNetUsedInfo::clear_mask() {
  mask_ = 0u;
  clear_has_mask();
}
inline ::google::protobuf::uint32 TNetUsedInfo::mask() const {
  return mask_;
}
inline void TNetUsedInfo::set_mask(::google::protobuf::uint32 value) {
  set_has_mask();
  mask_ = value;
}

// optional uint32 gateway_ip = 4;
inline bool TNetUsedInfo::has_gateway_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNetUsedInfo::set_has_gateway_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNetUsedInfo::clear_has_gateway_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNetUsedInfo::clear_gateway_ip() {
  gateway_ip_ = 0u;
  clear_has_gateway_ip();
}
inline ::google::protobuf::uint32 TNetUsedInfo::gateway_ip() const {
  return gateway_ip_;
}
inline void TNetUsedInfo::set_gateway_ip(::google::protobuf::uint32 value) {
  set_has_gateway_ip();
  gateway_ip_ = value;
}

// optional uint32 dns = 5;
inline bool TNetUsedInfo::has_dns() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNetUsedInfo::set_has_dns() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNetUsedInfo::clear_has_dns() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNetUsedInfo::clear_dns() {
  dns_ = 0u;
  clear_has_dns();
}
inline ::google::protobuf::uint32 TNetUsedInfo::dns() const {
  return dns_;
}
inline void TNetUsedInfo::set_dns(::google::protobuf::uint32 value) {
  set_has_dns();
  dns_ = value;
}

// optional uint32 dns_backup = 6;
inline bool TNetUsedInfo::has_dns_backup() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNetUsedInfo::set_has_dns_backup() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNetUsedInfo::clear_has_dns_backup() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNetUsedInfo::clear_dns_backup() {
  dns_backup_ = 0u;
  clear_has_dns_backup();
}
inline ::google::protobuf::uint32 TNetUsedInfo::dns_backup() const {
  return dns_backup_;
}
inline void TNetUsedInfo::set_dns_backup(::google::protobuf::uint32 value) {
  set_has_dns_backup();
  dns_backup_ = value;
}

// -------------------------------------------------------------------

// TMTNTPInfo

// optional bool used_ntp = 1;
inline bool TMTNTPInfo::has_used_ntp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTNTPInfo::set_has_used_ntp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTNTPInfo::clear_has_used_ntp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTNTPInfo::clear_used_ntp() {
  used_ntp_ = false;
  clear_has_used_ntp();
}
inline bool TMTNTPInfo::used_ntp() const {
  return used_ntp_;
}
inline void TMTNTPInfo::set_used_ntp(bool value) {
  set_has_used_ntp();
  used_ntp_ = value;
}

// optional string domain = 2;
inline bool TMTNTPInfo::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTNTPInfo::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTNTPInfo::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTNTPInfo::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMTNTPInfo::domain() const {
  return *domain_;
}
inline void TMTNTPInfo::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMTNTPInfo::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMTNTPInfo::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTNTPInfo::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMTNTPInfo::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTNTPInfo::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 interval = 3;
inline bool TMTNTPInfo::has_interval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTNTPInfo::set_has_interval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTNTPInfo::clear_has_interval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTNTPInfo::clear_interval() {
  interval_ = 0u;
  clear_has_interval();
}
inline ::google::protobuf::uint32 TMTNTPInfo::interval() const {
  return interval_;
}
inline void TMTNTPInfo::set_interval(::google::protobuf::uint32 value) {
  set_has_interval();
  interval_ = value;
}

// -------------------------------------------------------------------

// TMTTimeZoneInfo

// optional .mt.EmTimeZone time_zone = 1;
inline bool TMTTimeZoneInfo::has_time_zone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTimeZoneInfo::set_has_time_zone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTimeZoneInfo::clear_has_time_zone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTimeZoneInfo::clear_time_zone() {
  time_zone_ = 0;
  clear_has_time_zone();
}
inline ::mt::EmTimeZone TMTTimeZoneInfo::time_zone() const {
  return static_cast< ::mt::EmTimeZone >(time_zone_);
}
inline void TMTTimeZoneInfo::set_time_zone(::mt::EmTimeZone value) {
  assert(::mt::EmTimeZone_IsValid(value));
  set_has_time_zone();
  time_zone_ = value;
}

// -------------------------------------------------------------------

// TMTFtpTelnetAccountInfo

// optional string username = 1;
inline bool TMTFtpTelnetAccountInfo::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTFtpTelnetAccountInfo::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTFtpTelnetAccountInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTFtpTelnetAccountInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMTFtpTelnetAccountInfo::username() const {
  return *username_;
}
inline void TMTFtpTelnetAccountInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTFtpTelnetAccountInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTFtpTelnetAccountInfo::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTFtpTelnetAccountInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMTFtpTelnetAccountInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTFtpTelnetAccountInfo::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool TMTFtpTelnetAccountInfo::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTFtpTelnetAccountInfo::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTFtpTelnetAccountInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTFtpTelnetAccountInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTFtpTelnetAccountInfo::password() const {
  return *password_;
}
inline void TMTFtpTelnetAccountInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTFtpTelnetAccountInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTFtpTelnetAccountInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTFtpTelnetAccountInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTFtpTelnetAccountInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTFtpTelnetAccountInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TServerTestResult

// optional uint32 userid = 1;
inline bool TServerTestResult::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TServerTestResult::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TServerTestResult::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TServerTestResult::clear_userid() {
  userid_ = 0u;
  clear_has_userid();
}
inline ::google::protobuf::uint32 TServerTestResult::userid() const {
  return userid_;
}
inline void TServerTestResult::set_userid(::google::protobuf::uint32 value) {
  set_has_userid();
  userid_ = value;
}

// optional bool isok = 2;
inline bool TServerTestResult::has_isok() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TServerTestResult::set_has_isok() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TServerTestResult::clear_has_isok() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TServerTestResult::clear_isok() {
  isok_ = false;
  clear_has_isok();
}
inline bool TServerTestResult::isok() const {
  return isok_;
}
inline void TServerTestResult::set_isok(bool value) {
  set_has_isok();
  isok_ = value;
}

// -------------------------------------------------------------------

// TWifiWirelessScreenInfo

// optional .mt.EmWirelessScreenState wirelessScreen_state = 1;
inline bool TWifiWirelessScreenInfo::has_wirelessscreen_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TWifiWirelessScreenInfo::set_has_wirelessscreen_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TWifiWirelessScreenInfo::clear_has_wirelessscreen_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TWifiWirelessScreenInfo::clear_wirelessscreen_state() {
  wirelessscreen_state_ = 0;
  clear_has_wirelessscreen_state();
}
inline ::mt::EmWirelessScreenState TWifiWirelessScreenInfo::wirelessscreen_state() const {
  return static_cast< ::mt::EmWirelessScreenState >(wirelessscreen_state_);
}
inline void TWifiWirelessScreenInfo::set_wirelessscreen_state(::mt::EmWirelessScreenState value) {
  assert(::mt::EmWirelessScreenState_IsValid(value));
  set_has_wirelessscreen_state();
  wirelessscreen_state_ = value;
}

// optional uint32 wirelessScreen_deviceNum = 2;
inline bool TWifiWirelessScreenInfo::has_wirelessscreen_devicenum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TWifiWirelessScreenInfo::set_has_wirelessscreen_devicenum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TWifiWirelessScreenInfo::clear_has_wirelessscreen_devicenum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TWifiWirelessScreenInfo::clear_wirelessscreen_devicenum() {
  wirelessscreen_devicenum_ = 0u;
  clear_has_wirelessscreen_devicenum();
}
inline ::google::protobuf::uint32 TWifiWirelessScreenInfo::wirelessscreen_devicenum() const {
  return wirelessscreen_devicenum_;
}
inline void TWifiWirelessScreenInfo::set_wirelessscreen_devicenum(::google::protobuf::uint32 value) {
  set_has_wirelessscreen_devicenum();
  wirelessscreen_devicenum_ = value;
}

// optional .mt.EmWirelessScreenErrReason wirelessScreen_ErrReason = 3;
inline bool TWifiWirelessScreenInfo::has_wirelessscreen_errreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TWifiWirelessScreenInfo::set_has_wirelessscreen_errreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TWifiWirelessScreenInfo::clear_has_wirelessscreen_errreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TWifiWirelessScreenInfo::clear_wirelessscreen_errreason() {
  wirelessscreen_errreason_ = 0;
  clear_has_wirelessscreen_errreason();
}
inline ::mt::EmWirelessScreenErrReason TWifiWirelessScreenInfo::wirelessscreen_errreason() const {
  return static_cast< ::mt::EmWirelessScreenErrReason >(wirelessscreen_errreason_);
}
inline void TWifiWirelessScreenInfo::set_wirelessscreen_errreason(::mt::EmWirelessScreenErrReason value) {
  assert(::mt::EmWirelessScreenErrReason_IsValid(value));
  set_has_wirelessscreen_errreason();
  wirelessscreen_errreason_ = value;
}

// -------------------------------------------------------------------

// TLimitedIpItemInfo

// optional uint32 start_ip = 1;
inline bool TLimitedIpItemInfo::has_start_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TLimitedIpItemInfo::set_has_start_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TLimitedIpItemInfo::clear_has_start_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TLimitedIpItemInfo::clear_start_ip() {
  start_ip_ = 0u;
  clear_has_start_ip();
}
inline ::google::protobuf::uint32 TLimitedIpItemInfo::start_ip() const {
  return start_ip_;
}
inline void TLimitedIpItemInfo::set_start_ip(::google::protobuf::uint32 value) {
  set_has_start_ip();
  start_ip_ = value;
}

// optional uint32 end_ip = 2;
inline bool TLimitedIpItemInfo::has_end_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TLimitedIpItemInfo::set_has_end_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TLimitedIpItemInfo::clear_has_end_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TLimitedIpItemInfo::clear_end_ip() {
  end_ip_ = 0u;
  clear_has_end_ip();
}
inline ::google::protobuf::uint32 TLimitedIpItemInfo::end_ip() const {
  return end_ip_;
}
inline void TLimitedIpItemInfo::set_end_ip(::google::protobuf::uint32 value) {
  set_has_end_ip();
  end_ip_ = value;
}

// -------------------------------------------------------------------

// TLimitedIpCfg

// optional bool enable = 1;
inline bool TLimitedIpCfg::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TLimitedIpCfg::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TLimitedIpCfg::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TLimitedIpCfg::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TLimitedIpCfg::enable() const {
  return enable_;
}
inline void TLimitedIpCfg::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional .mt.EmLimitedIpType limitedIp_type = 2;
inline bool TLimitedIpCfg::has_limitedip_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TLimitedIpCfg::set_has_limitedip_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TLimitedIpCfg::clear_has_limitedip_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TLimitedIpCfg::clear_limitedip_type() {
  limitedip_type_ = 0;
  clear_has_limitedip_type();
}
inline ::mt::EmLimitedIpType TLimitedIpCfg::limitedip_type() const {
  return static_cast< ::mt::EmLimitedIpType >(limitedip_type_);
}
inline void TLimitedIpCfg::set_limitedip_type(::mt::EmLimitedIpType value) {
  assert(::mt::EmLimitedIpType_IsValid(value));
  set_has_limitedip_type();
  limitedip_type_ = value;
}

// repeated .mt.TLimitedIpItemInfo limitedIp_List = 3;
inline int TLimitedIpCfg::limitedip_list_size() const {
  return limitedip_list_.size();
}
inline void TLimitedIpCfg::clear_limitedip_list() {
  limitedip_list_.Clear();
}
inline const ::mt::TLimitedIpItemInfo& TLimitedIpCfg::limitedip_list(int index) const {
  return limitedip_list_.Get(index);
}
inline ::mt::TLimitedIpItemInfo* TLimitedIpCfg::mutable_limitedip_list(int index) {
  return limitedip_list_.Mutable(index);
}
inline ::mt::TLimitedIpItemInfo* TLimitedIpCfg::add_limitedip_list() {
  return limitedip_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TLimitedIpItemInfo >&
TLimitedIpCfg::limitedip_list() const {
  return limitedip_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TLimitedIpItemInfo >*
TLimitedIpCfg::mutable_limitedip_list() {
  return &limitedip_list_;
}

// -------------------------------------------------------------------

// TNetCardStatis

// optional string netcard_name = 1;
inline bool TNetCardStatis::has_netcard_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNetCardStatis::set_has_netcard_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNetCardStatis::clear_has_netcard_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNetCardStatis::clear_netcard_name() {
  if (netcard_name_ != &::google::protobuf::internal::kEmptyString) {
    netcard_name_->clear();
  }
  clear_has_netcard_name();
}
inline const ::std::string& TNetCardStatis::netcard_name() const {
  return *netcard_name_;
}
inline void TNetCardStatis::set_netcard_name(const ::std::string& value) {
  set_has_netcard_name();
  if (netcard_name_ == &::google::protobuf::internal::kEmptyString) {
    netcard_name_ = new ::std::string;
  }
  netcard_name_->assign(value);
}
inline void TNetCardStatis::set_netcard_name(const char* value) {
  set_has_netcard_name();
  if (netcard_name_ == &::google::protobuf::internal::kEmptyString) {
    netcard_name_ = new ::std::string;
  }
  netcard_name_->assign(value);
}
inline void TNetCardStatis::set_netcard_name(const char* value, size_t size) {
  set_has_netcard_name();
  if (netcard_name_ == &::google::protobuf::internal::kEmptyString) {
    netcard_name_ = new ::std::string;
  }
  netcard_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNetCardStatis::mutable_netcard_name() {
  set_has_netcard_name();
  if (netcard_name_ == &::google::protobuf::internal::kEmptyString) {
    netcard_name_ = new ::std::string;
  }
  return netcard_name_;
}
inline ::std::string* TNetCardStatis::release_netcard_name() {
  clear_has_netcard_name();
  if (netcard_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = netcard_name_;
    netcard_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNetCardStatis::set_allocated_netcard_name(::std::string* netcard_name) {
  if (netcard_name_ != &::google::protobuf::internal::kEmptyString) {
    delete netcard_name_;
  }
  if (netcard_name) {
    set_has_netcard_name();
    netcard_name_ = netcard_name;
  } else {
    clear_has_netcard_name();
    netcard_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 send_flow_amount = 2;
inline bool TNetCardStatis::has_send_flow_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNetCardStatis::set_has_send_flow_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNetCardStatis::clear_has_send_flow_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNetCardStatis::clear_send_flow_amount() {
  send_flow_amount_ = 0u;
  clear_has_send_flow_amount();
}
inline ::google::protobuf::uint32 TNetCardStatis::send_flow_amount() const {
  return send_flow_amount_;
}
inline void TNetCardStatis::set_send_flow_amount(::google::protobuf::uint32 value) {
  set_has_send_flow_amount();
  send_flow_amount_ = value;
}

// optional uint32 recv_flow_amount = 3;
inline bool TNetCardStatis::has_recv_flow_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNetCardStatis::set_has_recv_flow_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNetCardStatis::clear_has_recv_flow_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNetCardStatis::clear_recv_flow_amount() {
  recv_flow_amount_ = 0u;
  clear_has_recv_flow_amount();
}
inline ::google::protobuf::uint32 TNetCardStatis::recv_flow_amount() const {
  return recv_flow_amount_;
}
inline void TNetCardStatis::set_recv_flow_amount(::google::protobuf::uint32 value) {
  set_has_recv_flow_amount();
  recv_flow_amount_ = value;
}

// optional .mt.EmNetAdapterWorkType netcard_type = 4;
inline bool TNetCardStatis::has_netcard_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNetCardStatis::set_has_netcard_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNetCardStatis::clear_has_netcard_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNetCardStatis::clear_netcard_type() {
  netcard_type_ = 0;
  clear_has_netcard_type();
}
inline ::mt::EmNetAdapterWorkType TNetCardStatis::netcard_type() const {
  return static_cast< ::mt::EmNetAdapterWorkType >(netcard_type_);
}
inline void TNetCardStatis::set_netcard_type(::mt::EmNetAdapterWorkType value) {
  assert(::mt::EmNetAdapterWorkType_IsValid(value));
  set_has_netcard_type();
  netcard_type_ = value;
}

// -------------------------------------------------------------------

// TNetCardStatisList

// optional uint32 netcard_num = 1;
inline bool TNetCardStatisList::has_netcard_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNetCardStatisList::set_has_netcard_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNetCardStatisList::clear_has_netcard_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNetCardStatisList::clear_netcard_num() {
  netcard_num_ = 0u;
  clear_has_netcard_num();
}
inline ::google::protobuf::uint32 TNetCardStatisList::netcard_num() const {
  return netcard_num_;
}
inline void TNetCardStatisList::set_netcard_num(::google::protobuf::uint32 value) {
  set_has_netcard_num();
  netcard_num_ = value;
}

// repeated .mt.TNetCardStatis netcard_statis = 2;
inline int TNetCardStatisList::netcard_statis_size() const {
  return netcard_statis_.size();
}
inline void TNetCardStatisList::clear_netcard_statis() {
  netcard_statis_.Clear();
}
inline const ::mt::TNetCardStatis& TNetCardStatisList::netcard_statis(int index) const {
  return netcard_statis_.Get(index);
}
inline ::mt::TNetCardStatis* TNetCardStatisList::mutable_netcard_statis(int index) {
  return netcard_statis_.Mutable(index);
}
inline ::mt::TNetCardStatis* TNetCardStatisList::add_netcard_statis() {
  return netcard_statis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TNetCardStatis >&
TNetCardStatisList::netcard_statis() const {
  return netcard_statis_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TNetCardStatis >*
TNetCardStatisList::mutable_netcard_statis() {
  return &netcard_statis_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mt

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_structnet_2eproto__INCLUDED
