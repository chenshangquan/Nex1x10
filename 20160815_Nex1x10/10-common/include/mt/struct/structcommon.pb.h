// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structcommon.proto

#ifndef PROTOBUF_structcommon_2eproto__INCLUDED
#define PROTOBUF_structcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "enum.pb.h"
// @@protoc_insertion_point(includes)

namespace mt {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
void protobuf_AssignDesc_structcommon_2eproto();
void protobuf_ShutdownFile_structcommon_2eproto();

class TNetAddr;
class TRpNetAddr;
class TPrsParam;
class TEncryptKey;
class TMTTime;
class TSocks5Cfg;
class TMtAddr;
class TRpMtAddr;
class TMtAlias;
class TRpMtAlias;
class TMtId;
class TRpMtId;
class TMtLoc;
class TRpMtLoc;
class TMtInfo;
class TRpMtInfo;
class TH323Cfg;
class TSipCfg;
class TMTSrvInfo;
class TMTSrvInfoList;
class TMTLocalParam;
class TVrsLoginInfo;
class TVrsGetPrgsReq;
class TVrsFolderInfo;
class TVrsFoldersInfo;
class TVrsPrgDetailInfo;
class TVrsPrgsDetailInfo;
class TVrsPrgBaseInfo;
class TVrsPrgsBaseInfo;
class TVrsRoomState;
class TVrsRoomsState;
class TVrsRoomCfg;
class TVrsRoomsCfg;
class TSubsMsgID;
class TVrsSearchFilesReq;
class TVrsGetReserveRoomListReq;
class TVrsOldRoomCfg;
class TVrsOldRoomsCfg;
class TMTOrder;
class TGmTestResult;
class TGmAndRandomNumTest;
class TAllSelfTestResult;
class THandShakeParam;
class TMtcLoginParam;
class TMtcLoginRet;
class TMtcBaseInfo;
class TMtVersionInfo;
class TMtcBaseInfoList;
class TMtAiInfoCfg;

// ===================================================================

class MTMSG_API TNetAddr : public ::google::protobuf::Message {
 public:
  TNetAddr();
  virtual ~TNetAddr();

  TNetAddr(const TNetAddr& from);

  inline TNetAddr& operator=(const TNetAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNetAddr& default_instance();

  void Swap(TNetAddr* other);

  // implements Message ----------------------------------------------

  TNetAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNetAddr& from);
  void MergeFrom(const TNetAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmIpAddrType ip_type = 1 [default = emIpV4];
  inline bool has_ip_type() const;
  inline void clear_ip_type();
  static const int kIpTypeFieldNumber = 1;
  inline ::mt::EmIpAddrType ip_type() const;
  inline void set_ip_type(::mt::EmIpAddrType value);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional bytes ip_v6 = 3;
  inline bool has_ip_v6() const;
  inline void clear_ip_v6();
  static const int kIpV6FieldNumber = 3;
  inline const ::std::string& ip_v6() const;
  inline void set_ip_v6(const ::std::string& value);
  inline void set_ip_v6(const char* value);
  inline void set_ip_v6(const void* value, size_t size);
  inline ::std::string* mutable_ip_v6();
  inline ::std::string* release_ip_v6();
  inline void set_allocated_ip_v6(::std::string* ip_v6);

  // optional uint32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TNetAddr)
 private:
  inline void set_has_ip_type();
  inline void clear_has_ip_type();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_ip_v6();
  inline void clear_has_ip_v6();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ip_type_;
  ::google::protobuf::uint32 ip_;
  ::std::string* ip_v6_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TNetAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpNetAddr : public ::google::protobuf::Message {
 public:
  TRpNetAddr();
  virtual ~TRpNetAddr();

  TRpNetAddr(const TRpNetAddr& from);

  inline TRpNetAddr& operator=(const TRpNetAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpNetAddr& default_instance();

  void Swap(TRpNetAddr* other);

  // implements Message ----------------------------------------------

  TRpNetAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpNetAddr& from);
  void MergeFrom(const TRpNetAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TNetAddr net_addr = 1;
  inline int net_addr_size() const;
  inline void clear_net_addr();
  static const int kNetAddrFieldNumber = 1;
  inline const ::mt::TNetAddr& net_addr(int index) const;
  inline ::mt::TNetAddr* mutable_net_addr(int index);
  inline ::mt::TNetAddr* add_net_addr();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TNetAddr >&
      net_addr() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TNetAddr >*
      mutable_net_addr();

  // @@protoc_insertion_point(class_scope:mt.TRpNetAddr)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TNetAddr > net_addr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TRpNetAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPrsParam : public ::google::protobuf::Message {
 public:
  TPrsParam();
  virtual ~TPrsParam();

  TPrsParam(const TPrsParam& from);

  inline TPrsParam& operator=(const TPrsParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPrsParam& default_instance();

  void Swap(TPrsParam* other);

  // implements Message ----------------------------------------------

  TPrsParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPrsParam& from);
  void MergeFrom(const TPrsParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional uint32 first_time_span = 2 [default = 40];
  inline bool has_first_time_span() const;
  inline void clear_first_time_span();
  static const int kFirstTimeSpanFieldNumber = 2;
  inline ::google::protobuf::uint32 first_time_span() const;
  inline void set_first_time_span(::google::protobuf::uint32 value);

  // optional uint32 second_time_span = 3 [default = 80];
  inline bool has_second_time_span() const;
  inline void clear_second_time_span();
  static const int kSecondTimeSpanFieldNumber = 3;
  inline ::google::protobuf::uint32 second_time_span() const;
  inline void set_second_time_span(::google::protobuf::uint32 value);

  // optional uint32 third_time_span = 4 [default = 160];
  inline bool has_third_time_span() const;
  inline void clear_third_time_span();
  static const int kThirdTimeSpanFieldNumber = 4;
  inline ::google::protobuf::uint32 third_time_span() const;
  inline void set_third_time_span(::google::protobuf::uint32 value);

  // optional uint32 reject_time_span = 5 [default = 200];
  inline bool has_reject_time_span() const;
  inline void clear_reject_time_span();
  static const int kRejectTimeSpanFieldNumber = 5;
  inline ::google::protobuf::uint32 reject_time_span() const;
  inline void set_reject_time_span(::google::protobuf::uint32 value);

  // optional uint32 send_buf_time_span = 6 [default = 1000];
  inline bool has_send_buf_time_span() const;
  inline void clear_send_buf_time_span();
  static const int kSendBufTimeSpanFieldNumber = 6;
  inline ::google::protobuf::uint32 send_buf_time_span() const;
  inline void set_send_buf_time_span(::google::protobuf::uint32 value);

  // optional bool bUseSmoothSend = 7;
  inline bool has_busesmoothsend() const;
  inline void clear_busesmoothsend();
  static const int kBUseSmoothSendFieldNumber = 7;
  inline bool busesmoothsend() const;
  inline void set_busesmoothsend(bool value);

  // @@protoc_insertion_point(class_scope:mt.TPrsParam)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_first_time_span();
  inline void clear_has_first_time_span();
  inline void set_has_second_time_span();
  inline void clear_has_second_time_span();
  inline void set_has_third_time_span();
  inline void clear_has_third_time_span();
  inline void set_has_reject_time_span();
  inline void clear_has_reject_time_span();
  inline void set_has_send_buf_time_span();
  inline void clear_has_send_buf_time_span();
  inline void set_has_busesmoothsend();
  inline void clear_has_busesmoothsend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 first_time_span_;
  ::google::protobuf::uint32 second_time_span_;
  ::google::protobuf::uint32 third_time_span_;
  bool enable_;
  bool busesmoothsend_;
  ::google::protobuf::uint32 reject_time_span_;
  ::google::protobuf::uint32 send_buf_time_span_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TPrsParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TEncryptKey : public ::google::protobuf::Message {
 public:
  TEncryptKey();
  virtual ~TEncryptKey();

  TEncryptKey(const TEncryptKey& from);

  inline TEncryptKey& operator=(const TEncryptKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TEncryptKey& default_instance();

  void Swap(TEncryptKey* other);

  // implements Message ----------------------------------------------

  TEncryptKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TEncryptKey& from);
  void MergeFrom(const TEncryptKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:mt.TEncryptKey)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TEncryptKey* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTime : public ::google::protobuf::Message {
 public:
  TMTTime();
  virtual ~TMTTime();

  TMTTime(const TMTTime& from);

  inline TMTTime& operator=(const TMTTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTime& default_instance();

  void Swap(TMTTime* other);

  // implements Message ----------------------------------------------

  TMTTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTime& from);
  void MergeFrom(const TMTTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 year = 1;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 1;
  inline ::google::protobuf::uint32 year() const;
  inline void set_year(::google::protobuf::uint32 value);

  // optional uint32 month = 2;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 2;
  inline ::google::protobuf::uint32 month() const;
  inline void set_month(::google::protobuf::uint32 value);

  // optional uint32 day = 3;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // optional uint32 hour = 4;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 4;
  inline ::google::protobuf::uint32 hour() const;
  inline void set_hour(::google::protobuf::uint32 value);

  // optional uint32 minute = 5;
  inline bool has_minute() const;
  inline void clear_minute();
  static const int kMinuteFieldNumber = 5;
  inline ::google::protobuf::uint32 minute() const;
  inline void set_minute(::google::protobuf::uint32 value);

  // optional uint32 second = 6;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 6;
  inline ::google::protobuf::uint32 second() const;
  inline void set_second(::google::protobuf::uint32 value);

  // optional uint32 microsecond = 7;
  inline bool has_microsecond() const;
  inline void clear_microsecond();
  static const int kMicrosecondFieldNumber = 7;
  inline ::google::protobuf::uint32 microsecond() const;
  inline void set_microsecond(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTTime)
 private:
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_minute();
  inline void clear_has_minute();
  inline void set_has_second();
  inline void clear_has_second();
  inline void set_has_microsecond();
  inline void clear_has_microsecond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 year_;
  ::google::protobuf::uint32 month_;
  ::google::protobuf::uint32 day_;
  ::google::protobuf::uint32 hour_;
  ::google::protobuf::uint32 minute_;
  ::google::protobuf::uint32 second_;
  ::google::protobuf::uint32 microsecond_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMTTime* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TSocks5Cfg : public ::google::protobuf::Message {
 public:
  TSocks5Cfg();
  virtual ~TSocks5Cfg();

  TSocks5Cfg(const TSocks5Cfg& from);

  inline TSocks5Cfg& operator=(const TSocks5Cfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSocks5Cfg& default_instance();

  void Swap(TSocks5Cfg* other);

  // implements Message ----------------------------------------------

  TSocks5Cfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSocks5Cfg& from);
  void MergeFrom(const TSocks5Cfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TNetAddr server_ip = 1;
  inline bool has_server_ip() const;
  inline void clear_server_ip();
  static const int kServerIpFieldNumber = 1;
  inline const ::mt::TNetAddr& server_ip() const;
  inline ::mt::TNetAddr* mutable_server_ip();
  inline ::mt::TNetAddr* release_server_ip();
  inline void set_allocated_server_ip(::mt::TNetAddr* server_ip);

  // optional string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string pwd = 3;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 3;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // @@protoc_insertion_point(class_scope:mt.TSocks5Cfg)
 private:
  inline void set_has_server_ip();
  inline void clear_has_server_ip();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_pwd();
  inline void clear_has_pwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TNetAddr* server_ip_;
  ::std::string* user_name_;
  ::std::string* pwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TSocks5Cfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAddr : public ::google::protobuf::Message {
 public:
  TMtAddr();
  virtual ~TMtAddr();

  TMtAddr(const TMtAddr& from);

  inline TMtAddr& operator=(const TMtAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAddr& default_instance();

  void Swap(TMtAddr* other);

  // implements Message ----------------------------------------------

  TMtAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAddr& from);
  void MergeFrom(const TMtAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtAddrType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmMtAddrType type() const;
  inline void set_type(::mt::EmMtAddrType value);

  // optional .mt.TNetAddr ip_addr = 2;
  inline bool has_ip_addr() const;
  inline void clear_ip_addr();
  static const int kIpAddrFieldNumber = 2;
  inline const ::mt::TNetAddr& ip_addr() const;
  inline ::mt::TNetAddr* mutable_ip_addr();
  inline ::mt::TNetAddr* release_ip_addr();
  inline void set_allocated_ip_addr(::mt::TNetAddr* ip_addr);

  // optional string alias = 3;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 3;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // @@protoc_insertion_point(class_scope:mt.TMtAddr)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ip_addr();
  inline void clear_has_ip_addr();
  inline void set_has_alias();
  inline void clear_has_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TNetAddr* ip_addr_;
  ::std::string* alias_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMtAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtAddr : public ::google::protobuf::Message {
 public:
  TRpMtAddr();
  virtual ~TRpMtAddr();

  TRpMtAddr(const TRpMtAddr& from);

  inline TRpMtAddr& operator=(const TRpMtAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtAddr& default_instance();

  void Swap(TRpMtAddr* other);

  // implements Message ----------------------------------------------

  TRpMtAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtAddr& from);
  void MergeFrom(const TRpMtAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtAddr mt_addr = 1;
  inline int mt_addr_size() const;
  inline void clear_mt_addr();
  static const int kMtAddrFieldNumber = 1;
  inline const ::mt::TMtAddr& mt_addr(int index) const;
  inline ::mt::TMtAddr* mutable_mt_addr(int index);
  inline ::mt::TMtAddr* add_mt_addr();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAddr >&
      mt_addr() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAddr >*
      mutable_mt_addr();

  // @@protoc_insertion_point(class_scope:mt.TRpMtAddr)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtAddr > mt_addr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TRpMtAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAlias : public ::google::protobuf::Message {
 public:
  TMtAlias();
  virtual ~TMtAlias();

  TMtAlias(const TMtAlias& from);

  inline TMtAlias& operator=(const TMtAlias& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAlias& default_instance();

  void Swap(TMtAlias* other);

  // implements Message ----------------------------------------------

  TMtAlias* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAlias& from);
  void MergeFrom(const TMtAlias& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtAliasType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmMtAliasType type() const;
  inline void set_type(::mt::EmMtAliasType value);

  // optional string alias = 2;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 2;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // @@protoc_insertion_point(class_scope:mt.TMtAlias)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_alias();
  inline void clear_has_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alias_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMtAlias* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtAlias : public ::google::protobuf::Message {
 public:
  TRpMtAlias();
  virtual ~TRpMtAlias();

  TRpMtAlias(const TRpMtAlias& from);

  inline TRpMtAlias& operator=(const TRpMtAlias& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtAlias& default_instance();

  void Swap(TRpMtAlias* other);

  // implements Message ----------------------------------------------

  TRpMtAlias* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtAlias& from);
  void MergeFrom(const TRpMtAlias& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtAlias alias = 1;
  inline int alias_size() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 1;
  inline const ::mt::TMtAlias& alias(int index) const;
  inline ::mt::TMtAlias* mutable_alias(int index);
  inline ::mt::TMtAlias* add_alias();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAlias >&
      alias() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAlias >*
      mutable_alias();

  // @@protoc_insertion_point(class_scope:mt.TRpMtAlias)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtAlias > alias_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TRpMtAlias* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtId : public ::google::protobuf::Message {
 public:
  TMtId();
  virtual ~TMtId();

  TMtId(const TMtId& from);

  inline TMtId& operator=(const TMtId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtId& default_instance();

  void Swap(TMtId* other);

  // implements Message ----------------------------------------------

  TMtId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtId& from);
  void MergeFrom(const TMtId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 mcu_id = 1;
  inline bool has_mcu_id() const;
  inline void clear_mcu_id();
  static const int kMcuIdFieldNumber = 1;
  inline ::google::protobuf::uint32 mcu_id() const;
  inline void set_mcu_id(::google::protobuf::uint32 value);

  // optional uint32 ter_id = 2;
  inline bool has_ter_id() const;
  inline void clear_ter_id();
  static const int kTerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 ter_id() const;
  inline void set_ter_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtId)
 private:
  inline void set_has_mcu_id();
  inline void clear_has_mcu_id();
  inline void set_has_ter_id();
  inline void clear_has_ter_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 mcu_id_;
  ::google::protobuf::uint32 ter_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMtId* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtId : public ::google::protobuf::Message {
 public:
  TRpMtId();
  virtual ~TRpMtId();

  TRpMtId(const TRpMtId& from);

  inline TRpMtId& operator=(const TRpMtId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtId& default_instance();

  void Swap(TRpMtId* other);

  // implements Message ----------------------------------------------

  TRpMtId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtId& from);
  void MergeFrom(const TRpMtId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtId mt_id = 1;
  inline int mt_id_size() const;
  inline void clear_mt_id();
  static const int kMtIdFieldNumber = 1;
  inline const ::mt::TMtId& mt_id(int index) const;
  inline ::mt::TMtId* mutable_mt_id(int index);
  inline ::mt::TMtId* add_mt_id();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtId >&
      mt_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtId >*
      mutable_mt_id();

  // @@protoc_insertion_point(class_scope:mt.TRpMtId)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtId > mt_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TRpMtId* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtLoc : public ::google::protobuf::Message {
 public:
  TMtLoc();
  virtual ~TMtLoc();

  TMtLoc(const TMtLoc& from);

  inline TMtLoc& operator=(const TMtLoc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtLoc& default_instance();

  void Swap(TMtLoc* other);

  // implements Message ----------------------------------------------

  TMtLoc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtLoc& from);
  void MergeFrom(const TMtLoc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtMediaDirection direct = 1;
  inline bool has_direct() const;
  inline void clear_direct();
  static const int kDirectFieldNumber = 1;
  inline ::mt::EmMtMediaDirection direct() const;
  inline void set_direct(::mt::EmMtMediaDirection value);

  // optional .mt.EmMtMediaType mediatype = 2;
  inline bool has_mediatype() const;
  inline void clear_mediatype();
  static const int kMediatypeFieldNumber = 2;
  inline ::mt::EmMtMediaType mediatype() const;
  inline void set_mediatype(::mt::EmMtMediaType value);

  // optional .mt.EmCodecComponentIndex stream_id = 3;
  inline bool has_stream_id() const;
  inline void clear_stream_id();
  static const int kStreamIdFieldNumber = 3;
  inline ::mt::EmCodecComponentIndex stream_id() const;
  inline void set_stream_id(::mt::EmCodecComponentIndex value);

  // optional string stream_alias = 4;
  inline bool has_stream_alias() const;
  inline void clear_stream_alias();
  static const int kStreamAliasFieldNumber = 4;
  inline const ::std::string& stream_alias() const;
  inline void set_stream_alias(const ::std::string& value);
  inline void set_stream_alias(const char* value);
  inline void set_stream_alias(const char* value, size_t size);
  inline ::std::string* mutable_stream_alias();
  inline ::std::string* release_stream_alias();
  inline void set_allocated_stream_alias(::std::string* stream_alias);

  // @@protoc_insertion_point(class_scope:mt.TMtLoc)
 private:
  inline void set_has_direct();
  inline void clear_has_direct();
  inline void set_has_mediatype();
  inline void clear_has_mediatype();
  inline void set_has_stream_id();
  inline void clear_has_stream_id();
  inline void set_has_stream_alias();
  inline void clear_has_stream_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int direct_;
  int mediatype_;
  ::std::string* stream_alias_;
  int stream_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMtLoc* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtLoc : public ::google::protobuf::Message {
 public:
  TRpMtLoc();
  virtual ~TRpMtLoc();

  TRpMtLoc(const TRpMtLoc& from);

  inline TRpMtLoc& operator=(const TRpMtLoc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtLoc& default_instance();

  void Swap(TRpMtLoc* other);

  // implements Message ----------------------------------------------

  TRpMtLoc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtLoc& from);
  void MergeFrom(const TRpMtLoc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtLoc mt_loc = 1;
  inline int mt_loc_size() const;
  inline void clear_mt_loc();
  static const int kMtLocFieldNumber = 1;
  inline const ::mt::TMtLoc& mt_loc(int index) const;
  inline ::mt::TMtLoc* mutable_mt_loc(int index);
  inline ::mt::TMtLoc* add_mt_loc();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtLoc >&
      mt_loc() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtLoc >*
      mutable_mt_loc();

  // @@protoc_insertion_point(class_scope:mt.TRpMtLoc)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtLoc > mt_loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TRpMtLoc* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtInfo : public ::google::protobuf::Message {
 public:
  TMtInfo();
  virtual ~TMtInfo();

  TMtInfo(const TMtInfo& from);

  inline TMtInfo& operator=(const TMtInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtInfo& default_instance();

  void Swap(TMtInfo* other);

  // implements Message ----------------------------------------------

  TMtInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtInfo& from);
  void MergeFrom(const TMtInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMtId label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::mt::TMtId& label() const;
  inline ::mt::TMtId* mutable_label();
  inline ::mt::TMtId* release_label();
  inline void set_allocated_label(::mt::TMtId* label);

  // optional string alias = 2;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 2;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // optional string e164 = 3;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 3;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional .mt.EmMtType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::mt::EmMtType type() const;
  inline void set_type(::mt::EmMtType value);

  // optional bool is_only_aud = 5;
  inline bool has_is_only_aud() const;
  inline void clear_is_only_aud();
  static const int kIsOnlyAudFieldNumber = 5;
  inline bool is_only_aud() const;
  inline void set_is_only_aud(bool value);

  // repeated .mt.TMtLoc mt_loc = 6;
  inline int mt_loc_size() const;
  inline void clear_mt_loc();
  static const int kMtLocFieldNumber = 6;
  inline const ::mt::TMtLoc& mt_loc(int index) const;
  inline ::mt::TMtLoc* mutable_mt_loc(int index);
  inline ::mt::TMtLoc* add_mt_loc();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtLoc >&
      mt_loc() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtLoc >*
      mutable_mt_loc();

  // @@protoc_insertion_point(class_scope:mt.TMtInfo)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_is_only_aud();
  inline void clear_has_is_only_aud();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMtId* label_;
  ::std::string* alias_;
  ::std::string* e164_;
  int type_;
  bool is_only_aud_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMtLoc > mt_loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMtInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtInfo : public ::google::protobuf::Message {
 public:
  TRpMtInfo();
  virtual ~TRpMtInfo();

  TRpMtInfo(const TRpMtInfo& from);

  inline TRpMtInfo& operator=(const TRpMtInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtInfo& default_instance();

  void Swap(TRpMtInfo* other);

  // implements Message ----------------------------------------------

  TRpMtInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtInfo& from);
  void MergeFrom(const TRpMtInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtInfo mt_info = 1;
  inline int mt_info_size() const;
  inline void clear_mt_info();
  static const int kMtInfoFieldNumber = 1;
  inline const ::mt::TMtInfo& mt_info(int index) const;
  inline ::mt::TMtInfo* mutable_mt_info(int index);
  inline ::mt::TMtInfo* add_mt_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtInfo >&
      mt_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtInfo >*
      mutable_mt_info();

  // @@protoc_insertion_point(class_scope:mt.TRpMtInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtInfo > mt_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TRpMtInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TH323Cfg : public ::google::protobuf::Message {
 public:
  TH323Cfg();
  virtual ~TH323Cfg();

  TH323Cfg(const TH323Cfg& from);

  inline TH323Cfg& operator=(const TH323Cfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TH323Cfg& default_instance();

  void Swap(TH323Cfg* other);

  // implements Message ----------------------------------------------

  TH323Cfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TH323Cfg& from);
  void MergeFrom(const TH323Cfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string alias = 1;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 1;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // optional string e164 = 2;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 2;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional bool buse_gk = 3;
  inline bool has_buse_gk() const;
  inline void clear_buse_gk();
  static const int kBuseGkFieldNumber = 3;
  inline bool buse_gk() const;
  inline void set_buse_gk(bool value);

  // optional string gk_pwd = 4;
  inline bool has_gk_pwd() const;
  inline void clear_gk_pwd();
  static const int kGkPwdFieldNumber = 4;
  inline const ::std::string& gk_pwd() const;
  inline void set_gk_pwd(const ::std::string& value);
  inline void set_gk_pwd(const char* value);
  inline void set_gk_pwd(const char* value, size_t size);
  inline ::std::string* mutable_gk_pwd();
  inline ::std::string* release_gk_pwd();
  inline void set_allocated_gk_pwd(::std::string* gk_pwd);

  // optional uint32 gk_ip = 5;
  inline bool has_gk_ip() const;
  inline void clear_gk_ip();
  static const int kGkIpFieldNumber = 5;
  inline ::google::protobuf::uint32 gk_ip() const;
  inline void set_gk_ip(::google::protobuf::uint32 value);

  // optional uint32 roundtrip_time = 7;
  inline bool has_roundtrip_time() const;
  inline void clear_roundtrip_time();
  static const int kRoundtripTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 roundtrip_time() const;
  inline void set_roundtrip_time(::google::protobuf::uint32 value);

  // optional bool buse_h239 = 8;
  inline bool has_buse_h239() const;
  inline void clear_buse_h239();
  static const int kBuseH239FieldNumber = 8;
  inline bool buse_h239() const;
  inline void set_buse_h239(bool value);

  // @@protoc_insertion_point(class_scope:mt.TH323Cfg)
 private:
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_buse_gk();
  inline void clear_has_buse_gk();
  inline void set_has_gk_pwd();
  inline void clear_has_gk_pwd();
  inline void set_has_gk_ip();
  inline void clear_has_gk_ip();
  inline void set_has_roundtrip_time();
  inline void clear_has_roundtrip_time();
  inline void set_has_buse_h239();
  inline void clear_has_buse_h239();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alias_;
  ::std::string* e164_;
  ::std::string* gk_pwd_;
  ::google::protobuf::uint32 gk_ip_;
  bool buse_gk_;
  bool buse_h239_;
  ::google::protobuf::uint32 roundtrip_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TH323Cfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TSipCfg : public ::google::protobuf::Message {
 public:
  TSipCfg();
  virtual ~TSipCfg();

  TSipCfg(const TSipCfg& from);

  inline TSipCfg& operator=(const TSipCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSipCfg& default_instance();

  void Swap(TSipCfg* other);

  // implements Message ----------------------------------------------

  TSipCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSipCfg& from);
  void MergeFrom(const TSipCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string password = 1;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 1;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string host_domain = 2;
  inline bool has_host_domain() const;
  inline void clear_host_domain();
  static const int kHostDomainFieldNumber = 2;
  inline const ::std::string& host_domain() const;
  inline void set_host_domain(const ::std::string& value);
  inline void set_host_domain(const char* value);
  inline void set_host_domain(const char* value, size_t size);
  inline ::std::string* mutable_host_domain();
  inline ::std::string* release_host_domain();
  inline void set_allocated_host_domain(::std::string* host_domain);

  // optional uint32 host_port = 3;
  inline bool has_host_port() const;
  inline void clear_host_port();
  static const int kHostPortFieldNumber = 3;
  inline ::google::protobuf::uint32 host_port() const;
  inline void set_host_port(::google::protobuf::uint32 value);

  // optional bool buse_regserver = 4;
  inline bool has_buse_regserver() const;
  inline void clear_buse_regserver();
  static const int kBuseRegserverFieldNumber = 4;
  inline bool buse_regserver() const;
  inline void set_buse_regserver(bool value);

  // optional uint32 regserver_ip = 5;
  inline bool has_regserver_ip() const;
  inline void clear_regserver_ip();
  static const int kRegserverIpFieldNumber = 5;
  inline ::google::protobuf::uint32 regserver_ip() const;
  inline void set_regserver_ip(::google::protobuf::uint32 value);

  // optional uint32 regserver_port = 6;
  inline bool has_regserver_port() const;
  inline void clear_regserver_port();
  static const int kRegserverPortFieldNumber = 6;
  inline ::google::protobuf::uint32 regserver_port() const;
  inline void set_regserver_port(::google::protobuf::uint32 value);

  // optional string regserver_domain = 7;
  inline bool has_regserver_domain() const;
  inline void clear_regserver_domain();
  static const int kRegserverDomainFieldNumber = 7;
  inline const ::std::string& regserver_domain() const;
  inline void set_regserver_domain(const ::std::string& value);
  inline void set_regserver_domain(const char* value);
  inline void set_regserver_domain(const char* value, size_t size);
  inline ::std::string* mutable_regserver_domain();
  inline ::std::string* release_regserver_domain();
  inline void set_allocated_regserver_domain(::std::string* regserver_domain);

  // optional uint32 expire = 8;
  inline bool has_expire() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 8;
  inline ::google::protobuf::uint32 expire() const;
  inline void set_expire(::google::protobuf::uint32 value);

  // optional bool buse_proxy = 9;
  inline bool has_buse_proxy() const;
  inline void clear_buse_proxy();
  static const int kBuseProxyFieldNumber = 9;
  inline bool buse_proxy() const;
  inline void set_buse_proxy(bool value);

  // optional uint32 proxy_ip = 10;
  inline bool has_proxy_ip() const;
  inline void clear_proxy_ip();
  static const int kProxyIpFieldNumber = 10;
  inline ::google::protobuf::uint32 proxy_ip() const;
  inline void set_proxy_ip(::google::protobuf::uint32 value);

  // optional uint32 proxy_port = 11;
  inline bool has_proxy_port() const;
  inline void clear_proxy_port();
  static const int kProxyPortFieldNumber = 11;
  inline ::google::protobuf::uint32 proxy_port() const;
  inline void set_proxy_port(::google::protobuf::uint32 value);

  // optional string proxy_domain = 12;
  inline bool has_proxy_domain() const;
  inline void clear_proxy_domain();
  static const int kProxyDomainFieldNumber = 12;
  inline const ::std::string& proxy_domain() const;
  inline void set_proxy_domain(const ::std::string& value);
  inline void set_proxy_domain(const char* value);
  inline void set_proxy_domain(const char* value, size_t size);
  inline ::std::string* mutable_proxy_domain();
  inline ::std::string* release_proxy_domain();
  inline void set_allocated_proxy_domain(::std::string* proxy_domain);

  // @@protoc_insertion_point(class_scope:mt.TSipCfg)
 private:
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_host_domain();
  inline void clear_has_host_domain();
  inline void set_has_host_port();
  inline void clear_has_host_port();
  inline void set_has_buse_regserver();
  inline void clear_has_buse_regserver();
  inline void set_has_regserver_ip();
  inline void clear_has_regserver_ip();
  inline void set_has_regserver_port();
  inline void clear_has_regserver_port();
  inline void set_has_regserver_domain();
  inline void clear_has_regserver_domain();
  inline void set_has_expire();
  inline void clear_has_expire();
  inline void set_has_buse_proxy();
  inline void clear_has_buse_proxy();
  inline void set_has_proxy_ip();
  inline void clear_has_proxy_ip();
  inline void set_has_proxy_port();
  inline void clear_has_proxy_port();
  inline void set_has_proxy_domain();
  inline void clear_has_proxy_domain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* password_;
  ::std::string* host_domain_;
  ::google::protobuf::uint32 host_port_;
  ::google::protobuf::uint32 regserver_ip_;
  ::google::protobuf::uint32 regserver_port_;
  bool buse_regserver_;
  bool buse_proxy_;
  ::std::string* regserver_domain_;
  ::google::protobuf::uint32 expire_;
  ::google::protobuf::uint32 proxy_ip_;
  ::std::string* proxy_domain_;
  ::google::protobuf::uint32 proxy_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TSipCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTSrvInfo : public ::google::protobuf::Message {
 public:
  TMTSrvInfo();
  virtual ~TMTSrvInfo();

  TMTSrvInfo(const TMTSrvInfo& from);

  inline TMTSrvInfo& operator=(const TMTSrvInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTSrvInfo& default_instance();

  void Swap(TMTSrvInfo* other);

  // implements Message ----------------------------------------------

  TMTSrvInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTSrvInfo& from);
  void MergeFrom(const TMTSrvInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .mt.EmServerType srvtype = 2;
  inline bool has_srvtype() const;
  inline void clear_srvtype();
  static const int kSrvtypeFieldNumber = 2;
  inline ::mt::EmServerType srvtype() const;
  inline void set_srvtype(::mt::EmServerType value);

  // optional string domain = 3;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 3;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional .mt.EmServerState state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline ::mt::EmServerState state() const;
  inline void set_state(::mt::EmServerState value);

  // optional bool used = 6;
  inline bool has_used() const;
  inline void clear_used();
  static const int kUsedFieldNumber = 6;
  inline bool used() const;
  inline void set_used(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTSrvInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_srvtype();
  inline void clear_has_srvtype();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_used();
  inline void clear_has_used();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* domain_;
  int srvtype_;
  ::google::protobuf::uint32 ip_;
  int state_;
  bool used_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMTSrvInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTSrvInfoList : public ::google::protobuf::Message {
 public:
  TMTSrvInfoList();
  virtual ~TMTSrvInfoList();

  TMTSrvInfoList(const TMTSrvInfoList& from);

  inline TMTSrvInfoList& operator=(const TMTSrvInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTSrvInfoList& default_instance();

  void Swap(TMTSrvInfoList* other);

  // implements Message ----------------------------------------------

  TMTSrvInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTSrvInfoList& from);
  void MergeFrom(const TMTSrvInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTSrvInfo list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::mt::TMTSrvInfo& list(int index) const;
  inline ::mt::TMTSrvInfo* mutable_list(int index);
  inline ::mt::TMTSrvInfo* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTSrvInfo >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTSrvInfo >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:mt.TMTSrvInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTSrvInfo > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMTSrvInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTLocalParam : public ::google::protobuf::Message {
 public:
  TMTLocalParam();
  virtual ~TMTLocalParam();

  TMTLocalParam(const TMTLocalParam& from);

  inline TMTLocalParam& operator=(const TMTLocalParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTLocalParam& default_instance();

  void Swap(TMTLocalParam* other);

  // implements Message ----------------------------------------------

  TMTLocalParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTLocalParam& from);
  void MergeFrom(const TMTLocalParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string model = 1;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 1;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // @@protoc_insertion_point(class_scope:mt.TMTLocalParam)
 private:
  inline void set_has_model();
  inline void clear_has_model();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* model_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMTLocalParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsLoginInfo : public ::google::protobuf::Message {
 public:
  TVrsLoginInfo();
  virtual ~TVrsLoginInfo();

  TVrsLoginInfo(const TVrsLoginInfo& from);

  inline TVrsLoginInfo& operator=(const TVrsLoginInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsLoginInfo& default_instance();

  void Swap(TVrsLoginInfo* other);

  // implements Message ----------------------------------------------

  TVrsLoginInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsLoginInfo& from);
  void MergeFrom(const TVrsLoginInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:mt.TVrsLoginInfo)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsLoginInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsGetPrgsReq : public ::google::protobuf::Message {
 public:
  TVrsGetPrgsReq();
  virtual ~TVrsGetPrgsReq();

  TVrsGetPrgsReq(const TVrsGetPrgsReq& from);

  inline TVrsGetPrgsReq& operator=(const TVrsGetPrgsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsGetPrgsReq& default_instance();

  void Swap(TVrsGetPrgsReq* other);

  // implements Message ----------------------------------------------

  TVrsGetPrgsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsGetPrgsReq& from);
  void MergeFrom(const TVrsGetPrgsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 folderid = 1;
  inline bool has_folderid() const;
  inline void clear_folderid();
  static const int kFolderidFieldNumber = 1;
  inline ::google::protobuf::uint32 folderid() const;
  inline void set_folderid(::google::protobuf::uint32 value);

  // optional uint32 prgs1page = 2;
  inline bool has_prgs1page() const;
  inline void clear_prgs1page();
  static const int kPrgs1PageFieldNumber = 2;
  inline ::google::protobuf::uint32 prgs1page() const;
  inline void set_prgs1page(::google::protobuf::uint32 value);

  // optional uint32 pageid = 3;
  inline bool has_pageid() const;
  inline void clear_pageid();
  static const int kPageidFieldNumber = 3;
  inline ::google::protobuf::uint32 pageid() const;
  inline void set_pageid(::google::protobuf::uint32 value);

  // optional string includename = 4;
  inline bool has_includename() const;
  inline void clear_includename();
  static const int kIncludenameFieldNumber = 4;
  inline const ::std::string& includename() const;
  inline void set_includename(const ::std::string& value);
  inline void set_includename(const char* value);
  inline void set_includename(const char* value, size_t size);
  inline ::std::string* mutable_includename();
  inline ::std::string* release_includename();
  inline void set_allocated_includename(::std::string* includename);

  // optional uint32 prgtypemask = 5;
  inline bool has_prgtypemask() const;
  inline void clear_prgtypemask();
  static const int kPrgtypemaskFieldNumber = 5;
  inline ::google::protobuf::uint32 prgtypemask() const;
  inline void set_prgtypemask(::google::protobuf::uint32 value);

  // optional uint32 starttime = 6;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 6;
  inline ::google::protobuf::uint32 starttime() const;
  inline void set_starttime(::google::protobuf::uint32 value);

  // optional uint32 endtime = 7;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 7;
  inline ::google::protobuf::uint32 endtime() const;
  inline void set_endtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TVrsGetPrgsReq)
 private:
  inline void set_has_folderid();
  inline void clear_has_folderid();
  inline void set_has_prgs1page();
  inline void clear_has_prgs1page();
  inline void set_has_pageid();
  inline void clear_has_pageid();
  inline void set_has_includename();
  inline void clear_has_includename();
  inline void set_has_prgtypemask();
  inline void clear_has_prgtypemask();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 folderid_;
  ::google::protobuf::uint32 prgs1page_;
  ::std::string* includename_;
  ::google::protobuf::uint32 pageid_;
  ::google::protobuf::uint32 prgtypemask_;
  ::google::protobuf::uint32 starttime_;
  ::google::protobuf::uint32 endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsGetPrgsReq* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsFolderInfo : public ::google::protobuf::Message {
 public:
  TVrsFolderInfo();
  virtual ~TVrsFolderInfo();

  TVrsFolderInfo(const TVrsFolderInfo& from);

  inline TVrsFolderInfo& operator=(const TVrsFolderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsFolderInfo& default_instance();

  void Swap(TVrsFolderInfo* other);

  // implements Message ----------------------------------------------

  TVrsFolderInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsFolderInfo& from);
  void MergeFrom(const TVrsFolderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 folderid = 1;
  inline bool has_folderid() const;
  inline void clear_folderid();
  static const int kFolderidFieldNumber = 1;
  inline ::google::protobuf::uint32 folderid() const;
  inline void set_folderid(::google::protobuf::uint32 value);

  // optional string foldername = 2;
  inline bool has_foldername() const;
  inline void clear_foldername();
  static const int kFoldernameFieldNumber = 2;
  inline const ::std::string& foldername() const;
  inline void set_foldername(const ::std::string& value);
  inline void set_foldername(const char* value);
  inline void set_foldername(const char* value, size_t size);
  inline ::std::string* mutable_foldername();
  inline ::std::string* release_foldername();
  inline void set_allocated_foldername(::std::string* foldername);

  // optional uint32 prgcount = 3;
  inline bool has_prgcount() const;
  inline void clear_prgcount();
  static const int kPrgcountFieldNumber = 3;
  inline ::google::protobuf::uint32 prgcount() const;
  inline void set_prgcount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TVrsFolderInfo)
 private:
  inline void set_has_folderid();
  inline void clear_has_folderid();
  inline void set_has_foldername();
  inline void clear_has_foldername();
  inline void set_has_prgcount();
  inline void clear_has_prgcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* foldername_;
  ::google::protobuf::uint32 folderid_;
  ::google::protobuf::uint32 prgcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsFolderInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsFoldersInfo : public ::google::protobuf::Message {
 public:
  TVrsFoldersInfo();
  virtual ~TVrsFoldersInfo();

  TVrsFoldersInfo(const TVrsFoldersInfo& from);

  inline TVrsFoldersInfo& operator=(const TVrsFoldersInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsFoldersInfo& default_instance();

  void Swap(TVrsFoldersInfo* other);

  // implements Message ----------------------------------------------

  TVrsFoldersInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsFoldersInfo& from);
  void MergeFrom(const TVrsFoldersInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVrsFolderInfo folderinfo = 1;
  inline int folderinfo_size() const;
  inline void clear_folderinfo();
  static const int kFolderinfoFieldNumber = 1;
  inline const ::mt::TVrsFolderInfo& folderinfo(int index) const;
  inline ::mt::TVrsFolderInfo* mutable_folderinfo(int index);
  inline ::mt::TVrsFolderInfo* add_folderinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsFolderInfo >&
      folderinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsFolderInfo >*
      mutable_folderinfo();

  // @@protoc_insertion_point(class_scope:mt.TVrsFoldersInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVrsFolderInfo > folderinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsFoldersInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsPrgDetailInfo : public ::google::protobuf::Message {
 public:
  TVrsPrgDetailInfo();
  virtual ~TVrsPrgDetailInfo();

  TVrsPrgDetailInfo(const TVrsPrgDetailInfo& from);

  inline TVrsPrgDetailInfo& operator=(const TVrsPrgDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsPrgDetailInfo& default_instance();

  void Swap(TVrsPrgDetailInfo* other);

  // implements Message ----------------------------------------------

  TVrsPrgDetailInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsPrgDetailInfo& from);
  void MergeFrom(const TVrsPrgDetailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 prgduration = 2;
  inline bool has_prgduration() const;
  inline void clear_prgduration();
  static const int kPrgdurationFieldNumber = 2;
  inline ::google::protobuf::uint32 prgduration() const;
  inline void set_prgduration(::google::protobuf::uint32 value);

  // optional uint32 prgindex = 3;
  inline bool has_prgindex() const;
  inline void clear_prgindex();
  static const int kPrgindexFieldNumber = 3;
  inline ::google::protobuf::uint32 prgindex() const;
  inline void set_prgindex(::google::protobuf::uint32 value);

  // optional uint32 prggid = 4;
  inline bool has_prggid() const;
  inline void clear_prggid();
  static const int kPrggidFieldNumber = 4;
  inline ::google::protobuf::uint32 prggid() const;
  inline void set_prggid(::google::protobuf::uint32 value);

  // optional string prgname = 5;
  inline bool has_prgname() const;
  inline void clear_prgname();
  static const int kPrgnameFieldNumber = 5;
  inline const ::std::string& prgname() const;
  inline void set_prgname(const ::std::string& value);
  inline void set_prgname(const char* value);
  inline void set_prgname(const char* value, size_t size);
  inline ::std::string* mutable_prgname();
  inline ::std::string* release_prgname();
  inline void set_allocated_prgname(::std::string* prgname);

  // optional uint32 prgsize = 6;
  inline bool has_prgsize() const;
  inline void clear_prgsize();
  static const int kPrgsizeFieldNumber = 6;
  inline ::google::protobuf::uint32 prgsize() const;
  inline void set_prgsize(::google::protobuf::uint32 value);

  // optional string prgtype = 7;
  inline bool has_prgtype() const;
  inline void clear_prgtype();
  static const int kPrgtypeFieldNumber = 7;
  inline const ::std::string& prgtype() const;
  inline void set_prgtype(const ::std::string& value);
  inline void set_prgtype(const char* value);
  inline void set_prgtype(const char* value, size_t size);
  inline ::std::string* mutable_prgtype();
  inline ::std::string* release_prgtype();
  inline void set_allocated_prgtype(::std::string* prgtype);

  // optional string path = 8;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 8;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional uint32 prginfoindex = 9;
  inline bool has_prginfoindex() const;
  inline void clear_prginfoindex();
  static const int kPrginfoindexFieldNumber = 9;
  inline ::google::protobuf::uint32 prginfoindex() const;
  inline void set_prginfoindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TVrsPrgDetailInfo)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_prgduration();
  inline void clear_has_prgduration();
  inline void set_has_prgindex();
  inline void clear_has_prgindex();
  inline void set_has_prggid();
  inline void clear_has_prggid();
  inline void set_has_prgname();
  inline void clear_has_prgname();
  inline void set_has_prgsize();
  inline void clear_has_prgsize();
  inline void set_has_prgtype();
  inline void clear_has_prgtype();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_prginfoindex();
  inline void clear_has_prginfoindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 prgduration_;
  ::google::protobuf::uint32 prgindex_;
  ::google::protobuf::uint32 prggid_;
  ::std::string* prgname_;
  ::std::string* prgtype_;
  ::google::protobuf::uint32 prgsize_;
  ::google::protobuf::uint32 prginfoindex_;
  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsPrgDetailInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsPrgsDetailInfo : public ::google::protobuf::Message {
 public:
  TVrsPrgsDetailInfo();
  virtual ~TVrsPrgsDetailInfo();

  TVrsPrgsDetailInfo(const TVrsPrgsDetailInfo& from);

  inline TVrsPrgsDetailInfo& operator=(const TVrsPrgsDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsPrgsDetailInfo& default_instance();

  void Swap(TVrsPrgsDetailInfo* other);

  // implements Message ----------------------------------------------

  TVrsPrgsDetailInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsPrgsDetailInfo& from);
  void MergeFrom(const TVrsPrgsDetailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVrsPrgDetailInfo prgdetail = 1;
  inline int prgdetail_size() const;
  inline void clear_prgdetail();
  static const int kPrgdetailFieldNumber = 1;
  inline const ::mt::TVrsPrgDetailInfo& prgdetail(int index) const;
  inline ::mt::TVrsPrgDetailInfo* mutable_prgdetail(int index);
  inline ::mt::TVrsPrgDetailInfo* add_prgdetail();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsPrgDetailInfo >&
      prgdetail() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsPrgDetailInfo >*
      mutable_prgdetail();

  // @@protoc_insertion_point(class_scope:mt.TVrsPrgsDetailInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVrsPrgDetailInfo > prgdetail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsPrgsDetailInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsPrgBaseInfo : public ::google::protobuf::Message {
 public:
  TVrsPrgBaseInfo();
  virtual ~TVrsPrgBaseInfo();

  TVrsPrgBaseInfo(const TVrsPrgBaseInfo& from);

  inline TVrsPrgBaseInfo& operator=(const TVrsPrgBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsPrgBaseInfo& default_instance();

  void Swap(TVrsPrgBaseInfo* other);

  // implements Message ----------------------------------------------

  TVrsPrgBaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsPrgBaseInfo& from);
  void MergeFrom(const TVrsPrgBaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 createtime = 1;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 1;
  inline ::google::protobuf::uint32 createtime() const;
  inline void set_createtime(::google::protobuf::uint32 value);

  // optional uint32 issuetime = 2;
  inline bool has_issuetime() const;
  inline void clear_issuetime();
  static const int kIssuetimeFieldNumber = 2;
  inline ::google::protobuf::uint32 issuetime() const;
  inline void set_issuetime(::google::protobuf::uint32 value);

  // optional string prgalias = 3;
  inline bool has_prgalias() const;
  inline void clear_prgalias();
  static const int kPrgaliasFieldNumber = 3;
  inline const ::std::string& prgalias() const;
  inline void set_prgalias(const ::std::string& value);
  inline void set_prgalias(const char* value);
  inline void set_prgalias(const char* value, size_t size);
  inline ::std::string* mutable_prgalias();
  inline ::std::string* release_prgalias();
  inline void set_allocated_prgalias(::std::string* prgalias);

  // optional uint32 prgallduration = 4;
  inline bool has_prgallduration() const;
  inline void clear_prgallduration();
  static const int kPrgalldurationFieldNumber = 4;
  inline ::google::protobuf::uint32 prgallduration() const;
  inline void set_prgallduration(::google::protobuf::uint32 value);

  // optional uint32 prgallsize = 5;
  inline bool has_prgallsize() const;
  inline void clear_prgallsize();
  static const int kPrgallsizeFieldNumber = 5;
  inline ::google::protobuf::uint32 prgallsize() const;
  inline void set_prgallsize(::google::protobuf::uint32 value);

  // optional string prgdesc = 6;
  inline bool has_prgdesc() const;
  inline void clear_prgdesc();
  static const int kPrgdescFieldNumber = 6;
  inline const ::std::string& prgdesc() const;
  inline void set_prgdesc(const ::std::string& value);
  inline void set_prgdesc(const char* value);
  inline void set_prgdesc(const char* value, size_t size);
  inline ::std::string* mutable_prgdesc();
  inline ::std::string* release_prgdesc();
  inline void set_allocated_prgdesc(::std::string* prgdesc);

  // optional uint32 prggid = 7;
  inline bool has_prggid() const;
  inline void clear_prggid();
  static const int kPrggidFieldNumber = 7;
  inline ::google::protobuf::uint32 prggid() const;
  inline void set_prggid(::google::protobuf::uint32 value);

  // optional uint32 prgstate = 8;
  inline bool has_prgstate() const;
  inline void clear_prgstate();
  static const int kPrgstateFieldNumber = 8;
  inline ::google::protobuf::uint32 prgstate() const;
  inline void set_prgstate(::google::protobuf::uint32 value);

  // optional string streamjsonpath = 9;
  inline bool has_streamjsonpath() const;
  inline void clear_streamjsonpath();
  static const int kStreamjsonpathFieldNumber = 9;
  inline const ::std::string& streamjsonpath() const;
  inline void set_streamjsonpath(const ::std::string& value);
  inline void set_streamjsonpath(const char* value);
  inline void set_streamjsonpath(const char* value, size_t size);
  inline ::std::string* mutable_streamjsonpath();
  inline ::std::string* release_streamjsonpath();
  inline void set_allocated_streamjsonpath(::std::string* streamjsonpath);

  // @@protoc_insertion_point(class_scope:mt.TVrsPrgBaseInfo)
 private:
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_issuetime();
  inline void clear_has_issuetime();
  inline void set_has_prgalias();
  inline void clear_has_prgalias();
  inline void set_has_prgallduration();
  inline void clear_has_prgallduration();
  inline void set_has_prgallsize();
  inline void clear_has_prgallsize();
  inline void set_has_prgdesc();
  inline void clear_has_prgdesc();
  inline void set_has_prggid();
  inline void clear_has_prggid();
  inline void set_has_prgstate();
  inline void clear_has_prgstate();
  inline void set_has_streamjsonpath();
  inline void clear_has_streamjsonpath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 createtime_;
  ::google::protobuf::uint32 issuetime_;
  ::std::string* prgalias_;
  ::google::protobuf::uint32 prgallduration_;
  ::google::protobuf::uint32 prgallsize_;
  ::std::string* prgdesc_;
  ::google::protobuf::uint32 prggid_;
  ::google::protobuf::uint32 prgstate_;
  ::std::string* streamjsonpath_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsPrgBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsPrgsBaseInfo : public ::google::protobuf::Message {
 public:
  TVrsPrgsBaseInfo();
  virtual ~TVrsPrgsBaseInfo();

  TVrsPrgsBaseInfo(const TVrsPrgsBaseInfo& from);

  inline TVrsPrgsBaseInfo& operator=(const TVrsPrgsBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsPrgsBaseInfo& default_instance();

  void Swap(TVrsPrgsBaseInfo* other);

  // implements Message ----------------------------------------------

  TVrsPrgsBaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsPrgsBaseInfo& from);
  void MergeFrom(const TVrsPrgsBaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVrsPrgBaseInfo prgbase = 1;
  inline int prgbase_size() const;
  inline void clear_prgbase();
  static const int kPrgbaseFieldNumber = 1;
  inline const ::mt::TVrsPrgBaseInfo& prgbase(int index) const;
  inline ::mt::TVrsPrgBaseInfo* mutable_prgbase(int index);
  inline ::mt::TVrsPrgBaseInfo* add_prgbase();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsPrgBaseInfo >&
      prgbase() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsPrgBaseInfo >*
      mutable_prgbase();

  // @@protoc_insertion_point(class_scope:mt.TVrsPrgsBaseInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVrsPrgBaseInfo > prgbase_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsPrgsBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsRoomState : public ::google::protobuf::Message {
 public:
  TVrsRoomState();
  virtual ~TVrsRoomState();

  TVrsRoomState(const TVrsRoomState& from);

  inline TVrsRoomState& operator=(const TVrsRoomState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsRoomState& default_instance();

  void Swap(TVrsRoomState* other);

  // implements Message ----------------------------------------------

  TVrsRoomState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsRoomState& from);
  void MergeFrom(const TVrsRoomState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 elapse = 1;
  inline bool has_elapse() const;
  inline void clear_elapse();
  static const int kElapseFieldNumber = 1;
  inline ::google::protobuf::uint32 elapse() const;
  inline void set_elapse(::google::protobuf::uint32 value);

  // optional string lcastpoint = 2;
  inline bool has_lcastpoint() const;
  inline void clear_lcastpoint();
  static const int kLcastpointFieldNumber = 2;
  inline const ::std::string& lcastpoint() const;
  inline void set_lcastpoint(const ::std::string& value);
  inline void set_lcastpoint(const char* value);
  inline void set_lcastpoint(const char* value, size_t size);
  inline ::std::string* mutable_lcastpoint();
  inline ::std::string* release_lcastpoint();
  inline void set_allocated_lcastpoint(::std::string* lcastpoint);

  // optional uint32 prgid = 3;
  inline bool has_prgid() const;
  inline void clear_prgid();
  static const int kPrgidFieldNumber = 3;
  inline ::google::protobuf::uint32 prgid() const;
  inline void set_prgid(::google::protobuf::uint32 value);

  // optional uint32 roomid = 4;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 4;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional string roomname = 5;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomnameFieldNumber = 5;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  inline void set_allocated_roomname(::std::string* roomname);

  // optional uint32 usrgrpid = 6;
  inline bool has_usrgrpid() const;
  inline void clear_usrgrpid();
  static const int kUsrgrpidFieldNumber = 6;
  inline ::google::protobuf::uint32 usrgrpid() const;
  inline void set_usrgrpid(::google::protobuf::uint32 value);

  // optional uint32 livetime = 7;
  inline bool has_livetime() const;
  inline void clear_livetime();
  static const int kLivetimeFieldNumber = 7;
  inline ::google::protobuf::uint32 livetime() const;
  inline void set_livetime(::google::protobuf::uint32 value);

  // optional string livestreampath = 8;
  inline bool has_livestreampath() const;
  inline void clear_livestreampath();
  static const int kLivestreampathFieldNumber = 8;
  inline const ::std::string& livestreampath() const;
  inline void set_livestreampath(const ::std::string& value);
  inline void set_livestreampath(const char* value);
  inline void set_livestreampath(const char* value, size_t size);
  inline ::std::string* mutable_livestreampath();
  inline ::std::string* release_livestreampath();
  inline void set_allocated_livestreampath(::std::string* livestreampath);

  // optional string roomidstr = 9;
  inline bool has_roomidstr() const;
  inline void clear_roomidstr();
  static const int kRoomidstrFieldNumber = 9;
  inline const ::std::string& roomidstr() const;
  inline void set_roomidstr(const ::std::string& value);
  inline void set_roomidstr(const char* value);
  inline void set_roomidstr(const char* value, size_t size);
  inline ::std::string* mutable_roomidstr();
  inline ::std::string* release_roomidstr();
  inline void set_allocated_roomidstr(::std::string* roomidstr);

  // optional string shorturl = 10;
  inline bool has_shorturl() const;
  inline void clear_shorturl();
  static const int kShorturlFieldNumber = 10;
  inline const ::std::string& shorturl() const;
  inline void set_shorturl(const ::std::string& value);
  inline void set_shorturl(const char* value);
  inline void set_shorturl(const char* value, size_t size);
  inline ::std::string* mutable_shorturl();
  inline ::std::string* release_shorturl();
  inline void set_allocated_shorturl(::std::string* shorturl);

  // @@protoc_insertion_point(class_scope:mt.TVrsRoomState)
 private:
  inline void set_has_elapse();
  inline void clear_has_elapse();
  inline void set_has_lcastpoint();
  inline void clear_has_lcastpoint();
  inline void set_has_prgid();
  inline void clear_has_prgid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomname();
  inline void clear_has_roomname();
  inline void set_has_usrgrpid();
  inline void clear_has_usrgrpid();
  inline void set_has_livetime();
  inline void clear_has_livetime();
  inline void set_has_livestreampath();
  inline void clear_has_livestreampath();
  inline void set_has_roomidstr();
  inline void clear_has_roomidstr();
  inline void set_has_shorturl();
  inline void clear_has_shorturl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* lcastpoint_;
  ::google::protobuf::uint32 elapse_;
  ::google::protobuf::uint32 prgid_;
  ::std::string* roomname_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 usrgrpid_;
  ::std::string* livestreampath_;
  ::std::string* roomidstr_;
  ::std::string* shorturl_;
  ::google::protobuf::uint32 livetime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsRoomState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsRoomsState : public ::google::protobuf::Message {
 public:
  TVrsRoomsState();
  virtual ~TVrsRoomsState();

  TVrsRoomsState(const TVrsRoomsState& from);

  inline TVrsRoomsState& operator=(const TVrsRoomsState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsRoomsState& default_instance();

  void Swap(TVrsRoomsState* other);

  // implements Message ----------------------------------------------

  TVrsRoomsState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsRoomsState& from);
  void MergeFrom(const TVrsRoomsState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVrsRoomState roomstate = 1;
  inline int roomstate_size() const;
  inline void clear_roomstate();
  static const int kRoomstateFieldNumber = 1;
  inline const ::mt::TVrsRoomState& roomstate(int index) const;
  inline ::mt::TVrsRoomState* mutable_roomstate(int index);
  inline ::mt::TVrsRoomState* add_roomstate();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsRoomState >&
      roomstate() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsRoomState >*
      mutable_roomstate();

  // @@protoc_insertion_point(class_scope:mt.TVrsRoomsState)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVrsRoomState > roomstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsRoomsState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsRoomCfg : public ::google::protobuf::Message {
 public:
  TVrsRoomCfg();
  virtual ~TVrsRoomCfg();

  TVrsRoomCfg(const TVrsRoomCfg& from);

  inline TVrsRoomCfg& operator=(const TVrsRoomCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsRoomCfg& default_instance();

  void Swap(TVrsRoomCfg* other);

  // implements Message ----------------------------------------------

  TVrsRoomCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsRoomCfg& from);
  void MergeFrom(const TVrsRoomCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string confname = 1;
  inline bool has_confname() const;
  inline void clear_confname();
  static const int kConfnameFieldNumber = 1;
  inline const ::std::string& confname() const;
  inline void set_confname(const ::std::string& value);
  inline void set_confname(const char* value);
  inline void set_confname(const char* value, size_t size);
  inline ::std::string* mutable_confname();
  inline ::std::string* release_confname();
  inline void set_allocated_confname(::std::string* confname);

  // optional string starttime = 2;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 2;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // @@protoc_insertion_point(class_scope:mt.TVrsRoomCfg)
 private:
  inline void set_has_confname();
  inline void clear_has_confname();
  inline void set_has_starttime();
  inline void clear_has_starttime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* confname_;
  ::std::string* starttime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsRoomCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsRoomsCfg : public ::google::protobuf::Message {
 public:
  TVrsRoomsCfg();
  virtual ~TVrsRoomsCfg();

  TVrsRoomsCfg(const TVrsRoomsCfg& from);

  inline TVrsRoomsCfg& operator=(const TVrsRoomsCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsRoomsCfg& default_instance();

  void Swap(TVrsRoomsCfg* other);

  // implements Message ----------------------------------------------

  TVrsRoomsCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsRoomsCfg& from);
  void MergeFrom(const TVrsRoomsCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVrsRoomCfg roomcfg = 1;
  inline int roomcfg_size() const;
  inline void clear_roomcfg();
  static const int kRoomcfgFieldNumber = 1;
  inline const ::mt::TVrsRoomCfg& roomcfg(int index) const;
  inline ::mt::TVrsRoomCfg* mutable_roomcfg(int index);
  inline ::mt::TVrsRoomCfg* add_roomcfg();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsRoomCfg >&
      roomcfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsRoomCfg >*
      mutable_roomcfg();

  // @@protoc_insertion_point(class_scope:mt.TVrsRoomsCfg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVrsRoomCfg > roomcfg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsRoomsCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TSubsMsgID : public ::google::protobuf::Message {
 public:
  TSubsMsgID();
  virtual ~TSubsMsgID();

  TSubsMsgID(const TSubsMsgID& from);

  inline TSubsMsgID& operator=(const TSubsMsgID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSubsMsgID& default_instance();

  void Swap(TSubsMsgID* other);

  // implements Message ----------------------------------------------

  TSubsMsgID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSubsMsgID& from);
  void MergeFrom(const TSubsMsgID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string msgid = 1;
  inline int msgid_size() const;
  inline void clear_msgid();
  static const int kMsgidFieldNumber = 1;
  inline const ::std::string& msgid(int index) const;
  inline ::std::string* mutable_msgid(int index);
  inline void set_msgid(int index, const ::std::string& value);
  inline void set_msgid(int index, const char* value);
  inline void set_msgid(int index, const char* value, size_t size);
  inline ::std::string* add_msgid();
  inline void add_msgid(const ::std::string& value);
  inline void add_msgid(const char* value);
  inline void add_msgid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& msgid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_msgid();

  // @@protoc_insertion_point(class_scope:mt.TSubsMsgID)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> msgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TSubsMsgID* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsSearchFilesReq : public ::google::protobuf::Message {
 public:
  TVrsSearchFilesReq();
  virtual ~TVrsSearchFilesReq();

  TVrsSearchFilesReq(const TVrsSearchFilesReq& from);

  inline TVrsSearchFilesReq& operator=(const TVrsSearchFilesReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsSearchFilesReq& default_instance();

  void Swap(TVrsSearchFilesReq* other);

  // implements Message ----------------------------------------------

  TVrsSearchFilesReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsSearchFilesReq& from);
  void MergeFrom(const TVrsSearchFilesReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 folderid = 1;
  inline bool has_folderid() const;
  inline void clear_folderid();
  static const int kFolderidFieldNumber = 1;
  inline ::google::protobuf::uint32 folderid() const;
  inline void set_folderid(::google::protobuf::uint32 value);

  // optional uint32 prgs1page = 2;
  inline bool has_prgs1page() const;
  inline void clear_prgs1page();
  static const int kPrgs1PageFieldNumber = 2;
  inline ::google::protobuf::uint32 prgs1page() const;
  inline void set_prgs1page(::google::protobuf::uint32 value);

  // optional uint32 pageid = 3;
  inline bool has_pageid() const;
  inline void clear_pageid();
  static const int kPageidFieldNumber = 3;
  inline ::google::protobuf::uint32 pageid() const;
  inline void set_pageid(::google::protobuf::uint32 value);

  // optional string includename = 5;
  inline bool has_includename() const;
  inline void clear_includename();
  static const int kIncludenameFieldNumber = 5;
  inline const ::std::string& includename() const;
  inline void set_includename(const ::std::string& value);
  inline void set_includename(const char* value);
  inline void set_includename(const char* value, size_t size);
  inline ::std::string* mutable_includename();
  inline ::std::string* release_includename();
  inline void set_allocated_includename(::std::string* includename);

  // @@protoc_insertion_point(class_scope:mt.TVrsSearchFilesReq)
 private:
  inline void set_has_folderid();
  inline void clear_has_folderid();
  inline void set_has_prgs1page();
  inline void clear_has_prgs1page();
  inline void set_has_pageid();
  inline void clear_has_pageid();
  inline void set_has_includename();
  inline void clear_has_includename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 folderid_;
  ::google::protobuf::uint32 prgs1page_;
  ::std::string* includename_;
  ::google::protobuf::uint32 pageid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsSearchFilesReq* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsGetReserveRoomListReq : public ::google::protobuf::Message {
 public:
  TVrsGetReserveRoomListReq();
  virtual ~TVrsGetReserveRoomListReq();

  TVrsGetReserveRoomListReq(const TVrsGetReserveRoomListReq& from);

  inline TVrsGetReserveRoomListReq& operator=(const TVrsGetReserveRoomListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsGetReserveRoomListReq& default_instance();

  void Swap(TVrsGetReserveRoomListReq* other);

  // implements Message ----------------------------------------------

  TVrsGetReserveRoomListReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsGetReserveRoomListReq& from);
  void MergeFrom(const TVrsGetReserveRoomListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 nums1page = 1;
  inline bool has_nums1page() const;
  inline void clear_nums1page();
  static const int kNums1PageFieldNumber = 1;
  inline ::google::protobuf::uint32 nums1page() const;
  inline void set_nums1page(::google::protobuf::uint32 value);

  // optional uint32 pageid = 2;
  inline bool has_pageid() const;
  inline void clear_pageid();
  static const int kPageidFieldNumber = 2;
  inline ::google::protobuf::uint32 pageid() const;
  inline void set_pageid(::google::protobuf::uint32 value);

  // optional string includename = 3;
  inline bool has_includename() const;
  inline void clear_includename();
  static const int kIncludenameFieldNumber = 3;
  inline const ::std::string& includename() const;
  inline void set_includename(const ::std::string& value);
  inline void set_includename(const char* value);
  inline void set_includename(const char* value, size_t size);
  inline ::std::string* mutable_includename();
  inline ::std::string* release_includename();
  inline void set_allocated_includename(::std::string* includename);

  // @@protoc_insertion_point(class_scope:mt.TVrsGetReserveRoomListReq)
 private:
  inline void set_has_nums1page();
  inline void clear_has_nums1page();
  inline void set_has_pageid();
  inline void clear_has_pageid();
  inline void set_has_includename();
  inline void clear_has_includename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 nums1page_;
  ::google::protobuf::uint32 pageid_;
  ::std::string* includename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsGetReserveRoomListReq* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsOldRoomCfg : public ::google::protobuf::Message {
 public:
  TVrsOldRoomCfg();
  virtual ~TVrsOldRoomCfg();

  TVrsOldRoomCfg(const TVrsOldRoomCfg& from);

  inline TVrsOldRoomCfg& operator=(const TVrsOldRoomCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsOldRoomCfg& default_instance();

  void Swap(TVrsOldRoomCfg* other);

  // implements Message ----------------------------------------------

  TVrsOldRoomCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsOldRoomCfg& from);
  void MergeFrom(const TVrsOldRoomCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string prgalias = 3;
  inline bool has_prgalias() const;
  inline void clear_prgalias();
  static const int kPrgaliasFieldNumber = 3;
  inline const ::std::string& prgalias() const;
  inline void set_prgalias(const ::std::string& value);
  inline void set_prgalias(const char* value);
  inline void set_prgalias(const char* value, size_t size);
  inline ::std::string* mutable_prgalias();
  inline ::std::string* release_prgalias();
  inline void set_allocated_prgalias(::std::string* prgalias);

  // optional uint32 prgid = 4;
  inline bool has_prgid() const;
  inline void clear_prgid();
  static const int kPrgidFieldNumber = 4;
  inline ::google::protobuf::uint32 prgid() const;
  inline void set_prgid(::google::protobuf::uint32 value);

  // optional string prgname = 5;
  inline bool has_prgname() const;
  inline void clear_prgname();
  static const int kPrgnameFieldNumber = 5;
  inline const ::std::string& prgname() const;
  inline void set_prgname(const ::std::string& value);
  inline void set_prgname(const char* value);
  inline void set_prgname(const char* value, size_t size);
  inline ::std::string* mutable_prgname();
  inline ::std::string* release_prgname();
  inline void set_allocated_prgname(::std::string* prgname);

  // optional uint32 restime = 6;
  inline bool has_restime() const;
  inline void clear_restime();
  static const int kRestimeFieldNumber = 6;
  inline ::google::protobuf::uint32 restime() const;
  inline void set_restime(::google::protobuf::uint32 value);

  // optional uint32 roomid = 7;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 7;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 usrgrpid = 8;
  inline bool has_usrgrpid() const;
  inline void clear_usrgrpid();
  static const int kUsrgrpidFieldNumber = 8;
  inline ::google::protobuf::uint32 usrgrpid() const;
  inline void set_usrgrpid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TVrsOldRoomCfg)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_prgalias();
  inline void clear_has_prgalias();
  inline void set_has_prgid();
  inline void clear_has_prgid();
  inline void set_has_prgname();
  inline void clear_has_prgname();
  inline void set_has_restime();
  inline void clear_has_restime();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_usrgrpid();
  inline void clear_has_usrgrpid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 prgid_;
  ::std::string* prgalias_;
  ::std::string* prgname_;
  ::google::protobuf::uint32 restime_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 usrgrpid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsOldRoomCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVrsOldRoomsCfg : public ::google::protobuf::Message {
 public:
  TVrsOldRoomsCfg();
  virtual ~TVrsOldRoomsCfg();

  TVrsOldRoomsCfg(const TVrsOldRoomsCfg& from);

  inline TVrsOldRoomsCfg& operator=(const TVrsOldRoomsCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVrsOldRoomsCfg& default_instance();

  void Swap(TVrsOldRoomsCfg* other);

  // implements Message ----------------------------------------------

  TVrsOldRoomsCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVrsOldRoomsCfg& from);
  void MergeFrom(const TVrsOldRoomsCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVrsOldRoomCfg roomcfg = 1;
  inline int roomcfg_size() const;
  inline void clear_roomcfg();
  static const int kRoomcfgFieldNumber = 1;
  inline const ::mt::TVrsOldRoomCfg& roomcfg(int index) const;
  inline ::mt::TVrsOldRoomCfg* mutable_roomcfg(int index);
  inline ::mt::TVrsOldRoomCfg* add_roomcfg();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsOldRoomCfg >&
      roomcfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsOldRoomCfg >*
      mutable_roomcfg();

  // @@protoc_insertion_point(class_scope:mt.TVrsOldRoomsCfg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVrsOldRoomCfg > roomcfg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TVrsOldRoomsCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTOrder : public ::google::protobuf::Message {
 public:
  TMTOrder();
  virtual ~TMTOrder();

  TMTOrder(const TMTOrder& from);

  inline TMTOrder& operator=(const TMTOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTOrder& default_instance();

  void Swap(TMTOrder* other);

  // implements Message ----------------------------------------------

  TMTOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTOrder& from);
  void MergeFrom(const TMTOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional bytes order = 2;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 2;
  inline const ::std::string& order() const;
  inline void set_order(const ::std::string& value);
  inline void set_order(const char* value);
  inline void set_order(const void* value, size_t size);
  inline ::std::string* mutable_order();
  inline ::std::string* release_order();
  inline void set_allocated_order(::std::string* order);

  // @@protoc_insertion_point(class_scope:mt.TMTOrder)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_order();
  inline void clear_has_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* order_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMTOrder* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TGmTestResult : public ::google::protobuf::Message {
 public:
  TGmTestResult();
  virtual ~TGmTestResult();

  TGmTestResult(const TGmTestResult& from);

  inline TGmTestResult& operator=(const TGmTestResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGmTestResult& default_instance();

  void Swap(TGmTestResult* other);

  // implements Message ----------------------------------------------

  TGmTestResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGmTestResult& from);
  void MergeFrom(const TGmTestResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmEncryptArithmetic emEncrypt = 1;
  inline bool has_emencrypt() const;
  inline void clear_emencrypt();
  static const int kEmEncryptFieldNumber = 1;
  inline ::mt::EmEncryptArithmetic emencrypt() const;
  inline void set_emencrypt(::mt::EmEncryptArithmetic value);

  // optional int32 errorcode = 2;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorcodeFieldNumber = 2;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt.TGmTestResult)
 private:
  inline void set_has_emencrypt();
  inline void clear_has_emencrypt();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emencrypt_;
  ::google::protobuf::int32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TGmTestResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TGmAndRandomNumTest : public ::google::protobuf::Message {
 public:
  TGmAndRandomNumTest();
  virtual ~TGmAndRandomNumTest();

  TGmAndRandomNumTest(const TGmAndRandomNumTest& from);

  inline TGmAndRandomNumTest& operator=(const TGmAndRandomNumTest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGmAndRandomNumTest& default_instance();

  void Swap(TGmAndRandomNumTest* other);

  // implements Message ----------------------------------------------

  TGmAndRandomNumTest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGmAndRandomNumTest& from);
  void MergeFrom(const TGmAndRandomNumTest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TGmTestResult gmtest_result = 1;
  inline int gmtest_result_size() const;
  inline void clear_gmtest_result();
  static const int kGmtestResultFieldNumber = 1;
  inline const ::mt::TGmTestResult& gmtest_result(int index) const;
  inline ::mt::TGmTestResult* mutable_gmtest_result(int index);
  inline ::mt::TGmTestResult* add_gmtest_result();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TGmTestResult >&
      gmtest_result() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TGmTestResult >*
      mutable_gmtest_result();

  // optional int32 randomnumtestresult = 2;
  inline bool has_randomnumtestresult() const;
  inline void clear_randomnumtestresult();
  static const int kRandomnumtestresultFieldNumber = 2;
  inline ::google::protobuf::int32 randomnumtestresult() const;
  inline void set_randomnumtestresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt.TGmAndRandomNumTest)
 private:
  inline void set_has_randomnumtestresult();
  inline void clear_has_randomnumtestresult();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TGmTestResult > gmtest_result_;
  ::google::protobuf::int32 randomnumtestresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TGmAndRandomNumTest* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAllSelfTestResult : public ::google::protobuf::Message {
 public:
  TAllSelfTestResult();
  virtual ~TAllSelfTestResult();

  TAllSelfTestResult(const TAllSelfTestResult& from);

  inline TAllSelfTestResult& operator=(const TAllSelfTestResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAllSelfTestResult& default_instance();

  void Swap(TAllSelfTestResult* other);

  // implements Message ----------------------------------------------

  TAllSelfTestResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAllSelfTestResult& from);
  void MergeFrom(const TAllSelfTestResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TGmTestResult gmtest_result = 1;
  inline int gmtest_result_size() const;
  inline void clear_gmtest_result();
  static const int kGmtestResultFieldNumber = 1;
  inline const ::mt::TGmTestResult& gmtest_result(int index) const;
  inline ::mt::TGmTestResult* mutable_gmtest_result(int index);
  inline ::mt::TGmTestResult* add_gmtest_result();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TGmTestResult >&
      gmtest_result() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TGmTestResult >*
      mutable_gmtest_result();

  // optional int32 randomnumtestresult = 2;
  inline bool has_randomnumtestresult() const;
  inline void clear_randomnumtestresult();
  static const int kRandomnumtestresultFieldNumber = 2;
  inline ::google::protobuf::int32 randomnumtestresult() const;
  inline void set_randomnumtestresult(::google::protobuf::int32 value);

  // optional int32 signcerttestresult = 3;
  inline bool has_signcerttestresult() const;
  inline void clear_signcerttestresult();
  static const int kSigncerttestresultFieldNumber = 3;
  inline ::google::protobuf::int32 signcerttestresult() const;
  inline void set_signcerttestresult(::google::protobuf::int32 value);

  // optional int32 enccerttestresult = 4;
  inline bool has_enccerttestresult() const;
  inline void clear_enccerttestresult();
  static const int kEnccerttestresultFieldNumber = 4;
  inline ::google::protobuf::int32 enccerttestresult() const;
  inline void set_enccerttestresult(::google::protobuf::int32 value);

  // optional uint32 softintegritytestresult = 5;
  inline bool has_softintegritytestresult() const;
  inline void clear_softintegritytestresult();
  static const int kSoftintegritytestresultFieldNumber = 5;
  inline ::google::protobuf::uint32 softintegritytestresult() const;
  inline void set_softintegritytestresult(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TAllSelfTestResult)
 private:
  inline void set_has_randomnumtestresult();
  inline void clear_has_randomnumtestresult();
  inline void set_has_signcerttestresult();
  inline void clear_has_signcerttestresult();
  inline void set_has_enccerttestresult();
  inline void clear_has_enccerttestresult();
  inline void set_has_softintegritytestresult();
  inline void clear_has_softintegritytestresult();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TGmTestResult > gmtest_result_;
  ::google::protobuf::int32 randomnumtestresult_;
  ::google::protobuf::int32 signcerttestresult_;
  ::google::protobuf::int32 enccerttestresult_;
  ::google::protobuf::uint32 softintegritytestresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TAllSelfTestResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API THandShakeParam : public ::google::protobuf::Message {
 public:
  THandShakeParam();
  virtual ~THandShakeParam();

  THandShakeParam(const THandShakeParam& from);

  inline THandShakeParam& operator=(const THandShakeParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const THandShakeParam& default_instance();

  void Swap(THandShakeParam* other);

  // implements Message ----------------------------------------------

  THandShakeParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const THandShakeParam& from);
  void MergeFrom(const THandShakeParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes pk = 1;
  inline bool has_pk() const;
  inline void clear_pk();
  static const int kPkFieldNumber = 1;
  inline const ::std::string& pk() const;
  inline void set_pk(const ::std::string& value);
  inline void set_pk(const char* value);
  inline void set_pk(const void* value, size_t size);
  inline ::std::string* mutable_pk();
  inline ::std::string* release_pk();
  inline void set_allocated_pk(::std::string* pk);

  // optional .mt.EmEncryptArithmetic enc_type = 2;
  inline bool has_enc_type() const;
  inline void clear_enc_type();
  static const int kEncTypeFieldNumber = 2;
  inline ::mt::EmEncryptArithmetic enc_type() const;
  inline void set_enc_type(::mt::EmEncryptArithmetic value);

  // optional .mt.EmDigestType digest_type = 3;
  inline bool has_digest_type() const;
  inline void clear_digest_type();
  static const int kDigestTypeFieldNumber = 3;
  inline ::mt::EmDigestType digest_type() const;
  inline void set_digest_type(::mt::EmDigestType value);

  // optional .mt.EmPubPriType pubpri_type = 4;
  inline bool has_pubpri_type() const;
  inline void clear_pubpri_type();
  static const int kPubpriTypeFieldNumber = 4;
  inline ::mt::EmPubPriType pubpri_type() const;
  inline void set_pubpri_type(::mt::EmPubPriType value);

  // optional bytes nonce = 5;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 5;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const void* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  inline void set_allocated_nonce(::std::string* nonce);

  // @@protoc_insertion_point(class_scope:mt.THandShakeParam)
 private:
  inline void set_has_pk();
  inline void clear_has_pk();
  inline void set_has_enc_type();
  inline void clear_has_enc_type();
  inline void set_has_digest_type();
  inline void clear_has_digest_type();
  inline void set_has_pubpri_type();
  inline void clear_has_pubpri_type();
  inline void set_has_nonce();
  inline void clear_has_nonce();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pk_;
  int enc_type_;
  int digest_type_;
  ::std::string* nonce_;
  int pubpri_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static THandShakeParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtcLoginParam : public ::google::protobuf::Message {
 public:
  TMtcLoginParam();
  virtual ~TMtcLoginParam();

  TMtcLoginParam(const TMtcLoginParam& from);

  inline TMtcLoginParam& operator=(const TMtcLoginParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtcLoginParam& default_instance();

  void Swap(TMtcLoginParam* other);

  // implements Message ----------------------------------------------

  TMtcLoginParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtcLoginParam& from);
  void MergeFrom(const TMtcLoginParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmClientAppType app_type = 1;
  inline bool has_app_type() const;
  inline void clear_app_type();
  static const int kAppTypeFieldNumber = 1;
  inline ::mt::EmClientAppType app_type() const;
  inline void set_app_type(::mt::EmClientAppType value);

  // optional .mt.EmAuthType auth_type = 2;
  inline bool has_auth_type() const;
  inline void clear_auth_type();
  static const int kAuthTypeFieldNumber = 2;
  inline ::mt::EmAuthType auth_type() const;
  inline void set_auth_type(::mt::EmAuthType value);

  // optional string user_name = 3;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional bytes digest_pwd = 4;
  inline bool has_digest_pwd() const;
  inline void clear_digest_pwd();
  static const int kDigestPwdFieldNumber = 4;
  inline const ::std::string& digest_pwd() const;
  inline void set_digest_pwd(const ::std::string& value);
  inline void set_digest_pwd(const char* value);
  inline void set_digest_pwd(const void* value, size_t size);
  inline ::std::string* mutable_digest_pwd();
  inline ::std::string* release_digest_pwd();
  inline void set_allocated_digest_pwd(::std::string* digest_pwd);

  // optional bytes nonce = 5;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 5;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const void* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  inline void set_allocated_nonce(::std::string* nonce);

  // optional bytes cnonce = 6;
  inline bool has_cnonce() const;
  inline void clear_cnonce();
  static const int kCnonceFieldNumber = 6;
  inline const ::std::string& cnonce() const;
  inline void set_cnonce(const ::std::string& value);
  inline void set_cnonce(const char* value);
  inline void set_cnonce(const void* value, size_t size);
  inline ::std::string* mutable_cnonce();
  inline ::std::string* release_cnonce();
  inline void set_allocated_cnonce(::std::string* cnonce);

  // optional bytes enc_key = 7;
  inline bool has_enc_key() const;
  inline void clear_enc_key();
  static const int kEncKeyFieldNumber = 7;
  inline const ::std::string& enc_key() const;
  inline void set_enc_key(const ::std::string& value);
  inline void set_enc_key(const char* value);
  inline void set_enc_key(const void* value, size_t size);
  inline ::std::string* mutable_enc_key();
  inline ::std::string* release_enc_key();
  inline void set_allocated_enc_key(::std::string* enc_key);

  // @@protoc_insertion_point(class_scope:mt.TMtcLoginParam)
 private:
  inline void set_has_app_type();
  inline void clear_has_app_type();
  inline void set_has_auth_type();
  inline void clear_has_auth_type();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_digest_pwd();
  inline void clear_has_digest_pwd();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_cnonce();
  inline void clear_has_cnonce();
  inline void set_has_enc_key();
  inline void clear_has_enc_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int app_type_;
  int auth_type_;
  ::std::string* user_name_;
  ::std::string* digest_pwd_;
  ::std::string* nonce_;
  ::std::string* cnonce_;
  ::std::string* enc_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMtcLoginParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtcLoginRet : public ::google::protobuf::Message {
 public:
  TMtcLoginRet();
  virtual ~TMtcLoginRet();

  TMtcLoginRet(const TMtcLoginRet& from);

  inline TMtcLoginRet& operator=(const TMtcLoginRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtcLoginRet& default_instance();

  void Swap(TMtcLoginRet* other);

  // implements Message ----------------------------------------------

  TMtcLoginRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtcLoginRet& from);
  void MergeFrom(const TMtcLoginRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional bool is_kickother = 2;
  inline bool has_is_kickother() const;
  inline void clear_is_kickother();
  static const int kIsKickotherFieldNumber = 2;
  inline bool is_kickother() const;
  inline void set_is_kickother(bool value);

  // optional .mt.TMtcBaseInfo kickee = 3;
  inline bool has_kickee() const;
  inline void clear_kickee();
  static const int kKickeeFieldNumber = 3;
  inline const ::mt::TMtcBaseInfo& kickee() const;
  inline ::mt::TMtcBaseInfo* mutable_kickee();
  inline ::mt::TMtcBaseInfo* release_kickee();
  inline void set_allocated_kickee(::mt::TMtcBaseInfo* kickee);

  // optional .mt.TMtcBaseInfo local = 4;
  inline bool has_local() const;
  inline void clear_local();
  static const int kLocalFieldNumber = 4;
  inline const ::mt::TMtcBaseInfo& local() const;
  inline ::mt::TMtcBaseInfo* mutable_local();
  inline ::mt::TMtcBaseInfo* release_local();
  inline void set_allocated_local(::mt::TMtcBaseInfo* local);

  // optional uint32 user_login_error_count = 5;
  inline bool has_user_login_error_count() const;
  inline void clear_user_login_error_count();
  static const int kUserLoginErrorCountFieldNumber = 5;
  inline ::google::protobuf::uint32 user_login_error_count() const;
  inline void set_user_login_error_count(::google::protobuf::uint32 value);

  // optional uint32 user_login_time = 6;
  inline bool has_user_login_time() const;
  inline void clear_user_login_time();
  static const int kUserLoginTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 user_login_time() const;
  inline void set_user_login_time(::google::protobuf::uint32 value);

  // optional bool user_is_exist = 7;
  inline bool has_user_is_exist() const;
  inline void clear_user_is_exist();
  static const int kUserIsExistFieldNumber = 7;
  inline bool user_is_exist() const;
  inline void set_user_is_exist(bool value);

  // optional .mt.EmLoginFailReason user_login_error_reason = 8;
  inline bool has_user_login_error_reason() const;
  inline void clear_user_login_error_reason();
  static const int kUserLoginErrorReasonFieldNumber = 8;
  inline ::mt::EmLoginFailReason user_login_error_reason() const;
  inline void set_user_login_error_reason(::mt::EmLoginFailReason value);

  // optional uint32 user_max_login_count = 9;
  inline bool has_user_max_login_count() const;
  inline void clear_user_max_login_count();
  static const int kUserMaxLoginCountFieldNumber = 9;
  inline ::google::protobuf::uint32 user_max_login_count() const;
  inline void set_user_max_login_count(::google::protobuf::uint32 value);

  // optional uint32 user_max_lock_time = 10;
  inline bool has_user_max_lock_time() const;
  inline void clear_user_max_lock_time();
  static const int kUserMaxLockTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 user_max_lock_time() const;
  inline void set_user_max_lock_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtcLoginRet)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_is_kickother();
  inline void clear_has_is_kickother();
  inline void set_has_kickee();
  inline void clear_has_kickee();
  inline void set_has_local();
  inline void clear_has_local();
  inline void set_has_user_login_error_count();
  inline void clear_has_user_login_error_count();
  inline void set_has_user_login_time();
  inline void clear_has_user_login_time();
  inline void set_has_user_is_exist();
  inline void clear_has_user_is_exist();
  inline void set_has_user_login_error_reason();
  inline void clear_has_user_login_error_reason();
  inline void set_has_user_max_login_count();
  inline void clear_has_user_max_login_count();
  inline void set_has_user_max_lock_time();
  inline void clear_has_user_max_lock_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMtcBaseInfo* kickee_;
  bool result_;
  bool is_kickother_;
  bool user_is_exist_;
  ::google::protobuf::uint32 user_login_error_count_;
  ::mt::TMtcBaseInfo* local_;
  ::google::protobuf::uint32 user_login_time_;
  int user_login_error_reason_;
  ::google::protobuf::uint32 user_max_login_count_;
  ::google::protobuf::uint32 user_max_lock_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMtcLoginRet* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtcBaseInfo : public ::google::protobuf::Message {
 public:
  TMtcBaseInfo();
  virtual ~TMtcBaseInfo();

  TMtcBaseInfo(const TMtcBaseInfo& from);

  inline TMtcBaseInfo& operator=(const TMtcBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtcBaseInfo& default_instance();

  void Swap(TMtcBaseInfo* other);

  // implements Message ----------------------------------------------

  TMtcBaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtcBaseInfo& from);
  void MergeFrom(const TMtcBaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional .mt.EmClientAppType app_type = 2;
  inline bool has_app_type() const;
  inline void clear_app_type();
  static const int kAppTypeFieldNumber = 2;
  inline ::mt::EmClientAppType app_type() const;
  inline void set_app_type(::mt::EmClientAppType value);

  // optional .mt.EmAuthType auth_type = 3;
  inline bool has_auth_type() const;
  inline void clear_auth_type();
  static const int kAuthTypeFieldNumber = 3;
  inline ::mt::EmAuthType auth_type() const;
  inline void set_auth_type(::mt::EmAuthType value);

  // optional string user_name = 4;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 4;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:mt.TMtcBaseInfo)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_app_type();
  inline void clear_has_app_type();
  inline void set_has_auth_type();
  inline void clear_has_auth_type();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  int app_type_;
  int auth_type_;
  ::std::string* user_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMtcBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVersionInfo : public ::google::protobuf::Message {
 public:
  TMtVersionInfo();
  virtual ~TMtVersionInfo();

  TMtVersionInfo(const TMtVersionInfo& from);

  inline TMtVersionInfo& operator=(const TMtVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVersionInfo& default_instance();

  void Swap(TMtVersionInfo* other);

  // implements Message ----------------------------------------------

  TMtVersionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVersionInfo& from);
  void MergeFrom(const TMtVersionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional .mt.EmMtModel model = 2;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 2;
  inline ::mt::EmMtModel model() const;
  inline void set_model(::mt::EmMtModel value);

  // optional bool is_support_sm = 3;
  inline bool has_is_support_sm() const;
  inline void clear_is_support_sm();
  static const int kIsSupportSmFieldNumber = 3;
  inline bool is_support_sm() const;
  inline void set_is_support_sm(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtVersionInfo)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_is_support_sm();
  inline void clear_has_is_support_sm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  int model_;
  bool is_support_sm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMtVersionInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtcBaseInfoList : public ::google::protobuf::Message {
 public:
  TMtcBaseInfoList();
  virtual ~TMtcBaseInfoList();

  TMtcBaseInfoList(const TMtcBaseInfoList& from);

  inline TMtcBaseInfoList& operator=(const TMtcBaseInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtcBaseInfoList& default_instance();

  void Swap(TMtcBaseInfoList* other);

  // implements Message ----------------------------------------------

  TMtcBaseInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtcBaseInfoList& from);
  void MergeFrom(const TMtcBaseInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtcBaseInfo mtc_list = 1;
  inline int mtc_list_size() const;
  inline void clear_mtc_list();
  static const int kMtcListFieldNumber = 1;
  inline const ::mt::TMtcBaseInfo& mtc_list(int index) const;
  inline ::mt::TMtcBaseInfo* mutable_mtc_list(int index);
  inline ::mt::TMtcBaseInfo* add_mtc_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtcBaseInfo >&
      mtc_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtcBaseInfo >*
      mutable_mtc_list();

  // @@protoc_insertion_point(class_scope:mt.TMtcBaseInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtcBaseInfo > mtc_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMtcBaseInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAiInfoCfg : public ::google::protobuf::Message {
 public:
  TMtAiInfoCfg();
  virtual ~TMtAiInfoCfg();

  TMtAiInfoCfg(const TMtAiInfoCfg& from);

  inline TMtAiInfoCfg& operator=(const TMtAiInfoCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAiInfoCfg& default_instance();

  void Swap(TMtAiInfoCfg* other);

  // implements Message ----------------------------------------------

  TMtAiInfoCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAiInfoCfg& from);
  void MergeFrom(const TMtAiInfoCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_UsedVoiceAide = 1;
  inline bool has_is_usedvoiceaide() const;
  inline void clear_is_usedvoiceaide();
  static const int kIsUsedVoiceAideFieldNumber = 1;
  inline bool is_usedvoiceaide() const;
  inline void set_is_usedvoiceaide(bool value);

  // optional bool is_UsedCountOfPeople = 2;
  inline bool has_is_usedcountofpeople() const;
  inline void clear_is_usedcountofpeople();
  static const int kIsUsedCountOfPeopleFieldNumber = 2;
  inline bool is_usedcountofpeople() const;
  inline void set_is_usedcountofpeople(bool value);

  // optional bool is_UsedFaceSign = 3;
  inline bool has_is_usedfacesign() const;
  inline void clear_is_usedfacesign();
  static const int kIsUsedFaceSignFieldNumber = 3;
  inline bool is_usedfacesign() const;
  inline void set_is_usedfacesign(bool value);

  // optional bool is_UsedElectNameplate = 4;
  inline bool has_is_usedelectnameplate() const;
  inline void clear_is_usedelectnameplate();
  static const int kIsUsedElectNameplateFieldNumber = 4;
  inline bool is_usedelectnameplate() const;
  inline void set_is_usedelectnameplate(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtAiInfoCfg)
 private:
  inline void set_has_is_usedvoiceaide();
  inline void clear_has_is_usedvoiceaide();
  inline void set_has_is_usedcountofpeople();
  inline void clear_has_is_usedcountofpeople();
  inline void set_has_is_usedfacesign();
  inline void clear_has_is_usedfacesign();
  inline void set_has_is_usedelectnameplate();
  inline void clear_has_is_usedelectnameplate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_usedvoiceaide_;
  bool is_usedcountofpeople_;
  bool is_usedfacesign_;
  bool is_usedelectnameplate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcommon_2eproto();
  friend void protobuf_AssignDesc_structcommon_2eproto();
  friend void protobuf_ShutdownFile_structcommon_2eproto();

  void InitAsDefaultInstance();
  static TMtAiInfoCfg* default_instance_;
};
// ===================================================================


// ===================================================================

// TNetAddr

// optional .mt.EmIpAddrType ip_type = 1 [default = emIpV4];
inline bool TNetAddr::has_ip_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNetAddr::set_has_ip_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNetAddr::clear_has_ip_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNetAddr::clear_ip_type() {
  ip_type_ = 0;
  clear_has_ip_type();
}
inline ::mt::EmIpAddrType TNetAddr::ip_type() const {
  return static_cast< ::mt::EmIpAddrType >(ip_type_);
}
inline void TNetAddr::set_ip_type(::mt::EmIpAddrType value) {
  assert(::mt::EmIpAddrType_IsValid(value));
  set_has_ip_type();
  ip_type_ = value;
}

// optional uint32 ip = 2;
inline bool TNetAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNetAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNetAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNetAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TNetAddr::ip() const {
  return ip_;
}
inline void TNetAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional bytes ip_v6 = 3;
inline bool TNetAddr::has_ip_v6() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNetAddr::set_has_ip_v6() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNetAddr::clear_has_ip_v6() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNetAddr::clear_ip_v6() {
  if (ip_v6_ != &::google::protobuf::internal::kEmptyString) {
    ip_v6_->clear();
  }
  clear_has_ip_v6();
}
inline const ::std::string& TNetAddr::ip_v6() const {
  return *ip_v6_;
}
inline void TNetAddr::set_ip_v6(const ::std::string& value) {
  set_has_ip_v6();
  if (ip_v6_ == &::google::protobuf::internal::kEmptyString) {
    ip_v6_ = new ::std::string;
  }
  ip_v6_->assign(value);
}
inline void TNetAddr::set_ip_v6(const char* value) {
  set_has_ip_v6();
  if (ip_v6_ == &::google::protobuf::internal::kEmptyString) {
    ip_v6_ = new ::std::string;
  }
  ip_v6_->assign(value);
}
inline void TNetAddr::set_ip_v6(const void* value, size_t size) {
  set_has_ip_v6();
  if (ip_v6_ == &::google::protobuf::internal::kEmptyString) {
    ip_v6_ = new ::std::string;
  }
  ip_v6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNetAddr::mutable_ip_v6() {
  set_has_ip_v6();
  if (ip_v6_ == &::google::protobuf::internal::kEmptyString) {
    ip_v6_ = new ::std::string;
  }
  return ip_v6_;
}
inline ::std::string* TNetAddr::release_ip_v6() {
  clear_has_ip_v6();
  if (ip_v6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_v6_;
    ip_v6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNetAddr::set_allocated_ip_v6(::std::string* ip_v6) {
  if (ip_v6_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_v6_;
  }
  if (ip_v6) {
    set_has_ip_v6();
    ip_v6_ = ip_v6;
  } else {
    clear_has_ip_v6();
    ip_v6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 4;
inline bool TNetAddr::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNetAddr::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNetAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNetAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TNetAddr::port() const {
  return port_;
}
inline void TNetAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TRpNetAddr

// repeated .mt.TNetAddr net_addr = 1;
inline int TRpNetAddr::net_addr_size() const {
  return net_addr_.size();
}
inline void TRpNetAddr::clear_net_addr() {
  net_addr_.Clear();
}
inline const ::mt::TNetAddr& TRpNetAddr::net_addr(int index) const {
  return net_addr_.Get(index);
}
inline ::mt::TNetAddr* TRpNetAddr::mutable_net_addr(int index) {
  return net_addr_.Mutable(index);
}
inline ::mt::TNetAddr* TRpNetAddr::add_net_addr() {
  return net_addr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TNetAddr >&
TRpNetAddr::net_addr() const {
  return net_addr_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TNetAddr >*
TRpNetAddr::mutable_net_addr() {
  return &net_addr_;
}

// -------------------------------------------------------------------

// TPrsParam

// optional bool enable = 1;
inline bool TPrsParam::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPrsParam::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPrsParam::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPrsParam::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TPrsParam::enable() const {
  return enable_;
}
inline void TPrsParam::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional uint32 first_time_span = 2 [default = 40];
inline bool TPrsParam::has_first_time_span() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TPrsParam::set_has_first_time_span() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TPrsParam::clear_has_first_time_span() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TPrsParam::clear_first_time_span() {
  first_time_span_ = 40u;
  clear_has_first_time_span();
}
inline ::google::protobuf::uint32 TPrsParam::first_time_span() const {
  return first_time_span_;
}
inline void TPrsParam::set_first_time_span(::google::protobuf::uint32 value) {
  set_has_first_time_span();
  first_time_span_ = value;
}

// optional uint32 second_time_span = 3 [default = 80];
inline bool TPrsParam::has_second_time_span() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TPrsParam::set_has_second_time_span() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TPrsParam::clear_has_second_time_span() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TPrsParam::clear_second_time_span() {
  second_time_span_ = 80u;
  clear_has_second_time_span();
}
inline ::google::protobuf::uint32 TPrsParam::second_time_span() const {
  return second_time_span_;
}
inline void TPrsParam::set_second_time_span(::google::protobuf::uint32 value) {
  set_has_second_time_span();
  second_time_span_ = value;
}

// optional uint32 third_time_span = 4 [default = 160];
inline bool TPrsParam::has_third_time_span() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TPrsParam::set_has_third_time_span() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TPrsParam::clear_has_third_time_span() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TPrsParam::clear_third_time_span() {
  third_time_span_ = 160u;
  clear_has_third_time_span();
}
inline ::google::protobuf::uint32 TPrsParam::third_time_span() const {
  return third_time_span_;
}
inline void TPrsParam::set_third_time_span(::google::protobuf::uint32 value) {
  set_has_third_time_span();
  third_time_span_ = value;
}

// optional uint32 reject_time_span = 5 [default = 200];
inline bool TPrsParam::has_reject_time_span() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TPrsParam::set_has_reject_time_span() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TPrsParam::clear_has_reject_time_span() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TPrsParam::clear_reject_time_span() {
  reject_time_span_ = 200u;
  clear_has_reject_time_span();
}
inline ::google::protobuf::uint32 TPrsParam::reject_time_span() const {
  return reject_time_span_;
}
inline void TPrsParam::set_reject_time_span(::google::protobuf::uint32 value) {
  set_has_reject_time_span();
  reject_time_span_ = value;
}

// optional uint32 send_buf_time_span = 6 [default = 1000];
inline bool TPrsParam::has_send_buf_time_span() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TPrsParam::set_has_send_buf_time_span() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TPrsParam::clear_has_send_buf_time_span() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TPrsParam::clear_send_buf_time_span() {
  send_buf_time_span_ = 1000u;
  clear_has_send_buf_time_span();
}
inline ::google::protobuf::uint32 TPrsParam::send_buf_time_span() const {
  return send_buf_time_span_;
}
inline void TPrsParam::set_send_buf_time_span(::google::protobuf::uint32 value) {
  set_has_send_buf_time_span();
  send_buf_time_span_ = value;
}

// optional bool bUseSmoothSend = 7;
inline bool TPrsParam::has_busesmoothsend() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TPrsParam::set_has_busesmoothsend() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TPrsParam::clear_has_busesmoothsend() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TPrsParam::clear_busesmoothsend() {
  busesmoothsend_ = false;
  clear_has_busesmoothsend();
}
inline bool TPrsParam::busesmoothsend() const {
  return busesmoothsend_;
}
inline void TPrsParam::set_busesmoothsend(bool value) {
  set_has_busesmoothsend();
  busesmoothsend_ = value;
}

// -------------------------------------------------------------------

// TEncryptKey

// optional bytes key = 1;
inline bool TEncryptKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TEncryptKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TEncryptKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TEncryptKey::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& TEncryptKey::key() const {
  return *key_;
}
inline void TEncryptKey::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TEncryptKey::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TEncryptKey::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TEncryptKey::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* TEncryptKey::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TEncryptKey::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTTime

// optional uint32 year = 1;
inline bool TMTTime::has_year() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTTime::set_has_year() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTTime::clear_has_year() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTTime::clear_year() {
  year_ = 0u;
  clear_has_year();
}
inline ::google::protobuf::uint32 TMTTime::year() const {
  return year_;
}
inline void TMTTime::set_year(::google::protobuf::uint32 value) {
  set_has_year();
  year_ = value;
}

// optional uint32 month = 2;
inline bool TMTTime::has_month() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTTime::set_has_month() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTTime::clear_has_month() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTTime::clear_month() {
  month_ = 0u;
  clear_has_month();
}
inline ::google::protobuf::uint32 TMTTime::month() const {
  return month_;
}
inline void TMTTime::set_month(::google::protobuf::uint32 value) {
  set_has_month();
  month_ = value;
}

// optional uint32 day = 3;
inline bool TMTTime::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTTime::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTTime::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTTime::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 TMTTime::day() const {
  return day_;
}
inline void TMTTime::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// optional uint32 hour = 4;
inline bool TMTTime::has_hour() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTTime::set_has_hour() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTTime::clear_has_hour() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTTime::clear_hour() {
  hour_ = 0u;
  clear_has_hour();
}
inline ::google::protobuf::uint32 TMTTime::hour() const {
  return hour_;
}
inline void TMTTime::set_hour(::google::protobuf::uint32 value) {
  set_has_hour();
  hour_ = value;
}

// optional uint32 minute = 5;
inline bool TMTTime::has_minute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTTime::set_has_minute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTTime::clear_has_minute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTTime::clear_minute() {
  minute_ = 0u;
  clear_has_minute();
}
inline ::google::protobuf::uint32 TMTTime::minute() const {
  return minute_;
}
inline void TMTTime::set_minute(::google::protobuf::uint32 value) {
  set_has_minute();
  minute_ = value;
}

// optional uint32 second = 6;
inline bool TMTTime::has_second() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTTime::set_has_second() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTTime::clear_has_second() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTTime::clear_second() {
  second_ = 0u;
  clear_has_second();
}
inline ::google::protobuf::uint32 TMTTime::second() const {
  return second_;
}
inline void TMTTime::set_second(::google::protobuf::uint32 value) {
  set_has_second();
  second_ = value;
}

// optional uint32 microsecond = 7;
inline bool TMTTime::has_microsecond() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTTime::set_has_microsecond() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTTime::clear_has_microsecond() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTTime::clear_microsecond() {
  microsecond_ = 0u;
  clear_has_microsecond();
}
inline ::google::protobuf::uint32 TMTTime::microsecond() const {
  return microsecond_;
}
inline void TMTTime::set_microsecond(::google::protobuf::uint32 value) {
  set_has_microsecond();
  microsecond_ = value;
}

// -------------------------------------------------------------------

// TSocks5Cfg

// optional .mt.TNetAddr server_ip = 1;
inline bool TSocks5Cfg::has_server_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSocks5Cfg::set_has_server_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSocks5Cfg::clear_has_server_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSocks5Cfg::clear_server_ip() {
  if (server_ip_ != NULL) server_ip_->::mt::TNetAddr::Clear();
  clear_has_server_ip();
}
inline const ::mt::TNetAddr& TSocks5Cfg::server_ip() const {
  return server_ip_ != NULL ? *server_ip_ : *default_instance_->server_ip_;
}
inline ::mt::TNetAddr* TSocks5Cfg::mutable_server_ip() {
  set_has_server_ip();
  if (server_ip_ == NULL) server_ip_ = new ::mt::TNetAddr;
  return server_ip_;
}
inline ::mt::TNetAddr* TSocks5Cfg::release_server_ip() {
  clear_has_server_ip();
  ::mt::TNetAddr* temp = server_ip_;
  server_ip_ = NULL;
  return temp;
}
inline void TSocks5Cfg::set_allocated_server_ip(::mt::TNetAddr* server_ip) {
  delete server_ip_;
  server_ip_ = server_ip;
  if (server_ip) {
    set_has_server_ip();
  } else {
    clear_has_server_ip();
  }
}

// optional string user_name = 2;
inline bool TSocks5Cfg::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TSocks5Cfg::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TSocks5Cfg::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TSocks5Cfg::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TSocks5Cfg::user_name() const {
  return *user_name_;
}
inline void TSocks5Cfg::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TSocks5Cfg::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TSocks5Cfg::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSocks5Cfg::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TSocks5Cfg::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSocks5Cfg::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pwd = 3;
inline bool TSocks5Cfg::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TSocks5Cfg::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TSocks5Cfg::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TSocks5Cfg::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& TSocks5Cfg::pwd() const {
  return *pwd_;
}
inline void TSocks5Cfg::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void TSocks5Cfg::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void TSocks5Cfg::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSocks5Cfg::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* TSocks5Cfg::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSocks5Cfg::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtAddr

// optional .mt.EmMtAddrType type = 1;
inline bool TMtAddr::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAddr::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAddr::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAddr::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmMtAddrType TMtAddr::type() const {
  return static_cast< ::mt::EmMtAddrType >(type_);
}
inline void TMtAddr::set_type(::mt::EmMtAddrType value) {
  assert(::mt::EmMtAddrType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mt.TNetAddr ip_addr = 2;
inline bool TMtAddr::has_ip_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAddr::set_has_ip_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAddr::clear_has_ip_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAddr::clear_ip_addr() {
  if (ip_addr_ != NULL) ip_addr_->::mt::TNetAddr::Clear();
  clear_has_ip_addr();
}
inline const ::mt::TNetAddr& TMtAddr::ip_addr() const {
  return ip_addr_ != NULL ? *ip_addr_ : *default_instance_->ip_addr_;
}
inline ::mt::TNetAddr* TMtAddr::mutable_ip_addr() {
  set_has_ip_addr();
  if (ip_addr_ == NULL) ip_addr_ = new ::mt::TNetAddr;
  return ip_addr_;
}
inline ::mt::TNetAddr* TMtAddr::release_ip_addr() {
  clear_has_ip_addr();
  ::mt::TNetAddr* temp = ip_addr_;
  ip_addr_ = NULL;
  return temp;
}
inline void TMtAddr::set_allocated_ip_addr(::mt::TNetAddr* ip_addr) {
  delete ip_addr_;
  ip_addr_ = ip_addr;
  if (ip_addr) {
    set_has_ip_addr();
  } else {
    clear_has_ip_addr();
  }
}

// optional string alias = 3;
inline bool TMtAddr::has_alias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtAddr::set_has_alias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtAddr::clear_has_alias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtAddr::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& TMtAddr::alias() const {
  return *alias_;
}
inline void TMtAddr::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMtAddr::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMtAddr::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtAddr::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* TMtAddr::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtAddr::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TRpMtAddr

// repeated .mt.TMtAddr mt_addr = 1;
inline int TRpMtAddr::mt_addr_size() const {
  return mt_addr_.size();
}
inline void TRpMtAddr::clear_mt_addr() {
  mt_addr_.Clear();
}
inline const ::mt::TMtAddr& TRpMtAddr::mt_addr(int index) const {
  return mt_addr_.Get(index);
}
inline ::mt::TMtAddr* TRpMtAddr::mutable_mt_addr(int index) {
  return mt_addr_.Mutable(index);
}
inline ::mt::TMtAddr* TRpMtAddr::add_mt_addr() {
  return mt_addr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAddr >&
TRpMtAddr::mt_addr() const {
  return mt_addr_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAddr >*
TRpMtAddr::mutable_mt_addr() {
  return &mt_addr_;
}

// -------------------------------------------------------------------

// TMtAlias

// optional .mt.EmMtAliasType type = 1;
inline bool TMtAlias::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAlias::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAlias::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAlias::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmMtAliasType TMtAlias::type() const {
  return static_cast< ::mt::EmMtAliasType >(type_);
}
inline void TMtAlias::set_type(::mt::EmMtAliasType value) {
  assert(::mt::EmMtAliasType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string alias = 2;
inline bool TMtAlias::has_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAlias::set_has_alias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAlias::clear_has_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAlias::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& TMtAlias::alias() const {
  return *alias_;
}
inline void TMtAlias::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMtAlias::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMtAlias::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtAlias::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* TMtAlias::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtAlias::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TRpMtAlias

// repeated .mt.TMtAlias alias = 1;
inline int TRpMtAlias::alias_size() const {
  return alias_.size();
}
inline void TRpMtAlias::clear_alias() {
  alias_.Clear();
}
inline const ::mt::TMtAlias& TRpMtAlias::alias(int index) const {
  return alias_.Get(index);
}
inline ::mt::TMtAlias* TRpMtAlias::mutable_alias(int index) {
  return alias_.Mutable(index);
}
inline ::mt::TMtAlias* TRpMtAlias::add_alias() {
  return alias_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAlias >&
TRpMtAlias::alias() const {
  return alias_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAlias >*
TRpMtAlias::mutable_alias() {
  return &alias_;
}

// -------------------------------------------------------------------

// TMtId

// optional uint32 mcu_id = 1;
inline bool TMtId::has_mcu_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtId::set_has_mcu_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtId::clear_has_mcu_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtId::clear_mcu_id() {
  mcu_id_ = 0u;
  clear_has_mcu_id();
}
inline ::google::protobuf::uint32 TMtId::mcu_id() const {
  return mcu_id_;
}
inline void TMtId::set_mcu_id(::google::protobuf::uint32 value) {
  set_has_mcu_id();
  mcu_id_ = value;
}

// optional uint32 ter_id = 2;
inline bool TMtId::has_ter_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtId::set_has_ter_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtId::clear_has_ter_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtId::clear_ter_id() {
  ter_id_ = 0u;
  clear_has_ter_id();
}
inline ::google::protobuf::uint32 TMtId::ter_id() const {
  return ter_id_;
}
inline void TMtId::set_ter_id(::google::protobuf::uint32 value) {
  set_has_ter_id();
  ter_id_ = value;
}

// -------------------------------------------------------------------

// TRpMtId

// repeated .mt.TMtId mt_id = 1;
inline int TRpMtId::mt_id_size() const {
  return mt_id_.size();
}
inline void TRpMtId::clear_mt_id() {
  mt_id_.Clear();
}
inline const ::mt::TMtId& TRpMtId::mt_id(int index) const {
  return mt_id_.Get(index);
}
inline ::mt::TMtId* TRpMtId::mutable_mt_id(int index) {
  return mt_id_.Mutable(index);
}
inline ::mt::TMtId* TRpMtId::add_mt_id() {
  return mt_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtId >&
TRpMtId::mt_id() const {
  return mt_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtId >*
TRpMtId::mutable_mt_id() {
  return &mt_id_;
}

// -------------------------------------------------------------------

// TMtLoc

// optional .mt.EmMtMediaDirection direct = 1;
inline bool TMtLoc::has_direct() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtLoc::set_has_direct() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtLoc::clear_has_direct() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtLoc::clear_direct() {
  direct_ = 0;
  clear_has_direct();
}
inline ::mt::EmMtMediaDirection TMtLoc::direct() const {
  return static_cast< ::mt::EmMtMediaDirection >(direct_);
}
inline void TMtLoc::set_direct(::mt::EmMtMediaDirection value) {
  assert(::mt::EmMtMediaDirection_IsValid(value));
  set_has_direct();
  direct_ = value;
}

// optional .mt.EmMtMediaType mediatype = 2;
inline bool TMtLoc::has_mediatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtLoc::set_has_mediatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtLoc::clear_has_mediatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtLoc::clear_mediatype() {
  mediatype_ = 0;
  clear_has_mediatype();
}
inline ::mt::EmMtMediaType TMtLoc::mediatype() const {
  return static_cast< ::mt::EmMtMediaType >(mediatype_);
}
inline void TMtLoc::set_mediatype(::mt::EmMtMediaType value) {
  assert(::mt::EmMtMediaType_IsValid(value));
  set_has_mediatype();
  mediatype_ = value;
}

// optional .mt.EmCodecComponentIndex stream_id = 3;
inline bool TMtLoc::has_stream_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtLoc::set_has_stream_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtLoc::clear_has_stream_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtLoc::clear_stream_id() {
  stream_id_ = 0;
  clear_has_stream_id();
}
inline ::mt::EmCodecComponentIndex TMtLoc::stream_id() const {
  return static_cast< ::mt::EmCodecComponentIndex >(stream_id_);
}
inline void TMtLoc::set_stream_id(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_stream_id();
  stream_id_ = value;
}

// optional string stream_alias = 4;
inline bool TMtLoc::has_stream_alias() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtLoc::set_has_stream_alias() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtLoc::clear_has_stream_alias() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtLoc::clear_stream_alias() {
  if (stream_alias_ != &::google::protobuf::internal::kEmptyString) {
    stream_alias_->clear();
  }
  clear_has_stream_alias();
}
inline const ::std::string& TMtLoc::stream_alias() const {
  return *stream_alias_;
}
inline void TMtLoc::set_stream_alias(const ::std::string& value) {
  set_has_stream_alias();
  if (stream_alias_ == &::google::protobuf::internal::kEmptyString) {
    stream_alias_ = new ::std::string;
  }
  stream_alias_->assign(value);
}
inline void TMtLoc::set_stream_alias(const char* value) {
  set_has_stream_alias();
  if (stream_alias_ == &::google::protobuf::internal::kEmptyString) {
    stream_alias_ = new ::std::string;
  }
  stream_alias_->assign(value);
}
inline void TMtLoc::set_stream_alias(const char* value, size_t size) {
  set_has_stream_alias();
  if (stream_alias_ == &::google::protobuf::internal::kEmptyString) {
    stream_alias_ = new ::std::string;
  }
  stream_alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtLoc::mutable_stream_alias() {
  set_has_stream_alias();
  if (stream_alias_ == &::google::protobuf::internal::kEmptyString) {
    stream_alias_ = new ::std::string;
  }
  return stream_alias_;
}
inline ::std::string* TMtLoc::release_stream_alias() {
  clear_has_stream_alias();
  if (stream_alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stream_alias_;
    stream_alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtLoc::set_allocated_stream_alias(::std::string* stream_alias) {
  if (stream_alias_ != &::google::protobuf::internal::kEmptyString) {
    delete stream_alias_;
  }
  if (stream_alias) {
    set_has_stream_alias();
    stream_alias_ = stream_alias;
  } else {
    clear_has_stream_alias();
    stream_alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TRpMtLoc

// repeated .mt.TMtLoc mt_loc = 1;
inline int TRpMtLoc::mt_loc_size() const {
  return mt_loc_.size();
}
inline void TRpMtLoc::clear_mt_loc() {
  mt_loc_.Clear();
}
inline const ::mt::TMtLoc& TRpMtLoc::mt_loc(int index) const {
  return mt_loc_.Get(index);
}
inline ::mt::TMtLoc* TRpMtLoc::mutable_mt_loc(int index) {
  return mt_loc_.Mutable(index);
}
inline ::mt::TMtLoc* TRpMtLoc::add_mt_loc() {
  return mt_loc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtLoc >&
TRpMtLoc::mt_loc() const {
  return mt_loc_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtLoc >*
TRpMtLoc::mutable_mt_loc() {
  return &mt_loc_;
}

// -------------------------------------------------------------------

// TMtInfo

// optional .mt.TMtId label = 1;
inline bool TMtInfo::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtInfo::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtInfo::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtInfo::clear_label() {
  if (label_ != NULL) label_->::mt::TMtId::Clear();
  clear_has_label();
}
inline const ::mt::TMtId& TMtInfo::label() const {
  return label_ != NULL ? *label_ : *default_instance_->label_;
}
inline ::mt::TMtId* TMtInfo::mutable_label() {
  set_has_label();
  if (label_ == NULL) label_ = new ::mt::TMtId;
  return label_;
}
inline ::mt::TMtId* TMtInfo::release_label() {
  clear_has_label();
  ::mt::TMtId* temp = label_;
  label_ = NULL;
  return temp;
}
inline void TMtInfo::set_allocated_label(::mt::TMtId* label) {
  delete label_;
  label_ = label;
  if (label) {
    set_has_label();
  } else {
    clear_has_label();
  }
}

// optional string alias = 2;
inline bool TMtInfo::has_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtInfo::set_has_alias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtInfo::clear_has_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtInfo::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& TMtInfo::alias() const {
  return *alias_;
}
inline void TMtInfo::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMtInfo::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMtInfo::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtInfo::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* TMtInfo::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtInfo::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 3;
inline bool TMtInfo::has_e164() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtInfo::set_has_e164() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtInfo::clear_has_e164() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtInfo::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMtInfo::e164() const {
  return *e164_;
}
inline void TMtInfo::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMtInfo::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMtInfo::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtInfo::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMtInfo::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtInfo::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtType type = 4;
inline bool TMtInfo::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtInfo::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmMtType TMtInfo::type() const {
  return static_cast< ::mt::EmMtType >(type_);
}
inline void TMtInfo::set_type(::mt::EmMtType value) {
  assert(::mt::EmMtType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bool is_only_aud = 5;
inline bool TMtInfo::has_is_only_aud() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtInfo::set_has_is_only_aud() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtInfo::clear_has_is_only_aud() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtInfo::clear_is_only_aud() {
  is_only_aud_ = false;
  clear_has_is_only_aud();
}
inline bool TMtInfo::is_only_aud() const {
  return is_only_aud_;
}
inline void TMtInfo::set_is_only_aud(bool value) {
  set_has_is_only_aud();
  is_only_aud_ = value;
}

// repeated .mt.TMtLoc mt_loc = 6;
inline int TMtInfo::mt_loc_size() const {
  return mt_loc_.size();
}
inline void TMtInfo::clear_mt_loc() {
  mt_loc_.Clear();
}
inline const ::mt::TMtLoc& TMtInfo::mt_loc(int index) const {
  return mt_loc_.Get(index);
}
inline ::mt::TMtLoc* TMtInfo::mutable_mt_loc(int index) {
  return mt_loc_.Mutable(index);
}
inline ::mt::TMtLoc* TMtInfo::add_mt_loc() {
  return mt_loc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtLoc >&
TMtInfo::mt_loc() const {
  return mt_loc_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtLoc >*
TMtInfo::mutable_mt_loc() {
  return &mt_loc_;
}

// -------------------------------------------------------------------

// TRpMtInfo

// repeated .mt.TMtInfo mt_info = 1;
inline int TRpMtInfo::mt_info_size() const {
  return mt_info_.size();
}
inline void TRpMtInfo::clear_mt_info() {
  mt_info_.Clear();
}
inline const ::mt::TMtInfo& TRpMtInfo::mt_info(int index) const {
  return mt_info_.Get(index);
}
inline ::mt::TMtInfo* TRpMtInfo::mutable_mt_info(int index) {
  return mt_info_.Mutable(index);
}
inline ::mt::TMtInfo* TRpMtInfo::add_mt_info() {
  return mt_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtInfo >&
TRpMtInfo::mt_info() const {
  return mt_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtInfo >*
TRpMtInfo::mutable_mt_info() {
  return &mt_info_;
}

// -------------------------------------------------------------------

// TH323Cfg

// optional string alias = 1;
inline bool TH323Cfg::has_alias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TH323Cfg::set_has_alias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TH323Cfg::clear_has_alias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TH323Cfg::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& TH323Cfg::alias() const {
  return *alias_;
}
inline void TH323Cfg::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TH323Cfg::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TH323Cfg::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TH323Cfg::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* TH323Cfg::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TH323Cfg::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 2;
inline bool TH323Cfg::has_e164() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TH323Cfg::set_has_e164() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TH323Cfg::clear_has_e164() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TH323Cfg::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TH323Cfg::e164() const {
  return *e164_;
}
inline void TH323Cfg::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TH323Cfg::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TH323Cfg::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TH323Cfg::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TH323Cfg::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TH323Cfg::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool buse_gk = 3;
inline bool TH323Cfg::has_buse_gk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TH323Cfg::set_has_buse_gk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TH323Cfg::clear_has_buse_gk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TH323Cfg::clear_buse_gk() {
  buse_gk_ = false;
  clear_has_buse_gk();
}
inline bool TH323Cfg::buse_gk() const {
  return buse_gk_;
}
inline void TH323Cfg::set_buse_gk(bool value) {
  set_has_buse_gk();
  buse_gk_ = value;
}

// optional string gk_pwd = 4;
inline bool TH323Cfg::has_gk_pwd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TH323Cfg::set_has_gk_pwd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TH323Cfg::clear_has_gk_pwd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TH323Cfg::clear_gk_pwd() {
  if (gk_pwd_ != &::google::protobuf::internal::kEmptyString) {
    gk_pwd_->clear();
  }
  clear_has_gk_pwd();
}
inline const ::std::string& TH323Cfg::gk_pwd() const {
  return *gk_pwd_;
}
inline void TH323Cfg::set_gk_pwd(const ::std::string& value) {
  set_has_gk_pwd();
  if (gk_pwd_ == &::google::protobuf::internal::kEmptyString) {
    gk_pwd_ = new ::std::string;
  }
  gk_pwd_->assign(value);
}
inline void TH323Cfg::set_gk_pwd(const char* value) {
  set_has_gk_pwd();
  if (gk_pwd_ == &::google::protobuf::internal::kEmptyString) {
    gk_pwd_ = new ::std::string;
  }
  gk_pwd_->assign(value);
}
inline void TH323Cfg::set_gk_pwd(const char* value, size_t size) {
  set_has_gk_pwd();
  if (gk_pwd_ == &::google::protobuf::internal::kEmptyString) {
    gk_pwd_ = new ::std::string;
  }
  gk_pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TH323Cfg::mutable_gk_pwd() {
  set_has_gk_pwd();
  if (gk_pwd_ == &::google::protobuf::internal::kEmptyString) {
    gk_pwd_ = new ::std::string;
  }
  return gk_pwd_;
}
inline ::std::string* TH323Cfg::release_gk_pwd() {
  clear_has_gk_pwd();
  if (gk_pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gk_pwd_;
    gk_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TH323Cfg::set_allocated_gk_pwd(::std::string* gk_pwd) {
  if (gk_pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete gk_pwd_;
  }
  if (gk_pwd) {
    set_has_gk_pwd();
    gk_pwd_ = gk_pwd;
  } else {
    clear_has_gk_pwd();
    gk_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gk_ip = 5;
inline bool TH323Cfg::has_gk_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TH323Cfg::set_has_gk_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TH323Cfg::clear_has_gk_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TH323Cfg::clear_gk_ip() {
  gk_ip_ = 0u;
  clear_has_gk_ip();
}
inline ::google::protobuf::uint32 TH323Cfg::gk_ip() const {
  return gk_ip_;
}
inline void TH323Cfg::set_gk_ip(::google::protobuf::uint32 value) {
  set_has_gk_ip();
  gk_ip_ = value;
}

// optional uint32 roundtrip_time = 7;
inline bool TH323Cfg::has_roundtrip_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TH323Cfg::set_has_roundtrip_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TH323Cfg::clear_has_roundtrip_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TH323Cfg::clear_roundtrip_time() {
  roundtrip_time_ = 0u;
  clear_has_roundtrip_time();
}
inline ::google::protobuf::uint32 TH323Cfg::roundtrip_time() const {
  return roundtrip_time_;
}
inline void TH323Cfg::set_roundtrip_time(::google::protobuf::uint32 value) {
  set_has_roundtrip_time();
  roundtrip_time_ = value;
}

// optional bool buse_h239 = 8;
inline bool TH323Cfg::has_buse_h239() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TH323Cfg::set_has_buse_h239() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TH323Cfg::clear_has_buse_h239() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TH323Cfg::clear_buse_h239() {
  buse_h239_ = false;
  clear_has_buse_h239();
}
inline bool TH323Cfg::buse_h239() const {
  return buse_h239_;
}
inline void TH323Cfg::set_buse_h239(bool value) {
  set_has_buse_h239();
  buse_h239_ = value;
}

// -------------------------------------------------------------------

// TSipCfg

// optional string password = 1;
inline bool TSipCfg::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSipCfg::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSipCfg::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSipCfg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TSipCfg::password() const {
  return *password_;
}
inline void TSipCfg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TSipCfg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TSipCfg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSipCfg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TSipCfg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSipCfg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host_domain = 2;
inline bool TSipCfg::has_host_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TSipCfg::set_has_host_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TSipCfg::clear_has_host_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TSipCfg::clear_host_domain() {
  if (host_domain_ != &::google::protobuf::internal::kEmptyString) {
    host_domain_->clear();
  }
  clear_has_host_domain();
}
inline const ::std::string& TSipCfg::host_domain() const {
  return *host_domain_;
}
inline void TSipCfg::set_host_domain(const ::std::string& value) {
  set_has_host_domain();
  if (host_domain_ == &::google::protobuf::internal::kEmptyString) {
    host_domain_ = new ::std::string;
  }
  host_domain_->assign(value);
}
inline void TSipCfg::set_host_domain(const char* value) {
  set_has_host_domain();
  if (host_domain_ == &::google::protobuf::internal::kEmptyString) {
    host_domain_ = new ::std::string;
  }
  host_domain_->assign(value);
}
inline void TSipCfg::set_host_domain(const char* value, size_t size) {
  set_has_host_domain();
  if (host_domain_ == &::google::protobuf::internal::kEmptyString) {
    host_domain_ = new ::std::string;
  }
  host_domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSipCfg::mutable_host_domain() {
  set_has_host_domain();
  if (host_domain_ == &::google::protobuf::internal::kEmptyString) {
    host_domain_ = new ::std::string;
  }
  return host_domain_;
}
inline ::std::string* TSipCfg::release_host_domain() {
  clear_has_host_domain();
  if (host_domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_domain_;
    host_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSipCfg::set_allocated_host_domain(::std::string* host_domain) {
  if (host_domain_ != &::google::protobuf::internal::kEmptyString) {
    delete host_domain_;
  }
  if (host_domain) {
    set_has_host_domain();
    host_domain_ = host_domain;
  } else {
    clear_has_host_domain();
    host_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 host_port = 3;
inline bool TSipCfg::has_host_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TSipCfg::set_has_host_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TSipCfg::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TSipCfg::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
inline ::google::protobuf::uint32 TSipCfg::host_port() const {
  return host_port_;
}
inline void TSipCfg::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
}

// optional bool buse_regserver = 4;
inline bool TSipCfg::has_buse_regserver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TSipCfg::set_has_buse_regserver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TSipCfg::clear_has_buse_regserver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TSipCfg::clear_buse_regserver() {
  buse_regserver_ = false;
  clear_has_buse_regserver();
}
inline bool TSipCfg::buse_regserver() const {
  return buse_regserver_;
}
inline void TSipCfg::set_buse_regserver(bool value) {
  set_has_buse_regserver();
  buse_regserver_ = value;
}

// optional uint32 regserver_ip = 5;
inline bool TSipCfg::has_regserver_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TSipCfg::set_has_regserver_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TSipCfg::clear_has_regserver_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TSipCfg::clear_regserver_ip() {
  regserver_ip_ = 0u;
  clear_has_regserver_ip();
}
inline ::google::protobuf::uint32 TSipCfg::regserver_ip() const {
  return regserver_ip_;
}
inline void TSipCfg::set_regserver_ip(::google::protobuf::uint32 value) {
  set_has_regserver_ip();
  regserver_ip_ = value;
}

// optional uint32 regserver_port = 6;
inline bool TSipCfg::has_regserver_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TSipCfg::set_has_regserver_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TSipCfg::clear_has_regserver_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TSipCfg::clear_regserver_port() {
  regserver_port_ = 0u;
  clear_has_regserver_port();
}
inline ::google::protobuf::uint32 TSipCfg::regserver_port() const {
  return regserver_port_;
}
inline void TSipCfg::set_regserver_port(::google::protobuf::uint32 value) {
  set_has_regserver_port();
  regserver_port_ = value;
}

// optional string regserver_domain = 7;
inline bool TSipCfg::has_regserver_domain() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TSipCfg::set_has_regserver_domain() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TSipCfg::clear_has_regserver_domain() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TSipCfg::clear_regserver_domain() {
  if (regserver_domain_ != &::google::protobuf::internal::kEmptyString) {
    regserver_domain_->clear();
  }
  clear_has_regserver_domain();
}
inline const ::std::string& TSipCfg::regserver_domain() const {
  return *regserver_domain_;
}
inline void TSipCfg::set_regserver_domain(const ::std::string& value) {
  set_has_regserver_domain();
  if (regserver_domain_ == &::google::protobuf::internal::kEmptyString) {
    regserver_domain_ = new ::std::string;
  }
  regserver_domain_->assign(value);
}
inline void TSipCfg::set_regserver_domain(const char* value) {
  set_has_regserver_domain();
  if (regserver_domain_ == &::google::protobuf::internal::kEmptyString) {
    regserver_domain_ = new ::std::string;
  }
  regserver_domain_->assign(value);
}
inline void TSipCfg::set_regserver_domain(const char* value, size_t size) {
  set_has_regserver_domain();
  if (regserver_domain_ == &::google::protobuf::internal::kEmptyString) {
    regserver_domain_ = new ::std::string;
  }
  regserver_domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSipCfg::mutable_regserver_domain() {
  set_has_regserver_domain();
  if (regserver_domain_ == &::google::protobuf::internal::kEmptyString) {
    regserver_domain_ = new ::std::string;
  }
  return regserver_domain_;
}
inline ::std::string* TSipCfg::release_regserver_domain() {
  clear_has_regserver_domain();
  if (regserver_domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = regserver_domain_;
    regserver_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSipCfg::set_allocated_regserver_domain(::std::string* regserver_domain) {
  if (regserver_domain_ != &::google::protobuf::internal::kEmptyString) {
    delete regserver_domain_;
  }
  if (regserver_domain) {
    set_has_regserver_domain();
    regserver_domain_ = regserver_domain;
  } else {
    clear_has_regserver_domain();
    regserver_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 expire = 8;
inline bool TSipCfg::has_expire() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TSipCfg::set_has_expire() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TSipCfg::clear_has_expire() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TSipCfg::clear_expire() {
  expire_ = 0u;
  clear_has_expire();
}
inline ::google::protobuf::uint32 TSipCfg::expire() const {
  return expire_;
}
inline void TSipCfg::set_expire(::google::protobuf::uint32 value) {
  set_has_expire();
  expire_ = value;
}

// optional bool buse_proxy = 9;
inline bool TSipCfg::has_buse_proxy() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TSipCfg::set_has_buse_proxy() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TSipCfg::clear_has_buse_proxy() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TSipCfg::clear_buse_proxy() {
  buse_proxy_ = false;
  clear_has_buse_proxy();
}
inline bool TSipCfg::buse_proxy() const {
  return buse_proxy_;
}
inline void TSipCfg::set_buse_proxy(bool value) {
  set_has_buse_proxy();
  buse_proxy_ = value;
}

// optional uint32 proxy_ip = 10;
inline bool TSipCfg::has_proxy_ip() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TSipCfg::set_has_proxy_ip() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TSipCfg::clear_has_proxy_ip() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TSipCfg::clear_proxy_ip() {
  proxy_ip_ = 0u;
  clear_has_proxy_ip();
}
inline ::google::protobuf::uint32 TSipCfg::proxy_ip() const {
  return proxy_ip_;
}
inline void TSipCfg::set_proxy_ip(::google::protobuf::uint32 value) {
  set_has_proxy_ip();
  proxy_ip_ = value;
}

// optional uint32 proxy_port = 11;
inline bool TSipCfg::has_proxy_port() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TSipCfg::set_has_proxy_port() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TSipCfg::clear_has_proxy_port() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TSipCfg::clear_proxy_port() {
  proxy_port_ = 0u;
  clear_has_proxy_port();
}
inline ::google::protobuf::uint32 TSipCfg::proxy_port() const {
  return proxy_port_;
}
inline void TSipCfg::set_proxy_port(::google::protobuf::uint32 value) {
  set_has_proxy_port();
  proxy_port_ = value;
}

// optional string proxy_domain = 12;
inline bool TSipCfg::has_proxy_domain() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TSipCfg::set_has_proxy_domain() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TSipCfg::clear_has_proxy_domain() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TSipCfg::clear_proxy_domain() {
  if (proxy_domain_ != &::google::protobuf::internal::kEmptyString) {
    proxy_domain_->clear();
  }
  clear_has_proxy_domain();
}
inline const ::std::string& TSipCfg::proxy_domain() const {
  return *proxy_domain_;
}
inline void TSipCfg::set_proxy_domain(const ::std::string& value) {
  set_has_proxy_domain();
  if (proxy_domain_ == &::google::protobuf::internal::kEmptyString) {
    proxy_domain_ = new ::std::string;
  }
  proxy_domain_->assign(value);
}
inline void TSipCfg::set_proxy_domain(const char* value) {
  set_has_proxy_domain();
  if (proxy_domain_ == &::google::protobuf::internal::kEmptyString) {
    proxy_domain_ = new ::std::string;
  }
  proxy_domain_->assign(value);
}
inline void TSipCfg::set_proxy_domain(const char* value, size_t size) {
  set_has_proxy_domain();
  if (proxy_domain_ == &::google::protobuf::internal::kEmptyString) {
    proxy_domain_ = new ::std::string;
  }
  proxy_domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSipCfg::mutable_proxy_domain() {
  set_has_proxy_domain();
  if (proxy_domain_ == &::google::protobuf::internal::kEmptyString) {
    proxy_domain_ = new ::std::string;
  }
  return proxy_domain_;
}
inline ::std::string* TSipCfg::release_proxy_domain() {
  clear_has_proxy_domain();
  if (proxy_domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proxy_domain_;
    proxy_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSipCfg::set_allocated_proxy_domain(::std::string* proxy_domain) {
  if (proxy_domain_ != &::google::protobuf::internal::kEmptyString) {
    delete proxy_domain_;
  }
  if (proxy_domain) {
    set_has_proxy_domain();
    proxy_domain_ = proxy_domain;
  } else {
    clear_has_proxy_domain();
    proxy_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTSrvInfo

// optional string name = 1;
inline bool TMTSrvInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTSrvInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTSrvInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTSrvInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTSrvInfo::name() const {
  return *name_;
}
inline void TMTSrvInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTSrvInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTSrvInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTSrvInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTSrvInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTSrvInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmServerType srvtype = 2;
inline bool TMTSrvInfo::has_srvtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTSrvInfo::set_has_srvtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTSrvInfo::clear_has_srvtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTSrvInfo::clear_srvtype() {
  srvtype_ = 0;
  clear_has_srvtype();
}
inline ::mt::EmServerType TMTSrvInfo::srvtype() const {
  return static_cast< ::mt::EmServerType >(srvtype_);
}
inline void TMTSrvInfo::set_srvtype(::mt::EmServerType value) {
  assert(::mt::EmServerType_IsValid(value));
  set_has_srvtype();
  srvtype_ = value;
}

// optional string domain = 3;
inline bool TMTSrvInfo::has_domain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTSrvInfo::set_has_domain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTSrvInfo::clear_has_domain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTSrvInfo::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMTSrvInfo::domain() const {
  return *domain_;
}
inline void TMTSrvInfo::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMTSrvInfo::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMTSrvInfo::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTSrvInfo::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMTSrvInfo::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTSrvInfo::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 4;
inline bool TMTSrvInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTSrvInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTSrvInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTSrvInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMTSrvInfo::ip() const {
  return ip_;
}
inline void TMTSrvInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional .mt.EmServerState state = 5;
inline bool TMTSrvInfo::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTSrvInfo::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTSrvInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTSrvInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::mt::EmServerState TMTSrvInfo::state() const {
  return static_cast< ::mt::EmServerState >(state_);
}
inline void TMTSrvInfo::set_state(::mt::EmServerState value) {
  assert(::mt::EmServerState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional bool used = 6;
inline bool TMTSrvInfo::has_used() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTSrvInfo::set_has_used() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTSrvInfo::clear_has_used() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTSrvInfo::clear_used() {
  used_ = false;
  clear_has_used();
}
inline bool TMTSrvInfo::used() const {
  return used_;
}
inline void TMTSrvInfo::set_used(bool value) {
  set_has_used();
  used_ = value;
}

// -------------------------------------------------------------------

// TMTSrvInfoList

// repeated .mt.TMTSrvInfo list = 1;
inline int TMTSrvInfoList::list_size() const {
  return list_.size();
}
inline void TMTSrvInfoList::clear_list() {
  list_.Clear();
}
inline const ::mt::TMTSrvInfo& TMTSrvInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::mt::TMTSrvInfo* TMTSrvInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::mt::TMTSrvInfo* TMTSrvInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTSrvInfo >&
TMTSrvInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTSrvInfo >*
TMTSrvInfoList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// TMTLocalParam

// optional string model = 1;
inline bool TMTLocalParam::has_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTLocalParam::set_has_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTLocalParam::clear_has_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTLocalParam::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& TMTLocalParam::model() const {
  return *model_;
}
inline void TMTLocalParam::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void TMTLocalParam::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void TMTLocalParam::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTLocalParam::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* TMTLocalParam::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTLocalParam::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TVrsLoginInfo

// optional uint32 ip = 1;
inline bool TVrsLoginInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVrsLoginInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVrsLoginInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVrsLoginInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TVrsLoginInfo::ip() const {
  return ip_;
}
inline void TVrsLoginInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 2;
inline bool TVrsLoginInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVrsLoginInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVrsLoginInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVrsLoginInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TVrsLoginInfo::port() const {
  return port_;
}
inline void TVrsLoginInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string username = 3;
inline bool TVrsLoginInfo::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVrsLoginInfo::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVrsLoginInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVrsLoginInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TVrsLoginInfo::username() const {
  return *username_;
}
inline void TVrsLoginInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TVrsLoginInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TVrsLoginInfo::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsLoginInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TVrsLoginInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsLoginInfo::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 4;
inline bool TVrsLoginInfo::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVrsLoginInfo::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVrsLoginInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVrsLoginInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TVrsLoginInfo::password() const {
  return *password_;
}
inline void TVrsLoginInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TVrsLoginInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TVrsLoginInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsLoginInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TVrsLoginInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsLoginInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TVrsGetPrgsReq

// optional uint32 folderid = 1;
inline bool TVrsGetPrgsReq::has_folderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVrsGetPrgsReq::set_has_folderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVrsGetPrgsReq::clear_has_folderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVrsGetPrgsReq::clear_folderid() {
  folderid_ = 0u;
  clear_has_folderid();
}
inline ::google::protobuf::uint32 TVrsGetPrgsReq::folderid() const {
  return folderid_;
}
inline void TVrsGetPrgsReq::set_folderid(::google::protobuf::uint32 value) {
  set_has_folderid();
  folderid_ = value;
}

// optional uint32 prgs1page = 2;
inline bool TVrsGetPrgsReq::has_prgs1page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVrsGetPrgsReq::set_has_prgs1page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVrsGetPrgsReq::clear_has_prgs1page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVrsGetPrgsReq::clear_prgs1page() {
  prgs1page_ = 0u;
  clear_has_prgs1page();
}
inline ::google::protobuf::uint32 TVrsGetPrgsReq::prgs1page() const {
  return prgs1page_;
}
inline void TVrsGetPrgsReq::set_prgs1page(::google::protobuf::uint32 value) {
  set_has_prgs1page();
  prgs1page_ = value;
}

// optional uint32 pageid = 3;
inline bool TVrsGetPrgsReq::has_pageid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVrsGetPrgsReq::set_has_pageid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVrsGetPrgsReq::clear_has_pageid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVrsGetPrgsReq::clear_pageid() {
  pageid_ = 0u;
  clear_has_pageid();
}
inline ::google::protobuf::uint32 TVrsGetPrgsReq::pageid() const {
  return pageid_;
}
inline void TVrsGetPrgsReq::set_pageid(::google::protobuf::uint32 value) {
  set_has_pageid();
  pageid_ = value;
}

// optional string includename = 4;
inline bool TVrsGetPrgsReq::has_includename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVrsGetPrgsReq::set_has_includename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVrsGetPrgsReq::clear_has_includename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVrsGetPrgsReq::clear_includename() {
  if (includename_ != &::google::protobuf::internal::kEmptyString) {
    includename_->clear();
  }
  clear_has_includename();
}
inline const ::std::string& TVrsGetPrgsReq::includename() const {
  return *includename_;
}
inline void TVrsGetPrgsReq::set_includename(const ::std::string& value) {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  includename_->assign(value);
}
inline void TVrsGetPrgsReq::set_includename(const char* value) {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  includename_->assign(value);
}
inline void TVrsGetPrgsReq::set_includename(const char* value, size_t size) {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  includename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsGetPrgsReq::mutable_includename() {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  return includename_;
}
inline ::std::string* TVrsGetPrgsReq::release_includename() {
  clear_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = includename_;
    includename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsGetPrgsReq::set_allocated_includename(::std::string* includename) {
  if (includename_ != &::google::protobuf::internal::kEmptyString) {
    delete includename_;
  }
  if (includename) {
    set_has_includename();
    includename_ = includename;
  } else {
    clear_has_includename();
    includename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 prgtypemask = 5;
inline bool TVrsGetPrgsReq::has_prgtypemask() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVrsGetPrgsReq::set_has_prgtypemask() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVrsGetPrgsReq::clear_has_prgtypemask() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVrsGetPrgsReq::clear_prgtypemask() {
  prgtypemask_ = 0u;
  clear_has_prgtypemask();
}
inline ::google::protobuf::uint32 TVrsGetPrgsReq::prgtypemask() const {
  return prgtypemask_;
}
inline void TVrsGetPrgsReq::set_prgtypemask(::google::protobuf::uint32 value) {
  set_has_prgtypemask();
  prgtypemask_ = value;
}

// optional uint32 starttime = 6;
inline bool TVrsGetPrgsReq::has_starttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVrsGetPrgsReq::set_has_starttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVrsGetPrgsReq::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVrsGetPrgsReq::clear_starttime() {
  starttime_ = 0u;
  clear_has_starttime();
}
inline ::google::protobuf::uint32 TVrsGetPrgsReq::starttime() const {
  return starttime_;
}
inline void TVrsGetPrgsReq::set_starttime(::google::protobuf::uint32 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional uint32 endtime = 7;
inline bool TVrsGetPrgsReq::has_endtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVrsGetPrgsReq::set_has_endtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVrsGetPrgsReq::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVrsGetPrgsReq::clear_endtime() {
  endtime_ = 0u;
  clear_has_endtime();
}
inline ::google::protobuf::uint32 TVrsGetPrgsReq::endtime() const {
  return endtime_;
}
inline void TVrsGetPrgsReq::set_endtime(::google::protobuf::uint32 value) {
  set_has_endtime();
  endtime_ = value;
}

// -------------------------------------------------------------------

// TVrsFolderInfo

// optional uint32 folderid = 1;
inline bool TVrsFolderInfo::has_folderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVrsFolderInfo::set_has_folderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVrsFolderInfo::clear_has_folderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVrsFolderInfo::clear_folderid() {
  folderid_ = 0u;
  clear_has_folderid();
}
inline ::google::protobuf::uint32 TVrsFolderInfo::folderid() const {
  return folderid_;
}
inline void TVrsFolderInfo::set_folderid(::google::protobuf::uint32 value) {
  set_has_folderid();
  folderid_ = value;
}

// optional string foldername = 2;
inline bool TVrsFolderInfo::has_foldername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVrsFolderInfo::set_has_foldername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVrsFolderInfo::clear_has_foldername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVrsFolderInfo::clear_foldername() {
  if (foldername_ != &::google::protobuf::internal::kEmptyString) {
    foldername_->clear();
  }
  clear_has_foldername();
}
inline const ::std::string& TVrsFolderInfo::foldername() const {
  return *foldername_;
}
inline void TVrsFolderInfo::set_foldername(const ::std::string& value) {
  set_has_foldername();
  if (foldername_ == &::google::protobuf::internal::kEmptyString) {
    foldername_ = new ::std::string;
  }
  foldername_->assign(value);
}
inline void TVrsFolderInfo::set_foldername(const char* value) {
  set_has_foldername();
  if (foldername_ == &::google::protobuf::internal::kEmptyString) {
    foldername_ = new ::std::string;
  }
  foldername_->assign(value);
}
inline void TVrsFolderInfo::set_foldername(const char* value, size_t size) {
  set_has_foldername();
  if (foldername_ == &::google::protobuf::internal::kEmptyString) {
    foldername_ = new ::std::string;
  }
  foldername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsFolderInfo::mutable_foldername() {
  set_has_foldername();
  if (foldername_ == &::google::protobuf::internal::kEmptyString) {
    foldername_ = new ::std::string;
  }
  return foldername_;
}
inline ::std::string* TVrsFolderInfo::release_foldername() {
  clear_has_foldername();
  if (foldername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = foldername_;
    foldername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsFolderInfo::set_allocated_foldername(::std::string* foldername) {
  if (foldername_ != &::google::protobuf::internal::kEmptyString) {
    delete foldername_;
  }
  if (foldername) {
    set_has_foldername();
    foldername_ = foldername;
  } else {
    clear_has_foldername();
    foldername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 prgcount = 3;
inline bool TVrsFolderInfo::has_prgcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVrsFolderInfo::set_has_prgcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVrsFolderInfo::clear_has_prgcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVrsFolderInfo::clear_prgcount() {
  prgcount_ = 0u;
  clear_has_prgcount();
}
inline ::google::protobuf::uint32 TVrsFolderInfo::prgcount() const {
  return prgcount_;
}
inline void TVrsFolderInfo::set_prgcount(::google::protobuf::uint32 value) {
  set_has_prgcount();
  prgcount_ = value;
}

// -------------------------------------------------------------------

// TVrsFoldersInfo

// repeated .mt.TVrsFolderInfo folderinfo = 1;
inline int TVrsFoldersInfo::folderinfo_size() const {
  return folderinfo_.size();
}
inline void TVrsFoldersInfo::clear_folderinfo() {
  folderinfo_.Clear();
}
inline const ::mt::TVrsFolderInfo& TVrsFoldersInfo::folderinfo(int index) const {
  return folderinfo_.Get(index);
}
inline ::mt::TVrsFolderInfo* TVrsFoldersInfo::mutable_folderinfo(int index) {
  return folderinfo_.Mutable(index);
}
inline ::mt::TVrsFolderInfo* TVrsFoldersInfo::add_folderinfo() {
  return folderinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsFolderInfo >&
TVrsFoldersInfo::folderinfo() const {
  return folderinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsFolderInfo >*
TVrsFoldersInfo::mutable_folderinfo() {
  return &folderinfo_;
}

// -------------------------------------------------------------------

// TVrsPrgDetailInfo

// optional uint32 ip = 1;
inline bool TVrsPrgDetailInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVrsPrgDetailInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVrsPrgDetailInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVrsPrgDetailInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TVrsPrgDetailInfo::ip() const {
  return ip_;
}
inline void TVrsPrgDetailInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 prgduration = 2;
inline bool TVrsPrgDetailInfo::has_prgduration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVrsPrgDetailInfo::set_has_prgduration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVrsPrgDetailInfo::clear_has_prgduration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVrsPrgDetailInfo::clear_prgduration() {
  prgduration_ = 0u;
  clear_has_prgduration();
}
inline ::google::protobuf::uint32 TVrsPrgDetailInfo::prgduration() const {
  return prgduration_;
}
inline void TVrsPrgDetailInfo::set_prgduration(::google::protobuf::uint32 value) {
  set_has_prgduration();
  prgduration_ = value;
}

// optional uint32 prgindex = 3;
inline bool TVrsPrgDetailInfo::has_prgindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVrsPrgDetailInfo::set_has_prgindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVrsPrgDetailInfo::clear_has_prgindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVrsPrgDetailInfo::clear_prgindex() {
  prgindex_ = 0u;
  clear_has_prgindex();
}
inline ::google::protobuf::uint32 TVrsPrgDetailInfo::prgindex() const {
  return prgindex_;
}
inline void TVrsPrgDetailInfo::set_prgindex(::google::protobuf::uint32 value) {
  set_has_prgindex();
  prgindex_ = value;
}

// optional uint32 prggid = 4;
inline bool TVrsPrgDetailInfo::has_prggid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVrsPrgDetailInfo::set_has_prggid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVrsPrgDetailInfo::clear_has_prggid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVrsPrgDetailInfo::clear_prggid() {
  prggid_ = 0u;
  clear_has_prggid();
}
inline ::google::protobuf::uint32 TVrsPrgDetailInfo::prggid() const {
  return prggid_;
}
inline void TVrsPrgDetailInfo::set_prggid(::google::protobuf::uint32 value) {
  set_has_prggid();
  prggid_ = value;
}

// optional string prgname = 5;
inline bool TVrsPrgDetailInfo::has_prgname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVrsPrgDetailInfo::set_has_prgname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVrsPrgDetailInfo::clear_has_prgname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVrsPrgDetailInfo::clear_prgname() {
  if (prgname_ != &::google::protobuf::internal::kEmptyString) {
    prgname_->clear();
  }
  clear_has_prgname();
}
inline const ::std::string& TVrsPrgDetailInfo::prgname() const {
  return *prgname_;
}
inline void TVrsPrgDetailInfo::set_prgname(const ::std::string& value) {
  set_has_prgname();
  if (prgname_ == &::google::protobuf::internal::kEmptyString) {
    prgname_ = new ::std::string;
  }
  prgname_->assign(value);
}
inline void TVrsPrgDetailInfo::set_prgname(const char* value) {
  set_has_prgname();
  if (prgname_ == &::google::protobuf::internal::kEmptyString) {
    prgname_ = new ::std::string;
  }
  prgname_->assign(value);
}
inline void TVrsPrgDetailInfo::set_prgname(const char* value, size_t size) {
  set_has_prgname();
  if (prgname_ == &::google::protobuf::internal::kEmptyString) {
    prgname_ = new ::std::string;
  }
  prgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsPrgDetailInfo::mutable_prgname() {
  set_has_prgname();
  if (prgname_ == &::google::protobuf::internal::kEmptyString) {
    prgname_ = new ::std::string;
  }
  return prgname_;
}
inline ::std::string* TVrsPrgDetailInfo::release_prgname() {
  clear_has_prgname();
  if (prgname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prgname_;
    prgname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsPrgDetailInfo::set_allocated_prgname(::std::string* prgname) {
  if (prgname_ != &::google::protobuf::internal::kEmptyString) {
    delete prgname_;
  }
  if (prgname) {
    set_has_prgname();
    prgname_ = prgname;
  } else {
    clear_has_prgname();
    prgname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 prgsize = 6;
inline bool TVrsPrgDetailInfo::has_prgsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVrsPrgDetailInfo::set_has_prgsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVrsPrgDetailInfo::clear_has_prgsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVrsPrgDetailInfo::clear_prgsize() {
  prgsize_ = 0u;
  clear_has_prgsize();
}
inline ::google::protobuf::uint32 TVrsPrgDetailInfo::prgsize() const {
  return prgsize_;
}
inline void TVrsPrgDetailInfo::set_prgsize(::google::protobuf::uint32 value) {
  set_has_prgsize();
  prgsize_ = value;
}

// optional string prgtype = 7;
inline bool TVrsPrgDetailInfo::has_prgtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVrsPrgDetailInfo::set_has_prgtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVrsPrgDetailInfo::clear_has_prgtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVrsPrgDetailInfo::clear_prgtype() {
  if (prgtype_ != &::google::protobuf::internal::kEmptyString) {
    prgtype_->clear();
  }
  clear_has_prgtype();
}
inline const ::std::string& TVrsPrgDetailInfo::prgtype() const {
  return *prgtype_;
}
inline void TVrsPrgDetailInfo::set_prgtype(const ::std::string& value) {
  set_has_prgtype();
  if (prgtype_ == &::google::protobuf::internal::kEmptyString) {
    prgtype_ = new ::std::string;
  }
  prgtype_->assign(value);
}
inline void TVrsPrgDetailInfo::set_prgtype(const char* value) {
  set_has_prgtype();
  if (prgtype_ == &::google::protobuf::internal::kEmptyString) {
    prgtype_ = new ::std::string;
  }
  prgtype_->assign(value);
}
inline void TVrsPrgDetailInfo::set_prgtype(const char* value, size_t size) {
  set_has_prgtype();
  if (prgtype_ == &::google::protobuf::internal::kEmptyString) {
    prgtype_ = new ::std::string;
  }
  prgtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsPrgDetailInfo::mutable_prgtype() {
  set_has_prgtype();
  if (prgtype_ == &::google::protobuf::internal::kEmptyString) {
    prgtype_ = new ::std::string;
  }
  return prgtype_;
}
inline ::std::string* TVrsPrgDetailInfo::release_prgtype() {
  clear_has_prgtype();
  if (prgtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prgtype_;
    prgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsPrgDetailInfo::set_allocated_prgtype(::std::string* prgtype) {
  if (prgtype_ != &::google::protobuf::internal::kEmptyString) {
    delete prgtype_;
  }
  if (prgtype) {
    set_has_prgtype();
    prgtype_ = prgtype;
  } else {
    clear_has_prgtype();
    prgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 8;
inline bool TVrsPrgDetailInfo::has_path() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TVrsPrgDetailInfo::set_has_path() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TVrsPrgDetailInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TVrsPrgDetailInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TVrsPrgDetailInfo::path() const {
  return *path_;
}
inline void TVrsPrgDetailInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TVrsPrgDetailInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TVrsPrgDetailInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsPrgDetailInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TVrsPrgDetailInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsPrgDetailInfo::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 prginfoindex = 9;
inline bool TVrsPrgDetailInfo::has_prginfoindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TVrsPrgDetailInfo::set_has_prginfoindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TVrsPrgDetailInfo::clear_has_prginfoindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TVrsPrgDetailInfo::clear_prginfoindex() {
  prginfoindex_ = 0u;
  clear_has_prginfoindex();
}
inline ::google::protobuf::uint32 TVrsPrgDetailInfo::prginfoindex() const {
  return prginfoindex_;
}
inline void TVrsPrgDetailInfo::set_prginfoindex(::google::protobuf::uint32 value) {
  set_has_prginfoindex();
  prginfoindex_ = value;
}

// -------------------------------------------------------------------

// TVrsPrgsDetailInfo

// repeated .mt.TVrsPrgDetailInfo prgdetail = 1;
inline int TVrsPrgsDetailInfo::prgdetail_size() const {
  return prgdetail_.size();
}
inline void TVrsPrgsDetailInfo::clear_prgdetail() {
  prgdetail_.Clear();
}
inline const ::mt::TVrsPrgDetailInfo& TVrsPrgsDetailInfo::prgdetail(int index) const {
  return prgdetail_.Get(index);
}
inline ::mt::TVrsPrgDetailInfo* TVrsPrgsDetailInfo::mutable_prgdetail(int index) {
  return prgdetail_.Mutable(index);
}
inline ::mt::TVrsPrgDetailInfo* TVrsPrgsDetailInfo::add_prgdetail() {
  return prgdetail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsPrgDetailInfo >&
TVrsPrgsDetailInfo::prgdetail() const {
  return prgdetail_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsPrgDetailInfo >*
TVrsPrgsDetailInfo::mutable_prgdetail() {
  return &prgdetail_;
}

// -------------------------------------------------------------------

// TVrsPrgBaseInfo

// optional uint32 createtime = 1;
inline bool TVrsPrgBaseInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVrsPrgBaseInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVrsPrgBaseInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVrsPrgBaseInfo::clear_createtime() {
  createtime_ = 0u;
  clear_has_createtime();
}
inline ::google::protobuf::uint32 TVrsPrgBaseInfo::createtime() const {
  return createtime_;
}
inline void TVrsPrgBaseInfo::set_createtime(::google::protobuf::uint32 value) {
  set_has_createtime();
  createtime_ = value;
}

// optional uint32 issuetime = 2;
inline bool TVrsPrgBaseInfo::has_issuetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVrsPrgBaseInfo::set_has_issuetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVrsPrgBaseInfo::clear_has_issuetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVrsPrgBaseInfo::clear_issuetime() {
  issuetime_ = 0u;
  clear_has_issuetime();
}
inline ::google::protobuf::uint32 TVrsPrgBaseInfo::issuetime() const {
  return issuetime_;
}
inline void TVrsPrgBaseInfo::set_issuetime(::google::protobuf::uint32 value) {
  set_has_issuetime();
  issuetime_ = value;
}

// optional string prgalias = 3;
inline bool TVrsPrgBaseInfo::has_prgalias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVrsPrgBaseInfo::set_has_prgalias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVrsPrgBaseInfo::clear_has_prgalias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVrsPrgBaseInfo::clear_prgalias() {
  if (prgalias_ != &::google::protobuf::internal::kEmptyString) {
    prgalias_->clear();
  }
  clear_has_prgalias();
}
inline const ::std::string& TVrsPrgBaseInfo::prgalias() const {
  return *prgalias_;
}
inline void TVrsPrgBaseInfo::set_prgalias(const ::std::string& value) {
  set_has_prgalias();
  if (prgalias_ == &::google::protobuf::internal::kEmptyString) {
    prgalias_ = new ::std::string;
  }
  prgalias_->assign(value);
}
inline void TVrsPrgBaseInfo::set_prgalias(const char* value) {
  set_has_prgalias();
  if (prgalias_ == &::google::protobuf::internal::kEmptyString) {
    prgalias_ = new ::std::string;
  }
  prgalias_->assign(value);
}
inline void TVrsPrgBaseInfo::set_prgalias(const char* value, size_t size) {
  set_has_prgalias();
  if (prgalias_ == &::google::protobuf::internal::kEmptyString) {
    prgalias_ = new ::std::string;
  }
  prgalias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsPrgBaseInfo::mutable_prgalias() {
  set_has_prgalias();
  if (prgalias_ == &::google::protobuf::internal::kEmptyString) {
    prgalias_ = new ::std::string;
  }
  return prgalias_;
}
inline ::std::string* TVrsPrgBaseInfo::release_prgalias() {
  clear_has_prgalias();
  if (prgalias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prgalias_;
    prgalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsPrgBaseInfo::set_allocated_prgalias(::std::string* prgalias) {
  if (prgalias_ != &::google::protobuf::internal::kEmptyString) {
    delete prgalias_;
  }
  if (prgalias) {
    set_has_prgalias();
    prgalias_ = prgalias;
  } else {
    clear_has_prgalias();
    prgalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 prgallduration = 4;
inline bool TVrsPrgBaseInfo::has_prgallduration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVrsPrgBaseInfo::set_has_prgallduration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVrsPrgBaseInfo::clear_has_prgallduration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVrsPrgBaseInfo::clear_prgallduration() {
  prgallduration_ = 0u;
  clear_has_prgallduration();
}
inline ::google::protobuf::uint32 TVrsPrgBaseInfo::prgallduration() const {
  return prgallduration_;
}
inline void TVrsPrgBaseInfo::set_prgallduration(::google::protobuf::uint32 value) {
  set_has_prgallduration();
  prgallduration_ = value;
}

// optional uint32 prgallsize = 5;
inline bool TVrsPrgBaseInfo::has_prgallsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVrsPrgBaseInfo::set_has_prgallsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVrsPrgBaseInfo::clear_has_prgallsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVrsPrgBaseInfo::clear_prgallsize() {
  prgallsize_ = 0u;
  clear_has_prgallsize();
}
inline ::google::protobuf::uint32 TVrsPrgBaseInfo::prgallsize() const {
  return prgallsize_;
}
inline void TVrsPrgBaseInfo::set_prgallsize(::google::protobuf::uint32 value) {
  set_has_prgallsize();
  prgallsize_ = value;
}

// optional string prgdesc = 6;
inline bool TVrsPrgBaseInfo::has_prgdesc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVrsPrgBaseInfo::set_has_prgdesc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVrsPrgBaseInfo::clear_has_prgdesc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVrsPrgBaseInfo::clear_prgdesc() {
  if (prgdesc_ != &::google::protobuf::internal::kEmptyString) {
    prgdesc_->clear();
  }
  clear_has_prgdesc();
}
inline const ::std::string& TVrsPrgBaseInfo::prgdesc() const {
  return *prgdesc_;
}
inline void TVrsPrgBaseInfo::set_prgdesc(const ::std::string& value) {
  set_has_prgdesc();
  if (prgdesc_ == &::google::protobuf::internal::kEmptyString) {
    prgdesc_ = new ::std::string;
  }
  prgdesc_->assign(value);
}
inline void TVrsPrgBaseInfo::set_prgdesc(const char* value) {
  set_has_prgdesc();
  if (prgdesc_ == &::google::protobuf::internal::kEmptyString) {
    prgdesc_ = new ::std::string;
  }
  prgdesc_->assign(value);
}
inline void TVrsPrgBaseInfo::set_prgdesc(const char* value, size_t size) {
  set_has_prgdesc();
  if (prgdesc_ == &::google::protobuf::internal::kEmptyString) {
    prgdesc_ = new ::std::string;
  }
  prgdesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsPrgBaseInfo::mutable_prgdesc() {
  set_has_prgdesc();
  if (prgdesc_ == &::google::protobuf::internal::kEmptyString) {
    prgdesc_ = new ::std::string;
  }
  return prgdesc_;
}
inline ::std::string* TVrsPrgBaseInfo::release_prgdesc() {
  clear_has_prgdesc();
  if (prgdesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prgdesc_;
    prgdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsPrgBaseInfo::set_allocated_prgdesc(::std::string* prgdesc) {
  if (prgdesc_ != &::google::protobuf::internal::kEmptyString) {
    delete prgdesc_;
  }
  if (prgdesc) {
    set_has_prgdesc();
    prgdesc_ = prgdesc;
  } else {
    clear_has_prgdesc();
    prgdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 prggid = 7;
inline bool TVrsPrgBaseInfo::has_prggid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVrsPrgBaseInfo::set_has_prggid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVrsPrgBaseInfo::clear_has_prggid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVrsPrgBaseInfo::clear_prggid() {
  prggid_ = 0u;
  clear_has_prggid();
}
inline ::google::protobuf::uint32 TVrsPrgBaseInfo::prggid() const {
  return prggid_;
}
inline void TVrsPrgBaseInfo::set_prggid(::google::protobuf::uint32 value) {
  set_has_prggid();
  prggid_ = value;
}

// optional uint32 prgstate = 8;
inline bool TVrsPrgBaseInfo::has_prgstate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TVrsPrgBaseInfo::set_has_prgstate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TVrsPrgBaseInfo::clear_has_prgstate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TVrsPrgBaseInfo::clear_prgstate() {
  prgstate_ = 0u;
  clear_has_prgstate();
}
inline ::google::protobuf::uint32 TVrsPrgBaseInfo::prgstate() const {
  return prgstate_;
}
inline void TVrsPrgBaseInfo::set_prgstate(::google::protobuf::uint32 value) {
  set_has_prgstate();
  prgstate_ = value;
}

// optional string streamjsonpath = 9;
inline bool TVrsPrgBaseInfo::has_streamjsonpath() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TVrsPrgBaseInfo::set_has_streamjsonpath() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TVrsPrgBaseInfo::clear_has_streamjsonpath() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TVrsPrgBaseInfo::clear_streamjsonpath() {
  if (streamjsonpath_ != &::google::protobuf::internal::kEmptyString) {
    streamjsonpath_->clear();
  }
  clear_has_streamjsonpath();
}
inline const ::std::string& TVrsPrgBaseInfo::streamjsonpath() const {
  return *streamjsonpath_;
}
inline void TVrsPrgBaseInfo::set_streamjsonpath(const ::std::string& value) {
  set_has_streamjsonpath();
  if (streamjsonpath_ == &::google::protobuf::internal::kEmptyString) {
    streamjsonpath_ = new ::std::string;
  }
  streamjsonpath_->assign(value);
}
inline void TVrsPrgBaseInfo::set_streamjsonpath(const char* value) {
  set_has_streamjsonpath();
  if (streamjsonpath_ == &::google::protobuf::internal::kEmptyString) {
    streamjsonpath_ = new ::std::string;
  }
  streamjsonpath_->assign(value);
}
inline void TVrsPrgBaseInfo::set_streamjsonpath(const char* value, size_t size) {
  set_has_streamjsonpath();
  if (streamjsonpath_ == &::google::protobuf::internal::kEmptyString) {
    streamjsonpath_ = new ::std::string;
  }
  streamjsonpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsPrgBaseInfo::mutable_streamjsonpath() {
  set_has_streamjsonpath();
  if (streamjsonpath_ == &::google::protobuf::internal::kEmptyString) {
    streamjsonpath_ = new ::std::string;
  }
  return streamjsonpath_;
}
inline ::std::string* TVrsPrgBaseInfo::release_streamjsonpath() {
  clear_has_streamjsonpath();
  if (streamjsonpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = streamjsonpath_;
    streamjsonpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsPrgBaseInfo::set_allocated_streamjsonpath(::std::string* streamjsonpath) {
  if (streamjsonpath_ != &::google::protobuf::internal::kEmptyString) {
    delete streamjsonpath_;
  }
  if (streamjsonpath) {
    set_has_streamjsonpath();
    streamjsonpath_ = streamjsonpath;
  } else {
    clear_has_streamjsonpath();
    streamjsonpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TVrsPrgsBaseInfo

// repeated .mt.TVrsPrgBaseInfo prgbase = 1;
inline int TVrsPrgsBaseInfo::prgbase_size() const {
  return prgbase_.size();
}
inline void TVrsPrgsBaseInfo::clear_prgbase() {
  prgbase_.Clear();
}
inline const ::mt::TVrsPrgBaseInfo& TVrsPrgsBaseInfo::prgbase(int index) const {
  return prgbase_.Get(index);
}
inline ::mt::TVrsPrgBaseInfo* TVrsPrgsBaseInfo::mutable_prgbase(int index) {
  return prgbase_.Mutable(index);
}
inline ::mt::TVrsPrgBaseInfo* TVrsPrgsBaseInfo::add_prgbase() {
  return prgbase_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsPrgBaseInfo >&
TVrsPrgsBaseInfo::prgbase() const {
  return prgbase_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsPrgBaseInfo >*
TVrsPrgsBaseInfo::mutable_prgbase() {
  return &prgbase_;
}

// -------------------------------------------------------------------

// TVrsRoomState

// optional uint32 elapse = 1;
inline bool TVrsRoomState::has_elapse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVrsRoomState::set_has_elapse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVrsRoomState::clear_has_elapse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVrsRoomState::clear_elapse() {
  elapse_ = 0u;
  clear_has_elapse();
}
inline ::google::protobuf::uint32 TVrsRoomState::elapse() const {
  return elapse_;
}
inline void TVrsRoomState::set_elapse(::google::protobuf::uint32 value) {
  set_has_elapse();
  elapse_ = value;
}

// optional string lcastpoint = 2;
inline bool TVrsRoomState::has_lcastpoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVrsRoomState::set_has_lcastpoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVrsRoomState::clear_has_lcastpoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVrsRoomState::clear_lcastpoint() {
  if (lcastpoint_ != &::google::protobuf::internal::kEmptyString) {
    lcastpoint_->clear();
  }
  clear_has_lcastpoint();
}
inline const ::std::string& TVrsRoomState::lcastpoint() const {
  return *lcastpoint_;
}
inline void TVrsRoomState::set_lcastpoint(const ::std::string& value) {
  set_has_lcastpoint();
  if (lcastpoint_ == &::google::protobuf::internal::kEmptyString) {
    lcastpoint_ = new ::std::string;
  }
  lcastpoint_->assign(value);
}
inline void TVrsRoomState::set_lcastpoint(const char* value) {
  set_has_lcastpoint();
  if (lcastpoint_ == &::google::protobuf::internal::kEmptyString) {
    lcastpoint_ = new ::std::string;
  }
  lcastpoint_->assign(value);
}
inline void TVrsRoomState::set_lcastpoint(const char* value, size_t size) {
  set_has_lcastpoint();
  if (lcastpoint_ == &::google::protobuf::internal::kEmptyString) {
    lcastpoint_ = new ::std::string;
  }
  lcastpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsRoomState::mutable_lcastpoint() {
  set_has_lcastpoint();
  if (lcastpoint_ == &::google::protobuf::internal::kEmptyString) {
    lcastpoint_ = new ::std::string;
  }
  return lcastpoint_;
}
inline ::std::string* TVrsRoomState::release_lcastpoint() {
  clear_has_lcastpoint();
  if (lcastpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lcastpoint_;
    lcastpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsRoomState::set_allocated_lcastpoint(::std::string* lcastpoint) {
  if (lcastpoint_ != &::google::protobuf::internal::kEmptyString) {
    delete lcastpoint_;
  }
  if (lcastpoint) {
    set_has_lcastpoint();
    lcastpoint_ = lcastpoint;
  } else {
    clear_has_lcastpoint();
    lcastpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 prgid = 3;
inline bool TVrsRoomState::has_prgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVrsRoomState::set_has_prgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVrsRoomState::clear_has_prgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVrsRoomState::clear_prgid() {
  prgid_ = 0u;
  clear_has_prgid();
}
inline ::google::protobuf::uint32 TVrsRoomState::prgid() const {
  return prgid_;
}
inline void TVrsRoomState::set_prgid(::google::protobuf::uint32 value) {
  set_has_prgid();
  prgid_ = value;
}

// optional uint32 roomid = 4;
inline bool TVrsRoomState::has_roomid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVrsRoomState::set_has_roomid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVrsRoomState::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVrsRoomState::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 TVrsRoomState::roomid() const {
  return roomid_;
}
inline void TVrsRoomState::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional string roomname = 5;
inline bool TVrsRoomState::has_roomname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVrsRoomState::set_has_roomname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVrsRoomState::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVrsRoomState::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& TVrsRoomState::roomname() const {
  return *roomname_;
}
inline void TVrsRoomState::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void TVrsRoomState::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void TVrsRoomState::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsRoomState::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  return roomname_;
}
inline ::std::string* TVrsRoomState::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsRoomState::set_allocated_roomname(::std::string* roomname) {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    delete roomname_;
  }
  if (roomname) {
    set_has_roomname();
    roomname_ = roomname;
  } else {
    clear_has_roomname();
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 usrgrpid = 6;
inline bool TVrsRoomState::has_usrgrpid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVrsRoomState::set_has_usrgrpid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVrsRoomState::clear_has_usrgrpid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVrsRoomState::clear_usrgrpid() {
  usrgrpid_ = 0u;
  clear_has_usrgrpid();
}
inline ::google::protobuf::uint32 TVrsRoomState::usrgrpid() const {
  return usrgrpid_;
}
inline void TVrsRoomState::set_usrgrpid(::google::protobuf::uint32 value) {
  set_has_usrgrpid();
  usrgrpid_ = value;
}

// optional uint32 livetime = 7;
inline bool TVrsRoomState::has_livetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVrsRoomState::set_has_livetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVrsRoomState::clear_has_livetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVrsRoomState::clear_livetime() {
  livetime_ = 0u;
  clear_has_livetime();
}
inline ::google::protobuf::uint32 TVrsRoomState::livetime() const {
  return livetime_;
}
inline void TVrsRoomState::set_livetime(::google::protobuf::uint32 value) {
  set_has_livetime();
  livetime_ = value;
}

// optional string livestreampath = 8;
inline bool TVrsRoomState::has_livestreampath() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TVrsRoomState::set_has_livestreampath() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TVrsRoomState::clear_has_livestreampath() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TVrsRoomState::clear_livestreampath() {
  if (livestreampath_ != &::google::protobuf::internal::kEmptyString) {
    livestreampath_->clear();
  }
  clear_has_livestreampath();
}
inline const ::std::string& TVrsRoomState::livestreampath() const {
  return *livestreampath_;
}
inline void TVrsRoomState::set_livestreampath(const ::std::string& value) {
  set_has_livestreampath();
  if (livestreampath_ == &::google::protobuf::internal::kEmptyString) {
    livestreampath_ = new ::std::string;
  }
  livestreampath_->assign(value);
}
inline void TVrsRoomState::set_livestreampath(const char* value) {
  set_has_livestreampath();
  if (livestreampath_ == &::google::protobuf::internal::kEmptyString) {
    livestreampath_ = new ::std::string;
  }
  livestreampath_->assign(value);
}
inline void TVrsRoomState::set_livestreampath(const char* value, size_t size) {
  set_has_livestreampath();
  if (livestreampath_ == &::google::protobuf::internal::kEmptyString) {
    livestreampath_ = new ::std::string;
  }
  livestreampath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsRoomState::mutable_livestreampath() {
  set_has_livestreampath();
  if (livestreampath_ == &::google::protobuf::internal::kEmptyString) {
    livestreampath_ = new ::std::string;
  }
  return livestreampath_;
}
inline ::std::string* TVrsRoomState::release_livestreampath() {
  clear_has_livestreampath();
  if (livestreampath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = livestreampath_;
    livestreampath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsRoomState::set_allocated_livestreampath(::std::string* livestreampath) {
  if (livestreampath_ != &::google::protobuf::internal::kEmptyString) {
    delete livestreampath_;
  }
  if (livestreampath) {
    set_has_livestreampath();
    livestreampath_ = livestreampath;
  } else {
    clear_has_livestreampath();
    livestreampath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string roomidstr = 9;
inline bool TVrsRoomState::has_roomidstr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TVrsRoomState::set_has_roomidstr() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TVrsRoomState::clear_has_roomidstr() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TVrsRoomState::clear_roomidstr() {
  if (roomidstr_ != &::google::protobuf::internal::kEmptyString) {
    roomidstr_->clear();
  }
  clear_has_roomidstr();
}
inline const ::std::string& TVrsRoomState::roomidstr() const {
  return *roomidstr_;
}
inline void TVrsRoomState::set_roomidstr(const ::std::string& value) {
  set_has_roomidstr();
  if (roomidstr_ == &::google::protobuf::internal::kEmptyString) {
    roomidstr_ = new ::std::string;
  }
  roomidstr_->assign(value);
}
inline void TVrsRoomState::set_roomidstr(const char* value) {
  set_has_roomidstr();
  if (roomidstr_ == &::google::protobuf::internal::kEmptyString) {
    roomidstr_ = new ::std::string;
  }
  roomidstr_->assign(value);
}
inline void TVrsRoomState::set_roomidstr(const char* value, size_t size) {
  set_has_roomidstr();
  if (roomidstr_ == &::google::protobuf::internal::kEmptyString) {
    roomidstr_ = new ::std::string;
  }
  roomidstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsRoomState::mutable_roomidstr() {
  set_has_roomidstr();
  if (roomidstr_ == &::google::protobuf::internal::kEmptyString) {
    roomidstr_ = new ::std::string;
  }
  return roomidstr_;
}
inline ::std::string* TVrsRoomState::release_roomidstr() {
  clear_has_roomidstr();
  if (roomidstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomidstr_;
    roomidstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsRoomState::set_allocated_roomidstr(::std::string* roomidstr) {
  if (roomidstr_ != &::google::protobuf::internal::kEmptyString) {
    delete roomidstr_;
  }
  if (roomidstr) {
    set_has_roomidstr();
    roomidstr_ = roomidstr;
  } else {
    clear_has_roomidstr();
    roomidstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string shorturl = 10;
inline bool TVrsRoomState::has_shorturl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TVrsRoomState::set_has_shorturl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TVrsRoomState::clear_has_shorturl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TVrsRoomState::clear_shorturl() {
  if (shorturl_ != &::google::protobuf::internal::kEmptyString) {
    shorturl_->clear();
  }
  clear_has_shorturl();
}
inline const ::std::string& TVrsRoomState::shorturl() const {
  return *shorturl_;
}
inline void TVrsRoomState::set_shorturl(const ::std::string& value) {
  set_has_shorturl();
  if (shorturl_ == &::google::protobuf::internal::kEmptyString) {
    shorturl_ = new ::std::string;
  }
  shorturl_->assign(value);
}
inline void TVrsRoomState::set_shorturl(const char* value) {
  set_has_shorturl();
  if (shorturl_ == &::google::protobuf::internal::kEmptyString) {
    shorturl_ = new ::std::string;
  }
  shorturl_->assign(value);
}
inline void TVrsRoomState::set_shorturl(const char* value, size_t size) {
  set_has_shorturl();
  if (shorturl_ == &::google::protobuf::internal::kEmptyString) {
    shorturl_ = new ::std::string;
  }
  shorturl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsRoomState::mutable_shorturl() {
  set_has_shorturl();
  if (shorturl_ == &::google::protobuf::internal::kEmptyString) {
    shorturl_ = new ::std::string;
  }
  return shorturl_;
}
inline ::std::string* TVrsRoomState::release_shorturl() {
  clear_has_shorturl();
  if (shorturl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shorturl_;
    shorturl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsRoomState::set_allocated_shorturl(::std::string* shorturl) {
  if (shorturl_ != &::google::protobuf::internal::kEmptyString) {
    delete shorturl_;
  }
  if (shorturl) {
    set_has_shorturl();
    shorturl_ = shorturl;
  } else {
    clear_has_shorturl();
    shorturl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TVrsRoomsState

// repeated .mt.TVrsRoomState roomstate = 1;
inline int TVrsRoomsState::roomstate_size() const {
  return roomstate_.size();
}
inline void TVrsRoomsState::clear_roomstate() {
  roomstate_.Clear();
}
inline const ::mt::TVrsRoomState& TVrsRoomsState::roomstate(int index) const {
  return roomstate_.Get(index);
}
inline ::mt::TVrsRoomState* TVrsRoomsState::mutable_roomstate(int index) {
  return roomstate_.Mutable(index);
}
inline ::mt::TVrsRoomState* TVrsRoomsState::add_roomstate() {
  return roomstate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsRoomState >&
TVrsRoomsState::roomstate() const {
  return roomstate_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsRoomState >*
TVrsRoomsState::mutable_roomstate() {
  return &roomstate_;
}

// -------------------------------------------------------------------

// TVrsRoomCfg

// optional string confname = 1;
inline bool TVrsRoomCfg::has_confname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVrsRoomCfg::set_has_confname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVrsRoomCfg::clear_has_confname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVrsRoomCfg::clear_confname() {
  if (confname_ != &::google::protobuf::internal::kEmptyString) {
    confname_->clear();
  }
  clear_has_confname();
}
inline const ::std::string& TVrsRoomCfg::confname() const {
  return *confname_;
}
inline void TVrsRoomCfg::set_confname(const ::std::string& value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
}
inline void TVrsRoomCfg::set_confname(const char* value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
}
inline void TVrsRoomCfg::set_confname(const char* value, size_t size) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  confname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsRoomCfg::mutable_confname() {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    confname_ = new ::std::string;
  }
  return confname_;
}
inline ::std::string* TVrsRoomCfg::release_confname() {
  clear_has_confname();
  if (confname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = confname_;
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsRoomCfg::set_allocated_confname(::std::string* confname) {
  if (confname_ != &::google::protobuf::internal::kEmptyString) {
    delete confname_;
  }
  if (confname) {
    set_has_confname();
    confname_ = confname;
  } else {
    clear_has_confname();
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string starttime = 2;
inline bool TVrsRoomCfg::has_starttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVrsRoomCfg::set_has_starttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVrsRoomCfg::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVrsRoomCfg::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& TVrsRoomCfg::starttime() const {
  return *starttime_;
}
inline void TVrsRoomCfg::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TVrsRoomCfg::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void TVrsRoomCfg::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsRoomCfg::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* TVrsRoomCfg::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsRoomCfg::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TVrsRoomsCfg

// repeated .mt.TVrsRoomCfg roomcfg = 1;
inline int TVrsRoomsCfg::roomcfg_size() const {
  return roomcfg_.size();
}
inline void TVrsRoomsCfg::clear_roomcfg() {
  roomcfg_.Clear();
}
inline const ::mt::TVrsRoomCfg& TVrsRoomsCfg::roomcfg(int index) const {
  return roomcfg_.Get(index);
}
inline ::mt::TVrsRoomCfg* TVrsRoomsCfg::mutable_roomcfg(int index) {
  return roomcfg_.Mutable(index);
}
inline ::mt::TVrsRoomCfg* TVrsRoomsCfg::add_roomcfg() {
  return roomcfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsRoomCfg >&
TVrsRoomsCfg::roomcfg() const {
  return roomcfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsRoomCfg >*
TVrsRoomsCfg::mutable_roomcfg() {
  return &roomcfg_;
}

// -------------------------------------------------------------------

// TSubsMsgID

// repeated string msgid = 1;
inline int TSubsMsgID::msgid_size() const {
  return msgid_.size();
}
inline void TSubsMsgID::clear_msgid() {
  msgid_.Clear();
}
inline const ::std::string& TSubsMsgID::msgid(int index) const {
  return msgid_.Get(index);
}
inline ::std::string* TSubsMsgID::mutable_msgid(int index) {
  return msgid_.Mutable(index);
}
inline void TSubsMsgID::set_msgid(int index, const ::std::string& value) {
  msgid_.Mutable(index)->assign(value);
}
inline void TSubsMsgID::set_msgid(int index, const char* value) {
  msgid_.Mutable(index)->assign(value);
}
inline void TSubsMsgID::set_msgid(int index, const char* value, size_t size) {
  msgid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSubsMsgID::add_msgid() {
  return msgid_.Add();
}
inline void TSubsMsgID::add_msgid(const ::std::string& value) {
  msgid_.Add()->assign(value);
}
inline void TSubsMsgID::add_msgid(const char* value) {
  msgid_.Add()->assign(value);
}
inline void TSubsMsgID::add_msgid(const char* value, size_t size) {
  msgid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TSubsMsgID::msgid() const {
  return msgid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TSubsMsgID::mutable_msgid() {
  return &msgid_;
}

// -------------------------------------------------------------------

// TVrsSearchFilesReq

// optional uint32 folderid = 1;
inline bool TVrsSearchFilesReq::has_folderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVrsSearchFilesReq::set_has_folderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVrsSearchFilesReq::clear_has_folderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVrsSearchFilesReq::clear_folderid() {
  folderid_ = 0u;
  clear_has_folderid();
}
inline ::google::protobuf::uint32 TVrsSearchFilesReq::folderid() const {
  return folderid_;
}
inline void TVrsSearchFilesReq::set_folderid(::google::protobuf::uint32 value) {
  set_has_folderid();
  folderid_ = value;
}

// optional uint32 prgs1page = 2;
inline bool TVrsSearchFilesReq::has_prgs1page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVrsSearchFilesReq::set_has_prgs1page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVrsSearchFilesReq::clear_has_prgs1page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVrsSearchFilesReq::clear_prgs1page() {
  prgs1page_ = 0u;
  clear_has_prgs1page();
}
inline ::google::protobuf::uint32 TVrsSearchFilesReq::prgs1page() const {
  return prgs1page_;
}
inline void TVrsSearchFilesReq::set_prgs1page(::google::protobuf::uint32 value) {
  set_has_prgs1page();
  prgs1page_ = value;
}

// optional uint32 pageid = 3;
inline bool TVrsSearchFilesReq::has_pageid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVrsSearchFilesReq::set_has_pageid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVrsSearchFilesReq::clear_has_pageid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVrsSearchFilesReq::clear_pageid() {
  pageid_ = 0u;
  clear_has_pageid();
}
inline ::google::protobuf::uint32 TVrsSearchFilesReq::pageid() const {
  return pageid_;
}
inline void TVrsSearchFilesReq::set_pageid(::google::protobuf::uint32 value) {
  set_has_pageid();
  pageid_ = value;
}

// optional string includename = 5;
inline bool TVrsSearchFilesReq::has_includename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVrsSearchFilesReq::set_has_includename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVrsSearchFilesReq::clear_has_includename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVrsSearchFilesReq::clear_includename() {
  if (includename_ != &::google::protobuf::internal::kEmptyString) {
    includename_->clear();
  }
  clear_has_includename();
}
inline const ::std::string& TVrsSearchFilesReq::includename() const {
  return *includename_;
}
inline void TVrsSearchFilesReq::set_includename(const ::std::string& value) {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  includename_->assign(value);
}
inline void TVrsSearchFilesReq::set_includename(const char* value) {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  includename_->assign(value);
}
inline void TVrsSearchFilesReq::set_includename(const char* value, size_t size) {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  includename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsSearchFilesReq::mutable_includename() {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  return includename_;
}
inline ::std::string* TVrsSearchFilesReq::release_includename() {
  clear_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = includename_;
    includename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsSearchFilesReq::set_allocated_includename(::std::string* includename) {
  if (includename_ != &::google::protobuf::internal::kEmptyString) {
    delete includename_;
  }
  if (includename) {
    set_has_includename();
    includename_ = includename;
  } else {
    clear_has_includename();
    includename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TVrsGetReserveRoomListReq

// optional uint32 nums1page = 1;
inline bool TVrsGetReserveRoomListReq::has_nums1page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVrsGetReserveRoomListReq::set_has_nums1page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVrsGetReserveRoomListReq::clear_has_nums1page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVrsGetReserveRoomListReq::clear_nums1page() {
  nums1page_ = 0u;
  clear_has_nums1page();
}
inline ::google::protobuf::uint32 TVrsGetReserveRoomListReq::nums1page() const {
  return nums1page_;
}
inline void TVrsGetReserveRoomListReq::set_nums1page(::google::protobuf::uint32 value) {
  set_has_nums1page();
  nums1page_ = value;
}

// optional uint32 pageid = 2;
inline bool TVrsGetReserveRoomListReq::has_pageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVrsGetReserveRoomListReq::set_has_pageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVrsGetReserveRoomListReq::clear_has_pageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVrsGetReserveRoomListReq::clear_pageid() {
  pageid_ = 0u;
  clear_has_pageid();
}
inline ::google::protobuf::uint32 TVrsGetReserveRoomListReq::pageid() const {
  return pageid_;
}
inline void TVrsGetReserveRoomListReq::set_pageid(::google::protobuf::uint32 value) {
  set_has_pageid();
  pageid_ = value;
}

// optional string includename = 3;
inline bool TVrsGetReserveRoomListReq::has_includename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVrsGetReserveRoomListReq::set_has_includename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVrsGetReserveRoomListReq::clear_has_includename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVrsGetReserveRoomListReq::clear_includename() {
  if (includename_ != &::google::protobuf::internal::kEmptyString) {
    includename_->clear();
  }
  clear_has_includename();
}
inline const ::std::string& TVrsGetReserveRoomListReq::includename() const {
  return *includename_;
}
inline void TVrsGetReserveRoomListReq::set_includename(const ::std::string& value) {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  includename_->assign(value);
}
inline void TVrsGetReserveRoomListReq::set_includename(const char* value) {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  includename_->assign(value);
}
inline void TVrsGetReserveRoomListReq::set_includename(const char* value, size_t size) {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  includename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsGetReserveRoomListReq::mutable_includename() {
  set_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    includename_ = new ::std::string;
  }
  return includename_;
}
inline ::std::string* TVrsGetReserveRoomListReq::release_includename() {
  clear_has_includename();
  if (includename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = includename_;
    includename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsGetReserveRoomListReq::set_allocated_includename(::std::string* includename) {
  if (includename_ != &::google::protobuf::internal::kEmptyString) {
    delete includename_;
  }
  if (includename) {
    set_has_includename();
    includename_ = includename;
  } else {
    clear_has_includename();
    includename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TVrsOldRoomCfg

// optional uint32 ip = 1;
inline bool TVrsOldRoomCfg::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVrsOldRoomCfg::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVrsOldRoomCfg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVrsOldRoomCfg::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TVrsOldRoomCfg::ip() const {
  return ip_;
}
inline void TVrsOldRoomCfg::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional string path = 2;
inline bool TVrsOldRoomCfg::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVrsOldRoomCfg::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVrsOldRoomCfg::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVrsOldRoomCfg::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TVrsOldRoomCfg::path() const {
  return *path_;
}
inline void TVrsOldRoomCfg::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TVrsOldRoomCfg::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TVrsOldRoomCfg::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsOldRoomCfg::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TVrsOldRoomCfg::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsOldRoomCfg::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string prgalias = 3;
inline bool TVrsOldRoomCfg::has_prgalias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVrsOldRoomCfg::set_has_prgalias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVrsOldRoomCfg::clear_has_prgalias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVrsOldRoomCfg::clear_prgalias() {
  if (prgalias_ != &::google::protobuf::internal::kEmptyString) {
    prgalias_->clear();
  }
  clear_has_prgalias();
}
inline const ::std::string& TVrsOldRoomCfg::prgalias() const {
  return *prgalias_;
}
inline void TVrsOldRoomCfg::set_prgalias(const ::std::string& value) {
  set_has_prgalias();
  if (prgalias_ == &::google::protobuf::internal::kEmptyString) {
    prgalias_ = new ::std::string;
  }
  prgalias_->assign(value);
}
inline void TVrsOldRoomCfg::set_prgalias(const char* value) {
  set_has_prgalias();
  if (prgalias_ == &::google::protobuf::internal::kEmptyString) {
    prgalias_ = new ::std::string;
  }
  prgalias_->assign(value);
}
inline void TVrsOldRoomCfg::set_prgalias(const char* value, size_t size) {
  set_has_prgalias();
  if (prgalias_ == &::google::protobuf::internal::kEmptyString) {
    prgalias_ = new ::std::string;
  }
  prgalias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsOldRoomCfg::mutable_prgalias() {
  set_has_prgalias();
  if (prgalias_ == &::google::protobuf::internal::kEmptyString) {
    prgalias_ = new ::std::string;
  }
  return prgalias_;
}
inline ::std::string* TVrsOldRoomCfg::release_prgalias() {
  clear_has_prgalias();
  if (prgalias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prgalias_;
    prgalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsOldRoomCfg::set_allocated_prgalias(::std::string* prgalias) {
  if (prgalias_ != &::google::protobuf::internal::kEmptyString) {
    delete prgalias_;
  }
  if (prgalias) {
    set_has_prgalias();
    prgalias_ = prgalias;
  } else {
    clear_has_prgalias();
    prgalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 prgid = 4;
inline bool TVrsOldRoomCfg::has_prgid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVrsOldRoomCfg::set_has_prgid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVrsOldRoomCfg::clear_has_prgid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVrsOldRoomCfg::clear_prgid() {
  prgid_ = 0u;
  clear_has_prgid();
}
inline ::google::protobuf::uint32 TVrsOldRoomCfg::prgid() const {
  return prgid_;
}
inline void TVrsOldRoomCfg::set_prgid(::google::protobuf::uint32 value) {
  set_has_prgid();
  prgid_ = value;
}

// optional string prgname = 5;
inline bool TVrsOldRoomCfg::has_prgname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVrsOldRoomCfg::set_has_prgname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVrsOldRoomCfg::clear_has_prgname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVrsOldRoomCfg::clear_prgname() {
  if (prgname_ != &::google::protobuf::internal::kEmptyString) {
    prgname_->clear();
  }
  clear_has_prgname();
}
inline const ::std::string& TVrsOldRoomCfg::prgname() const {
  return *prgname_;
}
inline void TVrsOldRoomCfg::set_prgname(const ::std::string& value) {
  set_has_prgname();
  if (prgname_ == &::google::protobuf::internal::kEmptyString) {
    prgname_ = new ::std::string;
  }
  prgname_->assign(value);
}
inline void TVrsOldRoomCfg::set_prgname(const char* value) {
  set_has_prgname();
  if (prgname_ == &::google::protobuf::internal::kEmptyString) {
    prgname_ = new ::std::string;
  }
  prgname_->assign(value);
}
inline void TVrsOldRoomCfg::set_prgname(const char* value, size_t size) {
  set_has_prgname();
  if (prgname_ == &::google::protobuf::internal::kEmptyString) {
    prgname_ = new ::std::string;
  }
  prgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVrsOldRoomCfg::mutable_prgname() {
  set_has_prgname();
  if (prgname_ == &::google::protobuf::internal::kEmptyString) {
    prgname_ = new ::std::string;
  }
  return prgname_;
}
inline ::std::string* TVrsOldRoomCfg::release_prgname() {
  clear_has_prgname();
  if (prgname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prgname_;
    prgname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVrsOldRoomCfg::set_allocated_prgname(::std::string* prgname) {
  if (prgname_ != &::google::protobuf::internal::kEmptyString) {
    delete prgname_;
  }
  if (prgname) {
    set_has_prgname();
    prgname_ = prgname;
  } else {
    clear_has_prgname();
    prgname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 restime = 6;
inline bool TVrsOldRoomCfg::has_restime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVrsOldRoomCfg::set_has_restime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVrsOldRoomCfg::clear_has_restime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVrsOldRoomCfg::clear_restime() {
  restime_ = 0u;
  clear_has_restime();
}
inline ::google::protobuf::uint32 TVrsOldRoomCfg::restime() const {
  return restime_;
}
inline void TVrsOldRoomCfg::set_restime(::google::protobuf::uint32 value) {
  set_has_restime();
  restime_ = value;
}

// optional uint32 roomid = 7;
inline bool TVrsOldRoomCfg::has_roomid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVrsOldRoomCfg::set_has_roomid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVrsOldRoomCfg::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVrsOldRoomCfg::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 TVrsOldRoomCfg::roomid() const {
  return roomid_;
}
inline void TVrsOldRoomCfg::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional uint32 usrgrpid = 8;
inline bool TVrsOldRoomCfg::has_usrgrpid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TVrsOldRoomCfg::set_has_usrgrpid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TVrsOldRoomCfg::clear_has_usrgrpid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TVrsOldRoomCfg::clear_usrgrpid() {
  usrgrpid_ = 0u;
  clear_has_usrgrpid();
}
inline ::google::protobuf::uint32 TVrsOldRoomCfg::usrgrpid() const {
  return usrgrpid_;
}
inline void TVrsOldRoomCfg::set_usrgrpid(::google::protobuf::uint32 value) {
  set_has_usrgrpid();
  usrgrpid_ = value;
}

// -------------------------------------------------------------------

// TVrsOldRoomsCfg

// repeated .mt.TVrsOldRoomCfg roomcfg = 1;
inline int TVrsOldRoomsCfg::roomcfg_size() const {
  return roomcfg_.size();
}
inline void TVrsOldRoomsCfg::clear_roomcfg() {
  roomcfg_.Clear();
}
inline const ::mt::TVrsOldRoomCfg& TVrsOldRoomsCfg::roomcfg(int index) const {
  return roomcfg_.Get(index);
}
inline ::mt::TVrsOldRoomCfg* TVrsOldRoomsCfg::mutable_roomcfg(int index) {
  return roomcfg_.Mutable(index);
}
inline ::mt::TVrsOldRoomCfg* TVrsOldRoomsCfg::add_roomcfg() {
  return roomcfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVrsOldRoomCfg >&
TVrsOldRoomsCfg::roomcfg() const {
  return roomcfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVrsOldRoomCfg >*
TVrsOldRoomsCfg::mutable_roomcfg() {
  return &roomcfg_;
}

// -------------------------------------------------------------------

// TMTOrder

// optional int32 count = 1;
inline bool TMTOrder::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTOrder::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTOrder::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTOrder::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 TMTOrder::count() const {
  return count_;
}
inline void TMTOrder::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional bytes order = 2;
inline bool TMTOrder::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTOrder::set_has_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTOrder::clear_has_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTOrder::clear_order() {
  if (order_ != &::google::protobuf::internal::kEmptyString) {
    order_->clear();
  }
  clear_has_order();
}
inline const ::std::string& TMTOrder::order() const {
  return *order_;
}
inline void TMTOrder::set_order(const ::std::string& value) {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  order_->assign(value);
}
inline void TMTOrder::set_order(const char* value) {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  order_->assign(value);
}
inline void TMTOrder::set_order(const void* value, size_t size) {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  order_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTOrder::mutable_order() {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  return order_;
}
inline ::std::string* TMTOrder::release_order() {
  clear_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_;
    order_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTOrder::set_allocated_order(::std::string* order) {
  if (order_ != &::google::protobuf::internal::kEmptyString) {
    delete order_;
  }
  if (order) {
    set_has_order();
    order_ = order;
  } else {
    clear_has_order();
    order_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TGmTestResult

// optional .mt.EmEncryptArithmetic emEncrypt = 1;
inline bool TGmTestResult::has_emencrypt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGmTestResult::set_has_emencrypt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGmTestResult::clear_has_emencrypt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGmTestResult::clear_emencrypt() {
  emencrypt_ = 0;
  clear_has_emencrypt();
}
inline ::mt::EmEncryptArithmetic TGmTestResult::emencrypt() const {
  return static_cast< ::mt::EmEncryptArithmetic >(emencrypt_);
}
inline void TGmTestResult::set_emencrypt(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_emencrypt();
  emencrypt_ = value;
}

// optional int32 errorcode = 2;
inline bool TGmTestResult::has_errorcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TGmTestResult::set_has_errorcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TGmTestResult::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TGmTestResult::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 TGmTestResult::errorcode() const {
  return errorcode_;
}
inline void TGmTestResult::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// -------------------------------------------------------------------

// TGmAndRandomNumTest

// repeated .mt.TGmTestResult gmtest_result = 1;
inline int TGmAndRandomNumTest::gmtest_result_size() const {
  return gmtest_result_.size();
}
inline void TGmAndRandomNumTest::clear_gmtest_result() {
  gmtest_result_.Clear();
}
inline const ::mt::TGmTestResult& TGmAndRandomNumTest::gmtest_result(int index) const {
  return gmtest_result_.Get(index);
}
inline ::mt::TGmTestResult* TGmAndRandomNumTest::mutable_gmtest_result(int index) {
  return gmtest_result_.Mutable(index);
}
inline ::mt::TGmTestResult* TGmAndRandomNumTest::add_gmtest_result() {
  return gmtest_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TGmTestResult >&
TGmAndRandomNumTest::gmtest_result() const {
  return gmtest_result_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TGmTestResult >*
TGmAndRandomNumTest::mutable_gmtest_result() {
  return &gmtest_result_;
}

// optional int32 randomnumtestresult = 2;
inline bool TGmAndRandomNumTest::has_randomnumtestresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TGmAndRandomNumTest::set_has_randomnumtestresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TGmAndRandomNumTest::clear_has_randomnumtestresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TGmAndRandomNumTest::clear_randomnumtestresult() {
  randomnumtestresult_ = 0;
  clear_has_randomnumtestresult();
}
inline ::google::protobuf::int32 TGmAndRandomNumTest::randomnumtestresult() const {
  return randomnumtestresult_;
}
inline void TGmAndRandomNumTest::set_randomnumtestresult(::google::protobuf::int32 value) {
  set_has_randomnumtestresult();
  randomnumtestresult_ = value;
}

// -------------------------------------------------------------------

// TAllSelfTestResult

// repeated .mt.TGmTestResult gmtest_result = 1;
inline int TAllSelfTestResult::gmtest_result_size() const {
  return gmtest_result_.size();
}
inline void TAllSelfTestResult::clear_gmtest_result() {
  gmtest_result_.Clear();
}
inline const ::mt::TGmTestResult& TAllSelfTestResult::gmtest_result(int index) const {
  return gmtest_result_.Get(index);
}
inline ::mt::TGmTestResult* TAllSelfTestResult::mutable_gmtest_result(int index) {
  return gmtest_result_.Mutable(index);
}
inline ::mt::TGmTestResult* TAllSelfTestResult::add_gmtest_result() {
  return gmtest_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TGmTestResult >&
TAllSelfTestResult::gmtest_result() const {
  return gmtest_result_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TGmTestResult >*
TAllSelfTestResult::mutable_gmtest_result() {
  return &gmtest_result_;
}

// optional int32 randomnumtestresult = 2;
inline bool TAllSelfTestResult::has_randomnumtestresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAllSelfTestResult::set_has_randomnumtestresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAllSelfTestResult::clear_has_randomnumtestresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAllSelfTestResult::clear_randomnumtestresult() {
  randomnumtestresult_ = 0;
  clear_has_randomnumtestresult();
}
inline ::google::protobuf::int32 TAllSelfTestResult::randomnumtestresult() const {
  return randomnumtestresult_;
}
inline void TAllSelfTestResult::set_randomnumtestresult(::google::protobuf::int32 value) {
  set_has_randomnumtestresult();
  randomnumtestresult_ = value;
}

// optional int32 signcerttestresult = 3;
inline bool TAllSelfTestResult::has_signcerttestresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAllSelfTestResult::set_has_signcerttestresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAllSelfTestResult::clear_has_signcerttestresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAllSelfTestResult::clear_signcerttestresult() {
  signcerttestresult_ = 0;
  clear_has_signcerttestresult();
}
inline ::google::protobuf::int32 TAllSelfTestResult::signcerttestresult() const {
  return signcerttestresult_;
}
inline void TAllSelfTestResult::set_signcerttestresult(::google::protobuf::int32 value) {
  set_has_signcerttestresult();
  signcerttestresult_ = value;
}

// optional int32 enccerttestresult = 4;
inline bool TAllSelfTestResult::has_enccerttestresult() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAllSelfTestResult::set_has_enccerttestresult() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAllSelfTestResult::clear_has_enccerttestresult() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAllSelfTestResult::clear_enccerttestresult() {
  enccerttestresult_ = 0;
  clear_has_enccerttestresult();
}
inline ::google::protobuf::int32 TAllSelfTestResult::enccerttestresult() const {
  return enccerttestresult_;
}
inline void TAllSelfTestResult::set_enccerttestresult(::google::protobuf::int32 value) {
  set_has_enccerttestresult();
  enccerttestresult_ = value;
}

// optional uint32 softintegritytestresult = 5;
inline bool TAllSelfTestResult::has_softintegritytestresult() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TAllSelfTestResult::set_has_softintegritytestresult() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TAllSelfTestResult::clear_has_softintegritytestresult() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TAllSelfTestResult::clear_softintegritytestresult() {
  softintegritytestresult_ = 0u;
  clear_has_softintegritytestresult();
}
inline ::google::protobuf::uint32 TAllSelfTestResult::softintegritytestresult() const {
  return softintegritytestresult_;
}
inline void TAllSelfTestResult::set_softintegritytestresult(::google::protobuf::uint32 value) {
  set_has_softintegritytestresult();
  softintegritytestresult_ = value;
}

// -------------------------------------------------------------------

// THandShakeParam

// optional bytes pk = 1;
inline bool THandShakeParam::has_pk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void THandShakeParam::set_has_pk() {
  _has_bits_[0] |= 0x00000001u;
}
inline void THandShakeParam::clear_has_pk() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void THandShakeParam::clear_pk() {
  if (pk_ != &::google::protobuf::internal::kEmptyString) {
    pk_->clear();
  }
  clear_has_pk();
}
inline const ::std::string& THandShakeParam::pk() const {
  return *pk_;
}
inline void THandShakeParam::set_pk(const ::std::string& value) {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  pk_->assign(value);
}
inline void THandShakeParam::set_pk(const char* value) {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  pk_->assign(value);
}
inline void THandShakeParam::set_pk(const void* value, size_t size) {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  pk_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* THandShakeParam::mutable_pk() {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  return pk_;
}
inline ::std::string* THandShakeParam::release_pk() {
  clear_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pk_;
    pk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void THandShakeParam::set_allocated_pk(::std::string* pk) {
  if (pk_ != &::google::protobuf::internal::kEmptyString) {
    delete pk_;
  }
  if (pk) {
    set_has_pk();
    pk_ = pk;
  } else {
    clear_has_pk();
    pk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmEncryptArithmetic enc_type = 2;
inline bool THandShakeParam::has_enc_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void THandShakeParam::set_has_enc_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void THandShakeParam::clear_has_enc_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void THandShakeParam::clear_enc_type() {
  enc_type_ = 0;
  clear_has_enc_type();
}
inline ::mt::EmEncryptArithmetic THandShakeParam::enc_type() const {
  return static_cast< ::mt::EmEncryptArithmetic >(enc_type_);
}
inline void THandShakeParam::set_enc_type(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_enc_type();
  enc_type_ = value;
}

// optional .mt.EmDigestType digest_type = 3;
inline bool THandShakeParam::has_digest_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void THandShakeParam::set_has_digest_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void THandShakeParam::clear_has_digest_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void THandShakeParam::clear_digest_type() {
  digest_type_ = 0;
  clear_has_digest_type();
}
inline ::mt::EmDigestType THandShakeParam::digest_type() const {
  return static_cast< ::mt::EmDigestType >(digest_type_);
}
inline void THandShakeParam::set_digest_type(::mt::EmDigestType value) {
  assert(::mt::EmDigestType_IsValid(value));
  set_has_digest_type();
  digest_type_ = value;
}

// optional .mt.EmPubPriType pubpri_type = 4;
inline bool THandShakeParam::has_pubpri_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void THandShakeParam::set_has_pubpri_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void THandShakeParam::clear_has_pubpri_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void THandShakeParam::clear_pubpri_type() {
  pubpri_type_ = 1;
  clear_has_pubpri_type();
}
inline ::mt::EmPubPriType THandShakeParam::pubpri_type() const {
  return static_cast< ::mt::EmPubPriType >(pubpri_type_);
}
inline void THandShakeParam::set_pubpri_type(::mt::EmPubPriType value) {
  assert(::mt::EmPubPriType_IsValid(value));
  set_has_pubpri_type();
  pubpri_type_ = value;
}

// optional bytes nonce = 5;
inline bool THandShakeParam::has_nonce() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void THandShakeParam::set_has_nonce() {
  _has_bits_[0] |= 0x00000010u;
}
inline void THandShakeParam::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void THandShakeParam::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& THandShakeParam::nonce() const {
  return *nonce_;
}
inline void THandShakeParam::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void THandShakeParam::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void THandShakeParam::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* THandShakeParam::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  return nonce_;
}
inline ::std::string* THandShakeParam::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void THandShakeParam::set_allocated_nonce(::std::string* nonce) {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete nonce_;
  }
  if (nonce) {
    set_has_nonce();
    nonce_ = nonce;
  } else {
    clear_has_nonce();
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtcLoginParam

// optional .mt.EmClientAppType app_type = 1;
inline bool TMtcLoginParam::has_app_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtcLoginParam::set_has_app_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtcLoginParam::clear_has_app_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtcLoginParam::clear_app_type() {
  app_type_ = 0;
  clear_has_app_type();
}
inline ::mt::EmClientAppType TMtcLoginParam::app_type() const {
  return static_cast< ::mt::EmClientAppType >(app_type_);
}
inline void TMtcLoginParam::set_app_type(::mt::EmClientAppType value) {
  assert(::mt::EmClientAppType_IsValid(value));
  set_has_app_type();
  app_type_ = value;
}

// optional .mt.EmAuthType auth_type = 2;
inline bool TMtcLoginParam::has_auth_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtcLoginParam::set_has_auth_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtcLoginParam::clear_has_auth_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtcLoginParam::clear_auth_type() {
  auth_type_ = 0;
  clear_has_auth_type();
}
inline ::mt::EmAuthType TMtcLoginParam::auth_type() const {
  return static_cast< ::mt::EmAuthType >(auth_type_);
}
inline void TMtcLoginParam::set_auth_type(::mt::EmAuthType value) {
  assert(::mt::EmAuthType_IsValid(value));
  set_has_auth_type();
  auth_type_ = value;
}

// optional string user_name = 3;
inline bool TMtcLoginParam::has_user_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtcLoginParam::set_has_user_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtcLoginParam::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtcLoginParam::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TMtcLoginParam::user_name() const {
  return *user_name_;
}
inline void TMtcLoginParam::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TMtcLoginParam::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TMtcLoginParam::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtcLoginParam::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TMtcLoginParam::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtcLoginParam::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes digest_pwd = 4;
inline bool TMtcLoginParam::has_digest_pwd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtcLoginParam::set_has_digest_pwd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtcLoginParam::clear_has_digest_pwd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtcLoginParam::clear_digest_pwd() {
  if (digest_pwd_ != &::google::protobuf::internal::kEmptyString) {
    digest_pwd_->clear();
  }
  clear_has_digest_pwd();
}
inline const ::std::string& TMtcLoginParam::digest_pwd() const {
  return *digest_pwd_;
}
inline void TMtcLoginParam::set_digest_pwd(const ::std::string& value) {
  set_has_digest_pwd();
  if (digest_pwd_ == &::google::protobuf::internal::kEmptyString) {
    digest_pwd_ = new ::std::string;
  }
  digest_pwd_->assign(value);
}
inline void TMtcLoginParam::set_digest_pwd(const char* value) {
  set_has_digest_pwd();
  if (digest_pwd_ == &::google::protobuf::internal::kEmptyString) {
    digest_pwd_ = new ::std::string;
  }
  digest_pwd_->assign(value);
}
inline void TMtcLoginParam::set_digest_pwd(const void* value, size_t size) {
  set_has_digest_pwd();
  if (digest_pwd_ == &::google::protobuf::internal::kEmptyString) {
    digest_pwd_ = new ::std::string;
  }
  digest_pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtcLoginParam::mutable_digest_pwd() {
  set_has_digest_pwd();
  if (digest_pwd_ == &::google::protobuf::internal::kEmptyString) {
    digest_pwd_ = new ::std::string;
  }
  return digest_pwd_;
}
inline ::std::string* TMtcLoginParam::release_digest_pwd() {
  clear_has_digest_pwd();
  if (digest_pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = digest_pwd_;
    digest_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtcLoginParam::set_allocated_digest_pwd(::std::string* digest_pwd) {
  if (digest_pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete digest_pwd_;
  }
  if (digest_pwd) {
    set_has_digest_pwd();
    digest_pwd_ = digest_pwd;
  } else {
    clear_has_digest_pwd();
    digest_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes nonce = 5;
inline bool TMtcLoginParam::has_nonce() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtcLoginParam::set_has_nonce() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtcLoginParam::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtcLoginParam::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& TMtcLoginParam::nonce() const {
  return *nonce_;
}
inline void TMtcLoginParam::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void TMtcLoginParam::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void TMtcLoginParam::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtcLoginParam::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  return nonce_;
}
inline ::std::string* TMtcLoginParam::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtcLoginParam::set_allocated_nonce(::std::string* nonce) {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete nonce_;
  }
  if (nonce) {
    set_has_nonce();
    nonce_ = nonce;
  } else {
    clear_has_nonce();
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes cnonce = 6;
inline bool TMtcLoginParam::has_cnonce() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtcLoginParam::set_has_cnonce() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtcLoginParam::clear_has_cnonce() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtcLoginParam::clear_cnonce() {
  if (cnonce_ != &::google::protobuf::internal::kEmptyString) {
    cnonce_->clear();
  }
  clear_has_cnonce();
}
inline const ::std::string& TMtcLoginParam::cnonce() const {
  return *cnonce_;
}
inline void TMtcLoginParam::set_cnonce(const ::std::string& value) {
  set_has_cnonce();
  if (cnonce_ == &::google::protobuf::internal::kEmptyString) {
    cnonce_ = new ::std::string;
  }
  cnonce_->assign(value);
}
inline void TMtcLoginParam::set_cnonce(const char* value) {
  set_has_cnonce();
  if (cnonce_ == &::google::protobuf::internal::kEmptyString) {
    cnonce_ = new ::std::string;
  }
  cnonce_->assign(value);
}
inline void TMtcLoginParam::set_cnonce(const void* value, size_t size) {
  set_has_cnonce();
  if (cnonce_ == &::google::protobuf::internal::kEmptyString) {
    cnonce_ = new ::std::string;
  }
  cnonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtcLoginParam::mutable_cnonce() {
  set_has_cnonce();
  if (cnonce_ == &::google::protobuf::internal::kEmptyString) {
    cnonce_ = new ::std::string;
  }
  return cnonce_;
}
inline ::std::string* TMtcLoginParam::release_cnonce() {
  clear_has_cnonce();
  if (cnonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cnonce_;
    cnonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtcLoginParam::set_allocated_cnonce(::std::string* cnonce) {
  if (cnonce_ != &::google::protobuf::internal::kEmptyString) {
    delete cnonce_;
  }
  if (cnonce) {
    set_has_cnonce();
    cnonce_ = cnonce;
  } else {
    clear_has_cnonce();
    cnonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes enc_key = 7;
inline bool TMtcLoginParam::has_enc_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtcLoginParam::set_has_enc_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtcLoginParam::clear_has_enc_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtcLoginParam::clear_enc_key() {
  if (enc_key_ != &::google::protobuf::internal::kEmptyString) {
    enc_key_->clear();
  }
  clear_has_enc_key();
}
inline const ::std::string& TMtcLoginParam::enc_key() const {
  return *enc_key_;
}
inline void TMtcLoginParam::set_enc_key(const ::std::string& value) {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::kEmptyString) {
    enc_key_ = new ::std::string;
  }
  enc_key_->assign(value);
}
inline void TMtcLoginParam::set_enc_key(const char* value) {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::kEmptyString) {
    enc_key_ = new ::std::string;
  }
  enc_key_->assign(value);
}
inline void TMtcLoginParam::set_enc_key(const void* value, size_t size) {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::kEmptyString) {
    enc_key_ = new ::std::string;
  }
  enc_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtcLoginParam::mutable_enc_key() {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::kEmptyString) {
    enc_key_ = new ::std::string;
  }
  return enc_key_;
}
inline ::std::string* TMtcLoginParam::release_enc_key() {
  clear_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enc_key_;
    enc_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtcLoginParam::set_allocated_enc_key(::std::string* enc_key) {
  if (enc_key_ != &::google::protobuf::internal::kEmptyString) {
    delete enc_key_;
  }
  if (enc_key) {
    set_has_enc_key();
    enc_key_ = enc_key;
  } else {
    clear_has_enc_key();
    enc_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtcLoginRet

// optional bool result = 1;
inline bool TMtcLoginRet::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtcLoginRet::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtcLoginRet::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtcLoginRet::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool TMtcLoginRet::result() const {
  return result_;
}
inline void TMtcLoginRet::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional bool is_kickother = 2;
inline bool TMtcLoginRet::has_is_kickother() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtcLoginRet::set_has_is_kickother() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtcLoginRet::clear_has_is_kickother() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtcLoginRet::clear_is_kickother() {
  is_kickother_ = false;
  clear_has_is_kickother();
}
inline bool TMtcLoginRet::is_kickother() const {
  return is_kickother_;
}
inline void TMtcLoginRet::set_is_kickother(bool value) {
  set_has_is_kickother();
  is_kickother_ = value;
}

// optional .mt.TMtcBaseInfo kickee = 3;
inline bool TMtcLoginRet::has_kickee() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtcLoginRet::set_has_kickee() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtcLoginRet::clear_has_kickee() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtcLoginRet::clear_kickee() {
  if (kickee_ != NULL) kickee_->::mt::TMtcBaseInfo::Clear();
  clear_has_kickee();
}
inline const ::mt::TMtcBaseInfo& TMtcLoginRet::kickee() const {
  return kickee_ != NULL ? *kickee_ : *default_instance_->kickee_;
}
inline ::mt::TMtcBaseInfo* TMtcLoginRet::mutable_kickee() {
  set_has_kickee();
  if (kickee_ == NULL) kickee_ = new ::mt::TMtcBaseInfo;
  return kickee_;
}
inline ::mt::TMtcBaseInfo* TMtcLoginRet::release_kickee() {
  clear_has_kickee();
  ::mt::TMtcBaseInfo* temp = kickee_;
  kickee_ = NULL;
  return temp;
}
inline void TMtcLoginRet::set_allocated_kickee(::mt::TMtcBaseInfo* kickee) {
  delete kickee_;
  kickee_ = kickee;
  if (kickee) {
    set_has_kickee();
  } else {
    clear_has_kickee();
  }
}

// optional .mt.TMtcBaseInfo local = 4;
inline bool TMtcLoginRet::has_local() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtcLoginRet::set_has_local() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtcLoginRet::clear_has_local() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtcLoginRet::clear_local() {
  if (local_ != NULL) local_->::mt::TMtcBaseInfo::Clear();
  clear_has_local();
}
inline const ::mt::TMtcBaseInfo& TMtcLoginRet::local() const {
  return local_ != NULL ? *local_ : *default_instance_->local_;
}
inline ::mt::TMtcBaseInfo* TMtcLoginRet::mutable_local() {
  set_has_local();
  if (local_ == NULL) local_ = new ::mt::TMtcBaseInfo;
  return local_;
}
inline ::mt::TMtcBaseInfo* TMtcLoginRet::release_local() {
  clear_has_local();
  ::mt::TMtcBaseInfo* temp = local_;
  local_ = NULL;
  return temp;
}
inline void TMtcLoginRet::set_allocated_local(::mt::TMtcBaseInfo* local) {
  delete local_;
  local_ = local;
  if (local) {
    set_has_local();
  } else {
    clear_has_local();
  }
}

// optional uint32 user_login_error_count = 5;
inline bool TMtcLoginRet::has_user_login_error_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtcLoginRet::set_has_user_login_error_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtcLoginRet::clear_has_user_login_error_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtcLoginRet::clear_user_login_error_count() {
  user_login_error_count_ = 0u;
  clear_has_user_login_error_count();
}
inline ::google::protobuf::uint32 TMtcLoginRet::user_login_error_count() const {
  return user_login_error_count_;
}
inline void TMtcLoginRet::set_user_login_error_count(::google::protobuf::uint32 value) {
  set_has_user_login_error_count();
  user_login_error_count_ = value;
}

// optional uint32 user_login_time = 6;
inline bool TMtcLoginRet::has_user_login_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtcLoginRet::set_has_user_login_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtcLoginRet::clear_has_user_login_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtcLoginRet::clear_user_login_time() {
  user_login_time_ = 0u;
  clear_has_user_login_time();
}
inline ::google::protobuf::uint32 TMtcLoginRet::user_login_time() const {
  return user_login_time_;
}
inline void TMtcLoginRet::set_user_login_time(::google::protobuf::uint32 value) {
  set_has_user_login_time();
  user_login_time_ = value;
}

// optional bool user_is_exist = 7;
inline bool TMtcLoginRet::has_user_is_exist() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtcLoginRet::set_has_user_is_exist() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtcLoginRet::clear_has_user_is_exist() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtcLoginRet::clear_user_is_exist() {
  user_is_exist_ = false;
  clear_has_user_is_exist();
}
inline bool TMtcLoginRet::user_is_exist() const {
  return user_is_exist_;
}
inline void TMtcLoginRet::set_user_is_exist(bool value) {
  set_has_user_is_exist();
  user_is_exist_ = value;
}

// optional .mt.EmLoginFailReason user_login_error_reason = 8;
inline bool TMtcLoginRet::has_user_login_error_reason() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtcLoginRet::set_has_user_login_error_reason() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtcLoginRet::clear_has_user_login_error_reason() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtcLoginRet::clear_user_login_error_reason() {
  user_login_error_reason_ = 1;
  clear_has_user_login_error_reason();
}
inline ::mt::EmLoginFailReason TMtcLoginRet::user_login_error_reason() const {
  return static_cast< ::mt::EmLoginFailReason >(user_login_error_reason_);
}
inline void TMtcLoginRet::set_user_login_error_reason(::mt::EmLoginFailReason value) {
  assert(::mt::EmLoginFailReason_IsValid(value));
  set_has_user_login_error_reason();
  user_login_error_reason_ = value;
}

// optional uint32 user_max_login_count = 9;
inline bool TMtcLoginRet::has_user_max_login_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMtcLoginRet::set_has_user_max_login_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMtcLoginRet::clear_has_user_max_login_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMtcLoginRet::clear_user_max_login_count() {
  user_max_login_count_ = 0u;
  clear_has_user_max_login_count();
}
inline ::google::protobuf::uint32 TMtcLoginRet::user_max_login_count() const {
  return user_max_login_count_;
}
inline void TMtcLoginRet::set_user_max_login_count(::google::protobuf::uint32 value) {
  set_has_user_max_login_count();
  user_max_login_count_ = value;
}

// optional uint32 user_max_lock_time = 10;
inline bool TMtcLoginRet::has_user_max_lock_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMtcLoginRet::set_has_user_max_lock_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMtcLoginRet::clear_has_user_max_lock_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMtcLoginRet::clear_user_max_lock_time() {
  user_max_lock_time_ = 0u;
  clear_has_user_max_lock_time();
}
inline ::google::protobuf::uint32 TMtcLoginRet::user_max_lock_time() const {
  return user_max_lock_time_;
}
inline void TMtcLoginRet::set_user_max_lock_time(::google::protobuf::uint32 value) {
  set_has_user_max_lock_time();
  user_max_lock_time_ = value;
}

// -------------------------------------------------------------------

// TMtcBaseInfo

// optional string ip = 1;
inline bool TMtcBaseInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtcBaseInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtcBaseInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtcBaseInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& TMtcBaseInfo::ip() const {
  return *ip_;
}
inline void TMtcBaseInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TMtcBaseInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TMtcBaseInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtcBaseInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* TMtcBaseInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtcBaseInfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmClientAppType app_type = 2;
inline bool TMtcBaseInfo::has_app_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtcBaseInfo::set_has_app_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtcBaseInfo::clear_has_app_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtcBaseInfo::clear_app_type() {
  app_type_ = 0;
  clear_has_app_type();
}
inline ::mt::EmClientAppType TMtcBaseInfo::app_type() const {
  return static_cast< ::mt::EmClientAppType >(app_type_);
}
inline void TMtcBaseInfo::set_app_type(::mt::EmClientAppType value) {
  assert(::mt::EmClientAppType_IsValid(value));
  set_has_app_type();
  app_type_ = value;
}

// optional .mt.EmAuthType auth_type = 3;
inline bool TMtcBaseInfo::has_auth_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtcBaseInfo::set_has_auth_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtcBaseInfo::clear_has_auth_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtcBaseInfo::clear_auth_type() {
  auth_type_ = 0;
  clear_has_auth_type();
}
inline ::mt::EmAuthType TMtcBaseInfo::auth_type() const {
  return static_cast< ::mt::EmAuthType >(auth_type_);
}
inline void TMtcBaseInfo::set_auth_type(::mt::EmAuthType value) {
  assert(::mt::EmAuthType_IsValid(value));
  set_has_auth_type();
  auth_type_ = value;
}

// optional string user_name = 4;
inline bool TMtcBaseInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtcBaseInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtcBaseInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtcBaseInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TMtcBaseInfo::user_name() const {
  return *user_name_;
}
inline void TMtcBaseInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TMtcBaseInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TMtcBaseInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtcBaseInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TMtcBaseInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtcBaseInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtVersionInfo

// optional string version = 1;
inline bool TMtVersionInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtVersionInfo::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtVersionInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtVersionInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TMtVersionInfo::version() const {
  return *version_;
}
inline void TMtVersionInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TMtVersionInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TMtVersionInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVersionInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* TMtVersionInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVersionInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtModel model = 2;
inline bool TMtVersionInfo::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtVersionInfo::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtVersionInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtVersionInfo::clear_model() {
  model_ = 0;
  clear_has_model();
}
inline ::mt::EmMtModel TMtVersionInfo::model() const {
  return static_cast< ::mt::EmMtModel >(model_);
}
inline void TMtVersionInfo::set_model(::mt::EmMtModel value) {
  assert(::mt::EmMtModel_IsValid(value));
  set_has_model();
  model_ = value;
}

// optional bool is_support_sm = 3;
inline bool TMtVersionInfo::has_is_support_sm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtVersionInfo::set_has_is_support_sm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtVersionInfo::clear_has_is_support_sm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtVersionInfo::clear_is_support_sm() {
  is_support_sm_ = false;
  clear_has_is_support_sm();
}
inline bool TMtVersionInfo::is_support_sm() const {
  return is_support_sm_;
}
inline void TMtVersionInfo::set_is_support_sm(bool value) {
  set_has_is_support_sm();
  is_support_sm_ = value;
}

// -------------------------------------------------------------------

// TMtcBaseInfoList

// repeated .mt.TMtcBaseInfo mtc_list = 1;
inline int TMtcBaseInfoList::mtc_list_size() const {
  return mtc_list_.size();
}
inline void TMtcBaseInfoList::clear_mtc_list() {
  mtc_list_.Clear();
}
inline const ::mt::TMtcBaseInfo& TMtcBaseInfoList::mtc_list(int index) const {
  return mtc_list_.Get(index);
}
inline ::mt::TMtcBaseInfo* TMtcBaseInfoList::mutable_mtc_list(int index) {
  return mtc_list_.Mutable(index);
}
inline ::mt::TMtcBaseInfo* TMtcBaseInfoList::add_mtc_list() {
  return mtc_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtcBaseInfo >&
TMtcBaseInfoList::mtc_list() const {
  return mtc_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtcBaseInfo >*
TMtcBaseInfoList::mutable_mtc_list() {
  return &mtc_list_;
}

// -------------------------------------------------------------------

// TMtAiInfoCfg

// optional bool is_UsedVoiceAide = 1;
inline bool TMtAiInfoCfg::has_is_usedvoiceaide() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAiInfoCfg::set_has_is_usedvoiceaide() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAiInfoCfg::clear_has_is_usedvoiceaide() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAiInfoCfg::clear_is_usedvoiceaide() {
  is_usedvoiceaide_ = false;
  clear_has_is_usedvoiceaide();
}
inline bool TMtAiInfoCfg::is_usedvoiceaide() const {
  return is_usedvoiceaide_;
}
inline void TMtAiInfoCfg::set_is_usedvoiceaide(bool value) {
  set_has_is_usedvoiceaide();
  is_usedvoiceaide_ = value;
}

// optional bool is_UsedCountOfPeople = 2;
inline bool TMtAiInfoCfg::has_is_usedcountofpeople() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAiInfoCfg::set_has_is_usedcountofpeople() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAiInfoCfg::clear_has_is_usedcountofpeople() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAiInfoCfg::clear_is_usedcountofpeople() {
  is_usedcountofpeople_ = false;
  clear_has_is_usedcountofpeople();
}
inline bool TMtAiInfoCfg::is_usedcountofpeople() const {
  return is_usedcountofpeople_;
}
inline void TMtAiInfoCfg::set_is_usedcountofpeople(bool value) {
  set_has_is_usedcountofpeople();
  is_usedcountofpeople_ = value;
}

// optional bool is_UsedFaceSign = 3;
inline bool TMtAiInfoCfg::has_is_usedfacesign() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtAiInfoCfg::set_has_is_usedfacesign() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtAiInfoCfg::clear_has_is_usedfacesign() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtAiInfoCfg::clear_is_usedfacesign() {
  is_usedfacesign_ = false;
  clear_has_is_usedfacesign();
}
inline bool TMtAiInfoCfg::is_usedfacesign() const {
  return is_usedfacesign_;
}
inline void TMtAiInfoCfg::set_is_usedfacesign(bool value) {
  set_has_is_usedfacesign();
  is_usedfacesign_ = value;
}

// optional bool is_UsedElectNameplate = 4;
inline bool TMtAiInfoCfg::has_is_usedelectnameplate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtAiInfoCfg::set_has_is_usedelectnameplate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtAiInfoCfg::clear_has_is_usedelectnameplate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtAiInfoCfg::clear_is_usedelectnameplate() {
  is_usedelectnameplate_ = false;
  clear_has_is_usedelectnameplate();
}
inline bool TMtAiInfoCfg::is_usedelectnameplate() const {
  return is_usedelectnameplate_;
}
inline void TMtAiInfoCfg::set_is_usedelectnameplate(bool value) {
  set_has_is_usedelectnameplate();
  is_usedelectnameplate_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mt

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_structcommon_2eproto__INCLUDED
