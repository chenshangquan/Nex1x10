// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structcfg.proto

#ifndef PROTOBUF_structcfg_2eproto__INCLUDED
#define PROTOBUF_structcfg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "enum.pb.h"
#include "structcommon.pb.h"
#include "structbase.pb.h"
#include "structconf.pb.h"
// @@protoc_insertion_point(includes)

namespace mt {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
void protobuf_AssignDesc_structcfg_2eproto();
void protobuf_ShutdownFile_structcfg_2eproto();

class TMtCfgIP;
class TMtSvrState;
class TMtSvrStateTable;
class TMtLoginTactic;
class TMtApsLoginParam;
class TMtApsLoginErrcode;
class TMtLoginTacticsTable;
class TMtSvrListFromSDK;
class TMtSvrLoginResultToSDK;
class TMtSvrType;
class TMtSvrLoginStateFromService;
class TMTDnsQueryCbResult;
class TMTDomainTranslateReqToUI;
class TMTDomainTranslateRspFromUI;
class TMTUserPrevilege;
class TMTUserInfoFromAps;
class TMTServerAddress;
class TMTSrvInfoFromAps;
class TMtAPSSvr;
class TMtAPSSvrList;
class TMtXMPPInfo;
class TMtAPSSvrAddr;
class TMtAPSAddrFromSrv;
class TMtAPSAddrCfg;
class TMtAPSAddrCfgs;
class TMtCSUAddr;
class TMtNMSAddr;
class TNMSClientHWInfo;
class TMtH323Cfg;
class TMtNTSAddr;
class TMtSUSAddr;
class TMTUpgradeNetParam;
class TMtNTPAddr;
class TMtPlatformApiAddr;
class TMtPlatformWeiboAddr;
class TMtStreamSvrAddr;
class TMtVODSvrCfg;
class TMtVRSSvrCfg;
class TMtDCSSvrAddr;
class TMtNSAddr;
class TMtMeetingSvrAddr;
class TMtSipSvrAddr;
class TMtH323PxyCfg;
class TMtH460PxyCfg;
class TMtLoginPlatformPwdCfg;
class TMtSipCfg;
class TMtSipProxyCfg;
class TMtTerminalName;
class TTerminalInfo;
class TMtBandWidthTest;
class TMTNat;
class TMTAutoCall;
class TMTCallerProtocol;
class TMTEncryptType;
class TMTStreamMedia;
class TMTChrmanPollScheme;
class TMTChrmanPollSchemeList;
class TSysHint;
class TMTVgaImageAdjustCfg;
class TMTVideoSrcTag;
class TMTVideoSrcTagList;
class TMTVideoOutTag;
class TMTVideoOutTagList;
class TMTSnapShotFtpCfg;
class TServiceInfo;
class TServiceInfoFromUI;
class TServiceDefInfo;
class TSrvKeepLiveInfo;
class TMutiTServiceInfo;
class TMutiTServiceInfoRtData;
class TMutiTServiceDefInfo;
class TUserFullInfo;
class TUserReqResult;
class TMultiUserFullInfo;
class TMultiUserReqResult;
class TMTNetBandWidth;
class TMTNetStatus;
class TMTPortPairInfo;
class TMTPortPairAllocReqInfo;
class TMTPortRangeAllocReqInfo;
class TMTPortPairAllocRspInfo;
class TMTPortRangeAllocRspInfo;
class TMTSymboPoint;
class TMTOsdCfg;
class TMtAsymmetricNetInfo;
class TMTMcRSParam;
class TMTQosParam;
class TMTIPQoS;
class TMTFecInfo;
class TStreamInfo;
class TVodPlayInfo;
class TMultiVodPlayInfo;
class TMTRingCfg;
class TMTVideoEncoderParamCfg;
class TMTAllVideoEncoderParamCfg;
class TMTVideoDecoderParamCfg;
class TMTAllVideoDecoderParamCfg;
class TMTPortCfg;
class TMTShortMsgCfg;
class TMTOspSock5Proxy;
class TMTInnerMcAssVidCfg;
class TMTUpgradeDeviceInfo;
class TMTUpgradeClientInfo;
class TMTUpgradeGrayRange;
class TMTUpgradeVersionInfo;
class TMTUpgradeVersionInfoList;
class TMTUpgradeDownloadInfo;
class TMTUsedPort;
class TMTUsedPortList;
class TMTTotalUsedPort;
class TMTAudioPriorCfg;
class TVidPriorParam;
class TMTMainVideoPriorCfg;
class TMTCodecVidSrcInfo;
class TAdjustAecParamCfg;
class TMTRestoreDefaultCfgInfo;
class TMTVideoOutPortMode;
class TMTBannerInfo;
class TMTBannerInfoList;
class TMTEnablePresetBanner;
class TMTLabelInfo;
class TStringAndTextFormat;
class TMTAutoSleep;
class TMTCfgSystemTime;
class TMTVideoShowMode;
class TMTHDAudInPort;
class TMTHDAudInPortList;
class TMTHDAudOutPortList;
class TMTHDVidInPort;
class TMTHDVidInPortCap;
class TMTHDVidInPortCapList;
class TMTHDMultiVideo;
class TMTDisplayRatio;
class TMTVidInPortMode;
class TMTVidOutPortMode;
class TMTVideoOutPort2InPort;
class TMTVideoMatrixScheme;
class TMTAllVideoMatrixScheme;
class TMTLastDisplay;
class TMTHDImageNoise;
class TMTHDImageDeformationTensile;
class TMTHDImageGeometricScaling;
class TMTHDCameraCfg;
class TMTHDCameraList;
class TMTHDCameraAiCfg;
class TMTHDCameraAiList;
class TMTFaceCheckInInfo;
class TMTFaceCheckInList;
class TMTHDSerialCtrl;
class TMTHDSerialList;
class TMTHDSerialMonitor;
class TMTHDSerialMonitorList;
class TMTAllPreSetNameInfoCfg;
class TMTPreSetNameInfo;
class TMTCodecPreSetIndex;
class TMTAllCodecPreSetIndex;
class TStaticPicCfg;
class TEthnetCardInfo;
class TEthnetCfg;
class TEthnetPPPoECfg;
class TE1Unit;
class TE1Group;
class TE1Cfg;
class TVidBitRationCfg;
class TMtVideoPortParam;
class TMtVideoPortParamList;
class TMTResizeMode;
class TDynamicPayload;
class TRpDynamicPayload;
class TMtForceSetH323Stack;
class TRtpRtcpPairPort;
class TMTInnerMCAvSWPort;
class TMTInnerMcRcvAddr;
class TAudioEncParam;
class TAudioEncParamList;
class TLoginStrategy;
class TMtQtAddr;
class TMtSecKeyUpdatePolicy;
class TAudAacConfPrm;
class TAudAacConfPrmList;
class TServerLoginPort;
class TPlatformType;
class TMTAgentInfo;
class TMTVgaImageOutAdjustCfg;
class TMtPlatformInfo;
class TMtCameraLastPos;
class TMtShortCutKey;
class TMtShortCutKeyList;
class TMtFunctionIcon;
class TMtFunctionIconList;

// ===================================================================

class MTMSG_API TMtCfgIP : public ::google::protobuf::Message {
 public:
  TMtCfgIP();
  virtual ~TMtCfgIP();

  TMtCfgIP(const TMtCfgIP& from);

  inline TMtCfgIP& operator=(const TMtCfgIP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtCfgIP& default_instance();

  void Swap(TMtCfgIP* other);

  // implements Message ----------------------------------------------

  TMtCfgIP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtCfgIP& from);
  void MergeFrom(const TMtCfgIP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtCfgIP)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtCfgIP* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSvrState : public ::google::protobuf::Message {
 public:
  TMtSvrState();
  virtual ~TMtSvrState();

  TMtSvrState(const TMtSvrState& from);

  inline TMtSvrState& operator=(const TMtSvrState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSvrState& default_instance();

  void Swap(TMtSvrState* other);

  // implements Message ----------------------------------------------

  TMtSvrState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSvrState& from);
  void MergeFrom(const TMtSvrState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmServerType svr_type = 1;
  inline bool has_svr_type() const;
  inline void clear_svr_type();
  static const int kSvrTypeFieldNumber = 1;
  inline ::mt::EmServerType svr_type() const;
  inline void set_svr_type(::mt::EmServerType value);

  // optional .mt.EmServerState svr_state = 2;
  inline bool has_svr_state() const;
  inline void clear_svr_state();
  static const int kSvrStateFieldNumber = 2;
  inline ::mt::EmServerState svr_state() const;
  inline void set_svr_state(::mt::EmServerState value);

  // @@protoc_insertion_point(class_scope:mt.TMtSvrState)
 private:
  inline void set_has_svr_type();
  inline void clear_has_svr_type();
  inline void set_has_svr_state();
  inline void clear_has_svr_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int svr_type_;
  int svr_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtSvrState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSvrStateTable : public ::google::protobuf::Message {
 public:
  TMtSvrStateTable();
  virtual ~TMtSvrStateTable();

  TMtSvrStateTable(const TMtSvrStateTable& from);

  inline TMtSvrStateTable& operator=(const TMtSvrStateTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSvrStateTable& default_instance();

  void Swap(TMtSvrStateTable* other);

  // implements Message ----------------------------------------------

  TMtSvrStateTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSvrStateTable& from);
  void MergeFrom(const TMtSvrStateTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtSvrState state_items = 1;
  inline int state_items_size() const;
  inline void clear_state_items();
  static const int kStateItemsFieldNumber = 1;
  inline const ::mt::TMtSvrState& state_items(int index) const;
  inline ::mt::TMtSvrState* mutable_state_items(int index);
  inline ::mt::TMtSvrState* add_state_items();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtSvrState >&
      state_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtSvrState >*
      mutable_state_items();

  // @@protoc_insertion_point(class_scope:mt.TMtSvrStateTable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtSvrState > state_items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtSvrStateTable* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtLoginTactic : public ::google::protobuf::Message {
 public:
  TMtLoginTactic();
  virtual ~TMtLoginTactic();

  TMtLoginTactic(const TMtLoginTactic& from);

  inline TMtLoginTactic& operator=(const TMtLoginTactic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtLoginTactic& default_instance();

  void Swap(TMtLoginTactic* other);

  // implements Message ----------------------------------------------

  TMtLoginTactic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtLoginTactic& from);
  void MergeFrom(const TMtLoginTactic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmServerType svr_type = 1;
  inline bool has_svr_type() const;
  inline void clear_svr_type();
  static const int kSvrTypeFieldNumber = 1;
  inline ::mt::EmServerType svr_type() const;
  inline void set_svr_type(::mt::EmServerType value);

  // repeated .mt.EmServerType predecessor_svr_list = 2;
  inline int predecessor_svr_list_size() const;
  inline void clear_predecessor_svr_list();
  static const int kPredecessorSvrListFieldNumber = 2;
  inline ::mt::EmServerType predecessor_svr_list(int index) const;
  inline void set_predecessor_svr_list(int index, ::mt::EmServerType value);
  inline void add_predecessor_svr_list(::mt::EmServerType value);
  inline const ::google::protobuf::RepeatedField<int>& predecessor_svr_list() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_predecessor_svr_list();

  // optional bool use_or_not = 3;
  inline bool has_use_or_not() const;
  inline void clear_use_or_not();
  static const int kUseOrNotFieldNumber = 3;
  inline bool use_or_not() const;
  inline void set_use_or_not(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtLoginTactic)
 private:
  inline void set_has_svr_type();
  inline void clear_has_svr_type();
  inline void set_has_use_or_not();
  inline void clear_has_use_or_not();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> predecessor_svr_list_;
  int svr_type_;
  bool use_or_not_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtLoginTactic* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtApsLoginParam : public ::google::protobuf::Message {
 public:
  TMtApsLoginParam();
  virtual ~TMtApsLoginParam();

  TMtApsLoginParam(const TMtApsLoginParam& from);

  inline TMtApsLoginParam& operator=(const TMtApsLoginParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtApsLoginParam& default_instance();

  void Swap(TMtApsLoginParam* other);

  // implements Message ----------------------------------------------

  TMtApsLoginParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtApsLoginParam& from);
  void MergeFrom(const TMtApsLoginParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string software_ver = 3;
  inline bool has_software_ver() const;
  inline void clear_software_ver();
  static const int kSoftwareVerFieldNumber = 3;
  inline const ::std::string& software_ver() const;
  inline void set_software_ver(const ::std::string& value);
  inline void set_software_ver(const char* value);
  inline void set_software_ver(const char* value, size_t size);
  inline ::std::string* mutable_software_ver();
  inline ::std::string* release_software_ver();
  inline void set_allocated_software_ver(::std::string* software_ver);

  // optional string model_name = 4;
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 4;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // optional string oem_info = 5;
  inline bool has_oem_info() const;
  inline void clear_oem_info();
  static const int kOemInfoFieldNumber = 5;
  inline const ::std::string& oem_info() const;
  inline void set_oem_info(const ::std::string& value);
  inline void set_oem_info(const char* value);
  inline void set_oem_info(const char* value, size_t size);
  inline ::std::string* mutable_oem_info();
  inline ::std::string* release_oem_info();
  inline void set_allocated_oem_info(::std::string* oem_info);

  // optional string md5password = 6;
  inline bool has_md5password() const;
  inline void clear_md5password();
  static const int kMd5PasswordFieldNumber = 6;
  inline const ::std::string& md5password() const;
  inline void set_md5password(const ::std::string& value);
  inline void set_md5password(const char* value);
  inline void set_md5password(const char* value, size_t size);
  inline ::std::string* mutable_md5password();
  inline ::std::string* release_md5password();
  inline void set_allocated_md5password(::std::string* md5password);

  // @@protoc_insertion_point(class_scope:mt.TMtApsLoginParam)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_software_ver();
  inline void clear_has_software_ver();
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_oem_info();
  inline void clear_has_oem_info();
  inline void set_has_md5password();
  inline void clear_has_md5password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;
  ::std::string* software_ver_;
  ::std::string* model_name_;
  ::std::string* oem_info_;
  ::std::string* md5password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtApsLoginParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtApsLoginErrcode : public ::google::protobuf::Message {
 public:
  TMtApsLoginErrcode();
  virtual ~TMtApsLoginErrcode();

  TMtApsLoginErrcode(const TMtApsLoginErrcode& from);

  inline TMtApsLoginErrcode& operator=(const TMtApsLoginErrcode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtApsLoginErrcode& default_instance();

  void Swap(TMtApsLoginErrcode* other);

  // implements Message ----------------------------------------------

  TMtApsLoginErrcode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtApsLoginErrcode& from);
  void MergeFrom(const TMtApsLoginErrcode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_sucess = 1;
  inline bool has_is_sucess() const;
  inline void clear_is_sucess();
  static const int kIsSucessFieldNumber = 1;
  inline bool is_sucess() const;
  inline void set_is_sucess(bool value);

  // optional uint32 http_errcode = 2;
  inline bool has_http_errcode() const;
  inline void clear_http_errcode();
  static const int kHttpErrcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 http_errcode() const;
  inline void set_http_errcode(::google::protobuf::uint32 value);

  // optional uint32 aps_errcode = 3;
  inline bool has_aps_errcode() const;
  inline void clear_aps_errcode();
  static const int kApsErrcodeFieldNumber = 3;
  inline ::google::protobuf::uint32 aps_errcode() const;
  inline void set_aps_errcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtApsLoginErrcode)
 private:
  inline void set_has_is_sucess();
  inline void clear_has_is_sucess();
  inline void set_has_http_errcode();
  inline void clear_has_http_errcode();
  inline void set_has_aps_errcode();
  inline void clear_has_aps_errcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_sucess_;
  ::google::protobuf::uint32 http_errcode_;
  ::google::protobuf::uint32 aps_errcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtApsLoginErrcode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtLoginTacticsTable : public ::google::protobuf::Message {
 public:
  TMtLoginTacticsTable();
  virtual ~TMtLoginTacticsTable();

  TMtLoginTacticsTable(const TMtLoginTacticsTable& from);

  inline TMtLoginTacticsTable& operator=(const TMtLoginTacticsTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtLoginTacticsTable& default_instance();

  void Swap(TMtLoginTacticsTable* other);

  // implements Message ----------------------------------------------

  TMtLoginTacticsTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtLoginTacticsTable& from);
  void MergeFrom(const TMtLoginTacticsTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtLoginTactic tactic_items = 1;
  inline int tactic_items_size() const;
  inline void clear_tactic_items();
  static const int kTacticItemsFieldNumber = 1;
  inline const ::mt::TMtLoginTactic& tactic_items(int index) const;
  inline ::mt::TMtLoginTactic* mutable_tactic_items(int index);
  inline ::mt::TMtLoginTactic* add_tactic_items();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtLoginTactic >&
      tactic_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtLoginTactic >*
      mutable_tactic_items();

  // @@protoc_insertion_point(class_scope:mt.TMtLoginTacticsTable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtLoginTactic > tactic_items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtLoginTacticsTable* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSvrListFromSDK : public ::google::protobuf::Message {
 public:
  TMtSvrListFromSDK();
  virtual ~TMtSvrListFromSDK();

  TMtSvrListFromSDK(const TMtSvrListFromSDK& from);

  inline TMtSvrListFromSDK& operator=(const TMtSvrListFromSDK& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSvrListFromSDK& default_instance();

  void Swap(TMtSvrListFromSDK* other);

  // implements Message ----------------------------------------------

  TMtSvrListFromSDK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSvrListFromSDK& from);
  void MergeFrom(const TMtSvrListFromSDK& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.EmServerType server_list = 1;
  inline int server_list_size() const;
  inline void clear_server_list();
  static const int kServerListFieldNumber = 1;
  inline ::mt::EmServerType server_list(int index) const;
  inline void set_server_list(int index, ::mt::EmServerType value);
  inline void add_server_list(::mt::EmServerType value);
  inline const ::google::protobuf::RepeatedField<int>& server_list() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_server_list();

  // @@protoc_insertion_point(class_scope:mt.TMtSvrListFromSDK)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> server_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtSvrListFromSDK* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSvrLoginResultToSDK : public ::google::protobuf::Message {
 public:
  TMtSvrLoginResultToSDK();
  virtual ~TMtSvrLoginResultToSDK();

  TMtSvrLoginResultToSDK(const TMtSvrLoginResultToSDK& from);

  inline TMtSvrLoginResultToSDK& operator=(const TMtSvrLoginResultToSDK& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSvrLoginResultToSDK& default_instance();

  void Swap(TMtSvrLoginResultToSDK* other);

  // implements Message ----------------------------------------------

  TMtSvrLoginResultToSDK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSvrLoginResultToSDK& from);
  void MergeFrom(const TMtSvrLoginResultToSDK& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 error_id = 1;
  inline bool has_error_id() const;
  inline void clear_error_id();
  static const int kErrorIdFieldNumber = 1;
  inline ::google::protobuf::int32 error_id() const;
  inline void set_error_id(::google::protobuf::int32 value);

  // optional .mt.EmServerType server_type = 2;
  inline bool has_server_type() const;
  inline void clear_server_type();
  static const int kServerTypeFieldNumber = 2;
  inline ::mt::EmServerType server_type() const;
  inline void set_server_type(::mt::EmServerType value);

  // optional .mt.EmServerState server_state = 3;
  inline bool has_server_state() const;
  inline void clear_server_state();
  static const int kServerStateFieldNumber = 3;
  inline ::mt::EmServerState server_state() const;
  inline void set_server_state(::mt::EmServerState value);

  // @@protoc_insertion_point(class_scope:mt.TMtSvrLoginResultToSDK)
 private:
  inline void set_has_error_id();
  inline void clear_has_error_id();
  inline void set_has_server_type();
  inline void clear_has_server_type();
  inline void set_has_server_state();
  inline void clear_has_server_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 error_id_;
  int server_type_;
  int server_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtSvrLoginResultToSDK* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSvrType : public ::google::protobuf::Message {
 public:
  TMtSvrType();
  virtual ~TMtSvrType();

  TMtSvrType(const TMtSvrType& from);

  inline TMtSvrType& operator=(const TMtSvrType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSvrType& default_instance();

  void Swap(TMtSvrType* other);

  // implements Message ----------------------------------------------

  TMtSvrType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSvrType& from);
  void MergeFrom(const TMtSvrType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 req_sqn = 1;
  inline bool has_req_sqn() const;
  inline void clear_req_sqn();
  static const int kReqSqnFieldNumber = 1;
  inline ::google::protobuf::uint32 req_sqn() const;
  inline void set_req_sqn(::google::protobuf::uint32 value);

  // optional .mt.EmServerType server_type = 2;
  inline bool has_server_type() const;
  inline void clear_server_type();
  static const int kServerTypeFieldNumber = 2;
  inline ::mt::EmServerType server_type() const;
  inline void set_server_type(::mt::EmServerType value);

  // @@protoc_insertion_point(class_scope:mt.TMtSvrType)
 private:
  inline void set_has_req_sqn();
  inline void clear_has_req_sqn();
  inline void set_has_server_type();
  inline void clear_has_server_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 req_sqn_;
  int server_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtSvrType* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSvrLoginStateFromService : public ::google::protobuf::Message {
 public:
  TMtSvrLoginStateFromService();
  virtual ~TMtSvrLoginStateFromService();

  TMtSvrLoginStateFromService(const TMtSvrLoginStateFromService& from);

  inline TMtSvrLoginStateFromService& operator=(const TMtSvrLoginStateFromService& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSvrLoginStateFromService& default_instance();

  void Swap(TMtSvrLoginStateFromService* other);

  // implements Message ----------------------------------------------

  TMtSvrLoginStateFromService* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSvrLoginStateFromService& from);
  void MergeFrom(const TMtSvrLoginStateFromService& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rsp_sqn = 1;
  inline bool has_rsp_sqn() const;
  inline void clear_rsp_sqn();
  static const int kRspSqnFieldNumber = 1;
  inline ::google::protobuf::uint32 rsp_sqn() const;
  inline void set_rsp_sqn(::google::protobuf::uint32 value);

  // optional .mt.EmServerType server_type = 2;
  inline bool has_server_type() const;
  inline void clear_server_type();
  static const int kServerTypeFieldNumber = 2;
  inline ::mt::EmServerType server_type() const;
  inline void set_server_type(::mt::EmServerType value);

  // optional .mt.EmServerState server_state = 3;
  inline bool has_server_state() const;
  inline void clear_server_state();
  static const int kServerStateFieldNumber = 3;
  inline ::mt::EmServerState server_state() const;
  inline void set_server_state(::mt::EmServerState value);

  // @@protoc_insertion_point(class_scope:mt.TMtSvrLoginStateFromService)
 private:
  inline void set_has_rsp_sqn();
  inline void clear_has_rsp_sqn();
  inline void set_has_server_type();
  inline void clear_has_server_type();
  inline void set_has_server_state();
  inline void clear_has_server_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 rsp_sqn_;
  int server_type_;
  int server_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtSvrLoginStateFromService* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTDnsQueryCbResult : public ::google::protobuf::Message {
 public:
  TMTDnsQueryCbResult();
  virtual ~TMTDnsQueryCbResult();

  TMTDnsQueryCbResult(const TMTDnsQueryCbResult& from);

  inline TMTDnsQueryCbResult& operator=(const TMTDnsQueryCbResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTDnsQueryCbResult& default_instance();

  void Swap(TMTDnsQueryCbResult* other);

  // implements Message ----------------------------------------------

  TMTDnsQueryCbResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTDnsQueryCbResult& from);
  void MergeFrom(const TMTDnsQueryCbResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 query_id = 1;
  inline bool has_query_id() const;
  inline void clear_query_id();
  static const int kQueryIdFieldNumber = 1;
  inline ::google::protobuf::uint32 query_id() const;
  inline void set_query_id(::google::protobuf::uint32 value);

  // optional uint32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional uint32 ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTDnsQueryCbResult)
 private:
  inline void set_has_query_id();
  inline void clear_has_query_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 query_id_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTDnsQueryCbResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTDomainTranslateReqToUI : public ::google::protobuf::Message {
 public:
  TMTDomainTranslateReqToUI();
  virtual ~TMTDomainTranslateReqToUI();

  TMTDomainTranslateReqToUI(const TMTDomainTranslateReqToUI& from);

  inline TMTDomainTranslateReqToUI& operator=(const TMTDomainTranslateReqToUI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTDomainTranslateReqToUI& default_instance();

  void Swap(TMTDomainTranslateReqToUI* other);

  // implements Message ----------------------------------------------

  TMTDomainTranslateReqToUI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTDomainTranslateReqToUI& from);
  void MergeFrom(const TMTDomainTranslateReqToUI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 query_id = 1;
  inline bool has_query_id() const;
  inline void clear_query_id();
  static const int kQueryIdFieldNumber = 1;
  inline ::google::protobuf::uint32 query_id() const;
  inline void set_query_id(::google::protobuf::uint32 value);

  // optional string domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // @@protoc_insertion_point(class_scope:mt.TMTDomainTranslateReqToUI)
 private:
  inline void set_has_query_id();
  inline void clear_has_query_id();
  inline void set_has_domain();
  inline void clear_has_domain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 query_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTDomainTranslateReqToUI* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTDomainTranslateRspFromUI : public ::google::protobuf::Message {
 public:
  TMTDomainTranslateRspFromUI();
  virtual ~TMTDomainTranslateRspFromUI();

  TMTDomainTranslateRspFromUI(const TMTDomainTranslateRspFromUI& from);

  inline TMTDomainTranslateRspFromUI& operator=(const TMTDomainTranslateRspFromUI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTDomainTranslateRspFromUI& default_instance();

  void Swap(TMTDomainTranslateRspFromUI* other);

  // implements Message ----------------------------------------------

  TMTDomainTranslateRspFromUI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTDomainTranslateRspFromUI& from);
  void MergeFrom(const TMTDomainTranslateRspFromUI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 query_id = 1;
  inline bool has_query_id() const;
  inline void clear_query_id();
  static const int kQueryIdFieldNumber = 1;
  inline ::google::protobuf::uint32 query_id() const;
  inline void set_query_id(::google::protobuf::uint32 value);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTDomainTranslateRspFromUI)
 private:
  inline void set_has_query_id();
  inline void clear_has_query_id();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 query_id_;
  ::google::protobuf::uint32 ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTDomainTranslateRspFromUI* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUserPrevilege : public ::google::protobuf::Message {
 public:
  TMTUserPrevilege();
  virtual ~TMTUserPrevilege();

  TMTUserPrevilege(const TMTUserPrevilege& from);

  inline TMTUserPrevilege& operator=(const TMTUserPrevilege& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUserPrevilege& default_instance();

  void Swap(TMTUserPrevilege* other);

  // implements Message ----------------------------------------------

  TMTUserPrevilege* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUserPrevilege& from);
  void MergeFrom(const TMTUserPrevilege& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool defaultServiceDomainAdmin = 1;
  inline bool has_defaultservicedomainadmin() const;
  inline void clear_defaultservicedomainadmin();
  static const int kDefaultServiceDomainAdminFieldNumber = 1;
  inline bool defaultservicedomainadmin() const;
  inline void set_defaultservicedomainadmin(bool value);

  // optional bool defaultUserDomainAdmin = 2;
  inline bool has_defaultuserdomainadmin() const;
  inline void clear_defaultuserdomainadmin();
  static const int kDefaultUserDomainAdminFieldNumber = 2;
  inline bool defaultuserdomainadmin() const;
  inline void set_defaultuserdomainadmin(bool value);

  // optional bool enableBMC = 3;
  inline bool has_enablebmc() const;
  inline void clear_enablebmc();
  static const int kEnableBMCFieldNumber = 3;
  inline bool enablebmc() const;
  inline void set_enablebmc(bool value);

  // optional bool enableCall = 4;
  inline bool has_enablecall() const;
  inline void clear_enablecall();
  static const int kEnableCallFieldNumber = 4;
  inline bool enablecall() const;
  inline void set_enablecall(bool value);

  // optional bool enableDCS = 5;
  inline bool has_enabledcs() const;
  inline void clear_enabledcs();
  static const int kEnableDCSFieldNumber = 5;
  inline bool enabledcs() const;
  inline void set_enabledcs(bool value);

  // optional bool enableHD = 6;
  inline bool has_enablehd() const;
  inline void clear_enablehd();
  static const int kEnableHDFieldNumber = 6;
  inline bool enablehd() const;
  inline void set_enablehd(bool value);

  // optional bool enableIncoming = 7;
  inline bool has_enableincoming() const;
  inline void clear_enableincoming();
  static const int kEnableIncomingFieldNumber = 7;
  inline bool enableincoming() const;
  inline void set_enableincoming(bool value);

  // optional bool enableMeeting = 8;
  inline bool has_enablemeeting() const;
  inline void clear_enablemeeting();
  static const int kEnableMeetingFieldNumber = 8;
  inline bool enablemeeting() const;
  inline void set_enablemeeting(bool value);

  // optional bool enableMeetingSMS = 9;
  inline bool has_enablemeetingsms() const;
  inline void clear_enablemeetingsms();
  static const int kEnableMeetingSMSFieldNumber = 9;
  inline bool enablemeetingsms() const;
  inline void set_enablemeetingsms(bool value);

  // optional bool enableNM = 10;
  inline bool has_enablenm() const;
  inline void clear_enablenm();
  static const int kEnableNMFieldNumber = 10;
  inline bool enablenm() const;
  inline void set_enablenm(bool value);

  // optional bool enableOut = 11;
  inline bool has_enableout() const;
  inline void clear_enableout();
  static const int kEnableOutFieldNumber = 11;
  inline bool enableout() const;
  inline void set_enableout(bool value);

  // optional bool enableRoam = 12;
  inline bool has_enableroam() const;
  inline void clear_enableroam();
  static const int kEnableRoamFieldNumber = 12;
  inline bool enableroam() const;
  inline void set_enableroam(bool value);

  // optional bool enableSatellite = 13;
  inline bool has_enablesatellite() const;
  inline void clear_enablesatellite();
  static const int kEnableSatelliteFieldNumber = 13;
  inline bool enablesatellite() const;
  inline void set_enablesatellite(bool value);

  // optional bool enableSatelliteP2P = 14;
  inline bool has_enablesatellitep2p() const;
  inline void clear_enablesatellitep2p();
  static const int kEnableSatelliteP2PFieldNumber = 14;
  inline bool enablesatellitep2p() const;
  inline void set_enablesatellitep2p(bool value);

  // optional bool enableUMC = 15;
  inline bool has_enableumc() const;
  inline void clear_enableumc();
  static const int kEnableUMCFieldNumber = 15;
  inline bool enableumc() const;
  inline void set_enableumc(bool value);

  // optional bool enableVRS = 16;
  inline bool has_enablevrs() const;
  inline void clear_enablevrs();
  static const int kEnableVRSFieldNumber = 16;
  inline bool enablevrs() const;
  inline void set_enablevrs(bool value);

  // optional bool enableWeibo = 17;
  inline bool has_enableweibo() const;
  inline void clear_enableweibo();
  static const int kEnableWeiboFieldNumber = 17;
  inline bool enableweibo() const;
  inline void set_enableweibo(bool value);

  // optional bool enableAdmin = 18;
  inline bool has_enableadmin() const;
  inline void clear_enableadmin();
  static const int kEnableAdminFieldNumber = 18;
  inline bool enableadmin() const;
  inline void set_enableadmin(bool value);

  // optional bool serviceDomainAdmin = 19;
  inline bool has_servicedomainadmin() const;
  inline void clear_servicedomainadmin();
  static const int kServiceDomainAdminFieldNumber = 19;
  inline bool servicedomainadmin() const;
  inline void set_servicedomainadmin(bool value);

  // optional bool userDomainAdmin = 20;
  inline bool has_userdomainadmin() const;
  inline void clear_userdomainadmin();
  static const int kUserDomainAdminFieldNumber = 20;
  inline bool userdomainadmin() const;
  inline void set_userdomainadmin(bool value);

  // optional bool weiboAdmin = 21;
  inline bool has_weiboadmin() const;
  inline void clear_weiboadmin();
  static const int kWeiboAdminFieldNumber = 21;
  inline bool weiboadmin() const;
  inline void set_weiboadmin(bool value);

  // optional bool selfbuilt = 22;
  inline bool has_selfbuilt() const;
  inline void clear_selfbuilt();
  static const int kSelfbuiltFieldNumber = 22;
  inline bool selfbuilt() const;
  inline void set_selfbuilt(bool value);

  // optional bool portmedia = 23;
  inline bool has_portmedia() const;
  inline void clear_portmedia();
  static const int kPortmediaFieldNumber = 23;
  inline bool portmedia() const;
  inline void set_portmedia(bool value);

  // optional bool enableAutoCreateMeeting = 24;
  inline bool has_enableautocreatemeeting() const;
  inline void clear_enableautocreatemeeting();
  static const int kEnableAutoCreateMeetingFieldNumber = 24;
  inline bool enableautocreatemeeting() const;
  inline void set_enableautocreatemeeting(bool value);

  // optional .mt.EmPltSupportConfType emConfType = 25;
  inline bool has_emconftype() const;
  inline void clear_emconftype();
  static const int kEmConfTypeFieldNumber = 25;
  inline ::mt::EmPltSupportConfType emconftype() const;
  inline void set_emconftype(::mt::EmPltSupportConfType value);

  // @@protoc_insertion_point(class_scope:mt.TMTUserPrevilege)
 private:
  inline void set_has_defaultservicedomainadmin();
  inline void clear_has_defaultservicedomainadmin();
  inline void set_has_defaultuserdomainadmin();
  inline void clear_has_defaultuserdomainadmin();
  inline void set_has_enablebmc();
  inline void clear_has_enablebmc();
  inline void set_has_enablecall();
  inline void clear_has_enablecall();
  inline void set_has_enabledcs();
  inline void clear_has_enabledcs();
  inline void set_has_enablehd();
  inline void clear_has_enablehd();
  inline void set_has_enableincoming();
  inline void clear_has_enableincoming();
  inline void set_has_enablemeeting();
  inline void clear_has_enablemeeting();
  inline void set_has_enablemeetingsms();
  inline void clear_has_enablemeetingsms();
  inline void set_has_enablenm();
  inline void clear_has_enablenm();
  inline void set_has_enableout();
  inline void clear_has_enableout();
  inline void set_has_enableroam();
  inline void clear_has_enableroam();
  inline void set_has_enablesatellite();
  inline void clear_has_enablesatellite();
  inline void set_has_enablesatellitep2p();
  inline void clear_has_enablesatellitep2p();
  inline void set_has_enableumc();
  inline void clear_has_enableumc();
  inline void set_has_enablevrs();
  inline void clear_has_enablevrs();
  inline void set_has_enableweibo();
  inline void clear_has_enableweibo();
  inline void set_has_enableadmin();
  inline void clear_has_enableadmin();
  inline void set_has_servicedomainadmin();
  inline void clear_has_servicedomainadmin();
  inline void set_has_userdomainadmin();
  inline void clear_has_userdomainadmin();
  inline void set_has_weiboadmin();
  inline void clear_has_weiboadmin();
  inline void set_has_selfbuilt();
  inline void clear_has_selfbuilt();
  inline void set_has_portmedia();
  inline void clear_has_portmedia();
  inline void set_has_enableautocreatemeeting();
  inline void clear_has_enableautocreatemeeting();
  inline void set_has_emconftype();
  inline void clear_has_emconftype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool defaultservicedomainadmin_;
  bool defaultuserdomainadmin_;
  bool enablebmc_;
  bool enablecall_;
  bool enabledcs_;
  bool enablehd_;
  bool enableincoming_;
  bool enablemeeting_;
  bool enablemeetingsms_;
  bool enablenm_;
  bool enableout_;
  bool enableroam_;
  bool enablesatellite_;
  bool enablesatellitep2p_;
  bool enableumc_;
  bool enablevrs_;
  bool enableweibo_;
  bool enableadmin_;
  bool servicedomainadmin_;
  bool userdomainadmin_;
  bool weiboadmin_;
  bool selfbuilt_;
  bool portmedia_;
  bool enableautocreatemeeting_;
  int emconftype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTUserPrevilege* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUserInfoFromAps : public ::google::protobuf::Message {
 public:
  TMTUserInfoFromAps();
  virtual ~TMTUserInfoFromAps();

  TMTUserInfoFromAps(const TMTUserInfoFromAps& from);

  inline TMTUserInfoFromAps& operator=(const TMTUserInfoFromAps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUserInfoFromAps& default_instance();

  void Swap(TMTUserInfoFromAps* other);

  // implements Message ----------------------------------------------

  TMTUserInfoFromAps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUserInfoFromAps& from);
  void MergeFrom(const TMTUserInfoFromAps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string e164 = 1;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 1;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string email = 2;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 2;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string jid = 3;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 3;
  inline const ::std::string& jid() const;
  inline void set_jid(const ::std::string& value);
  inline void set_jid(const char* value);
  inline void set_jid(const char* value, size_t size);
  inline ::std::string* mutable_jid();
  inline ::std::string* release_jid();
  inline void set_allocated_jid(::std::string* jid);

  // optional string moid = 4;
  inline bool has_moid() const;
  inline void clear_moid();
  static const int kMoidFieldNumber = 4;
  inline const ::std::string& moid() const;
  inline void set_moid(const ::std::string& value);
  inline void set_moid(const char* value);
  inline void set_moid(const char* value, size_t size);
  inline ::std::string* mutable_moid();
  inline ::std::string* release_moid();
  inline void set_allocated_moid(::std::string* moid);

  // optional string xmpp_pwd = 5;
  inline bool has_xmpp_pwd() const;
  inline void clear_xmpp_pwd();
  static const int kXmppPwdFieldNumber = 5;
  inline const ::std::string& xmpp_pwd() const;
  inline void set_xmpp_pwd(const ::std::string& value);
  inline void set_xmpp_pwd(const char* value);
  inline void set_xmpp_pwd(const char* value, size_t size);
  inline ::std::string* mutable_xmpp_pwd();
  inline ::std::string* release_xmpp_pwd();
  inline void set_allocated_xmpp_pwd(::std::string* xmpp_pwd);

  // optional string account = 6;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 6;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 regmode = 7;
  inline bool has_regmode() const;
  inline void clear_regmode();
  static const int kRegmodeFieldNumber = 7;
  inline ::google::protobuf::uint32 regmode() const;
  inline void set_regmode(::google::protobuf::uint32 value);

  // optional string ctime = 8;
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 8;
  inline const ::std::string& ctime() const;
  inline void set_ctime(const ::std::string& value);
  inline void set_ctime(const char* value);
  inline void set_ctime(const char* value, size_t size);
  inline ::std::string* mutable_ctime();
  inline ::std::string* release_ctime();
  inline void set_allocated_ctime(::std::string* ctime);

  // optional bool isGuest = 9;
  inline bool has_isguest() const;
  inline void clear_isguest();
  static const int kIsGuestFieldNumber = 9;
  inline bool isguest() const;
  inline void set_isguest(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTUserInfoFromAps)
 private:
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_jid();
  inline void clear_has_jid();
  inline void set_has_moid();
  inline void clear_has_moid();
  inline void set_has_xmpp_pwd();
  inline void clear_has_xmpp_pwd();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_regmode();
  inline void clear_has_regmode();
  inline void set_has_ctime();
  inline void clear_has_ctime();
  inline void set_has_isguest();
  inline void clear_has_isguest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* e164_;
  ::std::string* email_;
  ::std::string* jid_;
  ::std::string* moid_;
  ::std::string* xmpp_pwd_;
  ::std::string* account_;
  ::std::string* ctime_;
  ::google::protobuf::uint32 regmode_;
  bool isguest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTUserInfoFromAps* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTServerAddress : public ::google::protobuf::Message {
 public:
  TMTServerAddress();
  virtual ~TMTServerAddress();

  TMTServerAddress(const TMTServerAddress& from);

  inline TMTServerAddress& operator=(const TMTServerAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTServerAddress& default_instance();

  void Swap(TMTServerAddress* other);

  // implements Message ----------------------------------------------

  TMTServerAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTServerAddress& from);
  void MergeFrom(const TMTServerAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional uint32 priority = 4;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 4;
  inline ::google::protobuf::uint32 priority() const;
  inline void set_priority(::google::protobuf::uint32 value);

  // optional uint32 timeout = 5;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 5;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool is_new_aps = 6;
  inline bool has_is_new_aps() const;
  inline void clear_is_new_aps();
  static const int kIsNewApsFieldNumber = 6;
  inline bool is_new_aps() const;
  inline void set_is_new_aps(bool value);

  // optional bool is_recover = 7;
  inline bool has_is_recover() const;
  inline void clear_is_recover();
  static const int kIsRecoverFieldNumber = 7;
  inline bool is_recover() const;
  inline void set_is_recover(bool value);

  // optional bool is_sort_fininsh = 8;
  inline bool has_is_sort_fininsh() const;
  inline void clear_is_sort_fininsh();
  static const int kIsSortFininshFieldNumber = 8;
  inline bool is_sort_fininsh() const;
  inline void set_is_sort_fininsh(bool value);

  // optional uint32 tls_port = 9;
  inline bool has_tls_port() const;
  inline void clear_tls_port();
  static const int kTlsPortFieldNumber = 9;
  inline ::google::protobuf::uint32 tls_port() const;
  inline void set_tls_port(::google::protobuf::uint32 value);

  // optional uint32 sino_tls_port = 10;
  inline bool has_sino_tls_port() const;
  inline void clear_sino_tls_port();
  static const int kSinoTlsPortFieldNumber = 10;
  inline ::google::protobuf::uint32 sino_tls_port() const;
  inline void set_sino_tls_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTServerAddress)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_is_new_aps();
  inline void clear_has_is_new_aps();
  inline void set_has_is_recover();
  inline void clear_has_is_recover();
  inline void set_has_is_sort_fininsh();
  inline void clear_has_is_sort_fininsh();
  inline void set_has_tls_port();
  inline void clear_has_tls_port();
  inline void set_has_sino_tls_port();
  inline void clear_has_sino_tls_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 priority_;
  ::google::protobuf::uint32 timeout_;
  bool is_new_aps_;
  bool is_recover_;
  bool is_sort_fininsh_;
  ::google::protobuf::uint32 tls_port_;
  ::google::protobuf::uint32 sino_tls_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTServerAddress* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTSrvInfoFromAps : public ::google::protobuf::Message {
 public:
  TMTSrvInfoFromAps();
  virtual ~TMTSrvInfoFromAps();

  TMTSrvInfoFromAps(const TMTSrvInfoFromAps& from);

  inline TMTSrvInfoFromAps& operator=(const TMTSrvInfoFromAps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTSrvInfoFromAps& default_instance();

  void Swap(TMTSrvInfoFromAps* other);

  // implements Message ----------------------------------------------

  TMTSrvInfoFromAps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTSrvInfoFromAps& from);
  void MergeFrom(const TMTSrvInfoFromAps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMTServerAddress nms = 1;
  inline bool has_nms() const;
  inline void clear_nms();
  static const int kNmsFieldNumber = 1;
  inline const ::mt::TMTServerAddress& nms() const;
  inline ::mt::TMTServerAddress* mutable_nms();
  inline ::mt::TMTServerAddress* release_nms();
  inline void set_allocated_nms(::mt::TMTServerAddress* nms);

  // optional .mt.TMTServerAddress nts = 2;
  inline bool has_nts() const;
  inline void clear_nts();
  static const int kNtsFieldNumber = 2;
  inline const ::mt::TMTServerAddress& nts() const;
  inline ::mt::TMTServerAddress* mutable_nts();
  inline ::mt::TMTServerAddress* release_nts();
  inline void set_allocated_nts(::mt::TMTServerAddress* nts);

  // optional .mt.TMTServerAddress sus = 3;
  inline bool has_sus() const;
  inline void clear_sus();
  static const int kSusFieldNumber = 3;
  inline const ::mt::TMTServerAddress& sus() const;
  inline ::mt::TMTServerAddress* mutable_sus();
  inline ::mt::TMTServerAddress* release_sus();
  inline void set_allocated_sus(::mt::TMTServerAddress* sus);

  // optional .mt.TMTServerAddress nu = 4;
  inline bool has_nu() const;
  inline void clear_nu();
  static const int kNuFieldNumber = 4;
  inline const ::mt::TMTServerAddress& nu() const;
  inline ::mt::TMTServerAddress* mutable_nu();
  inline ::mt::TMTServerAddress* release_nu();
  inline void set_allocated_nu(::mt::TMTServerAddress* nu);

  // optional .mt.TMTServerAddress plat_api = 5;
  inline bool has_plat_api() const;
  inline void clear_plat_api();
  static const int kPlatApiFieldNumber = 5;
  inline const ::mt::TMTServerAddress& plat_api() const;
  inline ::mt::TMTServerAddress* mutable_plat_api();
  inline ::mt::TMTServerAddress* release_plat_api();
  inline void set_allocated_plat_api(::mt::TMTServerAddress* plat_api);

  // optional .mt.TMTServerAddress meeting = 6;
  inline bool has_meeting() const;
  inline void clear_meeting();
  static const int kMeetingFieldNumber = 6;
  inline const ::mt::TMTServerAddress& meeting() const;
  inline ::mt::TMTServerAddress* mutable_meeting();
  inline ::mt::TMTServerAddress* release_meeting();
  inline void set_allocated_meeting(::mt::TMTServerAddress* meeting);

  // optional .mt.TMTServerAddress weibo = 7;
  inline bool has_weibo() const;
  inline void clear_weibo();
  static const int kWeiboFieldNumber = 7;
  inline const ::mt::TMTServerAddress& weibo() const;
  inline ::mt::TMTServerAddress* mutable_weibo();
  inline ::mt::TMTServerAddress* release_weibo();
  inline void set_allocated_weibo(::mt::TMTServerAddress* weibo);

  // optional .mt.TMTServerAddress xmpp = 8;
  inline bool has_xmpp() const;
  inline void clear_xmpp();
  static const int kXmppFieldNumber = 8;
  inline const ::mt::TMTServerAddress& xmpp() const;
  inline ::mt::TMTServerAddress* mutable_xmpp();
  inline ::mt::TMTServerAddress* release_xmpp();
  inline void set_allocated_xmpp(::mt::TMTServerAddress* xmpp);

  // optional .mt.TMTServerAddress ntp = 9;
  inline bool has_ntp() const;
  inline void clear_ntp();
  static const int kNtpFieldNumber = 9;
  inline const ::mt::TMTServerAddress& ntp() const;
  inline ::mt::TMTServerAddress* mutable_ntp();
  inline ::mt::TMTServerAddress* release_ntp();
  inline void set_allocated_ntp(::mt::TMTServerAddress* ntp);

  // optional .mt.TMTServerAddress vrs = 10;
  inline bool has_vrs() const;
  inline void clear_vrs();
  static const int kVrsFieldNumber = 10;
  inline const ::mt::TMTServerAddress& vrs() const;
  inline ::mt::TMTServerAddress* mutable_vrs();
  inline ::mt::TMTServerAddress* release_vrs();
  inline void set_allocated_vrs(::mt::TMTServerAddress* vrs);

  // optional .mt.TMTServerAddress dcs = 11;
  inline bool has_dcs() const;
  inline void clear_dcs();
  static const int kDcsFieldNumber = 11;
  inline const ::mt::TMTServerAddress& dcs() const;
  inline ::mt::TMTServerAddress* mutable_dcs();
  inline ::mt::TMTServerAddress* release_dcs();
  inline void set_allocated_dcs(::mt::TMTServerAddress* dcs);

  // optional .mt.TMTServerAddress nonh323 = 12;
  inline bool has_nonh323() const;
  inline void clear_nonh323();
  static const int kNonh323FieldNumber = 12;
  inline const ::mt::TMTServerAddress& nonh323() const;
  inline ::mt::TMTServerAddress* mutable_nonh323();
  inline ::mt::TMTServerAddress* release_nonh323();
  inline void set_allocated_nonh323(::mt::TMTServerAddress* nonh323);

  // optional .mt.TMTServerAddress stdh323 = 13;
  inline bool has_stdh323() const;
  inline void clear_stdh323();
  static const int kStdh323FieldNumber = 13;
  inline const ::mt::TMTServerAddress& stdh323() const;
  inline ::mt::TMTServerAddress* mutable_stdh323();
  inline ::mt::TMTServerAddress* release_stdh323();
  inline void set_allocated_stdh323(::mt::TMTServerAddress* stdh323);

  // optional .mt.TMTServerAddress sip = 14;
  inline bool has_sip() const;
  inline void clear_sip();
  static const int kSipFieldNumber = 14;
  inline const ::mt::TMTServerAddress& sip() const;
  inline ::mt::TMTServerAddress* mutable_sip();
  inline ::mt::TMTServerAddress* release_sip();
  inline void set_allocated_sip(::mt::TMTServerAddress* sip);

  // repeated .mt.TMTServerAddress aps_list = 15;
  inline int aps_list_size() const;
  inline void clear_aps_list();
  static const int kApsListFieldNumber = 15;
  inline const ::mt::TMTServerAddress& aps_list(int index) const;
  inline ::mt::TMTServerAddress* mutable_aps_list(int index);
  inline ::mt::TMTServerAddress* add_aps_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTServerAddress >&
      aps_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTServerAddress >*
      mutable_aps_list();

  // optional .mt.TMTServerAddress ns = 16;
  inline bool has_ns() const;
  inline void clear_ns();
  static const int kNsFieldNumber = 16;
  inline const ::mt::TMTServerAddress& ns() const;
  inline ::mt::TMTServerAddress* mutable_ns();
  inline ::mt::TMTServerAddress* release_ns();
  inline void set_allocated_ns(::mt::TMTServerAddress* ns);

  // @@protoc_insertion_point(class_scope:mt.TMTSrvInfoFromAps)
 private:
  inline void set_has_nms();
  inline void clear_has_nms();
  inline void set_has_nts();
  inline void clear_has_nts();
  inline void set_has_sus();
  inline void clear_has_sus();
  inline void set_has_nu();
  inline void clear_has_nu();
  inline void set_has_plat_api();
  inline void clear_has_plat_api();
  inline void set_has_meeting();
  inline void clear_has_meeting();
  inline void set_has_weibo();
  inline void clear_has_weibo();
  inline void set_has_xmpp();
  inline void clear_has_xmpp();
  inline void set_has_ntp();
  inline void clear_has_ntp();
  inline void set_has_vrs();
  inline void clear_has_vrs();
  inline void set_has_dcs();
  inline void clear_has_dcs();
  inline void set_has_nonh323();
  inline void clear_has_nonh323();
  inline void set_has_stdh323();
  inline void clear_has_stdh323();
  inline void set_has_sip();
  inline void clear_has_sip();
  inline void set_has_ns();
  inline void clear_has_ns();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTServerAddress* nms_;
  ::mt::TMTServerAddress* nts_;
  ::mt::TMTServerAddress* sus_;
  ::mt::TMTServerAddress* nu_;
  ::mt::TMTServerAddress* plat_api_;
  ::mt::TMTServerAddress* meeting_;
  ::mt::TMTServerAddress* weibo_;
  ::mt::TMTServerAddress* xmpp_;
  ::mt::TMTServerAddress* ntp_;
  ::mt::TMTServerAddress* vrs_;
  ::mt::TMTServerAddress* dcs_;
  ::mt::TMTServerAddress* nonh323_;
  ::mt::TMTServerAddress* stdh323_;
  ::mt::TMTServerAddress* sip_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTServerAddress > aps_list_;
  ::mt::TMTServerAddress* ns_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTSrvInfoFromAps* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAPSSvr : public ::google::protobuf::Message {
 public:
  TMtAPSSvr();
  virtual ~TMtAPSSvr();

  TMtAPSSvr(const TMtAPSSvr& from);

  inline TMtAPSSvr& operator=(const TMtAPSSvr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAPSSvr& default_instance();

  void Swap(TMtAPSSvr* other);

  // implements Message ----------------------------------------------

  TMtAPSSvr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAPSSvr& from);
  void MergeFrom(const TMtAPSSvr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmServerAddrType addr_type = 1;
  inline bool has_addr_type() const;
  inline void clear_addr_type();
  static const int kAddrTypeFieldNumber = 1;
  inline ::mt::EmServerAddrType addr_type() const;
  inline void set_addr_type(::mt::EmServerAddrType value);

  // optional string Domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 aps_login_ip = 3;
  inline bool has_aps_login_ip() const;
  inline void clear_aps_login_ip();
  static const int kApsLoginIpFieldNumber = 3;
  inline ::google::protobuf::uint32 aps_login_ip() const;
  inline void set_aps_login_ip(::google::protobuf::uint32 value);

  // optional string addr_alias = 4;
  inline bool has_addr_alias() const;
  inline void clear_addr_alias();
  static const int kAddrAliasFieldNumber = 4;
  inline const ::std::string& addr_alias() const;
  inline void set_addr_alias(const ::std::string& value);
  inline void set_addr_alias(const char* value);
  inline void set_addr_alias(const char* value, size_t size);
  inline ::std::string* mutable_addr_alias();
  inline ::std::string* release_addr_alias();
  inline void set_allocated_addr_alias(::std::string* addr_alias);

  // optional bool is_ip_svr = 5;
  inline bool has_is_ip_svr() const;
  inline void clear_is_ip_svr();
  static const int kIsIpSvrFieldNumber = 5;
  inline bool is_ip_svr() const;
  inline void set_is_ip_svr(bool value);

  // optional uint32 port = 6;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 6;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtAPSSvr)
 private:
  inline void set_has_addr_type();
  inline void clear_has_addr_type();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_aps_login_ip();
  inline void clear_has_aps_login_ip();
  inline void set_has_addr_alias();
  inline void clear_has_addr_alias();
  inline void set_has_is_ip_svr();
  inline void clear_has_is_ip_svr();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  int addr_type_;
  ::google::protobuf::uint32 aps_login_ip_;
  ::std::string* addr_alias_;
  bool is_ip_svr_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtAPSSvr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAPSSvrList : public ::google::protobuf::Message {
 public:
  TMtAPSSvrList();
  virtual ~TMtAPSSvrList();

  TMtAPSSvrList(const TMtAPSSvrList& from);

  inline TMtAPSSvrList& operator=(const TMtAPSSvrList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAPSSvrList& default_instance();

  void Swap(TMtAPSSvrList* other);

  // implements Message ----------------------------------------------

  TMtAPSSvrList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAPSSvrList& from);
  void MergeFrom(const TMtAPSSvrList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_auto_select = 1;
  inline bool has_is_auto_select() const;
  inline void clear_is_auto_select();
  static const int kIsAutoSelectFieldNumber = 1;
  inline bool is_auto_select() const;
  inline void set_is_auto_select(bool value);

  // optional uint32 cur_index = 2;
  inline bool has_cur_index() const;
  inline void clear_cur_index();
  static const int kCurIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 cur_index() const;
  inline void set_cur_index(::google::protobuf::uint32 value);

  // repeated .mt.TMtAPSSvr srv_addr_list = 3;
  inline int srv_addr_list_size() const;
  inline void clear_srv_addr_list();
  static const int kSrvAddrListFieldNumber = 3;
  inline const ::mt::TMtAPSSvr& srv_addr_list(int index) const;
  inline ::mt::TMtAPSSvr* mutable_srv_addr_list(int index);
  inline ::mt::TMtAPSSvr* add_srv_addr_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSSvr >&
      srv_addr_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSSvr >*
      mutable_srv_addr_list();

  // @@protoc_insertion_point(class_scope:mt.TMtAPSSvrList)
 private:
  inline void set_has_is_auto_select();
  inline void clear_has_is_auto_select();
  inline void set_has_cur_index();
  inline void clear_has_cur_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_auto_select_;
  ::google::protobuf::uint32 cur_index_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSSvr > srv_addr_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtAPSSvrList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtXMPPInfo : public ::google::protobuf::Message {
 public:
  TMtXMPPInfo();
  virtual ~TMtXMPPInfo();

  TMtXMPPInfo(const TMtXMPPInfo& from);

  inline TMtXMPPInfo& operator=(const TMtXMPPInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtXMPPInfo& default_instance();

  void Swap(TMtXMPPInfo* other);

  // implements Message ----------------------------------------------

  TMtXMPPInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtXMPPInfo& from);
  void MergeFrom(const TMtXMPPInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:mt.TMtXMPPInfo)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::std::string* name_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtXMPPInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAPSSvrAddr : public ::google::protobuf::Message {
 public:
  TMtAPSSvrAddr();
  virtual ~TMtAPSSvrAddr();

  TMtAPSSvrAddr(const TMtAPSSvrAddr& from);

  inline TMtAPSSvrAddr& operator=(const TMtAPSSvrAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAPSSvrAddr& default_instance();

  void Swap(TMtAPSSvrAddr* other);

  // implements Message ----------------------------------------------

  TMtAPSSvrAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAPSSvrAddr& from);
  void MergeFrom(const TMtAPSSvrAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 aps_login_ip = 2;
  inline bool has_aps_login_ip() const;
  inline void clear_aps_login_ip();
  static const int kApsLoginIpFieldNumber = 2;
  inline ::google::protobuf::uint32 aps_login_ip() const;
  inline void set_aps_login_ip(::google::protobuf::uint32 value);

  // optional uint32 aps_login_port = 3;
  inline bool has_aps_login_port() const;
  inline void clear_aps_login_port();
  static const int kApsLoginPortFieldNumber = 3;
  inline ::google::protobuf::uint32 aps_login_port() const;
  inline void set_aps_login_port(::google::protobuf::uint32 value);

  // optional uint32 priority = 4;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 4;
  inline ::google::protobuf::uint32 priority() const;
  inline void set_priority(::google::protobuf::uint32 value);

  // optional uint32 timeout = 5;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 5;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool is_new_aps = 6;
  inline bool has_is_new_aps() const;
  inline void clear_is_new_aps();
  static const int kIsNewApsFieldNumber = 6;
  inline bool is_new_aps() const;
  inline void set_is_new_aps(bool value);

  // optional bool is_recover = 7;
  inline bool has_is_recover() const;
  inline void clear_is_recover();
  static const int kIsRecoverFieldNumber = 7;
  inline bool is_recover() const;
  inline void set_is_recover(bool value);

  // optional bool is_sort_fininsh = 8;
  inline bool has_is_sort_fininsh() const;
  inline void clear_is_sort_fininsh();
  static const int kIsSortFininshFieldNumber = 8;
  inline bool is_sort_fininsh() const;
  inline void set_is_sort_fininsh(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtAPSSvrAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_aps_login_ip();
  inline void clear_has_aps_login_ip();
  inline void set_has_aps_login_port();
  inline void clear_has_aps_login_port();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_is_new_aps();
  inline void clear_has_is_new_aps();
  inline void set_has_is_recover();
  inline void clear_has_is_recover();
  inline void set_has_is_sort_fininsh();
  inline void clear_has_is_sort_fininsh();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 aps_login_ip_;
  ::google::protobuf::uint32 aps_login_port_;
  ::google::protobuf::uint32 priority_;
  ::google::protobuf::uint32 timeout_;
  bool is_new_aps_;
  bool is_recover_;
  bool is_sort_fininsh_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtAPSSvrAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAPSAddrFromSrv : public ::google::protobuf::Message {
 public:
  TMtAPSAddrFromSrv();
  virtual ~TMtAPSAddrFromSrv();

  TMtAPSAddrFromSrv(const TMtAPSAddrFromSrv& from);

  inline TMtAPSAddrFromSrv& operator=(const TMtAPSAddrFromSrv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAPSAddrFromSrv& default_instance();

  void Swap(TMtAPSAddrFromSrv* other);

  // implements Message ----------------------------------------------

  TMtAPSAddrFromSrv* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAPSAddrFromSrv& from);
  void MergeFrom(const TMtAPSAddrFromSrv& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtAPSSvrAddr srv_list = 1;
  inline int srv_list_size() const;
  inline void clear_srv_list();
  static const int kSrvListFieldNumber = 1;
  inline const ::mt::TMtAPSSvrAddr& srv_list(int index) const;
  inline ::mt::TMtAPSSvrAddr* mutable_srv_list(int index);
  inline ::mt::TMtAPSSvrAddr* add_srv_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSSvrAddr >&
      srv_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSSvrAddr >*
      mutable_srv_list();

  // @@protoc_insertion_point(class_scope:mt.TMtAPSAddrFromSrv)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSSvrAddr > srv_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtAPSAddrFromSrv* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAPSAddrCfg : public ::google::protobuf::Message {
 public:
  TMtAPSAddrCfg();
  virtual ~TMtAPSAddrCfg();

  TMtAPSAddrCfg(const TMtAPSAddrCfg& from);

  inline TMtAPSAddrCfg& operator=(const TMtAPSAddrCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAPSAddrCfg& default_instance();

  void Swap(TMtAPSAddrCfg* other);

  // implements Message ----------------------------------------------

  TMtAPSAddrCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAPSAddrCfg& from);
  void MergeFrom(const TMtAPSAddrCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmPlatform platform = 1;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 1;
  inline ::mt::EmPlatform platform() const;
  inline void set_platform(::mt::EmPlatform value);

  // optional uint32 aps_cfg_ip = 2;
  inline bool has_aps_cfg_ip() const;
  inline void clear_aps_cfg_ip();
  static const int kApsCfgIpFieldNumber = 2;
  inline ::google::protobuf::uint32 aps_cfg_ip() const;
  inline void set_aps_cfg_ip(::google::protobuf::uint32 value);

  // optional .mt.TMtAPSAddrFromSrv addrs_from_srv = 3;
  inline bool has_addrs_from_srv() const;
  inline void clear_addrs_from_srv();
  static const int kAddrsFromSrvFieldNumber = 3;
  inline const ::mt::TMtAPSAddrFromSrv& addrs_from_srv() const;
  inline ::mt::TMtAPSAddrFromSrv* mutable_addrs_from_srv();
  inline ::mt::TMtAPSAddrFromSrv* release_addrs_from_srv();
  inline void set_allocated_addrs_from_srv(::mt::TMtAPSAddrFromSrv* addrs_from_srv);

  // @@protoc_insertion_point(class_scope:mt.TMtAPSAddrCfg)
 private:
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_aps_cfg_ip();
  inline void clear_has_aps_cfg_ip();
  inline void set_has_addrs_from_srv();
  inline void clear_has_addrs_from_srv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int platform_;
  ::google::protobuf::uint32 aps_cfg_ip_;
  ::mt::TMtAPSAddrFromSrv* addrs_from_srv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtAPSAddrCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAPSAddrCfgs : public ::google::protobuf::Message {
 public:
  TMtAPSAddrCfgs();
  virtual ~TMtAPSAddrCfgs();

  TMtAPSAddrCfgs(const TMtAPSAddrCfgs& from);

  inline TMtAPSAddrCfgs& operator=(const TMtAPSAddrCfgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAPSAddrCfgs& default_instance();

  void Swap(TMtAPSAddrCfgs* other);

  // implements Message ----------------------------------------------

  TMtAPSAddrCfgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAPSAddrCfgs& from);
  void MergeFrom(const TMtAPSAddrCfgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtAPSAddrCfg cfg_svr_list = 1;
  inline int cfg_svr_list_size() const;
  inline void clear_cfg_svr_list();
  static const int kCfgSvrListFieldNumber = 1;
  inline const ::mt::TMtAPSAddrCfg& cfg_svr_list(int index) const;
  inline ::mt::TMtAPSAddrCfg* mutable_cfg_svr_list(int index);
  inline ::mt::TMtAPSAddrCfg* add_cfg_svr_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSAddrCfg >&
      cfg_svr_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSAddrCfg >*
      mutable_cfg_svr_list();

  // @@protoc_insertion_point(class_scope:mt.TMtAPSAddrCfgs)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSAddrCfg > cfg_svr_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtAPSAddrCfgs* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtCSUAddr : public ::google::protobuf::Message {
 public:
  TMtCSUAddr();
  virtual ~TMtCSUAddr();

  TMtCSUAddr(const TMtCSUAddr& from);

  inline TMtCSUAddr& operator=(const TMtCSUAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtCSUAddr& default_instance();

  void Swap(TMtCSUAddr* other);

  // implements Message ----------------------------------------------

  TMtCSUAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtCSUAddr& from);
  void MergeFrom(const TMtCSUAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_enable = 1;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 1;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional string domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string number = 6;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 6;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional uint32 timetolive = 7;
  inline bool has_timetolive() const;
  inline void clear_timetolive();
  static const int kTimetoliveFieldNumber = 7;
  inline ::google::protobuf::uint32 timetolive() const;
  inline void set_timetolive(::google::protobuf::uint32 value);

  // optional string auth_name = 8;
  inline bool has_auth_name() const;
  inline void clear_auth_name();
  static const int kAuthNameFieldNumber = 8;
  inline const ::std::string& auth_name() const;
  inline void set_auth_name(const ::std::string& value);
  inline void set_auth_name(const char* value);
  inline void set_auth_name(const char* value, size_t size);
  inline ::std::string* mutable_auth_name();
  inline ::std::string* release_auth_name();
  inline void set_allocated_auth_name(::std::string* auth_name);

  // @@protoc_insertion_point(class_scope:mt.TMtCSUAddr)
 private:
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_timetolive();
  inline void clear_has_timetolive();
  inline void set_has_auth_name();
  inline void clear_has_auth_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  bool is_enable_;
  ::google::protobuf::uint32 ip_;
  ::std::string* password_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 timetolive_;
  ::std::string* number_;
  ::std::string* auth_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtCSUAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtNMSAddr : public ::google::protobuf::Message {
 public:
  TMtNMSAddr();
  virtual ~TMtNMSAddr();

  TMtNMSAddr(const TMtNMSAddr& from);

  inline TMtNMSAddr& operator=(const TMtNMSAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtNMSAddr& default_instance();

  void Swap(TMtNMSAddr* other);

  // implements Message ----------------------------------------------

  TMtNMSAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtNMSAddr& from);
  void MergeFrom(const TMtNMSAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtNMSAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtNMSAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNMSClientHWInfo : public ::google::protobuf::Message {
 public:
  TNMSClientHWInfo();
  virtual ~TNMSClientHWInfo();

  TNMSClientHWInfo(const TNMSClientHWInfo& from);

  inline TNMSClientHWInfo& operator=(const TNMSClientHWInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNMSClientHWInfo& default_instance();

  void Swap(TNMSClientHWInfo* other);

  // implements Message ----------------------------------------------

  TNMSClientHWInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNMSClientHWInfo& from);
  void MergeFrom(const TNMSClientHWInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string os = 1;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 1;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string cpu_type = 2;
  inline bool has_cpu_type() const;
  inline void clear_cpu_type();
  static const int kCpuTypeFieldNumber = 2;
  inline const ::std::string& cpu_type() const;
  inline void set_cpu_type(const ::std::string& value);
  inline void set_cpu_type(const char* value);
  inline void set_cpu_type(const char* value, size_t size);
  inline ::std::string* mutable_cpu_type();
  inline ::std::string* release_cpu_type();
  inline void set_allocated_cpu_type(::std::string* cpu_type);

  // optional uint32 cpu_freq = 3;
  inline bool has_cpu_freq() const;
  inline void clear_cpu_freq();
  static const int kCpuFreqFieldNumber = 3;
  inline ::google::protobuf::uint32 cpu_freq() const;
  inline void set_cpu_freq(::google::protobuf::uint32 value);

  // optional uint32 memory = 4;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 4;
  inline ::google::protobuf::uint32 memory() const;
  inline void set_memory(::google::protobuf::uint32 value);

  // optional uint32 cpu_num = 5;
  inline bool has_cpu_num() const;
  inline void clear_cpu_num();
  static const int kCpuNumFieldNumber = 5;
  inline ::google::protobuf::uint32 cpu_num() const;
  inline void set_cpu_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TNMSClientHWInfo)
 private:
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_cpu_type();
  inline void clear_has_cpu_type();
  inline void set_has_cpu_freq();
  inline void clear_has_cpu_freq();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_cpu_num();
  inline void clear_has_cpu_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* os_;
  ::std::string* cpu_type_;
  ::google::protobuf::uint32 cpu_freq_;
  ::google::protobuf::uint32 memory_;
  ::google::protobuf::uint32 cpu_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TNMSClientHWInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtH323Cfg : public ::google::protobuf::Message {
 public:
  TMtH323Cfg();
  virtual ~TMtH323Cfg();

  TMtH323Cfg(const TMtH323Cfg& from);

  inline TMtH323Cfg& operator=(const TMtH323Cfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtH323Cfg& default_instance();

  void Swap(TMtH323Cfg* other);

  // implements Message ----------------------------------------------

  TMtH323Cfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtH323Cfg& from);
  void MergeFrom(const TMtH323Cfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool EnableH239 = 1;
  inline bool has_enableh239() const;
  inline void clear_enableh239();
  static const int kEnableH239FieldNumber = 1;
  inline bool enableh239() const;
  inline void set_enableh239(bool value);

  // optional uint32 call_priority = 2;
  inline bool has_call_priority() const;
  inline void clear_call_priority();
  static const int kCallPriorityFieldNumber = 2;
  inline ::google::protobuf::uint32 call_priority() const;
  inline void set_call_priority(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtH323Cfg)
 private:
  inline void set_has_enableh239();
  inline void clear_has_enableh239();
  inline void set_has_call_priority();
  inline void clear_has_call_priority();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enableh239_;
  ::google::protobuf::uint32 call_priority_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtH323Cfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtNTSAddr : public ::google::protobuf::Message {
 public:
  TMtNTSAddr();
  virtual ~TMtNTSAddr();

  TMtNTSAddr(const TMtNTSAddr& from);

  inline TMtNTSAddr& operator=(const TMtNTSAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtNTSAddr& default_instance();

  void Swap(TMtNTSAddr* other);

  // implements Message ----------------------------------------------

  TMtNTSAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtNTSAddr& from);
  void MergeFrom(const TMtNTSAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtNTSAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtNTSAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSUSAddr : public ::google::protobuf::Message {
 public:
  TMtSUSAddr();
  virtual ~TMtSUSAddr();

  TMtSUSAddr(const TMtSUSAddr& from);

  inline TMtSUSAddr& operator=(const TMtSUSAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSUSAddr& default_instance();

  void Swap(TMtSUSAddr* other);

  // implements Message ----------------------------------------------

  TMtSUSAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSUSAddr& from);
  void MergeFrom(const TMtSUSAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional bool use_default_addr = 4;
  inline bool has_use_default_addr() const;
  inline void clear_use_default_addr();
  static const int kUseDefaultAddrFieldNumber = 4;
  inline bool use_default_addr() const;
  inline void set_use_default_addr(bool value);

  // optional string custom_domain = 5;
  inline bool has_custom_domain() const;
  inline void clear_custom_domain();
  static const int kCustomDomainFieldNumber = 5;
  inline const ::std::string& custom_domain() const;
  inline void set_custom_domain(const ::std::string& value);
  inline void set_custom_domain(const char* value);
  inline void set_custom_domain(const char* value, size_t size);
  inline ::std::string* mutable_custom_domain();
  inline ::std::string* release_custom_domain();
  inline void set_allocated_custom_domain(::std::string* custom_domain);

  // optional uint32 custom_ip = 6;
  inline bool has_custom_ip() const;
  inline void clear_custom_ip();
  static const int kCustomIpFieldNumber = 6;
  inline ::google::protobuf::uint32 custom_ip() const;
  inline void set_custom_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtSUSAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_use_default_addr();
  inline void clear_has_use_default_addr();
  inline void set_has_custom_domain();
  inline void clear_has_custom_domain();
  inline void set_has_custom_ip();
  inline void clear_has_custom_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::std::string* custom_domain_;
  bool use_default_addr_;
  ::google::protobuf::uint32 custom_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtSUSAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUpgradeNetParam : public ::google::protobuf::Message {
 public:
  TMTUpgradeNetParam();
  virtual ~TMTUpgradeNetParam();

  TMTUpgradeNetParam(const TMTUpgradeNetParam& from);

  inline TMTUpgradeNetParam& operator=(const TMTUpgradeNetParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUpgradeNetParam& default_instance();

  void Swap(TMTUpgradeNetParam* other);

  // implements Message ----------------------------------------------

  TMTUpgradeNetParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUpgradeNetParam& from);
  void MergeFrom(const TMTUpgradeNetParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_ip = 1;
  inline bool has_server_ip() const;
  inline void clear_server_ip();
  static const int kServerIpFieldNumber = 1;
  inline ::google::protobuf::uint32 server_ip() const;
  inline void set_server_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional bool is_proxy_used = 3;
  inline bool has_is_proxy_used() const;
  inline void clear_is_proxy_used();
  static const int kIsProxyUsedFieldNumber = 3;
  inline bool is_proxy_used() const;
  inline void set_is_proxy_used(bool value);

  // optional .mt.TMTOspSock5Proxy proxy_info = 4;
  inline bool has_proxy_info() const;
  inline void clear_proxy_info();
  static const int kProxyInfoFieldNumber = 4;
  inline const ::mt::TMTOspSock5Proxy& proxy_info() const;
  inline ::mt::TMTOspSock5Proxy* mutable_proxy_info();
  inline ::mt::TMTOspSock5Proxy* release_proxy_info();
  inline void set_allocated_proxy_info(::mt::TMTOspSock5Proxy* proxy_info);

  // optional string domain = 5;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 5;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // @@protoc_insertion_point(class_scope:mt.TMTUpgradeNetParam)
 private:
  inline void set_has_server_ip();
  inline void clear_has_server_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_is_proxy_used();
  inline void clear_has_is_proxy_used();
  inline void set_has_proxy_info();
  inline void clear_has_proxy_info();
  inline void set_has_domain();
  inline void clear_has_domain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 server_ip_;
  ::google::protobuf::uint32 port_;
  ::mt::TMTOspSock5Proxy* proxy_info_;
  ::std::string* domain_;
  bool is_proxy_used_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTUpgradeNetParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtNTPAddr : public ::google::protobuf::Message {
 public:
  TMtNTPAddr();
  virtual ~TMtNTPAddr();

  TMtNTPAddr(const TMtNTPAddr& from);

  inline TMtNTPAddr& operator=(const TMtNTPAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtNTPAddr& default_instance();

  void Swap(TMtNTPAddr* other);

  // implements Message ----------------------------------------------

  TMtNTPAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtNTPAddr& from);
  void MergeFrom(const TMtNTPAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtNTPAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtNTPAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtPlatformApiAddr : public ::google::protobuf::Message {
 public:
  TMtPlatformApiAddr();
  virtual ~TMtPlatformApiAddr();

  TMtPlatformApiAddr(const TMtPlatformApiAddr& from);

  inline TMtPlatformApiAddr& operator=(const TMtPlatformApiAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtPlatformApiAddr& default_instance();

  void Swap(TMtPlatformApiAddr* other);

  // implements Message ----------------------------------------------

  TMtPlatformApiAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtPlatformApiAddr& from);
  void MergeFrom(const TMtPlatformApiAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtPlatformApiAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtPlatformApiAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtPlatformWeiboAddr : public ::google::protobuf::Message {
 public:
  TMtPlatformWeiboAddr();
  virtual ~TMtPlatformWeiboAddr();

  TMtPlatformWeiboAddr(const TMtPlatformWeiboAddr& from);

  inline TMtPlatformWeiboAddr& operator=(const TMtPlatformWeiboAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtPlatformWeiboAddr& default_instance();

  void Swap(TMtPlatformWeiboAddr* other);

  // implements Message ----------------------------------------------

  TMtPlatformWeiboAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtPlatformWeiboAddr& from);
  void MergeFrom(const TMtPlatformWeiboAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtPlatformWeiboAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtPlatformWeiboAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtStreamSvrAddr : public ::google::protobuf::Message {
 public:
  TMtStreamSvrAddr();
  virtual ~TMtStreamSvrAddr();

  TMtStreamSvrAddr(const TMtStreamSvrAddr& from);

  inline TMtStreamSvrAddr& operator=(const TMtStreamSvrAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtStreamSvrAddr& default_instance();

  void Swap(TMtStreamSvrAddr* other);

  // implements Message ----------------------------------------------

  TMtStreamSvrAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtStreamSvrAddr& from);
  void MergeFrom(const TMtStreamSvrAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtStreamSvrAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtStreamSvrAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVODSvrCfg : public ::google::protobuf::Message {
 public:
  TMtVODSvrCfg();
  virtual ~TMtVODSvrCfg();

  TMtVODSvrCfg(const TMtVODSvrCfg& from);

  inline TMtVODSvrCfg& operator=(const TMtVODSvrCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVODSvrCfg& default_instance();

  void Swap(TMtVODSvrCfg* other);

  // implements Message ----------------------------------------------

  TMtVODSvrCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVODSvrCfg& from);
  void MergeFrom(const TMtVODSvrCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_enable = 1;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 1;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional string Domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string username = 5;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 5;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:mt.TMtVODSvrCfg)
 private:
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  bool is_enable_;
  ::google::protobuf::uint32 ip_;
  ::std::string* username_;
  ::std::string* password_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtVODSvrCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVRSSvrCfg : public ::google::protobuf::Message {
 public:
  TMtVRSSvrCfg();
  virtual ~TMtVRSSvrCfg();

  TMtVRSSvrCfg(const TMtVRSSvrCfg& from);

  inline TMtVRSSvrCfg& operator=(const TMtVRSSvrCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVRSSvrCfg& default_instance();

  void Swap(TMtVRSSvrCfg* other);

  // implements Message ----------------------------------------------

  TMtVRSSvrCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVRSSvrCfg& from);
  void MergeFrom(const TMtVRSSvrCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_enable = 1;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 1;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional bool is_custom = 2;
  inline bool has_is_custom() const;
  inline void clear_is_custom();
  static const int kIsCustomFieldNumber = 2;
  inline bool is_custom() const;
  inline void set_is_custom(bool value);

  // optional string Domain = 3;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 3;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string custom_addr = 6;
  inline bool has_custom_addr() const;
  inline void clear_custom_addr();
  static const int kCustomAddrFieldNumber = 6;
  inline const ::std::string& custom_addr() const;
  inline void set_custom_addr(const ::std::string& value);
  inline void set_custom_addr(const char* value);
  inline void set_custom_addr(const char* value, size_t size);
  inline ::std::string* mutable_custom_addr();
  inline ::std::string* release_custom_addr();
  inline void set_allocated_custom_addr(::std::string* custom_addr);

  // optional string username = 7;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 7;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 8;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 8;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:mt.TMtVRSSvrCfg)
 private:
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_is_custom();
  inline void clear_has_is_custom();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_custom_addr();
  inline void clear_has_custom_addr();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_enable_;
  bool is_custom_;
  ::google::protobuf::uint32 ip_;
  ::std::string* domain_;
  ::std::string* custom_addr_;
  ::std::string* username_;
  ::std::string* password_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtVRSSvrCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtDCSSvrAddr : public ::google::protobuf::Message {
 public:
  TMtDCSSvrAddr();
  virtual ~TMtDCSSvrAddr();

  TMtDCSSvrAddr(const TMtDCSSvrAddr& from);

  inline TMtDCSSvrAddr& operator=(const TMtDCSSvrAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtDCSSvrAddr& default_instance();

  void Swap(TMtDCSSvrAddr* other);

  // implements Message ----------------------------------------------

  TMtDCSSvrAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtDCSSvrAddr& from);
  void MergeFrom(const TMtDCSSvrAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional bool use_default_addr = 4;
  inline bool has_use_default_addr() const;
  inline void clear_use_default_addr();
  static const int kUseDefaultAddrFieldNumber = 4;
  inline bool use_default_addr() const;
  inline void set_use_default_addr(bool value);

  // optional string custom_domain = 5;
  inline bool has_custom_domain() const;
  inline void clear_custom_domain();
  static const int kCustomDomainFieldNumber = 5;
  inline const ::std::string& custom_domain() const;
  inline void set_custom_domain(const ::std::string& value);
  inline void set_custom_domain(const char* value);
  inline void set_custom_domain(const char* value, size_t size);
  inline ::std::string* mutable_custom_domain();
  inline ::std::string* release_custom_domain();
  inline void set_allocated_custom_domain(::std::string* custom_domain);

  // optional uint32 custom_ip = 6;
  inline bool has_custom_ip() const;
  inline void clear_custom_ip();
  static const int kCustomIpFieldNumber = 6;
  inline ::google::protobuf::uint32 custom_ip() const;
  inline void set_custom_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtDCSSvrAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_use_default_addr();
  inline void clear_has_use_default_addr();
  inline void set_has_custom_domain();
  inline void clear_has_custom_domain();
  inline void set_has_custom_ip();
  inline void clear_has_custom_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::std::string* custom_domain_;
  bool use_default_addr_;
  ::google::protobuf::uint32 custom_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtDCSSvrAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtNSAddr : public ::google::protobuf::Message {
 public:
  TMtNSAddr();
  virtual ~TMtNSAddr();

  TMtNSAddr(const TMtNSAddr& from);

  inline TMtNSAddr& operator=(const TMtNSAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtNSAddr& default_instance();

  void Swap(TMtNSAddr* other);

  // implements Message ----------------------------------------------

  TMtNSAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtNSAddr& from);
  void MergeFrom(const TMtNSAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional uint32 tls_port = 4;
  inline bool has_tls_port() const;
  inline void clear_tls_port();
  static const int kTlsPortFieldNumber = 4;
  inline ::google::protobuf::uint32 tls_port() const;
  inline void set_tls_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtNSAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_tls_port();
  inline void clear_has_tls_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 tls_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtNSAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtMeetingSvrAddr : public ::google::protobuf::Message {
 public:
  TMtMeetingSvrAddr();
  virtual ~TMtMeetingSvrAddr();

  TMtMeetingSvrAddr(const TMtMeetingSvrAddr& from);

  inline TMtMeetingSvrAddr& operator=(const TMtMeetingSvrAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtMeetingSvrAddr& default_instance();

  void Swap(TMtMeetingSvrAddr* other);

  // implements Message ----------------------------------------------

  TMtMeetingSvrAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtMeetingSvrAddr& from);
  void MergeFrom(const TMtMeetingSvrAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtMeetingSvrAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtMeetingSvrAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSipSvrAddr : public ::google::protobuf::Message {
 public:
  TMtSipSvrAddr();
  virtual ~TMtSipSvrAddr();

  TMtSipSvrAddr(const TMtSipSvrAddr& from);

  inline TMtSipSvrAddr& operator=(const TMtSipSvrAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSipSvrAddr& default_instance();

  void Swap(TMtSipSvrAddr* other);

  // implements Message ----------------------------------------------

  TMtSipSvrAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSipSvrAddr& from);
  void MergeFrom(const TMtSipSvrAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_enable = 1;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 1;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional string Domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 Ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 Port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string Password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional uint32 Expire = 6;
  inline bool has_expire() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 6;
  inline ::google::protobuf::uint32 expire() const;
  inline void set_expire(::google::protobuf::uint32 value);

  // optional string validate_name = 7;
  inline bool has_validate_name() const;
  inline void clear_validate_name();
  static const int kValidateNameFieldNumber = 7;
  inline const ::std::string& validate_name() const;
  inline void set_validate_name(const ::std::string& value);
  inline void set_validate_name(const char* value);
  inline void set_validate_name(const char* value, size_t size);
  inline ::std::string* mutable_validate_name();
  inline ::std::string* release_validate_name();
  inline void set_allocated_validate_name(::std::string* validate_name);

  // optional uint32 host_port = 8;
  inline bool has_host_port() const;
  inline void clear_host_port();
  static const int kHostPortFieldNumber = 8;
  inline ::google::protobuf::uint32 host_port() const;
  inline void set_host_port(::google::protobuf::uint32 value);

  // optional string auth_name = 9;
  inline bool has_auth_name() const;
  inline void clear_auth_name();
  static const int kAuthNameFieldNumber = 9;
  inline const ::std::string& auth_name() const;
  inline void set_auth_name(const ::std::string& value);
  inline void set_auth_name(const char* value);
  inline void set_auth_name(const char* value, size_t size);
  inline ::std::string* mutable_auth_name();
  inline ::std::string* release_auth_name();
  inline void set_allocated_auth_name(::std::string* auth_name);

  // optional uint32 TlsPort = 10;
  inline bool has_tlsport() const;
  inline void clear_tlsport();
  static const int kTlsPortFieldNumber = 10;
  inline ::google::protobuf::uint32 tlsport() const;
  inline void set_tlsport(::google::protobuf::uint32 value);

  // optional uint32 GtlsPort = 11;
  inline bool has_gtlsport() const;
  inline void clear_gtlsport();
  static const int kGtlsPortFieldNumber = 11;
  inline ::google::protobuf::uint32 gtlsport() const;
  inline void set_gtlsport(::google::protobuf::uint32 value);

  // optional string PxyDomain = 12;
  inline bool has_pxydomain() const;
  inline void clear_pxydomain();
  static const int kPxyDomainFieldNumber = 12;
  inline const ::std::string& pxydomain() const;
  inline void set_pxydomain(const ::std::string& value);
  inline void set_pxydomain(const char* value);
  inline void set_pxydomain(const char* value, size_t size);
  inline ::std::string* mutable_pxydomain();
  inline ::std::string* release_pxydomain();
  inline void set_allocated_pxydomain(::std::string* pxydomain);

  // @@protoc_insertion_point(class_scope:mt.TMtSipSvrAddr)
 private:
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_expire();
  inline void clear_has_expire();
  inline void set_has_validate_name();
  inline void clear_has_validate_name();
  inline void set_has_host_port();
  inline void clear_has_host_port();
  inline void set_has_auth_name();
  inline void clear_has_auth_name();
  inline void set_has_tlsport();
  inline void clear_has_tlsport();
  inline void set_has_gtlsport();
  inline void clear_has_gtlsport();
  inline void set_has_pxydomain();
  inline void clear_has_pxydomain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  bool is_enable_;
  ::google::protobuf::uint32 ip_;
  ::std::string* password_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 expire_;
  ::std::string* validate_name_;
  ::std::string* auth_name_;
  ::google::protobuf::uint32 host_port_;
  ::google::protobuf::uint32 tlsport_;
  ::std::string* pxydomain_;
  ::google::protobuf::uint32 gtlsport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtSipSvrAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtH323PxyCfg : public ::google::protobuf::Message {
 public:
  TMtH323PxyCfg();
  virtual ~TMtH323PxyCfg();

  TMtH323PxyCfg(const TMtH323PxyCfg& from);

  inline TMtH323PxyCfg& operator=(const TMtH323PxyCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtH323PxyCfg& default_instance();

  void Swap(TMtH323PxyCfg* other);

  // implements Message ----------------------------------------------

  TMtH323PxyCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtH323PxyCfg& from);
  void MergeFrom(const TMtH323PxyCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_enable = 1;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 1;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional uint32 srv_ip = 2;
  inline bool has_srv_ip() const;
  inline void clear_srv_ip();
  static const int kSrvIpFieldNumber = 2;
  inline ::google::protobuf::uint32 srv_ip() const;
  inline void set_srv_ip(::google::protobuf::uint32 value);

  // optional uint32 srv_port = 3;
  inline bool has_srv_port() const;
  inline void clear_srv_port();
  static const int kSrvPortFieldNumber = 3;
  inline ::google::protobuf::uint32 srv_port() const;
  inline void set_srv_port(::google::protobuf::uint32 value);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string number = 5;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 5;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // @@protoc_insertion_point(class_scope:mt.TMtH323PxyCfg)
 private:
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_srv_ip();
  inline void clear_has_srv_ip();
  inline void set_has_srv_port();
  inline void clear_has_srv_port();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_enable_;
  ::google::protobuf::uint32 srv_ip_;
  ::std::string* password_;
  ::std::string* number_;
  ::google::protobuf::uint32 srv_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtH323PxyCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtH460PxyCfg : public ::google::protobuf::Message {
 public:
  TMtH460PxyCfg();
  virtual ~TMtH460PxyCfg();

  TMtH460PxyCfg(const TMtH460PxyCfg& from);

  inline TMtH460PxyCfg& operator=(const TMtH460PxyCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtH460PxyCfg& default_instance();

  void Swap(TMtH460PxyCfg* other);

  // implements Message ----------------------------------------------

  TMtH460PxyCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtH460PxyCfg& from);
  void MergeFrom(const TMtH460PxyCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_enable = 1;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 1;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional uint32 srv_ip = 2;
  inline bool has_srv_ip() const;
  inline void clear_srv_ip();
  static const int kSrvIpFieldNumber = 2;
  inline ::google::protobuf::uint32 srv_ip() const;
  inline void set_srv_ip(::google::protobuf::uint32 value);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string number = 4;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 4;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // @@protoc_insertion_point(class_scope:mt.TMtH460PxyCfg)
 private:
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_srv_ip();
  inline void clear_has_srv_ip();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_enable_;
  ::google::protobuf::uint32 srv_ip_;
  ::std::string* password_;
  ::std::string* number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtH460PxyCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtLoginPlatformPwdCfg : public ::google::protobuf::Message {
 public:
  TMtLoginPlatformPwdCfg();
  virtual ~TMtLoginPlatformPwdCfg();

  TMtLoginPlatformPwdCfg(const TMtLoginPlatformPwdCfg& from);

  inline TMtLoginPlatformPwdCfg& operator=(const TMtLoginPlatformPwdCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtLoginPlatformPwdCfg& default_instance();

  void Swap(TMtLoginPlatformPwdCfg* other);

  // implements Message ----------------------------------------------

  TMtLoginPlatformPwdCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtLoginPlatformPwdCfg& from);
  void MergeFrom(const TMtLoginPlatformPwdCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string password = 1;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 1;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional bool is_modify_enable = 2;
  inline bool has_is_modify_enable() const;
  inline void clear_is_modify_enable();
  static const int kIsModifyEnableFieldNumber = 2;
  inline bool is_modify_enable() const;
  inline void set_is_modify_enable(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtLoginPlatformPwdCfg)
 private:
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_is_modify_enable();
  inline void clear_has_is_modify_enable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* password_;
  bool is_modify_enable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtLoginPlatformPwdCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSipCfg : public ::google::protobuf::Message {
 public:
  TMtSipCfg();
  virtual ~TMtSipCfg();

  TMtSipCfg(const TMtSipCfg& from);

  inline TMtSipCfg& operator=(const TMtSipCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSipCfg& default_instance();

  void Swap(TMtSipCfg* other);

  // implements Message ----------------------------------------------

  TMtSipCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSipCfg& from);
  void MergeFrom(const TMtSipCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_bfcp = 1;
  inline bool has_enable_bfcp() const;
  inline void clear_enable_bfcp();
  static const int kEnableBfcpFieldNumber = 1;
  inline bool enable_bfcp() const;
  inline void set_enable_bfcp(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtSipCfg)
 private:
  inline void set_has_enable_bfcp();
  inline void clear_has_enable_bfcp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_bfcp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtSipCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSipProxyCfg : public ::google::protobuf::Message {
 public:
  TMtSipProxyCfg();
  virtual ~TMtSipProxyCfg();

  TMtSipProxyCfg(const TMtSipProxyCfg& from);

  inline TMtSipProxyCfg& operator=(const TMtSipProxyCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSipProxyCfg& default_instance();

  void Swap(TMtSipProxyCfg* other);

  // implements Message ----------------------------------------------

  TMtSipProxyCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSipProxyCfg& from);
  void MergeFrom(const TMtSipProxyCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 Ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 Port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtSipProxyCfg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtSipProxyCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtTerminalName : public ::google::protobuf::Message {
 public:
  TMtTerminalName();
  virtual ~TMtTerminalName();

  TMtTerminalName(const TMtTerminalName& from);

  inline TMtTerminalName& operator=(const TMtTerminalName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtTerminalName& default_instance();

  void Swap(TMtTerminalName* other);

  // implements Message ----------------------------------------------

  TMtTerminalName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtTerminalName& from);
  void MergeFrom(const TMtTerminalName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string e164 = 1;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 1;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string alias = 2;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 2;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // @@protoc_insertion_point(class_scope:mt.TMtTerminalName)
 private:
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_alias();
  inline void clear_has_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* e164_;
  ::std::string* alias_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtTerminalName* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TTerminalInfo : public ::google::protobuf::Message {
 public:
  TTerminalInfo();
  virtual ~TTerminalInfo();

  TTerminalInfo(const TTerminalInfo& from);

  inline TTerminalInfo& operator=(const TTerminalInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTerminalInfo& default_instance();

  void Swap(TTerminalInfo* other);

  // implements Message ----------------------------------------------

  TTerminalInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TTerminalInfo& from);
  void MergeFrom(const TTerminalInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtModel model = 1;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 1;
  inline ::mt::EmMtModel model() const;
  inline void set_model(::mt::EmMtModel value);

  // optional string model_name = 2;
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 2;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // optional string hardware_ver = 3;
  inline bool has_hardware_ver() const;
  inline void clear_hardware_ver();
  static const int kHardwareVerFieldNumber = 3;
  inline const ::std::string& hardware_ver() const;
  inline void set_hardware_ver(const ::std::string& value);
  inline void set_hardware_ver(const char* value);
  inline void set_hardware_ver(const char* value, size_t size);
  inline ::std::string* mutable_hardware_ver();
  inline ::std::string* release_hardware_ver();
  inline void set_allocated_hardware_ver(::std::string* hardware_ver);

  // optional string software_ver = 4;
  inline bool has_software_ver() const;
  inline void clear_software_ver();
  static const int kSoftwareVerFieldNumber = 4;
  inline const ::std::string& software_ver() const;
  inline void set_software_ver(const ::std::string& value);
  inline void set_software_ver(const char* value);
  inline void set_software_ver(const char* value, size_t size);
  inline ::std::string* mutable_software_ver();
  inline ::std::string* release_software_ver();
  inline void set_allocated_software_ver(::std::string* software_ver);

  // optional string oem_info = 5;
  inline bool has_oem_info() const;
  inline void clear_oem_info();
  static const int kOemInfoFieldNumber = 5;
  inline const ::std::string& oem_info() const;
  inline void set_oem_info(const ::std::string& value);
  inline void set_oem_info(const char* value);
  inline void set_oem_info(const char* value, size_t size);
  inline ::std::string* mutable_oem_info();
  inline ::std::string* release_oem_info();
  inline void set_allocated_oem_info(::std::string* oem_info);

  // optional string fpga1_ver = 6;
  inline bool has_fpga1_ver() const;
  inline void clear_fpga1_ver();
  static const int kFpga1VerFieldNumber = 6;
  inline const ::std::string& fpga1_ver() const;
  inline void set_fpga1_ver(const ::std::string& value);
  inline void set_fpga1_ver(const char* value);
  inline void set_fpga1_ver(const char* value, size_t size);
  inline ::std::string* mutable_fpga1_ver();
  inline ::std::string* release_fpga1_ver();
  inline void set_allocated_fpga1_ver(::std::string* fpga1_ver);

  // optional string fpga2_ver = 7;
  inline bool has_fpga2_ver() const;
  inline void clear_fpga2_ver();
  static const int kFpga2VerFieldNumber = 7;
  inline const ::std::string& fpga2_ver() const;
  inline void set_fpga2_ver(const ::std::string& value);
  inline void set_fpga2_ver(const char* value);
  inline void set_fpga2_ver(const char* value, size_t size);
  inline ::std::string* mutable_fpga2_ver();
  inline ::std::string* release_fpga2_ver();
  inline void set_allocated_fpga2_ver(::std::string* fpga2_ver);

  // optional string cpld_ver = 8;
  inline bool has_cpld_ver() const;
  inline void clear_cpld_ver();
  static const int kCpldVerFieldNumber = 8;
  inline const ::std::string& cpld_ver() const;
  inline void set_cpld_ver(const ::std::string& value);
  inline void set_cpld_ver(const char* value);
  inline void set_cpld_ver(const char* value, size_t size);
  inline ::std::string* mutable_cpld_ver();
  inline ::std::string* release_cpld_ver();
  inline void set_allocated_cpld_ver(::std::string* cpld_ver);

  // optional string serial_num = 9;
  inline bool has_serial_num() const;
  inline void clear_serial_num();
  static const int kSerialNumFieldNumber = 9;
  inline const ::std::string& serial_num() const;
  inline void set_serial_num(const ::std::string& value);
  inline void set_serial_num(const char* value);
  inline void set_serial_num(const char* value, size_t size);
  inline ::std::string* mutable_serial_num();
  inline ::std::string* release_serial_num();
  inline void set_allocated_serial_num(::std::string* serial_num);

  // optional string infrared_ver = 10;
  inline bool has_infrared_ver() const;
  inline void clear_infrared_ver();
  static const int kInfraredVerFieldNumber = 10;
  inline const ::std::string& infrared_ver() const;
  inline void set_infrared_ver(const ::std::string& value);
  inline void set_infrared_ver(const char* value);
  inline void set_infrared_ver(const char* value, size_t size);
  inline ::std::string* mutable_infrared_ver();
  inline ::std::string* release_infrared_ver();
  inline void set_allocated_infrared_ver(::std::string* infrared_ver);

  // optional string fpga3_ver = 11;
  inline bool has_fpga3_ver() const;
  inline void clear_fpga3_ver();
  static const int kFpga3VerFieldNumber = 11;
  inline const ::std::string& fpga3_ver() const;
  inline void set_fpga3_ver(const ::std::string& value);
  inline void set_fpga3_ver(const char* value);
  inline void set_fpga3_ver(const char* value, size_t size);
  inline ::std::string* mutable_fpga3_ver();
  inline ::std::string* release_fpga3_ver();
  inline void set_allocated_fpga3_ver(::std::string* fpga3_ver);

  // optional string fpga4_ver = 12;
  inline bool has_fpga4_ver() const;
  inline void clear_fpga4_ver();
  static const int kFpga4VerFieldNumber = 12;
  inline const ::std::string& fpga4_ver() const;
  inline void set_fpga4_ver(const ::std::string& value);
  inline void set_fpga4_ver(const char* value);
  inline void set_fpga4_ver(const char* value, size_t size);
  inline ::std::string* mutable_fpga4_ver();
  inline ::std::string* release_fpga4_ver();
  inline void set_allocated_fpga4_ver(::std::string* fpga4_ver);

  // optional string ptz_ver = 13;
  inline bool has_ptz_ver() const;
  inline void clear_ptz_ver();
  static const int kPtzVerFieldNumber = 13;
  inline const ::std::string& ptz_ver() const;
  inline void set_ptz_ver(const ::std::string& value);
  inline void set_ptz_ver(const char* value);
  inline void set_ptz_ver(const char* value, size_t size);
  inline ::std::string* mutable_ptz_ver();
  inline ::std::string* release_ptz_ver();
  inline void set_allocated_ptz_ver(::std::string* ptz_ver);

  // @@protoc_insertion_point(class_scope:mt.TTerminalInfo)
 private:
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_hardware_ver();
  inline void clear_has_hardware_ver();
  inline void set_has_software_ver();
  inline void clear_has_software_ver();
  inline void set_has_oem_info();
  inline void clear_has_oem_info();
  inline void set_has_fpga1_ver();
  inline void clear_has_fpga1_ver();
  inline void set_has_fpga2_ver();
  inline void clear_has_fpga2_ver();
  inline void set_has_cpld_ver();
  inline void clear_has_cpld_ver();
  inline void set_has_serial_num();
  inline void clear_has_serial_num();
  inline void set_has_infrared_ver();
  inline void clear_has_infrared_ver();
  inline void set_has_fpga3_ver();
  inline void clear_has_fpga3_ver();
  inline void set_has_fpga4_ver();
  inline void clear_has_fpga4_ver();
  inline void set_has_ptz_ver();
  inline void clear_has_ptz_ver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* model_name_;
  ::std::string* hardware_ver_;
  ::std::string* software_ver_;
  ::std::string* oem_info_;
  ::std::string* fpga1_ver_;
  ::std::string* fpga2_ver_;
  ::std::string* cpld_ver_;
  ::std::string* serial_num_;
  ::std::string* infrared_ver_;
  ::std::string* fpga3_ver_;
  ::std::string* fpga4_ver_;
  ::std::string* ptz_ver_;
  int model_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TTerminalInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtBandWidthTest : public ::google::protobuf::Message {
 public:
  TMtBandWidthTest();
  virtual ~TMtBandWidthTest();

  TMtBandWidthTest(const TMtBandWidthTest& from);

  inline TMtBandWidthTest& operator=(const TMtBandWidthTest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtBandWidthTest& default_instance();

  void Swap(TMtBandWidthTest* other);

  // implements Message ----------------------------------------------

  TMtBandWidthTest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtBandWidthTest& from);
  void MergeFrom(const TMtBandWidthTest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1 [default = true];
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional uint32 up = 2 [default = 0];
  inline bool has_up() const;
  inline void clear_up();
  static const int kUpFieldNumber = 2;
  inline ::google::protobuf::uint32 up() const;
  inline void set_up(::google::protobuf::uint32 value);

  // optional uint32 down = 3 [default = 0];
  inline bool has_down() const;
  inline void clear_down();
  static const int kDownFieldNumber = 3;
  inline ::google::protobuf::uint32 down() const;
  inline void set_down(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtBandWidthTest)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_up();
  inline void clear_has_up();
  inline void set_has_down();
  inline void clear_has_down();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  ::google::protobuf::uint32 up_;
  ::google::protobuf::uint32 down_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtBandWidthTest* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTNat : public ::google::protobuf::Message {
 public:
  TMTNat();
  virtual ~TMTNat();

  TMTNat(const TMTNat& from);

  inline TMTNat& operator=(const TMTNat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTNat& default_instance();

  void Swap(TMTNat* other);

  // implements Message ----------------------------------------------

  TMTNat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTNat& from);
  void MergeFrom(const TMTNat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTNat)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  ::google::protobuf::uint32 ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTNat* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAutoCall : public ::google::protobuf::Message {
 public:
  TMTAutoCall();
  virtual ~TMTAutoCall();

  TMTAutoCall(const TMTAutoCall& from);

  inline TMTAutoCall& operator=(const TMTAutoCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAutoCall& default_instance();

  void Swap(TMTAutoCall* other);

  // implements Message ----------------------------------------------

  TMTAutoCall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAutoCall& from);
  void MergeFrom(const TMTAutoCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional string called_ter_name = 2;
  inline bool has_called_ter_name() const;
  inline void clear_called_ter_name();
  static const int kCalledTerNameFieldNumber = 2;
  inline const ::std::string& called_ter_name() const;
  inline void set_called_ter_name(const ::std::string& value);
  inline void set_called_ter_name(const char* value);
  inline void set_called_ter_name(const char* value, size_t size);
  inline ::std::string* mutable_called_ter_name();
  inline ::std::string* release_called_ter_name();
  inline void set_allocated_called_ter_name(::std::string* called_ter_name);

  // optional uint32 callrate = 3;
  inline bool has_callrate() const;
  inline void clear_callrate();
  static const int kCallrateFieldNumber = 3;
  inline ::google::protobuf::uint32 callrate() const;
  inline void set_callrate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTAutoCall)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_called_ter_name();
  inline void clear_has_called_ter_name();
  inline void set_has_callrate();
  inline void clear_has_callrate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* called_ter_name_;
  bool enable_;
  ::google::protobuf::uint32 callrate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTAutoCall* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCallerProtocol : public ::google::protobuf::Message {
 public:
  TMTCallerProtocol();
  virtual ~TMTCallerProtocol();

  TMTCallerProtocol(const TMTCallerProtocol& from);

  inline TMTCallerProtocol& operator=(const TMTCallerProtocol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCallerProtocol& default_instance();

  void Swap(TMTCallerProtocol* other);

  // implements Message ----------------------------------------------

  TMTCallerProtocol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCallerProtocol& from);
  void MergeFrom(const TMTCallerProtocol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmConfProtocol protocol = 1;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  inline ::mt::EmConfProtocol protocol() const;
  inline void set_protocol(::mt::EmConfProtocol value);

  // @@protoc_insertion_point(class_scope:mt.TMTCallerProtocol)
 private:
  inline void set_has_protocol();
  inline void clear_has_protocol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protocol_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTCallerProtocol* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTEncryptType : public ::google::protobuf::Message {
 public:
  TMTEncryptType();
  virtual ~TMTEncryptType();

  TMTEncryptType(const TMTEncryptType& from);

  inline TMTEncryptType& operator=(const TMTEncryptType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTEncryptType& default_instance();

  void Swap(TMTEncryptType* other);

  // implements Message ----------------------------------------------

  TMTEncryptType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTEncryptType& from);
  void MergeFrom(const TMTEncryptType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmEncryptArithmetic type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmEncryptArithmetic type() const;
  inline void set_type(::mt::EmEncryptArithmetic value);

  // @@protoc_insertion_point(class_scope:mt.TMTEncryptType)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTEncryptType* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTStreamMedia : public ::google::protobuf::Message {
 public:
  TMTStreamMedia();
  virtual ~TMTStreamMedia();

  TMTStreamMedia(const TMTStreamMedia& from);

  inline TMTStreamMedia& operator=(const TMTStreamMedia& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTStreamMedia& default_instance();

  void Swap(TMTStreamMedia* other);

  // implements Message ----------------------------------------------

  TMTStreamMedia* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTStreamMedia& from);
  void MergeFrom(const TMTStreamMedia& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional bool ForwardLocalVideo = 2;
  inline bool has_forwardlocalvideo() const;
  inline void clear_forwardlocalvideo();
  static const int kForwardLocalVideoFieldNumber = 2;
  inline bool forwardlocalvideo() const;
  inline void set_forwardlocalvideo(bool value);

  // optional uint32 MCIP = 3;
  inline bool has_mcip() const;
  inline void clear_mcip();
  static const int kMCIPFieldNumber = 3;
  inline ::google::protobuf::uint32 mcip() const;
  inline void set_mcip(::google::protobuf::uint32 value);

  // optional uint32 Port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional uint32 TTL = 5;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTTLFieldNumber = 5;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // optional string ChannelName = 6;
  inline bool has_channelname() const;
  inline void clear_channelname();
  static const int kChannelNameFieldNumber = 6;
  inline const ::std::string& channelname() const;
  inline void set_channelname(const ::std::string& value);
  inline void set_channelname(const char* value);
  inline void set_channelname(const char* value, size_t size);
  inline ::std::string* mutable_channelname();
  inline ::std::string* release_channelname();
  inline void set_allocated_channelname(::std::string* channelname);

  // optional string Password = 7;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 7;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:mt.TMTStreamMedia)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_forwardlocalvideo();
  inline void clear_has_forwardlocalvideo();
  inline void set_has_mcip();
  inline void clear_has_mcip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_channelname();
  inline void clear_has_channelname();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  bool forwardlocalvideo_;
  ::google::protobuf::uint32 mcip_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 ttl_;
  ::std::string* channelname_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTStreamMedia* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTChrmanPollScheme : public ::google::protobuf::Message {
 public:
  TMTChrmanPollScheme();
  virtual ~TMTChrmanPollScheme();

  TMTChrmanPollScheme(const TMTChrmanPollScheme& from);

  inline TMTChrmanPollScheme& operator=(const TMTChrmanPollScheme& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTChrmanPollScheme& default_instance();

  void Swap(TMTChrmanPollScheme* other);

  // implements Message ----------------------------------------------

  TMTChrmanPollScheme* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTChrmanPollScheme& from);
  void MergeFrom(const TMTChrmanPollScheme& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .mt.TMtPollInfo scheme = 2;
  inline bool has_scheme() const;
  inline void clear_scheme();
  static const int kSchemeFieldNumber = 2;
  inline const ::mt::TMtPollInfo& scheme() const;
  inline ::mt::TMtPollInfo* mutable_scheme();
  inline ::mt::TMtPollInfo* release_scheme();
  inline void set_allocated_scheme(::mt::TMtPollInfo* scheme);

  // @@protoc_insertion_point(class_scope:mt.TMTChrmanPollScheme)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_scheme();
  inline void clear_has_scheme();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::mt::TMtPollInfo* scheme_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTChrmanPollScheme* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTChrmanPollSchemeList : public ::google::protobuf::Message {
 public:
  TMTChrmanPollSchemeList();
  virtual ~TMTChrmanPollSchemeList();

  TMTChrmanPollSchemeList(const TMTChrmanPollSchemeList& from);

  inline TMTChrmanPollSchemeList& operator=(const TMTChrmanPollSchemeList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTChrmanPollSchemeList& default_instance();

  void Swap(TMTChrmanPollSchemeList* other);

  // implements Message ----------------------------------------------

  TMTChrmanPollSchemeList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTChrmanPollSchemeList& from);
  void MergeFrom(const TMTChrmanPollSchemeList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTChrmanPollScheme scheme_list = 1;
  inline int scheme_list_size() const;
  inline void clear_scheme_list();
  static const int kSchemeListFieldNumber = 1;
  inline const ::mt::TMTChrmanPollScheme& scheme_list(int index) const;
  inline ::mt::TMTChrmanPollScheme* mutable_scheme_list(int index);
  inline ::mt::TMTChrmanPollScheme* add_scheme_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTChrmanPollScheme >&
      scheme_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTChrmanPollScheme >*
      mutable_scheme_list();

  // @@protoc_insertion_point(class_scope:mt.TMTChrmanPollSchemeList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTChrmanPollScheme > scheme_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTChrmanPollSchemeList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TSysHint : public ::google::protobuf::Message {
 public:
  TSysHint();
  virtual ~TSysHint();

  TSysHint(const TSysHint& from);

  inline TSysHint& operator=(const TSysHint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSysHint& default_instance();

  void Swap(TSysHint* other);

  // implements Message ----------------------------------------------

  TSysHint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSysHint& from);
  void MergeFrom(const TSysHint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmHintCode hint_code = 1;
  inline bool has_hint_code() const;
  inline void clear_hint_code();
  static const int kHintCodeFieldNumber = 1;
  inline ::mt::EmHintCode hint_code() const;
  inline void set_hint_code(::mt::EmHintCode value);

  // optional string extra_param = 2;
  inline bool has_extra_param() const;
  inline void clear_extra_param();
  static const int kExtraParamFieldNumber = 2;
  inline const ::std::string& extra_param() const;
  inline void set_extra_param(const ::std::string& value);
  inline void set_extra_param(const char* value);
  inline void set_extra_param(const char* value, size_t size);
  inline ::std::string* mutable_extra_param();
  inline ::std::string* release_extra_param();
  inline void set_allocated_extra_param(::std::string* extra_param);

  // @@protoc_insertion_point(class_scope:mt.TSysHint)
 private:
  inline void set_has_hint_code();
  inline void clear_has_hint_code();
  inline void set_has_extra_param();
  inline void clear_has_extra_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* extra_param_;
  int hint_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TSysHint* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVgaImageAdjustCfg : public ::google::protobuf::Message {
 public:
  TMTVgaImageAdjustCfg();
  virtual ~TMTVgaImageAdjustCfg();

  TMTVgaImageAdjustCfg(const TMTVgaImageAdjustCfg& from);

  inline TMTVgaImageAdjustCfg& operator=(const TMTVgaImageAdjustCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVgaImageAdjustCfg& default_instance();

  void Swap(TMTVgaImageAdjustCfg* other);

  // implements Message ----------------------------------------------

  TMTVgaImageAdjustCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVgaImageAdjustCfg& from);
  void MergeFrom(const TMTVgaImageAdjustCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool vga1_filter_state = 1;
  inline bool has_vga1_filter_state() const;
  inline void clear_vga1_filter_state();
  static const int kVga1FilterStateFieldNumber = 1;
  inline bool vga1_filter_state() const;
  inline void set_vga1_filter_state(bool value);

  // optional uint32 vga1_phase_clock = 2;
  inline bool has_vga1_phase_clock() const;
  inline void clear_vga1_phase_clock();
  static const int kVga1PhaseClockFieldNumber = 2;
  inline ::google::protobuf::uint32 vga1_phase_clock() const;
  inline void set_vga1_phase_clock(::google::protobuf::uint32 value);

  // optional int32 vga1_image_offset = 3;
  inline bool has_vga1_image_offset() const;
  inline void clear_vga1_image_offset();
  static const int kVga1ImageOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 vga1_image_offset() const;
  inline void set_vga1_image_offset(::google::protobuf::int32 value);

  // optional bool vga2_filter_state = 4;
  inline bool has_vga2_filter_state() const;
  inline void clear_vga2_filter_state();
  static const int kVga2FilterStateFieldNumber = 4;
  inline bool vga2_filter_state() const;
  inline void set_vga2_filter_state(bool value);

  // optional uint32 vga2_phase_clock = 5;
  inline bool has_vga2_phase_clock() const;
  inline void clear_vga2_phase_clock();
  static const int kVga2PhaseClockFieldNumber = 5;
  inline ::google::protobuf::uint32 vga2_phase_clock() const;
  inline void set_vga2_phase_clock(::google::protobuf::uint32 value);

  // optional int32 vga2_image_offset = 6;
  inline bool has_vga2_image_offset() const;
  inline void clear_vga2_image_offset();
  static const int kVga2ImageOffsetFieldNumber = 6;
  inline ::google::protobuf::int32 vga2_image_offset() const;
  inline void set_vga2_image_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTVgaImageAdjustCfg)
 private:
  inline void set_has_vga1_filter_state();
  inline void clear_has_vga1_filter_state();
  inline void set_has_vga1_phase_clock();
  inline void clear_has_vga1_phase_clock();
  inline void set_has_vga1_image_offset();
  inline void clear_has_vga1_image_offset();
  inline void set_has_vga2_filter_state();
  inline void clear_has_vga2_filter_state();
  inline void set_has_vga2_phase_clock();
  inline void clear_has_vga2_phase_clock();
  inline void set_has_vga2_image_offset();
  inline void clear_has_vga2_image_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 vga1_phase_clock_;
  bool vga1_filter_state_;
  bool vga2_filter_state_;
  ::google::protobuf::int32 vga1_image_offset_;
  ::google::protobuf::uint32 vga2_phase_clock_;
  ::google::protobuf::int32 vga2_image_offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVgaImageAdjustCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoSrcTag : public ::google::protobuf::Message {
 public:
  TMTVideoSrcTag();
  virtual ~TMTVideoSrcTag();

  TMTVideoSrcTag(const TMTVideoSrcTag& from);

  inline TMTVideoSrcTag& operator=(const TMTVideoSrcTag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoSrcTag& default_instance();

  void Swap(TMTVideoSrcTag* other);

  // implements Message ----------------------------------------------

  TMTVideoSrcTag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoSrcTag& from);
  void MergeFrom(const TMTVideoSrcTag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtVideoPort video_port_id = 1;
  inline bool has_video_port_id() const;
  inline void clear_video_port_id();
  static const int kVideoPortIdFieldNumber = 1;
  inline ::mt::EmMtVideoPort video_port_id() const;
  inline void set_video_port_id(::mt::EmMtVideoPort value);

  // optional string video_port_tag = 2;
  inline bool has_video_port_tag() const;
  inline void clear_video_port_tag();
  static const int kVideoPortTagFieldNumber = 2;
  inline const ::std::string& video_port_tag() const;
  inline void set_video_port_tag(const ::std::string& value);
  inline void set_video_port_tag(const char* value);
  inline void set_video_port_tag(const char* value, size_t size);
  inline ::std::string* mutable_video_port_tag();
  inline ::std::string* release_video_port_tag();
  inline void set_allocated_video_port_tag(::std::string* video_port_tag);

  // @@protoc_insertion_point(class_scope:mt.TMTVideoSrcTag)
 private:
  inline void set_has_video_port_id();
  inline void clear_has_video_port_id();
  inline void set_has_video_port_tag();
  inline void clear_has_video_port_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* video_port_tag_;
  int video_port_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoSrcTag* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoSrcTagList : public ::google::protobuf::Message {
 public:
  TMTVideoSrcTagList();
  virtual ~TMTVideoSrcTagList();

  TMTVideoSrcTagList(const TMTVideoSrcTagList& from);

  inline TMTVideoSrcTagList& operator=(const TMTVideoSrcTagList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoSrcTagList& default_instance();

  void Swap(TMTVideoSrcTagList* other);

  // implements Message ----------------------------------------------

  TMTVideoSrcTagList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoSrcTagList& from);
  void MergeFrom(const TMTVideoSrcTagList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTVideoSrcTag video_tag_list = 1;
  inline int video_tag_list_size() const;
  inline void clear_video_tag_list();
  static const int kVideoTagListFieldNumber = 1;
  inline const ::mt::TMTVideoSrcTag& video_tag_list(int index) const;
  inline ::mt::TMTVideoSrcTag* mutable_video_tag_list(int index);
  inline ::mt::TMTVideoSrcTag* add_video_tag_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoSrcTag >&
      video_tag_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoSrcTag >*
      mutable_video_tag_list();

  // @@protoc_insertion_point(class_scope:mt.TMTVideoSrcTagList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoSrcTag > video_tag_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoSrcTagList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoOutTag : public ::google::protobuf::Message {
 public:
  TMTVideoOutTag();
  virtual ~TMTVideoOutTag();

  TMTVideoOutTag(const TMTVideoOutTag& from);

  inline TMTVideoOutTag& operator=(const TMTVideoOutTag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoOutTag& default_instance();

  void Swap(TMTVideoOutTag* other);

  // implements Message ----------------------------------------------

  TMTVideoOutTag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoOutTag& from);
  void MergeFrom(const TMTVideoOutTag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmHDVideoOutPortType video_port_id = 1;
  inline bool has_video_port_id() const;
  inline void clear_video_port_id();
  static const int kVideoPortIdFieldNumber = 1;
  inline ::mt::EmHDVideoOutPortType video_port_id() const;
  inline void set_video_port_id(::mt::EmHDVideoOutPortType value);

  // optional string video_port_tag = 2;
  inline bool has_video_port_tag() const;
  inline void clear_video_port_tag();
  static const int kVideoPortTagFieldNumber = 2;
  inline const ::std::string& video_port_tag() const;
  inline void set_video_port_tag(const ::std::string& value);
  inline void set_video_port_tag(const char* value);
  inline void set_video_port_tag(const char* value, size_t size);
  inline ::std::string* mutable_video_port_tag();
  inline ::std::string* release_video_port_tag();
  inline void set_allocated_video_port_tag(::std::string* video_port_tag);

  // @@protoc_insertion_point(class_scope:mt.TMTVideoOutTag)
 private:
  inline void set_has_video_port_id();
  inline void clear_has_video_port_id();
  inline void set_has_video_port_tag();
  inline void clear_has_video_port_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* video_port_tag_;
  int video_port_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoOutTag* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoOutTagList : public ::google::protobuf::Message {
 public:
  TMTVideoOutTagList();
  virtual ~TMTVideoOutTagList();

  TMTVideoOutTagList(const TMTVideoOutTagList& from);

  inline TMTVideoOutTagList& operator=(const TMTVideoOutTagList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoOutTagList& default_instance();

  void Swap(TMTVideoOutTagList* other);

  // implements Message ----------------------------------------------

  TMTVideoOutTagList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoOutTagList& from);
  void MergeFrom(const TMTVideoOutTagList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTVideoOutTag video_tag_list = 1;
  inline int video_tag_list_size() const;
  inline void clear_video_tag_list();
  static const int kVideoTagListFieldNumber = 1;
  inline const ::mt::TMTVideoOutTag& video_tag_list(int index) const;
  inline ::mt::TMTVideoOutTag* mutable_video_tag_list(int index);
  inline ::mt::TMTVideoOutTag* add_video_tag_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoOutTag >&
      video_tag_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoOutTag >*
      mutable_video_tag_list();

  // @@protoc_insertion_point(class_scope:mt.TMTVideoOutTagList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoOutTag > video_tag_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoOutTagList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTSnapShotFtpCfg : public ::google::protobuf::Message {
 public:
  TMTSnapShotFtpCfg();
  virtual ~TMTSnapShotFtpCfg();

  TMTSnapShotFtpCfg(const TMTSnapShotFtpCfg& from);

  inline TMTSnapShotFtpCfg& operator=(const TMTSnapShotFtpCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTSnapShotFtpCfg& default_instance();

  void Swap(TMTSnapShotFtpCfg* other);

  // implements Message ----------------------------------------------

  TMTSnapShotFtpCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTSnapShotFtpCfg& from);
  void MergeFrom(const TMTSnapShotFtpCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_enable = 1;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 1;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional uint32 ip_addr = 2;
  inline bool has_ip_addr() const;
  inline void clear_ip_addr();
  static const int kIpAddrFieldNumber = 2;
  inline ::google::protobuf::uint32 ip_addr() const;
  inline void set_ip_addr(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string upload_path = 4;
  inline bool has_upload_path() const;
  inline void clear_upload_path();
  static const int kUploadPathFieldNumber = 4;
  inline const ::std::string& upload_path() const;
  inline void set_upload_path(const ::std::string& value);
  inline void set_upload_path(const char* value);
  inline void set_upload_path(const char* value, size_t size);
  inline ::std::string* mutable_upload_path();
  inline ::std::string* release_upload_path();
  inline void set_allocated_upload_path(::std::string* upload_path);

  // optional string username = 5;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 5;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:mt.TMTSnapShotFtpCfg)
 private:
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_ip_addr();
  inline void clear_has_ip_addr();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_upload_path();
  inline void clear_has_upload_path();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_enable_;
  ::google::protobuf::uint32 ip_addr_;
  ::std::string* upload_path_;
  ::std::string* username_;
  ::std::string* password_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTSnapShotFtpCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TServiceInfo : public ::google::protobuf::Message {
 public:
  TServiceInfo();
  virtual ~TServiceInfo();

  TServiceInfo(const TServiceInfo& from);

  inline TServiceInfo& operator=(const TServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TServiceInfo& default_instance();

  void Swap(TServiceInfo* other);

  // implements Message ----------------------------------------------

  TServiceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TServiceInfo& from);
  void MergeFrom(const TServiceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 mtaid = 2;
  inline bool has_mtaid() const;
  inline void clear_mtaid();
  static const int kMtaidFieldNumber = 2;
  inline ::google::protobuf::uint32 mtaid() const;
  inline void set_mtaid(::google::protobuf::uint32 value);

  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string sysalias = 4;
  inline bool has_sysalias() const;
  inline void clear_sysalias();
  static const int kSysaliasFieldNumber = 4;
  inline const ::std::string& sysalias() const;
  inline void set_sysalias(const ::std::string& value);
  inline void set_sysalias(const char* value);
  inline void set_sysalias(const char* value, size_t size);
  inline ::std::string* mutable_sysalias();
  inline ::std::string* release_sysalias();
  inline void set_allocated_sysalias(::std::string* sysalias);

  // optional .mt.EmMtSysStartMod startmod = 5;
  inline bool has_startmod() const;
  inline void clear_startmod();
  static const int kStartmodFieldNumber = 5;
  inline ::mt::EmMtSysStartMod startmod() const;
  inline void set_startmod(::mt::EmMtSysStartMod value);

  // optional string srtfuncname = 6;
  inline bool has_srtfuncname() const;
  inline void clear_srtfuncname();
  static const int kSrtfuncnameFieldNumber = 6;
  inline const ::std::string& srtfuncname() const;
  inline void set_srtfuncname(const ::std::string& value);
  inline void set_srtfuncname(const char* value);
  inline void set_srtfuncname(const char* value, size_t size);
  inline ::std::string* mutable_srtfuncname();
  inline ::std::string* release_srtfuncname();
  inline void set_allocated_srtfuncname(::std::string* srtfuncname);

  // optional string endfuncname = 7;
  inline bool has_endfuncname() const;
  inline void clear_endfuncname();
  static const int kEndfuncnameFieldNumber = 7;
  inline const ::std::string& endfuncname() const;
  inline void set_endfuncname(const ::std::string& value);
  inline void set_endfuncname(const char* value);
  inline void set_endfuncname(const char* value, size_t size);
  inline ::std::string* mutable_endfuncname();
  inline ::std::string* release_endfuncname();
  inline void set_allocated_endfuncname(::std::string* endfuncname);

  // optional .mt.EmMtSysSrvState srvstate = 8;
  inline bool has_srvstate() const;
  inline void clear_srvstate();
  static const int kSrvstateFieldNumber = 8;
  inline ::mt::EmMtSysSrvState srvstate() const;
  inline void set_srvstate(::mt::EmMtSysSrvState value);

  // optional .mt.EmMtSysKeepLiveState srvklstate = 9;
  inline bool has_srvklstate() const;
  inline void clear_srvklstate();
  static const int kSrvklstateFieldNumber = 9;
  inline ::mt::EmMtSysKeepLiveState srvklstate() const;
  inline void set_srvklstate(::mt::EmMtSysKeepLiveState value);

  // optional uint32 time = 10;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 11;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 11;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 dllhandler = 12;
  inline bool has_dllhandler() const;
  inline void clear_dllhandler();
  static const int kDllhandlerFieldNumber = 12;
  inline ::google::protobuf::uint32 dllhandler() const;
  inline void set_dllhandler(::google::protobuf::uint32 value);

  // optional uint32 processpid = 13;
  inline bool has_processpid() const;
  inline void clear_processpid();
  static const int kProcesspidFieldNumber = 13;
  inline ::google::protobuf::uint32 processpid() const;
  inline void set_processpid(::google::protobuf::uint32 value);

  // optional string version = 14;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 14;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mt.TServiceInfo)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_mtaid();
  inline void clear_has_mtaid();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_sysalias();
  inline void clear_has_sysalias();
  inline void set_has_startmod();
  inline void clear_has_startmod();
  inline void set_has_srtfuncname();
  inline void clear_has_srtfuncname();
  inline void set_has_endfuncname();
  inline void clear_has_endfuncname();
  inline void set_has_srvstate();
  inline void clear_has_srvstate();
  inline void set_has_srvklstate();
  inline void clear_has_srvklstate();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_dllhandler();
  inline void clear_has_dllhandler();
  inline void set_has_processpid();
  inline void clear_has_processpid();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 mtaid_;
  ::std::string* path_;
  ::std::string* sysalias_;
  ::std::string* srtfuncname_;
  int startmod_;
  int srvstate_;
  ::std::string* endfuncname_;
  int srvklstate_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 dllhandler_;
  ::std::string* version_;
  ::google::protobuf::uint32 processpid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TServiceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TServiceInfoFromUI : public ::google::protobuf::Message {
 public:
  TServiceInfoFromUI();
  virtual ~TServiceInfoFromUI();

  TServiceInfoFromUI(const TServiceInfoFromUI& from);

  inline TServiceInfoFromUI& operator=(const TServiceInfoFromUI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TServiceInfoFromUI& default_instance();

  void Swap(TServiceInfoFromUI* other);

  // implements Message ----------------------------------------------

  TServiceInfoFromUI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TServiceInfoFromUI& from);
  void MergeFrom(const TServiceInfoFromUI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 mtaid = 1;
  inline bool has_mtaid() const;
  inline void clear_mtaid();
  static const int kMtaidFieldNumber = 1;
  inline ::google::protobuf::uint32 mtaid() const;
  inline void set_mtaid(::google::protobuf::uint32 value);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string sysalias = 3;
  inline bool has_sysalias() const;
  inline void clear_sysalias();
  static const int kSysaliasFieldNumber = 3;
  inline const ::std::string& sysalias() const;
  inline void set_sysalias(const ::std::string& value);
  inline void set_sysalias(const char* value);
  inline void set_sysalias(const char* value, size_t size);
  inline ::std::string* mutable_sysalias();
  inline ::std::string* release_sysalias();
  inline void set_allocated_sysalias(::std::string* sysalias);

  // optional .mt.EmMtSysStartModFromUI startmod = 4;
  inline bool has_startmod() const;
  inline void clear_startmod();
  static const int kStartmodFieldNumber = 4;
  inline ::mt::EmMtSysStartModFromUI startmod() const;
  inline void set_startmod(::mt::EmMtSysStartModFromUI value);

  // optional string srtfuncname = 5;
  inline bool has_srtfuncname() const;
  inline void clear_srtfuncname();
  static const int kSrtfuncnameFieldNumber = 5;
  inline const ::std::string& srtfuncname() const;
  inline void set_srtfuncname(const ::std::string& value);
  inline void set_srtfuncname(const char* value);
  inline void set_srtfuncname(const char* value, size_t size);
  inline ::std::string* mutable_srtfuncname();
  inline ::std::string* release_srtfuncname();
  inline void set_allocated_srtfuncname(::std::string* srtfuncname);

  // optional string endfuncname = 6;
  inline bool has_endfuncname() const;
  inline void clear_endfuncname();
  static const int kEndfuncnameFieldNumber = 6;
  inline const ::std::string& endfuncname() const;
  inline void set_endfuncname(const ::std::string& value);
  inline void set_endfuncname(const char* value);
  inline void set_endfuncname(const char* value, size_t size);
  inline ::std::string* mutable_endfuncname();
  inline ::std::string* release_endfuncname();
  inline void set_allocated_endfuncname(::std::string* endfuncname);

  // @@protoc_insertion_point(class_scope:mt.TServiceInfoFromUI)
 private:
  inline void set_has_mtaid();
  inline void clear_has_mtaid();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_sysalias();
  inline void clear_has_sysalias();
  inline void set_has_startmod();
  inline void clear_has_startmod();
  inline void set_has_srtfuncname();
  inline void clear_has_srtfuncname();
  inline void set_has_endfuncname();
  inline void clear_has_endfuncname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  ::google::protobuf::uint32 mtaid_;
  int startmod_;
  ::std::string* sysalias_;
  ::std::string* srtfuncname_;
  ::std::string* endfuncname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TServiceInfoFromUI* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TServiceDefInfo : public ::google::protobuf::Message {
 public:
  TServiceDefInfo();
  virtual ~TServiceDefInfo();

  TServiceDefInfo(const TServiceDefInfo& from);

  inline TServiceDefInfo& operator=(const TServiceDefInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TServiceDefInfo& default_instance();

  void Swap(TServiceDefInfo* other);

  // implements Message ----------------------------------------------

  TServiceDefInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TServiceDefInfo& from);
  void MergeFrom(const TServiceDefInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string sysalias = 3;
  inline bool has_sysalias() const;
  inline void clear_sysalias();
  static const int kSysaliasFieldNumber = 3;
  inline const ::std::string& sysalias() const;
  inline void set_sysalias(const ::std::string& value);
  inline void set_sysalias(const char* value);
  inline void set_sysalias(const char* value, size_t size);
  inline ::std::string* mutable_sysalias();
  inline ::std::string* release_sysalias();
  inline void set_allocated_sysalias(::std::string* sysalias);

  // optional .mt.EmMtSysStartMod startmod = 4;
  inline bool has_startmod() const;
  inline void clear_startmod();
  static const int kStartmodFieldNumber = 4;
  inline ::mt::EmMtSysStartMod startmod() const;
  inline void set_startmod(::mt::EmMtSysStartMod value);

  // optional string srtfuncname = 5;
  inline bool has_srtfuncname() const;
  inline void clear_srtfuncname();
  static const int kSrtfuncnameFieldNumber = 5;
  inline const ::std::string& srtfuncname() const;
  inline void set_srtfuncname(const ::std::string& value);
  inline void set_srtfuncname(const char* value);
  inline void set_srtfuncname(const char* value, size_t size);
  inline ::std::string* mutable_srtfuncname();
  inline ::std::string* release_srtfuncname();
  inline void set_allocated_srtfuncname(::std::string* srtfuncname);

  // optional string endfuncname = 6;
  inline bool has_endfuncname() const;
  inline void clear_endfuncname();
  static const int kEndfuncnameFieldNumber = 6;
  inline const ::std::string& endfuncname() const;
  inline void set_endfuncname(const ::std::string& value);
  inline void set_endfuncname(const char* value);
  inline void set_endfuncname(const char* value, size_t size);
  inline ::std::string* mutable_endfuncname();
  inline ::std::string* release_endfuncname();
  inline void set_allocated_endfuncname(::std::string* endfuncname);

  // @@protoc_insertion_point(class_scope:mt.TServiceDefInfo)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_sysalias();
  inline void clear_has_sysalias();
  inline void set_has_startmod();
  inline void clear_has_startmod();
  inline void set_has_srtfuncname();
  inline void clear_has_srtfuncname();
  inline void set_has_endfuncname();
  inline void clear_has_endfuncname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  ::google::protobuf::uint32 index_;
  int startmod_;
  ::std::string* sysalias_;
  ::std::string* srtfuncname_;
  ::std::string* endfuncname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TServiceDefInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TSrvKeepLiveInfo : public ::google::protobuf::Message {
 public:
  TSrvKeepLiveInfo();
  virtual ~TSrvKeepLiveInfo();

  TSrvKeepLiveInfo(const TSrvKeepLiveInfo& from);

  inline TSrvKeepLiveInfo& operator=(const TSrvKeepLiveInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSrvKeepLiveInfo& default_instance();

  void Swap(TSrvKeepLiveInfo* other);

  // implements Message ----------------------------------------------

  TSrvKeepLiveInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSrvKeepLiveInfo& from);
  void MergeFrom(const TSrvKeepLiveInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sysalias = 1;
  inline bool has_sysalias() const;
  inline void clear_sysalias();
  static const int kSysaliasFieldNumber = 1;
  inline const ::std::string& sysalias() const;
  inline void set_sysalias(const ::std::string& value);
  inline void set_sysalias(const char* value);
  inline void set_sysalias(const char* value, size_t size);
  inline ::std::string* mutable_sysalias();
  inline ::std::string* release_sysalias();
  inline void set_allocated_sysalias(::std::string* sysalias);

  // optional uint32 mtaid = 2;
  inline bool has_mtaid() const;
  inline void clear_mtaid();
  static const int kMtaidFieldNumber = 2;
  inline ::google::protobuf::uint32 mtaid() const;
  inline void set_mtaid(::google::protobuf::uint32 value);

  // optional uint32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TSrvKeepLiveInfo)
 private:
  inline void set_has_sysalias();
  inline void clear_has_sysalias();
  inline void set_has_mtaid();
  inline void clear_has_mtaid();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sysalias_;
  ::google::protobuf::uint32 mtaid_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TSrvKeepLiveInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMutiTServiceInfo : public ::google::protobuf::Message {
 public:
  TMutiTServiceInfo();
  virtual ~TMutiTServiceInfo();

  TMutiTServiceInfo(const TMutiTServiceInfo& from);

  inline TMutiTServiceInfo& operator=(const TMutiTServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMutiTServiceInfo& default_instance();

  void Swap(TMutiTServiceInfo* other);

  // implements Message ----------------------------------------------

  TMutiTServiceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMutiTServiceInfo& from);
  void MergeFrom(const TMutiTServiceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TServiceInfoFromUI tServiceInfo = 1;
  inline int tserviceinfo_size() const;
  inline void clear_tserviceinfo();
  static const int kTServiceInfoFieldNumber = 1;
  inline const ::mt::TServiceInfoFromUI& tserviceinfo(int index) const;
  inline ::mt::TServiceInfoFromUI* mutable_tserviceinfo(int index);
  inline ::mt::TServiceInfoFromUI* add_tserviceinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TServiceInfoFromUI >&
      tserviceinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TServiceInfoFromUI >*
      mutable_tserviceinfo();

  // @@protoc_insertion_point(class_scope:mt.TMutiTServiceInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TServiceInfoFromUI > tserviceinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMutiTServiceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMutiTServiceInfoRtData : public ::google::protobuf::Message {
 public:
  TMutiTServiceInfoRtData();
  virtual ~TMutiTServiceInfoRtData();

  TMutiTServiceInfoRtData(const TMutiTServiceInfoRtData& from);

  inline TMutiTServiceInfoRtData& operator=(const TMutiTServiceInfoRtData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMutiTServiceInfoRtData& default_instance();

  void Swap(TMutiTServiceInfoRtData* other);

  // implements Message ----------------------------------------------

  TMutiTServiceInfoRtData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMutiTServiceInfoRtData& from);
  void MergeFrom(const TMutiTServiceInfoRtData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TServiceInfo tServiceInfo = 1;
  inline int tserviceinfo_size() const;
  inline void clear_tserviceinfo();
  static const int kTServiceInfoFieldNumber = 1;
  inline const ::mt::TServiceInfo& tserviceinfo(int index) const;
  inline ::mt::TServiceInfo* mutable_tserviceinfo(int index);
  inline ::mt::TServiceInfo* add_tserviceinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TServiceInfo >&
      tserviceinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TServiceInfo >*
      mutable_tserviceinfo();

  // @@protoc_insertion_point(class_scope:mt.TMutiTServiceInfoRtData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TServiceInfo > tserviceinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMutiTServiceInfoRtData* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMutiTServiceDefInfo : public ::google::protobuf::Message {
 public:
  TMutiTServiceDefInfo();
  virtual ~TMutiTServiceDefInfo();

  TMutiTServiceDefInfo(const TMutiTServiceDefInfo& from);

  inline TMutiTServiceDefInfo& operator=(const TMutiTServiceDefInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMutiTServiceDefInfo& default_instance();

  void Swap(TMutiTServiceDefInfo* other);

  // implements Message ----------------------------------------------

  TMutiTServiceDefInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMutiTServiceDefInfo& from);
  void MergeFrom(const TMutiTServiceDefInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TServiceDefInfo tServiceDefInfo = 1;
  inline int tservicedefinfo_size() const;
  inline void clear_tservicedefinfo();
  static const int kTServiceDefInfoFieldNumber = 1;
  inline const ::mt::TServiceDefInfo& tservicedefinfo(int index) const;
  inline ::mt::TServiceDefInfo* mutable_tservicedefinfo(int index);
  inline ::mt::TServiceDefInfo* add_tservicedefinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TServiceDefInfo >&
      tservicedefinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TServiceDefInfo >*
      mutable_tservicedefinfo();

  // @@protoc_insertion_point(class_scope:mt.TMutiTServiceDefInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TServiceDefInfo > tservicedefinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMutiTServiceDefInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TUserFullInfo : public ::google::protobuf::Message {
 public:
  TUserFullInfo();
  virtual ~TUserFullInfo();

  TUserFullInfo(const TUserFullInfo& from);

  inline TUserFullInfo& operator=(const TUserFullInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TUserFullInfo& default_instance();

  void Swap(TUserFullInfo* other);

  // implements Message ----------------------------------------------

  TUserFullInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TUserFullInfo& from);
  void MergeFrom(const TUserFullInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 guid() const;
  inline void set_guid(::google::protobuf::uint32 value);

  // optional .mt.EmMtcType mtc_type = 2;
  inline bool has_mtc_type() const;
  inline void clear_mtc_type();
  static const int kMtcTypeFieldNumber = 2;
  inline ::mt::EmMtcType mtc_type() const;
  inline void set_mtc_type(::mt::EmMtcType value);

  // optional string user_name = 3;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional uint32 actor = 5;
  inline bool has_actor() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 5;
  inline ::google::protobuf::uint32 actor() const;
  inline void set_actor(::google::protobuf::uint32 value);

  // optional string full_user_name = 6;
  inline bool has_full_user_name() const;
  inline void clear_full_user_name();
  static const int kFullUserNameFieldNumber = 6;
  inline const ::std::string& full_user_name() const;
  inline void set_full_user_name(const ::std::string& value);
  inline void set_full_user_name(const char* value);
  inline void set_full_user_name(const char* value, size_t size);
  inline ::std::string* mutable_full_user_name();
  inline ::std::string* release_full_user_name();
  inline void set_allocated_full_user_name(::std::string* full_user_name);

  // optional string user_discription = 7;
  inline bool has_user_discription() const;
  inline void clear_user_discription();
  static const int kUserDiscriptionFieldNumber = 7;
  inline const ::std::string& user_discription() const;
  inline void set_user_discription(const ::std::string& value);
  inline void set_user_discription(const char* value);
  inline void set_user_discription(const char* value, size_t size);
  inline ::std::string* mutable_user_discription();
  inline ::std::string* release_user_discription();
  inline void set_allocated_user_discription(::std::string* user_discription);

  // @@protoc_insertion_point(class_scope:mt.TUserFullInfo)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_mtc_type();
  inline void clear_has_mtc_type();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_actor();
  inline void clear_has_actor();
  inline void set_has_full_user_name();
  inline void clear_has_full_user_name();
  inline void set_has_user_discription();
  inline void clear_has_user_discription();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 guid_;
  int mtc_type_;
  ::std::string* user_name_;
  ::std::string* password_;
  ::std::string* full_user_name_;
  ::std::string* user_discription_;
  ::google::protobuf::uint32 actor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TUserFullInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TUserReqResult : public ::google::protobuf::Message {
 public:
  TUserReqResult();
  virtual ~TUserReqResult();

  TUserReqResult(const TUserReqResult& from);

  inline TUserReqResult& operator=(const TUserReqResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TUserReqResult& default_instance();

  void Swap(TUserReqResult* other);

  // implements Message ----------------------------------------------

  TUserReqResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TUserReqResult& from);
  void MergeFrom(const TUserReqResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TUserFullInfo user_info = 1;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::mt::TUserFullInfo& user_info() const;
  inline ::mt::TUserFullInfo* mutable_user_info();
  inline ::mt::TUserFullInfo* release_user_info();
  inline void set_allocated_user_info(::mt::TUserFullInfo* user_info);

  // optional uint32 user_req_result = 2;
  inline bool has_user_req_result() const;
  inline void clear_user_req_result();
  static const int kUserReqResultFieldNumber = 2;
  inline ::google::protobuf::uint32 user_req_result() const;
  inline void set_user_req_result(::google::protobuf::uint32 value);

  // optional uint32 user_login_error_count = 3;
  inline bool has_user_login_error_count() const;
  inline void clear_user_login_error_count();
  static const int kUserLoginErrorCountFieldNumber = 3;
  inline ::google::protobuf::uint32 user_login_error_count() const;
  inline void set_user_login_error_count(::google::protobuf::uint32 value);

  // optional uint32 user_login_time = 4;
  inline bool has_user_login_time() const;
  inline void clear_user_login_time();
  static const int kUserLoginTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 user_login_time() const;
  inline void set_user_login_time(::google::protobuf::uint32 value);

  // optional bool user_is_exist = 5;
  inline bool has_user_is_exist() const;
  inline void clear_user_is_exist();
  static const int kUserIsExistFieldNumber = 5;
  inline bool user_is_exist() const;
  inline void set_user_is_exist(bool value);

  // @@protoc_insertion_point(class_scope:mt.TUserReqResult)
 private:
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_user_req_result();
  inline void clear_has_user_req_result();
  inline void set_has_user_login_error_count();
  inline void clear_has_user_login_error_count();
  inline void set_has_user_login_time();
  inline void clear_has_user_login_time();
  inline void set_has_user_is_exist();
  inline void clear_has_user_is_exist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TUserFullInfo* user_info_;
  ::google::protobuf::uint32 user_req_result_;
  ::google::protobuf::uint32 user_login_error_count_;
  ::google::protobuf::uint32 user_login_time_;
  bool user_is_exist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TUserReqResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMultiUserFullInfo : public ::google::protobuf::Message {
 public:
  TMultiUserFullInfo();
  virtual ~TMultiUserFullInfo();

  TMultiUserFullInfo(const TMultiUserFullInfo& from);

  inline TMultiUserFullInfo& operator=(const TMultiUserFullInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMultiUserFullInfo& default_instance();

  void Swap(TMultiUserFullInfo* other);

  // implements Message ----------------------------------------------

  TMultiUserFullInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMultiUserFullInfo& from);
  void MergeFrom(const TMultiUserFullInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TUserFullInfo multi_user_info = 1;
  inline int multi_user_info_size() const;
  inline void clear_multi_user_info();
  static const int kMultiUserInfoFieldNumber = 1;
  inline const ::mt::TUserFullInfo& multi_user_info(int index) const;
  inline ::mt::TUserFullInfo* mutable_multi_user_info(int index);
  inline ::mt::TUserFullInfo* add_multi_user_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TUserFullInfo >&
      multi_user_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TUserFullInfo >*
      mutable_multi_user_info();

  // @@protoc_insertion_point(class_scope:mt.TMultiUserFullInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TUserFullInfo > multi_user_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMultiUserFullInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMultiUserReqResult : public ::google::protobuf::Message {
 public:
  TMultiUserReqResult();
  virtual ~TMultiUserReqResult();

  TMultiUserReqResult(const TMultiUserReqResult& from);

  inline TMultiUserReqResult& operator=(const TMultiUserReqResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMultiUserReqResult& default_instance();

  void Swap(TMultiUserReqResult* other);

  // implements Message ----------------------------------------------

  TMultiUserReqResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMultiUserReqResult& from);
  void MergeFrom(const TMultiUserReqResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TUserReqResult multi_user_req_result = 1;
  inline int multi_user_req_result_size() const;
  inline void clear_multi_user_req_result();
  static const int kMultiUserReqResultFieldNumber = 1;
  inline const ::mt::TUserReqResult& multi_user_req_result(int index) const;
  inline ::mt::TUserReqResult* mutable_multi_user_req_result(int index);
  inline ::mt::TUserReqResult* add_multi_user_req_result();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TUserReqResult >&
      multi_user_req_result() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TUserReqResult >*
      mutable_multi_user_req_result();

  // @@protoc_insertion_point(class_scope:mt.TMultiUserReqResult)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TUserReqResult > multi_user_req_result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMultiUserReqResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTNetBandWidth : public ::google::protobuf::Message {
 public:
  TMTNetBandWidth();
  virtual ~TMTNetBandWidth();

  TMTNetBandWidth(const TMTNetBandWidth& from);

  inline TMTNetBandWidth& operator=(const TMTNetBandWidth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTNetBandWidth& default_instance();

  void Swap(TMTNetBandWidth* other);

  // implements Message ----------------------------------------------

  TMTNetBandWidth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTNetBandWidth& from);
  void MergeFrom(const TMTNetBandWidth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 band_width = 1;
  inline bool has_band_width() const;
  inline void clear_band_width();
  static const int kBandWidthFieldNumber = 1;
  inline ::google::protobuf::uint32 band_width() const;
  inline void set_band_width(::google::protobuf::uint32 value);

  // optional uint32 drop_rate = 2;
  inline bool has_drop_rate() const;
  inline void clear_drop_rate();
  static const int kDropRateFieldNumber = 2;
  inline ::google::protobuf::uint32 drop_rate() const;
  inline void set_drop_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTNetBandWidth)
 private:
  inline void set_has_band_width();
  inline void clear_has_band_width();
  inline void set_has_drop_rate();
  inline void clear_has_drop_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 band_width_;
  ::google::protobuf::uint32 drop_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTNetBandWidth* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTNetStatus : public ::google::protobuf::Message {
 public:
  TMTNetStatus();
  virtual ~TMTNetStatus();

  TMTNetStatus(const TMTNetStatus& from);

  inline TMTNetStatus& operator=(const TMTNetStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTNetStatus& default_instance();

  void Swap(TMTNetStatus* other);

  // implements Message ----------------------------------------------

  TMTNetStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTNetStatus& from);
  void MergeFrom(const TMTNetStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_timeout = 1;
  inline bool has_is_timeout() const;
  inline void clear_is_timeout();
  static const int kIsTimeoutFieldNumber = 1;
  inline bool is_timeout() const;
  inline void set_is_timeout(bool value);

  // optional .mt.TMTNetBandWidth up_bandwidth_info = 2;
  inline bool has_up_bandwidth_info() const;
  inline void clear_up_bandwidth_info();
  static const int kUpBandwidthInfoFieldNumber = 2;
  inline const ::mt::TMTNetBandWidth& up_bandwidth_info() const;
  inline ::mt::TMTNetBandWidth* mutable_up_bandwidth_info();
  inline ::mt::TMTNetBandWidth* release_up_bandwidth_info();
  inline void set_allocated_up_bandwidth_info(::mt::TMTNetBandWidth* up_bandwidth_info);

  // optional .mt.TMTNetBandWidth down_bandwidth_info = 3;
  inline bool has_down_bandwidth_info() const;
  inline void clear_down_bandwidth_info();
  static const int kDownBandwidthInfoFieldNumber = 3;
  inline const ::mt::TMTNetBandWidth& down_bandwidth_info() const;
  inline ::mt::TMTNetBandWidth* mutable_down_bandwidth_info();
  inline ::mt::TMTNetBandWidth* release_down_bandwidth_info();
  inline void set_allocated_down_bandwidth_info(::mt::TMTNetBandWidth* down_bandwidth_info);

  // @@protoc_insertion_point(class_scope:mt.TMTNetStatus)
 private:
  inline void set_has_is_timeout();
  inline void clear_has_is_timeout();
  inline void set_has_up_bandwidth_info();
  inline void clear_has_up_bandwidth_info();
  inline void set_has_down_bandwidth_info();
  inline void clear_has_down_bandwidth_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTNetBandWidth* up_bandwidth_info_;
  ::mt::TMTNetBandWidth* down_bandwidth_info_;
  bool is_timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTNetStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPortPairInfo : public ::google::protobuf::Message {
 public:
  TMTPortPairInfo();
  virtual ~TMTPortPairInfo();

  TMTPortPairInfo(const TMTPortPairInfo& from);

  inline TMTPortPairInfo& operator=(const TMTPortPairInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPortPairInfo& default_instance();

  void Swap(TMTPortPairInfo* other);

  // implements Message ----------------------------------------------

  TMTPortPairInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPortPairInfo& from);
  void MergeFrom(const TMTPortPairInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 port_one = 1;
  inline bool has_port_one() const;
  inline void clear_port_one();
  static const int kPortOneFieldNumber = 1;
  inline ::google::protobuf::uint32 port_one() const;
  inline void set_port_one(::google::protobuf::uint32 value);

  // optional uint32 port_two = 2;
  inline bool has_port_two() const;
  inline void clear_port_two();
  static const int kPortTwoFieldNumber = 2;
  inline ::google::protobuf::uint32 port_two() const;
  inline void set_port_two(::google::protobuf::uint32 value);

  // optional string describe = 3;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 3;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // @@protoc_insertion_point(class_scope:mt.TMTPortPairInfo)
 private:
  inline void set_has_port_one();
  inline void clear_has_port_one();
  inline void set_has_port_two();
  inline void clear_has_port_two();
  inline void set_has_describe();
  inline void clear_has_describe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 port_one_;
  ::google::protobuf::uint32 port_two_;
  ::std::string* describe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTPortPairInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPortPairAllocReqInfo : public ::google::protobuf::Message {
 public:
  TMTPortPairAllocReqInfo();
  virtual ~TMTPortPairAllocReqInfo();

  TMTPortPairAllocReqInfo(const TMTPortPairAllocReqInfo& from);

  inline TMTPortPairAllocReqInfo& operator=(const TMTPortPairAllocReqInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPortPairAllocReqInfo& default_instance();

  void Swap(TMTPortPairAllocReqInfo* other);

  // implements Message ----------------------------------------------

  TMTPortPairAllocReqInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPortPairAllocReqInfo& from);
  void MergeFrom(const TMTPortPairAllocReqInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_tcp_port = 1;
  inline bool has_is_tcp_port() const;
  inline void clear_is_tcp_port();
  static const int kIsTcpPortFieldNumber = 1;
  inline bool is_tcp_port() const;
  inline void set_is_tcp_port(bool value);

  // optional uint32 port_pair_num = 2;
  inline bool has_port_pair_num() const;
  inline void clear_port_pair_num();
  static const int kPortPairNumFieldNumber = 2;
  inline ::google::protobuf::uint32 port_pair_num() const;
  inline void set_port_pair_num(::google::protobuf::uint32 value);

  // optional string describe = 3;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 3;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // @@protoc_insertion_point(class_scope:mt.TMTPortPairAllocReqInfo)
 private:
  inline void set_has_is_tcp_port();
  inline void clear_has_is_tcp_port();
  inline void set_has_port_pair_num();
  inline void clear_has_port_pair_num();
  inline void set_has_describe();
  inline void clear_has_describe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_tcp_port_;
  ::google::protobuf::uint32 port_pair_num_;
  ::std::string* describe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTPortPairAllocReqInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPortRangeAllocReqInfo : public ::google::protobuf::Message {
 public:
  TMTPortRangeAllocReqInfo();
  virtual ~TMTPortRangeAllocReqInfo();

  TMTPortRangeAllocReqInfo(const TMTPortRangeAllocReqInfo& from);

  inline TMTPortRangeAllocReqInfo& operator=(const TMTPortRangeAllocReqInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPortRangeAllocReqInfo& default_instance();

  void Swap(TMTPortRangeAllocReqInfo* other);

  // implements Message ----------------------------------------------

  TMTPortRangeAllocReqInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPortRangeAllocReqInfo& from);
  void MergeFrom(const TMTPortRangeAllocReqInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_tcp_port = 1;
  inline bool has_is_tcp_port() const;
  inline void clear_is_tcp_port();
  static const int kIsTcpPortFieldNumber = 1;
  inline bool is_tcp_port() const;
  inline void set_is_tcp_port(bool value);

  // optional uint32 port_num = 2;
  inline bool has_port_num() const;
  inline void clear_port_num();
  static const int kPortNumFieldNumber = 2;
  inline ::google::protobuf::uint32 port_num() const;
  inline void set_port_num(::google::protobuf::uint32 value);

  // optional bool is_from_even_bgning = 3;
  inline bool has_is_from_even_bgning() const;
  inline void clear_is_from_even_bgning();
  static const int kIsFromEvenBgningFieldNumber = 3;
  inline bool is_from_even_bgning() const;
  inline void set_is_from_even_bgning(bool value);

  // optional string describe = 4;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 4;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // @@protoc_insertion_point(class_scope:mt.TMTPortRangeAllocReqInfo)
 private:
  inline void set_has_is_tcp_port();
  inline void clear_has_is_tcp_port();
  inline void set_has_port_num();
  inline void clear_has_port_num();
  inline void set_has_is_from_even_bgning();
  inline void clear_has_is_from_even_bgning();
  inline void set_has_describe();
  inline void clear_has_describe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 port_num_;
  bool is_tcp_port_;
  bool is_from_even_bgning_;
  ::std::string* describe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTPortRangeAllocReqInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPortPairAllocRspInfo : public ::google::protobuf::Message {
 public:
  TMTPortPairAllocRspInfo();
  virtual ~TMTPortPairAllocRspInfo();

  TMTPortPairAllocRspInfo(const TMTPortPairAllocRspInfo& from);

  inline TMTPortPairAllocRspInfo& operator=(const TMTPortPairAllocRspInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPortPairAllocRspInfo& default_instance();

  void Swap(TMTPortPairAllocRspInfo* other);

  // implements Message ----------------------------------------------

  TMTPortPairAllocRspInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPortPairAllocRspInfo& from);
  void MergeFrom(const TMTPortPairAllocRspInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_ok = 1;
  inline bool has_is_ok() const;
  inline void clear_is_ok();
  static const int kIsOkFieldNumber = 1;
  inline bool is_ok() const;
  inline void set_is_ok(bool value);

  // repeated .mt.TMTPortPairInfo port_pair = 2;
  inline int port_pair_size() const;
  inline void clear_port_pair();
  static const int kPortPairFieldNumber = 2;
  inline const ::mt::TMTPortPairInfo& port_pair(int index) const;
  inline ::mt::TMTPortPairInfo* mutable_port_pair(int index);
  inline ::mt::TMTPortPairInfo* add_port_pair();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPortPairInfo >&
      port_pair() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPortPairInfo >*
      mutable_port_pair();

  // @@protoc_insertion_point(class_scope:mt.TMTPortPairAllocRspInfo)
 private:
  inline void set_has_is_ok();
  inline void clear_has_is_ok();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTPortPairInfo > port_pair_;
  bool is_ok_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTPortPairAllocRspInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPortRangeAllocRspInfo : public ::google::protobuf::Message {
 public:
  TMTPortRangeAllocRspInfo();
  virtual ~TMTPortRangeAllocRspInfo();

  TMTPortRangeAllocRspInfo(const TMTPortRangeAllocRspInfo& from);

  inline TMTPortRangeAllocRspInfo& operator=(const TMTPortRangeAllocRspInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPortRangeAllocRspInfo& default_instance();

  void Swap(TMTPortRangeAllocRspInfo* other);

  // implements Message ----------------------------------------------

  TMTPortRangeAllocRspInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPortRangeAllocRspInfo& from);
  void MergeFrom(const TMTPortRangeAllocRspInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_ok = 1;
  inline bool has_is_ok() const;
  inline void clear_is_ok();
  static const int kIsOkFieldNumber = 1;
  inline bool is_ok() const;
  inline void set_is_ok(bool value);

  // optional uint32 start_port = 2;
  inline bool has_start_port() const;
  inline void clear_start_port();
  static const int kStartPortFieldNumber = 2;
  inline ::google::protobuf::uint32 start_port() const;
  inline void set_start_port(::google::protobuf::uint32 value);

  // optional uint32 end_port = 3;
  inline bool has_end_port() const;
  inline void clear_end_port();
  static const int kEndPortFieldNumber = 3;
  inline ::google::protobuf::uint32 end_port() const;
  inline void set_end_port(::google::protobuf::uint32 value);

  // optional string describe = 4;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 4;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // @@protoc_insertion_point(class_scope:mt.TMTPortRangeAllocRspInfo)
 private:
  inline void set_has_is_ok();
  inline void clear_has_is_ok();
  inline void set_has_start_port();
  inline void clear_has_start_port();
  inline void set_has_end_port();
  inline void clear_has_end_port();
  inline void set_has_describe();
  inline void clear_has_describe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_ok_;
  ::google::protobuf::uint32 start_port_;
  ::std::string* describe_;
  ::google::protobuf::uint32 end_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTPortRangeAllocRspInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTSymboPoint : public ::google::protobuf::Message {
 public:
  TMTSymboPoint();
  virtual ~TMTSymboPoint();

  TMTSymboPoint(const TMTSymboPoint& from);

  inline TMTSymboPoint& operator=(const TMTSymboPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTSymboPoint& default_instance();

  void Swap(TMTSymboPoint* other);

  // implements Message ----------------------------------------------

  TMTSymboPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTSymboPoint& from);
  void MergeFrom(const TMTSymboPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // optional uint32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTSymboPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTSymboPoint* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTOsdCfg : public ::google::protobuf::Message {
 public:
  TMTOsdCfg();
  virtual ~TMTOsdCfg();

  TMTOsdCfg(const TMTOsdCfg& from);

  inline TMTOsdCfg& operator=(const TMTOsdCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTOsdCfg& default_instance();

  void Swap(TMTOsdCfg* other);

  // implements Message ----------------------------------------------

  TMTOsdCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTOsdCfg& from);
  void MergeFrom(const TMTOsdCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_auto_pip = 1;
  inline bool has_is_auto_pip() const;
  inline void clear_is_auto_pip();
  static const int kIsAutoPipFieldNumber = 1;
  inline bool is_auto_pip() const;
  inline void set_is_auto_pip(bool value);

  // optional bool is_show_conf_lapse = 2;
  inline bool has_is_show_conf_lapse() const;
  inline void clear_is_show_conf_lapse();
  static const int kIsShowConfLapseFieldNumber = 2;
  inline bool is_show_conf_lapse() const;
  inline void set_is_show_conf_lapse(bool value);

  // optional bool is_show_sys_time = 3;
  inline bool has_is_show_sys_time() const;
  inline void clear_is_show_sys_time();
  static const int kIsShowSysTimeFieldNumber = 3;
  inline bool is_show_sys_time() const;
  inline void set_is_show_sys_time(bool value);

  // optional bool is_show_state = 4;
  inline bool has_is_show_state() const;
  inline void clear_is_show_state();
  static const int kIsShowStateFieldNumber = 4;
  inline bool is_show_state() const;
  inline void set_is_show_state(bool value);

  // optional .mt.EmLabelType label_type = 5;
  inline bool has_label_type() const;
  inline void clear_label_type();
  static const int kLabelTypeFieldNumber = 5;
  inline ::mt::EmLabelType label_type() const;
  inline void set_label_type(::mt::EmLabelType value);

  // optional .mt.TMTSymboPoint label_coordinate = 6;
  inline bool has_label_coordinate() const;
  inline void clear_label_coordinate();
  static const int kLabelCoordinateFieldNumber = 6;
  inline const ::mt::TMTSymboPoint& label_coordinate() const;
  inline ::mt::TMTSymboPoint* mutable_label_coordinate();
  inline ::mt::TMTSymboPoint* release_label_coordinate();
  inline void set_allocated_label_coordinate(::mt::TMTSymboPoint* label_coordinate);

  // optional .mt.EmLabelPosType label_pos_type = 7;
  inline bool has_label_pos_type() const;
  inline void clear_label_pos_type();
  static const int kLabelPosTypeFieldNumber = 7;
  inline ::mt::EmLabelPosType label_pos_type() const;
  inline void set_label_pos_type(::mt::EmLabelPosType value);

  // optional .mt.EmDualVideoShowMode dual_show_mode = 8;
  inline bool has_dual_show_mode() const;
  inline void clear_dual_show_mode();
  static const int kDualShowModeFieldNumber = 8;
  inline ::mt::EmDualVideoShowMode dual_show_mode() const;
  inline void set_dual_show_mode(::mt::EmDualVideoShowMode value);

  // optional .mt.EmDisplayRatio pri_display_ratio = 9;
  inline bool has_pri_display_ratio() const;
  inline void clear_pri_display_ratio();
  static const int kPriDisplayRatioFieldNumber = 9;
  inline ::mt::EmDisplayRatio pri_display_ratio() const;
  inline void set_pri_display_ratio(::mt::EmDisplayRatio value);

  // optional .mt.EmDisplayRatio sec_display_ratio = 10;
  inline bool has_sec_display_ratio() const;
  inline void clear_sec_display_ratio();
  static const int kSecDisplayRatioFieldNumber = 10;
  inline ::mt::EmDisplayRatio sec_display_ratio() const;
  inline void set_sec_display_ratio(::mt::EmDisplayRatio value);

  // @@protoc_insertion_point(class_scope:mt.TMTOsdCfg)
 private:
  inline void set_has_is_auto_pip();
  inline void clear_has_is_auto_pip();
  inline void set_has_is_show_conf_lapse();
  inline void clear_has_is_show_conf_lapse();
  inline void set_has_is_show_sys_time();
  inline void clear_has_is_show_sys_time();
  inline void set_has_is_show_state();
  inline void clear_has_is_show_state();
  inline void set_has_label_type();
  inline void clear_has_label_type();
  inline void set_has_label_coordinate();
  inline void clear_has_label_coordinate();
  inline void set_has_label_pos_type();
  inline void clear_has_label_pos_type();
  inline void set_has_dual_show_mode();
  inline void clear_has_dual_show_mode();
  inline void set_has_pri_display_ratio();
  inline void clear_has_pri_display_ratio();
  inline void set_has_sec_display_ratio();
  inline void clear_has_sec_display_ratio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_auto_pip_;
  bool is_show_conf_lapse_;
  bool is_show_sys_time_;
  bool is_show_state_;
  int label_type_;
  ::mt::TMTSymboPoint* label_coordinate_;
  int label_pos_type_;
  int dual_show_mode_;
  int pri_display_ratio_;
  int sec_display_ratio_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTOsdCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAsymmetricNetInfo : public ::google::protobuf::Message {
 public:
  TMtAsymmetricNetInfo();
  virtual ~TMtAsymmetricNetInfo();

  TMtAsymmetricNetInfo(const TMtAsymmetricNetInfo& from);

  inline TMtAsymmetricNetInfo& operator=(const TMtAsymmetricNetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAsymmetricNetInfo& default_instance();

  void Swap(TMtAsymmetricNetInfo* other);

  // implements Message ----------------------------------------------

  TMtAsymmetricNetInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAsymmetricNetInfo& from);
  void MergeFrom(const TMtAsymmetricNetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_enable = 1;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 1;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional uint32 up_link_rate = 2;
  inline bool has_up_link_rate() const;
  inline void clear_up_link_rate();
  static const int kUpLinkRateFieldNumber = 2;
  inline ::google::protobuf::uint32 up_link_rate() const;
  inline void set_up_link_rate(::google::protobuf::uint32 value);

  // optional uint32 down_link_rate = 3;
  inline bool has_down_link_rate() const;
  inline void clear_down_link_rate();
  static const int kDownLinkRateFieldNumber = 3;
  inline ::google::protobuf::uint32 down_link_rate() const;
  inline void set_down_link_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtAsymmetricNetInfo)
 private:
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_up_link_rate();
  inline void clear_has_up_link_rate();
  inline void set_has_down_link_rate();
  inline void clear_has_down_link_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_enable_;
  ::google::protobuf::uint32 up_link_rate_;
  ::google::protobuf::uint32 down_link_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtAsymmetricNetInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMcRSParam : public ::google::protobuf::Message {
 public:
  TMTMcRSParam();
  virtual ~TMTMcRSParam();

  TMTMcRSParam(const TMTMcRSParam& from);

  inline TMTMcRSParam& operator=(const TMTMcRSParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMcRSParam& default_instance();

  void Swap(TMTMcRSParam* other);

  // implements Message ----------------------------------------------

  TMTMcRSParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMcRSParam& from);
  void MergeFrom(const TMTMcRSParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 first_time_span = 1 [default = 40];
  inline bool has_first_time_span() const;
  inline void clear_first_time_span();
  static const int kFirstTimeSpanFieldNumber = 1;
  inline ::google::protobuf::uint32 first_time_span() const;
  inline void set_first_time_span(::google::protobuf::uint32 value);

  // optional uint32 second_time_span = 2 [default = 2000];
  inline bool has_second_time_span() const;
  inline void clear_second_time_span();
  static const int kSecondTimeSpanFieldNumber = 2;
  inline ::google::protobuf::uint32 second_time_span() const;
  inline void set_second_time_span(::google::protobuf::uint32 value);

  // optional uint32 third_time_span = 3 [default = 0];
  inline bool has_third_time_span() const;
  inline void clear_third_time_span();
  static const int kThirdTimeSpanFieldNumber = 3;
  inline ::google::protobuf::uint32 third_time_span() const;
  inline void set_third_time_span(::google::protobuf::uint32 value);

  // optional uint32 reject_time_span = 4 [default = 0];
  inline bool has_reject_time_span() const;
  inline void clear_reject_time_span();
  static const int kRejectTimeSpanFieldNumber = 4;
  inline ::google::protobuf::uint32 reject_time_span() const;
  inline void set_reject_time_span(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTMcRSParam)
 private:
  inline void set_has_first_time_span();
  inline void clear_has_first_time_span();
  inline void set_has_second_time_span();
  inline void clear_has_second_time_span();
  inline void set_has_third_time_span();
  inline void clear_has_third_time_span();
  inline void set_has_reject_time_span();
  inline void clear_has_reject_time_span();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 first_time_span_;
  ::google::protobuf::uint32 second_time_span_;
  ::google::protobuf::uint32 third_time_span_;
  ::google::protobuf::uint32 reject_time_span_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTMcRSParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTQosParam : public ::google::protobuf::Message {
 public:
  TMTQosParam();
  virtual ~TMTQosParam();

  TMTQosParam(const TMTQosParam& from);

  inline TMTQosParam& operator=(const TMTQosParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTQosParam& default_instance();

  void Swap(TMTQosParam* other);

  // implements Message ----------------------------------------------

  TMTQosParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTQosParam& from);
  void MergeFrom(const TMTQosParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 signalling = 1;
  inline bool has_signalling() const;
  inline void clear_signalling();
  static const int kSignallingFieldNumber = 1;
  inline ::google::protobuf::uint32 signalling() const;
  inline void set_signalling(::google::protobuf::uint32 value);

  // optional uint32 data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline ::google::protobuf::uint32 data() const;
  inline void set_data(::google::protobuf::uint32 value);

  // optional uint32 audio = 3;
  inline bool has_audio() const;
  inline void clear_audio();
  static const int kAudioFieldNumber = 3;
  inline ::google::protobuf::uint32 audio() const;
  inline void set_audio(::google::protobuf::uint32 value);

  // optional uint32 video = 4;
  inline bool has_video() const;
  inline void clear_video();
  static const int kVideoFieldNumber = 4;
  inline ::google::protobuf::uint32 video() const;
  inline void set_video(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTQosParam)
 private:
  inline void set_has_signalling();
  inline void clear_has_signalling();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_audio();
  inline void clear_has_audio();
  inline void set_has_video();
  inline void clear_has_video();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 signalling_;
  ::google::protobuf::uint32 data_;
  ::google::protobuf::uint32 audio_;
  ::google::protobuf::uint32 video_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTQosParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTIPQoS : public ::google::protobuf::Message {
 public:
  TMTIPQoS();
  virtual ~TMTIPQoS();

  TMTIPQoS(const TMTIPQoS& from);

  inline TMTIPQoS& operator=(const TMTIPQoS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTIPQoS& default_instance();

  void Swap(TMTIPQoS* other);

  // implements Message ----------------------------------------------

  TMTIPQoS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTIPQoS& from);
  void MergeFrom(const TMTIPQoS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmQoS qos_type = 1;
  inline bool has_qos_type() const;
  inline void clear_qos_type();
  static const int kQosTypeFieldNumber = 1;
  inline ::mt::EmQoS qos_type() const;
  inline void set_qos_type(::mt::EmQoS value);

  // optional .mt.EmTOS tos_type = 2;
  inline bool has_tos_type() const;
  inline void clear_tos_type();
  static const int kTosTypeFieldNumber = 2;
  inline ::mt::EmTOS tos_type() const;
  inline void set_tos_type(::mt::EmTOS value);

  // optional .mt.TMTQosParam param_diff_service = 3;
  inline bool has_param_diff_service() const;
  inline void clear_param_diff_service();
  static const int kParamDiffServiceFieldNumber = 3;
  inline const ::mt::TMTQosParam& param_diff_service() const;
  inline ::mt::TMTQosParam* mutable_param_diff_service();
  inline ::mt::TMTQosParam* release_param_diff_service();
  inline void set_allocated_param_diff_service(::mt::TMTQosParam* param_diff_service);

  // optional .mt.TMTQosParam param_ip_precedence = 4;
  inline bool has_param_ip_precedence() const;
  inline void clear_param_ip_precedence();
  static const int kParamIpPrecedenceFieldNumber = 4;
  inline const ::mt::TMTQosParam& param_ip_precedence() const;
  inline ::mt::TMTQosParam* mutable_param_ip_precedence();
  inline ::mt::TMTQosParam* release_param_ip_precedence();
  inline void set_allocated_param_ip_precedence(::mt::TMTQosParam* param_ip_precedence);

  // @@protoc_insertion_point(class_scope:mt.TMTIPQoS)
 private:
  inline void set_has_qos_type();
  inline void clear_has_qos_type();
  inline void set_has_tos_type();
  inline void clear_has_tos_type();
  inline void set_has_param_diff_service();
  inline void clear_has_param_diff_service();
  inline void set_has_param_ip_precedence();
  inline void clear_has_param_ip_precedence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int qos_type_;
  int tos_type_;
  ::mt::TMTQosParam* param_diff_service_;
  ::mt::TMTQosParam* param_ip_precedence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTIPQoS* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTFecInfo : public ::google::protobuf::Message {
 public:
  TMTFecInfo();
  virtual ~TMTFecInfo();

  TMTFecInfo(const TMTFecInfo& from);

  inline TMTFecInfo& operator=(const TMTFecInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTFecInfo& default_instance();

  void Swap(TMTFecInfo* other);

  // implements Message ----------------------------------------------

  TMTFecInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTFecInfo& from);
  void MergeFrom(const TMTFecInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_enable = 1;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 1;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional uint32 fec_type = 2;
  inline bool has_fec_type() const;
  inline void clear_fec_type();
  static const int kFecTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 fec_type() const;
  inline void set_fec_type(::google::protobuf::uint32 value);

  // optional uint32 pack_len = 3;
  inline bool has_pack_len() const;
  inline void clear_pack_len();
  static const int kPackLenFieldNumber = 3;
  inline ::google::protobuf::uint32 pack_len() const;
  inline void set_pack_len(::google::protobuf::uint32 value);

  // optional bool is_intra_frame = 4;
  inline bool has_is_intra_frame() const;
  inline void clear_is_intra_frame();
  static const int kIsIntraFrameFieldNumber = 4;
  inline bool is_intra_frame() const;
  inline void set_is_intra_frame(bool value);

  // optional uint32 data_pack_num = 5;
  inline bool has_data_pack_num() const;
  inline void clear_data_pack_num();
  static const int kDataPackNumFieldNumber = 5;
  inline ::google::protobuf::uint32 data_pack_num() const;
  inline void set_data_pack_num(::google::protobuf::uint32 value);

  // optional uint32 crc_pack_num = 6;
  inline bool has_crc_pack_num() const;
  inline void clear_crc_pack_num();
  static const int kCrcPackNumFieldNumber = 6;
  inline ::google::protobuf::uint32 crc_pack_num() const;
  inline void set_crc_pack_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTFecInfo)
 private:
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_fec_type();
  inline void clear_has_fec_type();
  inline void set_has_pack_len();
  inline void clear_has_pack_len();
  inline void set_has_is_intra_frame();
  inline void clear_has_is_intra_frame();
  inline void set_has_data_pack_num();
  inline void clear_has_data_pack_num();
  inline void set_has_crc_pack_num();
  inline void clear_has_crc_pack_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 fec_type_;
  bool is_enable_;
  bool is_intra_frame_;
  ::google::protobuf::uint32 pack_len_;
  ::google::protobuf::uint32 data_pack_num_;
  ::google::protobuf::uint32 crc_pack_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTFecInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TStreamInfo : public ::google::protobuf::Message {
 public:
  TStreamInfo();
  virtual ~TStreamInfo();

  TStreamInfo(const TStreamInfo& from);

  inline TStreamInfo& operator=(const TStreamInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStreamInfo& default_instance();

  void Swap(TStreamInfo* other);

  // implements Message ----------------------------------------------

  TStreamInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStreamInfo& from);
  void MergeFrom(const TStreamInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 stream_id = 1;
  inline bool has_stream_id() const;
  inline void clear_stream_id();
  static const int kStreamIdFieldNumber = 1;
  inline ::google::protobuf::uint32 stream_id() const;
  inline void set_stream_id(::google::protobuf::uint32 value);

  // optional .mt.EmMtChanType stream_type = 2;
  inline bool has_stream_type() const;
  inline void clear_stream_type();
  static const int kStreamTypeFieldNumber = 2;
  inline ::mt::EmMtChanType stream_type() const;
  inline void set_stream_type(::mt::EmMtChanType value);

  // optional .mt.EmCodecComponentIndex bit_stream_index = 3;
  inline bool has_bit_stream_index() const;
  inline void clear_bit_stream_index();
  static const int kBitStreamIndexFieldNumber = 3;
  inline ::mt::EmCodecComponentIndex bit_stream_index() const;
  inline void set_bit_stream_index(::mt::EmCodecComponentIndex value);

  // optional uint32 band_width = 4;
  inline bool has_band_width() const;
  inline void clear_band_width();
  static const int kBandWidthFieldNumber = 4;
  inline ::google::protobuf::uint32 band_width() const;
  inline void set_band_width(::google::protobuf::uint32 value);

  // optional int32 speed_scale = 5;
  inline bool has_speed_scale() const;
  inline void clear_speed_scale();
  static const int kSpeedScaleFieldNumber = 5;
  inline ::google::protobuf::int32 speed_scale() const;
  inline void set_speed_scale(::google::protobuf::int32 value);

  // optional uint32 start_time = 6;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 end_time = 7;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // optional uint32 cur_time = 8;
  inline bool has_cur_time() const;
  inline void clear_cur_time();
  static const int kCurTimeFieldNumber = 8;
  inline ::google::protobuf::uint32 cur_time() const;
  inline void set_cur_time(::google::protobuf::uint32 value);

  // optional uint32 media_type = 9;
  inline bool has_media_type() const;
  inline void clear_media_type();
  static const int kMediaTypeFieldNumber = 9;
  inline ::google::protobuf::uint32 media_type() const;
  inline void set_media_type(::google::protobuf::uint32 value);

  // optional uint32 video_width = 10;
  inline bool has_video_width() const;
  inline void clear_video_width();
  static const int kVideoWidthFieldNumber = 10;
  inline ::google::protobuf::uint32 video_width() const;
  inline void set_video_width(::google::protobuf::uint32 value);

  // optional uint32 video_height = 11;
  inline bool has_video_height() const;
  inline void clear_video_height();
  static const int kVideoHeightFieldNumber = 11;
  inline ::google::protobuf::uint32 video_height() const;
  inline void set_video_height(::google::protobuf::uint32 value);

  // optional uint32 video_fps = 12;
  inline bool has_video_fps() const;
  inline void clear_video_fps();
  static const int kVideoFpsFieldNumber = 12;
  inline ::google::protobuf::uint32 video_fps() const;
  inline void set_video_fps(::google::protobuf::uint32 value);

  // optional .mt.EmRtspStatus status = 13;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 13;
  inline ::mt::EmRtspStatus status() const;
  inline void set_status(::mt::EmRtspStatus value);

  // optional bool is_livebroadcast = 14;
  inline bool has_is_livebroadcast() const;
  inline void clear_is_livebroadcast();
  static const int kIsLivebroadcastFieldNumber = 14;
  inline bool is_livebroadcast() const;
  inline void set_is_livebroadcast(bool value);

  // optional .mt.EmAacChnlNum aac_channel_num = 15;
  inline bool has_aac_channel_num() const;
  inline void clear_aac_channel_num();
  static const int kAacChannelNumFieldNumber = 15;
  inline ::mt::EmAacChnlNum aac_channel_num() const;
  inline void set_aac_channel_num(::mt::EmAacChnlNum value);

  // optional .mt.EmAacSampFreq aac_sample_rate = 16;
  inline bool has_aac_sample_rate() const;
  inline void clear_aac_sample_rate();
  static const int kAacSampleRateFieldNumber = 16;
  inline ::mt::EmAacSampFreq aac_sample_rate() const;
  inline void set_aac_sample_rate(::mt::EmAacSampFreq value);

  // @@protoc_insertion_point(class_scope:mt.TStreamInfo)
 private:
  inline void set_has_stream_id();
  inline void clear_has_stream_id();
  inline void set_has_stream_type();
  inline void clear_has_stream_type();
  inline void set_has_bit_stream_index();
  inline void clear_has_bit_stream_index();
  inline void set_has_band_width();
  inline void clear_has_band_width();
  inline void set_has_speed_scale();
  inline void clear_has_speed_scale();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_cur_time();
  inline void clear_has_cur_time();
  inline void set_has_media_type();
  inline void clear_has_media_type();
  inline void set_has_video_width();
  inline void clear_has_video_width();
  inline void set_has_video_height();
  inline void clear_has_video_height();
  inline void set_has_video_fps();
  inline void clear_has_video_fps();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_is_livebroadcast();
  inline void clear_has_is_livebroadcast();
  inline void set_has_aac_channel_num();
  inline void clear_has_aac_channel_num();
  inline void set_has_aac_sample_rate();
  inline void clear_has_aac_sample_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 stream_id_;
  int stream_type_;
  int bit_stream_index_;
  ::google::protobuf::uint32 band_width_;
  ::google::protobuf::int32 speed_scale_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 end_time_;
  ::google::protobuf::uint32 cur_time_;
  ::google::protobuf::uint32 media_type_;
  ::google::protobuf::uint32 video_width_;
  ::google::protobuf::uint32 video_height_;
  ::google::protobuf::uint32 video_fps_;
  int status_;
  bool is_livebroadcast_;
  int aac_channel_num_;
  int aac_sample_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TStreamInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVodPlayInfo : public ::google::protobuf::Message {
 public:
  TVodPlayInfo();
  virtual ~TVodPlayInfo();

  TVodPlayInfo(const TVodPlayInfo& from);

  inline TVodPlayInfo& operator=(const TVodPlayInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVodPlayInfo& default_instance();

  void Swap(TVodPlayInfo* other);

  // implements Message ----------------------------------------------

  TVodPlayInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVodPlayInfo& from);
  void MergeFrom(const TVodPlayInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string play_url = 1;
  inline bool has_play_url() const;
  inline void clear_play_url();
  static const int kPlayUrlFieldNumber = 1;
  inline const ::std::string& play_url() const;
  inline void set_play_url(const ::std::string& value);
  inline void set_play_url(const char* value);
  inline void set_play_url(const char* value, size_t size);
  inline ::std::string* mutable_play_url();
  inline ::std::string* release_play_url();
  inline void set_allocated_play_url(::std::string* play_url);

  // optional uint32 vod_id = 2;
  inline bool has_vod_id() const;
  inline void clear_vod_id();
  static const int kVodIdFieldNumber = 2;
  inline ::google::protobuf::uint32 vod_id() const;
  inline void set_vod_id(::google::protobuf::uint32 value);

  // repeated .mt.TStreamInfo stream_info = 3;
  inline int stream_info_size() const;
  inline void clear_stream_info();
  static const int kStreamInfoFieldNumber = 3;
  inline const ::mt::TStreamInfo& stream_info(int index) const;
  inline ::mt::TStreamInfo* mutable_stream_info(int index);
  inline ::mt::TStreamInfo* add_stream_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TStreamInfo >&
      stream_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TStreamInfo >*
      mutable_stream_info();

  // optional .mt.EmRtspStatus status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::mt::EmRtspStatus status() const;
  inline void set_status(::mt::EmRtspStatus value);

  // optional bool is_livebroadcast = 5;
  inline bool has_is_livebroadcast() const;
  inline void clear_is_livebroadcast();
  static const int kIsLivebroadcastFieldNumber = 5;
  inline bool is_livebroadcast() const;
  inline void set_is_livebroadcast(bool value);

  // @@protoc_insertion_point(class_scope:mt.TVodPlayInfo)
 private:
  inline void set_has_play_url();
  inline void clear_has_play_url();
  inline void set_has_vod_id();
  inline void clear_has_vod_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_is_livebroadcast();
  inline void clear_has_is_livebroadcast();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* play_url_;
  ::google::protobuf::RepeatedPtrField< ::mt::TStreamInfo > stream_info_;
  ::google::protobuf::uint32 vod_id_;
  int status_;
  bool is_livebroadcast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TVodPlayInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMultiVodPlayInfo : public ::google::protobuf::Message {
 public:
  TMultiVodPlayInfo();
  virtual ~TMultiVodPlayInfo();

  TMultiVodPlayInfo(const TMultiVodPlayInfo& from);

  inline TMultiVodPlayInfo& operator=(const TMultiVodPlayInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMultiVodPlayInfo& default_instance();

  void Swap(TMultiVodPlayInfo* other);

  // implements Message ----------------------------------------------

  TMultiVodPlayInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMultiVodPlayInfo& from);
  void MergeFrom(const TMultiVodPlayInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVodPlayInfo vod_info = 1;
  inline int vod_info_size() const;
  inline void clear_vod_info();
  static const int kVodInfoFieldNumber = 1;
  inline const ::mt::TVodPlayInfo& vod_info(int index) const;
  inline ::mt::TVodPlayInfo* mutable_vod_info(int index);
  inline ::mt::TVodPlayInfo* add_vod_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVodPlayInfo >&
      vod_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVodPlayInfo >*
      mutable_vod_info();

  // @@protoc_insertion_point(class_scope:mt.TMultiVodPlayInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVodPlayInfo > vod_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMultiVodPlayInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRingCfg : public ::google::protobuf::Message {
 public:
  TMTRingCfg();
  virtual ~TMTRingCfg();

  TMTRingCfg(const TMTRingCfg& from);

  inline TMTRingCfg& operator=(const TMTRingCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRingCfg& default_instance();

  void Swap(TMTRingCfg* other);

  // implements Message ----------------------------------------------

  TMTRingCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRingCfg& from);
  void MergeFrom(const TMTRingCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_ringin_path = 1;
  inline bool has_is_ringin_path() const;
  inline void clear_is_ringin_path();
  static const int kIsRinginPathFieldNumber = 1;
  inline bool is_ringin_path() const;
  inline void set_is_ringin_path(bool value);

  // optional bool is_ringout_path = 2;
  inline bool has_is_ringout_path() const;
  inline void clear_is_ringout_path();
  static const int kIsRingoutPathFieldNumber = 2;
  inline bool is_ringout_path() const;
  inline void set_is_ringout_path(bool value);

  // optional string path_ring_in = 3;
  inline bool has_path_ring_in() const;
  inline void clear_path_ring_in();
  static const int kPathRingInFieldNumber = 3;
  inline const ::std::string& path_ring_in() const;
  inline void set_path_ring_in(const ::std::string& value);
  inline void set_path_ring_in(const char* value);
  inline void set_path_ring_in(const char* value, size_t size);
  inline ::std::string* mutable_path_ring_in();
  inline ::std::string* release_path_ring_in();
  inline void set_allocated_path_ring_in(::std::string* path_ring_in);

  // optional string path_ring_out = 4;
  inline bool has_path_ring_out() const;
  inline void clear_path_ring_out();
  static const int kPathRingOutFieldNumber = 4;
  inline const ::std::string& path_ring_out() const;
  inline void set_path_ring_out(const ::std::string& value);
  inline void set_path_ring_out(const char* value);
  inline void set_path_ring_out(const char* value, size_t size);
  inline ::std::string* mutable_path_ring_out();
  inline ::std::string* release_path_ring_out();
  inline void set_allocated_path_ring_out(::std::string* path_ring_out);

  // optional .mt.EmMtRing ring_in = 5;
  inline bool has_ring_in() const;
  inline void clear_ring_in();
  static const int kRingInFieldNumber = 5;
  inline ::mt::EmMtRing ring_in() const;
  inline void set_ring_in(::mt::EmMtRing value);

  // optional .mt.EmMtRing ring_out = 6;
  inline bool has_ring_out() const;
  inline void clear_ring_out();
  static const int kRingOutFieldNumber = 6;
  inline ::mt::EmMtRing ring_out() const;
  inline void set_ring_out(::mt::EmMtRing value);

  // @@protoc_insertion_point(class_scope:mt.TMTRingCfg)
 private:
  inline void set_has_is_ringin_path();
  inline void clear_has_is_ringin_path();
  inline void set_has_is_ringout_path();
  inline void clear_has_is_ringout_path();
  inline void set_has_path_ring_in();
  inline void clear_has_path_ring_in();
  inline void set_has_path_ring_out();
  inline void clear_has_path_ring_out();
  inline void set_has_ring_in();
  inline void clear_has_ring_in();
  inline void set_has_ring_out();
  inline void clear_has_ring_out();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_ringin_path_;
  bool is_ringout_path_;
  int ring_in_;
  ::std::string* path_ring_in_;
  ::std::string* path_ring_out_;
  int ring_out_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTRingCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoEncoderParamCfg : public ::google::protobuf::Message {
 public:
  TMTVideoEncoderParamCfg();
  virtual ~TMTVideoEncoderParamCfg();

  TMTVideoEncoderParamCfg(const TMTVideoEncoderParamCfg& from);

  inline TMTVideoEncoderParamCfg& operator=(const TMTVideoEncoderParamCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoEncoderParamCfg& default_instance();

  void Swap(TMTVideoEncoderParamCfg* other);

  // implements Message ----------------------------------------------

  TMTVideoEncoderParamCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoEncoderParamCfg& from);
  void MergeFrom(const TMTVideoEncoderParamCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponentIndex index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::mt::EmCodecComponentIndex index() const;
  inline void set_index(::mt::EmCodecComponentIndex value);

  // optional uint32 h264_keyframe_interval = 2;
  inline bool has_h264_keyframe_interval() const;
  inline void clear_h264_keyframe_interval();
  static const int kH264KeyframeIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 h264_keyframe_interval() const;
  inline void set_h264_keyframe_interval(::google::protobuf::uint32 value);

  // optional uint32 h264_qual_max_value = 3;
  inline bool has_h264_qual_max_value() const;
  inline void clear_h264_qual_max_value();
  static const int kH264QualMaxValueFieldNumber = 3;
  inline ::google::protobuf::uint32 h264_qual_max_value() const;
  inline void set_h264_qual_max_value(::google::protobuf::uint32 value);

  // optional uint32 h264_qual_min_value = 4;
  inline bool has_h264_qual_min_value() const;
  inline void clear_h264_qual_min_value();
  static const int kH264QualMinValueFieldNumber = 4;
  inline ::google::protobuf::uint32 h264_qual_min_value() const;
  inline void set_h264_qual_min_value(::google::protobuf::uint32 value);

  // optional uint32 keyframe_interval = 5;
  inline bool has_keyframe_interval() const;
  inline void clear_keyframe_interval();
  static const int kKeyframeIntervalFieldNumber = 5;
  inline ::google::protobuf::uint32 keyframe_interval() const;
  inline void set_keyframe_interval(::google::protobuf::uint32 value);

  // optional uint32 qual_max_value = 6;
  inline bool has_qual_max_value() const;
  inline void clear_qual_max_value();
  static const int kQualMaxValueFieldNumber = 6;
  inline ::google::protobuf::uint32 qual_max_value() const;
  inline void set_qual_max_value(::google::protobuf::uint32 value);

  // optional uint32 qual_min_value = 7;
  inline bool has_qual_min_value() const;
  inline void clear_qual_min_value();
  static const int kQualMinValueFieldNumber = 7;
  inline ::google::protobuf::uint32 qual_min_value() const;
  inline void set_qual_min_value(::google::protobuf::uint32 value);

  // optional uint32 h265_keyframe_interval = 8;
  inline bool has_h265_keyframe_interval() const;
  inline void clear_h265_keyframe_interval();
  static const int kH265KeyframeIntervalFieldNumber = 8;
  inline ::google::protobuf::uint32 h265_keyframe_interval() const;
  inline void set_h265_keyframe_interval(::google::protobuf::uint32 value);

  // optional uint32 h265_qual_max_value = 9;
  inline bool has_h265_qual_max_value() const;
  inline void clear_h265_qual_max_value();
  static const int kH265QualMaxValueFieldNumber = 9;
  inline ::google::protobuf::uint32 h265_qual_max_value() const;
  inline void set_h265_qual_max_value(::google::protobuf::uint32 value);

  // optional uint32 h265_qual_min_value = 10;
  inline bool has_h265_qual_min_value() const;
  inline void clear_h265_qual_min_value();
  static const int kH265QualMinValueFieldNumber = 10;
  inline ::google::protobuf::uint32 h265_qual_min_value() const;
  inline void set_h265_qual_min_value(::google::protobuf::uint32 value);

  // optional uint32 frameRate_720p = 11;
  inline bool has_framerate_720p() const;
  inline void clear_framerate_720p();
  static const int kFrameRate720PFieldNumber = 11;
  inline ::google::protobuf::uint32 framerate_720p() const;
  inline void set_framerate_720p(::google::protobuf::uint32 value);

  // optional uint32 frameRate_1080p = 12;
  inline bool has_framerate_1080p() const;
  inline void clear_framerate_1080p();
  static const int kFrameRate1080PFieldNumber = 12;
  inline ::google::protobuf::uint32 framerate_1080p() const;
  inline void set_framerate_1080p(::google::protobuf::uint32 value);

  // optional uint32 framerate_gt720p = 13;
  inline bool has_framerate_gt720p() const;
  inline void clear_framerate_gt720p();
  static const int kFramerateGt720PFieldNumber = 13;
  inline ::google::protobuf::uint32 framerate_gt720p() const;
  inline void set_framerate_gt720p(::google::protobuf::uint32 value);

  // optional uint32 framerate_lt720p = 14;
  inline bool has_framerate_lt720p() const;
  inline void clear_framerate_lt720p();
  static const int kFramerateLt720PFieldNumber = 14;
  inline ::google::protobuf::uint32 framerate_lt720p() const;
  inline void set_framerate_lt720p(::google::protobuf::uint32 value);

  // optional uint32 framerate_4k = 15;
  inline bool has_framerate_4k() const;
  inline void clear_framerate_4k();
  static const int kFramerate4KFieldNumber = 15;
  inline ::google::protobuf::uint32 framerate_4k() const;
  inline void set_framerate_4k(::google::protobuf::uint32 value);

  // optional uint32 framerate_other = 16;
  inline bool has_framerate_other() const;
  inline void clear_framerate_other();
  static const int kFramerateOtherFieldNumber = 16;
  inline ::google::protobuf::uint32 framerate_other() const;
  inline void set_framerate_other(::google::protobuf::uint32 value);

  // optional bool is_skip = 17;
  inline bool has_is_skip() const;
  inline void clear_is_skip();
  static const int kIsSkipFieldNumber = 17;
  inline bool is_skip() const;
  inline void set_is_skip(bool value);

  // optional float fRatio = 18;
  inline bool has_fratio() const;
  inline void clear_fratio();
  static const int kFRatioFieldNumber = 18;
  inline float fratio() const;
  inline void set_fratio(float value);

  // @@protoc_insertion_point(class_scope:mt.TMTVideoEncoderParamCfg)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_h264_keyframe_interval();
  inline void clear_has_h264_keyframe_interval();
  inline void set_has_h264_qual_max_value();
  inline void clear_has_h264_qual_max_value();
  inline void set_has_h264_qual_min_value();
  inline void clear_has_h264_qual_min_value();
  inline void set_has_keyframe_interval();
  inline void clear_has_keyframe_interval();
  inline void set_has_qual_max_value();
  inline void clear_has_qual_max_value();
  inline void set_has_qual_min_value();
  inline void clear_has_qual_min_value();
  inline void set_has_h265_keyframe_interval();
  inline void clear_has_h265_keyframe_interval();
  inline void set_has_h265_qual_max_value();
  inline void clear_has_h265_qual_max_value();
  inline void set_has_h265_qual_min_value();
  inline void clear_has_h265_qual_min_value();
  inline void set_has_framerate_720p();
  inline void clear_has_framerate_720p();
  inline void set_has_framerate_1080p();
  inline void clear_has_framerate_1080p();
  inline void set_has_framerate_gt720p();
  inline void clear_has_framerate_gt720p();
  inline void set_has_framerate_lt720p();
  inline void clear_has_framerate_lt720p();
  inline void set_has_framerate_4k();
  inline void clear_has_framerate_4k();
  inline void set_has_framerate_other();
  inline void clear_has_framerate_other();
  inline void set_has_is_skip();
  inline void clear_has_is_skip();
  inline void set_has_fratio();
  inline void clear_has_fratio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int index_;
  ::google::protobuf::uint32 h264_keyframe_interval_;
  ::google::protobuf::uint32 h264_qual_max_value_;
  ::google::protobuf::uint32 h264_qual_min_value_;
  ::google::protobuf::uint32 keyframe_interval_;
  ::google::protobuf::uint32 qual_max_value_;
  ::google::protobuf::uint32 qual_min_value_;
  ::google::protobuf::uint32 h265_keyframe_interval_;
  ::google::protobuf::uint32 h265_qual_max_value_;
  ::google::protobuf::uint32 h265_qual_min_value_;
  ::google::protobuf::uint32 framerate_720p_;
  ::google::protobuf::uint32 framerate_1080p_;
  ::google::protobuf::uint32 framerate_gt720p_;
  ::google::protobuf::uint32 framerate_lt720p_;
  ::google::protobuf::uint32 framerate_4k_;
  ::google::protobuf::uint32 framerate_other_;
  bool is_skip_;
  float fratio_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoEncoderParamCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAllVideoEncoderParamCfg : public ::google::protobuf::Message {
 public:
  TMTAllVideoEncoderParamCfg();
  virtual ~TMTAllVideoEncoderParamCfg();

  TMTAllVideoEncoderParamCfg(const TMTAllVideoEncoderParamCfg& from);

  inline TMTAllVideoEncoderParamCfg& operator=(const TMTAllVideoEncoderParamCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAllVideoEncoderParamCfg& default_instance();

  void Swap(TMTAllVideoEncoderParamCfg* other);

  // implements Message ----------------------------------------------

  TMTAllVideoEncoderParamCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAllVideoEncoderParamCfg& from);
  void MergeFrom(const TMTAllVideoEncoderParamCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTVideoEncoderParamCfg param_array = 1;
  inline int param_array_size() const;
  inline void clear_param_array();
  static const int kParamArrayFieldNumber = 1;
  inline const ::mt::TMTVideoEncoderParamCfg& param_array(int index) const;
  inline ::mt::TMTVideoEncoderParamCfg* mutable_param_array(int index);
  inline ::mt::TMTVideoEncoderParamCfg* add_param_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoEncoderParamCfg >&
      param_array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoEncoderParamCfg >*
      mutable_param_array();

  // @@protoc_insertion_point(class_scope:mt.TMTAllVideoEncoderParamCfg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoEncoderParamCfg > param_array_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTAllVideoEncoderParamCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoDecoderParamCfg : public ::google::protobuf::Message {
 public:
  TMTVideoDecoderParamCfg();
  virtual ~TMTVideoDecoderParamCfg();

  TMTVideoDecoderParamCfg(const TMTVideoDecoderParamCfg& from);

  inline TMTVideoDecoderParamCfg& operator=(const TMTVideoDecoderParamCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoDecoderParamCfg& default_instance();

  void Swap(TMTVideoDecoderParamCfg* other);

  // implements Message ----------------------------------------------

  TMTVideoDecoderParamCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoDecoderParamCfg& from);
  void MergeFrom(const TMTVideoDecoderParamCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponentIndex index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::mt::EmCodecComponentIndex index() const;
  inline void set_index(::mt::EmCodecComponentIndex value);

  // optional .mt.EmLostPackStrategy type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mt::EmLostPackStrategy type() const;
  inline void set_type(::mt::EmLostPackStrategy value);

  // @@protoc_insertion_point(class_scope:mt.TMTVideoDecoderParamCfg)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int index_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoDecoderParamCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAllVideoDecoderParamCfg : public ::google::protobuf::Message {
 public:
  TMTAllVideoDecoderParamCfg();
  virtual ~TMTAllVideoDecoderParamCfg();

  TMTAllVideoDecoderParamCfg(const TMTAllVideoDecoderParamCfg& from);

  inline TMTAllVideoDecoderParamCfg& operator=(const TMTAllVideoDecoderParamCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAllVideoDecoderParamCfg& default_instance();

  void Swap(TMTAllVideoDecoderParamCfg* other);

  // implements Message ----------------------------------------------

  TMTAllVideoDecoderParamCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAllVideoDecoderParamCfg& from);
  void MergeFrom(const TMTAllVideoDecoderParamCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTVideoDecoderParamCfg param_array = 2;
  inline int param_array_size() const;
  inline void clear_param_array();
  static const int kParamArrayFieldNumber = 2;
  inline const ::mt::TMTVideoDecoderParamCfg& param_array(int index) const;
  inline ::mt::TMTVideoDecoderParamCfg* mutable_param_array(int index);
  inline ::mt::TMTVideoDecoderParamCfg* add_param_array();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoDecoderParamCfg >&
      param_array() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoDecoderParamCfg >*
      mutable_param_array();

  // @@protoc_insertion_point(class_scope:mt.TMTAllVideoDecoderParamCfg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoDecoderParamCfg > param_array_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTAllVideoDecoderParamCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPortCfg : public ::google::protobuf::Message {
 public:
  TMTPortCfg();
  virtual ~TMTPortCfg();

  TMTPortCfg(const TMTPortCfg& from);

  inline TMTPortCfg& operator=(const TMTPortCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPortCfg& default_instance();

  void Swap(TMTPortCfg* other);

  // implements Message ----------------------------------------------

  TMTPortCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPortCfg& from);
  void MergeFrom(const TMTPortCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_used = 1;
  inline bool has_is_used() const;
  inline void clear_is_used();
  static const int kIsUsedFieldNumber = 1;
  inline bool is_used() const;
  inline void set_is_used(bool value);

  // optional uint32 tcp_base_port = 2;
  inline bool has_tcp_base_port() const;
  inline void clear_tcp_base_port();
  static const int kTcpBasePortFieldNumber = 2;
  inline ::google::protobuf::uint32 tcp_base_port() const;
  inline void set_tcp_base_port(::google::protobuf::uint32 value);

  // optional uint32 udp_base_port = 3;
  inline bool has_udp_base_port() const;
  inline void clear_udp_base_port();
  static const int kUdpBasePortFieldNumber = 3;
  inline ::google::protobuf::uint32 udp_base_port() const;
  inline void set_udp_base_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTPortCfg)
 private:
  inline void set_has_is_used();
  inline void clear_has_is_used();
  inline void set_has_tcp_base_port();
  inline void clear_has_tcp_base_port();
  inline void set_has_udp_base_port();
  inline void clear_has_udp_base_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_used_;
  ::google::protobuf::uint32 tcp_base_port_;
  ::google::protobuf::uint32 udp_base_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTPortCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTShortMsgCfg : public ::google::protobuf::Message {
 public:
  TMTShortMsgCfg();
  virtual ~TMTShortMsgCfg();

  TMTShortMsgCfg(const TMTShortMsgCfg& from);

  inline TMTShortMsgCfg& operator=(const TMTShortMsgCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTShortMsgCfg& default_instance();

  void Swap(TMTShortMsgCfg* other);

  // implements Message ----------------------------------------------

  TMTShortMsgCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTShortMsgCfg& from);
  void MergeFrom(const TMTShortMsgCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 font_size_index = 1;
  inline bool has_font_size_index() const;
  inline void clear_font_size_index();
  static const int kFontSizeIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 font_size_index() const;
  inline void set_font_size_index(::google::protobuf::uint32 value);

  // optional uint32 font_color_index = 2;
  inline bool has_font_color_index() const;
  inline void clear_font_color_index();
  static const int kFontColorIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 font_color_index() const;
  inline void set_font_color_index(::google::protobuf::uint32 value);

  // optional uint32 background_color_index = 3 [default = 7];
  inline bool has_background_color_index() const;
  inline void clear_background_color_index();
  static const int kBackgroundColorIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 background_color_index() const;
  inline void set_background_color_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTShortMsgCfg)
 private:
  inline void set_has_font_size_index();
  inline void clear_has_font_size_index();
  inline void set_has_font_color_index();
  inline void clear_has_font_color_index();
  inline void set_has_background_color_index();
  inline void clear_has_background_color_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 font_size_index_;
  ::google::protobuf::uint32 font_color_index_;
  ::google::protobuf::uint32 background_color_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTShortMsgCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTOspSock5Proxy : public ::google::protobuf::Message {
 public:
  TMTOspSock5Proxy();
  virtual ~TMTOspSock5Proxy();

  TMTOspSock5Proxy(const TMTOspSock5Proxy& from);

  inline TMTOspSock5Proxy& operator=(const TMTOspSock5Proxy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTOspSock5Proxy& default_instance();

  void Swap(TMTOspSock5Proxy* other);

  // implements Message ----------------------------------------------

  TMTOspSock5Proxy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTOspSock5Proxy& from);
  void MergeFrom(const TMTOspSock5Proxy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 proxy_ip = 1;
  inline bool has_proxy_ip() const;
  inline void clear_proxy_ip();
  static const int kProxyIpFieldNumber = 1;
  inline ::google::protobuf::uint32 proxy_ip() const;
  inline void set_proxy_ip(::google::protobuf::uint32 value);

  // optional uint32 proxy_port = 2;
  inline bool has_proxy_port() const;
  inline void clear_proxy_port();
  static const int kProxyPortFieldNumber = 2;
  inline ::google::protobuf::uint32 proxy_port() const;
  inline void set_proxy_port(::google::protobuf::uint32 value);

  // optional uint32 authen_num = 3;
  inline bool has_authen_num() const;
  inline void clear_authen_num();
  static const int kAuthenNumFieldNumber = 3;
  inline ::google::protobuf::uint32 authen_num() const;
  inline void set_authen_num(::google::protobuf::uint32 value);

  // optional string authen_method = 4;
  inline bool has_authen_method() const;
  inline void clear_authen_method();
  static const int kAuthenMethodFieldNumber = 4;
  inline const ::std::string& authen_method() const;
  inline void set_authen_method(const ::std::string& value);
  inline void set_authen_method(const char* value);
  inline void set_authen_method(const char* value, size_t size);
  inline ::std::string* mutable_authen_method();
  inline ::std::string* release_authen_method();
  inline void set_allocated_authen_method(::std::string* authen_method);

  // optional string user_name = 5;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 5;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:mt.TMTOspSock5Proxy)
 private:
  inline void set_has_proxy_ip();
  inline void clear_has_proxy_ip();
  inline void set_has_proxy_port();
  inline void clear_has_proxy_port();
  inline void set_has_authen_num();
  inline void clear_has_authen_num();
  inline void set_has_authen_method();
  inline void clear_has_authen_method();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 proxy_ip_;
  ::google::protobuf::uint32 proxy_port_;
  ::std::string* authen_method_;
  ::std::string* user_name_;
  ::std::string* password_;
  ::google::protobuf::uint32 authen_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTOspSock5Proxy* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTInnerMcAssVidCfg : public ::google::protobuf::Message {
 public:
  TMTInnerMcAssVidCfg();
  virtual ~TMTInnerMcAssVidCfg();

  TMTInnerMcAssVidCfg(const TMTInnerMcAssVidCfg& from);

  inline TMTInnerMcAssVidCfg& operator=(const TMTInnerMcAssVidCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTInnerMcAssVidCfg& default_instance();

  void Swap(TMTInnerMcAssVidCfg* other);

  // implements Message ----------------------------------------------

  TMTInnerMcAssVidCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTInnerMcAssVidCfg& from);
  void MergeFrom(const TMTInnerMcAssVidCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVidFormat ass_video_format = 1;
  inline bool has_ass_video_format() const;
  inline void clear_ass_video_format();
  static const int kAssVideoFormatFieldNumber = 1;
  inline ::mt::EmVidFormat ass_video_format() const;
  inline void set_ass_video_format(::mt::EmVidFormat value);

  // optional .mt.EmMtResolution ass_video_res = 2;
  inline bool has_ass_video_res() const;
  inline void clear_ass_video_res();
  static const int kAssVideoResFieldNumber = 2;
  inline ::mt::EmMtResolution ass_video_res() const;
  inline void set_ass_video_res(::mt::EmMtResolution value);

  // optional uint32 ass_video_framerate = 3;
  inline bool has_ass_video_framerate() const;
  inline void clear_ass_video_framerate();
  static const int kAssVideoFramerateFieldNumber = 3;
  inline ::google::protobuf::uint32 ass_video_framerate() const;
  inline void set_ass_video_framerate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTInnerMcAssVidCfg)
 private:
  inline void set_has_ass_video_format();
  inline void clear_has_ass_video_format();
  inline void set_has_ass_video_res();
  inline void clear_has_ass_video_res();
  inline void set_has_ass_video_framerate();
  inline void clear_has_ass_video_framerate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ass_video_format_;
  int ass_video_res_;
  ::google::protobuf::uint32 ass_video_framerate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTInnerMcAssVidCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUpgradeDeviceInfo : public ::google::protobuf::Message {
 public:
  TMTUpgradeDeviceInfo();
  virtual ~TMTUpgradeDeviceInfo();

  TMTUpgradeDeviceInfo(const TMTUpgradeDeviceInfo& from);

  inline TMTUpgradeDeviceInfo& operator=(const TMTUpgradeDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUpgradeDeviceInfo& default_instance();

  void Swap(TMTUpgradeDeviceInfo* other);

  // implements Message ----------------------------------------------

  TMTUpgradeDeviceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUpgradeDeviceInfo& from);
  void MergeFrom(const TMTUpgradeDeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dev_type = 1;
  inline bool has_dev_type() const;
  inline void clear_dev_type();
  static const int kDevTypeFieldNumber = 1;
  inline const ::std::string& dev_type() const;
  inline void set_dev_type(const ::std::string& value);
  inline void set_dev_type(const char* value);
  inline void set_dev_type(const char* value, size_t size);
  inline ::std::string* mutable_dev_type();
  inline ::std::string* release_dev_type();
  inline void set_allocated_dev_type(::std::string* dev_type);

  // optional string oem_mark = 2;
  inline bool has_oem_mark() const;
  inline void clear_oem_mark();
  static const int kOemMarkFieldNumber = 2;
  inline const ::std::string& oem_mark() const;
  inline void set_oem_mark(const ::std::string& value);
  inline void set_oem_mark(const char* value);
  inline void set_oem_mark(const char* value, size_t size);
  inline ::std::string* mutable_oem_mark();
  inline ::std::string* release_oem_mark();
  inline void set_allocated_oem_mark(::std::string* oem_mark);

  // optional string e164 = 3;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 3;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string cur_soft_ver = 4;
  inline bool has_cur_soft_ver() const;
  inline void clear_cur_soft_ver();
  static const int kCurSoftVerFieldNumber = 4;
  inline const ::std::string& cur_soft_ver() const;
  inline void set_cur_soft_ver(const ::std::string& value);
  inline void set_cur_soft_ver(const char* value);
  inline void set_cur_soft_ver(const char* value, size_t size);
  inline ::std::string* mutable_cur_soft_ver();
  inline ::std::string* release_cur_soft_ver();
  inline void set_allocated_cur_soft_ver(::std::string* cur_soft_ver);

  // optional uint32 dev_ip = 5;
  inline bool has_dev_ip() const;
  inline void clear_dev_ip();
  static const int kDevIpFieldNumber = 5;
  inline ::google::protobuf::uint32 dev_ip() const;
  inline void set_dev_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTUpgradeDeviceInfo)
 private:
  inline void set_has_dev_type();
  inline void clear_has_dev_type();
  inline void set_has_oem_mark();
  inline void clear_has_oem_mark();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_cur_soft_ver();
  inline void clear_has_cur_soft_ver();
  inline void set_has_dev_ip();
  inline void clear_has_dev_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dev_type_;
  ::std::string* oem_mark_;
  ::std::string* e164_;
  ::std::string* cur_soft_ver_;
  ::google::protobuf::uint32 dev_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTUpgradeDeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUpgradeClientInfo : public ::google::protobuf::Message {
 public:
  TMTUpgradeClientInfo();
  virtual ~TMTUpgradeClientInfo();

  TMTUpgradeClientInfo(const TMTUpgradeClientInfo& from);

  inline TMTUpgradeClientInfo& operator=(const TMTUpgradeClientInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUpgradeClientInfo& default_instance();

  void Swap(TMTUpgradeClientInfo* other);

  // implements Message ----------------------------------------------

  TMTUpgradeClientInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUpgradeClientInfo& from);
  void MergeFrom(const TMTUpgradeClientInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMTUpgradeNetParam server_info = 1;
  inline bool has_server_info() const;
  inline void clear_server_info();
  static const int kServerInfoFieldNumber = 1;
  inline const ::mt::TMTUpgradeNetParam& server_info() const;
  inline ::mt::TMTUpgradeNetParam* mutable_server_info();
  inline ::mt::TMTUpgradeNetParam* release_server_info();
  inline void set_allocated_server_info(::mt::TMTUpgradeNetParam* server_info);

  // optional .mt.TMTUpgradeDeviceInfo dev_info = 2;
  inline bool has_dev_info() const;
  inline void clear_dev_info();
  static const int kDevInfoFieldNumber = 2;
  inline const ::mt::TMTUpgradeDeviceInfo& dev_info() const;
  inline ::mt::TMTUpgradeDeviceInfo* mutable_dev_info();
  inline ::mt::TMTUpgradeDeviceInfo* release_dev_info();
  inline void set_allocated_dev_info(::mt::TMTUpgradeDeviceInfo* dev_info);

  // @@protoc_insertion_point(class_scope:mt.TMTUpgradeClientInfo)
 private:
  inline void set_has_server_info();
  inline void clear_has_server_info();
  inline void set_has_dev_info();
  inline void clear_has_dev_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTUpgradeNetParam* server_info_;
  ::mt::TMTUpgradeDeviceInfo* dev_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTUpgradeClientInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUpgradeGrayRange : public ::google::protobuf::Message {
 public:
  TMTUpgradeGrayRange();
  virtual ~TMTUpgradeGrayRange();

  TMTUpgradeGrayRange(const TMTUpgradeGrayRange& from);

  inline TMTUpgradeGrayRange& operator=(const TMTUpgradeGrayRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUpgradeGrayRange& default_instance();

  void Swap(TMTUpgradeGrayRange* other);

  // implements Message ----------------------------------------------

  TMTUpgradeGrayRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUpgradeGrayRange& from);
  void MergeFrom(const TMTUpgradeGrayRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid_list = 1;
  inline bool has_moid_list() const;
  inline void clear_moid_list();
  static const int kMoidListFieldNumber = 1;
  inline const ::std::string& moid_list() const;
  inline void set_moid_list(const ::std::string& value);
  inline void set_moid_list(const char* value);
  inline void set_moid_list(const char* value, size_t size);
  inline ::std::string* mutable_moid_list();
  inline ::std::string* release_moid_list();
  inline void set_allocated_moid_list(::std::string* moid_list);

  // optional string e164_list = 2;
  inline bool has_e164_list() const;
  inline void clear_e164_list();
  static const int kE164ListFieldNumber = 2;
  inline const ::std::string& e164_list() const;
  inline void set_e164_list(const ::std::string& value);
  inline void set_e164_list(const char* value);
  inline void set_e164_list(const char* value, size_t size);
  inline ::std::string* mutable_e164_list();
  inline ::std::string* release_e164_list();
  inline void set_allocated_e164_list(::std::string* e164_list);

  // @@protoc_insertion_point(class_scope:mt.TMTUpgradeGrayRange)
 private:
  inline void set_has_moid_list();
  inline void clear_has_moid_list();
  inline void set_has_e164_list();
  inline void clear_has_e164_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_list_;
  ::std::string* e164_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTUpgradeGrayRange* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUpgradeVersionInfo : public ::google::protobuf::Message {
 public:
  TMTUpgradeVersionInfo();
  virtual ~TMTUpgradeVersionInfo();

  TMTUpgradeVersionInfo(const TMTUpgradeVersionInfo& from);

  inline TMTUpgradeVersionInfo& operator=(const TMTUpgradeVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUpgradeVersionInfo& default_instance();

  void Swap(TMTUpgradeVersionInfo* other);

  // implements Message ----------------------------------------------

  TMTUpgradeVersionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUpgradeVersionInfo& from);
  void MergeFrom(const TMTUpgradeVersionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ver_id = 1;
  inline bool has_ver_id() const;
  inline void clear_ver_id();
  static const int kVerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 ver_id() const;
  inline void set_ver_id(::google::protobuf::uint32 value);

  // optional string oem_mark = 2;
  inline bool has_oem_mark() const;
  inline void clear_oem_mark();
  static const int kOemMarkFieldNumber = 2;
  inline const ::std::string& oem_mark() const;
  inline void set_oem_mark(const ::std::string& value);
  inline void set_oem_mark(const char* value);
  inline void set_oem_mark(const char* value, size_t size);
  inline ::std::string* mutable_oem_mark();
  inline ::std::string* release_oem_mark();
  inline void set_allocated_oem_mark(::std::string* oem_mark);

  // optional string dev_Type = 3;
  inline bool has_dev_type() const;
  inline void clear_dev_type();
  static const int kDevTypeFieldNumber = 3;
  inline const ::std::string& dev_type() const;
  inline void set_dev_type(const ::std::string& value);
  inline void set_dev_type(const char* value);
  inline void set_dev_type(const char* value, size_t size);
  inline ::std::string* mutable_dev_type();
  inline ::std::string* release_dev_type();
  inline void set_allocated_dev_type(::std::string* dev_type);

  // optional .mt.EmUpgradeVerLevel ver_level = 4;
  inline bool has_ver_level() const;
  inline void clear_ver_level();
  static const int kVerLevelFieldNumber = 4;
  inline ::mt::EmUpgradeVerLevel ver_level() const;
  inline void set_ver_level(::mt::EmUpgradeVerLevel value);

  // optional string soft_ver = 5;
  inline bool has_soft_ver() const;
  inline void clear_soft_ver();
  static const int kSoftVerFieldNumber = 5;
  inline const ::std::string& soft_ver() const;
  inline void set_soft_ver(const ::std::string& value);
  inline void set_soft_ver(const char* value);
  inline void set_soft_ver(const char* value, size_t size);
  inline ::std::string* mutable_soft_ver();
  inline ::std::string* release_soft_ver();
  inline void set_allocated_soft_ver(::std::string* soft_ver);

  // optional string ver_notes = 6;
  inline bool has_ver_notes() const;
  inline void clear_ver_notes();
  static const int kVerNotesFieldNumber = 6;
  inline const ::std::string& ver_notes() const;
  inline void set_ver_notes(const ::std::string& value);
  inline void set_ver_notes(const char* value);
  inline void set_ver_notes(const char* value, size_t size);
  inline ::std::string* mutable_ver_notes();
  inline ::std::string* release_ver_notes();
  inline void set_allocated_ver_notes(::std::string* ver_notes);

  // optional uint32 size = 7;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 7;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // optional .mt.EmUpgradeReleaseAttr ver_attr = 8;
  inline bool has_ver_attr() const;
  inline void clear_ver_attr();
  static const int kVerAttrFieldNumber = 8;
  inline ::mt::EmUpgradeReleaseAttr ver_attr() const;
  inline void set_ver_attr(::mt::EmUpgradeReleaseAttr value);

  // optional string file_name = 9;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 9;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional .mt.TMTUpgradeGrayRange gray_range = 10;
  inline bool has_gray_range() const;
  inline void clear_gray_range();
  static const int kGrayRangeFieldNumber = 10;
  inline const ::mt::TMTUpgradeGrayRange& gray_range() const;
  inline ::mt::TMTUpgradeGrayRange* mutable_gray_range();
  inline ::mt::TMTUpgradeGrayRange* release_gray_range();
  inline void set_allocated_gray_range(::mt::TMTUpgradeGrayRange* gray_range);

  // @@protoc_insertion_point(class_scope:mt.TMTUpgradeVersionInfo)
 private:
  inline void set_has_ver_id();
  inline void clear_has_ver_id();
  inline void set_has_oem_mark();
  inline void clear_has_oem_mark();
  inline void set_has_dev_type();
  inline void clear_has_dev_type();
  inline void set_has_ver_level();
  inline void clear_has_ver_level();
  inline void set_has_soft_ver();
  inline void clear_has_soft_ver();
  inline void set_has_ver_notes();
  inline void clear_has_ver_notes();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_ver_attr();
  inline void clear_has_ver_attr();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_gray_range();
  inline void clear_has_gray_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* oem_mark_;
  ::google::protobuf::uint32 ver_id_;
  int ver_level_;
  ::std::string* dev_type_;
  ::std::string* soft_ver_;
  ::std::string* ver_notes_;
  ::google::protobuf::uint32 size_;
  int ver_attr_;
  ::std::string* file_name_;
  ::mt::TMTUpgradeGrayRange* gray_range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTUpgradeVersionInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUpgradeVersionInfoList : public ::google::protobuf::Message {
 public:
  TMTUpgradeVersionInfoList();
  virtual ~TMTUpgradeVersionInfoList();

  TMTUpgradeVersionInfoList(const TMTUpgradeVersionInfoList& from);

  inline TMTUpgradeVersionInfoList& operator=(const TMTUpgradeVersionInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUpgradeVersionInfoList& default_instance();

  void Swap(TMTUpgradeVersionInfoList* other);

  // implements Message ----------------------------------------------

  TMTUpgradeVersionInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUpgradeVersionInfoList& from);
  void MergeFrom(const TMTUpgradeVersionInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_get_recommend = 1;
  inline bool has_is_get_recommend() const;
  inline void clear_is_get_recommend();
  static const int kIsGetRecommendFieldNumber = 1;
  inline bool is_get_recommend() const;
  inline void set_is_get_recommend(bool value);

  // repeated .mt.TMTUpgradeVersionInfo ver_list = 2;
  inline int ver_list_size() const;
  inline void clear_ver_list();
  static const int kVerListFieldNumber = 2;
  inline const ::mt::TMTUpgradeVersionInfo& ver_list(int index) const;
  inline ::mt::TMTUpgradeVersionInfo* mutable_ver_list(int index);
  inline ::mt::TMTUpgradeVersionInfo* add_ver_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUpgradeVersionInfo >&
      ver_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUpgradeVersionInfo >*
      mutable_ver_list();

  // @@protoc_insertion_point(class_scope:mt.TMTUpgradeVersionInfoList)
 private:
  inline void set_has_is_get_recommend();
  inline void clear_has_is_get_recommend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTUpgradeVersionInfo > ver_list_;
  bool is_get_recommend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTUpgradeVersionInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUpgradeDownloadInfo : public ::google::protobuf::Message {
 public:
  TMTUpgradeDownloadInfo();
  virtual ~TMTUpgradeDownloadInfo();

  TMTUpgradeDownloadInfo(const TMTUpgradeDownloadInfo& from);

  inline TMTUpgradeDownloadInfo& operator=(const TMTUpgradeDownloadInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUpgradeDownloadInfo& default_instance();

  void Swap(TMTUpgradeDownloadInfo* other);

  // implements Message ----------------------------------------------

  TMTUpgradeDownloadInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUpgradeDownloadInfo& from);
  void MergeFrom(const TMTUpgradeDownloadInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // optional uint32 total_percent = 2;
  inline bool has_total_percent() const;
  inline void clear_total_percent();
  static const int kTotalPercentFieldNumber = 2;
  inline ::google::protobuf::uint32 total_percent() const;
  inline void set_total_percent(::google::protobuf::uint32 value);

  // optional uint32 cur_percent = 3;
  inline bool has_cur_percent() const;
  inline void clear_cur_percent();
  static const int kCurPercentFieldNumber = 3;
  inline ::google::protobuf::uint32 cur_percent() const;
  inline void set_cur_percent(::google::protobuf::uint32 value);

  // optional string cur_file_name = 4;
  inline bool has_cur_file_name() const;
  inline void clear_cur_file_name();
  static const int kCurFileNameFieldNumber = 4;
  inline const ::std::string& cur_file_name() const;
  inline void set_cur_file_name(const ::std::string& value);
  inline void set_cur_file_name(const char* value);
  inline void set_cur_file_name(const char* value, size_t size);
  inline ::std::string* mutable_cur_file_name();
  inline ::std::string* release_cur_file_name();
  inline void set_allocated_cur_file_name(::std::string* cur_file_name);

  // @@protoc_insertion_point(class_scope:mt.TMTUpgradeDownloadInfo)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_total_percent();
  inline void clear_has_total_percent();
  inline void set_has_cur_percent();
  inline void clear_has_cur_percent();
  inline void set_has_cur_file_name();
  inline void clear_has_cur_file_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 total_percent_;
  ::std::string* cur_file_name_;
  ::google::protobuf::uint32 cur_percent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTUpgradeDownloadInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUsedPort : public ::google::protobuf::Message {
 public:
  TMTUsedPort();
  virtual ~TMTUsedPort();

  TMTUsedPort(const TMTUsedPort& from);

  inline TMTUsedPort& operator=(const TMTUsedPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUsedPort& default_instance();

  void Swap(TMTUsedPort* other);

  // implements Message ----------------------------------------------

  TMTUsedPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUsedPort& from);
  void MergeFrom(const TMTUsedPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTUsedPort)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTUsedPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTUsedPortList : public ::google::protobuf::Message {
 public:
  TMTUsedPortList();
  virtual ~TMTUsedPortList();

  TMTUsedPortList(const TMTUsedPortList& from);

  inline TMTUsedPortList& operator=(const TMTUsedPortList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTUsedPortList& default_instance();

  void Swap(TMTUsedPortList* other);

  // implements Message ----------------------------------------------

  TMTUsedPortList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTUsedPortList& from);
  void MergeFrom(const TMTUsedPortList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmPortType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mt::EmPortType type() const;
  inline void set_type(::mt::EmPortType value);

  // repeated .mt.TMTUsedPort list = 2;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 2;
  inline const ::mt::TMTUsedPort& list(int index) const;
  inline ::mt::TMTUsedPort* mutable_list(int index);
  inline ::mt::TMTUsedPort* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUsedPort >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUsedPort >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:mt.TMTUsedPortList)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTUsedPort > list_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTUsedPortList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTTotalUsedPort : public ::google::protobuf::Message {
 public:
  TMTTotalUsedPort();
  virtual ~TMTTotalUsedPort();

  TMTTotalUsedPort(const TMTTotalUsedPort& from);

  inline TMTTotalUsedPort& operator=(const TMTTotalUsedPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTTotalUsedPort& default_instance();

  void Swap(TMTTotalUsedPort* other);

  // implements Message ----------------------------------------------

  TMTTotalUsedPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTTotalUsedPort& from);
  void MergeFrom(const TMTTotalUsedPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTUsedPortList list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::mt::TMTUsedPortList& list(int index) const;
  inline ::mt::TMTUsedPortList* mutable_list(int index);
  inline ::mt::TMTUsedPortList* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUsedPortList >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUsedPortList >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:mt.TMTTotalUsedPort)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTUsedPortList > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTTotalUsedPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAudioPriorCfg : public ::google::protobuf::Message {
 public:
  TMTAudioPriorCfg();
  virtual ~TMTAudioPriorCfg();

  TMTAudioPriorCfg(const TMTAudioPriorCfg& from);

  inline TMTAudioPriorCfg& operator=(const TMTAudioPriorCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAudioPriorCfg& default_instance();

  void Swap(TMTAudioPriorCfg* other);

  // implements Message ----------------------------------------------

  TMTAudioPriorCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAudioPriorCfg& from);
  void MergeFrom(const TMTAudioPriorCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmAudFormat audio_format = 1;
  inline bool has_audio_format() const;
  inline void clear_audio_format();
  static const int kAudioFormatFieldNumber = 1;
  inline ::mt::EmAudFormat audio_format() const;
  inline void set_audio_format(::mt::EmAudFormat value);

  // optional .mt.EmAacChnlNum aac_channel_num = 2;
  inline bool has_aac_channel_num() const;
  inline void clear_aac_channel_num();
  static const int kAacChannelNumFieldNumber = 2;
  inline ::mt::EmAacChnlNum aac_channel_num() const;
  inline void set_aac_channel_num(::mt::EmAacChnlNum value);

  // optional .mt.EmAacSampFreq aac_samp_freq = 3;
  inline bool has_aac_samp_freq() const;
  inline void clear_aac_samp_freq();
  static const int kAacSampFreqFieldNumber = 3;
  inline ::mt::EmAacSampFreq aac_samp_freq() const;
  inline void set_aac_samp_freq(::mt::EmAacSampFreq value);

  // @@protoc_insertion_point(class_scope:mt.TMTAudioPriorCfg)
 private:
  inline void set_has_audio_format();
  inline void clear_has_audio_format();
  inline void set_has_aac_channel_num();
  inline void clear_has_aac_channel_num();
  inline void set_has_aac_samp_freq();
  inline void clear_has_aac_samp_freq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int audio_format_;
  int aac_channel_num_;
  int aac_samp_freq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTAudioPriorCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidPriorParam : public ::google::protobuf::Message {
 public:
  TVidPriorParam();
  virtual ~TVidPriorParam();

  TVidPriorParam(const TVidPriorParam& from);

  inline TVidPriorParam& operator=(const TVidPriorParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidPriorParam& default_instance();

  void Swap(TVidPriorParam* other);

  // implements Message ----------------------------------------------

  TVidPriorParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidPriorParam& from);
  void MergeFrom(const TVidPriorParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVidFormat video_format = 1;
  inline bool has_video_format() const;
  inline void clear_video_format();
  static const int kVideoFormatFieldNumber = 1;
  inline ::mt::EmVidFormat video_format() const;
  inline void set_video_format(::mt::EmVidFormat value);

  // optional .mt.EmMtResolution video_res = 2;
  inline bool has_video_res() const;
  inline void clear_video_res();
  static const int kVideoResFieldNumber = 2;
  inline ::mt::EmMtResolution video_res() const;
  inline void set_video_res(::mt::EmMtResolution value);

  // @@protoc_insertion_point(class_scope:mt.TVidPriorParam)
 private:
  inline void set_has_video_format();
  inline void clear_has_video_format();
  inline void set_has_video_res();
  inline void clear_has_video_res();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_format_;
  int video_res_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TVidPriorParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTMainVideoPriorCfg : public ::google::protobuf::Message {
 public:
  TMTMainVideoPriorCfg();
  virtual ~TMTMainVideoPriorCfg();

  TMTMainVideoPriorCfg(const TMTMainVideoPriorCfg& from);

  inline TMTMainVideoPriorCfg& operator=(const TMTMainVideoPriorCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTMainVideoPriorCfg& default_instance();

  void Swap(TMTMainVideoPriorCfg* other);

  // implements Message ----------------------------------------------

  TMTMainVideoPriorCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTMainVideoPriorCfg& from);
  void MergeFrom(const TMTMainVideoPriorCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVidPriorParam video_prior_param = 1;
  inline int video_prior_param_size() const;
  inline void clear_video_prior_param();
  static const int kVideoPriorParamFieldNumber = 1;
  inline const ::mt::TVidPriorParam& video_prior_param(int index) const;
  inline ::mt::TVidPriorParam* mutable_video_prior_param(int index);
  inline ::mt::TVidPriorParam* add_video_prior_param();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidPriorParam >&
      video_prior_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidPriorParam >*
      mutable_video_prior_param();

  // @@protoc_insertion_point(class_scope:mt.TMTMainVideoPriorCfg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVidPriorParam > video_prior_param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTMainVideoPriorCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCodecVidSrcInfo : public ::google::protobuf::Message {
 public:
  TMTCodecVidSrcInfo();
  virtual ~TMTCodecVidSrcInfo();

  TMTCodecVidSrcInfo(const TMTCodecVidSrcInfo& from);

  inline TMTCodecVidSrcInfo& operator=(const TMTCodecVidSrcInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCodecVidSrcInfo& default_instance();

  void Swap(TMTCodecVidSrcInfo* other);

  // implements Message ----------------------------------------------

  TMTCodecVidSrcInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCodecVidSrcInfo& from);
  void MergeFrom(const TMTCodecVidSrcInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponentIndex codec_cp_index = 1;
  inline bool has_codec_cp_index() const;
  inline void clear_codec_cp_index();
  static const int kCodecCpIndexFieldNumber = 1;
  inline ::mt::EmCodecComponentIndex codec_cp_index() const;
  inline void set_codec_cp_index(::mt::EmCodecComponentIndex value);

  // optional .mt.EmVidPort vid_port = 2;
  inline bool has_vid_port() const;
  inline void clear_vid_port();
  static const int kVidPortFieldNumber = 2;
  inline ::mt::EmVidPort vid_port() const;
  inline void set_vid_port(::mt::EmVidPort value);

  // @@protoc_insertion_point(class_scope:mt.TMTCodecVidSrcInfo)
 private:
  inline void set_has_codec_cp_index();
  inline void clear_has_codec_cp_index();
  inline void set_has_vid_port();
  inline void clear_has_vid_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int codec_cp_index_;
  int vid_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTCodecVidSrcInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAdjustAecParamCfg : public ::google::protobuf::Message {
 public:
  TAdjustAecParamCfg();
  virtual ~TAdjustAecParamCfg();

  TAdjustAecParamCfg(const TAdjustAecParamCfg& from);

  inline TAdjustAecParamCfg& operator=(const TAdjustAecParamCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAdjustAecParamCfg& default_instance();

  void Swap(TAdjustAecParamCfg* other);

  // implements Message ----------------------------------------------

  TAdjustAecParamCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAdjustAecParamCfg& from);
  void MergeFrom(const TAdjustAecParamCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bAudo = 1;
  inline bool has_baudo() const;
  inline void clear_baudo();
  static const int kBAudoFieldNumber = 1;
  inline bool baudo() const;
  inline void set_baudo(bool value);

  // optional uint32 Val = 2;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 2;
  inline ::google::protobuf::uint32 val() const;
  inline void set_val(::google::protobuf::uint32 value);

  // optional bool bEnable = 3;
  inline bool has_benable() const;
  inline void clear_benable();
  static const int kBEnableFieldNumber = 3;
  inline bool benable() const;
  inline void set_benable(bool value);

  // optional uint32 manualVal = 4;
  inline bool has_manualval() const;
  inline void clear_manualval();
  static const int kManualValFieldNumber = 4;
  inline ::google::protobuf::uint32 manualval() const;
  inline void set_manualval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TAdjustAecParamCfg)
 private:
  inline void set_has_baudo();
  inline void clear_has_baudo();
  inline void set_has_val();
  inline void clear_has_val();
  inline void set_has_benable();
  inline void clear_has_benable();
  inline void set_has_manualval();
  inline void clear_has_manualval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 val_;
  bool baudo_;
  bool benable_;
  ::google::protobuf::uint32 manualval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TAdjustAecParamCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTRestoreDefaultCfgInfo : public ::google::protobuf::Message {
 public:
  TMTRestoreDefaultCfgInfo();
  virtual ~TMTRestoreDefaultCfgInfo();

  TMTRestoreDefaultCfgInfo(const TMTRestoreDefaultCfgInfo& from);

  inline TMTRestoreDefaultCfgInfo& operator=(const TMTRestoreDefaultCfgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTRestoreDefaultCfgInfo& default_instance();

  void Swap(TMTRestoreDefaultCfgInfo* other);

  // implements Message ----------------------------------------------

  TMTRestoreDefaultCfgInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTRestoreDefaultCfgInfo& from);
  void MergeFrom(const TMTRestoreDefaultCfgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string key_list = 1;
  inline int key_list_size() const;
  inline void clear_key_list();
  static const int kKeyListFieldNumber = 1;
  inline const ::std::string& key_list(int index) const;
  inline ::std::string* mutable_key_list(int index);
  inline void set_key_list(int index, const ::std::string& value);
  inline void set_key_list(int index, const char* value);
  inline void set_key_list(int index, const char* value, size_t size);
  inline ::std::string* add_key_list();
  inline void add_key_list(const ::std::string& value);
  inline void add_key_list(const char* value);
  inline void add_key_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& key_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key_list();

  // @@protoc_insertion_point(class_scope:mt.TMTRestoreDefaultCfgInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> key_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTRestoreDefaultCfgInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoOutPortMode : public ::google::protobuf::Message {
 public:
  TMTVideoOutPortMode();
  virtual ~TMTVideoOutPortMode();

  TMTVideoOutPortMode(const TMTVideoOutPortMode& from);

  inline TMTVideoOutPortMode& operator=(const TMTVideoOutPortMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoOutPortMode& default_instance();

  void Swap(TMTVideoOutPortMode* other);

  // implements Message ----------------------------------------------

  TMTVideoOutPortMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoOutPortMode& from);
  void MergeFrom(const TMTVideoOutPortMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVideoOutPutMode first_priom_video_res = 1;
  inline bool has_first_priom_video_res() const;
  inline void clear_first_priom_video_res();
  static const int kFirstPriomVideoResFieldNumber = 1;
  inline ::mt::EmVideoOutPutMode first_priom_video_res() const;
  inline void set_first_priom_video_res(::mt::EmVideoOutPutMode value);

  // optional .mt.EmVideoOutPutMode first_priom_vga_res = 2;
  inline bool has_first_priom_vga_res() const;
  inline void clear_first_priom_vga_res();
  static const int kFirstPriomVgaResFieldNumber = 2;
  inline ::mt::EmVideoOutPutMode first_priom_vga_res() const;
  inline void set_first_priom_vga_res(::mt::EmVideoOutPutMode value);

  // optional .mt.EmVideoOutPutMode second_priom_video_res = 3;
  inline bool has_second_priom_video_res() const;
  inline void clear_second_priom_video_res();
  static const int kSecondPriomVideoResFieldNumber = 3;
  inline ::mt::EmVideoOutPutMode second_priom_video_res() const;
  inline void set_second_priom_video_res(::mt::EmVideoOutPutMode value);

  // optional .mt.EmVideoOutPutMode second_priom_vga_res = 4;
  inline bool has_second_priom_vga_res() const;
  inline void clear_second_priom_vga_res();
  static const int kSecondPriomVgaResFieldNumber = 4;
  inline ::mt::EmVideoOutPutMode second_priom_vga_res() const;
  inline void set_second_priom_vga_res(::mt::EmVideoOutPutMode value);

  // optional .mt.EmVideoOutPutMode ass_video_res = 5;
  inline bool has_ass_video_res() const;
  inline void clear_ass_video_res();
  static const int kAssVideoResFieldNumber = 5;
  inline ::mt::EmVideoOutPutMode ass_video_res() const;
  inline void set_ass_video_res(::mt::EmVideoOutPutMode value);

  // @@protoc_insertion_point(class_scope:mt.TMTVideoOutPortMode)
 private:
  inline void set_has_first_priom_video_res();
  inline void clear_has_first_priom_video_res();
  inline void set_has_first_priom_vga_res();
  inline void clear_has_first_priom_vga_res();
  inline void set_has_second_priom_video_res();
  inline void clear_has_second_priom_video_res();
  inline void set_has_second_priom_vga_res();
  inline void clear_has_second_priom_vga_res();
  inline void set_has_ass_video_res();
  inline void clear_has_ass_video_res();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int first_priom_video_res_;
  int first_priom_vga_res_;
  int second_priom_video_res_;
  int second_priom_vga_res_;
  int ass_video_res_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoOutPortMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTBannerInfo : public ::google::protobuf::Message {
 public:
  TMTBannerInfo();
  virtual ~TMTBannerInfo();

  TMTBannerInfo(const TMTBannerInfo& from);

  inline TMTBannerInfo& operator=(const TMTBannerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTBannerInfo& default_instance();

  void Swap(TMTBannerInfo* other);

  // implements Message ----------------------------------------------

  TMTBannerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTBannerInfo& from);
  void MergeFrom(const TMTBannerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bEnable = 1;
  inline bool has_benable() const;
  inline void clear_benable();
  static const int kBEnableFieldNumber = 1;
  inline bool benable() const;
  inline void set_benable(bool value);

  // optional uint32 UseType = 2;
  inline bool has_usetype() const;
  inline void clear_usetype();
  static const int kUseTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 usetype() const;
  inline void set_usetype(::google::protobuf::uint32 value);

  // optional string bk_color = 3;
  inline bool has_bk_color() const;
  inline void clear_bk_color();
  static const int kBkColorFieldNumber = 3;
  inline const ::std::string& bk_color() const;
  inline void set_bk_color(const ::std::string& value);
  inline void set_bk_color(const char* value);
  inline void set_bk_color(const char* value, size_t size);
  inline ::std::string* mutable_bk_color();
  inline ::std::string* release_bk_color();
  inline void set_allocated_bk_color(::std::string* bk_color);

  // optional .mt.EmTextAlign TextAlign = 4;
  inline bool has_textalign() const;
  inline void clear_textalign();
  static const int kTextAlignFieldNumber = 4;
  inline ::mt::EmTextAlign textalign() const;
  inline void set_textalign(::mt::EmTextAlign value);

  // optional .mt.EmRollMode RollMode = 5;
  inline bool has_rollmode() const;
  inline void clear_rollmode();
  static const int kRollModeFieldNumber = 5;
  inline ::mt::EmRollMode rollmode() const;
  inline void set_rollmode(::mt::EmRollMode value);

  // optional uint32 TransParent = 6;
  inline bool has_transparent() const;
  inline void clear_transparent();
  static const int kTransParentFieldNumber = 6;
  inline ::google::protobuf::uint32 transparent() const;
  inline void set_transparent(::google::protobuf::uint32 value);

  // optional .mt.EmRollSpeed RollSpeed = 7;
  inline bool has_rollspeed() const;
  inline void clear_rollspeed();
  static const int kRollSpeedFieldNumber = 7;
  inline ::mt::EmRollSpeed rollspeed() const;
  inline void set_rollspeed(::mt::EmRollSpeed value);

  // optional uint32 RollNum = 8;
  inline bool has_rollnum() const;
  inline void clear_rollnum();
  static const int kRollNumFieldNumber = 8;
  inline ::google::protobuf::uint32 rollnum() const;
  inline void set_rollnum(::google::protobuf::uint32 value);

  // optional uint32 StayTime = 9;
  inline bool has_staytime() const;
  inline void clear_staytime();
  static const int kStayTimeFieldNumber = 9;
  inline ::google::protobuf::uint32 staytime() const;
  inline void set_staytime(::google::protobuf::uint32 value);

  // optional .mt.TMTSymboPoint BannerCoordinate = 10;
  inline bool has_bannercoordinate() const;
  inline void clear_bannercoordinate();
  static const int kBannerCoordinateFieldNumber = 10;
  inline const ::mt::TMTSymboPoint& bannercoordinate() const;
  inline ::mt::TMTSymboPoint* mutable_bannercoordinate();
  inline ::mt::TMTSymboPoint* release_bannercoordinate();
  inline void set_allocated_bannercoordinate(::mt::TMTSymboPoint* bannercoordinate);

  // optional uint32 DisplayWidth = 11;
  inline bool has_displaywidth() const;
  inline void clear_displaywidth();
  static const int kDisplayWidthFieldNumber = 11;
  inline ::google::protobuf::uint32 displaywidth() const;
  inline void set_displaywidth(::google::protobuf::uint32 value);

  // optional uint32 DisplayHeight = 12;
  inline bool has_displayheight() const;
  inline void clear_displayheight();
  static const int kDisplayHeightFieldNumber = 12;
  inline ::google::protobuf::uint32 displayheight() const;
  inline void set_displayheight(::google::protobuf::uint32 value);

  // optional uint32 TextLineSpace = 13;
  inline bool has_textlinespace() const;
  inline void clear_textlinespace();
  static const int kTextLineSpaceFieldNumber = 13;
  inline ::google::protobuf::uint32 textlinespace() const;
  inline void set_textlinespace(::google::protobuf::uint32 value);

  // optional uint32 TextLineNum = 14;
  inline bool has_textlinenum() const;
  inline void clear_textlinenum();
  static const int kTextLineNumFieldNumber = 14;
  inline ::google::protobuf::uint32 textlinenum() const;
  inline void set_textlinenum(::google::protobuf::uint32 value);

  // optional uint32 TextDisplayRatio = 15;
  inline bool has_textdisplayratio() const;
  inline void clear_textdisplayratio();
  static const int kTextDisplayRatioFieldNumber = 15;
  inline ::google::protobuf::uint32 textdisplayratio() const;
  inline void set_textdisplayratio(::google::protobuf::uint32 value);

  // repeated .mt.TStringAndTextFormat banner_context = 16;
  inline int banner_context_size() const;
  inline void clear_banner_context();
  static const int kBannerContextFieldNumber = 16;
  inline const ::mt::TStringAndTextFormat& banner_context(int index) const;
  inline ::mt::TStringAndTextFormat* mutable_banner_context(int index);
  inline ::mt::TStringAndTextFormat* add_banner_context();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TStringAndTextFormat >&
      banner_context() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TStringAndTextFormat >*
      mutable_banner_context();

  // optional string PictureName = 17;
  inline bool has_picturename() const;
  inline void clear_picturename();
  static const int kPictureNameFieldNumber = 17;
  inline const ::std::string& picturename() const;
  inline void set_picturename(const ::std::string& value);
  inline void set_picturename(const char* value);
  inline void set_picturename(const char* value, size_t size);
  inline ::std::string* mutable_picturename();
  inline ::std::string* release_picturename();
  inline void set_allocated_picturename(::std::string* picturename);

  // optional string PresetBannerName = 18;
  inline bool has_presetbannername() const;
  inline void clear_presetbannername();
  static const int kPresetBannerNameFieldNumber = 18;
  inline const ::std::string& presetbannername() const;
  inline void set_presetbannername(const ::std::string& value);
  inline void set_presetbannername(const char* value);
  inline void set_presetbannername(const char* value, size_t size);
  inline ::std::string* mutable_presetbannername();
  inline ::std::string* release_presetbannername();
  inline void set_allocated_presetbannername(::std::string* presetbannername);

  // optional uint32 PresetBannerIndex = 19;
  inline bool has_presetbannerindex() const;
  inline void clear_presetbannerindex();
  static const int kPresetBannerIndexFieldNumber = 19;
  inline ::google::protobuf::uint32 presetbannerindex() const;
  inline void set_presetbannerindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTBannerInfo)
 private:
  inline void set_has_benable();
  inline void clear_has_benable();
  inline void set_has_usetype();
  inline void clear_has_usetype();
  inline void set_has_bk_color();
  inline void clear_has_bk_color();
  inline void set_has_textalign();
  inline void clear_has_textalign();
  inline void set_has_rollmode();
  inline void clear_has_rollmode();
  inline void set_has_transparent();
  inline void clear_has_transparent();
  inline void set_has_rollspeed();
  inline void clear_has_rollspeed();
  inline void set_has_rollnum();
  inline void clear_has_rollnum();
  inline void set_has_staytime();
  inline void clear_has_staytime();
  inline void set_has_bannercoordinate();
  inline void clear_has_bannercoordinate();
  inline void set_has_displaywidth();
  inline void clear_has_displaywidth();
  inline void set_has_displayheight();
  inline void clear_has_displayheight();
  inline void set_has_textlinespace();
  inline void clear_has_textlinespace();
  inline void set_has_textlinenum();
  inline void clear_has_textlinenum();
  inline void set_has_textdisplayratio();
  inline void clear_has_textdisplayratio();
  inline void set_has_picturename();
  inline void clear_has_picturename();
  inline void set_has_presetbannername();
  inline void clear_has_presetbannername();
  inline void set_has_presetbannerindex();
  inline void clear_has_presetbannerindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool benable_;
  ::google::protobuf::uint32 usetype_;
  ::std::string* bk_color_;
  int textalign_;
  int rollmode_;
  ::google::protobuf::uint32 transparent_;
  int rollspeed_;
  ::google::protobuf::uint32 rollnum_;
  ::google::protobuf::uint32 staytime_;
  ::mt::TMTSymboPoint* bannercoordinate_;
  ::google::protobuf::uint32 displaywidth_;
  ::google::protobuf::uint32 displayheight_;
  ::google::protobuf::uint32 textlinespace_;
  ::google::protobuf::uint32 textlinenum_;
  ::google::protobuf::RepeatedPtrField< ::mt::TStringAndTextFormat > banner_context_;
  ::std::string* picturename_;
  ::google::protobuf::uint32 textdisplayratio_;
  ::google::protobuf::uint32 presetbannerindex_;
  ::std::string* presetbannername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTBannerInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTBannerInfoList : public ::google::protobuf::Message {
 public:
  TMTBannerInfoList();
  virtual ~TMTBannerInfoList();

  TMTBannerInfoList(const TMTBannerInfoList& from);

  inline TMTBannerInfoList& operator=(const TMTBannerInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTBannerInfoList& default_instance();

  void Swap(TMTBannerInfoList* other);

  // implements Message ----------------------------------------------

  TMTBannerInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTBannerInfoList& from);
  void MergeFrom(const TMTBannerInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTBannerInfo banner_info = 1;
  inline int banner_info_size() const;
  inline void clear_banner_info();
  static const int kBannerInfoFieldNumber = 1;
  inline const ::mt::TMTBannerInfo& banner_info(int index) const;
  inline ::mt::TMTBannerInfo* mutable_banner_info(int index);
  inline ::mt::TMTBannerInfo* add_banner_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTBannerInfo >&
      banner_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTBannerInfo >*
      mutable_banner_info();

  // @@protoc_insertion_point(class_scope:mt.TMTBannerInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTBannerInfo > banner_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTBannerInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTEnablePresetBanner : public ::google::protobuf::Message {
 public:
  TMTEnablePresetBanner();
  virtual ~TMTEnablePresetBanner();

  TMTEnablePresetBanner(const TMTEnablePresetBanner& from);

  inline TMTEnablePresetBanner& operator=(const TMTEnablePresetBanner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTEnablePresetBanner& default_instance();

  void Swap(TMTEnablePresetBanner* other);

  // implements Message ----------------------------------------------

  TMTEnablePresetBanner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTEnablePresetBanner& from);
  void MergeFrom(const TMTEnablePresetBanner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 BannerIndex = 1;
  inline bool has_bannerindex() const;
  inline void clear_bannerindex();
  static const int kBannerIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 bannerindex() const;
  inline void set_bannerindex(::google::protobuf::uint32 value);

  // optional bool bEnable = 2;
  inline bool has_benable() const;
  inline void clear_benable();
  static const int kBEnableFieldNumber = 2;
  inline bool benable() const;
  inline void set_benable(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTEnablePresetBanner)
 private:
  inline void set_has_bannerindex();
  inline void clear_has_bannerindex();
  inline void set_has_benable();
  inline void clear_has_benable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 bannerindex_;
  bool benable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTEnablePresetBanner* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTLabelInfo : public ::google::protobuf::Message {
 public:
  TMTLabelInfo();
  virtual ~TMTLabelInfo();

  TMTLabelInfo(const TMTLabelInfo& from);

  inline TMTLabelInfo& operator=(const TMTLabelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTLabelInfo& default_instance();

  void Swap(TMTLabelInfo* other);

  // implements Message ----------------------------------------------

  TMTLabelInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTLabelInfo& from);
  void MergeFrom(const TMTLabelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmLabelType emLabelType = 1;
  inline bool has_emlabeltype() const;
  inline void clear_emlabeltype();
  static const int kEmLabelTypeFieldNumber = 1;
  inline ::mt::EmLabelType emlabeltype() const;
  inline void set_emlabeltype(::mt::EmLabelType value);

  // optional .mt.TMTSymboPoint tLableCoordinate = 2;
  inline bool has_tlablecoordinate() const;
  inline void clear_tlablecoordinate();
  static const int kTLableCoordinateFieldNumber = 2;
  inline const ::mt::TMTSymboPoint& tlablecoordinate() const;
  inline ::mt::TMTSymboPoint* mutable_tlablecoordinate();
  inline ::mt::TMTSymboPoint* release_tlablecoordinate();
  inline void set_allocated_tlablecoordinate(::mt::TMTSymboPoint* tlablecoordinate);

  // optional .mt.EmLabelPosType emLabelPosType = 3;
  inline bool has_emlabelpostype() const;
  inline void clear_emlabelpostype();
  static const int kEmLabelPosTypeFieldNumber = 3;
  inline ::mt::EmLabelPosType emlabelpostype() const;
  inline void set_emlabelpostype(::mt::EmLabelPosType value);

  // repeated .mt.TStringAndTextFormat custom_label_content = 4;
  inline int custom_label_content_size() const;
  inline void clear_custom_label_content();
  static const int kCustomLabelContentFieldNumber = 4;
  inline const ::mt::TStringAndTextFormat& custom_label_content(int index) const;
  inline ::mt::TStringAndTextFormat* mutable_custom_label_content(int index);
  inline ::mt::TStringAndTextFormat* add_custom_label_content();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TStringAndTextFormat >&
      custom_label_content() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TStringAndTextFormat >*
      mutable_custom_label_content();

  // optional string PictureName = 5;
  inline bool has_picturename() const;
  inline void clear_picturename();
  static const int kPictureNameFieldNumber = 5;
  inline const ::std::string& picturename() const;
  inline void set_picturename(const ::std::string& value);
  inline void set_picturename(const char* value);
  inline void set_picturename(const char* value, size_t size);
  inline ::std::string* mutable_picturename();
  inline ::std::string* release_picturename();
  inline void set_allocated_picturename(::std::string* picturename);

  // optional string AutoTextContent = 6;
  inline bool has_autotextcontent() const;
  inline void clear_autotextcontent();
  static const int kAutoTextContentFieldNumber = 6;
  inline const ::std::string& autotextcontent() const;
  inline void set_autotextcontent(const ::std::string& value);
  inline void set_autotextcontent(const char* value);
  inline void set_autotextcontent(const char* value, size_t size);
  inline ::std::string* mutable_autotextcontent();
  inline ::std::string* release_autotextcontent();
  inline void set_allocated_autotextcontent(::std::string* autotextcontent);

  // @@protoc_insertion_point(class_scope:mt.TMTLabelInfo)
 private:
  inline void set_has_emlabeltype();
  inline void clear_has_emlabeltype();
  inline void set_has_tlablecoordinate();
  inline void clear_has_tlablecoordinate();
  inline void set_has_emlabelpostype();
  inline void clear_has_emlabelpostype();
  inline void set_has_picturename();
  inline void clear_has_picturename();
  inline void set_has_autotextcontent();
  inline void clear_has_autotextcontent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTSymboPoint* tlablecoordinate_;
  int emlabeltype_;
  int emlabelpostype_;
  ::google::protobuf::RepeatedPtrField< ::mt::TStringAndTextFormat > custom_label_content_;
  ::std::string* picturename_;
  ::std::string* autotextcontent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTLabelInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TStringAndTextFormat : public ::google::protobuf::Message {
 public:
  TStringAndTextFormat();
  virtual ~TStringAndTextFormat();

  TStringAndTextFormat(const TStringAndTextFormat& from);

  inline TStringAndTextFormat& operator=(const TStringAndTextFormat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStringAndTextFormat& default_instance();

  void Swap(TStringAndTextFormat* other);

  // implements Message ----------------------------------------------

  TStringAndTextFormat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStringAndTextFormat& from);
  void MergeFrom(const TStringAndTextFormat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string facename_type = 1;
  inline bool has_facename_type() const;
  inline void clear_facename_type();
  static const int kFacenameTypeFieldNumber = 1;
  inline const ::std::string& facename_type() const;
  inline void set_facename_type(const ::std::string& value);
  inline void set_facename_type(const char* value);
  inline void set_facename_type(const char* value, size_t size);
  inline ::std::string* mutable_facename_type();
  inline ::std::string* release_facename_type();
  inline void set_allocated_facename_type(::std::string* facename_type);

  // optional string text_color = 2;
  inline bool has_text_color() const;
  inline void clear_text_color();
  static const int kTextColorFieldNumber = 2;
  inline const ::std::string& text_color() const;
  inline void set_text_color(const ::std::string& value);
  inline void set_text_color(const char* value);
  inline void set_text_color(const char* value, size_t size);
  inline ::std::string* mutable_text_color();
  inline ::std::string* release_text_color();
  inline void set_allocated_text_color(::std::string* text_color);

  // optional string text_size = 3;
  inline bool has_text_size() const;
  inline void clear_text_size();
  static const int kTextSizeFieldNumber = 3;
  inline const ::std::string& text_size() const;
  inline void set_text_size(const ::std::string& value);
  inline void set_text_size(const char* value);
  inline void set_text_size(const char* value, size_t size);
  inline ::std::string* mutable_text_size();
  inline ::std::string* release_text_size();
  inline void set_allocated_text_size(::std::string* text_size);

  // optional bool text_bold = 4;
  inline bool has_text_bold() const;
  inline void clear_text_bold();
  static const int kTextBoldFieldNumber = 4;
  inline bool text_bold() const;
  inline void set_text_bold(bool value);

  // optional bool text_italic = 5;
  inline bool has_text_italic() const;
  inline void clear_text_italic();
  static const int kTextItalicFieldNumber = 5;
  inline bool text_italic() const;
  inline void set_text_italic(bool value);

  // optional bool text_underline = 6;
  inline bool has_text_underline() const;
  inline void clear_text_underline();
  static const int kTextUnderlineFieldNumber = 6;
  inline bool text_underline() const;
  inline void set_text_underline(bool value);

  // optional string text_content = 7;
  inline bool has_text_content() const;
  inline void clear_text_content();
  static const int kTextContentFieldNumber = 7;
  inline const ::std::string& text_content() const;
  inline void set_text_content(const ::std::string& value);
  inline void set_text_content(const char* value);
  inline void set_text_content(const char* value, size_t size);
  inline ::std::string* mutable_text_content();
  inline ::std::string* release_text_content();
  inline void set_allocated_text_content(::std::string* text_content);

  // optional bool auto_wrap = 8;
  inline bool has_auto_wrap() const;
  inline void clear_auto_wrap();
  static const int kAutoWrapFieldNumber = 8;
  inline bool auto_wrap() const;
  inline void set_auto_wrap(bool value);

  // @@protoc_insertion_point(class_scope:mt.TStringAndTextFormat)
 private:
  inline void set_has_facename_type();
  inline void clear_has_facename_type();
  inline void set_has_text_color();
  inline void clear_has_text_color();
  inline void set_has_text_size();
  inline void clear_has_text_size();
  inline void set_has_text_bold();
  inline void clear_has_text_bold();
  inline void set_has_text_italic();
  inline void clear_has_text_italic();
  inline void set_has_text_underline();
  inline void clear_has_text_underline();
  inline void set_has_text_content();
  inline void clear_has_text_content();
  inline void set_has_auto_wrap();
  inline void clear_has_auto_wrap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* facename_type_;
  ::std::string* text_color_;
  ::std::string* text_size_;
  ::std::string* text_content_;
  bool text_bold_;
  bool text_italic_;
  bool text_underline_;
  bool auto_wrap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TStringAndTextFormat* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAutoSleep : public ::google::protobuf::Message {
 public:
  TMTAutoSleep();
  virtual ~TMTAutoSleep();

  TMTAutoSleep(const TMTAutoSleep& from);

  inline TMTAutoSleep& operator=(const TMTAutoSleep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAutoSleep& default_instance();

  void Swap(TMTAutoSleep* other);

  // implements Message ----------------------------------------------

  TMTAutoSleep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAutoSleep& from);
  void MergeFrom(const TMTAutoSleep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bEnable = 1;
  inline bool has_benable() const;
  inline void clear_benable();
  static const int kBEnableFieldNumber = 1;
  inline bool benable() const;
  inline void set_benable(bool value);

  // optional uint32 TimeOut = 2;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeOutFieldNumber = 2;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool bAllowCall = 3;
  inline bool has_ballowcall() const;
  inline void clear_ballowcall();
  static const int kBAllowCallFieldNumber = 3;
  inline bool ballowcall() const;
  inline void set_ballowcall(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTAutoSleep)
 private:
  inline void set_has_benable();
  inline void clear_has_benable();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_ballowcall();
  inline void clear_has_ballowcall();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 timeout_;
  bool benable_;
  bool ballowcall_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTAutoSleep* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCfgSystemTime : public ::google::protobuf::Message {
 public:
  TMTCfgSystemTime();
  virtual ~TMTCfgSystemTime();

  TMTCfgSystemTime(const TMTCfgSystemTime& from);

  inline TMTCfgSystemTime& operator=(const TMTCfgSystemTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCfgSystemTime& default_instance();

  void Swap(TMTCfgSystemTime* other);

  // implements Message ----------------------------------------------

  TMTCfgSystemTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCfgSystemTime& from);
  void MergeFrom(const TMTCfgSystemTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bSyncServer = 1;
  inline bool has_bsyncserver() const;
  inline void clear_bsyncserver();
  static const int kBSyncServerFieldNumber = 1;
  inline bool bsyncserver() const;
  inline void set_bsyncserver(bool value);

  // optional .mt.EmTimeZone emTimeZone = 2;
  inline bool has_emtimezone() const;
  inline void clear_emtimezone();
  static const int kEmTimeZoneFieldNumber = 2;
  inline ::mt::EmTimeZone emtimezone() const;
  inline void set_emtimezone(::mt::EmTimeZone value);

  // @@protoc_insertion_point(class_scope:mt.TMTCfgSystemTime)
 private:
  inline void set_has_bsyncserver();
  inline void clear_has_bsyncserver();
  inline void set_has_emtimezone();
  inline void clear_has_emtimezone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool bsyncserver_;
  int emtimezone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTCfgSystemTime* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoShowMode : public ::google::protobuf::Message {
 public:
  TMTVideoShowMode();
  virtual ~TMTVideoShowMode();

  TMTVideoShowMode(const TMTVideoShowMode& from);

  inline TMTVideoShowMode& operator=(const TMTVideoShowMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoShowMode& default_instance();

  void Swap(TMTVideoShowMode* other);

  // implements Message ----------------------------------------------

  TMTVideoShowMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoShowMode& from);
  void MergeFrom(const TMTVideoShowMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmDualVideoShowMode emShowMode = 1;
  inline bool has_emshowmode() const;
  inline void clear_emshowmode();
  static const int kEmShowModeFieldNumber = 1;
  inline ::mt::EmDualVideoShowMode emshowmode() const;
  inline void set_emshowmode(::mt::EmDualVideoShowMode value);

  // @@protoc_insertion_point(class_scope:mt.TMTVideoShowMode)
 private:
  inline void set_has_emshowmode();
  inline void clear_has_emshowmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emshowmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoShowMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDAudInPort : public ::google::protobuf::Message {
 public:
  TMTHDAudInPort();
  virtual ~TMTHDAudInPort();

  TMTHDAudInPort(const TMTHDAudInPort& from);

  inline TMTHDAudInPort& operator=(const TMTHDAudInPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDAudInPort& default_instance();

  void Swap(TMTHDAudInPort* other);

  // implements Message ----------------------------------------------

  TMTHDAudInPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDAudInPort& from);
  void MergeFrom(const TMTHDAudInPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.EmHDAudPortIn emAudInPortList = 1;
  inline int emaudinportlist_size() const;
  inline void clear_emaudinportlist();
  static const int kEmAudInPortListFieldNumber = 1;
  inline ::mt::EmHDAudPortIn emaudinportlist(int index) const;
  inline void set_emaudinportlist(int index, ::mt::EmHDAudPortIn value);
  inline void add_emaudinportlist(::mt::EmHDAudPortIn value);
  inline const ::google::protobuf::RepeatedField<int>& emaudinportlist() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_emaudinportlist();

  // @@protoc_insertion_point(class_scope:mt.TMTHDAudInPort)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> emaudinportlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDAudInPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDAudInPortList : public ::google::protobuf::Message {
 public:
  TMTHDAudInPortList();
  virtual ~TMTHDAudInPortList();

  TMTHDAudInPortList(const TMTHDAudInPortList& from);

  inline TMTHDAudInPortList& operator=(const TMTHDAudInPortList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDAudInPortList& default_instance();

  void Swap(TMTHDAudInPortList* other);

  // implements Message ----------------------------------------------

  TMTHDAudInPortList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDAudInPortList& from);
  void MergeFrom(const TMTHDAudInPortList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMTHDAudInPort emMainMicPortList = 1;
  inline bool has_emmainmicportlist() const;
  inline void clear_emmainmicportlist();
  static const int kEmMainMicPortListFieldNumber = 1;
  inline const ::mt::TMTHDAudInPort& emmainmicportlist() const;
  inline ::mt::TMTHDAudInPort* mutable_emmainmicportlist();
  inline ::mt::TMTHDAudInPort* release_emmainmicportlist();
  inline void set_allocated_emmainmicportlist(::mt::TMTHDAudInPort* emmainmicportlist);

  // optional .mt.TMTHDAudInPort emLineInPortList = 2;
  inline bool has_emlineinportlist() const;
  inline void clear_emlineinportlist();
  static const int kEmLineInPortListFieldNumber = 2;
  inline const ::mt::TMTHDAudInPort& emlineinportlist() const;
  inline ::mt::TMTHDAudInPort* mutable_emlineinportlist();
  inline ::mt::TMTHDAudInPort* release_emlineinportlist();
  inline void set_allocated_emlineinportlist(::mt::TMTHDAudInPort* emlineinportlist);

  // optional bool aux_is_mic = 3;
  inline bool has_aux_is_mic() const;
  inline void clear_aux_is_mic();
  static const int kAuxIsMicFieldNumber = 3;
  inline bool aux_is_mic() const;
  inline void set_aux_is_mic(bool value);

  // optional bool line_is_mic = 4;
  inline bool has_line_is_mic() const;
  inline void clear_line_is_mic();
  static const int kLineIsMicFieldNumber = 4;
  inline bool line_is_mic() const;
  inline void set_line_is_mic(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTHDAudInPortList)
 private:
  inline void set_has_emmainmicportlist();
  inline void clear_has_emmainmicportlist();
  inline void set_has_emlineinportlist();
  inline void clear_has_emlineinportlist();
  inline void set_has_aux_is_mic();
  inline void clear_has_aux_is_mic();
  inline void set_has_line_is_mic();
  inline void clear_has_line_is_mic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTHDAudInPort* emmainmicportlist_;
  ::mt::TMTHDAudInPort* emlineinportlist_;
  bool aux_is_mic_;
  bool line_is_mic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDAudInPortList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDAudOutPortList : public ::google::protobuf::Message {
 public:
  TMTHDAudOutPortList();
  virtual ~TMTHDAudOutPortList();

  TMTHDAudOutPortList(const TMTHDAudOutPortList& from);

  inline TMTHDAudOutPortList& operator=(const TMTHDAudOutPortList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDAudOutPortList& default_instance();

  void Swap(TMTHDAudOutPortList* other);

  // implements Message ----------------------------------------------

  TMTHDAudOutPortList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDAudOutPortList& from);
  void MergeFrom(const TMTHDAudOutPortList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.EmHDAudPortOut emAudOutPortList = 1;
  inline int emaudoutportlist_size() const;
  inline void clear_emaudoutportlist();
  static const int kEmAudOutPortListFieldNumber = 1;
  inline ::mt::EmHDAudPortOut emaudoutportlist(int index) const;
  inline void set_emaudoutportlist(int index, ::mt::EmHDAudPortOut value);
  inline void add_emaudoutportlist(::mt::EmHDAudPortOut value);
  inline const ::google::protobuf::RepeatedField<int>& emaudoutportlist() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_emaudoutportlist();

  // @@protoc_insertion_point(class_scope:mt.TMTHDAudOutPortList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> emaudoutportlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDAudOutPortList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDVidInPort : public ::google::protobuf::Message {
 public:
  TMTHDVidInPort();
  virtual ~TMTHDVidInPort();

  TMTHDVidInPort(const TMTHDVidInPort& from);

  inline TMTHDVidInPort& operator=(const TMTHDVidInPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDVidInPort& default_instance();

  void Swap(TMTHDVidInPort* other);

  // implements Message ----------------------------------------------

  TMTHDVidInPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDVidInPort& from);
  void MergeFrom(const TMTHDVidInPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVideoType emVideoType = 1;
  inline bool has_emvideotype() const;
  inline void clear_emvideotype();
  static const int kEmVideoTypeFieldNumber = 1;
  inline ::mt::EmVideoType emvideotype() const;
  inline void set_emvideotype(::mt::EmVideoType value);

  // optional .mt.EmMtVideoPort emVideoInPort = 2;
  inline bool has_emvideoinport() const;
  inline void clear_emvideoinport();
  static const int kEmVideoInPortFieldNumber = 2;
  inline ::mt::EmMtVideoPort emvideoinport() const;
  inline void set_emvideoinport(::mt::EmMtVideoPort value);

  // @@protoc_insertion_point(class_scope:mt.TMTHDVidInPort)
 private:
  inline void set_has_emvideotype();
  inline void clear_has_emvideotype();
  inline void set_has_emvideoinport();
  inline void clear_has_emvideoinport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emvideotype_;
  int emvideoinport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDVidInPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDVidInPortCap : public ::google::protobuf::Message {
 public:
  TMTHDVidInPortCap();
  virtual ~TMTHDVidInPortCap();

  TMTHDVidInPortCap(const TMTHDVidInPortCap& from);

  inline TMTHDVidInPortCap& operator=(const TMTHDVidInPortCap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDVidInPortCap& default_instance();

  void Swap(TMTHDVidInPortCap* other);

  // implements Message ----------------------------------------------

  TMTHDVidInPortCap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDVidInPortCap& from);
  void MergeFrom(const TMTHDVidInPortCap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVideoType video_type = 1;
  inline bool has_video_type() const;
  inline void clear_video_type();
  static const int kVideoTypeFieldNumber = 1;
  inline ::mt::EmVideoType video_type() const;
  inline void set_video_type(::mt::EmVideoType value);

  // repeated .mt.EmMtVideoPort video_port = 2;
  inline int video_port_size() const;
  inline void clear_video_port();
  static const int kVideoPortFieldNumber = 2;
  inline ::mt::EmMtVideoPort video_port(int index) const;
  inline void set_video_port(int index, ::mt::EmMtVideoPort value);
  inline void add_video_port(::mt::EmMtVideoPort value);
  inline const ::google::protobuf::RepeatedField<int>& video_port() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_video_port();

  // @@protoc_insertion_point(class_scope:mt.TMTHDVidInPortCap)
 private:
  inline void set_has_video_type();
  inline void clear_has_video_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> video_port_;
  int video_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDVidInPortCap* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDVidInPortCapList : public ::google::protobuf::Message {
 public:
  TMTHDVidInPortCapList();
  virtual ~TMTHDVidInPortCapList();

  TMTHDVidInPortCapList(const TMTHDVidInPortCapList& from);

  inline TMTHDVidInPortCapList& operator=(const TMTHDVidInPortCapList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDVidInPortCapList& default_instance();

  void Swap(TMTHDVidInPortCapList* other);

  // implements Message ----------------------------------------------

  TMTHDVidInPortCapList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDVidInPortCapList& from);
  void MergeFrom(const TMTHDVidInPortCapList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTHDVidInPortCap video_cap_list = 1;
  inline int video_cap_list_size() const;
  inline void clear_video_cap_list();
  static const int kVideoCapListFieldNumber = 1;
  inline const ::mt::TMTHDVidInPortCap& video_cap_list(int index) const;
  inline ::mt::TMTHDVidInPortCap* mutable_video_cap_list(int index);
  inline ::mt::TMTHDVidInPortCap* add_video_cap_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTHDVidInPortCap >&
      video_cap_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTHDVidInPortCap >*
      mutable_video_cap_list();

  // @@protoc_insertion_point(class_scope:mt.TMTHDVidInPortCapList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTHDVidInPortCap > video_cap_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDVidInPortCapList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDMultiVideo : public ::google::protobuf::Message {
 public:
  TMTHDMultiVideo();
  virtual ~TMTHDMultiVideo();

  TMTHDMultiVideo(const TMTHDMultiVideo& from);

  inline TMTHDMultiVideo& operator=(const TMTHDMultiVideo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDMultiVideo& default_instance();

  void Swap(TMTHDMultiVideo* other);

  // implements Message ----------------------------------------------

  TMTHDMultiVideo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDMultiVideo& from);
  void MergeFrom(const TMTHDMultiVideo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmHDMultiVideoSwitch emMVType = 1;
  inline bool has_emmvtype() const;
  inline void clear_emmvtype();
  static const int kEmMVTypeFieldNumber = 1;
  inline ::mt::EmHDMultiVideoSwitch emmvtype() const;
  inline void set_emmvtype(::mt::EmHDMultiVideoSwitch value);

  // optional .mt.EmHDMultiViewMP emVMPType = 2;
  inline bool has_emvmptype() const;
  inline void clear_emvmptype();
  static const int kEmVMPTypeFieldNumber = 2;
  inline ::mt::EmHDMultiViewMP emvmptype() const;
  inline void set_emvmptype(::mt::EmHDMultiViewMP value);

  // repeated .mt.EmMtVideoPort emVideoInPortList = 3;
  inline int emvideoinportlist_size() const;
  inline void clear_emvideoinportlist();
  static const int kEmVideoInPortListFieldNumber = 3;
  inline ::mt::EmMtVideoPort emvideoinportlist(int index) const;
  inline void set_emvideoinportlist(int index, ::mt::EmMtVideoPort value);
  inline void add_emvideoinportlist(::mt::EmMtVideoPort value);
  inline const ::google::protobuf::RepeatedField<int>& emvideoinportlist() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_emvideoinportlist();

  // @@protoc_insertion_point(class_scope:mt.TMTHDMultiVideo)
 private:
  inline void set_has_emmvtype();
  inline void clear_has_emmvtype();
  inline void set_has_emvmptype();
  inline void clear_has_emvmptype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emmvtype_;
  int emvmptype_;
  ::google::protobuf::RepeatedField<int> emvideoinportlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDMultiVideo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTDisplayRatio : public ::google::protobuf::Message {
 public:
  TMTDisplayRatio();
  virtual ~TMTDisplayRatio();

  TMTDisplayRatio(const TMTDisplayRatio& from);

  inline TMTDisplayRatio& operator=(const TMTDisplayRatio& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTDisplayRatio& default_instance();

  void Swap(TMTDisplayRatio* other);

  // implements Message ----------------------------------------------

  TMTDisplayRatio* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTDisplayRatio& from);
  void MergeFrom(const TMTDisplayRatio& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVideoType emVideoType = 1;
  inline bool has_emvideotype() const;
  inline void clear_emvideotype();
  static const int kEmVideoTypeFieldNumber = 1;
  inline ::mt::EmVideoType emvideotype() const;
  inline void set_emvideotype(::mt::EmVideoType value);

  // optional .mt.EmDisplayRatio emRatio = 2;
  inline bool has_emratio() const;
  inline void clear_emratio();
  static const int kEmRatioFieldNumber = 2;
  inline ::mt::EmDisplayRatio emratio() const;
  inline void set_emratio(::mt::EmDisplayRatio value);

  // @@protoc_insertion_point(class_scope:mt.TMTDisplayRatio)
 private:
  inline void set_has_emvideotype();
  inline void clear_has_emvideotype();
  inline void set_has_emratio();
  inline void clear_has_emratio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emvideotype_;
  int emratio_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTDisplayRatio* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVidInPortMode : public ::google::protobuf::Message {
 public:
  TMTVidInPortMode();
  virtual ~TMTVidInPortMode();

  TMTVidInPortMode(const TMTVidInPortMode& from);

  inline TMTVidInPortMode& operator=(const TMTVidInPortMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVidInPortMode& default_instance();

  void Swap(TMTVidInPortMode* other);

  // implements Message ----------------------------------------------

  TMTVidInPortMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVidInPortMode& from);
  void MergeFrom(const TMTVidInPortMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtVideoPort emVideoInPort = 1;
  inline bool has_emvideoinport() const;
  inline void clear_emvideoinport();
  static const int kEmVideoInPortFieldNumber = 1;
  inline ::mt::EmMtVideoPort emvideoinport() const;
  inline void set_emvideoinport(::mt::EmMtVideoPort value);

  // optional .mt.EmHDVideoPortMode emInPortMode = 2;
  inline bool has_eminportmode() const;
  inline void clear_eminportmode();
  static const int kEmInPortModeFieldNumber = 2;
  inline ::mt::EmHDVideoPortMode eminportmode() const;
  inline void set_eminportmode(::mt::EmHDVideoPortMode value);

  // @@protoc_insertion_point(class_scope:mt.TMTVidInPortMode)
 private:
  inline void set_has_emvideoinport();
  inline void clear_has_emvideoinport();
  inline void set_has_eminportmode();
  inline void clear_has_eminportmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emvideoinport_;
  int eminportmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVidInPortMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVidOutPortMode : public ::google::protobuf::Message {
 public:
  TMTVidOutPortMode();
  virtual ~TMTVidOutPortMode();

  TMTVidOutPortMode(const TMTVidOutPortMode& from);

  inline TMTVidOutPortMode& operator=(const TMTVidOutPortMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVidOutPortMode& default_instance();

  void Swap(TMTVidOutPortMode* other);

  // implements Message ----------------------------------------------

  TMTVidOutPortMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVidOutPortMode& from);
  void MergeFrom(const TMTVidOutPortMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmHDVideoOutPortType emVideoOutPort = 1;
  inline bool has_emvideooutport() const;
  inline void clear_emvideooutport();
  static const int kEmVideoOutPortFieldNumber = 1;
  inline ::mt::EmHDVideoOutPortType emvideooutport() const;
  inline void set_emvideooutport(::mt::EmHDVideoOutPortType value);

  // optional .mt.EmHDVideoPortMode emOutPortMode = 2;
  inline bool has_emoutportmode() const;
  inline void clear_emoutportmode();
  static const int kEmOutPortModeFieldNumber = 2;
  inline ::mt::EmHDVideoPortMode emoutportmode() const;
  inline void set_emoutportmode(::mt::EmHDVideoPortMode value);

  // @@protoc_insertion_point(class_scope:mt.TMTVidOutPortMode)
 private:
  inline void set_has_emvideooutport();
  inline void clear_has_emvideooutport();
  inline void set_has_emoutportmode();
  inline void clear_has_emoutportmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emvideooutport_;
  int emoutportmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVidOutPortMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoOutPort2InPort : public ::google::protobuf::Message {
 public:
  TMTVideoOutPort2InPort();
  virtual ~TMTVideoOutPort2InPort();

  TMTVideoOutPort2InPort(const TMTVideoOutPort2InPort& from);

  inline TMTVideoOutPort2InPort& operator=(const TMTVideoOutPort2InPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoOutPort2InPort& default_instance();

  void Swap(TMTVideoOutPort2InPort* other);

  // implements Message ----------------------------------------------

  TMTVideoOutPort2InPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoOutPort2InPort& from);
  void MergeFrom(const TMTVideoOutPort2InPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmHDVideoOutPortType emVideoOutPort = 1;
  inline bool has_emvideooutport() const;
  inline void clear_emvideooutport();
  static const int kEmVideoOutPortFieldNumber = 1;
  inline ::mt::EmHDVideoOutPortType emvideooutport() const;
  inline void set_emvideooutport(::mt::EmHDVideoOutPortType value);

  // optional .mt.EmHDVideoSourceType emVideoOutType = 2;
  inline bool has_emvideoouttype() const;
  inline void clear_emvideoouttype();
  static const int kEmVideoOutTypeFieldNumber = 2;
  inline ::mt::EmHDVideoSourceType emvideoouttype() const;
  inline void set_emvideoouttype(::mt::EmHDVideoSourceType value);

  // @@protoc_insertion_point(class_scope:mt.TMTVideoOutPort2InPort)
 private:
  inline void set_has_emvideooutport();
  inline void clear_has_emvideooutport();
  inline void set_has_emvideoouttype();
  inline void clear_has_emvideoouttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emvideooutport_;
  int emvideoouttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoOutPort2InPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVideoMatrixScheme : public ::google::protobuf::Message {
 public:
  TMTVideoMatrixScheme();
  virtual ~TMTVideoMatrixScheme();

  TMTVideoMatrixScheme(const TMTVideoMatrixScheme& from);

  inline TMTVideoMatrixScheme& operator=(const TMTVideoMatrixScheme& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVideoMatrixScheme& default_instance();

  void Swap(TMTVideoMatrixScheme* other);

  // implements Message ----------------------------------------------

  TMTVideoMatrixScheme* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVideoMatrixScheme& from);
  void MergeFrom(const TMTVideoMatrixScheme& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SchemeID = 1;
  inline bool has_schemeid() const;
  inline void clear_schemeid();
  static const int kSchemeIDFieldNumber = 1;
  inline ::google::protobuf::uint32 schemeid() const;
  inline void set_schemeid(::google::protobuf::uint32 value);

  // optional string SchemeName = 2;
  inline bool has_schemename() const;
  inline void clear_schemename();
  static const int kSchemeNameFieldNumber = 2;
  inline const ::std::string& schemename() const;
  inline void set_schemename(const ::std::string& value);
  inline void set_schemename(const char* value);
  inline void set_schemename(const char* value, size_t size);
  inline ::std::string* mutable_schemename();
  inline ::std::string* release_schemename();
  inline void set_allocated_schemename(::std::string* schemename);

  // repeated .mt.TMTVidInPortMode tInPortMode = 3;
  inline int tinportmode_size() const;
  inline void clear_tinportmode();
  static const int kTInPortModeFieldNumber = 3;
  inline const ::mt::TMTVidInPortMode& tinportmode(int index) const;
  inline ::mt::TMTVidInPortMode* mutable_tinportmode(int index);
  inline ::mt::TMTVidInPortMode* add_tinportmode();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidInPortMode >&
      tinportmode() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidInPortMode >*
      mutable_tinportmode();

  // repeated .mt.TMTVidOutPortMode tOutPortMode = 4;
  inline int toutportmode_size() const;
  inline void clear_toutportmode();
  static const int kTOutPortModeFieldNumber = 4;
  inline const ::mt::TMTVidOutPortMode& toutportmode(int index) const;
  inline ::mt::TMTVidOutPortMode* mutable_toutportmode(int index);
  inline ::mt::TMTVidOutPortMode* add_toutportmode();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidOutPortMode >&
      toutportmode() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidOutPortMode >*
      mutable_toutportmode();

  // repeated .mt.TMTVideoOutPort2InPort tOutPort2InPort = 5;
  inline int toutport2inport_size() const;
  inline void clear_toutport2inport();
  static const int kTOutPort2InPortFieldNumber = 5;
  inline const ::mt::TMTVideoOutPort2InPort& toutport2inport(int index) const;
  inline ::mt::TMTVideoOutPort2InPort* mutable_toutport2inport(int index);
  inline ::mt::TMTVideoOutPort2InPort* add_toutport2inport();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoOutPort2InPort >&
      toutport2inport() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoOutPort2InPort >*
      mutable_toutport2inport();

  // @@protoc_insertion_point(class_scope:mt.TMTVideoMatrixScheme)
 private:
  inline void set_has_schemeid();
  inline void clear_has_schemeid();
  inline void set_has_schemename();
  inline void clear_has_schemename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* schemename_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVidInPortMode > tinportmode_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVidOutPortMode > toutportmode_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoOutPort2InPort > toutport2inport_;
  ::google::protobuf::uint32 schemeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVideoMatrixScheme* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAllVideoMatrixScheme : public ::google::protobuf::Message {
 public:
  TMTAllVideoMatrixScheme();
  virtual ~TMTAllVideoMatrixScheme();

  TMTAllVideoMatrixScheme(const TMTAllVideoMatrixScheme& from);

  inline TMTAllVideoMatrixScheme& operator=(const TMTAllVideoMatrixScheme& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAllVideoMatrixScheme& default_instance();

  void Swap(TMTAllVideoMatrixScheme* other);

  // implements Message ----------------------------------------------

  TMTAllVideoMatrixScheme* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAllVideoMatrixScheme& from);
  void MergeFrom(const TMTAllVideoMatrixScheme& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SchemeID = 1;
  inline bool has_schemeid() const;
  inline void clear_schemeid();
  static const int kSchemeIDFieldNumber = 1;
  inline ::google::protobuf::uint32 schemeid() const;
  inline void set_schemeid(::google::protobuf::uint32 value);

  // repeated .mt.TMTVideoMatrixScheme tMatrixScheme = 2;
  inline int tmatrixscheme_size() const;
  inline void clear_tmatrixscheme();
  static const int kTMatrixSchemeFieldNumber = 2;
  inline const ::mt::TMTVideoMatrixScheme& tmatrixscheme(int index) const;
  inline ::mt::TMTVideoMatrixScheme* mutable_tmatrixscheme(int index);
  inline ::mt::TMTVideoMatrixScheme* add_tmatrixscheme();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoMatrixScheme >&
      tmatrixscheme() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoMatrixScheme >*
      mutable_tmatrixscheme();

  // @@protoc_insertion_point(class_scope:mt.TMTAllVideoMatrixScheme)
 private:
  inline void set_has_schemeid();
  inline void clear_has_schemeid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoMatrixScheme > tmatrixscheme_;
  ::google::protobuf::uint32 schemeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTAllVideoMatrixScheme* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTLastDisplay : public ::google::protobuf::Message {
 public:
  TMTLastDisplay();
  virtual ~TMTLastDisplay();

  TMTLastDisplay(const TMTLastDisplay& from);

  inline TMTLastDisplay& operator=(const TMTLastDisplay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTLastDisplay& default_instance();

  void Swap(TMTLastDisplay* other);

  // implements Message ----------------------------------------------

  TMTLastDisplay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTLastDisplay& from);
  void MergeFrom(const TMTLastDisplay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmHDLastDisplay emLastDisplayType = 1;
  inline bool has_emlastdisplaytype() const;
  inline void clear_emlastdisplaytype();
  static const int kEmLastDisplayTypeFieldNumber = 1;
  inline ::mt::EmHDLastDisplay emlastdisplaytype() const;
  inline void set_emlastdisplaytype(::mt::EmHDLastDisplay value);

  // optional uint32 wait_timer = 2;
  inline bool has_wait_timer() const;
  inline void clear_wait_timer();
  static const int kWaitTimerFieldNumber = 2;
  inline ::google::protobuf::uint32 wait_timer() const;
  inline void set_wait_timer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTLastDisplay)
 private:
  inline void set_has_emlastdisplaytype();
  inline void clear_has_emlastdisplaytype();
  inline void set_has_wait_timer();
  inline void clear_has_wait_timer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emlastdisplaytype_;
  ::google::protobuf::uint32 wait_timer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTLastDisplay* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDImageNoise : public ::google::protobuf::Message {
 public:
  TMTHDImageNoise();
  virtual ~TMTHDImageNoise();

  TMTHDImageNoise(const TMTHDImageNoise& from);

  inline TMTHDImageNoise& operator=(const TMTHDImageNoise& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDImageNoise& default_instance();

  void Swap(TMTHDImageNoise* other);

  // implements Message ----------------------------------------------

  TMTHDImageNoise* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDImageNoise& from);
  void MergeFrom(const TMTHDImageNoise& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmHDImageNoise emNoiseLevel = 1;
  inline bool has_emnoiselevel() const;
  inline void clear_emnoiselevel();
  static const int kEmNoiseLevelFieldNumber = 1;
  inline ::mt::EmHDImageNoise emnoiselevel() const;
  inline void set_emnoiselevel(::mt::EmHDImageNoise value);

  // @@protoc_insertion_point(class_scope:mt.TMTHDImageNoise)
 private:
  inline void set_has_emnoiselevel();
  inline void clear_has_emnoiselevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emnoiselevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDImageNoise* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDImageDeformationTensile : public ::google::protobuf::Message {
 public:
  TMTHDImageDeformationTensile();
  virtual ~TMTHDImageDeformationTensile();

  TMTHDImageDeformationTensile(const TMTHDImageDeformationTensile& from);

  inline TMTHDImageDeformationTensile& operator=(const TMTHDImageDeformationTensile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDImageDeformationTensile& default_instance();

  void Swap(TMTHDImageDeformationTensile* other);

  // implements Message ----------------------------------------------

  TMTHDImageDeformationTensile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDImageDeformationTensile& from);
  void MergeFrom(const TMTHDImageDeformationTensile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent CodecType = 1;
  inline bool has_codectype() const;
  inline void clear_codectype();
  static const int kCodecTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent codectype() const;
  inline void set_codectype(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex CodecIndex = 2;
  inline bool has_codecindex() const;
  inline void clear_codecindex();
  static const int kCodecIndexFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex codecindex() const;
  inline void set_codecindex(::mt::EmCodecComponentIndex value);

  // optional uint32 left_right_number = 3;
  inline bool has_left_right_number() const;
  inline void clear_left_right_number();
  static const int kLeftRightNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 left_right_number() const;
  inline void set_left_right_number(::google::protobuf::uint32 value);

  // optional uint32 up_down_number = 4;
  inline bool has_up_down_number() const;
  inline void clear_up_down_number();
  static const int kUpDownNumberFieldNumber = 4;
  inline ::google::protobuf::uint32 up_down_number() const;
  inline void set_up_down_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTHDImageDeformationTensile)
 private:
  inline void set_has_codectype();
  inline void clear_has_codectype();
  inline void set_has_codecindex();
  inline void clear_has_codecindex();
  inline void set_has_left_right_number();
  inline void clear_has_left_right_number();
  inline void set_has_up_down_number();
  inline void clear_has_up_down_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int codectype_;
  int codecindex_;
  ::google::protobuf::uint32 left_right_number_;
  ::google::protobuf::uint32 up_down_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDImageDeformationTensile* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDImageGeometricScaling : public ::google::protobuf::Message {
 public:
  TMTHDImageGeometricScaling();
  virtual ~TMTHDImageGeometricScaling();

  TMTHDImageGeometricScaling(const TMTHDImageGeometricScaling& from);

  inline TMTHDImageGeometricScaling& operator=(const TMTHDImageGeometricScaling& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDImageGeometricScaling& default_instance();

  void Swap(TMTHDImageGeometricScaling* other);

  // implements Message ----------------------------------------------

  TMTHDImageGeometricScaling* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDImageGeometricScaling& from);
  void MergeFrom(const TMTHDImageGeometricScaling& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent CodecType = 1;
  inline bool has_codectype() const;
  inline void clear_codectype();
  static const int kCodecTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent codectype() const;
  inline void set_codectype(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex CodecIndex = 2;
  inline bool has_codecindex() const;
  inline void clear_codecindex();
  static const int kCodecIndexFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex codecindex() const;
  inline void set_codecindex(::mt::EmCodecComponentIndex value);

  // optional uint32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTHDImageGeometricScaling)
 private:
  inline void set_has_codectype();
  inline void clear_has_codectype();
  inline void set_has_codecindex();
  inline void clear_has_codecindex();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int codectype_;
  int codecindex_;
  ::google::protobuf::uint32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDImageGeometricScaling* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDCameraCfg : public ::google::protobuf::Message {
 public:
  TMTHDCameraCfg();
  virtual ~TMTHDCameraCfg();

  TMTHDCameraCfg(const TMTHDCameraCfg& from);

  inline TMTHDCameraCfg& operator=(const TMTHDCameraCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDCameraCfg& default_instance();

  void Swap(TMTHDCameraCfg* other);

  // implements Message ----------------------------------------------

  TMTHDCameraCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDCameraCfg& from);
  void MergeFrom(const TMTHDCameraCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtVideoPort video_index = 1;
  inline bool has_video_index() const;
  inline void clear_video_index();
  static const int kVideoIndexFieldNumber = 1;
  inline ::mt::EmMtVideoPort video_index() const;
  inline void set_video_index(::mt::EmMtVideoPort value);

  // optional string camera_type_name = 2;
  inline bool has_camera_type_name() const;
  inline void clear_camera_type_name();
  static const int kCameraTypeNameFieldNumber = 2;
  inline const ::std::string& camera_type_name() const;
  inline void set_camera_type_name(const ::std::string& value);
  inline void set_camera_type_name(const char* value);
  inline void set_camera_type_name(const char* value, size_t size);
  inline ::std::string* mutable_camera_type_name();
  inline ::std::string* release_camera_type_name();
  inline void set_allocated_camera_type_name(::std::string* camera_type_name);

  // optional uint32 address = 3;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 3;
  inline ::google::protobuf::uint32 address() const;
  inline void set_address(::google::protobuf::uint32 value);

  // optional uint32 speed = 4;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline ::google::protobuf::uint32 speed() const;
  inline void set_speed(::google::protobuf::uint32 value);

  // optional .mt.EmSerialType serial_type = 5;
  inline bool has_serial_type() const;
  inline void clear_serial_type();
  static const int kSerialTypeFieldNumber = 5;
  inline ::mt::EmSerialType serial_type() const;
  inline void set_serial_type(::mt::EmSerialType value);

  // optional uint32 ip = 6;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 6;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 7;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 7;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTHDCameraCfg)
 private:
  inline void set_has_video_index();
  inline void clear_has_video_index();
  inline void set_has_camera_type_name();
  inline void clear_has_camera_type_name();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_serial_type();
  inline void clear_has_serial_type();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* camera_type_name_;
  int video_index_;
  ::google::protobuf::uint32 address_;
  ::google::protobuf::uint32 speed_;
  int serial_type_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDCameraCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDCameraList : public ::google::protobuf::Message {
 public:
  TMTHDCameraList();
  virtual ~TMTHDCameraList();

  TMTHDCameraList(const TMTHDCameraList& from);

  inline TMTHDCameraList& operator=(const TMTHDCameraList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDCameraList& default_instance();

  void Swap(TMTHDCameraList* other);

  // implements Message ----------------------------------------------

  TMTHDCameraList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDCameraList& from);
  void MergeFrom(const TMTHDCameraList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTHDCameraCfg cameralist = 1;
  inline int cameralist_size() const;
  inline void clear_cameralist();
  static const int kCameralistFieldNumber = 1;
  inline const ::mt::TMTHDCameraCfg& cameralist(int index) const;
  inline ::mt::TMTHDCameraCfg* mutable_cameralist(int index);
  inline ::mt::TMTHDCameraCfg* add_cameralist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTHDCameraCfg >&
      cameralist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTHDCameraCfg >*
      mutable_cameralist();

  // @@protoc_insertion_point(class_scope:mt.TMTHDCameraList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTHDCameraCfg > cameralist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDCameraList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDCameraAiCfg : public ::google::protobuf::Message {
 public:
  TMTHDCameraAiCfg();
  virtual ~TMTHDCameraAiCfg();

  TMTHDCameraAiCfg(const TMTHDCameraAiCfg& from);

  inline TMTHDCameraAiCfg& operator=(const TMTHDCameraAiCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDCameraAiCfg& default_instance();

  void Swap(TMTHDCameraAiCfg* other);

  // implements Message ----------------------------------------------

  TMTHDCameraAiCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDCameraAiCfg& from);
  void MergeFrom(const TMTHDCameraAiCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtVideoPort video_index = 1;
  inline bool has_video_index() const;
  inline void clear_video_index();
  static const int kVideoIndexFieldNumber = 1;
  inline ::mt::EmMtVideoPort video_index() const;
  inline void set_video_index(::mt::EmMtVideoPort value);

  // optional string camera_type_name = 2;
  inline bool has_camera_type_name() const;
  inline void clear_camera_type_name();
  static const int kCameraTypeNameFieldNumber = 2;
  inline const ::std::string& camera_type_name() const;
  inline void set_camera_type_name(const ::std::string& value);
  inline void set_camera_type_name(const char* value);
  inline void set_camera_type_name(const char* value, size_t size);
  inline ::std::string* mutable_camera_type_name();
  inline ::std::string* release_camera_type_name();
  inline void set_allocated_camera_type_name(::std::string* camera_type_name);

  // optional uint32 ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional bool en_people_cnt = 5;
  inline bool has_en_people_cnt() const;
  inline void clear_en_people_cnt();
  static const int kEnPeopleCntFieldNumber = 5;
  inline bool en_people_cnt() const;
  inline void set_en_people_cnt(bool value);

  // optional bool en_face_checkin = 6;
  inline bool has_en_face_checkin() const;
  inline void clear_en_face_checkin();
  static const int kEnFaceCheckinFieldNumber = 6;
  inline bool en_face_checkin() const;
  inline void set_en_face_checkin(bool value);

  // optional bool en_dog_tag = 7;
  inline bool has_en_dog_tag() const;
  inline void clear_en_dog_tag();
  static const int kEnDogTagFieldNumber = 7;
  inline bool en_dog_tag() const;
  inline void set_en_dog_tag(bool value);

  // optional bool en_CameraAi = 8;
  inline bool has_en_cameraai() const;
  inline void clear_en_cameraai();
  static const int kEnCameraAiFieldNumber = 8;
  inline bool en_cameraai() const;
  inline void set_en_cameraai(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTHDCameraAiCfg)
 private:
  inline void set_has_video_index();
  inline void clear_has_video_index();
  inline void set_has_camera_type_name();
  inline void clear_has_camera_type_name();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_en_people_cnt();
  inline void clear_has_en_people_cnt();
  inline void set_has_en_face_checkin();
  inline void clear_has_en_face_checkin();
  inline void set_has_en_dog_tag();
  inline void clear_has_en_dog_tag();
  inline void set_has_en_cameraai();
  inline void clear_has_en_cameraai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* camera_type_name_;
  int video_index_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  bool en_people_cnt_;
  bool en_face_checkin_;
  bool en_dog_tag_;
  bool en_cameraai_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDCameraAiCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDCameraAiList : public ::google::protobuf::Message {
 public:
  TMTHDCameraAiList();
  virtual ~TMTHDCameraAiList();

  TMTHDCameraAiList(const TMTHDCameraAiList& from);

  inline TMTHDCameraAiList& operator=(const TMTHDCameraAiList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDCameraAiList& default_instance();

  void Swap(TMTHDCameraAiList* other);

  // implements Message ----------------------------------------------

  TMTHDCameraAiList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDCameraAiList& from);
  void MergeFrom(const TMTHDCameraAiList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTHDCameraAiCfg camera_ai_list = 1;
  inline int camera_ai_list_size() const;
  inline void clear_camera_ai_list();
  static const int kCameraAiListFieldNumber = 1;
  inline const ::mt::TMTHDCameraAiCfg& camera_ai_list(int index) const;
  inline ::mt::TMTHDCameraAiCfg* mutable_camera_ai_list(int index);
  inline ::mt::TMTHDCameraAiCfg* add_camera_ai_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTHDCameraAiCfg >&
      camera_ai_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTHDCameraAiCfg >*
      mutable_camera_ai_list();

  // @@protoc_insertion_point(class_scope:mt.TMTHDCameraAiList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTHDCameraAiCfg > camera_ai_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDCameraAiList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTFaceCheckInInfo : public ::google::protobuf::Message {
 public:
  TMTFaceCheckInInfo();
  virtual ~TMTFaceCheckInInfo();

  TMTFaceCheckInInfo(const TMTFaceCheckInInfo& from);

  inline TMTFaceCheckInInfo& operator=(const TMTFaceCheckInInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTFaceCheckInInfo& default_instance();

  void Swap(TMTFaceCheckInInfo* other);

  // implements Message ----------------------------------------------

  TMTFaceCheckInInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTFaceCheckInInfo& from);
  void MergeFrom(const TMTFaceCheckInInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::std::string& position() const;
  inline void set_position(const ::std::string& value);
  inline void set_position(const char* value);
  inline void set_position(const char* value, size_t size);
  inline ::std::string* mutable_position();
  inline ::std::string* release_position();
  inline void set_allocated_position(::std::string* position);

  // @@protoc_insertion_point(class_scope:mt.TMTFaceCheckInInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* time_;
  ::std::string* position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTFaceCheckInInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTFaceCheckInList : public ::google::protobuf::Message {
 public:
  TMTFaceCheckInList();
  virtual ~TMTFaceCheckInList();

  TMTFaceCheckInList(const TMTFaceCheckInList& from);

  inline TMTFaceCheckInList& operator=(const TMTFaceCheckInList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTFaceCheckInList& default_instance();

  void Swap(TMTFaceCheckInList* other);

  // implements Message ----------------------------------------------

  TMTFaceCheckInList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTFaceCheckInList& from);
  void MergeFrom(const TMTFaceCheckInList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTFaceCheckInInfo face_checkin = 1;
  inline int face_checkin_size() const;
  inline void clear_face_checkin();
  static const int kFaceCheckinFieldNumber = 1;
  inline const ::mt::TMTFaceCheckInInfo& face_checkin(int index) const;
  inline ::mt::TMTFaceCheckInInfo* mutable_face_checkin(int index);
  inline ::mt::TMTFaceCheckInInfo* add_face_checkin();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTFaceCheckInInfo >&
      face_checkin() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTFaceCheckInInfo >*
      mutable_face_checkin();

  // @@protoc_insertion_point(class_scope:mt.TMTFaceCheckInList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTFaceCheckInInfo > face_checkin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTFaceCheckInList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDSerialCtrl : public ::google::protobuf::Message {
 public:
  TMTHDSerialCtrl();
  virtual ~TMTHDSerialCtrl();

  TMTHDSerialCtrl(const TMTHDSerialCtrl& from);

  inline TMTHDSerialCtrl& operator=(const TMTHDSerialCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDSerialCtrl& default_instance();

  void Swap(TMTHDSerialCtrl* other);

  // implements Message ----------------------------------------------

  TMTHDSerialCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDSerialCtrl& from);
  void MergeFrom(const TMTHDSerialCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmSerialType serial_type = 1;
  inline bool has_serial_type() const;
  inline void clear_serial_type();
  static const int kSerialTypeFieldNumber = 1;
  inline ::mt::EmSerialType serial_type() const;
  inline void set_serial_type(::mt::EmSerialType value);

  // optional uint32 band_rate = 2;
  inline bool has_band_rate() const;
  inline void clear_band_rate();
  static const int kBandRateFieldNumber = 2;
  inline ::google::protobuf::uint32 band_rate() const;
  inline void set_band_rate(::google::protobuf::uint32 value);

  // optional uint32 byte_size = 3;
  inline bool has_byte_size() const;
  inline void clear_byte_size();
  static const int kByteSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 byte_size() const;
  inline void set_byte_size(::google::protobuf::uint32 value);

  // optional .mt.EmStopBits stop_bits = 4;
  inline bool has_stop_bits() const;
  inline void clear_stop_bits();
  static const int kStopBitsFieldNumber = 4;
  inline ::mt::EmStopBits stop_bits() const;
  inline void set_stop_bits(::mt::EmStopBits value);

  // optional .mt.EmParityCheck parity_check = 5;
  inline bool has_parity_check() const;
  inline void clear_parity_check();
  static const int kParityCheckFieldNumber = 5;
  inline ::mt::EmParityCheck parity_check() const;
  inline void set_parity_check(::mt::EmParityCheck value);

  // @@protoc_insertion_point(class_scope:mt.TMTHDSerialCtrl)
 private:
  inline void set_has_serial_type();
  inline void clear_has_serial_type();
  inline void set_has_band_rate();
  inline void clear_has_band_rate();
  inline void set_has_byte_size();
  inline void clear_has_byte_size();
  inline void set_has_stop_bits();
  inline void clear_has_stop_bits();
  inline void set_has_parity_check();
  inline void clear_has_parity_check();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int serial_type_;
  ::google::protobuf::uint32 band_rate_;
  ::google::protobuf::uint32 byte_size_;
  int stop_bits_;
  int parity_check_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDSerialCtrl* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDSerialList : public ::google::protobuf::Message {
 public:
  TMTHDSerialList();
  virtual ~TMTHDSerialList();

  TMTHDSerialList(const TMTHDSerialList& from);

  inline TMTHDSerialList& operator=(const TMTHDSerialList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDSerialList& default_instance();

  void Swap(TMTHDSerialList* other);

  // implements Message ----------------------------------------------

  TMTHDSerialList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDSerialList& from);
  void MergeFrom(const TMTHDSerialList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTHDSerialCtrl seriallist = 1;
  inline int seriallist_size() const;
  inline void clear_seriallist();
  static const int kSeriallistFieldNumber = 1;
  inline const ::mt::TMTHDSerialCtrl& seriallist(int index) const;
  inline ::mt::TMTHDSerialCtrl* mutable_seriallist(int index);
  inline ::mt::TMTHDSerialCtrl* add_seriallist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTHDSerialCtrl >&
      seriallist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTHDSerialCtrl >*
      mutable_seriallist();

  // @@protoc_insertion_point(class_scope:mt.TMTHDSerialList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTHDSerialCtrl > seriallist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDSerialList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDSerialMonitor : public ::google::protobuf::Message {
 public:
  TMTHDSerialMonitor();
  virtual ~TMTHDSerialMonitor();

  TMTHDSerialMonitor(const TMTHDSerialMonitor& from);

  inline TMTHDSerialMonitor& operator=(const TMTHDSerialMonitor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDSerialMonitor& default_instance();

  void Swap(TMTHDSerialMonitor* other);

  // implements Message ----------------------------------------------

  TMTHDSerialMonitor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDSerialMonitor& from);
  void MergeFrom(const TMTHDSerialMonitor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmSerialType serial_type = 1;
  inline bool has_serial_type() const;
  inline void clear_serial_type();
  static const int kSerialTypeFieldNumber = 1;
  inline ::mt::EmSerialType serial_type() const;
  inline void set_serial_type(::mt::EmSerialType value);

  // optional bool enable_monitor = 2;
  inline bool has_enable_monitor() const;
  inline void clear_enable_monitor();
  static const int kEnableMonitorFieldNumber = 2;
  inline bool enable_monitor() const;
  inline void set_enable_monitor(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTHDSerialMonitor)
 private:
  inline void set_has_serial_type();
  inline void clear_has_serial_type();
  inline void set_has_enable_monitor();
  inline void clear_has_enable_monitor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int serial_type_;
  bool enable_monitor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDSerialMonitor* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTHDSerialMonitorList : public ::google::protobuf::Message {
 public:
  TMTHDSerialMonitorList();
  virtual ~TMTHDSerialMonitorList();

  TMTHDSerialMonitorList(const TMTHDSerialMonitorList& from);

  inline TMTHDSerialMonitorList& operator=(const TMTHDSerialMonitorList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTHDSerialMonitorList& default_instance();

  void Swap(TMTHDSerialMonitorList* other);

  // implements Message ----------------------------------------------

  TMTHDSerialMonitorList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTHDSerialMonitorList& from);
  void MergeFrom(const TMTHDSerialMonitorList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTHDSerialMonitor monitorlist = 1;
  inline int monitorlist_size() const;
  inline void clear_monitorlist();
  static const int kMonitorlistFieldNumber = 1;
  inline const ::mt::TMTHDSerialMonitor& monitorlist(int index) const;
  inline ::mt::TMTHDSerialMonitor* mutable_monitorlist(int index);
  inline ::mt::TMTHDSerialMonitor* add_monitorlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTHDSerialMonitor >&
      monitorlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTHDSerialMonitor >*
      mutable_monitorlist();

  // @@protoc_insertion_point(class_scope:mt.TMTHDSerialMonitorList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTHDSerialMonitor > monitorlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTHDSerialMonitorList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAllPreSetNameInfoCfg : public ::google::protobuf::Message {
 public:
  TMTAllPreSetNameInfoCfg();
  virtual ~TMTAllPreSetNameInfoCfg();

  TMTAllPreSetNameInfoCfg(const TMTAllPreSetNameInfoCfg& from);

  inline TMTAllPreSetNameInfoCfg& operator=(const TMTAllPreSetNameInfoCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAllPreSetNameInfoCfg& default_instance();

  void Swap(TMTAllPreSetNameInfoCfg* other);

  // implements Message ----------------------------------------------

  TMTAllPreSetNameInfoCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAllPreSetNameInfoCfg& from);
  void MergeFrom(const TMTAllPreSetNameInfoCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTPreSetNameInfo pri1st_preset_name_info = 1;
  inline int pri1st_preset_name_info_size() const;
  inline void clear_pri1st_preset_name_info();
  static const int kPri1StPresetNameInfoFieldNumber = 1;
  inline const ::mt::TMTPreSetNameInfo& pri1st_preset_name_info(int index) const;
  inline ::mt::TMTPreSetNameInfo* mutable_pri1st_preset_name_info(int index);
  inline ::mt::TMTPreSetNameInfo* add_pri1st_preset_name_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >&
      pri1st_preset_name_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >*
      mutable_pri1st_preset_name_info();

  // repeated .mt.TMTPreSetNameInfo pri2nd_preset_name_info = 2;
  inline int pri2nd_preset_name_info_size() const;
  inline void clear_pri2nd_preset_name_info();
  static const int kPri2NdPresetNameInfoFieldNumber = 2;
  inline const ::mt::TMTPreSetNameInfo& pri2nd_preset_name_info(int index) const;
  inline ::mt::TMTPreSetNameInfo* mutable_pri2nd_preset_name_info(int index);
  inline ::mt::TMTPreSetNameInfo* add_pri2nd_preset_name_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >&
      pri2nd_preset_name_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >*
      mutable_pri2nd_preset_name_info();

  // repeated .mt.TMTPreSetNameInfo pri3rd_preset_name_info = 3;
  inline int pri3rd_preset_name_info_size() const;
  inline void clear_pri3rd_preset_name_info();
  static const int kPri3RdPresetNameInfoFieldNumber = 3;
  inline const ::mt::TMTPreSetNameInfo& pri3rd_preset_name_info(int index) const;
  inline ::mt::TMTPreSetNameInfo* mutable_pri3rd_preset_name_info(int index);
  inline ::mt::TMTPreSetNameInfo* add_pri3rd_preset_name_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >&
      pri3rd_preset_name_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >*
      mutable_pri3rd_preset_name_info();

  // @@protoc_insertion_point(class_scope:mt.TMTAllPreSetNameInfoCfg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo > pri1st_preset_name_info_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo > pri2nd_preset_name_info_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo > pri3rd_preset_name_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTAllPreSetNameInfoCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTPreSetNameInfo : public ::google::protobuf::Message {
 public:
  TMTPreSetNameInfo();
  virtual ~TMTPreSetNameInfo();

  TMTPreSetNameInfo(const TMTPreSetNameInfo& from);

  inline TMTPreSetNameInfo& operator=(const TMTPreSetNameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTPreSetNameInfo& default_instance();

  void Swap(TMTPreSetNameInfo* other);

  // implements Message ----------------------------------------------

  TMTPreSetNameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTPreSetNameInfo& from);
  void MergeFrom(const TMTPreSetNameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 pre_set_index = 1;
  inline bool has_pre_set_index() const;
  inline void clear_pre_set_index();
  static const int kPreSetIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 pre_set_index() const;
  inline void set_pre_set_index(::google::protobuf::uint32 value);

  // optional string pre_set_name = 2;
  inline bool has_pre_set_name() const;
  inline void clear_pre_set_name();
  static const int kPreSetNameFieldNumber = 2;
  inline const ::std::string& pre_set_name() const;
  inline void set_pre_set_name(const ::std::string& value);
  inline void set_pre_set_name(const char* value);
  inline void set_pre_set_name(const char* value, size_t size);
  inline ::std::string* mutable_pre_set_name();
  inline ::std::string* release_pre_set_name();
  inline void set_allocated_pre_set_name(::std::string* pre_set_name);

  // @@protoc_insertion_point(class_scope:mt.TMTPreSetNameInfo)
 private:
  inline void set_has_pre_set_index();
  inline void clear_has_pre_set_index();
  inline void set_has_pre_set_name();
  inline void clear_has_pre_set_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pre_set_name_;
  ::google::protobuf::uint32 pre_set_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTPreSetNameInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTCodecPreSetIndex : public ::google::protobuf::Message {
 public:
  TMTCodecPreSetIndex();
  virtual ~TMTCodecPreSetIndex();

  TMTCodecPreSetIndex(const TMTCodecPreSetIndex& from);

  inline TMTCodecPreSetIndex& operator=(const TMTCodecPreSetIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTCodecPreSetIndex& default_instance();

  void Swap(TMTCodecPreSetIndex* other);

  // implements Message ----------------------------------------------

  TMTCodecPreSetIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTCodecPreSetIndex& from);
  void MergeFrom(const TMTCodecPreSetIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponentIndex codec_index = 1;
  inline bool has_codec_index() const;
  inline void clear_codec_index();
  static const int kCodecIndexFieldNumber = 1;
  inline ::mt::EmCodecComponentIndex codec_index() const;
  inline void set_codec_index(::mt::EmCodecComponentIndex value);

  // optional uint32 pre_set_index = 2;
  inline bool has_pre_set_index() const;
  inline void clear_pre_set_index();
  static const int kPreSetIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 pre_set_index() const;
  inline void set_pre_set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTCodecPreSetIndex)
 private:
  inline void set_has_codec_index();
  inline void clear_has_codec_index();
  inline void set_has_pre_set_index();
  inline void clear_has_pre_set_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int codec_index_;
  ::google::protobuf::uint32 pre_set_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTCodecPreSetIndex* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAllCodecPreSetIndex : public ::google::protobuf::Message {
 public:
  TMTAllCodecPreSetIndex();
  virtual ~TMTAllCodecPreSetIndex();

  TMTAllCodecPreSetIndex(const TMTAllCodecPreSetIndex& from);

  inline TMTAllCodecPreSetIndex& operator=(const TMTAllCodecPreSetIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAllCodecPreSetIndex& default_instance();

  void Swap(TMTAllCodecPreSetIndex* other);

  // implements Message ----------------------------------------------

  TMTAllCodecPreSetIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAllCodecPreSetIndex& from);
  void MergeFrom(const TMTAllCodecPreSetIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMTCodecPreSetIndex codec_pre_set_index = 1;
  inline int codec_pre_set_index_size() const;
  inline void clear_codec_pre_set_index();
  static const int kCodecPreSetIndexFieldNumber = 1;
  inline const ::mt::TMTCodecPreSetIndex& codec_pre_set_index(int index) const;
  inline ::mt::TMTCodecPreSetIndex* mutable_codec_pre_set_index(int index);
  inline ::mt::TMTCodecPreSetIndex* add_codec_pre_set_index();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTCodecPreSetIndex >&
      codec_pre_set_index() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMTCodecPreSetIndex >*
      mutable_codec_pre_set_index();

  // @@protoc_insertion_point(class_scope:mt.TMTAllCodecPreSetIndex)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMTCodecPreSetIndex > codec_pre_set_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTAllCodecPreSetIndex* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TStaticPicCfg : public ::google::protobuf::Message {
 public:
  TStaticPicCfg();
  virtual ~TStaticPicCfg();

  TStaticPicCfg(const TStaticPicCfg& from);

  inline TStaticPicCfg& operator=(const TStaticPicCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStaticPicCfg& default_instance();

  void Swap(TStaticPicCfg* other);

  // implements Message ----------------------------------------------

  TStaticPicCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStaticPicCfg& from);
  void MergeFrom(const TStaticPicCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_send = 1;
  inline bool has_enable_send() const;
  inline void clear_enable_send();
  static const int kEnableSendFieldNumber = 1;
  inline bool enable_send() const;
  inline void set_enable_send(bool value);

  // optional string pic_path = 2;
  inline bool has_pic_path() const;
  inline void clear_pic_path();
  static const int kPicPathFieldNumber = 2;
  inline const ::std::string& pic_path() const;
  inline void set_pic_path(const ::std::string& value);
  inline void set_pic_path(const char* value);
  inline void set_pic_path(const char* value, size_t size);
  inline ::std::string* mutable_pic_path();
  inline ::std::string* release_pic_path();
  inline void set_allocated_pic_path(::std::string* pic_path);

  // @@protoc_insertion_point(class_scope:mt.TStaticPicCfg)
 private:
  inline void set_has_enable_send();
  inline void clear_has_enable_send();
  inline void set_has_pic_path();
  inline void clear_has_pic_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pic_path_;
  bool enable_send_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TStaticPicCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TEthnetCardInfo : public ::google::protobuf::Message {
 public:
  TEthnetCardInfo();
  virtual ~TEthnetCardInfo();

  TEthnetCardInfo(const TEthnetCardInfo& from);

  inline TEthnetCardInfo& operator=(const TEthnetCardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TEthnetCardInfo& default_instance();

  void Swap(TEthnetCardInfo* other);

  // implements Message ----------------------------------------------

  TEthnetCardInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TEthnetCardInfo& from);
  void MergeFrom(const TEthnetCardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_ip_dhcp = 1;
  inline bool has_enable_ip_dhcp() const;
  inline void clear_enable_ip_dhcp();
  static const int kEnableIpDhcpFieldNumber = 1;
  inline bool enable_ip_dhcp() const;
  inline void set_enable_ip_dhcp(bool value);

  // optional uint32 static_ip = 2;
  inline bool has_static_ip() const;
  inline void clear_static_ip();
  static const int kStaticIpFieldNumber = 2;
  inline ::google::protobuf::uint32 static_ip() const;
  inline void set_static_ip(::google::protobuf::uint32 value);

  // optional uint32 static_mask = 3;
  inline bool has_static_mask() const;
  inline void clear_static_mask();
  static const int kStaticMaskFieldNumber = 3;
  inline ::google::protobuf::uint32 static_mask() const;
  inline void set_static_mask(::google::protobuf::uint32 value);

  // optional uint32 static_gateway_ip = 4;
  inline bool has_static_gateway_ip() const;
  inline void clear_static_gateway_ip();
  static const int kStaticGatewayIpFieldNumber = 4;
  inline ::google::protobuf::uint32 static_gateway_ip() const;
  inline void set_static_gateway_ip(::google::protobuf::uint32 value);

  // optional uint32 dhcp_ip = 5;
  inline bool has_dhcp_ip() const;
  inline void clear_dhcp_ip();
  static const int kDhcpIpFieldNumber = 5;
  inline ::google::protobuf::uint32 dhcp_ip() const;
  inline void set_dhcp_ip(::google::protobuf::uint32 value);

  // optional uint32 dhcp_mask = 6;
  inline bool has_dhcp_mask() const;
  inline void clear_dhcp_mask();
  static const int kDhcpMaskFieldNumber = 6;
  inline ::google::protobuf::uint32 dhcp_mask() const;
  inline void set_dhcp_mask(::google::protobuf::uint32 value);

  // optional uint32 dhcp_gateway = 7;
  inline bool has_dhcp_gateway() const;
  inline void clear_dhcp_gateway();
  static const int kDhcpGatewayFieldNumber = 7;
  inline ::google::protobuf::uint32 dhcp_gateway() const;
  inline void set_dhcp_gateway(::google::protobuf::uint32 value);

  // optional bool enable_dns_dhcp = 8;
  inline bool has_enable_dns_dhcp() const;
  inline void clear_enable_dns_dhcp();
  static const int kEnableDnsDhcpFieldNumber = 8;
  inline bool enable_dns_dhcp() const;
  inline void set_enable_dns_dhcp(bool value);

  // optional uint32 static_dns = 9;
  inline bool has_static_dns() const;
  inline void clear_static_dns();
  static const int kStaticDnsFieldNumber = 9;
  inline ::google::protobuf::uint32 static_dns() const;
  inline void set_static_dns(::google::protobuf::uint32 value);

  // optional uint32 static_dns_backup = 10;
  inline bool has_static_dns_backup() const;
  inline void clear_static_dns_backup();
  static const int kStaticDnsBackupFieldNumber = 10;
  inline ::google::protobuf::uint32 static_dns_backup() const;
  inline void set_static_dns_backup(::google::protobuf::uint32 value);

  // optional uint32 dhcp_dns = 11;
  inline bool has_dhcp_dns() const;
  inline void clear_dhcp_dns();
  static const int kDhcpDnsFieldNumber = 11;
  inline ::google::protobuf::uint32 dhcp_dns() const;
  inline void set_dhcp_dns(::google::protobuf::uint32 value);

  // optional uint32 dhcp_dns_backup = 12;
  inline bool has_dhcp_dns_backup() const;
  inline void clear_dhcp_dns_backup();
  static const int kDhcpDnsBackupFieldNumber = 12;
  inline ::google::protobuf::uint32 dhcp_dns_backup() const;
  inline void set_dhcp_dns_backup(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TEthnetCardInfo)
 private:
  inline void set_has_enable_ip_dhcp();
  inline void clear_has_enable_ip_dhcp();
  inline void set_has_static_ip();
  inline void clear_has_static_ip();
  inline void set_has_static_mask();
  inline void clear_has_static_mask();
  inline void set_has_static_gateway_ip();
  inline void clear_has_static_gateway_ip();
  inline void set_has_dhcp_ip();
  inline void clear_has_dhcp_ip();
  inline void set_has_dhcp_mask();
  inline void clear_has_dhcp_mask();
  inline void set_has_dhcp_gateway();
  inline void clear_has_dhcp_gateway();
  inline void set_has_enable_dns_dhcp();
  inline void clear_has_enable_dns_dhcp();
  inline void set_has_static_dns();
  inline void clear_has_static_dns();
  inline void set_has_static_dns_backup();
  inline void clear_has_static_dns_backup();
  inline void set_has_dhcp_dns();
  inline void clear_has_dhcp_dns();
  inline void set_has_dhcp_dns_backup();
  inline void clear_has_dhcp_dns_backup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 static_ip_;
  ::google::protobuf::uint32 static_mask_;
  ::google::protobuf::uint32 static_gateway_ip_;
  bool enable_ip_dhcp_;
  bool enable_dns_dhcp_;
  ::google::protobuf::uint32 dhcp_ip_;
  ::google::protobuf::uint32 dhcp_mask_;
  ::google::protobuf::uint32 dhcp_gateway_;
  ::google::protobuf::uint32 static_dns_;
  ::google::protobuf::uint32 static_dns_backup_;
  ::google::protobuf::uint32 dhcp_dns_;
  ::google::protobuf::uint32 dhcp_dns_backup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TEthnetCardInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TEthnetCfg : public ::google::protobuf::Message {
 public:
  TEthnetCfg();
  virtual ~TEthnetCfg();

  TEthnetCfg(const TEthnetCfg& from);

  inline TEthnetCfg& operator=(const TEthnetCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TEthnetCfg& default_instance();

  void Swap(TEthnetCfg* other);

  // implements Message ----------------------------------------------

  TEthnetCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TEthnetCfg& from);
  void MergeFrom(const TEthnetCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmEthInterfaceMode ethnet_backupmode = 1;
  inline bool has_ethnet_backupmode() const;
  inline void clear_ethnet_backupmode();
  static const int kEthnetBackupmodeFieldNumber = 1;
  inline ::mt::EmEthInterfaceMode ethnet_backupmode() const;
  inline void set_ethnet_backupmode(::mt::EmEthInterfaceMode value);

  // optional uint32 cur_cardid = 2;
  inline bool has_cur_cardid() const;
  inline void clear_cur_cardid();
  static const int kCurCardidFieldNumber = 2;
  inline ::google::protobuf::uint32 cur_cardid() const;
  inline void set_cur_cardid(::google::protobuf::uint32 value);

  // optional .mt.TEthnetCardInfo eth1 = 3;
  inline bool has_eth1() const;
  inline void clear_eth1();
  static const int kEth1FieldNumber = 3;
  inline const ::mt::TEthnetCardInfo& eth1() const;
  inline ::mt::TEthnetCardInfo* mutable_eth1();
  inline ::mt::TEthnetCardInfo* release_eth1();
  inline void set_allocated_eth1(::mt::TEthnetCardInfo* eth1);

  // optional .mt.TEthnetCardInfo eth2 = 4;
  inline bool has_eth2() const;
  inline void clear_eth2();
  static const int kEth2FieldNumber = 4;
  inline const ::mt::TEthnetCardInfo& eth2() const;
  inline ::mt::TEthnetCardInfo* mutable_eth2();
  inline ::mt::TEthnetCardInfo* release_eth2();
  inline void set_allocated_eth2(::mt::TEthnetCardInfo* eth2);

  // @@protoc_insertion_point(class_scope:mt.TEthnetCfg)
 private:
  inline void set_has_ethnet_backupmode();
  inline void clear_has_ethnet_backupmode();
  inline void set_has_cur_cardid();
  inline void clear_has_cur_cardid();
  inline void set_has_eth1();
  inline void clear_has_eth1();
  inline void set_has_eth2();
  inline void clear_has_eth2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ethnet_backupmode_;
  ::google::protobuf::uint32 cur_cardid_;
  ::mt::TEthnetCardInfo* eth1_;
  ::mt::TEthnetCardInfo* eth2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TEthnetCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TEthnetPPPoECfg : public ::google::protobuf::Message {
 public:
  TEthnetPPPoECfg();
  virtual ~TEthnetPPPoECfg();

  TEthnetPPPoECfg(const TEthnetPPPoECfg& from);

  inline TEthnetPPPoECfg& operator=(const TEthnetPPPoECfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TEthnetPPPoECfg& default_instance();

  void Swap(TEthnetPPPoECfg* other);

  // implements Message ----------------------------------------------

  TEthnetPPPoECfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TEthnetPPPoECfg& from);
  void MergeFrom(const TEthnetPPPoECfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional bool autodial = 4;
  inline bool has_autodial() const;
  inline void clear_autodial();
  static const int kAutodialFieldNumber = 4;
  inline bool autodial() const;
  inline void set_autodial(bool value);

  // @@protoc_insertion_point(class_scope:mt.TEthnetPPPoECfg)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_autodial();
  inline void clear_has_autodial();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;
  bool enable_;
  bool autodial_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TEthnetPPPoECfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TE1Unit : public ::google::protobuf::Message {
 public:
  TE1Unit();
  virtual ~TE1Unit();

  TE1Unit(const TE1Unit& from);

  inline TE1Unit& operator=(const TE1Unit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TE1Unit& default_instance();

  void Swap(TE1Unit* other);

  // implements Message ----------------------------------------------

  TE1Unit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TE1Unit& from);
  void MergeFrom(const TE1Unit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 e1_id = 1;
  inline bool has_e1_id() const;
  inline void clear_e1_id();
  static const int kE1IdFieldNumber = 1;
  inline ::google::protobuf::uint32 e1_id() const;
  inline void set_e1_id(::google::protobuf::uint32 value);

  // optional uint32 used_flag = 2;
  inline bool has_used_flag() const;
  inline void clear_used_flag();
  static const int kUsedFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 used_flag() const;
  inline void set_used_flag(::google::protobuf::uint32 value);

  // optional uint32 e1_ts_mask = 3;
  inline bool has_e1_ts_mask() const;
  inline void clear_e1_ts_mask();
  static const int kE1TsMaskFieldNumber = 3;
  inline ::google::protobuf::uint32 e1_ts_mask() const;
  inline void set_e1_ts_mask(::google::protobuf::uint32 value);

  // optional uint32 protocol_type = 4;
  inline bool has_protocol_type() const;
  inline void clear_protocol_type();
  static const int kProtocolTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 protocol_type() const;
  inline void set_protocol_type(::google::protobuf::uint32 value);

  // optional uint32 echo_interval = 5;
  inline bool has_echo_interval() const;
  inline void clear_echo_interval();
  static const int kEchoIntervalFieldNumber = 5;
  inline ::google::protobuf::uint32 echo_interval() const;
  inline void set_echo_interval(::google::protobuf::uint32 value);

  // optional uint32 echo_maxretry = 6;
  inline bool has_echo_maxretry() const;
  inline void clear_echo_maxretry();
  static const int kEchoMaxretryFieldNumber = 6;
  inline ::google::protobuf::uint32 echo_maxretry() const;
  inline void set_echo_maxretry(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TE1Unit)
 private:
  inline void set_has_e1_id();
  inline void clear_has_e1_id();
  inline void set_has_used_flag();
  inline void clear_has_used_flag();
  inline void set_has_e1_ts_mask();
  inline void clear_has_e1_ts_mask();
  inline void set_has_protocol_type();
  inline void clear_has_protocol_type();
  inline void set_has_echo_interval();
  inline void clear_has_echo_interval();
  inline void set_has_echo_maxretry();
  inline void clear_has_echo_maxretry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 e1_id_;
  ::google::protobuf::uint32 used_flag_;
  ::google::protobuf::uint32 e1_ts_mask_;
  ::google::protobuf::uint32 protocol_type_;
  ::google::protobuf::uint32 echo_interval_;
  ::google::protobuf::uint32 echo_maxretry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TE1Unit* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TE1Group : public ::google::protobuf::Message {
 public:
  TE1Group();
  virtual ~TE1Group();

  TE1Group(const TE1Group& from);

  inline TE1Group& operator=(const TE1Group& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TE1Group& default_instance();

  void Swap(TE1Group* other);

  // implements Message ----------------------------------------------

  TE1Group* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TE1Group& from);
  void MergeFrom(const TE1Group& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional uint32 unit_num = 2;
  inline bool has_unit_num() const;
  inline void clear_unit_num();
  static const int kUnitNumFieldNumber = 2;
  inline ::google::protobuf::uint32 unit_num() const;
  inline void set_unit_num(::google::protobuf::uint32 value);

  // optional uint32 is_bind = 3;
  inline bool has_is_bind() const;
  inline void clear_is_bind();
  static const int kIsBindFieldNumber = 3;
  inline ::google::protobuf::uint32 is_bind() const;
  inline void set_is_bind(::google::protobuf::uint32 value);

  // optional uint32 group_id = 4;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 4;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // optional uint32 ip = 5;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 5;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 mask = 6;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 6;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);

  // optional uint32 auth_type = 7;
  inline bool has_auth_type() const;
  inline void clear_auth_type();
  static const int kAuthTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 auth_type() const;
  inline void set_auth_type(::google::protobuf::uint32 value);

  // optional uint32 frag_minpackage_len = 8;
  inline bool has_frag_minpackage_len() const;
  inline void clear_frag_minpackage_len();
  static const int kFragMinpackageLenFieldNumber = 8;
  inline ::google::protobuf::uint32 frag_minpackage_len() const;
  inline void set_frag_minpackage_len(::google::protobuf::uint32 value);

  // optional string svr_usrname = 9;
  inline bool has_svr_usrname() const;
  inline void clear_svr_usrname();
  static const int kSvrUsrnameFieldNumber = 9;
  inline const ::std::string& svr_usrname() const;
  inline void set_svr_usrname(const ::std::string& value);
  inline void set_svr_usrname(const char* value);
  inline void set_svr_usrname(const char* value, size_t size);
  inline ::std::string* mutable_svr_usrname();
  inline ::std::string* release_svr_usrname();
  inline void set_allocated_svr_usrname(::std::string* svr_usrname);

  // optional string svr_usrpwd = 10;
  inline bool has_svr_usrpwd() const;
  inline void clear_svr_usrpwd();
  static const int kSvrUsrpwdFieldNumber = 10;
  inline const ::std::string& svr_usrpwd() const;
  inline void set_svr_usrpwd(const ::std::string& value);
  inline void set_svr_usrpwd(const char* value);
  inline void set_svr_usrpwd(const char* value, size_t size);
  inline ::std::string* mutable_svr_usrpwd();
  inline ::std::string* release_svr_usrpwd();
  inline void set_allocated_svr_usrpwd(::std::string* svr_usrpwd);

  // optional string sent_usrname = 11;
  inline bool has_sent_usrname() const;
  inline void clear_sent_usrname();
  static const int kSentUsrnameFieldNumber = 11;
  inline const ::std::string& sent_usrname() const;
  inline void set_sent_usrname(const ::std::string& value);
  inline void set_sent_usrname(const char* value);
  inline void set_sent_usrname(const char* value, size_t size);
  inline ::std::string* mutable_sent_usrname();
  inline ::std::string* release_sent_usrname();
  inline void set_allocated_sent_usrname(::std::string* sent_usrname);

  // optional string sent_usrpwd = 12;
  inline bool has_sent_usrpwd() const;
  inline void clear_sent_usrpwd();
  static const int kSentUsrpwdFieldNumber = 12;
  inline const ::std::string& sent_usrpwd() const;
  inline void set_sent_usrpwd(const ::std::string& value);
  inline void set_sent_usrpwd(const char* value);
  inline void set_sent_usrpwd(const char* value, size_t size);
  inline ::std::string* mutable_sent_usrpwd();
  inline ::std::string* release_sent_usrpwd();
  inline void set_allocated_sent_usrpwd(::std::string* sent_usrpwd);

  // repeated .mt.TE1Unit unit_list = 13;
  inline int unit_list_size() const;
  inline void clear_unit_list();
  static const int kUnitListFieldNumber = 13;
  inline const ::mt::TE1Unit& unit_list(int index) const;
  inline ::mt::TE1Unit* mutable_unit_list(int index);
  inline ::mt::TE1Unit* add_unit_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TE1Unit >&
      unit_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TE1Unit >*
      mutable_unit_list();

  // @@protoc_insertion_point(class_scope:mt.TE1Group)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_unit_num();
  inline void clear_has_unit_num();
  inline void set_has_is_bind();
  inline void clear_has_is_bind();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_auth_type();
  inline void clear_has_auth_type();
  inline void set_has_frag_minpackage_len();
  inline void clear_has_frag_minpackage_len();
  inline void set_has_svr_usrname();
  inline void clear_has_svr_usrname();
  inline void set_has_svr_usrpwd();
  inline void clear_has_svr_usrpwd();
  inline void set_has_sent_usrname();
  inline void clear_has_sent_usrname();
  inline void set_has_sent_usrpwd();
  inline void clear_has_sent_usrpwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  ::google::protobuf::uint32 unit_num_;
  ::google::protobuf::uint32 is_bind_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 mask_;
  ::google::protobuf::uint32 auth_type_;
  ::google::protobuf::uint32 frag_minpackage_len_;
  ::std::string* svr_usrname_;
  ::std::string* svr_usrpwd_;
  ::std::string* sent_usrname_;
  ::std::string* sent_usrpwd_;
  ::google::protobuf::RepeatedPtrField< ::mt::TE1Unit > unit_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TE1Group* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TE1Cfg : public ::google::protobuf::Message {
 public:
  TE1Cfg();
  virtual ~TE1Cfg();

  TE1Cfg(const TE1Cfg& from);

  inline TE1Cfg& operator=(const TE1Cfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TE1Cfg& default_instance();

  void Swap(TE1Cfg* other);

  // implements Message ----------------------------------------------

  TE1Cfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TE1Cfg& from);
  void MergeFrom(const TE1Cfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool encrypt = 1;
  inline bool has_encrypt() const;
  inline void clear_encrypt();
  static const int kEncryptFieldNumber = 1;
  inline bool encrypt() const;
  inline void set_encrypt(bool value);

  // optional uint32 clock_type = 2;
  inline bool has_clock_type() const;
  inline void clear_clock_type();
  static const int kClockTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 clock_type() const;
  inline void set_clock_type(::google::protobuf::uint32 value);

  // repeated .mt.TE1Group group_detail = 3;
  inline int group_detail_size() const;
  inline void clear_group_detail();
  static const int kGroupDetailFieldNumber = 3;
  inline const ::mt::TE1Group& group_detail(int index) const;
  inline ::mt::TE1Group* mutable_group_detail(int index);
  inline ::mt::TE1Group* add_group_detail();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TE1Group >&
      group_detail() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TE1Group >*
      mutable_group_detail();

  // @@protoc_insertion_point(class_scope:mt.TE1Cfg)
 private:
  inline void set_has_encrypt();
  inline void clear_has_encrypt();
  inline void set_has_clock_type();
  inline void clear_has_clock_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool encrypt_;
  ::google::protobuf::uint32 clock_type_;
  ::google::protobuf::RepeatedPtrField< ::mt::TE1Group > group_detail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TE1Cfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidBitRationCfg : public ::google::protobuf::Message {
 public:
  TVidBitRationCfg();
  virtual ~TVidBitRationCfg();

  TVidBitRationCfg(const TVidBitRationCfg& from);

  inline TVidBitRationCfg& operator=(const TVidBitRationCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidBitRationCfg& default_instance();

  void Swap(TVidBitRationCfg* other);

  // implements Message ----------------------------------------------

  TVidBitRationCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidBitRationCfg& from);
  void MergeFrom(const TVidBitRationCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVidRationStrategy ration_strategy = 1;
  inline bool has_ration_strategy() const;
  inline void clear_ration_strategy();
  static const int kRationStrategyFieldNumber = 1;
  inline ::mt::EmVidRationStrategy ration_strategy() const;
  inline void set_ration_strategy(::mt::EmVidRationStrategy value);

  // repeated uint32 main_ration = 2;
  inline int main_ration_size() const;
  inline void clear_main_ration();
  static const int kMainRationFieldNumber = 2;
  inline ::google::protobuf::uint32 main_ration(int index) const;
  inline void set_main_ration(int index, ::google::protobuf::uint32 value);
  inline void add_main_ration(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      main_ration() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_main_ration();

  // repeated uint32 ass_ration = 3;
  inline int ass_ration_size() const;
  inline void clear_ass_ration();
  static const int kAssRationFieldNumber = 3;
  inline ::google::protobuf::uint32 ass_ration(int index) const;
  inline void set_ass_ration(int index, ::google::protobuf::uint32 value);
  inline void add_ass_ration(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ass_ration() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ass_ration();

  // @@protoc_insertion_point(class_scope:mt.TVidBitRationCfg)
 private:
  inline void set_has_ration_strategy();
  inline void clear_has_ration_strategy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > main_ration_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ass_ration_;
  int ration_strategy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TVidBitRationCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVideoPortParam : public ::google::protobuf::Message {
 public:
  TMtVideoPortParam();
  virtual ~TMtVideoPortParam();

  TMtVideoPortParam(const TMtVideoPortParam& from);

  inline TMtVideoPortParam& operator=(const TMtVideoPortParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVideoPortParam& default_instance();

  void Swap(TMtVideoPortParam* other);

  // implements Message ----------------------------------------------

  TMtVideoPortParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVideoPortParam& from);
  void MergeFrom(const TMtVideoPortParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtVideoPort video_port = 1;
  inline bool has_video_port() const;
  inline void clear_video_port();
  static const int kVideoPortFieldNumber = 1;
  inline ::mt::EmMtVideoPort video_port() const;
  inline void set_video_port(::mt::EmMtVideoPort value);

  // optional uint32 video_param = 2;
  inline bool has_video_param() const;
  inline void clear_video_param();
  static const int kVideoParamFieldNumber = 2;
  inline ::google::protobuf::uint32 video_param() const;
  inline void set_video_param(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtVideoPortParam)
 private:
  inline void set_has_video_port();
  inline void clear_has_video_port();
  inline void set_has_video_param();
  inline void clear_has_video_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_port_;
  ::google::protobuf::uint32 video_param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtVideoPortParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVideoPortParamList : public ::google::protobuf::Message {
 public:
  TMtVideoPortParamList();
  virtual ~TMtVideoPortParamList();

  TMtVideoPortParamList(const TMtVideoPortParamList& from);

  inline TMtVideoPortParamList& operator=(const TMtVideoPortParamList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVideoPortParamList& default_instance();

  void Swap(TMtVideoPortParamList* other);

  // implements Message ----------------------------------------------

  TMtVideoPortParamList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVideoPortParamList& from);
  void MergeFrom(const TMtVideoPortParamList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtVideoPortParam param_list = 1;
  inline int param_list_size() const;
  inline void clear_param_list();
  static const int kParamListFieldNumber = 1;
  inline const ::mt::TMtVideoPortParam& param_list(int index) const;
  inline ::mt::TMtVideoPortParam* mutable_param_list(int index);
  inline ::mt::TMtVideoPortParam* add_param_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtVideoPortParam >&
      param_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtVideoPortParam >*
      mutable_param_list();

  // @@protoc_insertion_point(class_scope:mt.TMtVideoPortParamList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtVideoPortParam > param_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtVideoPortParamList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTResizeMode : public ::google::protobuf::Message {
 public:
  TMTResizeMode();
  virtual ~TMTResizeMode();

  TMTResizeMode(const TMTResizeMode& from);

  inline TMTResizeMode& operator=(const TMTResizeMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTResizeMode& default_instance();

  void Swap(TMTResizeMode* other);

  // implements Message ----------------------------------------------

  TMTResizeMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTResizeMode& from);
  void MergeFrom(const TMTResizeMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmResizeMode emResizeMode = 1;
  inline bool has_emresizemode() const;
  inline void clear_emresizemode();
  static const int kEmResizeModeFieldNumber = 1;
  inline ::mt::EmResizeMode emresizemode() const;
  inline void set_emresizemode(::mt::EmResizeMode value);

  // @@protoc_insertion_point(class_scope:mt.TMTResizeMode)
 private:
  inline void set_has_emresizemode();
  inline void clear_has_emresizemode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emresizemode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTResizeMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDynamicPayload : public ::google::protobuf::Message {
 public:
  TDynamicPayload();
  virtual ~TDynamicPayload();

  TDynamicPayload(const TDynamicPayload& from);

  inline TDynamicPayload& operator=(const TDynamicPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDynamicPayload& default_instance();

  void Swap(TDynamicPayload* other);

  // implements Message ----------------------------------------------

  TDynamicPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDynamicPayload& from);
  void MergeFrom(const TDynamicPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 mtKeyRmtActivePT = 1;
  inline bool has_mtkeyrmtactivept() const;
  inline void clear_mtkeyrmtactivept();
  static const int kMtKeyRmtActivePTFieldNumber = 1;
  inline ::google::protobuf::uint32 mtkeyrmtactivept() const;
  inline void set_mtkeyrmtactivept(::google::protobuf::uint32 value);

  // optional uint32 mtKeyRealPT = 2;
  inline bool has_mtkeyrealpt() const;
  inline void clear_mtkeyrealpt();
  static const int kMtKeyRealPTFieldNumber = 2;
  inline ::google::protobuf::uint32 mtkeyrealpt() const;
  inline void set_mtkeyrealpt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TDynamicPayload)
 private:
  inline void set_has_mtkeyrmtactivept();
  inline void clear_has_mtkeyrmtactivept();
  inline void set_has_mtkeyrealpt();
  inline void clear_has_mtkeyrealpt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 mtkeyrmtactivept_;
  ::google::protobuf::uint32 mtkeyrealpt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TDynamicPayload* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpDynamicPayload : public ::google::protobuf::Message {
 public:
  TRpDynamicPayload();
  virtual ~TRpDynamicPayload();

  TRpDynamicPayload(const TRpDynamicPayload& from);

  inline TRpDynamicPayload& operator=(const TRpDynamicPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpDynamicPayload& default_instance();

  void Swap(TRpDynamicPayload* other);

  // implements Message ----------------------------------------------

  TRpDynamicPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpDynamicPayload& from);
  void MergeFrom(const TRpDynamicPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TDynamicPayload payload_list = 1;
  inline int payload_list_size() const;
  inline void clear_payload_list();
  static const int kPayloadListFieldNumber = 1;
  inline const ::mt::TDynamicPayload& payload_list(int index) const;
  inline ::mt::TDynamicPayload* mutable_payload_list(int index);
  inline ::mt::TDynamicPayload* add_payload_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TDynamicPayload >&
      payload_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TDynamicPayload >*
      mutable_payload_list();

  // @@protoc_insertion_point(class_scope:mt.TRpDynamicPayload)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TDynamicPayload > payload_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TRpDynamicPayload* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtForceSetH323Stack : public ::google::protobuf::Message {
 public:
  TMtForceSetH323Stack();
  virtual ~TMtForceSetH323Stack();

  TMtForceSetH323Stack(const TMtForceSetH323Stack& from);

  inline TMtForceSetH323Stack& operator=(const TMtForceSetH323Stack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtForceSetH323Stack& default_instance();

  void Swap(TMtForceSetH323Stack* other);

  // implements Message ----------------------------------------------

  TMtForceSetH323Stack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtForceSetH323Stack& from);
  void MergeFrom(const TMtForceSetH323Stack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional bool bstand = 2;
  inline bool has_bstand() const;
  inline void clear_bstand();
  static const int kBstandFieldNumber = 2;
  inline bool bstand() const;
  inline void set_bstand(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtForceSetH323Stack)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_bstand();
  inline void clear_has_bstand();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  bool bstand_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtForceSetH323Stack* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRtpRtcpPairPort : public ::google::protobuf::Message {
 public:
  TRtpRtcpPairPort();
  virtual ~TRtpRtcpPairPort();

  TRtpRtcpPairPort(const TRtpRtcpPairPort& from);

  inline TRtpRtcpPairPort& operator=(const TRtpRtcpPairPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRtpRtcpPairPort& default_instance();

  void Swap(TRtpRtcpPairPort* other);

  // implements Message ----------------------------------------------

  TRtpRtcpPairPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRtpRtcpPairPort& from);
  void MergeFrom(const TRtpRtcpPairPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rtpport = 1;
  inline bool has_rtpport() const;
  inline void clear_rtpport();
  static const int kRtpportFieldNumber = 1;
  inline ::google::protobuf::uint32 rtpport() const;
  inline void set_rtpport(::google::protobuf::uint32 value);

  // optional uint32 rtcpport = 2;
  inline bool has_rtcpport() const;
  inline void clear_rtcpport();
  static const int kRtcpportFieldNumber = 2;
  inline ::google::protobuf::uint32 rtcpport() const;
  inline void set_rtcpport(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TRtpRtcpPairPort)
 private:
  inline void set_has_rtpport();
  inline void clear_has_rtpport();
  inline void set_has_rtcpport();
  inline void clear_has_rtcpport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 rtpport_;
  ::google::protobuf::uint32 rtcpport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TRtpRtcpPairPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTInnerMCAvSWPort : public ::google::protobuf::Message {
 public:
  TMTInnerMCAvSWPort();
  virtual ~TMTInnerMCAvSWPort();

  TMTInnerMCAvSWPort(const TMTInnerMCAvSWPort& from);

  inline TMTInnerMCAvSWPort& operator=(const TMTInnerMCAvSWPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTInnerMCAvSWPort& default_instance();

  void Swap(TMTInnerMCAvSWPort* other);

  // implements Message ----------------------------------------------

  TMTInnerMCAvSWPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTInnerMCAvSWPort& from);
  void MergeFrom(const TMTInnerMCAvSWPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TRtpRtcpPairPort mtVidPort = 1;
  inline bool has_mtvidport() const;
  inline void clear_mtvidport();
  static const int kMtVidPortFieldNumber = 1;
  inline const ::mt::TRtpRtcpPairPort& mtvidport() const;
  inline ::mt::TRtpRtcpPairPort* mutable_mtvidport();
  inline ::mt::TRtpRtcpPairPort* release_mtvidport();
  inline void set_allocated_mtvidport(::mt::TRtpRtcpPairPort* mtvidport);

  // optional .mt.TRtpRtcpPairPort mtAudPort = 2;
  inline bool has_mtaudport() const;
  inline void clear_mtaudport();
  static const int kMtAudPortFieldNumber = 2;
  inline const ::mt::TRtpRtcpPairPort& mtaudport() const;
  inline ::mt::TRtpRtcpPairPort* mutable_mtaudport();
  inline ::mt::TRtpRtcpPairPort* release_mtaudport();
  inline void set_allocated_mtaudport(::mt::TRtpRtcpPairPort* mtaudport);

  // optional .mt.TRtpRtcpPairPort mtAssPort = 3;
  inline bool has_mtassport() const;
  inline void clear_mtassport();
  static const int kMtAssPortFieldNumber = 3;
  inline const ::mt::TRtpRtcpPairPort& mtassport() const;
  inline ::mt::TRtpRtcpPairPort* mutable_mtassport();
  inline ::mt::TRtpRtcpPairPort* release_mtassport();
  inline void set_allocated_mtassport(::mt::TRtpRtcpPairPort* mtassport);

  // @@protoc_insertion_point(class_scope:mt.TMTInnerMCAvSWPort)
 private:
  inline void set_has_mtvidport();
  inline void clear_has_mtvidport();
  inline void set_has_mtaudport();
  inline void clear_has_mtaudport();
  inline void set_has_mtassport();
  inline void clear_has_mtassport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TRtpRtcpPairPort* mtvidport_;
  ::mt::TRtpRtcpPairPort* mtaudport_;
  ::mt::TRtpRtcpPairPort* mtassport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTInnerMCAvSWPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTInnerMcRcvAddr : public ::google::protobuf::Message {
 public:
  TMTInnerMcRcvAddr();
  virtual ~TMTInnerMcRcvAddr();

  TMTInnerMcRcvAddr(const TMTInnerMcRcvAddr& from);

  inline TMTInnerMcRcvAddr& operator=(const TMTInnerMcRcvAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTInnerMcRcvAddr& default_instance();

  void Swap(TMTInnerMcRcvAddr* other);

  // implements Message ----------------------------------------------

  TMTInnerMcRcvAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTInnerMcRcvAddr& from);
  void MergeFrom(const TMTInnerMcRcvAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TRtpRtcpPairPort mtVidPort = 1;
  inline int mtvidport_size() const;
  inline void clear_mtvidport();
  static const int kMtVidPortFieldNumber = 1;
  inline const ::mt::TRtpRtcpPairPort& mtvidport(int index) const;
  inline ::mt::TRtpRtcpPairPort* mutable_mtvidport(int index);
  inline ::mt::TRtpRtcpPairPort* add_mtvidport();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPairPort >&
      mtvidport() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPairPort >*
      mutable_mtvidport();

  // repeated .mt.TRtpRtcpPairPort mtAudPort = 2;
  inline int mtaudport_size() const;
  inline void clear_mtaudport();
  static const int kMtAudPortFieldNumber = 2;
  inline const ::mt::TRtpRtcpPairPort& mtaudport(int index) const;
  inline ::mt::TRtpRtcpPairPort* mutable_mtaudport(int index);
  inline ::mt::TRtpRtcpPairPort* add_mtaudport();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPairPort >&
      mtaudport() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPairPort >*
      mutable_mtaudport();

  // @@protoc_insertion_point(class_scope:mt.TMTInnerMcRcvAddr)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPairPort > mtvidport_;
  ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPairPort > mtaudport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTInnerMcRcvAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudioEncParam : public ::google::protobuf::Message {
 public:
  TAudioEncParam();
  virtual ~TAudioEncParam();

  TAudioEncParam(const TAudioEncParam& from);

  inline TAudioEncParam& operator=(const TAudioEncParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudioEncParam& default_instance();

  void Swap(TAudioEncParam* other);

  // implements Message ----------------------------------------------

  TAudioEncParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudioEncParam& from);
  void MergeFrom(const TAudioEncParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmAudFormat aud_format = 1;
  inline bool has_aud_format() const;
  inline void clear_aud_format();
  static const int kAudFormatFieldNumber = 1;
  inline ::mt::EmAudFormat aud_format() const;
  inline void set_aud_format(::mt::EmAudFormat value);

  // optional .mt.EmAacChnlNum channel_num = 2;
  inline bool has_channel_num() const;
  inline void clear_channel_num();
  static const int kChannelNumFieldNumber = 2;
  inline ::mt::EmAacChnlNum channel_num() const;
  inline void set_channel_num(::mt::EmAacChnlNum value);

  // optional .mt.EmAacSampFreq sample_rate = 3;
  inline bool has_sample_rate() const;
  inline void clear_sample_rate();
  static const int kSampleRateFieldNumber = 3;
  inline ::mt::EmAacSampFreq sample_rate() const;
  inline void set_sample_rate(::mt::EmAacSampFreq value);

  // optional uint32 aud_rate = 4;
  inline bool has_aud_rate() const;
  inline void clear_aud_rate();
  static const int kAudRateFieldNumber = 4;
  inline ::google::protobuf::uint32 aud_rate() const;
  inline void set_aud_rate(::google::protobuf::uint32 value);

  // optional uint32 head_flag = 5;
  inline bool has_head_flag() const;
  inline void clear_head_flag();
  static const int kHeadFlagFieldNumber = 5;
  inline ::google::protobuf::uint32 head_flag() const;
  inline void set_head_flag(::google::protobuf::uint32 value);

  // optional uint32 aud_duration = 6;
  inline bool has_aud_duration() const;
  inline void clear_aud_duration();
  static const int kAudDurationFieldNumber = 6;
  inline ::google::protobuf::uint32 aud_duration() const;
  inline void set_aud_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TAudioEncParam)
 private:
  inline void set_has_aud_format();
  inline void clear_has_aud_format();
  inline void set_has_channel_num();
  inline void clear_has_channel_num();
  inline void set_has_sample_rate();
  inline void clear_has_sample_rate();
  inline void set_has_aud_rate();
  inline void clear_has_aud_rate();
  inline void set_has_head_flag();
  inline void clear_has_head_flag();
  inline void set_has_aud_duration();
  inline void clear_has_aud_duration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int aud_format_;
  int channel_num_;
  int sample_rate_;
  ::google::protobuf::uint32 aud_rate_;
  ::google::protobuf::uint32 head_flag_;
  ::google::protobuf::uint32 aud_duration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TAudioEncParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudioEncParamList : public ::google::protobuf::Message {
 public:
  TAudioEncParamList();
  virtual ~TAudioEncParamList();

  TAudioEncParamList(const TAudioEncParamList& from);

  inline TAudioEncParamList& operator=(const TAudioEncParamList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudioEncParamList& default_instance();

  void Swap(TAudioEncParamList* other);

  // implements Message ----------------------------------------------

  TAudioEncParamList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudioEncParamList& from);
  void MergeFrom(const TAudioEncParamList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAudioEncParam aud_enc_param = 1;
  inline int aud_enc_param_size() const;
  inline void clear_aud_enc_param();
  static const int kAudEncParamFieldNumber = 1;
  inline const ::mt::TAudioEncParam& aud_enc_param(int index) const;
  inline ::mt::TAudioEncParam* mutable_aud_enc_param(int index);
  inline ::mt::TAudioEncParam* add_aud_enc_param();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudioEncParam >&
      aud_enc_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudioEncParam >*
      mutable_aud_enc_param();

  // @@protoc_insertion_point(class_scope:mt.TAudioEncParamList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAudioEncParam > aud_enc_param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TAudioEncParamList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TLoginStrategy : public ::google::protobuf::Message {
 public:
  TLoginStrategy();
  virtual ~TLoginStrategy();

  TLoginStrategy(const TLoginStrategy& from);

  inline TLoginStrategy& operator=(const TLoginStrategy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLoginStrategy& default_instance();

  void Swap(TLoginStrategy* other);

  // implements Message ----------------------------------------------

  TLoginStrategy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLoginStrategy& from);
  void MergeFrom(const TLoginStrategy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 login_count = 1;
  inline bool has_login_count() const;
  inline void clear_login_count();
  static const int kLoginCountFieldNumber = 1;
  inline ::google::protobuf::uint32 login_count() const;
  inline void set_login_count(::google::protobuf::uint32 value);

  // optional uint32 wait_time = 2;
  inline bool has_wait_time() const;
  inline void clear_wait_time();
  static const int kWaitTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 wait_time() const;
  inline void set_wait_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TLoginStrategy)
 private:
  inline void set_has_login_count();
  inline void clear_has_login_count();
  inline void set_has_wait_time();
  inline void clear_has_wait_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 login_count_;
  ::google::protobuf::uint32 wait_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TLoginStrategy* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtQtAddr : public ::google::protobuf::Message {
 public:
  TMtQtAddr();
  virtual ~TMtQtAddr();

  TMtQtAddr(const TMtQtAddr& from);

  inline TMtQtAddr& operator=(const TMtQtAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtQtAddr& default_instance();

  void Swap(TMtQtAddr* other);

  // implements Message ----------------------------------------------

  TMtQtAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtQtAddr& from);
  void MergeFrom(const TMtQtAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_enable = 1;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 1;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string username = 4;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 4;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:mt.TMtQtAddr)
 private:
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  bool is_enable_;
  ::google::protobuf::uint32 port_;
  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtQtAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSecKeyUpdatePolicy : public ::google::protobuf::Message {
 public:
  TMtSecKeyUpdatePolicy();
  virtual ~TMtSecKeyUpdatePolicy();

  TMtSecKeyUpdatePolicy(const TMtSecKeyUpdatePolicy& from);

  inline TMtSecKeyUpdatePolicy& operator=(const TMtSecKeyUpdatePolicy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSecKeyUpdatePolicy& default_instance();

  void Swap(TMtSecKeyUpdatePolicy* other);

  // implements Message ----------------------------------------------

  TMtSecKeyUpdatePolicy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSecKeyUpdatePolicy& from);
  void MergeFrom(const TMtSecKeyUpdatePolicy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmSecKeyUpdateMode emseckeyupdatemode = 1;
  inline bool has_emseckeyupdatemode() const;
  inline void clear_emseckeyupdatemode();
  static const int kEmseckeyupdatemodeFieldNumber = 1;
  inline ::mt::EmSecKeyUpdateMode emseckeyupdatemode() const;
  inline void set_emseckeyupdatemode(::mt::EmSecKeyUpdateMode value);

  // optional uint32 keyupdateperiod = 2;
  inline bool has_keyupdateperiod() const;
  inline void clear_keyupdateperiod();
  static const int kKeyupdateperiodFieldNumber = 2;
  inline ::google::protobuf::uint32 keyupdateperiod() const;
  inline void set_keyupdateperiod(::google::protobuf::uint32 value);

  // optional uint32 keyupdatepackcnt = 3;
  inline bool has_keyupdatepackcnt() const;
  inline void clear_keyupdatepackcnt();
  static const int kKeyupdatepackcntFieldNumber = 3;
  inline ::google::protobuf::uint32 keyupdatepackcnt() const;
  inline void set_keyupdatepackcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtSecKeyUpdatePolicy)
 private:
  inline void set_has_emseckeyupdatemode();
  inline void clear_has_emseckeyupdatemode();
  inline void set_has_keyupdateperiod();
  inline void clear_has_keyupdateperiod();
  inline void set_has_keyupdatepackcnt();
  inline void clear_has_keyupdatepackcnt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emseckeyupdatemode_;
  ::google::protobuf::uint32 keyupdateperiod_;
  ::google::protobuf::uint32 keyupdatepackcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtSecKeyUpdatePolicy* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudAacConfPrm : public ::google::protobuf::Message {
 public:
  TAudAacConfPrm();
  virtual ~TAudAacConfPrm();

  TAudAacConfPrm(const TAudAacConfPrm& from);

  inline TAudAacConfPrm& operator=(const TAudAacConfPrm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudAacConfPrm& default_instance();

  void Swap(TAudAacConfPrm* other);

  // implements Message ----------------------------------------------

  TAudAacConfPrm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudAacConfPrm& from);
  void MergeFrom(const TAudAacConfPrm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes conf_para = 1;
  inline bool has_conf_para() const;
  inline void clear_conf_para();
  static const int kConfParaFieldNumber = 1;
  inline const ::std::string& conf_para() const;
  inline void set_conf_para(const ::std::string& value);
  inline void set_conf_para(const char* value);
  inline void set_conf_para(const void* value, size_t size);
  inline ::std::string* mutable_conf_para();
  inline ::std::string* release_conf_para();
  inline void set_allocated_conf_para(::std::string* conf_para);

  // optional .mt.EmAacChnlNum emchnl_num = 2;
  inline bool has_emchnl_num() const;
  inline void clear_emchnl_num();
  static const int kEmchnlNumFieldNumber = 2;
  inline ::mt::EmAacChnlNum emchnl_num() const;
  inline void set_emchnl_num(::mt::EmAacChnlNum value);

  // optional .mt.EmAacSampFreq emsamp_freq = 3;
  inline bool has_emsamp_freq() const;
  inline void clear_emsamp_freq();
  static const int kEmsampFreqFieldNumber = 3;
  inline ::mt::EmAacSampFreq emsamp_freq() const;
  inline void set_emsamp_freq(::mt::EmAacSampFreq value);

  // @@protoc_insertion_point(class_scope:mt.TAudAacConfPrm)
 private:
  inline void set_has_conf_para();
  inline void clear_has_conf_para();
  inline void set_has_emchnl_num();
  inline void clear_has_emchnl_num();
  inline void set_has_emsamp_freq();
  inline void clear_has_emsamp_freq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* conf_para_;
  int emchnl_num_;
  int emsamp_freq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TAudAacConfPrm* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudAacConfPrmList : public ::google::protobuf::Message {
 public:
  TAudAacConfPrmList();
  virtual ~TAudAacConfPrmList();

  TAudAacConfPrmList(const TAudAacConfPrmList& from);

  inline TAudAacConfPrmList& operator=(const TAudAacConfPrmList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudAacConfPrmList& default_instance();

  void Swap(TAudAacConfPrmList* other);

  // implements Message ----------------------------------------------

  TAudAacConfPrmList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudAacConfPrmList& from);
  void MergeFrom(const TAudAacConfPrmList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAudAacConfPrm aud_aac_conf = 1;
  inline int aud_aac_conf_size() const;
  inline void clear_aud_aac_conf();
  static const int kAudAacConfFieldNumber = 1;
  inline const ::mt::TAudAacConfPrm& aud_aac_conf(int index) const;
  inline ::mt::TAudAacConfPrm* mutable_aud_aac_conf(int index);
  inline ::mt::TAudAacConfPrm* add_aud_aac_conf();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudAacConfPrm >&
      aud_aac_conf() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudAacConfPrm >*
      mutable_aud_aac_conf();

  // @@protoc_insertion_point(class_scope:mt.TAudAacConfPrmList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAudAacConfPrm > aud_aac_conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TAudAacConfPrmList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TServerLoginPort : public ::google::protobuf::Message {
 public:
  TServerLoginPort();
  virtual ~TServerLoginPort();

  TServerLoginPort(const TServerLoginPort& from);

  inline TServerLoginPort& operator=(const TServerLoginPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TServerLoginPort& default_instance();

  void Swap(TServerLoginPort* other);

  // implements Message ----------------------------------------------

  TServerLoginPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TServerLoginPort& from);
  void MergeFrom(const TServerLoginPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 http_port = 1;
  inline bool has_http_port() const;
  inline void clear_http_port();
  static const int kHttpPortFieldNumber = 1;
  inline ::google::protobuf::uint32 http_port() const;
  inline void set_http_port(::google::protobuf::uint32 value);

  // optional uint32 https_port = 2 [default = 60090];
  inline bool has_https_port() const;
  inline void clear_https_port();
  static const int kHttpsPortFieldNumber = 2;
  inline ::google::protobuf::uint32 https_port() const;
  inline void set_https_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TServerLoginPort)
 private:
  inline void set_has_http_port();
  inline void clear_has_http_port();
  inline void set_has_https_port();
  inline void clear_has_https_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 http_port_;
  ::google::protobuf::uint32 https_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TServerLoginPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPlatformType : public ::google::protobuf::Message {
 public:
  TPlatformType();
  virtual ~TPlatformType();

  TPlatformType(const TPlatformType& from);

  inline TPlatformType& operator=(const TPlatformType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPlatformType& default_instance();

  void Swap(TPlatformType* other);

  // implements Message ----------------------------------------------

  TPlatformType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPlatformType& from);
  void MergeFrom(const TPlatformType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmPlatform em_platform = 1;
  inline bool has_em_platform() const;
  inline void clear_em_platform();
  static const int kEmPlatformFieldNumber = 1;
  inline ::mt::EmPlatform em_platform() const;
  inline void set_em_platform(::mt::EmPlatform value);

  // optional bool https = 2;
  inline bool has_https() const;
  inline void clear_https();
  static const int kHttpsFieldNumber = 2;
  inline bool https() const;
  inline void set_https(bool value);

  // @@protoc_insertion_point(class_scope:mt.TPlatformType)
 private:
  inline void set_has_em_platform();
  inline void clear_has_em_platform();
  inline void set_has_https();
  inline void clear_has_https();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int em_platform_;
  bool https_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TPlatformType* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTAgentInfo : public ::google::protobuf::Message {
 public:
  TMTAgentInfo();
  virtual ~TMTAgentInfo();

  TMTAgentInfo(const TMTAgentInfo& from);

  inline TMTAgentInfo& operator=(const TMTAgentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTAgentInfo& default_instance();

  void Swap(TMTAgentInfo* other);

  // implements Message ----------------------------------------------

  TMTAgentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTAgentInfo& from);
  void MergeFrom(const TMTAgentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_agent = 1;
  inline bool has_is_agent() const;
  inline void clear_is_agent();
  static const int kIsAgentFieldNumber = 1;
  inline bool is_agent() const;
  inline void set_is_agent(bool value);

  // optional uint32 agent_id = 2;
  inline bool has_agent_id() const;
  inline void clear_agent_id();
  static const int kAgentIdFieldNumber = 2;
  inline ::google::protobuf::uint32 agent_id() const;
  inline void set_agent_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTAgentInfo)
 private:
  inline void set_has_is_agent();
  inline void clear_has_is_agent();
  inline void set_has_agent_id();
  inline void clear_has_agent_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_agent_;
  ::google::protobuf::uint32 agent_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTAgentInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTVgaImageOutAdjustCfg : public ::google::protobuf::Message {
 public:
  TMTVgaImageOutAdjustCfg();
  virtual ~TMTVgaImageOutAdjustCfg();

  TMTVgaImageOutAdjustCfg(const TMTVgaImageOutAdjustCfg& from);

  inline TMTVgaImageOutAdjustCfg& operator=(const TMTVgaImageOutAdjustCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTVgaImageOutAdjustCfg& default_instance();

  void Swap(TMTVgaImageOutAdjustCfg* other);

  // implements Message ----------------------------------------------

  TMTVgaImageOutAdjustCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTVgaImageOutAdjustCfg& from);
  void MergeFrom(const TMTVgaImageOutAdjustCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 vga1_imageout_offset = 1;
  inline bool has_vga1_imageout_offset() const;
  inline void clear_vga1_imageout_offset();
  static const int kVga1ImageoutOffsetFieldNumber = 1;
  inline ::google::protobuf::int32 vga1_imageout_offset() const;
  inline void set_vga1_imageout_offset(::google::protobuf::int32 value);

  // optional int32 vga2_imageout_offset = 2;
  inline bool has_vga2_imageout_offset() const;
  inline void clear_vga2_imageout_offset();
  static const int kVga2ImageoutOffsetFieldNumber = 2;
  inline ::google::protobuf::int32 vga2_imageout_offset() const;
  inline void set_vga2_imageout_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt.TMTVgaImageOutAdjustCfg)
 private:
  inline void set_has_vga1_imageout_offset();
  inline void clear_has_vga1_imageout_offset();
  inline void set_has_vga2_imageout_offset();
  inline void clear_has_vga2_imageout_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 vga1_imageout_offset_;
  ::google::protobuf::int32 vga2_imageout_offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMTVgaImageOutAdjustCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtPlatformInfo : public ::google::protobuf::Message {
 public:
  TMtPlatformInfo();
  virtual ~TMtPlatformInfo();

  TMtPlatformInfo(const TMtPlatformInfo& from);

  inline TMtPlatformInfo& operator=(const TMtPlatformInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtPlatformInfo& default_instance();

  void Swap(TMtPlatformInfo* other);

  // implements Message ----------------------------------------------

  TMtPlatformInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtPlatformInfo& from);
  void MergeFrom(const TMtPlatformInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional .mt.EmResourceType resource_type = 3;
  inline bool has_resource_type() const;
  inline void clear_resource_type();
  static const int kResourceTypeFieldNumber = 3;
  inline ::mt::EmResourceType resource_type() const;
  inline void set_resource_type(::mt::EmResourceType value);

  // @@protoc_insertion_point(class_scope:mt.TMtPlatformInfo)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_resource_type();
  inline void clear_has_resource_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  ::google::protobuf::uint32 ip_;
  int resource_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtPlatformInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtCameraLastPos : public ::google::protobuf::Message {
 public:
  TMtCameraLastPos();
  virtual ~TMtCameraLastPos();

  TMtCameraLastPos(const TMtCameraLastPos& from);

  inline TMtCameraLastPos& operator=(const TMtCameraLastPos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtCameraLastPos& default_instance();

  void Swap(TMtCameraLastPos* other);

  // implements Message ----------------------------------------------

  TMtCameraLastPos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtCameraLastPos& from);
  void MergeFrom(const TMtCameraLastPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool b_use = 1;
  inline bool has_b_use() const;
  inline void clear_b_use();
  static const int kBUseFieldNumber = 1;
  inline bool b_use() const;
  inline void set_b_use(bool value);

  // optional int32 pos_x = 2;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 2;
  inline ::google::protobuf::int32 pos_x() const;
  inline void set_pos_x(::google::protobuf::int32 value);

  // optional int32 pos_y = 3;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 3;
  inline ::google::protobuf::int32 pos_y() const;
  inline void set_pos_y(::google::protobuf::int32 value);

  // optional int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtCameraLastPos)
 private:
  inline void set_has_b_use();
  inline void clear_has_b_use();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool b_use_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 pos_y_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtCameraLastPos* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtShortCutKey : public ::google::protobuf::Message {
 public:
  TMtShortCutKey();
  virtual ~TMtShortCutKey();

  TMtShortCutKey(const TMtShortCutKey& from);

  inline TMtShortCutKey& operator=(const TMtShortCutKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtShortCutKey& default_instance();

  void Swap(TMtShortCutKey* other);

  // implements Message ----------------------------------------------

  TMtShortCutKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtShortCutKey& from);
  void MergeFrom(const TMtShortCutKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmShortCutKeyType key_type = 1;
  inline bool has_key_type() const;
  inline void clear_key_type();
  static const int kKeyTypeFieldNumber = 1;
  inline ::mt::EmShortCutKeyType key_type() const;
  inline void set_key_type(::mt::EmShortCutKeyType value);

  // optional .mt.EmShortCutKeyFuc key_fuc = 2;
  inline bool has_key_fuc() const;
  inline void clear_key_fuc();
  static const int kKeyFucFieldNumber = 2;
  inline ::mt::EmShortCutKeyFuc key_fuc() const;
  inline void set_key_fuc(::mt::EmShortCutKeyFuc value);

  // @@protoc_insertion_point(class_scope:mt.TMtShortCutKey)
 private:
  inline void set_has_key_type();
  inline void clear_has_key_type();
  inline void set_has_key_fuc();
  inline void clear_has_key_fuc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int key_type_;
  int key_fuc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtShortCutKey* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtShortCutKeyList : public ::google::protobuf::Message {
 public:
  TMtShortCutKeyList();
  virtual ~TMtShortCutKeyList();

  TMtShortCutKeyList(const TMtShortCutKeyList& from);

  inline TMtShortCutKeyList& operator=(const TMtShortCutKeyList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtShortCutKeyList& default_instance();

  void Swap(TMtShortCutKeyList* other);

  // implements Message ----------------------------------------------

  TMtShortCutKeyList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtShortCutKeyList& from);
  void MergeFrom(const TMtShortCutKeyList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtShortCutKey short_cut_key = 1;
  inline int short_cut_key_size() const;
  inline void clear_short_cut_key();
  static const int kShortCutKeyFieldNumber = 1;
  inline const ::mt::TMtShortCutKey& short_cut_key(int index) const;
  inline ::mt::TMtShortCutKey* mutable_short_cut_key(int index);
  inline ::mt::TMtShortCutKey* add_short_cut_key();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtShortCutKey >&
      short_cut_key() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtShortCutKey >*
      mutable_short_cut_key();

  // @@protoc_insertion_point(class_scope:mt.TMtShortCutKeyList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtShortCutKey > short_cut_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtShortCutKeyList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtFunctionIcon : public ::google::protobuf::Message {
 public:
  TMtFunctionIcon();
  virtual ~TMtFunctionIcon();

  TMtFunctionIcon(const TMtFunctionIcon& from);

  inline TMtFunctionIcon& operator=(const TMtFunctionIcon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtFunctionIcon& default_instance();

  void Swap(TMtFunctionIcon* other);

  // implements Message ----------------------------------------------

  TMtFunctionIcon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtFunctionIcon& from);
  void MergeFrom(const TMtFunctionIcon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmFunctionIcon icon_type = 1;
  inline bool has_icon_type() const;
  inline void clear_icon_type();
  static const int kIconTypeFieldNumber = 1;
  inline ::mt::EmFunctionIcon icon_type() const;
  inline void set_icon_type(::mt::EmFunctionIcon value);

  // optional bool is_enable = 2;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 2;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtFunctionIcon)
 private:
  inline void set_has_icon_type();
  inline void clear_has_icon_type();
  inline void set_has_is_enable();
  inline void clear_has_is_enable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int icon_type_;
  bool is_enable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtFunctionIcon* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtFunctionIconList : public ::google::protobuf::Message {
 public:
  TMtFunctionIconList();
  virtual ~TMtFunctionIconList();

  TMtFunctionIconList(const TMtFunctionIconList& from);

  inline TMtFunctionIconList& operator=(const TMtFunctionIconList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtFunctionIconList& default_instance();

  void Swap(TMtFunctionIconList* other);

  // implements Message ----------------------------------------------

  TMtFunctionIconList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtFunctionIconList& from);
  void MergeFrom(const TMtFunctionIconList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtFunctionIcon function_icon = 1;
  inline int function_icon_size() const;
  inline void clear_function_icon();
  static const int kFunctionIconFieldNumber = 1;
  inline const ::mt::TMtFunctionIcon& function_icon(int index) const;
  inline ::mt::TMtFunctionIcon* mutable_function_icon(int index);
  inline ::mt::TMtFunctionIcon* add_function_icon();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtFunctionIcon >&
      function_icon() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtFunctionIcon >*
      mutable_function_icon();

  // @@protoc_insertion_point(class_scope:mt.TMtFunctionIconList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtFunctionIcon > function_icon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structcfg_2eproto();
  friend void protobuf_AssignDesc_structcfg_2eproto();
  friend void protobuf_ShutdownFile_structcfg_2eproto();

  void InitAsDefaultInstance();
  static TMtFunctionIconList* default_instance_;
};
// ===================================================================


// ===================================================================

// TMtCfgIP

// optional uint32 ip = 1;
inline bool TMtCfgIP::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtCfgIP::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtCfgIP::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtCfgIP::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtCfgIP::ip() const {
  return ip_;
}
inline void TMtCfgIP::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// -------------------------------------------------------------------

// TMtSvrState

// optional .mt.EmServerType svr_type = 1;
inline bool TMtSvrState::has_svr_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSvrState::set_has_svr_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSvrState::clear_has_svr_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSvrState::clear_svr_type() {
  svr_type_ = 0;
  clear_has_svr_type();
}
inline ::mt::EmServerType TMtSvrState::svr_type() const {
  return static_cast< ::mt::EmServerType >(svr_type_);
}
inline void TMtSvrState::set_svr_type(::mt::EmServerType value) {
  assert(::mt::EmServerType_IsValid(value));
  set_has_svr_type();
  svr_type_ = value;
}

// optional .mt.EmServerState svr_state = 2;
inline bool TMtSvrState::has_svr_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSvrState::set_has_svr_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSvrState::clear_has_svr_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSvrState::clear_svr_state() {
  svr_state_ = 0;
  clear_has_svr_state();
}
inline ::mt::EmServerState TMtSvrState::svr_state() const {
  return static_cast< ::mt::EmServerState >(svr_state_);
}
inline void TMtSvrState::set_svr_state(::mt::EmServerState value) {
  assert(::mt::EmServerState_IsValid(value));
  set_has_svr_state();
  svr_state_ = value;
}

// -------------------------------------------------------------------

// TMtSvrStateTable

// repeated .mt.TMtSvrState state_items = 1;
inline int TMtSvrStateTable::state_items_size() const {
  return state_items_.size();
}
inline void TMtSvrStateTable::clear_state_items() {
  state_items_.Clear();
}
inline const ::mt::TMtSvrState& TMtSvrStateTable::state_items(int index) const {
  return state_items_.Get(index);
}
inline ::mt::TMtSvrState* TMtSvrStateTable::mutable_state_items(int index) {
  return state_items_.Mutable(index);
}
inline ::mt::TMtSvrState* TMtSvrStateTable::add_state_items() {
  return state_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtSvrState >&
TMtSvrStateTable::state_items() const {
  return state_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtSvrState >*
TMtSvrStateTable::mutable_state_items() {
  return &state_items_;
}

// -------------------------------------------------------------------

// TMtLoginTactic

// optional .mt.EmServerType svr_type = 1;
inline bool TMtLoginTactic::has_svr_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtLoginTactic::set_has_svr_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtLoginTactic::clear_has_svr_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtLoginTactic::clear_svr_type() {
  svr_type_ = 0;
  clear_has_svr_type();
}
inline ::mt::EmServerType TMtLoginTactic::svr_type() const {
  return static_cast< ::mt::EmServerType >(svr_type_);
}
inline void TMtLoginTactic::set_svr_type(::mt::EmServerType value) {
  assert(::mt::EmServerType_IsValid(value));
  set_has_svr_type();
  svr_type_ = value;
}

// repeated .mt.EmServerType predecessor_svr_list = 2;
inline int TMtLoginTactic::predecessor_svr_list_size() const {
  return predecessor_svr_list_.size();
}
inline void TMtLoginTactic::clear_predecessor_svr_list() {
  predecessor_svr_list_.Clear();
}
inline ::mt::EmServerType TMtLoginTactic::predecessor_svr_list(int index) const {
  return static_cast< ::mt::EmServerType >(predecessor_svr_list_.Get(index));
}
inline void TMtLoginTactic::set_predecessor_svr_list(int index, ::mt::EmServerType value) {
  assert(::mt::EmServerType_IsValid(value));
  predecessor_svr_list_.Set(index, value);
}
inline void TMtLoginTactic::add_predecessor_svr_list(::mt::EmServerType value) {
  assert(::mt::EmServerType_IsValid(value));
  predecessor_svr_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TMtLoginTactic::predecessor_svr_list() const {
  return predecessor_svr_list_;
}
inline ::google::protobuf::RepeatedField<int>*
TMtLoginTactic::mutable_predecessor_svr_list() {
  return &predecessor_svr_list_;
}

// optional bool use_or_not = 3;
inline bool TMtLoginTactic::has_use_or_not() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtLoginTactic::set_has_use_or_not() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtLoginTactic::clear_has_use_or_not() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtLoginTactic::clear_use_or_not() {
  use_or_not_ = false;
  clear_has_use_or_not();
}
inline bool TMtLoginTactic::use_or_not() const {
  return use_or_not_;
}
inline void TMtLoginTactic::set_use_or_not(bool value) {
  set_has_use_or_not();
  use_or_not_ = value;
}

// -------------------------------------------------------------------

// TMtApsLoginParam

// optional string username = 1;
inline bool TMtApsLoginParam::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtApsLoginParam::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtApsLoginParam::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtApsLoginParam::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMtApsLoginParam::username() const {
  return *username_;
}
inline void TMtApsLoginParam::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMtApsLoginParam::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMtApsLoginParam::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtApsLoginParam::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMtApsLoginParam::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtApsLoginParam::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool TMtApsLoginParam::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtApsLoginParam::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtApsLoginParam::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtApsLoginParam::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtApsLoginParam::password() const {
  return *password_;
}
inline void TMtApsLoginParam::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtApsLoginParam::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtApsLoginParam::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtApsLoginParam::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtApsLoginParam::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtApsLoginParam::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string software_ver = 3;
inline bool TMtApsLoginParam::has_software_ver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtApsLoginParam::set_has_software_ver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtApsLoginParam::clear_has_software_ver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtApsLoginParam::clear_software_ver() {
  if (software_ver_ != &::google::protobuf::internal::kEmptyString) {
    software_ver_->clear();
  }
  clear_has_software_ver();
}
inline const ::std::string& TMtApsLoginParam::software_ver() const {
  return *software_ver_;
}
inline void TMtApsLoginParam::set_software_ver(const ::std::string& value) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(value);
}
inline void TMtApsLoginParam::set_software_ver(const char* value) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(value);
}
inline void TMtApsLoginParam::set_software_ver(const char* value, size_t size) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtApsLoginParam::mutable_software_ver() {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  return software_ver_;
}
inline ::std::string* TMtApsLoginParam::release_software_ver() {
  clear_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_ver_;
    software_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtApsLoginParam::set_allocated_software_ver(::std::string* software_ver) {
  if (software_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete software_ver_;
  }
  if (software_ver) {
    set_has_software_ver();
    software_ver_ = software_ver;
  } else {
    clear_has_software_ver();
    software_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string model_name = 4;
inline bool TMtApsLoginParam::has_model_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtApsLoginParam::set_has_model_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtApsLoginParam::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtApsLoginParam::clear_model_name() {
  if (model_name_ != &::google::protobuf::internal::kEmptyString) {
    model_name_->clear();
  }
  clear_has_model_name();
}
inline const ::std::string& TMtApsLoginParam::model_name() const {
  return *model_name_;
}
inline void TMtApsLoginParam::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void TMtApsLoginParam::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void TMtApsLoginParam::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtApsLoginParam::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  return model_name_;
}
inline ::std::string* TMtApsLoginParam::release_model_name() {
  clear_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtApsLoginParam::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != &::google::protobuf::internal::kEmptyString) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string oem_info = 5;
inline bool TMtApsLoginParam::has_oem_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtApsLoginParam::set_has_oem_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtApsLoginParam::clear_has_oem_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtApsLoginParam::clear_oem_info() {
  if (oem_info_ != &::google::protobuf::internal::kEmptyString) {
    oem_info_->clear();
  }
  clear_has_oem_info();
}
inline const ::std::string& TMtApsLoginParam::oem_info() const {
  return *oem_info_;
}
inline void TMtApsLoginParam::set_oem_info(const ::std::string& value) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(value);
}
inline void TMtApsLoginParam::set_oem_info(const char* value) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(value);
}
inline void TMtApsLoginParam::set_oem_info(const char* value, size_t size) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtApsLoginParam::mutable_oem_info() {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  return oem_info_;
}
inline ::std::string* TMtApsLoginParam::release_oem_info() {
  clear_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oem_info_;
    oem_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtApsLoginParam::set_allocated_oem_info(::std::string* oem_info) {
  if (oem_info_ != &::google::protobuf::internal::kEmptyString) {
    delete oem_info_;
  }
  if (oem_info) {
    set_has_oem_info();
    oem_info_ = oem_info;
  } else {
    clear_has_oem_info();
    oem_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string md5password = 6;
inline bool TMtApsLoginParam::has_md5password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtApsLoginParam::set_has_md5password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtApsLoginParam::clear_has_md5password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtApsLoginParam::clear_md5password() {
  if (md5password_ != &::google::protobuf::internal::kEmptyString) {
    md5password_->clear();
  }
  clear_has_md5password();
}
inline const ::std::string& TMtApsLoginParam::md5password() const {
  return *md5password_;
}
inline void TMtApsLoginParam::set_md5password(const ::std::string& value) {
  set_has_md5password();
  if (md5password_ == &::google::protobuf::internal::kEmptyString) {
    md5password_ = new ::std::string;
  }
  md5password_->assign(value);
}
inline void TMtApsLoginParam::set_md5password(const char* value) {
  set_has_md5password();
  if (md5password_ == &::google::protobuf::internal::kEmptyString) {
    md5password_ = new ::std::string;
  }
  md5password_->assign(value);
}
inline void TMtApsLoginParam::set_md5password(const char* value, size_t size) {
  set_has_md5password();
  if (md5password_ == &::google::protobuf::internal::kEmptyString) {
    md5password_ = new ::std::string;
  }
  md5password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtApsLoginParam::mutable_md5password() {
  set_has_md5password();
  if (md5password_ == &::google::protobuf::internal::kEmptyString) {
    md5password_ = new ::std::string;
  }
  return md5password_;
}
inline ::std::string* TMtApsLoginParam::release_md5password() {
  clear_has_md5password();
  if (md5password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md5password_;
    md5password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtApsLoginParam::set_allocated_md5password(::std::string* md5password) {
  if (md5password_ != &::google::protobuf::internal::kEmptyString) {
    delete md5password_;
  }
  if (md5password) {
    set_has_md5password();
    md5password_ = md5password;
  } else {
    clear_has_md5password();
    md5password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtApsLoginErrcode

// optional bool is_sucess = 1;
inline bool TMtApsLoginErrcode::has_is_sucess() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtApsLoginErrcode::set_has_is_sucess() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtApsLoginErrcode::clear_has_is_sucess() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtApsLoginErrcode::clear_is_sucess() {
  is_sucess_ = false;
  clear_has_is_sucess();
}
inline bool TMtApsLoginErrcode::is_sucess() const {
  return is_sucess_;
}
inline void TMtApsLoginErrcode::set_is_sucess(bool value) {
  set_has_is_sucess();
  is_sucess_ = value;
}

// optional uint32 http_errcode = 2;
inline bool TMtApsLoginErrcode::has_http_errcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtApsLoginErrcode::set_has_http_errcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtApsLoginErrcode::clear_has_http_errcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtApsLoginErrcode::clear_http_errcode() {
  http_errcode_ = 0u;
  clear_has_http_errcode();
}
inline ::google::protobuf::uint32 TMtApsLoginErrcode::http_errcode() const {
  return http_errcode_;
}
inline void TMtApsLoginErrcode::set_http_errcode(::google::protobuf::uint32 value) {
  set_has_http_errcode();
  http_errcode_ = value;
}

// optional uint32 aps_errcode = 3;
inline bool TMtApsLoginErrcode::has_aps_errcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtApsLoginErrcode::set_has_aps_errcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtApsLoginErrcode::clear_has_aps_errcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtApsLoginErrcode::clear_aps_errcode() {
  aps_errcode_ = 0u;
  clear_has_aps_errcode();
}
inline ::google::protobuf::uint32 TMtApsLoginErrcode::aps_errcode() const {
  return aps_errcode_;
}
inline void TMtApsLoginErrcode::set_aps_errcode(::google::protobuf::uint32 value) {
  set_has_aps_errcode();
  aps_errcode_ = value;
}

// -------------------------------------------------------------------

// TMtLoginTacticsTable

// repeated .mt.TMtLoginTactic tactic_items = 1;
inline int TMtLoginTacticsTable::tactic_items_size() const {
  return tactic_items_.size();
}
inline void TMtLoginTacticsTable::clear_tactic_items() {
  tactic_items_.Clear();
}
inline const ::mt::TMtLoginTactic& TMtLoginTacticsTable::tactic_items(int index) const {
  return tactic_items_.Get(index);
}
inline ::mt::TMtLoginTactic* TMtLoginTacticsTable::mutable_tactic_items(int index) {
  return tactic_items_.Mutable(index);
}
inline ::mt::TMtLoginTactic* TMtLoginTacticsTable::add_tactic_items() {
  return tactic_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtLoginTactic >&
TMtLoginTacticsTable::tactic_items() const {
  return tactic_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtLoginTactic >*
TMtLoginTacticsTable::mutable_tactic_items() {
  return &tactic_items_;
}

// -------------------------------------------------------------------

// TMtSvrListFromSDK

// repeated .mt.EmServerType server_list = 1;
inline int TMtSvrListFromSDK::server_list_size() const {
  return server_list_.size();
}
inline void TMtSvrListFromSDK::clear_server_list() {
  server_list_.Clear();
}
inline ::mt::EmServerType TMtSvrListFromSDK::server_list(int index) const {
  return static_cast< ::mt::EmServerType >(server_list_.Get(index));
}
inline void TMtSvrListFromSDK::set_server_list(int index, ::mt::EmServerType value) {
  assert(::mt::EmServerType_IsValid(value));
  server_list_.Set(index, value);
}
inline void TMtSvrListFromSDK::add_server_list(::mt::EmServerType value) {
  assert(::mt::EmServerType_IsValid(value));
  server_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TMtSvrListFromSDK::server_list() const {
  return server_list_;
}
inline ::google::protobuf::RepeatedField<int>*
TMtSvrListFromSDK::mutable_server_list() {
  return &server_list_;
}

// -------------------------------------------------------------------

// TMtSvrLoginResultToSDK

// optional int32 error_id = 1;
inline bool TMtSvrLoginResultToSDK::has_error_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSvrLoginResultToSDK::set_has_error_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSvrLoginResultToSDK::clear_has_error_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSvrLoginResultToSDK::clear_error_id() {
  error_id_ = 0;
  clear_has_error_id();
}
inline ::google::protobuf::int32 TMtSvrLoginResultToSDK::error_id() const {
  return error_id_;
}
inline void TMtSvrLoginResultToSDK::set_error_id(::google::protobuf::int32 value) {
  set_has_error_id();
  error_id_ = value;
}

// optional .mt.EmServerType server_type = 2;
inline bool TMtSvrLoginResultToSDK::has_server_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSvrLoginResultToSDK::set_has_server_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSvrLoginResultToSDK::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSvrLoginResultToSDK::clear_server_type() {
  server_type_ = 0;
  clear_has_server_type();
}
inline ::mt::EmServerType TMtSvrLoginResultToSDK::server_type() const {
  return static_cast< ::mt::EmServerType >(server_type_);
}
inline void TMtSvrLoginResultToSDK::set_server_type(::mt::EmServerType value) {
  assert(::mt::EmServerType_IsValid(value));
  set_has_server_type();
  server_type_ = value;
}

// optional .mt.EmServerState server_state = 3;
inline bool TMtSvrLoginResultToSDK::has_server_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtSvrLoginResultToSDK::set_has_server_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtSvrLoginResultToSDK::clear_has_server_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtSvrLoginResultToSDK::clear_server_state() {
  server_state_ = 0;
  clear_has_server_state();
}
inline ::mt::EmServerState TMtSvrLoginResultToSDK::server_state() const {
  return static_cast< ::mt::EmServerState >(server_state_);
}
inline void TMtSvrLoginResultToSDK::set_server_state(::mt::EmServerState value) {
  assert(::mt::EmServerState_IsValid(value));
  set_has_server_state();
  server_state_ = value;
}

// -------------------------------------------------------------------

// TMtSvrType

// optional uint32 req_sqn = 1;
inline bool TMtSvrType::has_req_sqn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSvrType::set_has_req_sqn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSvrType::clear_has_req_sqn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSvrType::clear_req_sqn() {
  req_sqn_ = 0u;
  clear_has_req_sqn();
}
inline ::google::protobuf::uint32 TMtSvrType::req_sqn() const {
  return req_sqn_;
}
inline void TMtSvrType::set_req_sqn(::google::protobuf::uint32 value) {
  set_has_req_sqn();
  req_sqn_ = value;
}

// optional .mt.EmServerType server_type = 2;
inline bool TMtSvrType::has_server_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSvrType::set_has_server_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSvrType::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSvrType::clear_server_type() {
  server_type_ = 0;
  clear_has_server_type();
}
inline ::mt::EmServerType TMtSvrType::server_type() const {
  return static_cast< ::mt::EmServerType >(server_type_);
}
inline void TMtSvrType::set_server_type(::mt::EmServerType value) {
  assert(::mt::EmServerType_IsValid(value));
  set_has_server_type();
  server_type_ = value;
}

// -------------------------------------------------------------------

// TMtSvrLoginStateFromService

// optional uint32 rsp_sqn = 1;
inline bool TMtSvrLoginStateFromService::has_rsp_sqn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSvrLoginStateFromService::set_has_rsp_sqn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSvrLoginStateFromService::clear_has_rsp_sqn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSvrLoginStateFromService::clear_rsp_sqn() {
  rsp_sqn_ = 0u;
  clear_has_rsp_sqn();
}
inline ::google::protobuf::uint32 TMtSvrLoginStateFromService::rsp_sqn() const {
  return rsp_sqn_;
}
inline void TMtSvrLoginStateFromService::set_rsp_sqn(::google::protobuf::uint32 value) {
  set_has_rsp_sqn();
  rsp_sqn_ = value;
}

// optional .mt.EmServerType server_type = 2;
inline bool TMtSvrLoginStateFromService::has_server_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSvrLoginStateFromService::set_has_server_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSvrLoginStateFromService::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSvrLoginStateFromService::clear_server_type() {
  server_type_ = 0;
  clear_has_server_type();
}
inline ::mt::EmServerType TMtSvrLoginStateFromService::server_type() const {
  return static_cast< ::mt::EmServerType >(server_type_);
}
inline void TMtSvrLoginStateFromService::set_server_type(::mt::EmServerType value) {
  assert(::mt::EmServerType_IsValid(value));
  set_has_server_type();
  server_type_ = value;
}

// optional .mt.EmServerState server_state = 3;
inline bool TMtSvrLoginStateFromService::has_server_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtSvrLoginStateFromService::set_has_server_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtSvrLoginStateFromService::clear_has_server_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtSvrLoginStateFromService::clear_server_state() {
  server_state_ = 0;
  clear_has_server_state();
}
inline ::mt::EmServerState TMtSvrLoginStateFromService::server_state() const {
  return static_cast< ::mt::EmServerState >(server_state_);
}
inline void TMtSvrLoginStateFromService::set_server_state(::mt::EmServerState value) {
  assert(::mt::EmServerState_IsValid(value));
  set_has_server_state();
  server_state_ = value;
}

// -------------------------------------------------------------------

// TMTDnsQueryCbResult

// optional uint32 query_id = 1;
inline bool TMTDnsQueryCbResult::has_query_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTDnsQueryCbResult::set_has_query_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTDnsQueryCbResult::clear_has_query_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTDnsQueryCbResult::clear_query_id() {
  query_id_ = 0u;
  clear_has_query_id();
}
inline ::google::protobuf::uint32 TMTDnsQueryCbResult::query_id() const {
  return query_id_;
}
inline void TMTDnsQueryCbResult::set_query_id(::google::protobuf::uint32 value) {
  set_has_query_id();
  query_id_ = value;
}

// optional uint32 result = 2;
inline bool TMTDnsQueryCbResult::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTDnsQueryCbResult::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTDnsQueryCbResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTDnsQueryCbResult::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 TMTDnsQueryCbResult::result() const {
  return result_;
}
inline void TMTDnsQueryCbResult::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// optional uint32 ip = 3;
inline bool TMTDnsQueryCbResult::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTDnsQueryCbResult::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTDnsQueryCbResult::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTDnsQueryCbResult::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMTDnsQueryCbResult::ip() const {
  return ip_;
}
inline void TMTDnsQueryCbResult::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// -------------------------------------------------------------------

// TMTDomainTranslateReqToUI

// optional uint32 query_id = 1;
inline bool TMTDomainTranslateReqToUI::has_query_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTDomainTranslateReqToUI::set_has_query_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTDomainTranslateReqToUI::clear_has_query_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTDomainTranslateReqToUI::clear_query_id() {
  query_id_ = 0u;
  clear_has_query_id();
}
inline ::google::protobuf::uint32 TMTDomainTranslateReqToUI::query_id() const {
  return query_id_;
}
inline void TMTDomainTranslateReqToUI::set_query_id(::google::protobuf::uint32 value) {
  set_has_query_id();
  query_id_ = value;
}

// optional string domain = 2;
inline bool TMTDomainTranslateReqToUI::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTDomainTranslateReqToUI::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTDomainTranslateReqToUI::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTDomainTranslateReqToUI::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMTDomainTranslateReqToUI::domain() const {
  return *domain_;
}
inline void TMTDomainTranslateReqToUI::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMTDomainTranslateReqToUI::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMTDomainTranslateReqToUI::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTDomainTranslateReqToUI::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMTDomainTranslateReqToUI::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTDomainTranslateReqToUI::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTDomainTranslateRspFromUI

// optional uint32 query_id = 1;
inline bool TMTDomainTranslateRspFromUI::has_query_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTDomainTranslateRspFromUI::set_has_query_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTDomainTranslateRspFromUI::clear_has_query_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTDomainTranslateRspFromUI::clear_query_id() {
  query_id_ = 0u;
  clear_has_query_id();
}
inline ::google::protobuf::uint32 TMTDomainTranslateRspFromUI::query_id() const {
  return query_id_;
}
inline void TMTDomainTranslateRspFromUI::set_query_id(::google::protobuf::uint32 value) {
  set_has_query_id();
  query_id_ = value;
}

// optional uint32 ip = 2;
inline bool TMTDomainTranslateRspFromUI::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTDomainTranslateRspFromUI::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTDomainTranslateRspFromUI::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTDomainTranslateRspFromUI::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMTDomainTranslateRspFromUI::ip() const {
  return ip_;
}
inline void TMTDomainTranslateRspFromUI::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// -------------------------------------------------------------------

// TMTUserPrevilege

// optional bool defaultServiceDomainAdmin = 1;
inline bool TMTUserPrevilege::has_defaultservicedomainadmin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUserPrevilege::set_has_defaultservicedomainadmin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUserPrevilege::clear_has_defaultservicedomainadmin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUserPrevilege::clear_defaultservicedomainadmin() {
  defaultservicedomainadmin_ = false;
  clear_has_defaultservicedomainadmin();
}
inline bool TMTUserPrevilege::defaultservicedomainadmin() const {
  return defaultservicedomainadmin_;
}
inline void TMTUserPrevilege::set_defaultservicedomainadmin(bool value) {
  set_has_defaultservicedomainadmin();
  defaultservicedomainadmin_ = value;
}

// optional bool defaultUserDomainAdmin = 2;
inline bool TMTUserPrevilege::has_defaultuserdomainadmin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUserPrevilege::set_has_defaultuserdomainadmin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUserPrevilege::clear_has_defaultuserdomainadmin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUserPrevilege::clear_defaultuserdomainadmin() {
  defaultuserdomainadmin_ = false;
  clear_has_defaultuserdomainadmin();
}
inline bool TMTUserPrevilege::defaultuserdomainadmin() const {
  return defaultuserdomainadmin_;
}
inline void TMTUserPrevilege::set_defaultuserdomainadmin(bool value) {
  set_has_defaultuserdomainadmin();
  defaultuserdomainadmin_ = value;
}

// optional bool enableBMC = 3;
inline bool TMTUserPrevilege::has_enablebmc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTUserPrevilege::set_has_enablebmc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTUserPrevilege::clear_has_enablebmc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTUserPrevilege::clear_enablebmc() {
  enablebmc_ = false;
  clear_has_enablebmc();
}
inline bool TMTUserPrevilege::enablebmc() const {
  return enablebmc_;
}
inline void TMTUserPrevilege::set_enablebmc(bool value) {
  set_has_enablebmc();
  enablebmc_ = value;
}

// optional bool enableCall = 4;
inline bool TMTUserPrevilege::has_enablecall() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTUserPrevilege::set_has_enablecall() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTUserPrevilege::clear_has_enablecall() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTUserPrevilege::clear_enablecall() {
  enablecall_ = false;
  clear_has_enablecall();
}
inline bool TMTUserPrevilege::enablecall() const {
  return enablecall_;
}
inline void TMTUserPrevilege::set_enablecall(bool value) {
  set_has_enablecall();
  enablecall_ = value;
}

// optional bool enableDCS = 5;
inline bool TMTUserPrevilege::has_enabledcs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTUserPrevilege::set_has_enabledcs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTUserPrevilege::clear_has_enabledcs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTUserPrevilege::clear_enabledcs() {
  enabledcs_ = false;
  clear_has_enabledcs();
}
inline bool TMTUserPrevilege::enabledcs() const {
  return enabledcs_;
}
inline void TMTUserPrevilege::set_enabledcs(bool value) {
  set_has_enabledcs();
  enabledcs_ = value;
}

// optional bool enableHD = 6;
inline bool TMTUserPrevilege::has_enablehd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTUserPrevilege::set_has_enablehd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTUserPrevilege::clear_has_enablehd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTUserPrevilege::clear_enablehd() {
  enablehd_ = false;
  clear_has_enablehd();
}
inline bool TMTUserPrevilege::enablehd() const {
  return enablehd_;
}
inline void TMTUserPrevilege::set_enablehd(bool value) {
  set_has_enablehd();
  enablehd_ = value;
}

// optional bool enableIncoming = 7;
inline bool TMTUserPrevilege::has_enableincoming() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTUserPrevilege::set_has_enableincoming() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTUserPrevilege::clear_has_enableincoming() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTUserPrevilege::clear_enableincoming() {
  enableincoming_ = false;
  clear_has_enableincoming();
}
inline bool TMTUserPrevilege::enableincoming() const {
  return enableincoming_;
}
inline void TMTUserPrevilege::set_enableincoming(bool value) {
  set_has_enableincoming();
  enableincoming_ = value;
}

// optional bool enableMeeting = 8;
inline bool TMTUserPrevilege::has_enablemeeting() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTUserPrevilege::set_has_enablemeeting() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTUserPrevilege::clear_has_enablemeeting() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTUserPrevilege::clear_enablemeeting() {
  enablemeeting_ = false;
  clear_has_enablemeeting();
}
inline bool TMTUserPrevilege::enablemeeting() const {
  return enablemeeting_;
}
inline void TMTUserPrevilege::set_enablemeeting(bool value) {
  set_has_enablemeeting();
  enablemeeting_ = value;
}

// optional bool enableMeetingSMS = 9;
inline bool TMTUserPrevilege::has_enablemeetingsms() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTUserPrevilege::set_has_enablemeetingsms() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTUserPrevilege::clear_has_enablemeetingsms() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTUserPrevilege::clear_enablemeetingsms() {
  enablemeetingsms_ = false;
  clear_has_enablemeetingsms();
}
inline bool TMTUserPrevilege::enablemeetingsms() const {
  return enablemeetingsms_;
}
inline void TMTUserPrevilege::set_enablemeetingsms(bool value) {
  set_has_enablemeetingsms();
  enablemeetingsms_ = value;
}

// optional bool enableNM = 10;
inline bool TMTUserPrevilege::has_enablenm() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTUserPrevilege::set_has_enablenm() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTUserPrevilege::clear_has_enablenm() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTUserPrevilege::clear_enablenm() {
  enablenm_ = false;
  clear_has_enablenm();
}
inline bool TMTUserPrevilege::enablenm() const {
  return enablenm_;
}
inline void TMTUserPrevilege::set_enablenm(bool value) {
  set_has_enablenm();
  enablenm_ = value;
}

// optional bool enableOut = 11;
inline bool TMTUserPrevilege::has_enableout() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTUserPrevilege::set_has_enableout() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTUserPrevilege::clear_has_enableout() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTUserPrevilege::clear_enableout() {
  enableout_ = false;
  clear_has_enableout();
}
inline bool TMTUserPrevilege::enableout() const {
  return enableout_;
}
inline void TMTUserPrevilege::set_enableout(bool value) {
  set_has_enableout();
  enableout_ = value;
}

// optional bool enableRoam = 12;
inline bool TMTUserPrevilege::has_enableroam() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTUserPrevilege::set_has_enableroam() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTUserPrevilege::clear_has_enableroam() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTUserPrevilege::clear_enableroam() {
  enableroam_ = false;
  clear_has_enableroam();
}
inline bool TMTUserPrevilege::enableroam() const {
  return enableroam_;
}
inline void TMTUserPrevilege::set_enableroam(bool value) {
  set_has_enableroam();
  enableroam_ = value;
}

// optional bool enableSatellite = 13;
inline bool TMTUserPrevilege::has_enablesatellite() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTUserPrevilege::set_has_enablesatellite() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTUserPrevilege::clear_has_enablesatellite() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTUserPrevilege::clear_enablesatellite() {
  enablesatellite_ = false;
  clear_has_enablesatellite();
}
inline bool TMTUserPrevilege::enablesatellite() const {
  return enablesatellite_;
}
inline void TMTUserPrevilege::set_enablesatellite(bool value) {
  set_has_enablesatellite();
  enablesatellite_ = value;
}

// optional bool enableSatelliteP2P = 14;
inline bool TMTUserPrevilege::has_enablesatellitep2p() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTUserPrevilege::set_has_enablesatellitep2p() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTUserPrevilege::clear_has_enablesatellitep2p() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTUserPrevilege::clear_enablesatellitep2p() {
  enablesatellitep2p_ = false;
  clear_has_enablesatellitep2p();
}
inline bool TMTUserPrevilege::enablesatellitep2p() const {
  return enablesatellitep2p_;
}
inline void TMTUserPrevilege::set_enablesatellitep2p(bool value) {
  set_has_enablesatellitep2p();
  enablesatellitep2p_ = value;
}

// optional bool enableUMC = 15;
inline bool TMTUserPrevilege::has_enableumc() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTUserPrevilege::set_has_enableumc() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTUserPrevilege::clear_has_enableumc() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTUserPrevilege::clear_enableumc() {
  enableumc_ = false;
  clear_has_enableumc();
}
inline bool TMTUserPrevilege::enableumc() const {
  return enableumc_;
}
inline void TMTUserPrevilege::set_enableumc(bool value) {
  set_has_enableumc();
  enableumc_ = value;
}

// optional bool enableVRS = 16;
inline bool TMTUserPrevilege::has_enablevrs() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTUserPrevilege::set_has_enablevrs() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTUserPrevilege::clear_has_enablevrs() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTUserPrevilege::clear_enablevrs() {
  enablevrs_ = false;
  clear_has_enablevrs();
}
inline bool TMTUserPrevilege::enablevrs() const {
  return enablevrs_;
}
inline void TMTUserPrevilege::set_enablevrs(bool value) {
  set_has_enablevrs();
  enablevrs_ = value;
}

// optional bool enableWeibo = 17;
inline bool TMTUserPrevilege::has_enableweibo() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTUserPrevilege::set_has_enableweibo() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTUserPrevilege::clear_has_enableweibo() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTUserPrevilege::clear_enableweibo() {
  enableweibo_ = false;
  clear_has_enableweibo();
}
inline bool TMTUserPrevilege::enableweibo() const {
  return enableweibo_;
}
inline void TMTUserPrevilege::set_enableweibo(bool value) {
  set_has_enableweibo();
  enableweibo_ = value;
}

// optional bool enableAdmin = 18;
inline bool TMTUserPrevilege::has_enableadmin() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTUserPrevilege::set_has_enableadmin() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTUserPrevilege::clear_has_enableadmin() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTUserPrevilege::clear_enableadmin() {
  enableadmin_ = false;
  clear_has_enableadmin();
}
inline bool TMTUserPrevilege::enableadmin() const {
  return enableadmin_;
}
inline void TMTUserPrevilege::set_enableadmin(bool value) {
  set_has_enableadmin();
  enableadmin_ = value;
}

// optional bool serviceDomainAdmin = 19;
inline bool TMTUserPrevilege::has_servicedomainadmin() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTUserPrevilege::set_has_servicedomainadmin() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTUserPrevilege::clear_has_servicedomainadmin() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTUserPrevilege::clear_servicedomainadmin() {
  servicedomainadmin_ = false;
  clear_has_servicedomainadmin();
}
inline bool TMTUserPrevilege::servicedomainadmin() const {
  return servicedomainadmin_;
}
inline void TMTUserPrevilege::set_servicedomainadmin(bool value) {
  set_has_servicedomainadmin();
  servicedomainadmin_ = value;
}

// optional bool userDomainAdmin = 20;
inline bool TMTUserPrevilege::has_userdomainadmin() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMTUserPrevilege::set_has_userdomainadmin() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMTUserPrevilege::clear_has_userdomainadmin() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMTUserPrevilege::clear_userdomainadmin() {
  userdomainadmin_ = false;
  clear_has_userdomainadmin();
}
inline bool TMTUserPrevilege::userdomainadmin() const {
  return userdomainadmin_;
}
inline void TMTUserPrevilege::set_userdomainadmin(bool value) {
  set_has_userdomainadmin();
  userdomainadmin_ = value;
}

// optional bool weiboAdmin = 21;
inline bool TMTUserPrevilege::has_weiboadmin() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMTUserPrevilege::set_has_weiboadmin() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMTUserPrevilege::clear_has_weiboadmin() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMTUserPrevilege::clear_weiboadmin() {
  weiboadmin_ = false;
  clear_has_weiboadmin();
}
inline bool TMTUserPrevilege::weiboadmin() const {
  return weiboadmin_;
}
inline void TMTUserPrevilege::set_weiboadmin(bool value) {
  set_has_weiboadmin();
  weiboadmin_ = value;
}

// optional bool selfbuilt = 22;
inline bool TMTUserPrevilege::has_selfbuilt() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMTUserPrevilege::set_has_selfbuilt() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMTUserPrevilege::clear_has_selfbuilt() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMTUserPrevilege::clear_selfbuilt() {
  selfbuilt_ = false;
  clear_has_selfbuilt();
}
inline bool TMTUserPrevilege::selfbuilt() const {
  return selfbuilt_;
}
inline void TMTUserPrevilege::set_selfbuilt(bool value) {
  set_has_selfbuilt();
  selfbuilt_ = value;
}

// optional bool portmedia = 23;
inline bool TMTUserPrevilege::has_portmedia() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMTUserPrevilege::set_has_portmedia() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMTUserPrevilege::clear_has_portmedia() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMTUserPrevilege::clear_portmedia() {
  portmedia_ = false;
  clear_has_portmedia();
}
inline bool TMTUserPrevilege::portmedia() const {
  return portmedia_;
}
inline void TMTUserPrevilege::set_portmedia(bool value) {
  set_has_portmedia();
  portmedia_ = value;
}

// optional bool enableAutoCreateMeeting = 24;
inline bool TMTUserPrevilege::has_enableautocreatemeeting() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMTUserPrevilege::set_has_enableautocreatemeeting() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMTUserPrevilege::clear_has_enableautocreatemeeting() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMTUserPrevilege::clear_enableautocreatemeeting() {
  enableautocreatemeeting_ = false;
  clear_has_enableautocreatemeeting();
}
inline bool TMTUserPrevilege::enableautocreatemeeting() const {
  return enableautocreatemeeting_;
}
inline void TMTUserPrevilege::set_enableautocreatemeeting(bool value) {
  set_has_enableautocreatemeeting();
  enableautocreatemeeting_ = value;
}

// optional .mt.EmPltSupportConfType emConfType = 25;
inline bool TMTUserPrevilege::has_emconftype() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMTUserPrevilege::set_has_emconftype() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMTUserPrevilege::clear_has_emconftype() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMTUserPrevilege::clear_emconftype() {
  emconftype_ = 0;
  clear_has_emconftype();
}
inline ::mt::EmPltSupportConfType TMTUserPrevilege::emconftype() const {
  return static_cast< ::mt::EmPltSupportConfType >(emconftype_);
}
inline void TMTUserPrevilege::set_emconftype(::mt::EmPltSupportConfType value) {
  assert(::mt::EmPltSupportConfType_IsValid(value));
  set_has_emconftype();
  emconftype_ = value;
}

// -------------------------------------------------------------------

// TMTUserInfoFromAps

// optional string e164 = 1;
inline bool TMTUserInfoFromAps::has_e164() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUserInfoFromAps::set_has_e164() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUserInfoFromAps::clear_has_e164() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUserInfoFromAps::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTUserInfoFromAps::e164() const {
  return *e164_;
}
inline void TMTUserInfoFromAps::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTUserInfoFromAps::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTUserInfoFromAps::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserInfoFromAps::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTUserInfoFromAps::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserInfoFromAps::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 2;
inline bool TMTUserInfoFromAps::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUserInfoFromAps::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUserInfoFromAps::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUserInfoFromAps::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& TMTUserInfoFromAps::email() const {
  return *email_;
}
inline void TMTUserInfoFromAps::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTUserInfoFromAps::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TMTUserInfoFromAps::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserInfoFromAps::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* TMTUserInfoFromAps::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserInfoFromAps::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jid = 3;
inline bool TMTUserInfoFromAps::has_jid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTUserInfoFromAps::set_has_jid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTUserInfoFromAps::clear_has_jid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTUserInfoFromAps::clear_jid() {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    jid_->clear();
  }
  clear_has_jid();
}
inline const ::std::string& TMTUserInfoFromAps::jid() const {
  return *jid_;
}
inline void TMTUserInfoFromAps::set_jid(const ::std::string& value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTUserInfoFromAps::set_jid(const char* value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
}
inline void TMTUserInfoFromAps::set_jid(const char* value, size_t size) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  jid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserInfoFromAps::mutable_jid() {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    jid_ = new ::std::string;
  }
  return jid_;
}
inline ::std::string* TMTUserInfoFromAps::release_jid() {
  clear_has_jid();
  if (jid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jid_;
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserInfoFromAps::set_allocated_jid(::std::string* jid) {
  if (jid_ != &::google::protobuf::internal::kEmptyString) {
    delete jid_;
  }
  if (jid) {
    set_has_jid();
    jid_ = jid;
  } else {
    clear_has_jid();
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string moid = 4;
inline bool TMTUserInfoFromAps::has_moid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTUserInfoFromAps::set_has_moid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTUserInfoFromAps::clear_has_moid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTUserInfoFromAps::clear_moid() {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    moid_->clear();
  }
  clear_has_moid();
}
inline const ::std::string& TMTUserInfoFromAps::moid() const {
  return *moid_;
}
inline void TMTUserInfoFromAps::set_moid(const ::std::string& value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTUserInfoFromAps::set_moid(const char* value) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(value);
}
inline void TMTUserInfoFromAps::set_moid(const char* value, size_t size) {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserInfoFromAps::mutable_moid() {
  set_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    moid_ = new ::std::string;
  }
  return moid_;
}
inline ::std::string* TMTUserInfoFromAps::release_moid() {
  clear_has_moid();
  if (moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_;
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserInfoFromAps::set_allocated_moid(::std::string* moid) {
  if (moid_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_;
  }
  if (moid) {
    set_has_moid();
    moid_ = moid;
  } else {
    clear_has_moid();
    moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string xmpp_pwd = 5;
inline bool TMTUserInfoFromAps::has_xmpp_pwd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTUserInfoFromAps::set_has_xmpp_pwd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTUserInfoFromAps::clear_has_xmpp_pwd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTUserInfoFromAps::clear_xmpp_pwd() {
  if (xmpp_pwd_ != &::google::protobuf::internal::kEmptyString) {
    xmpp_pwd_->clear();
  }
  clear_has_xmpp_pwd();
}
inline const ::std::string& TMTUserInfoFromAps::xmpp_pwd() const {
  return *xmpp_pwd_;
}
inline void TMTUserInfoFromAps::set_xmpp_pwd(const ::std::string& value) {
  set_has_xmpp_pwd();
  if (xmpp_pwd_ == &::google::protobuf::internal::kEmptyString) {
    xmpp_pwd_ = new ::std::string;
  }
  xmpp_pwd_->assign(value);
}
inline void TMTUserInfoFromAps::set_xmpp_pwd(const char* value) {
  set_has_xmpp_pwd();
  if (xmpp_pwd_ == &::google::protobuf::internal::kEmptyString) {
    xmpp_pwd_ = new ::std::string;
  }
  xmpp_pwd_->assign(value);
}
inline void TMTUserInfoFromAps::set_xmpp_pwd(const char* value, size_t size) {
  set_has_xmpp_pwd();
  if (xmpp_pwd_ == &::google::protobuf::internal::kEmptyString) {
    xmpp_pwd_ = new ::std::string;
  }
  xmpp_pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserInfoFromAps::mutable_xmpp_pwd() {
  set_has_xmpp_pwd();
  if (xmpp_pwd_ == &::google::protobuf::internal::kEmptyString) {
    xmpp_pwd_ = new ::std::string;
  }
  return xmpp_pwd_;
}
inline ::std::string* TMTUserInfoFromAps::release_xmpp_pwd() {
  clear_has_xmpp_pwd();
  if (xmpp_pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmpp_pwd_;
    xmpp_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserInfoFromAps::set_allocated_xmpp_pwd(::std::string* xmpp_pwd) {
  if (xmpp_pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete xmpp_pwd_;
  }
  if (xmpp_pwd) {
    set_has_xmpp_pwd();
    xmpp_pwd_ = xmpp_pwd;
  } else {
    clear_has_xmpp_pwd();
    xmpp_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 6;
inline bool TMTUserInfoFromAps::has_account() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTUserInfoFromAps::set_has_account() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTUserInfoFromAps::clear_has_account() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTUserInfoFromAps::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TMTUserInfoFromAps::account() const {
  return *account_;
}
inline void TMTUserInfoFromAps::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTUserInfoFromAps::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TMTUserInfoFromAps::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserInfoFromAps::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TMTUserInfoFromAps::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserInfoFromAps::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 regmode = 7;
inline bool TMTUserInfoFromAps::has_regmode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTUserInfoFromAps::set_has_regmode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTUserInfoFromAps::clear_has_regmode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTUserInfoFromAps::clear_regmode() {
  regmode_ = 0u;
  clear_has_regmode();
}
inline ::google::protobuf::uint32 TMTUserInfoFromAps::regmode() const {
  return regmode_;
}
inline void TMTUserInfoFromAps::set_regmode(::google::protobuf::uint32 value) {
  set_has_regmode();
  regmode_ = value;
}

// optional string ctime = 8;
inline bool TMTUserInfoFromAps::has_ctime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTUserInfoFromAps::set_has_ctime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTUserInfoFromAps::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTUserInfoFromAps::clear_ctime() {
  if (ctime_ != &::google::protobuf::internal::kEmptyString) {
    ctime_->clear();
  }
  clear_has_ctime();
}
inline const ::std::string& TMTUserInfoFromAps::ctime() const {
  return *ctime_;
}
inline void TMTUserInfoFromAps::set_ctime(const ::std::string& value) {
  set_has_ctime();
  if (ctime_ == &::google::protobuf::internal::kEmptyString) {
    ctime_ = new ::std::string;
  }
  ctime_->assign(value);
}
inline void TMTUserInfoFromAps::set_ctime(const char* value) {
  set_has_ctime();
  if (ctime_ == &::google::protobuf::internal::kEmptyString) {
    ctime_ = new ::std::string;
  }
  ctime_->assign(value);
}
inline void TMTUserInfoFromAps::set_ctime(const char* value, size_t size) {
  set_has_ctime();
  if (ctime_ == &::google::protobuf::internal::kEmptyString) {
    ctime_ = new ::std::string;
  }
  ctime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUserInfoFromAps::mutable_ctime() {
  set_has_ctime();
  if (ctime_ == &::google::protobuf::internal::kEmptyString) {
    ctime_ = new ::std::string;
  }
  return ctime_;
}
inline ::std::string* TMTUserInfoFromAps::release_ctime() {
  clear_has_ctime();
  if (ctime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ctime_;
    ctime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUserInfoFromAps::set_allocated_ctime(::std::string* ctime) {
  if (ctime_ != &::google::protobuf::internal::kEmptyString) {
    delete ctime_;
  }
  if (ctime) {
    set_has_ctime();
    ctime_ = ctime;
  } else {
    clear_has_ctime();
    ctime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isGuest = 9;
inline bool TMTUserInfoFromAps::has_isguest() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTUserInfoFromAps::set_has_isguest() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTUserInfoFromAps::clear_has_isguest() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTUserInfoFromAps::clear_isguest() {
  isguest_ = false;
  clear_has_isguest();
}
inline bool TMTUserInfoFromAps::isguest() const {
  return isguest_;
}
inline void TMTUserInfoFromAps::set_isguest(bool value) {
  set_has_isguest();
  isguest_ = value;
}

// -------------------------------------------------------------------

// TMTServerAddress

// optional string Domain = 1;
inline bool TMTServerAddress::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTServerAddress::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTServerAddress::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTServerAddress::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMTServerAddress::domain() const {
  return *domain_;
}
inline void TMTServerAddress::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMTServerAddress::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMTServerAddress::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTServerAddress::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMTServerAddress::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTServerAddress::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMTServerAddress::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTServerAddress::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTServerAddress::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTServerAddress::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMTServerAddress::ip() const {
  return ip_;
}
inline void TMTServerAddress::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMTServerAddress::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTServerAddress::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTServerAddress::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTServerAddress::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMTServerAddress::port() const {
  return port_;
}
inline void TMTServerAddress::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional uint32 priority = 4;
inline bool TMTServerAddress::has_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTServerAddress::set_has_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTServerAddress::clear_has_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTServerAddress::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 TMTServerAddress::priority() const {
  return priority_;
}
inline void TMTServerAddress::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
}

// optional uint32 timeout = 5;
inline bool TMTServerAddress::has_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTServerAddress::set_has_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTServerAddress::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTServerAddress::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TMTServerAddress::timeout() const {
  return timeout_;
}
inline void TMTServerAddress::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional bool is_new_aps = 6;
inline bool TMTServerAddress::has_is_new_aps() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTServerAddress::set_has_is_new_aps() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTServerAddress::clear_has_is_new_aps() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTServerAddress::clear_is_new_aps() {
  is_new_aps_ = false;
  clear_has_is_new_aps();
}
inline bool TMTServerAddress::is_new_aps() const {
  return is_new_aps_;
}
inline void TMTServerAddress::set_is_new_aps(bool value) {
  set_has_is_new_aps();
  is_new_aps_ = value;
}

// optional bool is_recover = 7;
inline bool TMTServerAddress::has_is_recover() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTServerAddress::set_has_is_recover() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTServerAddress::clear_has_is_recover() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTServerAddress::clear_is_recover() {
  is_recover_ = false;
  clear_has_is_recover();
}
inline bool TMTServerAddress::is_recover() const {
  return is_recover_;
}
inline void TMTServerAddress::set_is_recover(bool value) {
  set_has_is_recover();
  is_recover_ = value;
}

// optional bool is_sort_fininsh = 8;
inline bool TMTServerAddress::has_is_sort_fininsh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTServerAddress::set_has_is_sort_fininsh() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTServerAddress::clear_has_is_sort_fininsh() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTServerAddress::clear_is_sort_fininsh() {
  is_sort_fininsh_ = false;
  clear_has_is_sort_fininsh();
}
inline bool TMTServerAddress::is_sort_fininsh() const {
  return is_sort_fininsh_;
}
inline void TMTServerAddress::set_is_sort_fininsh(bool value) {
  set_has_is_sort_fininsh();
  is_sort_fininsh_ = value;
}

// optional uint32 tls_port = 9;
inline bool TMTServerAddress::has_tls_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTServerAddress::set_has_tls_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTServerAddress::clear_has_tls_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTServerAddress::clear_tls_port() {
  tls_port_ = 0u;
  clear_has_tls_port();
}
inline ::google::protobuf::uint32 TMTServerAddress::tls_port() const {
  return tls_port_;
}
inline void TMTServerAddress::set_tls_port(::google::protobuf::uint32 value) {
  set_has_tls_port();
  tls_port_ = value;
}

// optional uint32 sino_tls_port = 10;
inline bool TMTServerAddress::has_sino_tls_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTServerAddress::set_has_sino_tls_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTServerAddress::clear_has_sino_tls_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTServerAddress::clear_sino_tls_port() {
  sino_tls_port_ = 0u;
  clear_has_sino_tls_port();
}
inline ::google::protobuf::uint32 TMTServerAddress::sino_tls_port() const {
  return sino_tls_port_;
}
inline void TMTServerAddress::set_sino_tls_port(::google::protobuf::uint32 value) {
  set_has_sino_tls_port();
  sino_tls_port_ = value;
}

// -------------------------------------------------------------------

// TMTSrvInfoFromAps

// optional .mt.TMTServerAddress nms = 1;
inline bool TMTSrvInfoFromAps::has_nms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_nms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTSrvInfoFromAps::clear_has_nms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTSrvInfoFromAps::clear_nms() {
  if (nms_ != NULL) nms_->::mt::TMTServerAddress::Clear();
  clear_has_nms();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::nms() const {
  return nms_ != NULL ? *nms_ : *default_instance_->nms_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_nms() {
  set_has_nms();
  if (nms_ == NULL) nms_ = new ::mt::TMTServerAddress;
  return nms_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_nms() {
  clear_has_nms();
  ::mt::TMTServerAddress* temp = nms_;
  nms_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_nms(::mt::TMTServerAddress* nms) {
  delete nms_;
  nms_ = nms;
  if (nms) {
    set_has_nms();
  } else {
    clear_has_nms();
  }
}

// optional .mt.TMTServerAddress nts = 2;
inline bool TMTSrvInfoFromAps::has_nts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_nts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTSrvInfoFromAps::clear_has_nts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTSrvInfoFromAps::clear_nts() {
  if (nts_ != NULL) nts_->::mt::TMTServerAddress::Clear();
  clear_has_nts();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::nts() const {
  return nts_ != NULL ? *nts_ : *default_instance_->nts_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_nts() {
  set_has_nts();
  if (nts_ == NULL) nts_ = new ::mt::TMTServerAddress;
  return nts_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_nts() {
  clear_has_nts();
  ::mt::TMTServerAddress* temp = nts_;
  nts_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_nts(::mt::TMTServerAddress* nts) {
  delete nts_;
  nts_ = nts;
  if (nts) {
    set_has_nts();
  } else {
    clear_has_nts();
  }
}

// optional .mt.TMTServerAddress sus = 3;
inline bool TMTSrvInfoFromAps::has_sus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_sus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTSrvInfoFromAps::clear_has_sus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTSrvInfoFromAps::clear_sus() {
  if (sus_ != NULL) sus_->::mt::TMTServerAddress::Clear();
  clear_has_sus();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::sus() const {
  return sus_ != NULL ? *sus_ : *default_instance_->sus_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_sus() {
  set_has_sus();
  if (sus_ == NULL) sus_ = new ::mt::TMTServerAddress;
  return sus_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_sus() {
  clear_has_sus();
  ::mt::TMTServerAddress* temp = sus_;
  sus_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_sus(::mt::TMTServerAddress* sus) {
  delete sus_;
  sus_ = sus;
  if (sus) {
    set_has_sus();
  } else {
    clear_has_sus();
  }
}

// optional .mt.TMTServerAddress nu = 4;
inline bool TMTSrvInfoFromAps::has_nu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_nu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTSrvInfoFromAps::clear_has_nu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTSrvInfoFromAps::clear_nu() {
  if (nu_ != NULL) nu_->::mt::TMTServerAddress::Clear();
  clear_has_nu();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::nu() const {
  return nu_ != NULL ? *nu_ : *default_instance_->nu_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_nu() {
  set_has_nu();
  if (nu_ == NULL) nu_ = new ::mt::TMTServerAddress;
  return nu_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_nu() {
  clear_has_nu();
  ::mt::TMTServerAddress* temp = nu_;
  nu_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_nu(::mt::TMTServerAddress* nu) {
  delete nu_;
  nu_ = nu;
  if (nu) {
    set_has_nu();
  } else {
    clear_has_nu();
  }
}

// optional .mt.TMTServerAddress plat_api = 5;
inline bool TMTSrvInfoFromAps::has_plat_api() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_plat_api() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTSrvInfoFromAps::clear_has_plat_api() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTSrvInfoFromAps::clear_plat_api() {
  if (plat_api_ != NULL) plat_api_->::mt::TMTServerAddress::Clear();
  clear_has_plat_api();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::plat_api() const {
  return plat_api_ != NULL ? *plat_api_ : *default_instance_->plat_api_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_plat_api() {
  set_has_plat_api();
  if (plat_api_ == NULL) plat_api_ = new ::mt::TMTServerAddress;
  return plat_api_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_plat_api() {
  clear_has_plat_api();
  ::mt::TMTServerAddress* temp = plat_api_;
  plat_api_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_plat_api(::mt::TMTServerAddress* plat_api) {
  delete plat_api_;
  plat_api_ = plat_api;
  if (plat_api) {
    set_has_plat_api();
  } else {
    clear_has_plat_api();
  }
}

// optional .mt.TMTServerAddress meeting = 6;
inline bool TMTSrvInfoFromAps::has_meeting() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_meeting() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTSrvInfoFromAps::clear_has_meeting() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTSrvInfoFromAps::clear_meeting() {
  if (meeting_ != NULL) meeting_->::mt::TMTServerAddress::Clear();
  clear_has_meeting();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::meeting() const {
  return meeting_ != NULL ? *meeting_ : *default_instance_->meeting_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_meeting() {
  set_has_meeting();
  if (meeting_ == NULL) meeting_ = new ::mt::TMTServerAddress;
  return meeting_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_meeting() {
  clear_has_meeting();
  ::mt::TMTServerAddress* temp = meeting_;
  meeting_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_meeting(::mt::TMTServerAddress* meeting) {
  delete meeting_;
  meeting_ = meeting;
  if (meeting) {
    set_has_meeting();
  } else {
    clear_has_meeting();
  }
}

// optional .mt.TMTServerAddress weibo = 7;
inline bool TMTSrvInfoFromAps::has_weibo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_weibo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTSrvInfoFromAps::clear_has_weibo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTSrvInfoFromAps::clear_weibo() {
  if (weibo_ != NULL) weibo_->::mt::TMTServerAddress::Clear();
  clear_has_weibo();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::weibo() const {
  return weibo_ != NULL ? *weibo_ : *default_instance_->weibo_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_weibo() {
  set_has_weibo();
  if (weibo_ == NULL) weibo_ = new ::mt::TMTServerAddress;
  return weibo_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_weibo() {
  clear_has_weibo();
  ::mt::TMTServerAddress* temp = weibo_;
  weibo_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_weibo(::mt::TMTServerAddress* weibo) {
  delete weibo_;
  weibo_ = weibo;
  if (weibo) {
    set_has_weibo();
  } else {
    clear_has_weibo();
  }
}

// optional .mt.TMTServerAddress xmpp = 8;
inline bool TMTSrvInfoFromAps::has_xmpp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_xmpp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTSrvInfoFromAps::clear_has_xmpp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTSrvInfoFromAps::clear_xmpp() {
  if (xmpp_ != NULL) xmpp_->::mt::TMTServerAddress::Clear();
  clear_has_xmpp();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::xmpp() const {
  return xmpp_ != NULL ? *xmpp_ : *default_instance_->xmpp_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_xmpp() {
  set_has_xmpp();
  if (xmpp_ == NULL) xmpp_ = new ::mt::TMTServerAddress;
  return xmpp_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_xmpp() {
  clear_has_xmpp();
  ::mt::TMTServerAddress* temp = xmpp_;
  xmpp_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_xmpp(::mt::TMTServerAddress* xmpp) {
  delete xmpp_;
  xmpp_ = xmpp;
  if (xmpp) {
    set_has_xmpp();
  } else {
    clear_has_xmpp();
  }
}

// optional .mt.TMTServerAddress ntp = 9;
inline bool TMTSrvInfoFromAps::has_ntp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_ntp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTSrvInfoFromAps::clear_has_ntp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTSrvInfoFromAps::clear_ntp() {
  if (ntp_ != NULL) ntp_->::mt::TMTServerAddress::Clear();
  clear_has_ntp();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::ntp() const {
  return ntp_ != NULL ? *ntp_ : *default_instance_->ntp_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_ntp() {
  set_has_ntp();
  if (ntp_ == NULL) ntp_ = new ::mt::TMTServerAddress;
  return ntp_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_ntp() {
  clear_has_ntp();
  ::mt::TMTServerAddress* temp = ntp_;
  ntp_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_ntp(::mt::TMTServerAddress* ntp) {
  delete ntp_;
  ntp_ = ntp;
  if (ntp) {
    set_has_ntp();
  } else {
    clear_has_ntp();
  }
}

// optional .mt.TMTServerAddress vrs = 10;
inline bool TMTSrvInfoFromAps::has_vrs() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_vrs() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTSrvInfoFromAps::clear_has_vrs() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTSrvInfoFromAps::clear_vrs() {
  if (vrs_ != NULL) vrs_->::mt::TMTServerAddress::Clear();
  clear_has_vrs();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::vrs() const {
  return vrs_ != NULL ? *vrs_ : *default_instance_->vrs_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_vrs() {
  set_has_vrs();
  if (vrs_ == NULL) vrs_ = new ::mt::TMTServerAddress;
  return vrs_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_vrs() {
  clear_has_vrs();
  ::mt::TMTServerAddress* temp = vrs_;
  vrs_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_vrs(::mt::TMTServerAddress* vrs) {
  delete vrs_;
  vrs_ = vrs;
  if (vrs) {
    set_has_vrs();
  } else {
    clear_has_vrs();
  }
}

// optional .mt.TMTServerAddress dcs = 11;
inline bool TMTSrvInfoFromAps::has_dcs() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_dcs() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTSrvInfoFromAps::clear_has_dcs() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTSrvInfoFromAps::clear_dcs() {
  if (dcs_ != NULL) dcs_->::mt::TMTServerAddress::Clear();
  clear_has_dcs();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::dcs() const {
  return dcs_ != NULL ? *dcs_ : *default_instance_->dcs_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_dcs() {
  set_has_dcs();
  if (dcs_ == NULL) dcs_ = new ::mt::TMTServerAddress;
  return dcs_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_dcs() {
  clear_has_dcs();
  ::mt::TMTServerAddress* temp = dcs_;
  dcs_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_dcs(::mt::TMTServerAddress* dcs) {
  delete dcs_;
  dcs_ = dcs;
  if (dcs) {
    set_has_dcs();
  } else {
    clear_has_dcs();
  }
}

// optional .mt.TMTServerAddress nonh323 = 12;
inline bool TMTSrvInfoFromAps::has_nonh323() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_nonh323() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTSrvInfoFromAps::clear_has_nonh323() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTSrvInfoFromAps::clear_nonh323() {
  if (nonh323_ != NULL) nonh323_->::mt::TMTServerAddress::Clear();
  clear_has_nonh323();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::nonh323() const {
  return nonh323_ != NULL ? *nonh323_ : *default_instance_->nonh323_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_nonh323() {
  set_has_nonh323();
  if (nonh323_ == NULL) nonh323_ = new ::mt::TMTServerAddress;
  return nonh323_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_nonh323() {
  clear_has_nonh323();
  ::mt::TMTServerAddress* temp = nonh323_;
  nonh323_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_nonh323(::mt::TMTServerAddress* nonh323) {
  delete nonh323_;
  nonh323_ = nonh323;
  if (nonh323) {
    set_has_nonh323();
  } else {
    clear_has_nonh323();
  }
}

// optional .mt.TMTServerAddress stdh323 = 13;
inline bool TMTSrvInfoFromAps::has_stdh323() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_stdh323() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTSrvInfoFromAps::clear_has_stdh323() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTSrvInfoFromAps::clear_stdh323() {
  if (stdh323_ != NULL) stdh323_->::mt::TMTServerAddress::Clear();
  clear_has_stdh323();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::stdh323() const {
  return stdh323_ != NULL ? *stdh323_ : *default_instance_->stdh323_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_stdh323() {
  set_has_stdh323();
  if (stdh323_ == NULL) stdh323_ = new ::mt::TMTServerAddress;
  return stdh323_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_stdh323() {
  clear_has_stdh323();
  ::mt::TMTServerAddress* temp = stdh323_;
  stdh323_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_stdh323(::mt::TMTServerAddress* stdh323) {
  delete stdh323_;
  stdh323_ = stdh323;
  if (stdh323) {
    set_has_stdh323();
  } else {
    clear_has_stdh323();
  }
}

// optional .mt.TMTServerAddress sip = 14;
inline bool TMTSrvInfoFromAps::has_sip() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_sip() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTSrvInfoFromAps::clear_has_sip() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTSrvInfoFromAps::clear_sip() {
  if (sip_ != NULL) sip_->::mt::TMTServerAddress::Clear();
  clear_has_sip();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::sip() const {
  return sip_ != NULL ? *sip_ : *default_instance_->sip_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_sip() {
  set_has_sip();
  if (sip_ == NULL) sip_ = new ::mt::TMTServerAddress;
  return sip_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_sip() {
  clear_has_sip();
  ::mt::TMTServerAddress* temp = sip_;
  sip_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_sip(::mt::TMTServerAddress* sip) {
  delete sip_;
  sip_ = sip;
  if (sip) {
    set_has_sip();
  } else {
    clear_has_sip();
  }
}

// repeated .mt.TMTServerAddress aps_list = 15;
inline int TMTSrvInfoFromAps::aps_list_size() const {
  return aps_list_.size();
}
inline void TMTSrvInfoFromAps::clear_aps_list() {
  aps_list_.Clear();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::aps_list(int index) const {
  return aps_list_.Get(index);
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_aps_list(int index) {
  return aps_list_.Mutable(index);
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::add_aps_list() {
  return aps_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTServerAddress >&
TMTSrvInfoFromAps::aps_list() const {
  return aps_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTServerAddress >*
TMTSrvInfoFromAps::mutable_aps_list() {
  return &aps_list_;
}

// optional .mt.TMTServerAddress ns = 16;
inline bool TMTSrvInfoFromAps::has_ns() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTSrvInfoFromAps::set_has_ns() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTSrvInfoFromAps::clear_has_ns() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTSrvInfoFromAps::clear_ns() {
  if (ns_ != NULL) ns_->::mt::TMTServerAddress::Clear();
  clear_has_ns();
}
inline const ::mt::TMTServerAddress& TMTSrvInfoFromAps::ns() const {
  return ns_ != NULL ? *ns_ : *default_instance_->ns_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::mutable_ns() {
  set_has_ns();
  if (ns_ == NULL) ns_ = new ::mt::TMTServerAddress;
  return ns_;
}
inline ::mt::TMTServerAddress* TMTSrvInfoFromAps::release_ns() {
  clear_has_ns();
  ::mt::TMTServerAddress* temp = ns_;
  ns_ = NULL;
  return temp;
}
inline void TMTSrvInfoFromAps::set_allocated_ns(::mt::TMTServerAddress* ns) {
  delete ns_;
  ns_ = ns;
  if (ns) {
    set_has_ns();
  } else {
    clear_has_ns();
  }
}

// -------------------------------------------------------------------

// TMtAPSSvr

// optional .mt.EmServerAddrType addr_type = 1;
inline bool TMtAPSSvr::has_addr_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAPSSvr::set_has_addr_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAPSSvr::clear_has_addr_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAPSSvr::clear_addr_type() {
  addr_type_ = 0;
  clear_has_addr_type();
}
inline ::mt::EmServerAddrType TMtAPSSvr::addr_type() const {
  return static_cast< ::mt::EmServerAddrType >(addr_type_);
}
inline void TMtAPSSvr::set_addr_type(::mt::EmServerAddrType value) {
  assert(::mt::EmServerAddrType_IsValid(value));
  set_has_addr_type();
  addr_type_ = value;
}

// optional string Domain = 2;
inline bool TMtAPSSvr::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAPSSvr::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAPSSvr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAPSSvr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtAPSSvr::domain() const {
  return *domain_;
}
inline void TMtAPSSvr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtAPSSvr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtAPSSvr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtAPSSvr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtAPSSvr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtAPSSvr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 aps_login_ip = 3;
inline bool TMtAPSSvr::has_aps_login_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtAPSSvr::set_has_aps_login_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtAPSSvr::clear_has_aps_login_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtAPSSvr::clear_aps_login_ip() {
  aps_login_ip_ = 0u;
  clear_has_aps_login_ip();
}
inline ::google::protobuf::uint32 TMtAPSSvr::aps_login_ip() const {
  return aps_login_ip_;
}
inline void TMtAPSSvr::set_aps_login_ip(::google::protobuf::uint32 value) {
  set_has_aps_login_ip();
  aps_login_ip_ = value;
}

// optional string addr_alias = 4;
inline bool TMtAPSSvr::has_addr_alias() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtAPSSvr::set_has_addr_alias() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtAPSSvr::clear_has_addr_alias() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtAPSSvr::clear_addr_alias() {
  if (addr_alias_ != &::google::protobuf::internal::kEmptyString) {
    addr_alias_->clear();
  }
  clear_has_addr_alias();
}
inline const ::std::string& TMtAPSSvr::addr_alias() const {
  return *addr_alias_;
}
inline void TMtAPSSvr::set_addr_alias(const ::std::string& value) {
  set_has_addr_alias();
  if (addr_alias_ == &::google::protobuf::internal::kEmptyString) {
    addr_alias_ = new ::std::string;
  }
  addr_alias_->assign(value);
}
inline void TMtAPSSvr::set_addr_alias(const char* value) {
  set_has_addr_alias();
  if (addr_alias_ == &::google::protobuf::internal::kEmptyString) {
    addr_alias_ = new ::std::string;
  }
  addr_alias_->assign(value);
}
inline void TMtAPSSvr::set_addr_alias(const char* value, size_t size) {
  set_has_addr_alias();
  if (addr_alias_ == &::google::protobuf::internal::kEmptyString) {
    addr_alias_ = new ::std::string;
  }
  addr_alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtAPSSvr::mutable_addr_alias() {
  set_has_addr_alias();
  if (addr_alias_ == &::google::protobuf::internal::kEmptyString) {
    addr_alias_ = new ::std::string;
  }
  return addr_alias_;
}
inline ::std::string* TMtAPSSvr::release_addr_alias() {
  clear_has_addr_alias();
  if (addr_alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_alias_;
    addr_alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtAPSSvr::set_allocated_addr_alias(::std::string* addr_alias) {
  if (addr_alias_ != &::google::protobuf::internal::kEmptyString) {
    delete addr_alias_;
  }
  if (addr_alias) {
    set_has_addr_alias();
    addr_alias_ = addr_alias;
  } else {
    clear_has_addr_alias();
    addr_alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_ip_svr = 5;
inline bool TMtAPSSvr::has_is_ip_svr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtAPSSvr::set_has_is_ip_svr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtAPSSvr::clear_has_is_ip_svr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtAPSSvr::clear_is_ip_svr() {
  is_ip_svr_ = false;
  clear_has_is_ip_svr();
}
inline bool TMtAPSSvr::is_ip_svr() const {
  return is_ip_svr_;
}
inline void TMtAPSSvr::set_is_ip_svr(bool value) {
  set_has_is_ip_svr();
  is_ip_svr_ = value;
}

// optional uint32 port = 6;
inline bool TMtAPSSvr::has_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtAPSSvr::set_has_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtAPSSvr::clear_has_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtAPSSvr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtAPSSvr::port() const {
  return port_;
}
inline void TMtAPSSvr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMtAPSSvrList

// optional bool is_auto_select = 1;
inline bool TMtAPSSvrList::has_is_auto_select() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAPSSvrList::set_has_is_auto_select() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAPSSvrList::clear_has_is_auto_select() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAPSSvrList::clear_is_auto_select() {
  is_auto_select_ = false;
  clear_has_is_auto_select();
}
inline bool TMtAPSSvrList::is_auto_select() const {
  return is_auto_select_;
}
inline void TMtAPSSvrList::set_is_auto_select(bool value) {
  set_has_is_auto_select();
  is_auto_select_ = value;
}

// optional uint32 cur_index = 2;
inline bool TMtAPSSvrList::has_cur_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAPSSvrList::set_has_cur_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAPSSvrList::clear_has_cur_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAPSSvrList::clear_cur_index() {
  cur_index_ = 0u;
  clear_has_cur_index();
}
inline ::google::protobuf::uint32 TMtAPSSvrList::cur_index() const {
  return cur_index_;
}
inline void TMtAPSSvrList::set_cur_index(::google::protobuf::uint32 value) {
  set_has_cur_index();
  cur_index_ = value;
}

// repeated .mt.TMtAPSSvr srv_addr_list = 3;
inline int TMtAPSSvrList::srv_addr_list_size() const {
  return srv_addr_list_.size();
}
inline void TMtAPSSvrList::clear_srv_addr_list() {
  srv_addr_list_.Clear();
}
inline const ::mt::TMtAPSSvr& TMtAPSSvrList::srv_addr_list(int index) const {
  return srv_addr_list_.Get(index);
}
inline ::mt::TMtAPSSvr* TMtAPSSvrList::mutable_srv_addr_list(int index) {
  return srv_addr_list_.Mutable(index);
}
inline ::mt::TMtAPSSvr* TMtAPSSvrList::add_srv_addr_list() {
  return srv_addr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSSvr >&
TMtAPSSvrList::srv_addr_list() const {
  return srv_addr_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSSvr >*
TMtAPSSvrList::mutable_srv_addr_list() {
  return &srv_addr_list_;
}

// -------------------------------------------------------------------

// TMtXMPPInfo

// optional string Domain = 1;
inline bool TMtXMPPInfo::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtXMPPInfo::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtXMPPInfo::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtXMPPInfo::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtXMPPInfo::domain() const {
  return *domain_;
}
inline void TMtXMPPInfo::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtXMPPInfo::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtXMPPInfo::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtXMPPInfo::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtXMPPInfo::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtXMPPInfo::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtXMPPInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtXMPPInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtXMPPInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtXMPPInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtXMPPInfo::ip() const {
  return ip_;
}
inline void TMtXMPPInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMtXMPPInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtXMPPInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtXMPPInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtXMPPInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtXMPPInfo::port() const {
  return port_;
}
inline void TMtXMPPInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string name = 4;
inline bool TMtXMPPInfo::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtXMPPInfo::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtXMPPInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtXMPPInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMtXMPPInfo::name() const {
  return *name_;
}
inline void TMtXMPPInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMtXMPPInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMtXMPPInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtXMPPInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMtXMPPInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtXMPPInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 5;
inline bool TMtXMPPInfo::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtXMPPInfo::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtXMPPInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtXMPPInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtXMPPInfo::password() const {
  return *password_;
}
inline void TMtXMPPInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtXMPPInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtXMPPInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtXMPPInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtXMPPInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtXMPPInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtAPSSvrAddr

// optional string Domain = 1;
inline bool TMtAPSSvrAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAPSSvrAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAPSSvrAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAPSSvrAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtAPSSvrAddr::domain() const {
  return *domain_;
}
inline void TMtAPSSvrAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtAPSSvrAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtAPSSvrAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtAPSSvrAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtAPSSvrAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtAPSSvrAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 aps_login_ip = 2;
inline bool TMtAPSSvrAddr::has_aps_login_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAPSSvrAddr::set_has_aps_login_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAPSSvrAddr::clear_has_aps_login_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAPSSvrAddr::clear_aps_login_ip() {
  aps_login_ip_ = 0u;
  clear_has_aps_login_ip();
}
inline ::google::protobuf::uint32 TMtAPSSvrAddr::aps_login_ip() const {
  return aps_login_ip_;
}
inline void TMtAPSSvrAddr::set_aps_login_ip(::google::protobuf::uint32 value) {
  set_has_aps_login_ip();
  aps_login_ip_ = value;
}

// optional uint32 aps_login_port = 3;
inline bool TMtAPSSvrAddr::has_aps_login_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtAPSSvrAddr::set_has_aps_login_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtAPSSvrAddr::clear_has_aps_login_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtAPSSvrAddr::clear_aps_login_port() {
  aps_login_port_ = 0u;
  clear_has_aps_login_port();
}
inline ::google::protobuf::uint32 TMtAPSSvrAddr::aps_login_port() const {
  return aps_login_port_;
}
inline void TMtAPSSvrAddr::set_aps_login_port(::google::protobuf::uint32 value) {
  set_has_aps_login_port();
  aps_login_port_ = value;
}

// optional uint32 priority = 4;
inline bool TMtAPSSvrAddr::has_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtAPSSvrAddr::set_has_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtAPSSvrAddr::clear_has_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtAPSSvrAddr::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 TMtAPSSvrAddr::priority() const {
  return priority_;
}
inline void TMtAPSSvrAddr::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
}

// optional uint32 timeout = 5;
inline bool TMtAPSSvrAddr::has_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtAPSSvrAddr::set_has_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtAPSSvrAddr::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtAPSSvrAddr::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TMtAPSSvrAddr::timeout() const {
  return timeout_;
}
inline void TMtAPSSvrAddr::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional bool is_new_aps = 6;
inline bool TMtAPSSvrAddr::has_is_new_aps() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtAPSSvrAddr::set_has_is_new_aps() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtAPSSvrAddr::clear_has_is_new_aps() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtAPSSvrAddr::clear_is_new_aps() {
  is_new_aps_ = false;
  clear_has_is_new_aps();
}
inline bool TMtAPSSvrAddr::is_new_aps() const {
  return is_new_aps_;
}
inline void TMtAPSSvrAddr::set_is_new_aps(bool value) {
  set_has_is_new_aps();
  is_new_aps_ = value;
}

// optional bool is_recover = 7;
inline bool TMtAPSSvrAddr::has_is_recover() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtAPSSvrAddr::set_has_is_recover() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtAPSSvrAddr::clear_has_is_recover() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtAPSSvrAddr::clear_is_recover() {
  is_recover_ = false;
  clear_has_is_recover();
}
inline bool TMtAPSSvrAddr::is_recover() const {
  return is_recover_;
}
inline void TMtAPSSvrAddr::set_is_recover(bool value) {
  set_has_is_recover();
  is_recover_ = value;
}

// optional bool is_sort_fininsh = 8;
inline bool TMtAPSSvrAddr::has_is_sort_fininsh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtAPSSvrAddr::set_has_is_sort_fininsh() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtAPSSvrAddr::clear_has_is_sort_fininsh() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtAPSSvrAddr::clear_is_sort_fininsh() {
  is_sort_fininsh_ = false;
  clear_has_is_sort_fininsh();
}
inline bool TMtAPSSvrAddr::is_sort_fininsh() const {
  return is_sort_fininsh_;
}
inline void TMtAPSSvrAddr::set_is_sort_fininsh(bool value) {
  set_has_is_sort_fininsh();
  is_sort_fininsh_ = value;
}

// -------------------------------------------------------------------

// TMtAPSAddrFromSrv

// repeated .mt.TMtAPSSvrAddr srv_list = 1;
inline int TMtAPSAddrFromSrv::srv_list_size() const {
  return srv_list_.size();
}
inline void TMtAPSAddrFromSrv::clear_srv_list() {
  srv_list_.Clear();
}
inline const ::mt::TMtAPSSvrAddr& TMtAPSAddrFromSrv::srv_list(int index) const {
  return srv_list_.Get(index);
}
inline ::mt::TMtAPSSvrAddr* TMtAPSAddrFromSrv::mutable_srv_list(int index) {
  return srv_list_.Mutable(index);
}
inline ::mt::TMtAPSSvrAddr* TMtAPSAddrFromSrv::add_srv_list() {
  return srv_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSSvrAddr >&
TMtAPSAddrFromSrv::srv_list() const {
  return srv_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSSvrAddr >*
TMtAPSAddrFromSrv::mutable_srv_list() {
  return &srv_list_;
}

// -------------------------------------------------------------------

// TMtAPSAddrCfg

// optional .mt.EmPlatform platform = 1;
inline bool TMtAPSAddrCfg::has_platform() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAPSAddrCfg::set_has_platform() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAPSAddrCfg::clear_has_platform() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAPSAddrCfg::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::mt::EmPlatform TMtAPSAddrCfg::platform() const {
  return static_cast< ::mt::EmPlatform >(platform_);
}
inline void TMtAPSAddrCfg::set_platform(::mt::EmPlatform value) {
  assert(::mt::EmPlatform_IsValid(value));
  set_has_platform();
  platform_ = value;
}

// optional uint32 aps_cfg_ip = 2;
inline bool TMtAPSAddrCfg::has_aps_cfg_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAPSAddrCfg::set_has_aps_cfg_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAPSAddrCfg::clear_has_aps_cfg_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAPSAddrCfg::clear_aps_cfg_ip() {
  aps_cfg_ip_ = 0u;
  clear_has_aps_cfg_ip();
}
inline ::google::protobuf::uint32 TMtAPSAddrCfg::aps_cfg_ip() const {
  return aps_cfg_ip_;
}
inline void TMtAPSAddrCfg::set_aps_cfg_ip(::google::protobuf::uint32 value) {
  set_has_aps_cfg_ip();
  aps_cfg_ip_ = value;
}

// optional .mt.TMtAPSAddrFromSrv addrs_from_srv = 3;
inline bool TMtAPSAddrCfg::has_addrs_from_srv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtAPSAddrCfg::set_has_addrs_from_srv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtAPSAddrCfg::clear_has_addrs_from_srv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtAPSAddrCfg::clear_addrs_from_srv() {
  if (addrs_from_srv_ != NULL) addrs_from_srv_->::mt::TMtAPSAddrFromSrv::Clear();
  clear_has_addrs_from_srv();
}
inline const ::mt::TMtAPSAddrFromSrv& TMtAPSAddrCfg::addrs_from_srv() const {
  return addrs_from_srv_ != NULL ? *addrs_from_srv_ : *default_instance_->addrs_from_srv_;
}
inline ::mt::TMtAPSAddrFromSrv* TMtAPSAddrCfg::mutable_addrs_from_srv() {
  set_has_addrs_from_srv();
  if (addrs_from_srv_ == NULL) addrs_from_srv_ = new ::mt::TMtAPSAddrFromSrv;
  return addrs_from_srv_;
}
inline ::mt::TMtAPSAddrFromSrv* TMtAPSAddrCfg::release_addrs_from_srv() {
  clear_has_addrs_from_srv();
  ::mt::TMtAPSAddrFromSrv* temp = addrs_from_srv_;
  addrs_from_srv_ = NULL;
  return temp;
}
inline void TMtAPSAddrCfg::set_allocated_addrs_from_srv(::mt::TMtAPSAddrFromSrv* addrs_from_srv) {
  delete addrs_from_srv_;
  addrs_from_srv_ = addrs_from_srv;
  if (addrs_from_srv) {
    set_has_addrs_from_srv();
  } else {
    clear_has_addrs_from_srv();
  }
}

// -------------------------------------------------------------------

// TMtAPSAddrCfgs

// repeated .mt.TMtAPSAddrCfg cfg_svr_list = 1;
inline int TMtAPSAddrCfgs::cfg_svr_list_size() const {
  return cfg_svr_list_.size();
}
inline void TMtAPSAddrCfgs::clear_cfg_svr_list() {
  cfg_svr_list_.Clear();
}
inline const ::mt::TMtAPSAddrCfg& TMtAPSAddrCfgs::cfg_svr_list(int index) const {
  return cfg_svr_list_.Get(index);
}
inline ::mt::TMtAPSAddrCfg* TMtAPSAddrCfgs::mutable_cfg_svr_list(int index) {
  return cfg_svr_list_.Mutable(index);
}
inline ::mt::TMtAPSAddrCfg* TMtAPSAddrCfgs::add_cfg_svr_list() {
  return cfg_svr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSAddrCfg >&
TMtAPSAddrCfgs::cfg_svr_list() const {
  return cfg_svr_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAPSAddrCfg >*
TMtAPSAddrCfgs::mutable_cfg_svr_list() {
  return &cfg_svr_list_;
}

// -------------------------------------------------------------------

// TMtCSUAddr

// optional bool is_enable = 1;
inline bool TMtCSUAddr::has_is_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtCSUAddr::set_has_is_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtCSUAddr::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtCSUAddr::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMtCSUAddr::is_enable() const {
  return is_enable_;
}
inline void TMtCSUAddr::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// optional string domain = 2;
inline bool TMtCSUAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtCSUAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtCSUAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtCSUAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtCSUAddr::domain() const {
  return *domain_;
}
inline void TMtCSUAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtCSUAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtCSUAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCSUAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtCSUAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCSUAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 3;
inline bool TMtCSUAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtCSUAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtCSUAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtCSUAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtCSUAddr::ip() const {
  return ip_;
}
inline void TMtCSUAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 4;
inline bool TMtCSUAddr::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtCSUAddr::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtCSUAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtCSUAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtCSUAddr::port() const {
  return port_;
}
inline void TMtCSUAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string password = 5;
inline bool TMtCSUAddr::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtCSUAddr::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtCSUAddr::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtCSUAddr::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtCSUAddr::password() const {
  return *password_;
}
inline void TMtCSUAddr::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtCSUAddr::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtCSUAddr::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCSUAddr::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtCSUAddr::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCSUAddr::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string number = 6;
inline bool TMtCSUAddr::has_number() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtCSUAddr::set_has_number() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtCSUAddr::clear_has_number() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtCSUAddr::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& TMtCSUAddr::number() const {
  return *number_;
}
inline void TMtCSUAddr::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TMtCSUAddr::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TMtCSUAddr::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCSUAddr::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* TMtCSUAddr::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCSUAddr::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 timetolive = 7;
inline bool TMtCSUAddr::has_timetolive() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtCSUAddr::set_has_timetolive() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtCSUAddr::clear_has_timetolive() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtCSUAddr::clear_timetolive() {
  timetolive_ = 0u;
  clear_has_timetolive();
}
inline ::google::protobuf::uint32 TMtCSUAddr::timetolive() const {
  return timetolive_;
}
inline void TMtCSUAddr::set_timetolive(::google::protobuf::uint32 value) {
  set_has_timetolive();
  timetolive_ = value;
}

// optional string auth_name = 8;
inline bool TMtCSUAddr::has_auth_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtCSUAddr::set_has_auth_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtCSUAddr::clear_has_auth_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtCSUAddr::clear_auth_name() {
  if (auth_name_ != &::google::protobuf::internal::kEmptyString) {
    auth_name_->clear();
  }
  clear_has_auth_name();
}
inline const ::std::string& TMtCSUAddr::auth_name() const {
  return *auth_name_;
}
inline void TMtCSUAddr::set_auth_name(const ::std::string& value) {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  auth_name_->assign(value);
}
inline void TMtCSUAddr::set_auth_name(const char* value) {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  auth_name_->assign(value);
}
inline void TMtCSUAddr::set_auth_name(const char* value, size_t size) {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  auth_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCSUAddr::mutable_auth_name() {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  return auth_name_;
}
inline ::std::string* TMtCSUAddr::release_auth_name() {
  clear_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_name_;
    auth_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCSUAddr::set_allocated_auth_name(::std::string* auth_name) {
  if (auth_name_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_name_;
  }
  if (auth_name) {
    set_has_auth_name();
    auth_name_ = auth_name;
  } else {
    clear_has_auth_name();
    auth_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtNMSAddr

// optional string domain = 1;
inline bool TMtNMSAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtNMSAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtNMSAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtNMSAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtNMSAddr::domain() const {
  return *domain_;
}
inline void TMtNMSAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtNMSAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtNMSAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtNMSAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtNMSAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtNMSAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtNMSAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtNMSAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtNMSAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtNMSAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtNMSAddr::ip() const {
  return ip_;
}
inline void TMtNMSAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMtNMSAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtNMSAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtNMSAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtNMSAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtNMSAddr::port() const {
  return port_;
}
inline void TMtNMSAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TNMSClientHWInfo

// optional string os = 1;
inline bool TNMSClientHWInfo::has_os() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNMSClientHWInfo::set_has_os() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNMSClientHWInfo::clear_has_os() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNMSClientHWInfo::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& TNMSClientHWInfo::os() const {
  return *os_;
}
inline void TNMSClientHWInfo::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void TNMSClientHWInfo::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void TNMSClientHWInfo::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNMSClientHWInfo::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* TNMSClientHWInfo::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNMSClientHWInfo::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cpu_type = 2;
inline bool TNMSClientHWInfo::has_cpu_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNMSClientHWInfo::set_has_cpu_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNMSClientHWInfo::clear_has_cpu_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNMSClientHWInfo::clear_cpu_type() {
  if (cpu_type_ != &::google::protobuf::internal::kEmptyString) {
    cpu_type_->clear();
  }
  clear_has_cpu_type();
}
inline const ::std::string& TNMSClientHWInfo::cpu_type() const {
  return *cpu_type_;
}
inline void TNMSClientHWInfo::set_cpu_type(const ::std::string& value) {
  set_has_cpu_type();
  if (cpu_type_ == &::google::protobuf::internal::kEmptyString) {
    cpu_type_ = new ::std::string;
  }
  cpu_type_->assign(value);
}
inline void TNMSClientHWInfo::set_cpu_type(const char* value) {
  set_has_cpu_type();
  if (cpu_type_ == &::google::protobuf::internal::kEmptyString) {
    cpu_type_ = new ::std::string;
  }
  cpu_type_->assign(value);
}
inline void TNMSClientHWInfo::set_cpu_type(const char* value, size_t size) {
  set_has_cpu_type();
  if (cpu_type_ == &::google::protobuf::internal::kEmptyString) {
    cpu_type_ = new ::std::string;
  }
  cpu_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNMSClientHWInfo::mutable_cpu_type() {
  set_has_cpu_type();
  if (cpu_type_ == &::google::protobuf::internal::kEmptyString) {
    cpu_type_ = new ::std::string;
  }
  return cpu_type_;
}
inline ::std::string* TNMSClientHWInfo::release_cpu_type() {
  clear_has_cpu_type();
  if (cpu_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpu_type_;
    cpu_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNMSClientHWInfo::set_allocated_cpu_type(::std::string* cpu_type) {
  if (cpu_type_ != &::google::protobuf::internal::kEmptyString) {
    delete cpu_type_;
  }
  if (cpu_type) {
    set_has_cpu_type();
    cpu_type_ = cpu_type;
  } else {
    clear_has_cpu_type();
    cpu_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 cpu_freq = 3;
inline bool TNMSClientHWInfo::has_cpu_freq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNMSClientHWInfo::set_has_cpu_freq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNMSClientHWInfo::clear_has_cpu_freq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNMSClientHWInfo::clear_cpu_freq() {
  cpu_freq_ = 0u;
  clear_has_cpu_freq();
}
inline ::google::protobuf::uint32 TNMSClientHWInfo::cpu_freq() const {
  return cpu_freq_;
}
inline void TNMSClientHWInfo::set_cpu_freq(::google::protobuf::uint32 value) {
  set_has_cpu_freq();
  cpu_freq_ = value;
}

// optional uint32 memory = 4;
inline bool TNMSClientHWInfo::has_memory() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNMSClientHWInfo::set_has_memory() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNMSClientHWInfo::clear_has_memory() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNMSClientHWInfo::clear_memory() {
  memory_ = 0u;
  clear_has_memory();
}
inline ::google::protobuf::uint32 TNMSClientHWInfo::memory() const {
  return memory_;
}
inline void TNMSClientHWInfo::set_memory(::google::protobuf::uint32 value) {
  set_has_memory();
  memory_ = value;
}

// optional uint32 cpu_num = 5;
inline bool TNMSClientHWInfo::has_cpu_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNMSClientHWInfo::set_has_cpu_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNMSClientHWInfo::clear_has_cpu_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNMSClientHWInfo::clear_cpu_num() {
  cpu_num_ = 0u;
  clear_has_cpu_num();
}
inline ::google::protobuf::uint32 TNMSClientHWInfo::cpu_num() const {
  return cpu_num_;
}
inline void TNMSClientHWInfo::set_cpu_num(::google::protobuf::uint32 value) {
  set_has_cpu_num();
  cpu_num_ = value;
}

// -------------------------------------------------------------------

// TMtH323Cfg

// optional bool EnableH239 = 1;
inline bool TMtH323Cfg::has_enableh239() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtH323Cfg::set_has_enableh239() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtH323Cfg::clear_has_enableh239() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtH323Cfg::clear_enableh239() {
  enableh239_ = false;
  clear_has_enableh239();
}
inline bool TMtH323Cfg::enableh239() const {
  return enableh239_;
}
inline void TMtH323Cfg::set_enableh239(bool value) {
  set_has_enableh239();
  enableh239_ = value;
}

// optional uint32 call_priority = 2;
inline bool TMtH323Cfg::has_call_priority() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtH323Cfg::set_has_call_priority() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtH323Cfg::clear_has_call_priority() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtH323Cfg::clear_call_priority() {
  call_priority_ = 0u;
  clear_has_call_priority();
}
inline ::google::protobuf::uint32 TMtH323Cfg::call_priority() const {
  return call_priority_;
}
inline void TMtH323Cfg::set_call_priority(::google::protobuf::uint32 value) {
  set_has_call_priority();
  call_priority_ = value;
}

// -------------------------------------------------------------------

// TMtNTSAddr

// optional string Domain = 1;
inline bool TMtNTSAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtNTSAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtNTSAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtNTSAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtNTSAddr::domain() const {
  return *domain_;
}
inline void TMtNTSAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtNTSAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtNTSAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtNTSAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtNTSAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtNTSAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtNTSAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtNTSAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtNTSAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtNTSAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtNTSAddr::ip() const {
  return ip_;
}
inline void TMtNTSAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMtNTSAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtNTSAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtNTSAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtNTSAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtNTSAddr::port() const {
  return port_;
}
inline void TMtNTSAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMtSUSAddr

// optional string Domain = 1;
inline bool TMtSUSAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSUSAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSUSAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSUSAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtSUSAddr::domain() const {
  return *domain_;
}
inline void TMtSUSAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtSUSAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtSUSAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSUSAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtSUSAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSUSAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtSUSAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSUSAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSUSAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSUSAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtSUSAddr::ip() const {
  return ip_;
}
inline void TMtSUSAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMtSUSAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtSUSAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtSUSAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtSUSAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtSUSAddr::port() const {
  return port_;
}
inline void TMtSUSAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional bool use_default_addr = 4;
inline bool TMtSUSAddr::has_use_default_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtSUSAddr::set_has_use_default_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtSUSAddr::clear_has_use_default_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtSUSAddr::clear_use_default_addr() {
  use_default_addr_ = false;
  clear_has_use_default_addr();
}
inline bool TMtSUSAddr::use_default_addr() const {
  return use_default_addr_;
}
inline void TMtSUSAddr::set_use_default_addr(bool value) {
  set_has_use_default_addr();
  use_default_addr_ = value;
}

// optional string custom_domain = 5;
inline bool TMtSUSAddr::has_custom_domain() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtSUSAddr::set_has_custom_domain() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtSUSAddr::clear_has_custom_domain() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtSUSAddr::clear_custom_domain() {
  if (custom_domain_ != &::google::protobuf::internal::kEmptyString) {
    custom_domain_->clear();
  }
  clear_has_custom_domain();
}
inline const ::std::string& TMtSUSAddr::custom_domain() const {
  return *custom_domain_;
}
inline void TMtSUSAddr::set_custom_domain(const ::std::string& value) {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  custom_domain_->assign(value);
}
inline void TMtSUSAddr::set_custom_domain(const char* value) {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  custom_domain_->assign(value);
}
inline void TMtSUSAddr::set_custom_domain(const char* value, size_t size) {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  custom_domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSUSAddr::mutable_custom_domain() {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  return custom_domain_;
}
inline ::std::string* TMtSUSAddr::release_custom_domain() {
  clear_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custom_domain_;
    custom_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSUSAddr::set_allocated_custom_domain(::std::string* custom_domain) {
  if (custom_domain_ != &::google::protobuf::internal::kEmptyString) {
    delete custom_domain_;
  }
  if (custom_domain) {
    set_has_custom_domain();
    custom_domain_ = custom_domain;
  } else {
    clear_has_custom_domain();
    custom_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 custom_ip = 6;
inline bool TMtSUSAddr::has_custom_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtSUSAddr::set_has_custom_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtSUSAddr::clear_has_custom_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtSUSAddr::clear_custom_ip() {
  custom_ip_ = 0u;
  clear_has_custom_ip();
}
inline ::google::protobuf::uint32 TMtSUSAddr::custom_ip() const {
  return custom_ip_;
}
inline void TMtSUSAddr::set_custom_ip(::google::protobuf::uint32 value) {
  set_has_custom_ip();
  custom_ip_ = value;
}

// -------------------------------------------------------------------

// TMTUpgradeNetParam

// optional uint32 server_ip = 1;
inline bool TMTUpgradeNetParam::has_server_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUpgradeNetParam::set_has_server_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUpgradeNetParam::clear_has_server_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUpgradeNetParam::clear_server_ip() {
  server_ip_ = 0u;
  clear_has_server_ip();
}
inline ::google::protobuf::uint32 TMTUpgradeNetParam::server_ip() const {
  return server_ip_;
}
inline void TMTUpgradeNetParam::set_server_ip(::google::protobuf::uint32 value) {
  set_has_server_ip();
  server_ip_ = value;
}

// optional uint32 port = 2;
inline bool TMTUpgradeNetParam::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUpgradeNetParam::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUpgradeNetParam::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUpgradeNetParam::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMTUpgradeNetParam::port() const {
  return port_;
}
inline void TMTUpgradeNetParam::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional bool is_proxy_used = 3;
inline bool TMTUpgradeNetParam::has_is_proxy_used() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTUpgradeNetParam::set_has_is_proxy_used() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTUpgradeNetParam::clear_has_is_proxy_used() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTUpgradeNetParam::clear_is_proxy_used() {
  is_proxy_used_ = false;
  clear_has_is_proxy_used();
}
inline bool TMTUpgradeNetParam::is_proxy_used() const {
  return is_proxy_used_;
}
inline void TMTUpgradeNetParam::set_is_proxy_used(bool value) {
  set_has_is_proxy_used();
  is_proxy_used_ = value;
}

// optional .mt.TMTOspSock5Proxy proxy_info = 4;
inline bool TMTUpgradeNetParam::has_proxy_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTUpgradeNetParam::set_has_proxy_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTUpgradeNetParam::clear_has_proxy_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTUpgradeNetParam::clear_proxy_info() {
  if (proxy_info_ != NULL) proxy_info_->::mt::TMTOspSock5Proxy::Clear();
  clear_has_proxy_info();
}
inline const ::mt::TMTOspSock5Proxy& TMTUpgradeNetParam::proxy_info() const {
  return proxy_info_ != NULL ? *proxy_info_ : *default_instance_->proxy_info_;
}
inline ::mt::TMTOspSock5Proxy* TMTUpgradeNetParam::mutable_proxy_info() {
  set_has_proxy_info();
  if (proxy_info_ == NULL) proxy_info_ = new ::mt::TMTOspSock5Proxy;
  return proxy_info_;
}
inline ::mt::TMTOspSock5Proxy* TMTUpgradeNetParam::release_proxy_info() {
  clear_has_proxy_info();
  ::mt::TMTOspSock5Proxy* temp = proxy_info_;
  proxy_info_ = NULL;
  return temp;
}
inline void TMTUpgradeNetParam::set_allocated_proxy_info(::mt::TMTOspSock5Proxy* proxy_info) {
  delete proxy_info_;
  proxy_info_ = proxy_info;
  if (proxy_info) {
    set_has_proxy_info();
  } else {
    clear_has_proxy_info();
  }
}

// optional string domain = 5;
inline bool TMTUpgradeNetParam::has_domain() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTUpgradeNetParam::set_has_domain() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTUpgradeNetParam::clear_has_domain() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTUpgradeNetParam::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMTUpgradeNetParam::domain() const {
  return *domain_;
}
inline void TMTUpgradeNetParam::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMTUpgradeNetParam::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMTUpgradeNetParam::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeNetParam::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMTUpgradeNetParam::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeNetParam::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtNTPAddr

// optional string Domain = 1;
inline bool TMtNTPAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtNTPAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtNTPAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtNTPAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtNTPAddr::domain() const {
  return *domain_;
}
inline void TMtNTPAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtNTPAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtNTPAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtNTPAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtNTPAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtNTPAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtNTPAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtNTPAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtNTPAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtNTPAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtNTPAddr::ip() const {
  return ip_;
}
inline void TMtNTPAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMtNTPAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtNTPAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtNTPAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtNTPAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtNTPAddr::port() const {
  return port_;
}
inline void TMtNTPAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMtPlatformApiAddr

// optional string Domain = 1;
inline bool TMtPlatformApiAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtPlatformApiAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtPlatformApiAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtPlatformApiAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtPlatformApiAddr::domain() const {
  return *domain_;
}
inline void TMtPlatformApiAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtPlatformApiAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtPlatformApiAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtPlatformApiAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtPlatformApiAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtPlatformApiAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtPlatformApiAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtPlatformApiAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtPlatformApiAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtPlatformApiAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtPlatformApiAddr::ip() const {
  return ip_;
}
inline void TMtPlatformApiAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMtPlatformApiAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtPlatformApiAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtPlatformApiAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtPlatformApiAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtPlatformApiAddr::port() const {
  return port_;
}
inline void TMtPlatformApiAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMtPlatformWeiboAddr

// optional string Domain = 1;
inline bool TMtPlatformWeiboAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtPlatformWeiboAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtPlatformWeiboAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtPlatformWeiboAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtPlatformWeiboAddr::domain() const {
  return *domain_;
}
inline void TMtPlatformWeiboAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtPlatformWeiboAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtPlatformWeiboAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtPlatformWeiboAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtPlatformWeiboAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtPlatformWeiboAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtPlatformWeiboAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtPlatformWeiboAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtPlatformWeiboAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtPlatformWeiboAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtPlatformWeiboAddr::ip() const {
  return ip_;
}
inline void TMtPlatformWeiboAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMtPlatformWeiboAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtPlatformWeiboAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtPlatformWeiboAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtPlatformWeiboAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtPlatformWeiboAddr::port() const {
  return port_;
}
inline void TMtPlatformWeiboAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMtStreamSvrAddr

// optional string Domain = 1;
inline bool TMtStreamSvrAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtStreamSvrAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtStreamSvrAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtStreamSvrAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtStreamSvrAddr::domain() const {
  return *domain_;
}
inline void TMtStreamSvrAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtStreamSvrAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtStreamSvrAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtStreamSvrAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtStreamSvrAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtStreamSvrAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtStreamSvrAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtStreamSvrAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtStreamSvrAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtStreamSvrAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtStreamSvrAddr::ip() const {
  return ip_;
}
inline void TMtStreamSvrAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMtStreamSvrAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtStreamSvrAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtStreamSvrAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtStreamSvrAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtStreamSvrAddr::port() const {
  return port_;
}
inline void TMtStreamSvrAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMtVODSvrCfg

// optional bool is_enable = 1;
inline bool TMtVODSvrCfg::has_is_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtVODSvrCfg::set_has_is_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtVODSvrCfg::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtVODSvrCfg::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMtVODSvrCfg::is_enable() const {
  return is_enable_;
}
inline void TMtVODSvrCfg::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// optional string Domain = 2;
inline bool TMtVODSvrCfg::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtVODSvrCfg::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtVODSvrCfg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtVODSvrCfg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtVODSvrCfg::domain() const {
  return *domain_;
}
inline void TMtVODSvrCfg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtVODSvrCfg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtVODSvrCfg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVODSvrCfg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtVODSvrCfg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVODSvrCfg::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 3;
inline bool TMtVODSvrCfg::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtVODSvrCfg::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtVODSvrCfg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtVODSvrCfg::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtVODSvrCfg::ip() const {
  return ip_;
}
inline void TMtVODSvrCfg::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 4;
inline bool TMtVODSvrCfg::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtVODSvrCfg::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtVODSvrCfg::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtVODSvrCfg::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtVODSvrCfg::port() const {
  return port_;
}
inline void TMtVODSvrCfg::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string username = 5;
inline bool TMtVODSvrCfg::has_username() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtVODSvrCfg::set_has_username() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtVODSvrCfg::clear_has_username() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtVODSvrCfg::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMtVODSvrCfg::username() const {
  return *username_;
}
inline void TMtVODSvrCfg::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMtVODSvrCfg::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMtVODSvrCfg::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVODSvrCfg::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMtVODSvrCfg::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVODSvrCfg::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 6;
inline bool TMtVODSvrCfg::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtVODSvrCfg::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtVODSvrCfg::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtVODSvrCfg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtVODSvrCfg::password() const {
  return *password_;
}
inline void TMtVODSvrCfg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtVODSvrCfg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtVODSvrCfg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVODSvrCfg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtVODSvrCfg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVODSvrCfg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtVRSSvrCfg

// optional bool is_enable = 1;
inline bool TMtVRSSvrCfg::has_is_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtVRSSvrCfg::set_has_is_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtVRSSvrCfg::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtVRSSvrCfg::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMtVRSSvrCfg::is_enable() const {
  return is_enable_;
}
inline void TMtVRSSvrCfg::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// optional bool is_custom = 2;
inline bool TMtVRSSvrCfg::has_is_custom() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtVRSSvrCfg::set_has_is_custom() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtVRSSvrCfg::clear_has_is_custom() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtVRSSvrCfg::clear_is_custom() {
  is_custom_ = false;
  clear_has_is_custom();
}
inline bool TMtVRSSvrCfg::is_custom() const {
  return is_custom_;
}
inline void TMtVRSSvrCfg::set_is_custom(bool value) {
  set_has_is_custom();
  is_custom_ = value;
}

// optional string Domain = 3;
inline bool TMtVRSSvrCfg::has_domain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtVRSSvrCfg::set_has_domain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtVRSSvrCfg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtVRSSvrCfg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtVRSSvrCfg::domain() const {
  return *domain_;
}
inline void TMtVRSSvrCfg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtVRSSvrCfg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtVRSSvrCfg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVRSSvrCfg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtVRSSvrCfg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVRSSvrCfg::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 4;
inline bool TMtVRSSvrCfg::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtVRSSvrCfg::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtVRSSvrCfg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtVRSSvrCfg::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtVRSSvrCfg::ip() const {
  return ip_;
}
inline void TMtVRSSvrCfg::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 5;
inline bool TMtVRSSvrCfg::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtVRSSvrCfg::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtVRSSvrCfg::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtVRSSvrCfg::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtVRSSvrCfg::port() const {
  return port_;
}
inline void TMtVRSSvrCfg::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string custom_addr = 6;
inline bool TMtVRSSvrCfg::has_custom_addr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtVRSSvrCfg::set_has_custom_addr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtVRSSvrCfg::clear_has_custom_addr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtVRSSvrCfg::clear_custom_addr() {
  if (custom_addr_ != &::google::protobuf::internal::kEmptyString) {
    custom_addr_->clear();
  }
  clear_has_custom_addr();
}
inline const ::std::string& TMtVRSSvrCfg::custom_addr() const {
  return *custom_addr_;
}
inline void TMtVRSSvrCfg::set_custom_addr(const ::std::string& value) {
  set_has_custom_addr();
  if (custom_addr_ == &::google::protobuf::internal::kEmptyString) {
    custom_addr_ = new ::std::string;
  }
  custom_addr_->assign(value);
}
inline void TMtVRSSvrCfg::set_custom_addr(const char* value) {
  set_has_custom_addr();
  if (custom_addr_ == &::google::protobuf::internal::kEmptyString) {
    custom_addr_ = new ::std::string;
  }
  custom_addr_->assign(value);
}
inline void TMtVRSSvrCfg::set_custom_addr(const char* value, size_t size) {
  set_has_custom_addr();
  if (custom_addr_ == &::google::protobuf::internal::kEmptyString) {
    custom_addr_ = new ::std::string;
  }
  custom_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVRSSvrCfg::mutable_custom_addr() {
  set_has_custom_addr();
  if (custom_addr_ == &::google::protobuf::internal::kEmptyString) {
    custom_addr_ = new ::std::string;
  }
  return custom_addr_;
}
inline ::std::string* TMtVRSSvrCfg::release_custom_addr() {
  clear_has_custom_addr();
  if (custom_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custom_addr_;
    custom_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVRSSvrCfg::set_allocated_custom_addr(::std::string* custom_addr) {
  if (custom_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete custom_addr_;
  }
  if (custom_addr) {
    set_has_custom_addr();
    custom_addr_ = custom_addr;
  } else {
    clear_has_custom_addr();
    custom_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string username = 7;
inline bool TMtVRSSvrCfg::has_username() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtVRSSvrCfg::set_has_username() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtVRSSvrCfg::clear_has_username() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtVRSSvrCfg::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMtVRSSvrCfg::username() const {
  return *username_;
}
inline void TMtVRSSvrCfg::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMtVRSSvrCfg::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMtVRSSvrCfg::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVRSSvrCfg::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMtVRSSvrCfg::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVRSSvrCfg::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 8;
inline bool TMtVRSSvrCfg::has_password() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtVRSSvrCfg::set_has_password() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtVRSSvrCfg::clear_has_password() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtVRSSvrCfg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtVRSSvrCfg::password() const {
  return *password_;
}
inline void TMtVRSSvrCfg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtVRSSvrCfg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtVRSSvrCfg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVRSSvrCfg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtVRSSvrCfg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVRSSvrCfg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtDCSSvrAddr

// optional string Domain = 1;
inline bool TMtDCSSvrAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtDCSSvrAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtDCSSvrAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtDCSSvrAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtDCSSvrAddr::domain() const {
  return *domain_;
}
inline void TMtDCSSvrAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtDCSSvrAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtDCSSvrAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtDCSSvrAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtDCSSvrAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtDCSSvrAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtDCSSvrAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtDCSSvrAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtDCSSvrAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtDCSSvrAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtDCSSvrAddr::ip() const {
  return ip_;
}
inline void TMtDCSSvrAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMtDCSSvrAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtDCSSvrAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtDCSSvrAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtDCSSvrAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtDCSSvrAddr::port() const {
  return port_;
}
inline void TMtDCSSvrAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional bool use_default_addr = 4;
inline bool TMtDCSSvrAddr::has_use_default_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtDCSSvrAddr::set_has_use_default_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtDCSSvrAddr::clear_has_use_default_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtDCSSvrAddr::clear_use_default_addr() {
  use_default_addr_ = false;
  clear_has_use_default_addr();
}
inline bool TMtDCSSvrAddr::use_default_addr() const {
  return use_default_addr_;
}
inline void TMtDCSSvrAddr::set_use_default_addr(bool value) {
  set_has_use_default_addr();
  use_default_addr_ = value;
}

// optional string custom_domain = 5;
inline bool TMtDCSSvrAddr::has_custom_domain() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtDCSSvrAddr::set_has_custom_domain() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtDCSSvrAddr::clear_has_custom_domain() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtDCSSvrAddr::clear_custom_domain() {
  if (custom_domain_ != &::google::protobuf::internal::kEmptyString) {
    custom_domain_->clear();
  }
  clear_has_custom_domain();
}
inline const ::std::string& TMtDCSSvrAddr::custom_domain() const {
  return *custom_domain_;
}
inline void TMtDCSSvrAddr::set_custom_domain(const ::std::string& value) {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  custom_domain_->assign(value);
}
inline void TMtDCSSvrAddr::set_custom_domain(const char* value) {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  custom_domain_->assign(value);
}
inline void TMtDCSSvrAddr::set_custom_domain(const char* value, size_t size) {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  custom_domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtDCSSvrAddr::mutable_custom_domain() {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  return custom_domain_;
}
inline ::std::string* TMtDCSSvrAddr::release_custom_domain() {
  clear_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custom_domain_;
    custom_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtDCSSvrAddr::set_allocated_custom_domain(::std::string* custom_domain) {
  if (custom_domain_ != &::google::protobuf::internal::kEmptyString) {
    delete custom_domain_;
  }
  if (custom_domain) {
    set_has_custom_domain();
    custom_domain_ = custom_domain;
  } else {
    clear_has_custom_domain();
    custom_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 custom_ip = 6;
inline bool TMtDCSSvrAddr::has_custom_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtDCSSvrAddr::set_has_custom_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtDCSSvrAddr::clear_has_custom_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtDCSSvrAddr::clear_custom_ip() {
  custom_ip_ = 0u;
  clear_has_custom_ip();
}
inline ::google::protobuf::uint32 TMtDCSSvrAddr::custom_ip() const {
  return custom_ip_;
}
inline void TMtDCSSvrAddr::set_custom_ip(::google::protobuf::uint32 value) {
  set_has_custom_ip();
  custom_ip_ = value;
}

// -------------------------------------------------------------------

// TMtNSAddr

// optional string Domain = 1;
inline bool TMtNSAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtNSAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtNSAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtNSAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtNSAddr::domain() const {
  return *domain_;
}
inline void TMtNSAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtNSAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtNSAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtNSAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtNSAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtNSAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtNSAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtNSAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtNSAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtNSAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtNSAddr::ip() const {
  return ip_;
}
inline void TMtNSAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMtNSAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtNSAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtNSAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtNSAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtNSAddr::port() const {
  return port_;
}
inline void TMtNSAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional uint32 tls_port = 4;
inline bool TMtNSAddr::has_tls_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtNSAddr::set_has_tls_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtNSAddr::clear_has_tls_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtNSAddr::clear_tls_port() {
  tls_port_ = 0u;
  clear_has_tls_port();
}
inline ::google::protobuf::uint32 TMtNSAddr::tls_port() const {
  return tls_port_;
}
inline void TMtNSAddr::set_tls_port(::google::protobuf::uint32 value) {
  set_has_tls_port();
  tls_port_ = value;
}

// -------------------------------------------------------------------

// TMtMeetingSvrAddr

// optional string Domain = 1;
inline bool TMtMeetingSvrAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtMeetingSvrAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtMeetingSvrAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtMeetingSvrAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtMeetingSvrAddr::domain() const {
  return *domain_;
}
inline void TMtMeetingSvrAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtMeetingSvrAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtMeetingSvrAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtMeetingSvrAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtMeetingSvrAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtMeetingSvrAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtMeetingSvrAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtMeetingSvrAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtMeetingSvrAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtMeetingSvrAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtMeetingSvrAddr::ip() const {
  return ip_;
}
inline void TMtMeetingSvrAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TMtMeetingSvrAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtMeetingSvrAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtMeetingSvrAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtMeetingSvrAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtMeetingSvrAddr::port() const {
  return port_;
}
inline void TMtMeetingSvrAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMtSipSvrAddr

// optional bool is_enable = 1;
inline bool TMtSipSvrAddr::has_is_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSipSvrAddr::set_has_is_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSipSvrAddr::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSipSvrAddr::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMtSipSvrAddr::is_enable() const {
  return is_enable_;
}
inline void TMtSipSvrAddr::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// optional string Domain = 2;
inline bool TMtSipSvrAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSipSvrAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSipSvrAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSipSvrAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtSipSvrAddr::domain() const {
  return *domain_;
}
inline void TMtSipSvrAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtSipSvrAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtSipSvrAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSipSvrAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtSipSvrAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSipSvrAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 Ip = 3;
inline bool TMtSipSvrAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtSipSvrAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtSipSvrAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtSipSvrAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtSipSvrAddr::ip() const {
  return ip_;
}
inline void TMtSipSvrAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 Port = 4;
inline bool TMtSipSvrAddr::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtSipSvrAddr::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtSipSvrAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtSipSvrAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtSipSvrAddr::port() const {
  return port_;
}
inline void TMtSipSvrAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string Password = 5;
inline bool TMtSipSvrAddr::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtSipSvrAddr::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtSipSvrAddr::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtSipSvrAddr::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtSipSvrAddr::password() const {
  return *password_;
}
inline void TMtSipSvrAddr::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtSipSvrAddr::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtSipSvrAddr::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSipSvrAddr::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtSipSvrAddr::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSipSvrAddr::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 Expire = 6;
inline bool TMtSipSvrAddr::has_expire() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtSipSvrAddr::set_has_expire() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtSipSvrAddr::clear_has_expire() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtSipSvrAddr::clear_expire() {
  expire_ = 0u;
  clear_has_expire();
}
inline ::google::protobuf::uint32 TMtSipSvrAddr::expire() const {
  return expire_;
}
inline void TMtSipSvrAddr::set_expire(::google::protobuf::uint32 value) {
  set_has_expire();
  expire_ = value;
}

// optional string validate_name = 7;
inline bool TMtSipSvrAddr::has_validate_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtSipSvrAddr::set_has_validate_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtSipSvrAddr::clear_has_validate_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtSipSvrAddr::clear_validate_name() {
  if (validate_name_ != &::google::protobuf::internal::kEmptyString) {
    validate_name_->clear();
  }
  clear_has_validate_name();
}
inline const ::std::string& TMtSipSvrAddr::validate_name() const {
  return *validate_name_;
}
inline void TMtSipSvrAddr::set_validate_name(const ::std::string& value) {
  set_has_validate_name();
  if (validate_name_ == &::google::protobuf::internal::kEmptyString) {
    validate_name_ = new ::std::string;
  }
  validate_name_->assign(value);
}
inline void TMtSipSvrAddr::set_validate_name(const char* value) {
  set_has_validate_name();
  if (validate_name_ == &::google::protobuf::internal::kEmptyString) {
    validate_name_ = new ::std::string;
  }
  validate_name_->assign(value);
}
inline void TMtSipSvrAddr::set_validate_name(const char* value, size_t size) {
  set_has_validate_name();
  if (validate_name_ == &::google::protobuf::internal::kEmptyString) {
    validate_name_ = new ::std::string;
  }
  validate_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSipSvrAddr::mutable_validate_name() {
  set_has_validate_name();
  if (validate_name_ == &::google::protobuf::internal::kEmptyString) {
    validate_name_ = new ::std::string;
  }
  return validate_name_;
}
inline ::std::string* TMtSipSvrAddr::release_validate_name() {
  clear_has_validate_name();
  if (validate_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = validate_name_;
    validate_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSipSvrAddr::set_allocated_validate_name(::std::string* validate_name) {
  if (validate_name_ != &::google::protobuf::internal::kEmptyString) {
    delete validate_name_;
  }
  if (validate_name) {
    set_has_validate_name();
    validate_name_ = validate_name;
  } else {
    clear_has_validate_name();
    validate_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 host_port = 8;
inline bool TMtSipSvrAddr::has_host_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtSipSvrAddr::set_has_host_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtSipSvrAddr::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtSipSvrAddr::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
inline ::google::protobuf::uint32 TMtSipSvrAddr::host_port() const {
  return host_port_;
}
inline void TMtSipSvrAddr::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
}

// optional string auth_name = 9;
inline bool TMtSipSvrAddr::has_auth_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMtSipSvrAddr::set_has_auth_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMtSipSvrAddr::clear_has_auth_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMtSipSvrAddr::clear_auth_name() {
  if (auth_name_ != &::google::protobuf::internal::kEmptyString) {
    auth_name_->clear();
  }
  clear_has_auth_name();
}
inline const ::std::string& TMtSipSvrAddr::auth_name() const {
  return *auth_name_;
}
inline void TMtSipSvrAddr::set_auth_name(const ::std::string& value) {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  auth_name_->assign(value);
}
inline void TMtSipSvrAddr::set_auth_name(const char* value) {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  auth_name_->assign(value);
}
inline void TMtSipSvrAddr::set_auth_name(const char* value, size_t size) {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  auth_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSipSvrAddr::mutable_auth_name() {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  return auth_name_;
}
inline ::std::string* TMtSipSvrAddr::release_auth_name() {
  clear_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_name_;
    auth_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSipSvrAddr::set_allocated_auth_name(::std::string* auth_name) {
  if (auth_name_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_name_;
  }
  if (auth_name) {
    set_has_auth_name();
    auth_name_ = auth_name;
  } else {
    clear_has_auth_name();
    auth_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 TlsPort = 10;
inline bool TMtSipSvrAddr::has_tlsport() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMtSipSvrAddr::set_has_tlsport() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMtSipSvrAddr::clear_has_tlsport() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMtSipSvrAddr::clear_tlsport() {
  tlsport_ = 0u;
  clear_has_tlsport();
}
inline ::google::protobuf::uint32 TMtSipSvrAddr::tlsport() const {
  return tlsport_;
}
inline void TMtSipSvrAddr::set_tlsport(::google::protobuf::uint32 value) {
  set_has_tlsport();
  tlsport_ = value;
}

// optional uint32 GtlsPort = 11;
inline bool TMtSipSvrAddr::has_gtlsport() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMtSipSvrAddr::set_has_gtlsport() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMtSipSvrAddr::clear_has_gtlsport() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMtSipSvrAddr::clear_gtlsport() {
  gtlsport_ = 0u;
  clear_has_gtlsport();
}
inline ::google::protobuf::uint32 TMtSipSvrAddr::gtlsport() const {
  return gtlsport_;
}
inline void TMtSipSvrAddr::set_gtlsport(::google::protobuf::uint32 value) {
  set_has_gtlsport();
  gtlsport_ = value;
}

// optional string PxyDomain = 12;
inline bool TMtSipSvrAddr::has_pxydomain() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMtSipSvrAddr::set_has_pxydomain() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMtSipSvrAddr::clear_has_pxydomain() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMtSipSvrAddr::clear_pxydomain() {
  if (pxydomain_ != &::google::protobuf::internal::kEmptyString) {
    pxydomain_->clear();
  }
  clear_has_pxydomain();
}
inline const ::std::string& TMtSipSvrAddr::pxydomain() const {
  return *pxydomain_;
}
inline void TMtSipSvrAddr::set_pxydomain(const ::std::string& value) {
  set_has_pxydomain();
  if (pxydomain_ == &::google::protobuf::internal::kEmptyString) {
    pxydomain_ = new ::std::string;
  }
  pxydomain_->assign(value);
}
inline void TMtSipSvrAddr::set_pxydomain(const char* value) {
  set_has_pxydomain();
  if (pxydomain_ == &::google::protobuf::internal::kEmptyString) {
    pxydomain_ = new ::std::string;
  }
  pxydomain_->assign(value);
}
inline void TMtSipSvrAddr::set_pxydomain(const char* value, size_t size) {
  set_has_pxydomain();
  if (pxydomain_ == &::google::protobuf::internal::kEmptyString) {
    pxydomain_ = new ::std::string;
  }
  pxydomain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSipSvrAddr::mutable_pxydomain() {
  set_has_pxydomain();
  if (pxydomain_ == &::google::protobuf::internal::kEmptyString) {
    pxydomain_ = new ::std::string;
  }
  return pxydomain_;
}
inline ::std::string* TMtSipSvrAddr::release_pxydomain() {
  clear_has_pxydomain();
  if (pxydomain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pxydomain_;
    pxydomain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSipSvrAddr::set_allocated_pxydomain(::std::string* pxydomain) {
  if (pxydomain_ != &::google::protobuf::internal::kEmptyString) {
    delete pxydomain_;
  }
  if (pxydomain) {
    set_has_pxydomain();
    pxydomain_ = pxydomain;
  } else {
    clear_has_pxydomain();
    pxydomain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtH323PxyCfg

// optional bool is_enable = 1;
inline bool TMtH323PxyCfg::has_is_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtH323PxyCfg::set_has_is_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtH323PxyCfg::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtH323PxyCfg::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMtH323PxyCfg::is_enable() const {
  return is_enable_;
}
inline void TMtH323PxyCfg::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// optional uint32 srv_ip = 2;
inline bool TMtH323PxyCfg::has_srv_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtH323PxyCfg::set_has_srv_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtH323PxyCfg::clear_has_srv_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtH323PxyCfg::clear_srv_ip() {
  srv_ip_ = 0u;
  clear_has_srv_ip();
}
inline ::google::protobuf::uint32 TMtH323PxyCfg::srv_ip() const {
  return srv_ip_;
}
inline void TMtH323PxyCfg::set_srv_ip(::google::protobuf::uint32 value) {
  set_has_srv_ip();
  srv_ip_ = value;
}

// optional uint32 srv_port = 3;
inline bool TMtH323PxyCfg::has_srv_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtH323PxyCfg::set_has_srv_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtH323PxyCfg::clear_has_srv_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtH323PxyCfg::clear_srv_port() {
  srv_port_ = 0u;
  clear_has_srv_port();
}
inline ::google::protobuf::uint32 TMtH323PxyCfg::srv_port() const {
  return srv_port_;
}
inline void TMtH323PxyCfg::set_srv_port(::google::protobuf::uint32 value) {
  set_has_srv_port();
  srv_port_ = value;
}

// optional string password = 4;
inline bool TMtH323PxyCfg::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtH323PxyCfg::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtH323PxyCfg::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtH323PxyCfg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtH323PxyCfg::password() const {
  return *password_;
}
inline void TMtH323PxyCfg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtH323PxyCfg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtH323PxyCfg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtH323PxyCfg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtH323PxyCfg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtH323PxyCfg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string number = 5;
inline bool TMtH323PxyCfg::has_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtH323PxyCfg::set_has_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtH323PxyCfg::clear_has_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtH323PxyCfg::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& TMtH323PxyCfg::number() const {
  return *number_;
}
inline void TMtH323PxyCfg::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TMtH323PxyCfg::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TMtH323PxyCfg::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtH323PxyCfg::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* TMtH323PxyCfg::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtH323PxyCfg::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtH460PxyCfg

// optional bool is_enable = 1;
inline bool TMtH460PxyCfg::has_is_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtH460PxyCfg::set_has_is_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtH460PxyCfg::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtH460PxyCfg::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMtH460PxyCfg::is_enable() const {
  return is_enable_;
}
inline void TMtH460PxyCfg::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// optional uint32 srv_ip = 2;
inline bool TMtH460PxyCfg::has_srv_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtH460PxyCfg::set_has_srv_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtH460PxyCfg::clear_has_srv_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtH460PxyCfg::clear_srv_ip() {
  srv_ip_ = 0u;
  clear_has_srv_ip();
}
inline ::google::protobuf::uint32 TMtH460PxyCfg::srv_ip() const {
  return srv_ip_;
}
inline void TMtH460PxyCfg::set_srv_ip(::google::protobuf::uint32 value) {
  set_has_srv_ip();
  srv_ip_ = value;
}

// optional string password = 3;
inline bool TMtH460PxyCfg::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtH460PxyCfg::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtH460PxyCfg::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtH460PxyCfg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtH460PxyCfg::password() const {
  return *password_;
}
inline void TMtH460PxyCfg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtH460PxyCfg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtH460PxyCfg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtH460PxyCfg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtH460PxyCfg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtH460PxyCfg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string number = 4;
inline bool TMtH460PxyCfg::has_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtH460PxyCfg::set_has_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtH460PxyCfg::clear_has_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtH460PxyCfg::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& TMtH460PxyCfg::number() const {
  return *number_;
}
inline void TMtH460PxyCfg::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TMtH460PxyCfg::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TMtH460PxyCfg::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtH460PxyCfg::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* TMtH460PxyCfg::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtH460PxyCfg::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtLoginPlatformPwdCfg

// optional string password = 1;
inline bool TMtLoginPlatformPwdCfg::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtLoginPlatformPwdCfg::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtLoginPlatformPwdCfg::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtLoginPlatformPwdCfg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtLoginPlatformPwdCfg::password() const {
  return *password_;
}
inline void TMtLoginPlatformPwdCfg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtLoginPlatformPwdCfg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtLoginPlatformPwdCfg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtLoginPlatformPwdCfg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtLoginPlatformPwdCfg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtLoginPlatformPwdCfg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_modify_enable = 2;
inline bool TMtLoginPlatformPwdCfg::has_is_modify_enable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtLoginPlatformPwdCfg::set_has_is_modify_enable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtLoginPlatformPwdCfg::clear_has_is_modify_enable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtLoginPlatformPwdCfg::clear_is_modify_enable() {
  is_modify_enable_ = false;
  clear_has_is_modify_enable();
}
inline bool TMtLoginPlatformPwdCfg::is_modify_enable() const {
  return is_modify_enable_;
}
inline void TMtLoginPlatformPwdCfg::set_is_modify_enable(bool value) {
  set_has_is_modify_enable();
  is_modify_enable_ = value;
}

// -------------------------------------------------------------------

// TMtSipCfg

// optional bool enable_bfcp = 1;
inline bool TMtSipCfg::has_enable_bfcp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSipCfg::set_has_enable_bfcp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSipCfg::clear_has_enable_bfcp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSipCfg::clear_enable_bfcp() {
  enable_bfcp_ = false;
  clear_has_enable_bfcp();
}
inline bool TMtSipCfg::enable_bfcp() const {
  return enable_bfcp_;
}
inline void TMtSipCfg::set_enable_bfcp(bool value) {
  set_has_enable_bfcp();
  enable_bfcp_ = value;
}

// -------------------------------------------------------------------

// TMtSipProxyCfg

// optional string Domain = 1;
inline bool TMtSipProxyCfg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSipProxyCfg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSipProxyCfg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSipProxyCfg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtSipProxyCfg::domain() const {
  return *domain_;
}
inline void TMtSipProxyCfg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtSipProxyCfg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtSipProxyCfg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSipProxyCfg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtSipProxyCfg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSipProxyCfg::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 Ip = 2;
inline bool TMtSipProxyCfg::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSipProxyCfg::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSipProxyCfg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSipProxyCfg::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtSipProxyCfg::ip() const {
  return ip_;
}
inline void TMtSipProxyCfg::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 Port = 3;
inline bool TMtSipProxyCfg::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtSipProxyCfg::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtSipProxyCfg::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtSipProxyCfg::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtSipProxyCfg::port() const {
  return port_;
}
inline void TMtSipProxyCfg::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMtTerminalName

// optional string e164 = 1;
inline bool TMtTerminalName::has_e164() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtTerminalName::set_has_e164() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtTerminalName::clear_has_e164() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtTerminalName::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMtTerminalName::e164() const {
  return *e164_;
}
inline void TMtTerminalName::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMtTerminalName::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMtTerminalName::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtTerminalName::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMtTerminalName::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtTerminalName::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alias = 2;
inline bool TMtTerminalName::has_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtTerminalName::set_has_alias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtTerminalName::clear_has_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtTerminalName::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& TMtTerminalName::alias() const {
  return *alias_;
}
inline void TMtTerminalName::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMtTerminalName::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMtTerminalName::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtTerminalName::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* TMtTerminalName::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtTerminalName::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TTerminalInfo

// optional .mt.EmMtModel model = 1;
inline bool TTerminalInfo::has_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TTerminalInfo::set_has_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TTerminalInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TTerminalInfo::clear_model() {
  model_ = 0;
  clear_has_model();
}
inline ::mt::EmMtModel TTerminalInfo::model() const {
  return static_cast< ::mt::EmMtModel >(model_);
}
inline void TTerminalInfo::set_model(::mt::EmMtModel value) {
  assert(::mt::EmMtModel_IsValid(value));
  set_has_model();
  model_ = value;
}

// optional string model_name = 2;
inline bool TTerminalInfo::has_model_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TTerminalInfo::set_has_model_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TTerminalInfo::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TTerminalInfo::clear_model_name() {
  if (model_name_ != &::google::protobuf::internal::kEmptyString) {
    model_name_->clear();
  }
  clear_has_model_name();
}
inline const ::std::string& TTerminalInfo::model_name() const {
  return *model_name_;
}
inline void TTerminalInfo::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void TTerminalInfo::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void TTerminalInfo::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  return model_name_;
}
inline ::std::string* TTerminalInfo::release_model_name() {
  clear_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != &::google::protobuf::internal::kEmptyString) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hardware_ver = 3;
inline bool TTerminalInfo::has_hardware_ver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TTerminalInfo::set_has_hardware_ver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TTerminalInfo::clear_has_hardware_ver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TTerminalInfo::clear_hardware_ver() {
  if (hardware_ver_ != &::google::protobuf::internal::kEmptyString) {
    hardware_ver_->clear();
  }
  clear_has_hardware_ver();
}
inline const ::std::string& TTerminalInfo::hardware_ver() const {
  return *hardware_ver_;
}
inline void TTerminalInfo::set_hardware_ver(const ::std::string& value) {
  set_has_hardware_ver();
  if (hardware_ver_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ver_ = new ::std::string;
  }
  hardware_ver_->assign(value);
}
inline void TTerminalInfo::set_hardware_ver(const char* value) {
  set_has_hardware_ver();
  if (hardware_ver_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ver_ = new ::std::string;
  }
  hardware_ver_->assign(value);
}
inline void TTerminalInfo::set_hardware_ver(const char* value, size_t size) {
  set_has_hardware_ver();
  if (hardware_ver_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ver_ = new ::std::string;
  }
  hardware_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_hardware_ver() {
  set_has_hardware_ver();
  if (hardware_ver_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ver_ = new ::std::string;
  }
  return hardware_ver_;
}
inline ::std::string* TTerminalInfo::release_hardware_ver() {
  clear_has_hardware_ver();
  if (hardware_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hardware_ver_;
    hardware_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_hardware_ver(::std::string* hardware_ver) {
  if (hardware_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete hardware_ver_;
  }
  if (hardware_ver) {
    set_has_hardware_ver();
    hardware_ver_ = hardware_ver;
  } else {
    clear_has_hardware_ver();
    hardware_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string software_ver = 4;
inline bool TTerminalInfo::has_software_ver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TTerminalInfo::set_has_software_ver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TTerminalInfo::clear_has_software_ver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TTerminalInfo::clear_software_ver() {
  if (software_ver_ != &::google::protobuf::internal::kEmptyString) {
    software_ver_->clear();
  }
  clear_has_software_ver();
}
inline const ::std::string& TTerminalInfo::software_ver() const {
  return *software_ver_;
}
inline void TTerminalInfo::set_software_ver(const ::std::string& value) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(value);
}
inline void TTerminalInfo::set_software_ver(const char* value) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(value);
}
inline void TTerminalInfo::set_software_ver(const char* value, size_t size) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_software_ver() {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  return software_ver_;
}
inline ::std::string* TTerminalInfo::release_software_ver() {
  clear_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_ver_;
    software_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_software_ver(::std::string* software_ver) {
  if (software_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete software_ver_;
  }
  if (software_ver) {
    set_has_software_ver();
    software_ver_ = software_ver;
  } else {
    clear_has_software_ver();
    software_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string oem_info = 5;
inline bool TTerminalInfo::has_oem_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TTerminalInfo::set_has_oem_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TTerminalInfo::clear_has_oem_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TTerminalInfo::clear_oem_info() {
  if (oem_info_ != &::google::protobuf::internal::kEmptyString) {
    oem_info_->clear();
  }
  clear_has_oem_info();
}
inline const ::std::string& TTerminalInfo::oem_info() const {
  return *oem_info_;
}
inline void TTerminalInfo::set_oem_info(const ::std::string& value) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(value);
}
inline void TTerminalInfo::set_oem_info(const char* value) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(value);
}
inline void TTerminalInfo::set_oem_info(const char* value, size_t size) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_oem_info() {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  return oem_info_;
}
inline ::std::string* TTerminalInfo::release_oem_info() {
  clear_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oem_info_;
    oem_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_oem_info(::std::string* oem_info) {
  if (oem_info_ != &::google::protobuf::internal::kEmptyString) {
    delete oem_info_;
  }
  if (oem_info) {
    set_has_oem_info();
    oem_info_ = oem_info;
  } else {
    clear_has_oem_info();
    oem_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fpga1_ver = 6;
inline bool TTerminalInfo::has_fpga1_ver() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TTerminalInfo::set_has_fpga1_ver() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TTerminalInfo::clear_has_fpga1_ver() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TTerminalInfo::clear_fpga1_ver() {
  if (fpga1_ver_ != &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_->clear();
  }
  clear_has_fpga1_ver();
}
inline const ::std::string& TTerminalInfo::fpga1_ver() const {
  return *fpga1_ver_;
}
inline void TTerminalInfo::set_fpga1_ver(const ::std::string& value) {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  fpga1_ver_->assign(value);
}
inline void TTerminalInfo::set_fpga1_ver(const char* value) {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  fpga1_ver_->assign(value);
}
inline void TTerminalInfo::set_fpga1_ver(const char* value, size_t size) {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  fpga1_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_fpga1_ver() {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  return fpga1_ver_;
}
inline ::std::string* TTerminalInfo::release_fpga1_ver() {
  clear_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fpga1_ver_;
    fpga1_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_fpga1_ver(::std::string* fpga1_ver) {
  if (fpga1_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete fpga1_ver_;
  }
  if (fpga1_ver) {
    set_has_fpga1_ver();
    fpga1_ver_ = fpga1_ver;
  } else {
    clear_has_fpga1_ver();
    fpga1_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fpga2_ver = 7;
inline bool TTerminalInfo::has_fpga2_ver() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TTerminalInfo::set_has_fpga2_ver() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TTerminalInfo::clear_has_fpga2_ver() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TTerminalInfo::clear_fpga2_ver() {
  if (fpga2_ver_ != &::google::protobuf::internal::kEmptyString) {
    fpga2_ver_->clear();
  }
  clear_has_fpga2_ver();
}
inline const ::std::string& TTerminalInfo::fpga2_ver() const {
  return *fpga2_ver_;
}
inline void TTerminalInfo::set_fpga2_ver(const ::std::string& value) {
  set_has_fpga2_ver();
  if (fpga2_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga2_ver_ = new ::std::string;
  }
  fpga2_ver_->assign(value);
}
inline void TTerminalInfo::set_fpga2_ver(const char* value) {
  set_has_fpga2_ver();
  if (fpga2_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga2_ver_ = new ::std::string;
  }
  fpga2_ver_->assign(value);
}
inline void TTerminalInfo::set_fpga2_ver(const char* value, size_t size) {
  set_has_fpga2_ver();
  if (fpga2_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga2_ver_ = new ::std::string;
  }
  fpga2_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_fpga2_ver() {
  set_has_fpga2_ver();
  if (fpga2_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga2_ver_ = new ::std::string;
  }
  return fpga2_ver_;
}
inline ::std::string* TTerminalInfo::release_fpga2_ver() {
  clear_has_fpga2_ver();
  if (fpga2_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fpga2_ver_;
    fpga2_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_fpga2_ver(::std::string* fpga2_ver) {
  if (fpga2_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete fpga2_ver_;
  }
  if (fpga2_ver) {
    set_has_fpga2_ver();
    fpga2_ver_ = fpga2_ver;
  } else {
    clear_has_fpga2_ver();
    fpga2_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cpld_ver = 8;
inline bool TTerminalInfo::has_cpld_ver() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TTerminalInfo::set_has_cpld_ver() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TTerminalInfo::clear_has_cpld_ver() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TTerminalInfo::clear_cpld_ver() {
  if (cpld_ver_ != &::google::protobuf::internal::kEmptyString) {
    cpld_ver_->clear();
  }
  clear_has_cpld_ver();
}
inline const ::std::string& TTerminalInfo::cpld_ver() const {
  return *cpld_ver_;
}
inline void TTerminalInfo::set_cpld_ver(const ::std::string& value) {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  cpld_ver_->assign(value);
}
inline void TTerminalInfo::set_cpld_ver(const char* value) {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  cpld_ver_->assign(value);
}
inline void TTerminalInfo::set_cpld_ver(const char* value, size_t size) {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  cpld_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_cpld_ver() {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  return cpld_ver_;
}
inline ::std::string* TTerminalInfo::release_cpld_ver() {
  clear_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpld_ver_;
    cpld_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_cpld_ver(::std::string* cpld_ver) {
  if (cpld_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete cpld_ver_;
  }
  if (cpld_ver) {
    set_has_cpld_ver();
    cpld_ver_ = cpld_ver;
  } else {
    clear_has_cpld_ver();
    cpld_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string serial_num = 9;
inline bool TTerminalInfo::has_serial_num() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TTerminalInfo::set_has_serial_num() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TTerminalInfo::clear_has_serial_num() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TTerminalInfo::clear_serial_num() {
  if (serial_num_ != &::google::protobuf::internal::kEmptyString) {
    serial_num_->clear();
  }
  clear_has_serial_num();
}
inline const ::std::string& TTerminalInfo::serial_num() const {
  return *serial_num_;
}
inline void TTerminalInfo::set_serial_num(const ::std::string& value) {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  serial_num_->assign(value);
}
inline void TTerminalInfo::set_serial_num(const char* value) {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  serial_num_->assign(value);
}
inline void TTerminalInfo::set_serial_num(const char* value, size_t size) {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  serial_num_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_serial_num() {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  return serial_num_;
}
inline ::std::string* TTerminalInfo::release_serial_num() {
  clear_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_num_;
    serial_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_serial_num(::std::string* serial_num) {
  if (serial_num_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_num_;
  }
  if (serial_num) {
    set_has_serial_num();
    serial_num_ = serial_num;
  } else {
    clear_has_serial_num();
    serial_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string infrared_ver = 10;
inline bool TTerminalInfo::has_infrared_ver() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TTerminalInfo::set_has_infrared_ver() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TTerminalInfo::clear_has_infrared_ver() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TTerminalInfo::clear_infrared_ver() {
  if (infrared_ver_ != &::google::protobuf::internal::kEmptyString) {
    infrared_ver_->clear();
  }
  clear_has_infrared_ver();
}
inline const ::std::string& TTerminalInfo::infrared_ver() const {
  return *infrared_ver_;
}
inline void TTerminalInfo::set_infrared_ver(const ::std::string& value) {
  set_has_infrared_ver();
  if (infrared_ver_ == &::google::protobuf::internal::kEmptyString) {
    infrared_ver_ = new ::std::string;
  }
  infrared_ver_->assign(value);
}
inline void TTerminalInfo::set_infrared_ver(const char* value) {
  set_has_infrared_ver();
  if (infrared_ver_ == &::google::protobuf::internal::kEmptyString) {
    infrared_ver_ = new ::std::string;
  }
  infrared_ver_->assign(value);
}
inline void TTerminalInfo::set_infrared_ver(const char* value, size_t size) {
  set_has_infrared_ver();
  if (infrared_ver_ == &::google::protobuf::internal::kEmptyString) {
    infrared_ver_ = new ::std::string;
  }
  infrared_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_infrared_ver() {
  set_has_infrared_ver();
  if (infrared_ver_ == &::google::protobuf::internal::kEmptyString) {
    infrared_ver_ = new ::std::string;
  }
  return infrared_ver_;
}
inline ::std::string* TTerminalInfo::release_infrared_ver() {
  clear_has_infrared_ver();
  if (infrared_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = infrared_ver_;
    infrared_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_infrared_ver(::std::string* infrared_ver) {
  if (infrared_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete infrared_ver_;
  }
  if (infrared_ver) {
    set_has_infrared_ver();
    infrared_ver_ = infrared_ver;
  } else {
    clear_has_infrared_ver();
    infrared_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fpga3_ver = 11;
inline bool TTerminalInfo::has_fpga3_ver() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TTerminalInfo::set_has_fpga3_ver() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TTerminalInfo::clear_has_fpga3_ver() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TTerminalInfo::clear_fpga3_ver() {
  if (fpga3_ver_ != &::google::protobuf::internal::kEmptyString) {
    fpga3_ver_->clear();
  }
  clear_has_fpga3_ver();
}
inline const ::std::string& TTerminalInfo::fpga3_ver() const {
  return *fpga3_ver_;
}
inline void TTerminalInfo::set_fpga3_ver(const ::std::string& value) {
  set_has_fpga3_ver();
  if (fpga3_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga3_ver_ = new ::std::string;
  }
  fpga3_ver_->assign(value);
}
inline void TTerminalInfo::set_fpga3_ver(const char* value) {
  set_has_fpga3_ver();
  if (fpga3_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga3_ver_ = new ::std::string;
  }
  fpga3_ver_->assign(value);
}
inline void TTerminalInfo::set_fpga3_ver(const char* value, size_t size) {
  set_has_fpga3_ver();
  if (fpga3_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga3_ver_ = new ::std::string;
  }
  fpga3_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_fpga3_ver() {
  set_has_fpga3_ver();
  if (fpga3_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga3_ver_ = new ::std::string;
  }
  return fpga3_ver_;
}
inline ::std::string* TTerminalInfo::release_fpga3_ver() {
  clear_has_fpga3_ver();
  if (fpga3_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fpga3_ver_;
    fpga3_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_fpga3_ver(::std::string* fpga3_ver) {
  if (fpga3_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete fpga3_ver_;
  }
  if (fpga3_ver) {
    set_has_fpga3_ver();
    fpga3_ver_ = fpga3_ver;
  } else {
    clear_has_fpga3_ver();
    fpga3_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fpga4_ver = 12;
inline bool TTerminalInfo::has_fpga4_ver() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TTerminalInfo::set_has_fpga4_ver() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TTerminalInfo::clear_has_fpga4_ver() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TTerminalInfo::clear_fpga4_ver() {
  if (fpga4_ver_ != &::google::protobuf::internal::kEmptyString) {
    fpga4_ver_->clear();
  }
  clear_has_fpga4_ver();
}
inline const ::std::string& TTerminalInfo::fpga4_ver() const {
  return *fpga4_ver_;
}
inline void TTerminalInfo::set_fpga4_ver(const ::std::string& value) {
  set_has_fpga4_ver();
  if (fpga4_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga4_ver_ = new ::std::string;
  }
  fpga4_ver_->assign(value);
}
inline void TTerminalInfo::set_fpga4_ver(const char* value) {
  set_has_fpga4_ver();
  if (fpga4_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga4_ver_ = new ::std::string;
  }
  fpga4_ver_->assign(value);
}
inline void TTerminalInfo::set_fpga4_ver(const char* value, size_t size) {
  set_has_fpga4_ver();
  if (fpga4_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga4_ver_ = new ::std::string;
  }
  fpga4_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_fpga4_ver() {
  set_has_fpga4_ver();
  if (fpga4_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga4_ver_ = new ::std::string;
  }
  return fpga4_ver_;
}
inline ::std::string* TTerminalInfo::release_fpga4_ver() {
  clear_has_fpga4_ver();
  if (fpga4_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fpga4_ver_;
    fpga4_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_fpga4_ver(::std::string* fpga4_ver) {
  if (fpga4_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete fpga4_ver_;
  }
  if (fpga4_ver) {
    set_has_fpga4_ver();
    fpga4_ver_ = fpga4_ver;
  } else {
    clear_has_fpga4_ver();
    fpga4_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ptz_ver = 13;
inline bool TTerminalInfo::has_ptz_ver() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TTerminalInfo::set_has_ptz_ver() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TTerminalInfo::clear_has_ptz_ver() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TTerminalInfo::clear_ptz_ver() {
  if (ptz_ver_ != &::google::protobuf::internal::kEmptyString) {
    ptz_ver_->clear();
  }
  clear_has_ptz_ver();
}
inline const ::std::string& TTerminalInfo::ptz_ver() const {
  return *ptz_ver_;
}
inline void TTerminalInfo::set_ptz_ver(const ::std::string& value) {
  set_has_ptz_ver();
  if (ptz_ver_ == &::google::protobuf::internal::kEmptyString) {
    ptz_ver_ = new ::std::string;
  }
  ptz_ver_->assign(value);
}
inline void TTerminalInfo::set_ptz_ver(const char* value) {
  set_has_ptz_ver();
  if (ptz_ver_ == &::google::protobuf::internal::kEmptyString) {
    ptz_ver_ = new ::std::string;
  }
  ptz_ver_->assign(value);
}
inline void TTerminalInfo::set_ptz_ver(const char* value, size_t size) {
  set_has_ptz_ver();
  if (ptz_ver_ == &::google::protobuf::internal::kEmptyString) {
    ptz_ver_ = new ::std::string;
  }
  ptz_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TTerminalInfo::mutable_ptz_ver() {
  set_has_ptz_ver();
  if (ptz_ver_ == &::google::protobuf::internal::kEmptyString) {
    ptz_ver_ = new ::std::string;
  }
  return ptz_ver_;
}
inline ::std::string* TTerminalInfo::release_ptz_ver() {
  clear_has_ptz_ver();
  if (ptz_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ptz_ver_;
    ptz_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TTerminalInfo::set_allocated_ptz_ver(::std::string* ptz_ver) {
  if (ptz_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete ptz_ver_;
  }
  if (ptz_ver) {
    set_has_ptz_ver();
    ptz_ver_ = ptz_ver;
  } else {
    clear_has_ptz_ver();
    ptz_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtBandWidthTest

// optional bool enable = 1 [default = true];
inline bool TMtBandWidthTest::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtBandWidthTest::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtBandWidthTest::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtBandWidthTest::clear_enable() {
  enable_ = true;
  clear_has_enable();
}
inline bool TMtBandWidthTest::enable() const {
  return enable_;
}
inline void TMtBandWidthTest::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional uint32 up = 2 [default = 0];
inline bool TMtBandWidthTest::has_up() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtBandWidthTest::set_has_up() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtBandWidthTest::clear_has_up() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtBandWidthTest::clear_up() {
  up_ = 0u;
  clear_has_up();
}
inline ::google::protobuf::uint32 TMtBandWidthTest::up() const {
  return up_;
}
inline void TMtBandWidthTest::set_up(::google::protobuf::uint32 value) {
  set_has_up();
  up_ = value;
}

// optional uint32 down = 3 [default = 0];
inline bool TMtBandWidthTest::has_down() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtBandWidthTest::set_has_down() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtBandWidthTest::clear_has_down() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtBandWidthTest::clear_down() {
  down_ = 0u;
  clear_has_down();
}
inline ::google::protobuf::uint32 TMtBandWidthTest::down() const {
  return down_;
}
inline void TMtBandWidthTest::set_down(::google::protobuf::uint32 value) {
  set_has_down();
  down_ = value;
}

// -------------------------------------------------------------------

// TMTNat

// optional bool enable = 1;
inline bool TMTNat::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTNat::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTNat::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTNat::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTNat::enable() const {
  return enable_;
}
inline void TMTNat::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional uint32 ip = 2;
inline bool TMTNat::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTNat::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTNat::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTNat::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMTNat::ip() const {
  return ip_;
}
inline void TMTNat::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// -------------------------------------------------------------------

// TMTAutoCall

// optional bool enable = 1;
inline bool TMTAutoCall::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTAutoCall::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTAutoCall::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTAutoCall::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTAutoCall::enable() const {
  return enable_;
}
inline void TMTAutoCall::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional string called_ter_name = 2;
inline bool TMTAutoCall::has_called_ter_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTAutoCall::set_has_called_ter_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTAutoCall::clear_has_called_ter_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTAutoCall::clear_called_ter_name() {
  if (called_ter_name_ != &::google::protobuf::internal::kEmptyString) {
    called_ter_name_->clear();
  }
  clear_has_called_ter_name();
}
inline const ::std::string& TMTAutoCall::called_ter_name() const {
  return *called_ter_name_;
}
inline void TMTAutoCall::set_called_ter_name(const ::std::string& value) {
  set_has_called_ter_name();
  if (called_ter_name_ == &::google::protobuf::internal::kEmptyString) {
    called_ter_name_ = new ::std::string;
  }
  called_ter_name_->assign(value);
}
inline void TMTAutoCall::set_called_ter_name(const char* value) {
  set_has_called_ter_name();
  if (called_ter_name_ == &::google::protobuf::internal::kEmptyString) {
    called_ter_name_ = new ::std::string;
  }
  called_ter_name_->assign(value);
}
inline void TMTAutoCall::set_called_ter_name(const char* value, size_t size) {
  set_has_called_ter_name();
  if (called_ter_name_ == &::google::protobuf::internal::kEmptyString) {
    called_ter_name_ = new ::std::string;
  }
  called_ter_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTAutoCall::mutable_called_ter_name() {
  set_has_called_ter_name();
  if (called_ter_name_ == &::google::protobuf::internal::kEmptyString) {
    called_ter_name_ = new ::std::string;
  }
  return called_ter_name_;
}
inline ::std::string* TMTAutoCall::release_called_ter_name() {
  clear_has_called_ter_name();
  if (called_ter_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = called_ter_name_;
    called_ter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTAutoCall::set_allocated_called_ter_name(::std::string* called_ter_name) {
  if (called_ter_name_ != &::google::protobuf::internal::kEmptyString) {
    delete called_ter_name_;
  }
  if (called_ter_name) {
    set_has_called_ter_name();
    called_ter_name_ = called_ter_name;
  } else {
    clear_has_called_ter_name();
    called_ter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 callrate = 3;
inline bool TMTAutoCall::has_callrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTAutoCall::set_has_callrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTAutoCall::clear_has_callrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTAutoCall::clear_callrate() {
  callrate_ = 0u;
  clear_has_callrate();
}
inline ::google::protobuf::uint32 TMTAutoCall::callrate() const {
  return callrate_;
}
inline void TMTAutoCall::set_callrate(::google::protobuf::uint32 value) {
  set_has_callrate();
  callrate_ = value;
}

// -------------------------------------------------------------------

// TMTCallerProtocol

// optional .mt.EmConfProtocol protocol = 1;
inline bool TMTCallerProtocol::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCallerProtocol::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCallerProtocol::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCallerProtocol::clear_protocol() {
  protocol_ = 0;
  clear_has_protocol();
}
inline ::mt::EmConfProtocol TMTCallerProtocol::protocol() const {
  return static_cast< ::mt::EmConfProtocol >(protocol_);
}
inline void TMTCallerProtocol::set_protocol(::mt::EmConfProtocol value) {
  assert(::mt::EmConfProtocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
}

// -------------------------------------------------------------------

// TMTEncryptType

// optional .mt.EmEncryptArithmetic type = 1;
inline bool TMTEncryptType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTEncryptType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTEncryptType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTEncryptType::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmEncryptArithmetic TMTEncryptType::type() const {
  return static_cast< ::mt::EmEncryptArithmetic >(type_);
}
inline void TMTEncryptType::set_type(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// TMTStreamMedia

// optional bool enable = 1;
inline bool TMTStreamMedia::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTStreamMedia::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTStreamMedia::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTStreamMedia::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMTStreamMedia::enable() const {
  return enable_;
}
inline void TMTStreamMedia::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional bool ForwardLocalVideo = 2;
inline bool TMTStreamMedia::has_forwardlocalvideo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTStreamMedia::set_has_forwardlocalvideo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTStreamMedia::clear_has_forwardlocalvideo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTStreamMedia::clear_forwardlocalvideo() {
  forwardlocalvideo_ = false;
  clear_has_forwardlocalvideo();
}
inline bool TMTStreamMedia::forwardlocalvideo() const {
  return forwardlocalvideo_;
}
inline void TMTStreamMedia::set_forwardlocalvideo(bool value) {
  set_has_forwardlocalvideo();
  forwardlocalvideo_ = value;
}

// optional uint32 MCIP = 3;
inline bool TMTStreamMedia::has_mcip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTStreamMedia::set_has_mcip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTStreamMedia::clear_has_mcip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTStreamMedia::clear_mcip() {
  mcip_ = 0u;
  clear_has_mcip();
}
inline ::google::protobuf::uint32 TMTStreamMedia::mcip() const {
  return mcip_;
}
inline void TMTStreamMedia::set_mcip(::google::protobuf::uint32 value) {
  set_has_mcip();
  mcip_ = value;
}

// optional uint32 Port = 4;
inline bool TMTStreamMedia::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTStreamMedia::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTStreamMedia::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTStreamMedia::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMTStreamMedia::port() const {
  return port_;
}
inline void TMTStreamMedia::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional uint32 TTL = 5;
inline bool TMTStreamMedia::has_ttl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTStreamMedia::set_has_ttl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTStreamMedia::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTStreamMedia::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 TMTStreamMedia::ttl() const {
  return ttl_;
}
inline void TMTStreamMedia::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// optional string ChannelName = 6;
inline bool TMTStreamMedia::has_channelname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTStreamMedia::set_has_channelname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTStreamMedia::clear_has_channelname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTStreamMedia::clear_channelname() {
  if (channelname_ != &::google::protobuf::internal::kEmptyString) {
    channelname_->clear();
  }
  clear_has_channelname();
}
inline const ::std::string& TMTStreamMedia::channelname() const {
  return *channelname_;
}
inline void TMTStreamMedia::set_channelname(const ::std::string& value) {
  set_has_channelname();
  if (channelname_ == &::google::protobuf::internal::kEmptyString) {
    channelname_ = new ::std::string;
  }
  channelname_->assign(value);
}
inline void TMTStreamMedia::set_channelname(const char* value) {
  set_has_channelname();
  if (channelname_ == &::google::protobuf::internal::kEmptyString) {
    channelname_ = new ::std::string;
  }
  channelname_->assign(value);
}
inline void TMTStreamMedia::set_channelname(const char* value, size_t size) {
  set_has_channelname();
  if (channelname_ == &::google::protobuf::internal::kEmptyString) {
    channelname_ = new ::std::string;
  }
  channelname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTStreamMedia::mutable_channelname() {
  set_has_channelname();
  if (channelname_ == &::google::protobuf::internal::kEmptyString) {
    channelname_ = new ::std::string;
  }
  return channelname_;
}
inline ::std::string* TMTStreamMedia::release_channelname() {
  clear_has_channelname();
  if (channelname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelname_;
    channelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTStreamMedia::set_allocated_channelname(::std::string* channelname) {
  if (channelname_ != &::google::protobuf::internal::kEmptyString) {
    delete channelname_;
  }
  if (channelname) {
    set_has_channelname();
    channelname_ = channelname;
  } else {
    clear_has_channelname();
    channelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Password = 7;
inline bool TMTStreamMedia::has_password() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTStreamMedia::set_has_password() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTStreamMedia::clear_has_password() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTStreamMedia::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTStreamMedia::password() const {
  return *password_;
}
inline void TMTStreamMedia::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTStreamMedia::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTStreamMedia::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTStreamMedia::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTStreamMedia::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTStreamMedia::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTChrmanPollScheme

// optional string name = 1;
inline bool TMTChrmanPollScheme::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTChrmanPollScheme::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTChrmanPollScheme::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTChrmanPollScheme::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTChrmanPollScheme::name() const {
  return *name_;
}
inline void TMTChrmanPollScheme::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTChrmanPollScheme::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTChrmanPollScheme::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTChrmanPollScheme::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTChrmanPollScheme::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTChrmanPollScheme::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMtPollInfo scheme = 2;
inline bool TMTChrmanPollScheme::has_scheme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTChrmanPollScheme::set_has_scheme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTChrmanPollScheme::clear_has_scheme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTChrmanPollScheme::clear_scheme() {
  if (scheme_ != NULL) scheme_->::mt::TMtPollInfo::Clear();
  clear_has_scheme();
}
inline const ::mt::TMtPollInfo& TMTChrmanPollScheme::scheme() const {
  return scheme_ != NULL ? *scheme_ : *default_instance_->scheme_;
}
inline ::mt::TMtPollInfo* TMTChrmanPollScheme::mutable_scheme() {
  set_has_scheme();
  if (scheme_ == NULL) scheme_ = new ::mt::TMtPollInfo;
  return scheme_;
}
inline ::mt::TMtPollInfo* TMTChrmanPollScheme::release_scheme() {
  clear_has_scheme();
  ::mt::TMtPollInfo* temp = scheme_;
  scheme_ = NULL;
  return temp;
}
inline void TMTChrmanPollScheme::set_allocated_scheme(::mt::TMtPollInfo* scheme) {
  delete scheme_;
  scheme_ = scheme;
  if (scheme) {
    set_has_scheme();
  } else {
    clear_has_scheme();
  }
}

// -------------------------------------------------------------------

// TMTChrmanPollSchemeList

// repeated .mt.TMTChrmanPollScheme scheme_list = 1;
inline int TMTChrmanPollSchemeList::scheme_list_size() const {
  return scheme_list_.size();
}
inline void TMTChrmanPollSchemeList::clear_scheme_list() {
  scheme_list_.Clear();
}
inline const ::mt::TMTChrmanPollScheme& TMTChrmanPollSchemeList::scheme_list(int index) const {
  return scheme_list_.Get(index);
}
inline ::mt::TMTChrmanPollScheme* TMTChrmanPollSchemeList::mutable_scheme_list(int index) {
  return scheme_list_.Mutable(index);
}
inline ::mt::TMTChrmanPollScheme* TMTChrmanPollSchemeList::add_scheme_list() {
  return scheme_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTChrmanPollScheme >&
TMTChrmanPollSchemeList::scheme_list() const {
  return scheme_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTChrmanPollScheme >*
TMTChrmanPollSchemeList::mutable_scheme_list() {
  return &scheme_list_;
}

// -------------------------------------------------------------------

// TSysHint

// optional .mt.EmHintCode hint_code = 1;
inline bool TSysHint::has_hint_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSysHint::set_has_hint_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSysHint::clear_has_hint_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSysHint::clear_hint_code() {
  hint_code_ = 0;
  clear_has_hint_code();
}
inline ::mt::EmHintCode TSysHint::hint_code() const {
  return static_cast< ::mt::EmHintCode >(hint_code_);
}
inline void TSysHint::set_hint_code(::mt::EmHintCode value) {
  assert(::mt::EmHintCode_IsValid(value));
  set_has_hint_code();
  hint_code_ = value;
}

// optional string extra_param = 2;
inline bool TSysHint::has_extra_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TSysHint::set_has_extra_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TSysHint::clear_has_extra_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TSysHint::clear_extra_param() {
  if (extra_param_ != &::google::protobuf::internal::kEmptyString) {
    extra_param_->clear();
  }
  clear_has_extra_param();
}
inline const ::std::string& TSysHint::extra_param() const {
  return *extra_param_;
}
inline void TSysHint::set_extra_param(const ::std::string& value) {
  set_has_extra_param();
  if (extra_param_ == &::google::protobuf::internal::kEmptyString) {
    extra_param_ = new ::std::string;
  }
  extra_param_->assign(value);
}
inline void TSysHint::set_extra_param(const char* value) {
  set_has_extra_param();
  if (extra_param_ == &::google::protobuf::internal::kEmptyString) {
    extra_param_ = new ::std::string;
  }
  extra_param_->assign(value);
}
inline void TSysHint::set_extra_param(const char* value, size_t size) {
  set_has_extra_param();
  if (extra_param_ == &::google::protobuf::internal::kEmptyString) {
    extra_param_ = new ::std::string;
  }
  extra_param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSysHint::mutable_extra_param() {
  set_has_extra_param();
  if (extra_param_ == &::google::protobuf::internal::kEmptyString) {
    extra_param_ = new ::std::string;
  }
  return extra_param_;
}
inline ::std::string* TSysHint::release_extra_param() {
  clear_has_extra_param();
  if (extra_param_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_param_;
    extra_param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSysHint::set_allocated_extra_param(::std::string* extra_param) {
  if (extra_param_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_param_;
  }
  if (extra_param) {
    set_has_extra_param();
    extra_param_ = extra_param;
  } else {
    clear_has_extra_param();
    extra_param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTVgaImageAdjustCfg

// optional bool vga1_filter_state = 1;
inline bool TMTVgaImageAdjustCfg::has_vga1_filter_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVgaImageAdjustCfg::set_has_vga1_filter_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVgaImageAdjustCfg::clear_has_vga1_filter_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVgaImageAdjustCfg::clear_vga1_filter_state() {
  vga1_filter_state_ = false;
  clear_has_vga1_filter_state();
}
inline bool TMTVgaImageAdjustCfg::vga1_filter_state() const {
  return vga1_filter_state_;
}
inline void TMTVgaImageAdjustCfg::set_vga1_filter_state(bool value) {
  set_has_vga1_filter_state();
  vga1_filter_state_ = value;
}

// optional uint32 vga1_phase_clock = 2;
inline bool TMTVgaImageAdjustCfg::has_vga1_phase_clock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVgaImageAdjustCfg::set_has_vga1_phase_clock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVgaImageAdjustCfg::clear_has_vga1_phase_clock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVgaImageAdjustCfg::clear_vga1_phase_clock() {
  vga1_phase_clock_ = 0u;
  clear_has_vga1_phase_clock();
}
inline ::google::protobuf::uint32 TMTVgaImageAdjustCfg::vga1_phase_clock() const {
  return vga1_phase_clock_;
}
inline void TMTVgaImageAdjustCfg::set_vga1_phase_clock(::google::protobuf::uint32 value) {
  set_has_vga1_phase_clock();
  vga1_phase_clock_ = value;
}

// optional int32 vga1_image_offset = 3;
inline bool TMTVgaImageAdjustCfg::has_vga1_image_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVgaImageAdjustCfg::set_has_vga1_image_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVgaImageAdjustCfg::clear_has_vga1_image_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVgaImageAdjustCfg::clear_vga1_image_offset() {
  vga1_image_offset_ = 0;
  clear_has_vga1_image_offset();
}
inline ::google::protobuf::int32 TMTVgaImageAdjustCfg::vga1_image_offset() const {
  return vga1_image_offset_;
}
inline void TMTVgaImageAdjustCfg::set_vga1_image_offset(::google::protobuf::int32 value) {
  set_has_vga1_image_offset();
  vga1_image_offset_ = value;
}

// optional bool vga2_filter_state = 4;
inline bool TMTVgaImageAdjustCfg::has_vga2_filter_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTVgaImageAdjustCfg::set_has_vga2_filter_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTVgaImageAdjustCfg::clear_has_vga2_filter_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTVgaImageAdjustCfg::clear_vga2_filter_state() {
  vga2_filter_state_ = false;
  clear_has_vga2_filter_state();
}
inline bool TMTVgaImageAdjustCfg::vga2_filter_state() const {
  return vga2_filter_state_;
}
inline void TMTVgaImageAdjustCfg::set_vga2_filter_state(bool value) {
  set_has_vga2_filter_state();
  vga2_filter_state_ = value;
}

// optional uint32 vga2_phase_clock = 5;
inline bool TMTVgaImageAdjustCfg::has_vga2_phase_clock() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTVgaImageAdjustCfg::set_has_vga2_phase_clock() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTVgaImageAdjustCfg::clear_has_vga2_phase_clock() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTVgaImageAdjustCfg::clear_vga2_phase_clock() {
  vga2_phase_clock_ = 0u;
  clear_has_vga2_phase_clock();
}
inline ::google::protobuf::uint32 TMTVgaImageAdjustCfg::vga2_phase_clock() const {
  return vga2_phase_clock_;
}
inline void TMTVgaImageAdjustCfg::set_vga2_phase_clock(::google::protobuf::uint32 value) {
  set_has_vga2_phase_clock();
  vga2_phase_clock_ = value;
}

// optional int32 vga2_image_offset = 6;
inline bool TMTVgaImageAdjustCfg::has_vga2_image_offset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTVgaImageAdjustCfg::set_has_vga2_image_offset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTVgaImageAdjustCfg::clear_has_vga2_image_offset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTVgaImageAdjustCfg::clear_vga2_image_offset() {
  vga2_image_offset_ = 0;
  clear_has_vga2_image_offset();
}
inline ::google::protobuf::int32 TMTVgaImageAdjustCfg::vga2_image_offset() const {
  return vga2_image_offset_;
}
inline void TMTVgaImageAdjustCfg::set_vga2_image_offset(::google::protobuf::int32 value) {
  set_has_vga2_image_offset();
  vga2_image_offset_ = value;
}

// -------------------------------------------------------------------

// TMTVideoSrcTag

// optional .mt.EmMtVideoPort video_port_id = 1;
inline bool TMTVideoSrcTag::has_video_port_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVideoSrcTag::set_has_video_port_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVideoSrcTag::clear_has_video_port_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVideoSrcTag::clear_video_port_id() {
  video_port_id_ = 0;
  clear_has_video_port_id();
}
inline ::mt::EmMtVideoPort TMTVideoSrcTag::video_port_id() const {
  return static_cast< ::mt::EmMtVideoPort >(video_port_id_);
}
inline void TMTVideoSrcTag::set_video_port_id(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  set_has_video_port_id();
  video_port_id_ = value;
}

// optional string video_port_tag = 2;
inline bool TMTVideoSrcTag::has_video_port_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVideoSrcTag::set_has_video_port_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVideoSrcTag::clear_has_video_port_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVideoSrcTag::clear_video_port_tag() {
  if (video_port_tag_ != &::google::protobuf::internal::kEmptyString) {
    video_port_tag_->clear();
  }
  clear_has_video_port_tag();
}
inline const ::std::string& TMTVideoSrcTag::video_port_tag() const {
  return *video_port_tag_;
}
inline void TMTVideoSrcTag::set_video_port_tag(const ::std::string& value) {
  set_has_video_port_tag();
  if (video_port_tag_ == &::google::protobuf::internal::kEmptyString) {
    video_port_tag_ = new ::std::string;
  }
  video_port_tag_->assign(value);
}
inline void TMTVideoSrcTag::set_video_port_tag(const char* value) {
  set_has_video_port_tag();
  if (video_port_tag_ == &::google::protobuf::internal::kEmptyString) {
    video_port_tag_ = new ::std::string;
  }
  video_port_tag_->assign(value);
}
inline void TMTVideoSrcTag::set_video_port_tag(const char* value, size_t size) {
  set_has_video_port_tag();
  if (video_port_tag_ == &::google::protobuf::internal::kEmptyString) {
    video_port_tag_ = new ::std::string;
  }
  video_port_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVideoSrcTag::mutable_video_port_tag() {
  set_has_video_port_tag();
  if (video_port_tag_ == &::google::protobuf::internal::kEmptyString) {
    video_port_tag_ = new ::std::string;
  }
  return video_port_tag_;
}
inline ::std::string* TMTVideoSrcTag::release_video_port_tag() {
  clear_has_video_port_tag();
  if (video_port_tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = video_port_tag_;
    video_port_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVideoSrcTag::set_allocated_video_port_tag(::std::string* video_port_tag) {
  if (video_port_tag_ != &::google::protobuf::internal::kEmptyString) {
    delete video_port_tag_;
  }
  if (video_port_tag) {
    set_has_video_port_tag();
    video_port_tag_ = video_port_tag;
  } else {
    clear_has_video_port_tag();
    video_port_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTVideoSrcTagList

// repeated .mt.TMTVideoSrcTag video_tag_list = 1;
inline int TMTVideoSrcTagList::video_tag_list_size() const {
  return video_tag_list_.size();
}
inline void TMTVideoSrcTagList::clear_video_tag_list() {
  video_tag_list_.Clear();
}
inline const ::mt::TMTVideoSrcTag& TMTVideoSrcTagList::video_tag_list(int index) const {
  return video_tag_list_.Get(index);
}
inline ::mt::TMTVideoSrcTag* TMTVideoSrcTagList::mutable_video_tag_list(int index) {
  return video_tag_list_.Mutable(index);
}
inline ::mt::TMTVideoSrcTag* TMTVideoSrcTagList::add_video_tag_list() {
  return video_tag_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoSrcTag >&
TMTVideoSrcTagList::video_tag_list() const {
  return video_tag_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoSrcTag >*
TMTVideoSrcTagList::mutable_video_tag_list() {
  return &video_tag_list_;
}

// -------------------------------------------------------------------

// TMTVideoOutTag

// optional .mt.EmHDVideoOutPortType video_port_id = 1;
inline bool TMTVideoOutTag::has_video_port_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVideoOutTag::set_has_video_port_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVideoOutTag::clear_has_video_port_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVideoOutTag::clear_video_port_id() {
  video_port_id_ = 0;
  clear_has_video_port_id();
}
inline ::mt::EmHDVideoOutPortType TMTVideoOutTag::video_port_id() const {
  return static_cast< ::mt::EmHDVideoOutPortType >(video_port_id_);
}
inline void TMTVideoOutTag::set_video_port_id(::mt::EmHDVideoOutPortType value) {
  assert(::mt::EmHDVideoOutPortType_IsValid(value));
  set_has_video_port_id();
  video_port_id_ = value;
}

// optional string video_port_tag = 2;
inline bool TMTVideoOutTag::has_video_port_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVideoOutTag::set_has_video_port_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVideoOutTag::clear_has_video_port_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVideoOutTag::clear_video_port_tag() {
  if (video_port_tag_ != &::google::protobuf::internal::kEmptyString) {
    video_port_tag_->clear();
  }
  clear_has_video_port_tag();
}
inline const ::std::string& TMTVideoOutTag::video_port_tag() const {
  return *video_port_tag_;
}
inline void TMTVideoOutTag::set_video_port_tag(const ::std::string& value) {
  set_has_video_port_tag();
  if (video_port_tag_ == &::google::protobuf::internal::kEmptyString) {
    video_port_tag_ = new ::std::string;
  }
  video_port_tag_->assign(value);
}
inline void TMTVideoOutTag::set_video_port_tag(const char* value) {
  set_has_video_port_tag();
  if (video_port_tag_ == &::google::protobuf::internal::kEmptyString) {
    video_port_tag_ = new ::std::string;
  }
  video_port_tag_->assign(value);
}
inline void TMTVideoOutTag::set_video_port_tag(const char* value, size_t size) {
  set_has_video_port_tag();
  if (video_port_tag_ == &::google::protobuf::internal::kEmptyString) {
    video_port_tag_ = new ::std::string;
  }
  video_port_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVideoOutTag::mutable_video_port_tag() {
  set_has_video_port_tag();
  if (video_port_tag_ == &::google::protobuf::internal::kEmptyString) {
    video_port_tag_ = new ::std::string;
  }
  return video_port_tag_;
}
inline ::std::string* TMTVideoOutTag::release_video_port_tag() {
  clear_has_video_port_tag();
  if (video_port_tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = video_port_tag_;
    video_port_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVideoOutTag::set_allocated_video_port_tag(::std::string* video_port_tag) {
  if (video_port_tag_ != &::google::protobuf::internal::kEmptyString) {
    delete video_port_tag_;
  }
  if (video_port_tag) {
    set_has_video_port_tag();
    video_port_tag_ = video_port_tag;
  } else {
    clear_has_video_port_tag();
    video_port_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTVideoOutTagList

// repeated .mt.TMTVideoOutTag video_tag_list = 1;
inline int TMTVideoOutTagList::video_tag_list_size() const {
  return video_tag_list_.size();
}
inline void TMTVideoOutTagList::clear_video_tag_list() {
  video_tag_list_.Clear();
}
inline const ::mt::TMTVideoOutTag& TMTVideoOutTagList::video_tag_list(int index) const {
  return video_tag_list_.Get(index);
}
inline ::mt::TMTVideoOutTag* TMTVideoOutTagList::mutable_video_tag_list(int index) {
  return video_tag_list_.Mutable(index);
}
inline ::mt::TMTVideoOutTag* TMTVideoOutTagList::add_video_tag_list() {
  return video_tag_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoOutTag >&
TMTVideoOutTagList::video_tag_list() const {
  return video_tag_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoOutTag >*
TMTVideoOutTagList::mutable_video_tag_list() {
  return &video_tag_list_;
}

// -------------------------------------------------------------------

// TMTSnapShotFtpCfg

// optional bool is_enable = 1;
inline bool TMTSnapShotFtpCfg::has_is_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTSnapShotFtpCfg::set_has_is_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTSnapShotFtpCfg::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTSnapShotFtpCfg::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMTSnapShotFtpCfg::is_enable() const {
  return is_enable_;
}
inline void TMTSnapShotFtpCfg::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// optional uint32 ip_addr = 2;
inline bool TMTSnapShotFtpCfg::has_ip_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTSnapShotFtpCfg::set_has_ip_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTSnapShotFtpCfg::clear_has_ip_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTSnapShotFtpCfg::clear_ip_addr() {
  ip_addr_ = 0u;
  clear_has_ip_addr();
}
inline ::google::protobuf::uint32 TMTSnapShotFtpCfg::ip_addr() const {
  return ip_addr_;
}
inline void TMTSnapShotFtpCfg::set_ip_addr(::google::protobuf::uint32 value) {
  set_has_ip_addr();
  ip_addr_ = value;
}

// optional uint32 port = 3;
inline bool TMTSnapShotFtpCfg::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTSnapShotFtpCfg::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTSnapShotFtpCfg::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTSnapShotFtpCfg::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMTSnapShotFtpCfg::port() const {
  return port_;
}
inline void TMTSnapShotFtpCfg::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string upload_path = 4;
inline bool TMTSnapShotFtpCfg::has_upload_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTSnapShotFtpCfg::set_has_upload_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTSnapShotFtpCfg::clear_has_upload_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTSnapShotFtpCfg::clear_upload_path() {
  if (upload_path_ != &::google::protobuf::internal::kEmptyString) {
    upload_path_->clear();
  }
  clear_has_upload_path();
}
inline const ::std::string& TMTSnapShotFtpCfg::upload_path() const {
  return *upload_path_;
}
inline void TMTSnapShotFtpCfg::set_upload_path(const ::std::string& value) {
  set_has_upload_path();
  if (upload_path_ == &::google::protobuf::internal::kEmptyString) {
    upload_path_ = new ::std::string;
  }
  upload_path_->assign(value);
}
inline void TMTSnapShotFtpCfg::set_upload_path(const char* value) {
  set_has_upload_path();
  if (upload_path_ == &::google::protobuf::internal::kEmptyString) {
    upload_path_ = new ::std::string;
  }
  upload_path_->assign(value);
}
inline void TMTSnapShotFtpCfg::set_upload_path(const char* value, size_t size) {
  set_has_upload_path();
  if (upload_path_ == &::google::protobuf::internal::kEmptyString) {
    upload_path_ = new ::std::string;
  }
  upload_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTSnapShotFtpCfg::mutable_upload_path() {
  set_has_upload_path();
  if (upload_path_ == &::google::protobuf::internal::kEmptyString) {
    upload_path_ = new ::std::string;
  }
  return upload_path_;
}
inline ::std::string* TMTSnapShotFtpCfg::release_upload_path() {
  clear_has_upload_path();
  if (upload_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = upload_path_;
    upload_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTSnapShotFtpCfg::set_allocated_upload_path(::std::string* upload_path) {
  if (upload_path_ != &::google::protobuf::internal::kEmptyString) {
    delete upload_path_;
  }
  if (upload_path) {
    set_has_upload_path();
    upload_path_ = upload_path;
  } else {
    clear_has_upload_path();
    upload_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string username = 5;
inline bool TMTSnapShotFtpCfg::has_username() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTSnapShotFtpCfg::set_has_username() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTSnapShotFtpCfg::clear_has_username() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTSnapShotFtpCfg::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMTSnapShotFtpCfg::username() const {
  return *username_;
}
inline void TMTSnapShotFtpCfg::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTSnapShotFtpCfg::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMTSnapShotFtpCfg::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTSnapShotFtpCfg::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMTSnapShotFtpCfg::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTSnapShotFtpCfg::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 6;
inline bool TMTSnapShotFtpCfg::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTSnapShotFtpCfg::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTSnapShotFtpCfg::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTSnapShotFtpCfg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTSnapShotFtpCfg::password() const {
  return *password_;
}
inline void TMTSnapShotFtpCfg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTSnapShotFtpCfg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTSnapShotFtpCfg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTSnapShotFtpCfg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTSnapShotFtpCfg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTSnapShotFtpCfg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TServiceInfo

// optional uint32 index = 1;
inline bool TServiceInfo::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TServiceInfo::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TServiceInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TServiceInfo::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TServiceInfo::index() const {
  return index_;
}
inline void TServiceInfo::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 mtaid = 2;
inline bool TServiceInfo::has_mtaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TServiceInfo::set_has_mtaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TServiceInfo::clear_has_mtaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TServiceInfo::clear_mtaid() {
  mtaid_ = 0u;
  clear_has_mtaid();
}
inline ::google::protobuf::uint32 TServiceInfo::mtaid() const {
  return mtaid_;
}
inline void TServiceInfo::set_mtaid(::google::protobuf::uint32 value) {
  set_has_mtaid();
  mtaid_ = value;
}

// optional string path = 3;
inline bool TServiceInfo::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TServiceInfo::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TServiceInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TServiceInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TServiceInfo::path() const {
  return *path_;
}
inline void TServiceInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TServiceInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TServiceInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TServiceInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceInfo::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sysalias = 4;
inline bool TServiceInfo::has_sysalias() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TServiceInfo::set_has_sysalias() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TServiceInfo::clear_has_sysalias() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TServiceInfo::clear_sysalias() {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    sysalias_->clear();
  }
  clear_has_sysalias();
}
inline const ::std::string& TServiceInfo::sysalias() const {
  return *sysalias_;
}
inline void TServiceInfo::set_sysalias(const ::std::string& value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TServiceInfo::set_sysalias(const char* value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TServiceInfo::set_sysalias(const char* value, size_t size) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceInfo::mutable_sysalias() {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  return sysalias_;
}
inline ::std::string* TServiceInfo::release_sysalias() {
  clear_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sysalias_;
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceInfo::set_allocated_sysalias(::std::string* sysalias) {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    delete sysalias_;
  }
  if (sysalias) {
    set_has_sysalias();
    sysalias_ = sysalias;
  } else {
    clear_has_sysalias();
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtSysStartMod startmod = 5;
inline bool TServiceInfo::has_startmod() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TServiceInfo::set_has_startmod() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TServiceInfo::clear_has_startmod() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TServiceInfo::clear_startmod() {
  startmod_ = 0;
  clear_has_startmod();
}
inline ::mt::EmMtSysStartMod TServiceInfo::startmod() const {
  return static_cast< ::mt::EmMtSysStartMod >(startmod_);
}
inline void TServiceInfo::set_startmod(::mt::EmMtSysStartMod value) {
  assert(::mt::EmMtSysStartMod_IsValid(value));
  set_has_startmod();
  startmod_ = value;
}

// optional string srtfuncname = 6;
inline bool TServiceInfo::has_srtfuncname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TServiceInfo::set_has_srtfuncname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TServiceInfo::clear_has_srtfuncname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TServiceInfo::clear_srtfuncname() {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    srtfuncname_->clear();
  }
  clear_has_srtfuncname();
}
inline const ::std::string& TServiceInfo::srtfuncname() const {
  return *srtfuncname_;
}
inline void TServiceInfo::set_srtfuncname(const ::std::string& value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TServiceInfo::set_srtfuncname(const char* value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TServiceInfo::set_srtfuncname(const char* value, size_t size) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceInfo::mutable_srtfuncname() {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  return srtfuncname_;
}
inline ::std::string* TServiceInfo::release_srtfuncname() {
  clear_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srtfuncname_;
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceInfo::set_allocated_srtfuncname(::std::string* srtfuncname) {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete srtfuncname_;
  }
  if (srtfuncname) {
    set_has_srtfuncname();
    srtfuncname_ = srtfuncname;
  } else {
    clear_has_srtfuncname();
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endfuncname = 7;
inline bool TServiceInfo::has_endfuncname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TServiceInfo::set_has_endfuncname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TServiceInfo::clear_has_endfuncname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TServiceInfo::clear_endfuncname() {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    endfuncname_->clear();
  }
  clear_has_endfuncname();
}
inline const ::std::string& TServiceInfo::endfuncname() const {
  return *endfuncname_;
}
inline void TServiceInfo::set_endfuncname(const ::std::string& value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TServiceInfo::set_endfuncname(const char* value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TServiceInfo::set_endfuncname(const char* value, size_t size) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceInfo::mutable_endfuncname() {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  return endfuncname_;
}
inline ::std::string* TServiceInfo::release_endfuncname() {
  clear_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endfuncname_;
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceInfo::set_allocated_endfuncname(::std::string* endfuncname) {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete endfuncname_;
  }
  if (endfuncname) {
    set_has_endfuncname();
    endfuncname_ = endfuncname;
  } else {
    clear_has_endfuncname();
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtSysSrvState srvstate = 8;
inline bool TServiceInfo::has_srvstate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TServiceInfo::set_has_srvstate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TServiceInfo::clear_has_srvstate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TServiceInfo::clear_srvstate() {
  srvstate_ = 0;
  clear_has_srvstate();
}
inline ::mt::EmMtSysSrvState TServiceInfo::srvstate() const {
  return static_cast< ::mt::EmMtSysSrvState >(srvstate_);
}
inline void TServiceInfo::set_srvstate(::mt::EmMtSysSrvState value) {
  assert(::mt::EmMtSysSrvState_IsValid(value));
  set_has_srvstate();
  srvstate_ = value;
}

// optional .mt.EmMtSysKeepLiveState srvklstate = 9;
inline bool TServiceInfo::has_srvklstate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TServiceInfo::set_has_srvklstate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TServiceInfo::clear_has_srvklstate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TServiceInfo::clear_srvklstate() {
  srvklstate_ = 0;
  clear_has_srvklstate();
}
inline ::mt::EmMtSysKeepLiveState TServiceInfo::srvklstate() const {
  return static_cast< ::mt::EmMtSysKeepLiveState >(srvklstate_);
}
inline void TServiceInfo::set_srvklstate(::mt::EmMtSysKeepLiveState value) {
  assert(::mt::EmMtSysKeepLiveState_IsValid(value));
  set_has_srvklstate();
  srvklstate_ = value;
}

// optional uint32 time = 10;
inline bool TServiceInfo::has_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TServiceInfo::set_has_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TServiceInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TServiceInfo::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 TServiceInfo::time() const {
  return time_;
}
inline void TServiceInfo::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional uint32 timestamp = 11;
inline bool TServiceInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TServiceInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TServiceInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TServiceInfo::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 TServiceInfo::timestamp() const {
  return timestamp_;
}
inline void TServiceInfo::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional uint32 dllhandler = 12;
inline bool TServiceInfo::has_dllhandler() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TServiceInfo::set_has_dllhandler() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TServiceInfo::clear_has_dllhandler() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TServiceInfo::clear_dllhandler() {
  dllhandler_ = 0u;
  clear_has_dllhandler();
}
inline ::google::protobuf::uint32 TServiceInfo::dllhandler() const {
  return dllhandler_;
}
inline void TServiceInfo::set_dllhandler(::google::protobuf::uint32 value) {
  set_has_dllhandler();
  dllhandler_ = value;
}

// optional uint32 processpid = 13;
inline bool TServiceInfo::has_processpid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TServiceInfo::set_has_processpid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TServiceInfo::clear_has_processpid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TServiceInfo::clear_processpid() {
  processpid_ = 0u;
  clear_has_processpid();
}
inline ::google::protobuf::uint32 TServiceInfo::processpid() const {
  return processpid_;
}
inline void TServiceInfo::set_processpid(::google::protobuf::uint32 value) {
  set_has_processpid();
  processpid_ = value;
}

// optional string version = 14;
inline bool TServiceInfo::has_version() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TServiceInfo::set_has_version() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TServiceInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TServiceInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TServiceInfo::version() const {
  return *version_;
}
inline void TServiceInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TServiceInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TServiceInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* TServiceInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TServiceInfoFromUI

// optional uint32 mtaid = 1;
inline bool TServiceInfoFromUI::has_mtaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TServiceInfoFromUI::set_has_mtaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TServiceInfoFromUI::clear_has_mtaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TServiceInfoFromUI::clear_mtaid() {
  mtaid_ = 0u;
  clear_has_mtaid();
}
inline ::google::protobuf::uint32 TServiceInfoFromUI::mtaid() const {
  return mtaid_;
}
inline void TServiceInfoFromUI::set_mtaid(::google::protobuf::uint32 value) {
  set_has_mtaid();
  mtaid_ = value;
}

// optional string path = 2;
inline bool TServiceInfoFromUI::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TServiceInfoFromUI::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TServiceInfoFromUI::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TServiceInfoFromUI::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TServiceInfoFromUI::path() const {
  return *path_;
}
inline void TServiceInfoFromUI::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TServiceInfoFromUI::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TServiceInfoFromUI::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceInfoFromUI::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TServiceInfoFromUI::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceInfoFromUI::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sysalias = 3;
inline bool TServiceInfoFromUI::has_sysalias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TServiceInfoFromUI::set_has_sysalias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TServiceInfoFromUI::clear_has_sysalias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TServiceInfoFromUI::clear_sysalias() {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    sysalias_->clear();
  }
  clear_has_sysalias();
}
inline const ::std::string& TServiceInfoFromUI::sysalias() const {
  return *sysalias_;
}
inline void TServiceInfoFromUI::set_sysalias(const ::std::string& value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TServiceInfoFromUI::set_sysalias(const char* value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TServiceInfoFromUI::set_sysalias(const char* value, size_t size) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceInfoFromUI::mutable_sysalias() {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  return sysalias_;
}
inline ::std::string* TServiceInfoFromUI::release_sysalias() {
  clear_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sysalias_;
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceInfoFromUI::set_allocated_sysalias(::std::string* sysalias) {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    delete sysalias_;
  }
  if (sysalias) {
    set_has_sysalias();
    sysalias_ = sysalias;
  } else {
    clear_has_sysalias();
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtSysStartModFromUI startmod = 4;
inline bool TServiceInfoFromUI::has_startmod() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TServiceInfoFromUI::set_has_startmod() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TServiceInfoFromUI::clear_has_startmod() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TServiceInfoFromUI::clear_startmod() {
  startmod_ = 0;
  clear_has_startmod();
}
inline ::mt::EmMtSysStartModFromUI TServiceInfoFromUI::startmod() const {
  return static_cast< ::mt::EmMtSysStartModFromUI >(startmod_);
}
inline void TServiceInfoFromUI::set_startmod(::mt::EmMtSysStartModFromUI value) {
  assert(::mt::EmMtSysStartModFromUI_IsValid(value));
  set_has_startmod();
  startmod_ = value;
}

// optional string srtfuncname = 5;
inline bool TServiceInfoFromUI::has_srtfuncname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TServiceInfoFromUI::set_has_srtfuncname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TServiceInfoFromUI::clear_has_srtfuncname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TServiceInfoFromUI::clear_srtfuncname() {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    srtfuncname_->clear();
  }
  clear_has_srtfuncname();
}
inline const ::std::string& TServiceInfoFromUI::srtfuncname() const {
  return *srtfuncname_;
}
inline void TServiceInfoFromUI::set_srtfuncname(const ::std::string& value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TServiceInfoFromUI::set_srtfuncname(const char* value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TServiceInfoFromUI::set_srtfuncname(const char* value, size_t size) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceInfoFromUI::mutable_srtfuncname() {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  return srtfuncname_;
}
inline ::std::string* TServiceInfoFromUI::release_srtfuncname() {
  clear_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srtfuncname_;
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceInfoFromUI::set_allocated_srtfuncname(::std::string* srtfuncname) {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete srtfuncname_;
  }
  if (srtfuncname) {
    set_has_srtfuncname();
    srtfuncname_ = srtfuncname;
  } else {
    clear_has_srtfuncname();
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endfuncname = 6;
inline bool TServiceInfoFromUI::has_endfuncname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TServiceInfoFromUI::set_has_endfuncname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TServiceInfoFromUI::clear_has_endfuncname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TServiceInfoFromUI::clear_endfuncname() {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    endfuncname_->clear();
  }
  clear_has_endfuncname();
}
inline const ::std::string& TServiceInfoFromUI::endfuncname() const {
  return *endfuncname_;
}
inline void TServiceInfoFromUI::set_endfuncname(const ::std::string& value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TServiceInfoFromUI::set_endfuncname(const char* value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TServiceInfoFromUI::set_endfuncname(const char* value, size_t size) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceInfoFromUI::mutable_endfuncname() {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  return endfuncname_;
}
inline ::std::string* TServiceInfoFromUI::release_endfuncname() {
  clear_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endfuncname_;
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceInfoFromUI::set_allocated_endfuncname(::std::string* endfuncname) {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete endfuncname_;
  }
  if (endfuncname) {
    set_has_endfuncname();
    endfuncname_ = endfuncname;
  } else {
    clear_has_endfuncname();
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TServiceDefInfo

// optional uint32 index = 1;
inline bool TServiceDefInfo::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TServiceDefInfo::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TServiceDefInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TServiceDefInfo::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TServiceDefInfo::index() const {
  return index_;
}
inline void TServiceDefInfo::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional string path = 2;
inline bool TServiceDefInfo::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TServiceDefInfo::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TServiceDefInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TServiceDefInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TServiceDefInfo::path() const {
  return *path_;
}
inline void TServiceDefInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TServiceDefInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TServiceDefInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceDefInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TServiceDefInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceDefInfo::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sysalias = 3;
inline bool TServiceDefInfo::has_sysalias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TServiceDefInfo::set_has_sysalias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TServiceDefInfo::clear_has_sysalias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TServiceDefInfo::clear_sysalias() {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    sysalias_->clear();
  }
  clear_has_sysalias();
}
inline const ::std::string& TServiceDefInfo::sysalias() const {
  return *sysalias_;
}
inline void TServiceDefInfo::set_sysalias(const ::std::string& value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TServiceDefInfo::set_sysalias(const char* value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TServiceDefInfo::set_sysalias(const char* value, size_t size) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceDefInfo::mutable_sysalias() {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  return sysalias_;
}
inline ::std::string* TServiceDefInfo::release_sysalias() {
  clear_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sysalias_;
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceDefInfo::set_allocated_sysalias(::std::string* sysalias) {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    delete sysalias_;
  }
  if (sysalias) {
    set_has_sysalias();
    sysalias_ = sysalias;
  } else {
    clear_has_sysalias();
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtSysStartMod startmod = 4;
inline bool TServiceDefInfo::has_startmod() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TServiceDefInfo::set_has_startmod() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TServiceDefInfo::clear_has_startmod() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TServiceDefInfo::clear_startmod() {
  startmod_ = 0;
  clear_has_startmod();
}
inline ::mt::EmMtSysStartMod TServiceDefInfo::startmod() const {
  return static_cast< ::mt::EmMtSysStartMod >(startmod_);
}
inline void TServiceDefInfo::set_startmod(::mt::EmMtSysStartMod value) {
  assert(::mt::EmMtSysStartMod_IsValid(value));
  set_has_startmod();
  startmod_ = value;
}

// optional string srtfuncname = 5;
inline bool TServiceDefInfo::has_srtfuncname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TServiceDefInfo::set_has_srtfuncname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TServiceDefInfo::clear_has_srtfuncname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TServiceDefInfo::clear_srtfuncname() {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    srtfuncname_->clear();
  }
  clear_has_srtfuncname();
}
inline const ::std::string& TServiceDefInfo::srtfuncname() const {
  return *srtfuncname_;
}
inline void TServiceDefInfo::set_srtfuncname(const ::std::string& value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TServiceDefInfo::set_srtfuncname(const char* value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TServiceDefInfo::set_srtfuncname(const char* value, size_t size) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceDefInfo::mutable_srtfuncname() {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  return srtfuncname_;
}
inline ::std::string* TServiceDefInfo::release_srtfuncname() {
  clear_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srtfuncname_;
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceDefInfo::set_allocated_srtfuncname(::std::string* srtfuncname) {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete srtfuncname_;
  }
  if (srtfuncname) {
    set_has_srtfuncname();
    srtfuncname_ = srtfuncname;
  } else {
    clear_has_srtfuncname();
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endfuncname = 6;
inline bool TServiceDefInfo::has_endfuncname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TServiceDefInfo::set_has_endfuncname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TServiceDefInfo::clear_has_endfuncname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TServiceDefInfo::clear_endfuncname() {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    endfuncname_->clear();
  }
  clear_has_endfuncname();
}
inline const ::std::string& TServiceDefInfo::endfuncname() const {
  return *endfuncname_;
}
inline void TServiceDefInfo::set_endfuncname(const ::std::string& value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TServiceDefInfo::set_endfuncname(const char* value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TServiceDefInfo::set_endfuncname(const char* value, size_t size) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TServiceDefInfo::mutable_endfuncname() {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  return endfuncname_;
}
inline ::std::string* TServiceDefInfo::release_endfuncname() {
  clear_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endfuncname_;
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TServiceDefInfo::set_allocated_endfuncname(::std::string* endfuncname) {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete endfuncname_;
  }
  if (endfuncname) {
    set_has_endfuncname();
    endfuncname_ = endfuncname;
  } else {
    clear_has_endfuncname();
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TSrvKeepLiveInfo

// optional string sysalias = 1;
inline bool TSrvKeepLiveInfo::has_sysalias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSrvKeepLiveInfo::set_has_sysalias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSrvKeepLiveInfo::clear_has_sysalias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSrvKeepLiveInfo::clear_sysalias() {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    sysalias_->clear();
  }
  clear_has_sysalias();
}
inline const ::std::string& TSrvKeepLiveInfo::sysalias() const {
  return *sysalias_;
}
inline void TSrvKeepLiveInfo::set_sysalias(const ::std::string& value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TSrvKeepLiveInfo::set_sysalias(const char* value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TSrvKeepLiveInfo::set_sysalias(const char* value, size_t size) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSrvKeepLiveInfo::mutable_sysalias() {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  return sysalias_;
}
inline ::std::string* TSrvKeepLiveInfo::release_sysalias() {
  clear_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sysalias_;
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSrvKeepLiveInfo::set_allocated_sysalias(::std::string* sysalias) {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    delete sysalias_;
  }
  if (sysalias) {
    set_has_sysalias();
    sysalias_ = sysalias;
  } else {
    clear_has_sysalias();
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 mtaid = 2;
inline bool TSrvKeepLiveInfo::has_mtaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TSrvKeepLiveInfo::set_has_mtaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TSrvKeepLiveInfo::clear_has_mtaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TSrvKeepLiveInfo::clear_mtaid() {
  mtaid_ = 0u;
  clear_has_mtaid();
}
inline ::google::protobuf::uint32 TSrvKeepLiveInfo::mtaid() const {
  return mtaid_;
}
inline void TSrvKeepLiveInfo::set_mtaid(::google::protobuf::uint32 value) {
  set_has_mtaid();
  mtaid_ = value;
}

// optional uint32 time = 3;
inline bool TSrvKeepLiveInfo::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TSrvKeepLiveInfo::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TSrvKeepLiveInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TSrvKeepLiveInfo::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 TSrvKeepLiveInfo::time() const {
  return time_;
}
inline void TSrvKeepLiveInfo::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// TMutiTServiceInfo

// repeated .mt.TServiceInfoFromUI tServiceInfo = 1;
inline int TMutiTServiceInfo::tserviceinfo_size() const {
  return tserviceinfo_.size();
}
inline void TMutiTServiceInfo::clear_tserviceinfo() {
  tserviceinfo_.Clear();
}
inline const ::mt::TServiceInfoFromUI& TMutiTServiceInfo::tserviceinfo(int index) const {
  return tserviceinfo_.Get(index);
}
inline ::mt::TServiceInfoFromUI* TMutiTServiceInfo::mutable_tserviceinfo(int index) {
  return tserviceinfo_.Mutable(index);
}
inline ::mt::TServiceInfoFromUI* TMutiTServiceInfo::add_tserviceinfo() {
  return tserviceinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TServiceInfoFromUI >&
TMutiTServiceInfo::tserviceinfo() const {
  return tserviceinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TServiceInfoFromUI >*
TMutiTServiceInfo::mutable_tserviceinfo() {
  return &tserviceinfo_;
}

// -------------------------------------------------------------------

// TMutiTServiceInfoRtData

// repeated .mt.TServiceInfo tServiceInfo = 1;
inline int TMutiTServiceInfoRtData::tserviceinfo_size() const {
  return tserviceinfo_.size();
}
inline void TMutiTServiceInfoRtData::clear_tserviceinfo() {
  tserviceinfo_.Clear();
}
inline const ::mt::TServiceInfo& TMutiTServiceInfoRtData::tserviceinfo(int index) const {
  return tserviceinfo_.Get(index);
}
inline ::mt::TServiceInfo* TMutiTServiceInfoRtData::mutable_tserviceinfo(int index) {
  return tserviceinfo_.Mutable(index);
}
inline ::mt::TServiceInfo* TMutiTServiceInfoRtData::add_tserviceinfo() {
  return tserviceinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TServiceInfo >&
TMutiTServiceInfoRtData::tserviceinfo() const {
  return tserviceinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TServiceInfo >*
TMutiTServiceInfoRtData::mutable_tserviceinfo() {
  return &tserviceinfo_;
}

// -------------------------------------------------------------------

// TMutiTServiceDefInfo

// repeated .mt.TServiceDefInfo tServiceDefInfo = 1;
inline int TMutiTServiceDefInfo::tservicedefinfo_size() const {
  return tservicedefinfo_.size();
}
inline void TMutiTServiceDefInfo::clear_tservicedefinfo() {
  tservicedefinfo_.Clear();
}
inline const ::mt::TServiceDefInfo& TMutiTServiceDefInfo::tservicedefinfo(int index) const {
  return tservicedefinfo_.Get(index);
}
inline ::mt::TServiceDefInfo* TMutiTServiceDefInfo::mutable_tservicedefinfo(int index) {
  return tservicedefinfo_.Mutable(index);
}
inline ::mt::TServiceDefInfo* TMutiTServiceDefInfo::add_tservicedefinfo() {
  return tservicedefinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TServiceDefInfo >&
TMutiTServiceDefInfo::tservicedefinfo() const {
  return tservicedefinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TServiceDefInfo >*
TMutiTServiceDefInfo::mutable_tservicedefinfo() {
  return &tservicedefinfo_;
}

// -------------------------------------------------------------------

// TUserFullInfo

// optional uint32 guid = 1;
inline bool TUserFullInfo::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TUserFullInfo::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TUserFullInfo::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TUserFullInfo::clear_guid() {
  guid_ = 0u;
  clear_has_guid();
}
inline ::google::protobuf::uint32 TUserFullInfo::guid() const {
  return guid_;
}
inline void TUserFullInfo::set_guid(::google::protobuf::uint32 value) {
  set_has_guid();
  guid_ = value;
}

// optional .mt.EmMtcType mtc_type = 2;
inline bool TUserFullInfo::has_mtc_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TUserFullInfo::set_has_mtc_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TUserFullInfo::clear_has_mtc_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TUserFullInfo::clear_mtc_type() {
  mtc_type_ = 0;
  clear_has_mtc_type();
}
inline ::mt::EmMtcType TUserFullInfo::mtc_type() const {
  return static_cast< ::mt::EmMtcType >(mtc_type_);
}
inline void TUserFullInfo::set_mtc_type(::mt::EmMtcType value) {
  assert(::mt::EmMtcType_IsValid(value));
  set_has_mtc_type();
  mtc_type_ = value;
}

// optional string user_name = 3;
inline bool TUserFullInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TUserFullInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TUserFullInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TUserFullInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TUserFullInfo::user_name() const {
  return *user_name_;
}
inline void TUserFullInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TUserFullInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TUserFullInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TUserFullInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TUserFullInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TUserFullInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 4;
inline bool TUserFullInfo::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TUserFullInfo::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TUserFullInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TUserFullInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TUserFullInfo::password() const {
  return *password_;
}
inline void TUserFullInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TUserFullInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TUserFullInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TUserFullInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TUserFullInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TUserFullInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 actor = 5;
inline bool TUserFullInfo::has_actor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TUserFullInfo::set_has_actor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TUserFullInfo::clear_has_actor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TUserFullInfo::clear_actor() {
  actor_ = 0u;
  clear_has_actor();
}
inline ::google::protobuf::uint32 TUserFullInfo::actor() const {
  return actor_;
}
inline void TUserFullInfo::set_actor(::google::protobuf::uint32 value) {
  set_has_actor();
  actor_ = value;
}

// optional string full_user_name = 6;
inline bool TUserFullInfo::has_full_user_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TUserFullInfo::set_has_full_user_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TUserFullInfo::clear_has_full_user_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TUserFullInfo::clear_full_user_name() {
  if (full_user_name_ != &::google::protobuf::internal::kEmptyString) {
    full_user_name_->clear();
  }
  clear_has_full_user_name();
}
inline const ::std::string& TUserFullInfo::full_user_name() const {
  return *full_user_name_;
}
inline void TUserFullInfo::set_full_user_name(const ::std::string& value) {
  set_has_full_user_name();
  if (full_user_name_ == &::google::protobuf::internal::kEmptyString) {
    full_user_name_ = new ::std::string;
  }
  full_user_name_->assign(value);
}
inline void TUserFullInfo::set_full_user_name(const char* value) {
  set_has_full_user_name();
  if (full_user_name_ == &::google::protobuf::internal::kEmptyString) {
    full_user_name_ = new ::std::string;
  }
  full_user_name_->assign(value);
}
inline void TUserFullInfo::set_full_user_name(const char* value, size_t size) {
  set_has_full_user_name();
  if (full_user_name_ == &::google::protobuf::internal::kEmptyString) {
    full_user_name_ = new ::std::string;
  }
  full_user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TUserFullInfo::mutable_full_user_name() {
  set_has_full_user_name();
  if (full_user_name_ == &::google::protobuf::internal::kEmptyString) {
    full_user_name_ = new ::std::string;
  }
  return full_user_name_;
}
inline ::std::string* TUserFullInfo::release_full_user_name() {
  clear_has_full_user_name();
  if (full_user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = full_user_name_;
    full_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TUserFullInfo::set_allocated_full_user_name(::std::string* full_user_name) {
  if (full_user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete full_user_name_;
  }
  if (full_user_name) {
    set_has_full_user_name();
    full_user_name_ = full_user_name;
  } else {
    clear_has_full_user_name();
    full_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_discription = 7;
inline bool TUserFullInfo::has_user_discription() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TUserFullInfo::set_has_user_discription() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TUserFullInfo::clear_has_user_discription() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TUserFullInfo::clear_user_discription() {
  if (user_discription_ != &::google::protobuf::internal::kEmptyString) {
    user_discription_->clear();
  }
  clear_has_user_discription();
}
inline const ::std::string& TUserFullInfo::user_discription() const {
  return *user_discription_;
}
inline void TUserFullInfo::set_user_discription(const ::std::string& value) {
  set_has_user_discription();
  if (user_discription_ == &::google::protobuf::internal::kEmptyString) {
    user_discription_ = new ::std::string;
  }
  user_discription_->assign(value);
}
inline void TUserFullInfo::set_user_discription(const char* value) {
  set_has_user_discription();
  if (user_discription_ == &::google::protobuf::internal::kEmptyString) {
    user_discription_ = new ::std::string;
  }
  user_discription_->assign(value);
}
inline void TUserFullInfo::set_user_discription(const char* value, size_t size) {
  set_has_user_discription();
  if (user_discription_ == &::google::protobuf::internal::kEmptyString) {
    user_discription_ = new ::std::string;
  }
  user_discription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TUserFullInfo::mutable_user_discription() {
  set_has_user_discription();
  if (user_discription_ == &::google::protobuf::internal::kEmptyString) {
    user_discription_ = new ::std::string;
  }
  return user_discription_;
}
inline ::std::string* TUserFullInfo::release_user_discription() {
  clear_has_user_discription();
  if (user_discription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_discription_;
    user_discription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TUserFullInfo::set_allocated_user_discription(::std::string* user_discription) {
  if (user_discription_ != &::google::protobuf::internal::kEmptyString) {
    delete user_discription_;
  }
  if (user_discription) {
    set_has_user_discription();
    user_discription_ = user_discription;
  } else {
    clear_has_user_discription();
    user_discription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TUserReqResult

// optional .mt.TUserFullInfo user_info = 1;
inline bool TUserReqResult::has_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TUserReqResult::set_has_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TUserReqResult::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TUserReqResult::clear_user_info() {
  if (user_info_ != NULL) user_info_->::mt::TUserFullInfo::Clear();
  clear_has_user_info();
}
inline const ::mt::TUserFullInfo& TUserReqResult::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::mt::TUserFullInfo* TUserReqResult::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::mt::TUserFullInfo;
  return user_info_;
}
inline ::mt::TUserFullInfo* TUserReqResult::release_user_info() {
  clear_has_user_info();
  ::mt::TUserFullInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void TUserReqResult::set_allocated_user_info(::mt::TUserFullInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// optional uint32 user_req_result = 2;
inline bool TUserReqResult::has_user_req_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TUserReqResult::set_has_user_req_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TUserReqResult::clear_has_user_req_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TUserReqResult::clear_user_req_result() {
  user_req_result_ = 0u;
  clear_has_user_req_result();
}
inline ::google::protobuf::uint32 TUserReqResult::user_req_result() const {
  return user_req_result_;
}
inline void TUserReqResult::set_user_req_result(::google::protobuf::uint32 value) {
  set_has_user_req_result();
  user_req_result_ = value;
}

// optional uint32 user_login_error_count = 3;
inline bool TUserReqResult::has_user_login_error_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TUserReqResult::set_has_user_login_error_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TUserReqResult::clear_has_user_login_error_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TUserReqResult::clear_user_login_error_count() {
  user_login_error_count_ = 0u;
  clear_has_user_login_error_count();
}
inline ::google::protobuf::uint32 TUserReqResult::user_login_error_count() const {
  return user_login_error_count_;
}
inline void TUserReqResult::set_user_login_error_count(::google::protobuf::uint32 value) {
  set_has_user_login_error_count();
  user_login_error_count_ = value;
}

// optional uint32 user_login_time = 4;
inline bool TUserReqResult::has_user_login_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TUserReqResult::set_has_user_login_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TUserReqResult::clear_has_user_login_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TUserReqResult::clear_user_login_time() {
  user_login_time_ = 0u;
  clear_has_user_login_time();
}
inline ::google::protobuf::uint32 TUserReqResult::user_login_time() const {
  return user_login_time_;
}
inline void TUserReqResult::set_user_login_time(::google::protobuf::uint32 value) {
  set_has_user_login_time();
  user_login_time_ = value;
}

// optional bool user_is_exist = 5;
inline bool TUserReqResult::has_user_is_exist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TUserReqResult::set_has_user_is_exist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TUserReqResult::clear_has_user_is_exist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TUserReqResult::clear_user_is_exist() {
  user_is_exist_ = false;
  clear_has_user_is_exist();
}
inline bool TUserReqResult::user_is_exist() const {
  return user_is_exist_;
}
inline void TUserReqResult::set_user_is_exist(bool value) {
  set_has_user_is_exist();
  user_is_exist_ = value;
}

// -------------------------------------------------------------------

// TMultiUserFullInfo

// repeated .mt.TUserFullInfo multi_user_info = 1;
inline int TMultiUserFullInfo::multi_user_info_size() const {
  return multi_user_info_.size();
}
inline void TMultiUserFullInfo::clear_multi_user_info() {
  multi_user_info_.Clear();
}
inline const ::mt::TUserFullInfo& TMultiUserFullInfo::multi_user_info(int index) const {
  return multi_user_info_.Get(index);
}
inline ::mt::TUserFullInfo* TMultiUserFullInfo::mutable_multi_user_info(int index) {
  return multi_user_info_.Mutable(index);
}
inline ::mt::TUserFullInfo* TMultiUserFullInfo::add_multi_user_info() {
  return multi_user_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TUserFullInfo >&
TMultiUserFullInfo::multi_user_info() const {
  return multi_user_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TUserFullInfo >*
TMultiUserFullInfo::mutable_multi_user_info() {
  return &multi_user_info_;
}

// -------------------------------------------------------------------

// TMultiUserReqResult

// repeated .mt.TUserReqResult multi_user_req_result = 1;
inline int TMultiUserReqResult::multi_user_req_result_size() const {
  return multi_user_req_result_.size();
}
inline void TMultiUserReqResult::clear_multi_user_req_result() {
  multi_user_req_result_.Clear();
}
inline const ::mt::TUserReqResult& TMultiUserReqResult::multi_user_req_result(int index) const {
  return multi_user_req_result_.Get(index);
}
inline ::mt::TUserReqResult* TMultiUserReqResult::mutable_multi_user_req_result(int index) {
  return multi_user_req_result_.Mutable(index);
}
inline ::mt::TUserReqResult* TMultiUserReqResult::add_multi_user_req_result() {
  return multi_user_req_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TUserReqResult >&
TMultiUserReqResult::multi_user_req_result() const {
  return multi_user_req_result_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TUserReqResult >*
TMultiUserReqResult::mutable_multi_user_req_result() {
  return &multi_user_req_result_;
}

// -------------------------------------------------------------------

// TMTNetBandWidth

// optional uint32 band_width = 1;
inline bool TMTNetBandWidth::has_band_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTNetBandWidth::set_has_band_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTNetBandWidth::clear_has_band_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTNetBandWidth::clear_band_width() {
  band_width_ = 0u;
  clear_has_band_width();
}
inline ::google::protobuf::uint32 TMTNetBandWidth::band_width() const {
  return band_width_;
}
inline void TMTNetBandWidth::set_band_width(::google::protobuf::uint32 value) {
  set_has_band_width();
  band_width_ = value;
}

// optional uint32 drop_rate = 2;
inline bool TMTNetBandWidth::has_drop_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTNetBandWidth::set_has_drop_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTNetBandWidth::clear_has_drop_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTNetBandWidth::clear_drop_rate() {
  drop_rate_ = 0u;
  clear_has_drop_rate();
}
inline ::google::protobuf::uint32 TMTNetBandWidth::drop_rate() const {
  return drop_rate_;
}
inline void TMTNetBandWidth::set_drop_rate(::google::protobuf::uint32 value) {
  set_has_drop_rate();
  drop_rate_ = value;
}

// -------------------------------------------------------------------

// TMTNetStatus

// optional bool is_timeout = 1;
inline bool TMTNetStatus::has_is_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTNetStatus::set_has_is_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTNetStatus::clear_has_is_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTNetStatus::clear_is_timeout() {
  is_timeout_ = false;
  clear_has_is_timeout();
}
inline bool TMTNetStatus::is_timeout() const {
  return is_timeout_;
}
inline void TMTNetStatus::set_is_timeout(bool value) {
  set_has_is_timeout();
  is_timeout_ = value;
}

// optional .mt.TMTNetBandWidth up_bandwidth_info = 2;
inline bool TMTNetStatus::has_up_bandwidth_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTNetStatus::set_has_up_bandwidth_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTNetStatus::clear_has_up_bandwidth_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTNetStatus::clear_up_bandwidth_info() {
  if (up_bandwidth_info_ != NULL) up_bandwidth_info_->::mt::TMTNetBandWidth::Clear();
  clear_has_up_bandwidth_info();
}
inline const ::mt::TMTNetBandWidth& TMTNetStatus::up_bandwidth_info() const {
  return up_bandwidth_info_ != NULL ? *up_bandwidth_info_ : *default_instance_->up_bandwidth_info_;
}
inline ::mt::TMTNetBandWidth* TMTNetStatus::mutable_up_bandwidth_info() {
  set_has_up_bandwidth_info();
  if (up_bandwidth_info_ == NULL) up_bandwidth_info_ = new ::mt::TMTNetBandWidth;
  return up_bandwidth_info_;
}
inline ::mt::TMTNetBandWidth* TMTNetStatus::release_up_bandwidth_info() {
  clear_has_up_bandwidth_info();
  ::mt::TMTNetBandWidth* temp = up_bandwidth_info_;
  up_bandwidth_info_ = NULL;
  return temp;
}
inline void TMTNetStatus::set_allocated_up_bandwidth_info(::mt::TMTNetBandWidth* up_bandwidth_info) {
  delete up_bandwidth_info_;
  up_bandwidth_info_ = up_bandwidth_info;
  if (up_bandwidth_info) {
    set_has_up_bandwidth_info();
  } else {
    clear_has_up_bandwidth_info();
  }
}

// optional .mt.TMTNetBandWidth down_bandwidth_info = 3;
inline bool TMTNetStatus::has_down_bandwidth_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTNetStatus::set_has_down_bandwidth_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTNetStatus::clear_has_down_bandwidth_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTNetStatus::clear_down_bandwidth_info() {
  if (down_bandwidth_info_ != NULL) down_bandwidth_info_->::mt::TMTNetBandWidth::Clear();
  clear_has_down_bandwidth_info();
}
inline const ::mt::TMTNetBandWidth& TMTNetStatus::down_bandwidth_info() const {
  return down_bandwidth_info_ != NULL ? *down_bandwidth_info_ : *default_instance_->down_bandwidth_info_;
}
inline ::mt::TMTNetBandWidth* TMTNetStatus::mutable_down_bandwidth_info() {
  set_has_down_bandwidth_info();
  if (down_bandwidth_info_ == NULL) down_bandwidth_info_ = new ::mt::TMTNetBandWidth;
  return down_bandwidth_info_;
}
inline ::mt::TMTNetBandWidth* TMTNetStatus::release_down_bandwidth_info() {
  clear_has_down_bandwidth_info();
  ::mt::TMTNetBandWidth* temp = down_bandwidth_info_;
  down_bandwidth_info_ = NULL;
  return temp;
}
inline void TMTNetStatus::set_allocated_down_bandwidth_info(::mt::TMTNetBandWidth* down_bandwidth_info) {
  delete down_bandwidth_info_;
  down_bandwidth_info_ = down_bandwidth_info;
  if (down_bandwidth_info) {
    set_has_down_bandwidth_info();
  } else {
    clear_has_down_bandwidth_info();
  }
}

// -------------------------------------------------------------------

// TMTPortPairInfo

// optional uint32 port_one = 1;
inline bool TMTPortPairInfo::has_port_one() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPortPairInfo::set_has_port_one() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPortPairInfo::clear_has_port_one() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPortPairInfo::clear_port_one() {
  port_one_ = 0u;
  clear_has_port_one();
}
inline ::google::protobuf::uint32 TMTPortPairInfo::port_one() const {
  return port_one_;
}
inline void TMTPortPairInfo::set_port_one(::google::protobuf::uint32 value) {
  set_has_port_one();
  port_one_ = value;
}

// optional uint32 port_two = 2;
inline bool TMTPortPairInfo::has_port_two() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPortPairInfo::set_has_port_two() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPortPairInfo::clear_has_port_two() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPortPairInfo::clear_port_two() {
  port_two_ = 0u;
  clear_has_port_two();
}
inline ::google::protobuf::uint32 TMTPortPairInfo::port_two() const {
  return port_two_;
}
inline void TMTPortPairInfo::set_port_two(::google::protobuf::uint32 value) {
  set_has_port_two();
  port_two_ = value;
}

// optional string describe = 3;
inline bool TMTPortPairInfo::has_describe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPortPairInfo::set_has_describe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPortPairInfo::clear_has_describe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPortPairInfo::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& TMTPortPairInfo::describe() const {
  return *describe_;
}
inline void TMTPortPairInfo::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TMTPortPairInfo::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TMTPortPairInfo::set_describe(const char* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPortPairInfo::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* TMTPortPairInfo::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPortPairInfo::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTPortPairAllocReqInfo

// optional bool is_tcp_port = 1;
inline bool TMTPortPairAllocReqInfo::has_is_tcp_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPortPairAllocReqInfo::set_has_is_tcp_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPortPairAllocReqInfo::clear_has_is_tcp_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPortPairAllocReqInfo::clear_is_tcp_port() {
  is_tcp_port_ = false;
  clear_has_is_tcp_port();
}
inline bool TMTPortPairAllocReqInfo::is_tcp_port() const {
  return is_tcp_port_;
}
inline void TMTPortPairAllocReqInfo::set_is_tcp_port(bool value) {
  set_has_is_tcp_port();
  is_tcp_port_ = value;
}

// optional uint32 port_pair_num = 2;
inline bool TMTPortPairAllocReqInfo::has_port_pair_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPortPairAllocReqInfo::set_has_port_pair_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPortPairAllocReqInfo::clear_has_port_pair_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPortPairAllocReqInfo::clear_port_pair_num() {
  port_pair_num_ = 0u;
  clear_has_port_pair_num();
}
inline ::google::protobuf::uint32 TMTPortPairAllocReqInfo::port_pair_num() const {
  return port_pair_num_;
}
inline void TMTPortPairAllocReqInfo::set_port_pair_num(::google::protobuf::uint32 value) {
  set_has_port_pair_num();
  port_pair_num_ = value;
}

// optional string describe = 3;
inline bool TMTPortPairAllocReqInfo::has_describe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPortPairAllocReqInfo::set_has_describe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPortPairAllocReqInfo::clear_has_describe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPortPairAllocReqInfo::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& TMTPortPairAllocReqInfo::describe() const {
  return *describe_;
}
inline void TMTPortPairAllocReqInfo::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TMTPortPairAllocReqInfo::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TMTPortPairAllocReqInfo::set_describe(const char* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPortPairAllocReqInfo::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* TMTPortPairAllocReqInfo::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPortPairAllocReqInfo::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTPortRangeAllocReqInfo

// optional bool is_tcp_port = 1;
inline bool TMTPortRangeAllocReqInfo::has_is_tcp_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPortRangeAllocReqInfo::set_has_is_tcp_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPortRangeAllocReqInfo::clear_has_is_tcp_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPortRangeAllocReqInfo::clear_is_tcp_port() {
  is_tcp_port_ = false;
  clear_has_is_tcp_port();
}
inline bool TMTPortRangeAllocReqInfo::is_tcp_port() const {
  return is_tcp_port_;
}
inline void TMTPortRangeAllocReqInfo::set_is_tcp_port(bool value) {
  set_has_is_tcp_port();
  is_tcp_port_ = value;
}

// optional uint32 port_num = 2;
inline bool TMTPortRangeAllocReqInfo::has_port_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPortRangeAllocReqInfo::set_has_port_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPortRangeAllocReqInfo::clear_has_port_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPortRangeAllocReqInfo::clear_port_num() {
  port_num_ = 0u;
  clear_has_port_num();
}
inline ::google::protobuf::uint32 TMTPortRangeAllocReqInfo::port_num() const {
  return port_num_;
}
inline void TMTPortRangeAllocReqInfo::set_port_num(::google::protobuf::uint32 value) {
  set_has_port_num();
  port_num_ = value;
}

// optional bool is_from_even_bgning = 3;
inline bool TMTPortRangeAllocReqInfo::has_is_from_even_bgning() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPortRangeAllocReqInfo::set_has_is_from_even_bgning() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPortRangeAllocReqInfo::clear_has_is_from_even_bgning() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPortRangeAllocReqInfo::clear_is_from_even_bgning() {
  is_from_even_bgning_ = false;
  clear_has_is_from_even_bgning();
}
inline bool TMTPortRangeAllocReqInfo::is_from_even_bgning() const {
  return is_from_even_bgning_;
}
inline void TMTPortRangeAllocReqInfo::set_is_from_even_bgning(bool value) {
  set_has_is_from_even_bgning();
  is_from_even_bgning_ = value;
}

// optional string describe = 4;
inline bool TMTPortRangeAllocReqInfo::has_describe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPortRangeAllocReqInfo::set_has_describe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPortRangeAllocReqInfo::clear_has_describe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPortRangeAllocReqInfo::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& TMTPortRangeAllocReqInfo::describe() const {
  return *describe_;
}
inline void TMTPortRangeAllocReqInfo::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TMTPortRangeAllocReqInfo::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TMTPortRangeAllocReqInfo::set_describe(const char* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPortRangeAllocReqInfo::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* TMTPortRangeAllocReqInfo::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPortRangeAllocReqInfo::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTPortPairAllocRspInfo

// optional bool is_ok = 1;
inline bool TMTPortPairAllocRspInfo::has_is_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPortPairAllocRspInfo::set_has_is_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPortPairAllocRspInfo::clear_has_is_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPortPairAllocRspInfo::clear_is_ok() {
  is_ok_ = false;
  clear_has_is_ok();
}
inline bool TMTPortPairAllocRspInfo::is_ok() const {
  return is_ok_;
}
inline void TMTPortPairAllocRspInfo::set_is_ok(bool value) {
  set_has_is_ok();
  is_ok_ = value;
}

// repeated .mt.TMTPortPairInfo port_pair = 2;
inline int TMTPortPairAllocRspInfo::port_pair_size() const {
  return port_pair_.size();
}
inline void TMTPortPairAllocRspInfo::clear_port_pair() {
  port_pair_.Clear();
}
inline const ::mt::TMTPortPairInfo& TMTPortPairAllocRspInfo::port_pair(int index) const {
  return port_pair_.Get(index);
}
inline ::mt::TMTPortPairInfo* TMTPortPairAllocRspInfo::mutable_port_pair(int index) {
  return port_pair_.Mutable(index);
}
inline ::mt::TMTPortPairInfo* TMTPortPairAllocRspInfo::add_port_pair() {
  return port_pair_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPortPairInfo >&
TMTPortPairAllocRspInfo::port_pair() const {
  return port_pair_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPortPairInfo >*
TMTPortPairAllocRspInfo::mutable_port_pair() {
  return &port_pair_;
}

// -------------------------------------------------------------------

// TMTPortRangeAllocRspInfo

// optional bool is_ok = 1;
inline bool TMTPortRangeAllocRspInfo::has_is_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPortRangeAllocRspInfo::set_has_is_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPortRangeAllocRspInfo::clear_has_is_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPortRangeAllocRspInfo::clear_is_ok() {
  is_ok_ = false;
  clear_has_is_ok();
}
inline bool TMTPortRangeAllocRspInfo::is_ok() const {
  return is_ok_;
}
inline void TMTPortRangeAllocRspInfo::set_is_ok(bool value) {
  set_has_is_ok();
  is_ok_ = value;
}

// optional uint32 start_port = 2;
inline bool TMTPortRangeAllocRspInfo::has_start_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPortRangeAllocRspInfo::set_has_start_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPortRangeAllocRspInfo::clear_has_start_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPortRangeAllocRspInfo::clear_start_port() {
  start_port_ = 0u;
  clear_has_start_port();
}
inline ::google::protobuf::uint32 TMTPortRangeAllocRspInfo::start_port() const {
  return start_port_;
}
inline void TMTPortRangeAllocRspInfo::set_start_port(::google::protobuf::uint32 value) {
  set_has_start_port();
  start_port_ = value;
}

// optional uint32 end_port = 3;
inline bool TMTPortRangeAllocRspInfo::has_end_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPortRangeAllocRspInfo::set_has_end_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPortRangeAllocRspInfo::clear_has_end_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPortRangeAllocRspInfo::clear_end_port() {
  end_port_ = 0u;
  clear_has_end_port();
}
inline ::google::protobuf::uint32 TMTPortRangeAllocRspInfo::end_port() const {
  return end_port_;
}
inline void TMTPortRangeAllocRspInfo::set_end_port(::google::protobuf::uint32 value) {
  set_has_end_port();
  end_port_ = value;
}

// optional string describe = 4;
inline bool TMTPortRangeAllocRspInfo::has_describe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTPortRangeAllocRspInfo::set_has_describe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTPortRangeAllocRspInfo::clear_has_describe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTPortRangeAllocRspInfo::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& TMTPortRangeAllocRspInfo::describe() const {
  return *describe_;
}
inline void TMTPortRangeAllocRspInfo::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TMTPortRangeAllocRspInfo::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TMTPortRangeAllocRspInfo::set_describe(const char* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPortRangeAllocRspInfo::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* TMTPortRangeAllocRspInfo::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPortRangeAllocRspInfo::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTSymboPoint

// optional uint32 x = 1;
inline bool TMTSymboPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTSymboPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTSymboPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTSymboPoint::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 TMTSymboPoint::x() const {
  return x_;
}
inline void TMTSymboPoint::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
}

// optional uint32 y = 2;
inline bool TMTSymboPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTSymboPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTSymboPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTSymboPoint::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 TMTSymboPoint::y() const {
  return y_;
}
inline void TMTSymboPoint::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// TMTOsdCfg

// optional bool is_auto_pip = 1;
inline bool TMTOsdCfg::has_is_auto_pip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTOsdCfg::set_has_is_auto_pip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTOsdCfg::clear_has_is_auto_pip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTOsdCfg::clear_is_auto_pip() {
  is_auto_pip_ = false;
  clear_has_is_auto_pip();
}
inline bool TMTOsdCfg::is_auto_pip() const {
  return is_auto_pip_;
}
inline void TMTOsdCfg::set_is_auto_pip(bool value) {
  set_has_is_auto_pip();
  is_auto_pip_ = value;
}

// optional bool is_show_conf_lapse = 2;
inline bool TMTOsdCfg::has_is_show_conf_lapse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTOsdCfg::set_has_is_show_conf_lapse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTOsdCfg::clear_has_is_show_conf_lapse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTOsdCfg::clear_is_show_conf_lapse() {
  is_show_conf_lapse_ = false;
  clear_has_is_show_conf_lapse();
}
inline bool TMTOsdCfg::is_show_conf_lapse() const {
  return is_show_conf_lapse_;
}
inline void TMTOsdCfg::set_is_show_conf_lapse(bool value) {
  set_has_is_show_conf_lapse();
  is_show_conf_lapse_ = value;
}

// optional bool is_show_sys_time = 3;
inline bool TMTOsdCfg::has_is_show_sys_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTOsdCfg::set_has_is_show_sys_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTOsdCfg::clear_has_is_show_sys_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTOsdCfg::clear_is_show_sys_time() {
  is_show_sys_time_ = false;
  clear_has_is_show_sys_time();
}
inline bool TMTOsdCfg::is_show_sys_time() const {
  return is_show_sys_time_;
}
inline void TMTOsdCfg::set_is_show_sys_time(bool value) {
  set_has_is_show_sys_time();
  is_show_sys_time_ = value;
}

// optional bool is_show_state = 4;
inline bool TMTOsdCfg::has_is_show_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTOsdCfg::set_has_is_show_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTOsdCfg::clear_has_is_show_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTOsdCfg::clear_is_show_state() {
  is_show_state_ = false;
  clear_has_is_show_state();
}
inline bool TMTOsdCfg::is_show_state() const {
  return is_show_state_;
}
inline void TMTOsdCfg::set_is_show_state(bool value) {
  set_has_is_show_state();
  is_show_state_ = value;
}

// optional .mt.EmLabelType label_type = 5;
inline bool TMTOsdCfg::has_label_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTOsdCfg::set_has_label_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTOsdCfg::clear_has_label_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTOsdCfg::clear_label_type() {
  label_type_ = 0;
  clear_has_label_type();
}
inline ::mt::EmLabelType TMTOsdCfg::label_type() const {
  return static_cast< ::mt::EmLabelType >(label_type_);
}
inline void TMTOsdCfg::set_label_type(::mt::EmLabelType value) {
  assert(::mt::EmLabelType_IsValid(value));
  set_has_label_type();
  label_type_ = value;
}

// optional .mt.TMTSymboPoint label_coordinate = 6;
inline bool TMTOsdCfg::has_label_coordinate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTOsdCfg::set_has_label_coordinate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTOsdCfg::clear_has_label_coordinate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTOsdCfg::clear_label_coordinate() {
  if (label_coordinate_ != NULL) label_coordinate_->::mt::TMTSymboPoint::Clear();
  clear_has_label_coordinate();
}
inline const ::mt::TMTSymboPoint& TMTOsdCfg::label_coordinate() const {
  return label_coordinate_ != NULL ? *label_coordinate_ : *default_instance_->label_coordinate_;
}
inline ::mt::TMTSymboPoint* TMTOsdCfg::mutable_label_coordinate() {
  set_has_label_coordinate();
  if (label_coordinate_ == NULL) label_coordinate_ = new ::mt::TMTSymboPoint;
  return label_coordinate_;
}
inline ::mt::TMTSymboPoint* TMTOsdCfg::release_label_coordinate() {
  clear_has_label_coordinate();
  ::mt::TMTSymboPoint* temp = label_coordinate_;
  label_coordinate_ = NULL;
  return temp;
}
inline void TMTOsdCfg::set_allocated_label_coordinate(::mt::TMTSymboPoint* label_coordinate) {
  delete label_coordinate_;
  label_coordinate_ = label_coordinate;
  if (label_coordinate) {
    set_has_label_coordinate();
  } else {
    clear_has_label_coordinate();
  }
}

// optional .mt.EmLabelPosType label_pos_type = 7;
inline bool TMTOsdCfg::has_label_pos_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTOsdCfg::set_has_label_pos_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTOsdCfg::clear_has_label_pos_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTOsdCfg::clear_label_pos_type() {
  label_pos_type_ = 0;
  clear_has_label_pos_type();
}
inline ::mt::EmLabelPosType TMTOsdCfg::label_pos_type() const {
  return static_cast< ::mt::EmLabelPosType >(label_pos_type_);
}
inline void TMTOsdCfg::set_label_pos_type(::mt::EmLabelPosType value) {
  assert(::mt::EmLabelPosType_IsValid(value));
  set_has_label_pos_type();
  label_pos_type_ = value;
}

// optional .mt.EmDualVideoShowMode dual_show_mode = 8;
inline bool TMTOsdCfg::has_dual_show_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTOsdCfg::set_has_dual_show_mode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTOsdCfg::clear_has_dual_show_mode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTOsdCfg::clear_dual_show_mode() {
  dual_show_mode_ = 1;
  clear_has_dual_show_mode();
}
inline ::mt::EmDualVideoShowMode TMTOsdCfg::dual_show_mode() const {
  return static_cast< ::mt::EmDualVideoShowMode >(dual_show_mode_);
}
inline void TMTOsdCfg::set_dual_show_mode(::mt::EmDualVideoShowMode value) {
  assert(::mt::EmDualVideoShowMode_IsValid(value));
  set_has_dual_show_mode();
  dual_show_mode_ = value;
}

// optional .mt.EmDisplayRatio pri_display_ratio = 9;
inline bool TMTOsdCfg::has_pri_display_ratio() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTOsdCfg::set_has_pri_display_ratio() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTOsdCfg::clear_has_pri_display_ratio() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTOsdCfg::clear_pri_display_ratio() {
  pri_display_ratio_ = 0;
  clear_has_pri_display_ratio();
}
inline ::mt::EmDisplayRatio TMTOsdCfg::pri_display_ratio() const {
  return static_cast< ::mt::EmDisplayRatio >(pri_display_ratio_);
}
inline void TMTOsdCfg::set_pri_display_ratio(::mt::EmDisplayRatio value) {
  assert(::mt::EmDisplayRatio_IsValid(value));
  set_has_pri_display_ratio();
  pri_display_ratio_ = value;
}

// optional .mt.EmDisplayRatio sec_display_ratio = 10;
inline bool TMTOsdCfg::has_sec_display_ratio() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTOsdCfg::set_has_sec_display_ratio() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTOsdCfg::clear_has_sec_display_ratio() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTOsdCfg::clear_sec_display_ratio() {
  sec_display_ratio_ = 0;
  clear_has_sec_display_ratio();
}
inline ::mt::EmDisplayRatio TMTOsdCfg::sec_display_ratio() const {
  return static_cast< ::mt::EmDisplayRatio >(sec_display_ratio_);
}
inline void TMTOsdCfg::set_sec_display_ratio(::mt::EmDisplayRatio value) {
  assert(::mt::EmDisplayRatio_IsValid(value));
  set_has_sec_display_ratio();
  sec_display_ratio_ = value;
}

// -------------------------------------------------------------------

// TMtAsymmetricNetInfo

// optional bool is_enable = 1;
inline bool TMtAsymmetricNetInfo::has_is_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAsymmetricNetInfo::set_has_is_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAsymmetricNetInfo::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAsymmetricNetInfo::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMtAsymmetricNetInfo::is_enable() const {
  return is_enable_;
}
inline void TMtAsymmetricNetInfo::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// optional uint32 up_link_rate = 2;
inline bool TMtAsymmetricNetInfo::has_up_link_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAsymmetricNetInfo::set_has_up_link_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAsymmetricNetInfo::clear_has_up_link_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAsymmetricNetInfo::clear_up_link_rate() {
  up_link_rate_ = 0u;
  clear_has_up_link_rate();
}
inline ::google::protobuf::uint32 TMtAsymmetricNetInfo::up_link_rate() const {
  return up_link_rate_;
}
inline void TMtAsymmetricNetInfo::set_up_link_rate(::google::protobuf::uint32 value) {
  set_has_up_link_rate();
  up_link_rate_ = value;
}

// optional uint32 down_link_rate = 3;
inline bool TMtAsymmetricNetInfo::has_down_link_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtAsymmetricNetInfo::set_has_down_link_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtAsymmetricNetInfo::clear_has_down_link_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtAsymmetricNetInfo::clear_down_link_rate() {
  down_link_rate_ = 0u;
  clear_has_down_link_rate();
}
inline ::google::protobuf::uint32 TMtAsymmetricNetInfo::down_link_rate() const {
  return down_link_rate_;
}
inline void TMtAsymmetricNetInfo::set_down_link_rate(::google::protobuf::uint32 value) {
  set_has_down_link_rate();
  down_link_rate_ = value;
}

// -------------------------------------------------------------------

// TMTMcRSParam

// optional uint32 first_time_span = 1 [default = 40];
inline bool TMTMcRSParam::has_first_time_span() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTMcRSParam::set_has_first_time_span() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTMcRSParam::clear_has_first_time_span() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTMcRSParam::clear_first_time_span() {
  first_time_span_ = 40u;
  clear_has_first_time_span();
}
inline ::google::protobuf::uint32 TMTMcRSParam::first_time_span() const {
  return first_time_span_;
}
inline void TMTMcRSParam::set_first_time_span(::google::protobuf::uint32 value) {
  set_has_first_time_span();
  first_time_span_ = value;
}

// optional uint32 second_time_span = 2 [default = 2000];
inline bool TMTMcRSParam::has_second_time_span() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTMcRSParam::set_has_second_time_span() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTMcRSParam::clear_has_second_time_span() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTMcRSParam::clear_second_time_span() {
  second_time_span_ = 2000u;
  clear_has_second_time_span();
}
inline ::google::protobuf::uint32 TMTMcRSParam::second_time_span() const {
  return second_time_span_;
}
inline void TMTMcRSParam::set_second_time_span(::google::protobuf::uint32 value) {
  set_has_second_time_span();
  second_time_span_ = value;
}

// optional uint32 third_time_span = 3 [default = 0];
inline bool TMTMcRSParam::has_third_time_span() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTMcRSParam::set_has_third_time_span() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTMcRSParam::clear_has_third_time_span() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTMcRSParam::clear_third_time_span() {
  third_time_span_ = 0u;
  clear_has_third_time_span();
}
inline ::google::protobuf::uint32 TMTMcRSParam::third_time_span() const {
  return third_time_span_;
}
inline void TMTMcRSParam::set_third_time_span(::google::protobuf::uint32 value) {
  set_has_third_time_span();
  third_time_span_ = value;
}

// optional uint32 reject_time_span = 4 [default = 0];
inline bool TMTMcRSParam::has_reject_time_span() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTMcRSParam::set_has_reject_time_span() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTMcRSParam::clear_has_reject_time_span() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTMcRSParam::clear_reject_time_span() {
  reject_time_span_ = 0u;
  clear_has_reject_time_span();
}
inline ::google::protobuf::uint32 TMTMcRSParam::reject_time_span() const {
  return reject_time_span_;
}
inline void TMTMcRSParam::set_reject_time_span(::google::protobuf::uint32 value) {
  set_has_reject_time_span();
  reject_time_span_ = value;
}

// -------------------------------------------------------------------

// TMTQosParam

// optional uint32 signalling = 1;
inline bool TMTQosParam::has_signalling() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTQosParam::set_has_signalling() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTQosParam::clear_has_signalling() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTQosParam::clear_signalling() {
  signalling_ = 0u;
  clear_has_signalling();
}
inline ::google::protobuf::uint32 TMTQosParam::signalling() const {
  return signalling_;
}
inline void TMTQosParam::set_signalling(::google::protobuf::uint32 value) {
  set_has_signalling();
  signalling_ = value;
}

// optional uint32 data = 2;
inline bool TMTQosParam::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTQosParam::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTQosParam::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTQosParam::clear_data() {
  data_ = 0u;
  clear_has_data();
}
inline ::google::protobuf::uint32 TMTQosParam::data() const {
  return data_;
}
inline void TMTQosParam::set_data(::google::protobuf::uint32 value) {
  set_has_data();
  data_ = value;
}

// optional uint32 audio = 3;
inline bool TMTQosParam::has_audio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTQosParam::set_has_audio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTQosParam::clear_has_audio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTQosParam::clear_audio() {
  audio_ = 0u;
  clear_has_audio();
}
inline ::google::protobuf::uint32 TMTQosParam::audio() const {
  return audio_;
}
inline void TMTQosParam::set_audio(::google::protobuf::uint32 value) {
  set_has_audio();
  audio_ = value;
}

// optional uint32 video = 4;
inline bool TMTQosParam::has_video() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTQosParam::set_has_video() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTQosParam::clear_has_video() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTQosParam::clear_video() {
  video_ = 0u;
  clear_has_video();
}
inline ::google::protobuf::uint32 TMTQosParam::video() const {
  return video_;
}
inline void TMTQosParam::set_video(::google::protobuf::uint32 value) {
  set_has_video();
  video_ = value;
}

// -------------------------------------------------------------------

// TMTIPQoS

// optional .mt.EmQoS qos_type = 1;
inline bool TMTIPQoS::has_qos_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTIPQoS::set_has_qos_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTIPQoS::clear_has_qos_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTIPQoS::clear_qos_type() {
  qos_type_ = 0;
  clear_has_qos_type();
}
inline ::mt::EmQoS TMTIPQoS::qos_type() const {
  return static_cast< ::mt::EmQoS >(qos_type_);
}
inline void TMTIPQoS::set_qos_type(::mt::EmQoS value) {
  assert(::mt::EmQoS_IsValid(value));
  set_has_qos_type();
  qos_type_ = value;
}

// optional .mt.EmTOS tos_type = 2;
inline bool TMTIPQoS::has_tos_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTIPQoS::set_has_tos_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTIPQoS::clear_has_tos_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTIPQoS::clear_tos_type() {
  tos_type_ = 0;
  clear_has_tos_type();
}
inline ::mt::EmTOS TMTIPQoS::tos_type() const {
  return static_cast< ::mt::EmTOS >(tos_type_);
}
inline void TMTIPQoS::set_tos_type(::mt::EmTOS value) {
  assert(::mt::EmTOS_IsValid(value));
  set_has_tos_type();
  tos_type_ = value;
}

// optional .mt.TMTQosParam param_diff_service = 3;
inline bool TMTIPQoS::has_param_diff_service() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTIPQoS::set_has_param_diff_service() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTIPQoS::clear_has_param_diff_service() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTIPQoS::clear_param_diff_service() {
  if (param_diff_service_ != NULL) param_diff_service_->::mt::TMTQosParam::Clear();
  clear_has_param_diff_service();
}
inline const ::mt::TMTQosParam& TMTIPQoS::param_diff_service() const {
  return param_diff_service_ != NULL ? *param_diff_service_ : *default_instance_->param_diff_service_;
}
inline ::mt::TMTQosParam* TMTIPQoS::mutable_param_diff_service() {
  set_has_param_diff_service();
  if (param_diff_service_ == NULL) param_diff_service_ = new ::mt::TMTQosParam;
  return param_diff_service_;
}
inline ::mt::TMTQosParam* TMTIPQoS::release_param_diff_service() {
  clear_has_param_diff_service();
  ::mt::TMTQosParam* temp = param_diff_service_;
  param_diff_service_ = NULL;
  return temp;
}
inline void TMTIPQoS::set_allocated_param_diff_service(::mt::TMTQosParam* param_diff_service) {
  delete param_diff_service_;
  param_diff_service_ = param_diff_service;
  if (param_diff_service) {
    set_has_param_diff_service();
  } else {
    clear_has_param_diff_service();
  }
}

// optional .mt.TMTQosParam param_ip_precedence = 4;
inline bool TMTIPQoS::has_param_ip_precedence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTIPQoS::set_has_param_ip_precedence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTIPQoS::clear_has_param_ip_precedence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTIPQoS::clear_param_ip_precedence() {
  if (param_ip_precedence_ != NULL) param_ip_precedence_->::mt::TMTQosParam::Clear();
  clear_has_param_ip_precedence();
}
inline const ::mt::TMTQosParam& TMTIPQoS::param_ip_precedence() const {
  return param_ip_precedence_ != NULL ? *param_ip_precedence_ : *default_instance_->param_ip_precedence_;
}
inline ::mt::TMTQosParam* TMTIPQoS::mutable_param_ip_precedence() {
  set_has_param_ip_precedence();
  if (param_ip_precedence_ == NULL) param_ip_precedence_ = new ::mt::TMTQosParam;
  return param_ip_precedence_;
}
inline ::mt::TMTQosParam* TMTIPQoS::release_param_ip_precedence() {
  clear_has_param_ip_precedence();
  ::mt::TMTQosParam* temp = param_ip_precedence_;
  param_ip_precedence_ = NULL;
  return temp;
}
inline void TMTIPQoS::set_allocated_param_ip_precedence(::mt::TMTQosParam* param_ip_precedence) {
  delete param_ip_precedence_;
  param_ip_precedence_ = param_ip_precedence;
  if (param_ip_precedence) {
    set_has_param_ip_precedence();
  } else {
    clear_has_param_ip_precedence();
  }
}

// -------------------------------------------------------------------

// TMTFecInfo

// optional bool is_enable = 1;
inline bool TMTFecInfo::has_is_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTFecInfo::set_has_is_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTFecInfo::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTFecInfo::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMTFecInfo::is_enable() const {
  return is_enable_;
}
inline void TMTFecInfo::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// optional uint32 fec_type = 2;
inline bool TMTFecInfo::has_fec_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTFecInfo::set_has_fec_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTFecInfo::clear_has_fec_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTFecInfo::clear_fec_type() {
  fec_type_ = 0u;
  clear_has_fec_type();
}
inline ::google::protobuf::uint32 TMTFecInfo::fec_type() const {
  return fec_type_;
}
inline void TMTFecInfo::set_fec_type(::google::protobuf::uint32 value) {
  set_has_fec_type();
  fec_type_ = value;
}

// optional uint32 pack_len = 3;
inline bool TMTFecInfo::has_pack_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTFecInfo::set_has_pack_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTFecInfo::clear_has_pack_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTFecInfo::clear_pack_len() {
  pack_len_ = 0u;
  clear_has_pack_len();
}
inline ::google::protobuf::uint32 TMTFecInfo::pack_len() const {
  return pack_len_;
}
inline void TMTFecInfo::set_pack_len(::google::protobuf::uint32 value) {
  set_has_pack_len();
  pack_len_ = value;
}

// optional bool is_intra_frame = 4;
inline bool TMTFecInfo::has_is_intra_frame() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTFecInfo::set_has_is_intra_frame() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTFecInfo::clear_has_is_intra_frame() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTFecInfo::clear_is_intra_frame() {
  is_intra_frame_ = false;
  clear_has_is_intra_frame();
}
inline bool TMTFecInfo::is_intra_frame() const {
  return is_intra_frame_;
}
inline void TMTFecInfo::set_is_intra_frame(bool value) {
  set_has_is_intra_frame();
  is_intra_frame_ = value;
}

// optional uint32 data_pack_num = 5;
inline bool TMTFecInfo::has_data_pack_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTFecInfo::set_has_data_pack_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTFecInfo::clear_has_data_pack_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTFecInfo::clear_data_pack_num() {
  data_pack_num_ = 0u;
  clear_has_data_pack_num();
}
inline ::google::protobuf::uint32 TMTFecInfo::data_pack_num() const {
  return data_pack_num_;
}
inline void TMTFecInfo::set_data_pack_num(::google::protobuf::uint32 value) {
  set_has_data_pack_num();
  data_pack_num_ = value;
}

// optional uint32 crc_pack_num = 6;
inline bool TMTFecInfo::has_crc_pack_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTFecInfo::set_has_crc_pack_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTFecInfo::clear_has_crc_pack_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTFecInfo::clear_crc_pack_num() {
  crc_pack_num_ = 0u;
  clear_has_crc_pack_num();
}
inline ::google::protobuf::uint32 TMTFecInfo::crc_pack_num() const {
  return crc_pack_num_;
}
inline void TMTFecInfo::set_crc_pack_num(::google::protobuf::uint32 value) {
  set_has_crc_pack_num();
  crc_pack_num_ = value;
}

// -------------------------------------------------------------------

// TStreamInfo

// optional uint32 stream_id = 1;
inline bool TStreamInfo::has_stream_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TStreamInfo::set_has_stream_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TStreamInfo::clear_has_stream_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TStreamInfo::clear_stream_id() {
  stream_id_ = 0u;
  clear_has_stream_id();
}
inline ::google::protobuf::uint32 TStreamInfo::stream_id() const {
  return stream_id_;
}
inline void TStreamInfo::set_stream_id(::google::protobuf::uint32 value) {
  set_has_stream_id();
  stream_id_ = value;
}

// optional .mt.EmMtChanType stream_type = 2;
inline bool TStreamInfo::has_stream_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TStreamInfo::set_has_stream_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TStreamInfo::clear_has_stream_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TStreamInfo::clear_stream_type() {
  stream_type_ = 0;
  clear_has_stream_type();
}
inline ::mt::EmMtChanType TStreamInfo::stream_type() const {
  return static_cast< ::mt::EmMtChanType >(stream_type_);
}
inline void TStreamInfo::set_stream_type(::mt::EmMtChanType value) {
  assert(::mt::EmMtChanType_IsValid(value));
  set_has_stream_type();
  stream_type_ = value;
}

// optional .mt.EmCodecComponentIndex bit_stream_index = 3;
inline bool TStreamInfo::has_bit_stream_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TStreamInfo::set_has_bit_stream_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TStreamInfo::clear_has_bit_stream_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TStreamInfo::clear_bit_stream_index() {
  bit_stream_index_ = 0;
  clear_has_bit_stream_index();
}
inline ::mt::EmCodecComponentIndex TStreamInfo::bit_stream_index() const {
  return static_cast< ::mt::EmCodecComponentIndex >(bit_stream_index_);
}
inline void TStreamInfo::set_bit_stream_index(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_bit_stream_index();
  bit_stream_index_ = value;
}

// optional uint32 band_width = 4;
inline bool TStreamInfo::has_band_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TStreamInfo::set_has_band_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TStreamInfo::clear_has_band_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TStreamInfo::clear_band_width() {
  band_width_ = 0u;
  clear_has_band_width();
}
inline ::google::protobuf::uint32 TStreamInfo::band_width() const {
  return band_width_;
}
inline void TStreamInfo::set_band_width(::google::protobuf::uint32 value) {
  set_has_band_width();
  band_width_ = value;
}

// optional int32 speed_scale = 5;
inline bool TStreamInfo::has_speed_scale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TStreamInfo::set_has_speed_scale() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TStreamInfo::clear_has_speed_scale() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TStreamInfo::clear_speed_scale() {
  speed_scale_ = 0;
  clear_has_speed_scale();
}
inline ::google::protobuf::int32 TStreamInfo::speed_scale() const {
  return speed_scale_;
}
inline void TStreamInfo::set_speed_scale(::google::protobuf::int32 value) {
  set_has_speed_scale();
  speed_scale_ = value;
}

// optional uint32 start_time = 6;
inline bool TStreamInfo::has_start_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TStreamInfo::set_has_start_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TStreamInfo::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TStreamInfo::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 TStreamInfo::start_time() const {
  return start_time_;
}
inline void TStreamInfo::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional uint32 end_time = 7;
inline bool TStreamInfo::has_end_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TStreamInfo::set_has_end_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TStreamInfo::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TStreamInfo::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 TStreamInfo::end_time() const {
  return end_time_;
}
inline void TStreamInfo::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional uint32 cur_time = 8;
inline bool TStreamInfo::has_cur_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TStreamInfo::set_has_cur_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TStreamInfo::clear_has_cur_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TStreamInfo::clear_cur_time() {
  cur_time_ = 0u;
  clear_has_cur_time();
}
inline ::google::protobuf::uint32 TStreamInfo::cur_time() const {
  return cur_time_;
}
inline void TStreamInfo::set_cur_time(::google::protobuf::uint32 value) {
  set_has_cur_time();
  cur_time_ = value;
}

// optional uint32 media_type = 9;
inline bool TStreamInfo::has_media_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TStreamInfo::set_has_media_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TStreamInfo::clear_has_media_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TStreamInfo::clear_media_type() {
  media_type_ = 0u;
  clear_has_media_type();
}
inline ::google::protobuf::uint32 TStreamInfo::media_type() const {
  return media_type_;
}
inline void TStreamInfo::set_media_type(::google::protobuf::uint32 value) {
  set_has_media_type();
  media_type_ = value;
}

// optional uint32 video_width = 10;
inline bool TStreamInfo::has_video_width() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TStreamInfo::set_has_video_width() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TStreamInfo::clear_has_video_width() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TStreamInfo::clear_video_width() {
  video_width_ = 0u;
  clear_has_video_width();
}
inline ::google::protobuf::uint32 TStreamInfo::video_width() const {
  return video_width_;
}
inline void TStreamInfo::set_video_width(::google::protobuf::uint32 value) {
  set_has_video_width();
  video_width_ = value;
}

// optional uint32 video_height = 11;
inline bool TStreamInfo::has_video_height() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TStreamInfo::set_has_video_height() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TStreamInfo::clear_has_video_height() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TStreamInfo::clear_video_height() {
  video_height_ = 0u;
  clear_has_video_height();
}
inline ::google::protobuf::uint32 TStreamInfo::video_height() const {
  return video_height_;
}
inline void TStreamInfo::set_video_height(::google::protobuf::uint32 value) {
  set_has_video_height();
  video_height_ = value;
}

// optional uint32 video_fps = 12;
inline bool TStreamInfo::has_video_fps() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TStreamInfo::set_has_video_fps() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TStreamInfo::clear_has_video_fps() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TStreamInfo::clear_video_fps() {
  video_fps_ = 0u;
  clear_has_video_fps();
}
inline ::google::protobuf::uint32 TStreamInfo::video_fps() const {
  return video_fps_;
}
inline void TStreamInfo::set_video_fps(::google::protobuf::uint32 value) {
  set_has_video_fps();
  video_fps_ = value;
}

// optional .mt.EmRtspStatus status = 13;
inline bool TStreamInfo::has_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TStreamInfo::set_has_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TStreamInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TStreamInfo::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::mt::EmRtspStatus TStreamInfo::status() const {
  return static_cast< ::mt::EmRtspStatus >(status_);
}
inline void TStreamInfo::set_status(::mt::EmRtspStatus value) {
  assert(::mt::EmRtspStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional bool is_livebroadcast = 14;
inline bool TStreamInfo::has_is_livebroadcast() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TStreamInfo::set_has_is_livebroadcast() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TStreamInfo::clear_has_is_livebroadcast() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TStreamInfo::clear_is_livebroadcast() {
  is_livebroadcast_ = false;
  clear_has_is_livebroadcast();
}
inline bool TStreamInfo::is_livebroadcast() const {
  return is_livebroadcast_;
}
inline void TStreamInfo::set_is_livebroadcast(bool value) {
  set_has_is_livebroadcast();
  is_livebroadcast_ = value;
}

// optional .mt.EmAacChnlNum aac_channel_num = 15;
inline bool TStreamInfo::has_aac_channel_num() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TStreamInfo::set_has_aac_channel_num() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TStreamInfo::clear_has_aac_channel_num() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TStreamInfo::clear_aac_channel_num() {
  aac_channel_num_ = 0;
  clear_has_aac_channel_num();
}
inline ::mt::EmAacChnlNum TStreamInfo::aac_channel_num() const {
  return static_cast< ::mt::EmAacChnlNum >(aac_channel_num_);
}
inline void TStreamInfo::set_aac_channel_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_aac_channel_num();
  aac_channel_num_ = value;
}

// optional .mt.EmAacSampFreq aac_sample_rate = 16;
inline bool TStreamInfo::has_aac_sample_rate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TStreamInfo::set_has_aac_sample_rate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TStreamInfo::clear_has_aac_sample_rate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TStreamInfo::clear_aac_sample_rate() {
  aac_sample_rate_ = 0;
  clear_has_aac_sample_rate();
}
inline ::mt::EmAacSampFreq TStreamInfo::aac_sample_rate() const {
  return static_cast< ::mt::EmAacSampFreq >(aac_sample_rate_);
}
inline void TStreamInfo::set_aac_sample_rate(::mt::EmAacSampFreq value) {
  assert(::mt::EmAacSampFreq_IsValid(value));
  set_has_aac_sample_rate();
  aac_sample_rate_ = value;
}

// -------------------------------------------------------------------

// TVodPlayInfo

// optional string play_url = 1;
inline bool TVodPlayInfo::has_play_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVodPlayInfo::set_has_play_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVodPlayInfo::clear_has_play_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVodPlayInfo::clear_play_url() {
  if (play_url_ != &::google::protobuf::internal::kEmptyString) {
    play_url_->clear();
  }
  clear_has_play_url();
}
inline const ::std::string& TVodPlayInfo::play_url() const {
  return *play_url_;
}
inline void TVodPlayInfo::set_play_url(const ::std::string& value) {
  set_has_play_url();
  if (play_url_ == &::google::protobuf::internal::kEmptyString) {
    play_url_ = new ::std::string;
  }
  play_url_->assign(value);
}
inline void TVodPlayInfo::set_play_url(const char* value) {
  set_has_play_url();
  if (play_url_ == &::google::protobuf::internal::kEmptyString) {
    play_url_ = new ::std::string;
  }
  play_url_->assign(value);
}
inline void TVodPlayInfo::set_play_url(const char* value, size_t size) {
  set_has_play_url();
  if (play_url_ == &::google::protobuf::internal::kEmptyString) {
    play_url_ = new ::std::string;
  }
  play_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVodPlayInfo::mutable_play_url() {
  set_has_play_url();
  if (play_url_ == &::google::protobuf::internal::kEmptyString) {
    play_url_ = new ::std::string;
  }
  return play_url_;
}
inline ::std::string* TVodPlayInfo::release_play_url() {
  clear_has_play_url();
  if (play_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = play_url_;
    play_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVodPlayInfo::set_allocated_play_url(::std::string* play_url) {
  if (play_url_ != &::google::protobuf::internal::kEmptyString) {
    delete play_url_;
  }
  if (play_url) {
    set_has_play_url();
    play_url_ = play_url;
  } else {
    clear_has_play_url();
    play_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 vod_id = 2;
inline bool TVodPlayInfo::has_vod_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVodPlayInfo::set_has_vod_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVodPlayInfo::clear_has_vod_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVodPlayInfo::clear_vod_id() {
  vod_id_ = 0u;
  clear_has_vod_id();
}
inline ::google::protobuf::uint32 TVodPlayInfo::vod_id() const {
  return vod_id_;
}
inline void TVodPlayInfo::set_vod_id(::google::protobuf::uint32 value) {
  set_has_vod_id();
  vod_id_ = value;
}

// repeated .mt.TStreamInfo stream_info = 3;
inline int TVodPlayInfo::stream_info_size() const {
  return stream_info_.size();
}
inline void TVodPlayInfo::clear_stream_info() {
  stream_info_.Clear();
}
inline const ::mt::TStreamInfo& TVodPlayInfo::stream_info(int index) const {
  return stream_info_.Get(index);
}
inline ::mt::TStreamInfo* TVodPlayInfo::mutable_stream_info(int index) {
  return stream_info_.Mutable(index);
}
inline ::mt::TStreamInfo* TVodPlayInfo::add_stream_info() {
  return stream_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TStreamInfo >&
TVodPlayInfo::stream_info() const {
  return stream_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TStreamInfo >*
TVodPlayInfo::mutable_stream_info() {
  return &stream_info_;
}

// optional .mt.EmRtspStatus status = 4;
inline bool TVodPlayInfo::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVodPlayInfo::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVodPlayInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVodPlayInfo::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::mt::EmRtspStatus TVodPlayInfo::status() const {
  return static_cast< ::mt::EmRtspStatus >(status_);
}
inline void TVodPlayInfo::set_status(::mt::EmRtspStatus value) {
  assert(::mt::EmRtspStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional bool is_livebroadcast = 5;
inline bool TVodPlayInfo::has_is_livebroadcast() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVodPlayInfo::set_has_is_livebroadcast() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVodPlayInfo::clear_has_is_livebroadcast() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVodPlayInfo::clear_is_livebroadcast() {
  is_livebroadcast_ = false;
  clear_has_is_livebroadcast();
}
inline bool TVodPlayInfo::is_livebroadcast() const {
  return is_livebroadcast_;
}
inline void TVodPlayInfo::set_is_livebroadcast(bool value) {
  set_has_is_livebroadcast();
  is_livebroadcast_ = value;
}

// -------------------------------------------------------------------

// TMultiVodPlayInfo

// repeated .mt.TVodPlayInfo vod_info = 1;
inline int TMultiVodPlayInfo::vod_info_size() const {
  return vod_info_.size();
}
inline void TMultiVodPlayInfo::clear_vod_info() {
  vod_info_.Clear();
}
inline const ::mt::TVodPlayInfo& TMultiVodPlayInfo::vod_info(int index) const {
  return vod_info_.Get(index);
}
inline ::mt::TVodPlayInfo* TMultiVodPlayInfo::mutable_vod_info(int index) {
  return vod_info_.Mutable(index);
}
inline ::mt::TVodPlayInfo* TMultiVodPlayInfo::add_vod_info() {
  return vod_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVodPlayInfo >&
TMultiVodPlayInfo::vod_info() const {
  return vod_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVodPlayInfo >*
TMultiVodPlayInfo::mutable_vod_info() {
  return &vod_info_;
}

// -------------------------------------------------------------------

// TMTRingCfg

// optional bool is_ringin_path = 1;
inline bool TMTRingCfg::has_is_ringin_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTRingCfg::set_has_is_ringin_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTRingCfg::clear_has_is_ringin_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTRingCfg::clear_is_ringin_path() {
  is_ringin_path_ = false;
  clear_has_is_ringin_path();
}
inline bool TMTRingCfg::is_ringin_path() const {
  return is_ringin_path_;
}
inline void TMTRingCfg::set_is_ringin_path(bool value) {
  set_has_is_ringin_path();
  is_ringin_path_ = value;
}

// optional bool is_ringout_path = 2;
inline bool TMTRingCfg::has_is_ringout_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTRingCfg::set_has_is_ringout_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTRingCfg::clear_has_is_ringout_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTRingCfg::clear_is_ringout_path() {
  is_ringout_path_ = false;
  clear_has_is_ringout_path();
}
inline bool TMTRingCfg::is_ringout_path() const {
  return is_ringout_path_;
}
inline void TMTRingCfg::set_is_ringout_path(bool value) {
  set_has_is_ringout_path();
  is_ringout_path_ = value;
}

// optional string path_ring_in = 3;
inline bool TMTRingCfg::has_path_ring_in() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTRingCfg::set_has_path_ring_in() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTRingCfg::clear_has_path_ring_in() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTRingCfg::clear_path_ring_in() {
  if (path_ring_in_ != &::google::protobuf::internal::kEmptyString) {
    path_ring_in_->clear();
  }
  clear_has_path_ring_in();
}
inline const ::std::string& TMTRingCfg::path_ring_in() const {
  return *path_ring_in_;
}
inline void TMTRingCfg::set_path_ring_in(const ::std::string& value) {
  set_has_path_ring_in();
  if (path_ring_in_ == &::google::protobuf::internal::kEmptyString) {
    path_ring_in_ = new ::std::string;
  }
  path_ring_in_->assign(value);
}
inline void TMTRingCfg::set_path_ring_in(const char* value) {
  set_has_path_ring_in();
  if (path_ring_in_ == &::google::protobuf::internal::kEmptyString) {
    path_ring_in_ = new ::std::string;
  }
  path_ring_in_->assign(value);
}
inline void TMTRingCfg::set_path_ring_in(const char* value, size_t size) {
  set_has_path_ring_in();
  if (path_ring_in_ == &::google::protobuf::internal::kEmptyString) {
    path_ring_in_ = new ::std::string;
  }
  path_ring_in_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRingCfg::mutable_path_ring_in() {
  set_has_path_ring_in();
  if (path_ring_in_ == &::google::protobuf::internal::kEmptyString) {
    path_ring_in_ = new ::std::string;
  }
  return path_ring_in_;
}
inline ::std::string* TMTRingCfg::release_path_ring_in() {
  clear_has_path_ring_in();
  if (path_ring_in_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_ring_in_;
    path_ring_in_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRingCfg::set_allocated_path_ring_in(::std::string* path_ring_in) {
  if (path_ring_in_ != &::google::protobuf::internal::kEmptyString) {
    delete path_ring_in_;
  }
  if (path_ring_in) {
    set_has_path_ring_in();
    path_ring_in_ = path_ring_in;
  } else {
    clear_has_path_ring_in();
    path_ring_in_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path_ring_out = 4;
inline bool TMTRingCfg::has_path_ring_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTRingCfg::set_has_path_ring_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTRingCfg::clear_has_path_ring_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTRingCfg::clear_path_ring_out() {
  if (path_ring_out_ != &::google::protobuf::internal::kEmptyString) {
    path_ring_out_->clear();
  }
  clear_has_path_ring_out();
}
inline const ::std::string& TMTRingCfg::path_ring_out() const {
  return *path_ring_out_;
}
inline void TMTRingCfg::set_path_ring_out(const ::std::string& value) {
  set_has_path_ring_out();
  if (path_ring_out_ == &::google::protobuf::internal::kEmptyString) {
    path_ring_out_ = new ::std::string;
  }
  path_ring_out_->assign(value);
}
inline void TMTRingCfg::set_path_ring_out(const char* value) {
  set_has_path_ring_out();
  if (path_ring_out_ == &::google::protobuf::internal::kEmptyString) {
    path_ring_out_ = new ::std::string;
  }
  path_ring_out_->assign(value);
}
inline void TMTRingCfg::set_path_ring_out(const char* value, size_t size) {
  set_has_path_ring_out();
  if (path_ring_out_ == &::google::protobuf::internal::kEmptyString) {
    path_ring_out_ = new ::std::string;
  }
  path_ring_out_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRingCfg::mutable_path_ring_out() {
  set_has_path_ring_out();
  if (path_ring_out_ == &::google::protobuf::internal::kEmptyString) {
    path_ring_out_ = new ::std::string;
  }
  return path_ring_out_;
}
inline ::std::string* TMTRingCfg::release_path_ring_out() {
  clear_has_path_ring_out();
  if (path_ring_out_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_ring_out_;
    path_ring_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTRingCfg::set_allocated_path_ring_out(::std::string* path_ring_out) {
  if (path_ring_out_ != &::google::protobuf::internal::kEmptyString) {
    delete path_ring_out_;
  }
  if (path_ring_out) {
    set_has_path_ring_out();
    path_ring_out_ = path_ring_out;
  } else {
    clear_has_path_ring_out();
    path_ring_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtRing ring_in = 5;
inline bool TMTRingCfg::has_ring_in() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTRingCfg::set_has_ring_in() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTRingCfg::clear_has_ring_in() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTRingCfg::clear_ring_in() {
  ring_in_ = 0;
  clear_has_ring_in();
}
inline ::mt::EmMtRing TMTRingCfg::ring_in() const {
  return static_cast< ::mt::EmMtRing >(ring_in_);
}
inline void TMTRingCfg::set_ring_in(::mt::EmMtRing value) {
  assert(::mt::EmMtRing_IsValid(value));
  set_has_ring_in();
  ring_in_ = value;
}

// optional .mt.EmMtRing ring_out = 6;
inline bool TMTRingCfg::has_ring_out() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTRingCfg::set_has_ring_out() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTRingCfg::clear_has_ring_out() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTRingCfg::clear_ring_out() {
  ring_out_ = 0;
  clear_has_ring_out();
}
inline ::mt::EmMtRing TMTRingCfg::ring_out() const {
  return static_cast< ::mt::EmMtRing >(ring_out_);
}
inline void TMTRingCfg::set_ring_out(::mt::EmMtRing value) {
  assert(::mt::EmMtRing_IsValid(value));
  set_has_ring_out();
  ring_out_ = value;
}

// -------------------------------------------------------------------

// TMTVideoEncoderParamCfg

// optional .mt.EmCodecComponentIndex index = 1;
inline bool TMTVideoEncoderParamCfg::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVideoEncoderParamCfg::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVideoEncoderParamCfg::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::mt::EmCodecComponentIndex TMTVideoEncoderParamCfg::index() const {
  return static_cast< ::mt::EmCodecComponentIndex >(index_);
}
inline void TMTVideoEncoderParamCfg::set_index(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_index();
  index_ = value;
}

// optional uint32 h264_keyframe_interval = 2;
inline bool TMTVideoEncoderParamCfg::has_h264_keyframe_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_h264_keyframe_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVideoEncoderParamCfg::clear_has_h264_keyframe_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVideoEncoderParamCfg::clear_h264_keyframe_interval() {
  h264_keyframe_interval_ = 0u;
  clear_has_h264_keyframe_interval();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::h264_keyframe_interval() const {
  return h264_keyframe_interval_;
}
inline void TMTVideoEncoderParamCfg::set_h264_keyframe_interval(::google::protobuf::uint32 value) {
  set_has_h264_keyframe_interval();
  h264_keyframe_interval_ = value;
}

// optional uint32 h264_qual_max_value = 3;
inline bool TMTVideoEncoderParamCfg::has_h264_qual_max_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_h264_qual_max_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVideoEncoderParamCfg::clear_has_h264_qual_max_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVideoEncoderParamCfg::clear_h264_qual_max_value() {
  h264_qual_max_value_ = 0u;
  clear_has_h264_qual_max_value();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::h264_qual_max_value() const {
  return h264_qual_max_value_;
}
inline void TMTVideoEncoderParamCfg::set_h264_qual_max_value(::google::protobuf::uint32 value) {
  set_has_h264_qual_max_value();
  h264_qual_max_value_ = value;
}

// optional uint32 h264_qual_min_value = 4;
inline bool TMTVideoEncoderParamCfg::has_h264_qual_min_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_h264_qual_min_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTVideoEncoderParamCfg::clear_has_h264_qual_min_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTVideoEncoderParamCfg::clear_h264_qual_min_value() {
  h264_qual_min_value_ = 0u;
  clear_has_h264_qual_min_value();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::h264_qual_min_value() const {
  return h264_qual_min_value_;
}
inline void TMTVideoEncoderParamCfg::set_h264_qual_min_value(::google::protobuf::uint32 value) {
  set_has_h264_qual_min_value();
  h264_qual_min_value_ = value;
}

// optional uint32 keyframe_interval = 5;
inline bool TMTVideoEncoderParamCfg::has_keyframe_interval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_keyframe_interval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTVideoEncoderParamCfg::clear_has_keyframe_interval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTVideoEncoderParamCfg::clear_keyframe_interval() {
  keyframe_interval_ = 0u;
  clear_has_keyframe_interval();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::keyframe_interval() const {
  return keyframe_interval_;
}
inline void TMTVideoEncoderParamCfg::set_keyframe_interval(::google::protobuf::uint32 value) {
  set_has_keyframe_interval();
  keyframe_interval_ = value;
}

// optional uint32 qual_max_value = 6;
inline bool TMTVideoEncoderParamCfg::has_qual_max_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_qual_max_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTVideoEncoderParamCfg::clear_has_qual_max_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTVideoEncoderParamCfg::clear_qual_max_value() {
  qual_max_value_ = 0u;
  clear_has_qual_max_value();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::qual_max_value() const {
  return qual_max_value_;
}
inline void TMTVideoEncoderParamCfg::set_qual_max_value(::google::protobuf::uint32 value) {
  set_has_qual_max_value();
  qual_max_value_ = value;
}

// optional uint32 qual_min_value = 7;
inline bool TMTVideoEncoderParamCfg::has_qual_min_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_qual_min_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTVideoEncoderParamCfg::clear_has_qual_min_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTVideoEncoderParamCfg::clear_qual_min_value() {
  qual_min_value_ = 0u;
  clear_has_qual_min_value();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::qual_min_value() const {
  return qual_min_value_;
}
inline void TMTVideoEncoderParamCfg::set_qual_min_value(::google::protobuf::uint32 value) {
  set_has_qual_min_value();
  qual_min_value_ = value;
}

// optional uint32 h265_keyframe_interval = 8;
inline bool TMTVideoEncoderParamCfg::has_h265_keyframe_interval() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_h265_keyframe_interval() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTVideoEncoderParamCfg::clear_has_h265_keyframe_interval() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTVideoEncoderParamCfg::clear_h265_keyframe_interval() {
  h265_keyframe_interval_ = 0u;
  clear_has_h265_keyframe_interval();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::h265_keyframe_interval() const {
  return h265_keyframe_interval_;
}
inline void TMTVideoEncoderParamCfg::set_h265_keyframe_interval(::google::protobuf::uint32 value) {
  set_has_h265_keyframe_interval();
  h265_keyframe_interval_ = value;
}

// optional uint32 h265_qual_max_value = 9;
inline bool TMTVideoEncoderParamCfg::has_h265_qual_max_value() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_h265_qual_max_value() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTVideoEncoderParamCfg::clear_has_h265_qual_max_value() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTVideoEncoderParamCfg::clear_h265_qual_max_value() {
  h265_qual_max_value_ = 0u;
  clear_has_h265_qual_max_value();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::h265_qual_max_value() const {
  return h265_qual_max_value_;
}
inline void TMTVideoEncoderParamCfg::set_h265_qual_max_value(::google::protobuf::uint32 value) {
  set_has_h265_qual_max_value();
  h265_qual_max_value_ = value;
}

// optional uint32 h265_qual_min_value = 10;
inline bool TMTVideoEncoderParamCfg::has_h265_qual_min_value() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_h265_qual_min_value() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTVideoEncoderParamCfg::clear_has_h265_qual_min_value() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTVideoEncoderParamCfg::clear_h265_qual_min_value() {
  h265_qual_min_value_ = 0u;
  clear_has_h265_qual_min_value();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::h265_qual_min_value() const {
  return h265_qual_min_value_;
}
inline void TMTVideoEncoderParamCfg::set_h265_qual_min_value(::google::protobuf::uint32 value) {
  set_has_h265_qual_min_value();
  h265_qual_min_value_ = value;
}

// optional uint32 frameRate_720p = 11;
inline bool TMTVideoEncoderParamCfg::has_framerate_720p() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_framerate_720p() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTVideoEncoderParamCfg::clear_has_framerate_720p() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTVideoEncoderParamCfg::clear_framerate_720p() {
  framerate_720p_ = 0u;
  clear_has_framerate_720p();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::framerate_720p() const {
  return framerate_720p_;
}
inline void TMTVideoEncoderParamCfg::set_framerate_720p(::google::protobuf::uint32 value) {
  set_has_framerate_720p();
  framerate_720p_ = value;
}

// optional uint32 frameRate_1080p = 12;
inline bool TMTVideoEncoderParamCfg::has_framerate_1080p() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_framerate_1080p() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTVideoEncoderParamCfg::clear_has_framerate_1080p() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTVideoEncoderParamCfg::clear_framerate_1080p() {
  framerate_1080p_ = 0u;
  clear_has_framerate_1080p();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::framerate_1080p() const {
  return framerate_1080p_;
}
inline void TMTVideoEncoderParamCfg::set_framerate_1080p(::google::protobuf::uint32 value) {
  set_has_framerate_1080p();
  framerate_1080p_ = value;
}

// optional uint32 framerate_gt720p = 13;
inline bool TMTVideoEncoderParamCfg::has_framerate_gt720p() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_framerate_gt720p() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTVideoEncoderParamCfg::clear_has_framerate_gt720p() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTVideoEncoderParamCfg::clear_framerate_gt720p() {
  framerate_gt720p_ = 0u;
  clear_has_framerate_gt720p();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::framerate_gt720p() const {
  return framerate_gt720p_;
}
inline void TMTVideoEncoderParamCfg::set_framerate_gt720p(::google::protobuf::uint32 value) {
  set_has_framerate_gt720p();
  framerate_gt720p_ = value;
}

// optional uint32 framerate_lt720p = 14;
inline bool TMTVideoEncoderParamCfg::has_framerate_lt720p() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_framerate_lt720p() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTVideoEncoderParamCfg::clear_has_framerate_lt720p() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTVideoEncoderParamCfg::clear_framerate_lt720p() {
  framerate_lt720p_ = 0u;
  clear_has_framerate_lt720p();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::framerate_lt720p() const {
  return framerate_lt720p_;
}
inline void TMTVideoEncoderParamCfg::set_framerate_lt720p(::google::protobuf::uint32 value) {
  set_has_framerate_lt720p();
  framerate_lt720p_ = value;
}

// optional uint32 framerate_4k = 15;
inline bool TMTVideoEncoderParamCfg::has_framerate_4k() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_framerate_4k() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTVideoEncoderParamCfg::clear_has_framerate_4k() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTVideoEncoderParamCfg::clear_framerate_4k() {
  framerate_4k_ = 0u;
  clear_has_framerate_4k();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::framerate_4k() const {
  return framerate_4k_;
}
inline void TMTVideoEncoderParamCfg::set_framerate_4k(::google::protobuf::uint32 value) {
  set_has_framerate_4k();
  framerate_4k_ = value;
}

// optional uint32 framerate_other = 16;
inline bool TMTVideoEncoderParamCfg::has_framerate_other() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_framerate_other() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMTVideoEncoderParamCfg::clear_has_framerate_other() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMTVideoEncoderParamCfg::clear_framerate_other() {
  framerate_other_ = 0u;
  clear_has_framerate_other();
}
inline ::google::protobuf::uint32 TMTVideoEncoderParamCfg::framerate_other() const {
  return framerate_other_;
}
inline void TMTVideoEncoderParamCfg::set_framerate_other(::google::protobuf::uint32 value) {
  set_has_framerate_other();
  framerate_other_ = value;
}

// optional bool is_skip = 17;
inline bool TMTVideoEncoderParamCfg::has_is_skip() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_is_skip() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTVideoEncoderParamCfg::clear_has_is_skip() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTVideoEncoderParamCfg::clear_is_skip() {
  is_skip_ = false;
  clear_has_is_skip();
}
inline bool TMTVideoEncoderParamCfg::is_skip() const {
  return is_skip_;
}
inline void TMTVideoEncoderParamCfg::set_is_skip(bool value) {
  set_has_is_skip();
  is_skip_ = value;
}

// optional float fRatio = 18;
inline bool TMTVideoEncoderParamCfg::has_fratio() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTVideoEncoderParamCfg::set_has_fratio() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTVideoEncoderParamCfg::clear_has_fratio() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTVideoEncoderParamCfg::clear_fratio() {
  fratio_ = 0;
  clear_has_fratio();
}
inline float TMTVideoEncoderParamCfg::fratio() const {
  return fratio_;
}
inline void TMTVideoEncoderParamCfg::set_fratio(float value) {
  set_has_fratio();
  fratio_ = value;
}

// -------------------------------------------------------------------

// TMTAllVideoEncoderParamCfg

// repeated .mt.TMTVideoEncoderParamCfg param_array = 1;
inline int TMTAllVideoEncoderParamCfg::param_array_size() const {
  return param_array_.size();
}
inline void TMTAllVideoEncoderParamCfg::clear_param_array() {
  param_array_.Clear();
}
inline const ::mt::TMTVideoEncoderParamCfg& TMTAllVideoEncoderParamCfg::param_array(int index) const {
  return param_array_.Get(index);
}
inline ::mt::TMTVideoEncoderParamCfg* TMTAllVideoEncoderParamCfg::mutable_param_array(int index) {
  return param_array_.Mutable(index);
}
inline ::mt::TMTVideoEncoderParamCfg* TMTAllVideoEncoderParamCfg::add_param_array() {
  return param_array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoEncoderParamCfg >&
TMTAllVideoEncoderParamCfg::param_array() const {
  return param_array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoEncoderParamCfg >*
TMTAllVideoEncoderParamCfg::mutable_param_array() {
  return &param_array_;
}

// -------------------------------------------------------------------

// TMTVideoDecoderParamCfg

// optional .mt.EmCodecComponentIndex index = 1;
inline bool TMTVideoDecoderParamCfg::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVideoDecoderParamCfg::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVideoDecoderParamCfg::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVideoDecoderParamCfg::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::mt::EmCodecComponentIndex TMTVideoDecoderParamCfg::index() const {
  return static_cast< ::mt::EmCodecComponentIndex >(index_);
}
inline void TMTVideoDecoderParamCfg::set_index(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_index();
  index_ = value;
}

// optional .mt.EmLostPackStrategy type = 2;
inline bool TMTVideoDecoderParamCfg::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVideoDecoderParamCfg::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVideoDecoderParamCfg::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVideoDecoderParamCfg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmLostPackStrategy TMTVideoDecoderParamCfg::type() const {
  return static_cast< ::mt::EmLostPackStrategy >(type_);
}
inline void TMTVideoDecoderParamCfg::set_type(::mt::EmLostPackStrategy value) {
  assert(::mt::EmLostPackStrategy_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// TMTAllVideoDecoderParamCfg

// repeated .mt.TMTVideoDecoderParamCfg param_array = 2;
inline int TMTAllVideoDecoderParamCfg::param_array_size() const {
  return param_array_.size();
}
inline void TMTAllVideoDecoderParamCfg::clear_param_array() {
  param_array_.Clear();
}
inline const ::mt::TMTVideoDecoderParamCfg& TMTAllVideoDecoderParamCfg::param_array(int index) const {
  return param_array_.Get(index);
}
inline ::mt::TMTVideoDecoderParamCfg* TMTAllVideoDecoderParamCfg::mutable_param_array(int index) {
  return param_array_.Mutable(index);
}
inline ::mt::TMTVideoDecoderParamCfg* TMTAllVideoDecoderParamCfg::add_param_array() {
  return param_array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoDecoderParamCfg >&
TMTAllVideoDecoderParamCfg::param_array() const {
  return param_array_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoDecoderParamCfg >*
TMTAllVideoDecoderParamCfg::mutable_param_array() {
  return &param_array_;
}

// -------------------------------------------------------------------

// TMTPortCfg

// optional bool is_used = 1;
inline bool TMTPortCfg::has_is_used() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPortCfg::set_has_is_used() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPortCfg::clear_has_is_used() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPortCfg::clear_is_used() {
  is_used_ = false;
  clear_has_is_used();
}
inline bool TMTPortCfg::is_used() const {
  return is_used_;
}
inline void TMTPortCfg::set_is_used(bool value) {
  set_has_is_used();
  is_used_ = value;
}

// optional uint32 tcp_base_port = 2;
inline bool TMTPortCfg::has_tcp_base_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPortCfg::set_has_tcp_base_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPortCfg::clear_has_tcp_base_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPortCfg::clear_tcp_base_port() {
  tcp_base_port_ = 0u;
  clear_has_tcp_base_port();
}
inline ::google::protobuf::uint32 TMTPortCfg::tcp_base_port() const {
  return tcp_base_port_;
}
inline void TMTPortCfg::set_tcp_base_port(::google::protobuf::uint32 value) {
  set_has_tcp_base_port();
  tcp_base_port_ = value;
}

// optional uint32 udp_base_port = 3;
inline bool TMTPortCfg::has_udp_base_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTPortCfg::set_has_udp_base_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTPortCfg::clear_has_udp_base_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTPortCfg::clear_udp_base_port() {
  udp_base_port_ = 0u;
  clear_has_udp_base_port();
}
inline ::google::protobuf::uint32 TMTPortCfg::udp_base_port() const {
  return udp_base_port_;
}
inline void TMTPortCfg::set_udp_base_port(::google::protobuf::uint32 value) {
  set_has_udp_base_port();
  udp_base_port_ = value;
}

// -------------------------------------------------------------------

// TMTShortMsgCfg

// optional uint32 font_size_index = 1;
inline bool TMTShortMsgCfg::has_font_size_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTShortMsgCfg::set_has_font_size_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTShortMsgCfg::clear_has_font_size_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTShortMsgCfg::clear_font_size_index() {
  font_size_index_ = 0u;
  clear_has_font_size_index();
}
inline ::google::protobuf::uint32 TMTShortMsgCfg::font_size_index() const {
  return font_size_index_;
}
inline void TMTShortMsgCfg::set_font_size_index(::google::protobuf::uint32 value) {
  set_has_font_size_index();
  font_size_index_ = value;
}

// optional uint32 font_color_index = 2;
inline bool TMTShortMsgCfg::has_font_color_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTShortMsgCfg::set_has_font_color_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTShortMsgCfg::clear_has_font_color_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTShortMsgCfg::clear_font_color_index() {
  font_color_index_ = 0u;
  clear_has_font_color_index();
}
inline ::google::protobuf::uint32 TMTShortMsgCfg::font_color_index() const {
  return font_color_index_;
}
inline void TMTShortMsgCfg::set_font_color_index(::google::protobuf::uint32 value) {
  set_has_font_color_index();
  font_color_index_ = value;
}

// optional uint32 background_color_index = 3 [default = 7];
inline bool TMTShortMsgCfg::has_background_color_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTShortMsgCfg::set_has_background_color_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTShortMsgCfg::clear_has_background_color_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTShortMsgCfg::clear_background_color_index() {
  background_color_index_ = 7u;
  clear_has_background_color_index();
}
inline ::google::protobuf::uint32 TMTShortMsgCfg::background_color_index() const {
  return background_color_index_;
}
inline void TMTShortMsgCfg::set_background_color_index(::google::protobuf::uint32 value) {
  set_has_background_color_index();
  background_color_index_ = value;
}

// -------------------------------------------------------------------

// TMTOspSock5Proxy

// optional uint32 proxy_ip = 1;
inline bool TMTOspSock5Proxy::has_proxy_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTOspSock5Proxy::set_has_proxy_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTOspSock5Proxy::clear_has_proxy_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTOspSock5Proxy::clear_proxy_ip() {
  proxy_ip_ = 0u;
  clear_has_proxy_ip();
}
inline ::google::protobuf::uint32 TMTOspSock5Proxy::proxy_ip() const {
  return proxy_ip_;
}
inline void TMTOspSock5Proxy::set_proxy_ip(::google::protobuf::uint32 value) {
  set_has_proxy_ip();
  proxy_ip_ = value;
}

// optional uint32 proxy_port = 2;
inline bool TMTOspSock5Proxy::has_proxy_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTOspSock5Proxy::set_has_proxy_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTOspSock5Proxy::clear_has_proxy_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTOspSock5Proxy::clear_proxy_port() {
  proxy_port_ = 0u;
  clear_has_proxy_port();
}
inline ::google::protobuf::uint32 TMTOspSock5Proxy::proxy_port() const {
  return proxy_port_;
}
inline void TMTOspSock5Proxy::set_proxy_port(::google::protobuf::uint32 value) {
  set_has_proxy_port();
  proxy_port_ = value;
}

// optional uint32 authen_num = 3;
inline bool TMTOspSock5Proxy::has_authen_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTOspSock5Proxy::set_has_authen_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTOspSock5Proxy::clear_has_authen_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTOspSock5Proxy::clear_authen_num() {
  authen_num_ = 0u;
  clear_has_authen_num();
}
inline ::google::protobuf::uint32 TMTOspSock5Proxy::authen_num() const {
  return authen_num_;
}
inline void TMTOspSock5Proxy::set_authen_num(::google::protobuf::uint32 value) {
  set_has_authen_num();
  authen_num_ = value;
}

// optional string authen_method = 4;
inline bool TMTOspSock5Proxy::has_authen_method() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTOspSock5Proxy::set_has_authen_method() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTOspSock5Proxy::clear_has_authen_method() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTOspSock5Proxy::clear_authen_method() {
  if (authen_method_ != &::google::protobuf::internal::kEmptyString) {
    authen_method_->clear();
  }
  clear_has_authen_method();
}
inline const ::std::string& TMTOspSock5Proxy::authen_method() const {
  return *authen_method_;
}
inline void TMTOspSock5Proxy::set_authen_method(const ::std::string& value) {
  set_has_authen_method();
  if (authen_method_ == &::google::protobuf::internal::kEmptyString) {
    authen_method_ = new ::std::string;
  }
  authen_method_->assign(value);
}
inline void TMTOspSock5Proxy::set_authen_method(const char* value) {
  set_has_authen_method();
  if (authen_method_ == &::google::protobuf::internal::kEmptyString) {
    authen_method_ = new ::std::string;
  }
  authen_method_->assign(value);
}
inline void TMTOspSock5Proxy::set_authen_method(const char* value, size_t size) {
  set_has_authen_method();
  if (authen_method_ == &::google::protobuf::internal::kEmptyString) {
    authen_method_ = new ::std::string;
  }
  authen_method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTOspSock5Proxy::mutable_authen_method() {
  set_has_authen_method();
  if (authen_method_ == &::google::protobuf::internal::kEmptyString) {
    authen_method_ = new ::std::string;
  }
  return authen_method_;
}
inline ::std::string* TMTOspSock5Proxy::release_authen_method() {
  clear_has_authen_method();
  if (authen_method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authen_method_;
    authen_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTOspSock5Proxy::set_allocated_authen_method(::std::string* authen_method) {
  if (authen_method_ != &::google::protobuf::internal::kEmptyString) {
    delete authen_method_;
  }
  if (authen_method) {
    set_has_authen_method();
    authen_method_ = authen_method;
  } else {
    clear_has_authen_method();
    authen_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_name = 5;
inline bool TMTOspSock5Proxy::has_user_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTOspSock5Proxy::set_has_user_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTOspSock5Proxy::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTOspSock5Proxy::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TMTOspSock5Proxy::user_name() const {
  return *user_name_;
}
inline void TMTOspSock5Proxy::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TMTOspSock5Proxy::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TMTOspSock5Proxy::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTOspSock5Proxy::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TMTOspSock5Proxy::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTOspSock5Proxy::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 6;
inline bool TMTOspSock5Proxy::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTOspSock5Proxy::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTOspSock5Proxy::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTOspSock5Proxy::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMTOspSock5Proxy::password() const {
  return *password_;
}
inline void TMTOspSock5Proxy::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTOspSock5Proxy::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMTOspSock5Proxy::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTOspSock5Proxy::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMTOspSock5Proxy::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTOspSock5Proxy::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTInnerMcAssVidCfg

// optional .mt.EmVidFormat ass_video_format = 1;
inline bool TMTInnerMcAssVidCfg::has_ass_video_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTInnerMcAssVidCfg::set_has_ass_video_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTInnerMcAssVidCfg::clear_has_ass_video_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTInnerMcAssVidCfg::clear_ass_video_format() {
  ass_video_format_ = 0;
  clear_has_ass_video_format();
}
inline ::mt::EmVidFormat TMTInnerMcAssVidCfg::ass_video_format() const {
  return static_cast< ::mt::EmVidFormat >(ass_video_format_);
}
inline void TMTInnerMcAssVidCfg::set_ass_video_format(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_ass_video_format();
  ass_video_format_ = value;
}

// optional .mt.EmMtResolution ass_video_res = 2;
inline bool TMTInnerMcAssVidCfg::has_ass_video_res() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTInnerMcAssVidCfg::set_has_ass_video_res() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTInnerMcAssVidCfg::clear_has_ass_video_res() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTInnerMcAssVidCfg::clear_ass_video_res() {
  ass_video_res_ = 0;
  clear_has_ass_video_res();
}
inline ::mt::EmMtResolution TMTInnerMcAssVidCfg::ass_video_res() const {
  return static_cast< ::mt::EmMtResolution >(ass_video_res_);
}
inline void TMTInnerMcAssVidCfg::set_ass_video_res(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_ass_video_res();
  ass_video_res_ = value;
}

// optional uint32 ass_video_framerate = 3;
inline bool TMTInnerMcAssVidCfg::has_ass_video_framerate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTInnerMcAssVidCfg::set_has_ass_video_framerate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTInnerMcAssVidCfg::clear_has_ass_video_framerate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTInnerMcAssVidCfg::clear_ass_video_framerate() {
  ass_video_framerate_ = 0u;
  clear_has_ass_video_framerate();
}
inline ::google::protobuf::uint32 TMTInnerMcAssVidCfg::ass_video_framerate() const {
  return ass_video_framerate_;
}
inline void TMTInnerMcAssVidCfg::set_ass_video_framerate(::google::protobuf::uint32 value) {
  set_has_ass_video_framerate();
  ass_video_framerate_ = value;
}

// -------------------------------------------------------------------

// TMTUpgradeDeviceInfo

// optional string dev_type = 1;
inline bool TMTUpgradeDeviceInfo::has_dev_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUpgradeDeviceInfo::set_has_dev_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUpgradeDeviceInfo::clear_has_dev_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUpgradeDeviceInfo::clear_dev_type() {
  if (dev_type_ != &::google::protobuf::internal::kEmptyString) {
    dev_type_->clear();
  }
  clear_has_dev_type();
}
inline const ::std::string& TMTUpgradeDeviceInfo::dev_type() const {
  return *dev_type_;
}
inline void TMTUpgradeDeviceInfo::set_dev_type(const ::std::string& value) {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  dev_type_->assign(value);
}
inline void TMTUpgradeDeviceInfo::set_dev_type(const char* value) {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  dev_type_->assign(value);
}
inline void TMTUpgradeDeviceInfo::set_dev_type(const char* value, size_t size) {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  dev_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeDeviceInfo::mutable_dev_type() {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  return dev_type_;
}
inline ::std::string* TMTUpgradeDeviceInfo::release_dev_type() {
  clear_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dev_type_;
    dev_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeDeviceInfo::set_allocated_dev_type(::std::string* dev_type) {
  if (dev_type_ != &::google::protobuf::internal::kEmptyString) {
    delete dev_type_;
  }
  if (dev_type) {
    set_has_dev_type();
    dev_type_ = dev_type;
  } else {
    clear_has_dev_type();
    dev_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string oem_mark = 2;
inline bool TMTUpgradeDeviceInfo::has_oem_mark() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUpgradeDeviceInfo::set_has_oem_mark() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUpgradeDeviceInfo::clear_has_oem_mark() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUpgradeDeviceInfo::clear_oem_mark() {
  if (oem_mark_ != &::google::protobuf::internal::kEmptyString) {
    oem_mark_->clear();
  }
  clear_has_oem_mark();
}
inline const ::std::string& TMTUpgradeDeviceInfo::oem_mark() const {
  return *oem_mark_;
}
inline void TMTUpgradeDeviceInfo::set_oem_mark(const ::std::string& value) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(value);
}
inline void TMTUpgradeDeviceInfo::set_oem_mark(const char* value) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(value);
}
inline void TMTUpgradeDeviceInfo::set_oem_mark(const char* value, size_t size) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeDeviceInfo::mutable_oem_mark() {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  return oem_mark_;
}
inline ::std::string* TMTUpgradeDeviceInfo::release_oem_mark() {
  clear_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oem_mark_;
    oem_mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeDeviceInfo::set_allocated_oem_mark(::std::string* oem_mark) {
  if (oem_mark_ != &::google::protobuf::internal::kEmptyString) {
    delete oem_mark_;
  }
  if (oem_mark) {
    set_has_oem_mark();
    oem_mark_ = oem_mark;
  } else {
    clear_has_oem_mark();
    oem_mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 3;
inline bool TMTUpgradeDeviceInfo::has_e164() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTUpgradeDeviceInfo::set_has_e164() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTUpgradeDeviceInfo::clear_has_e164() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTUpgradeDeviceInfo::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMTUpgradeDeviceInfo::e164() const {
  return *e164_;
}
inline void TMTUpgradeDeviceInfo::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTUpgradeDeviceInfo::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMTUpgradeDeviceInfo::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeDeviceInfo::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMTUpgradeDeviceInfo::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeDeviceInfo::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cur_soft_ver = 4;
inline bool TMTUpgradeDeviceInfo::has_cur_soft_ver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTUpgradeDeviceInfo::set_has_cur_soft_ver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTUpgradeDeviceInfo::clear_has_cur_soft_ver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTUpgradeDeviceInfo::clear_cur_soft_ver() {
  if (cur_soft_ver_ != &::google::protobuf::internal::kEmptyString) {
    cur_soft_ver_->clear();
  }
  clear_has_cur_soft_ver();
}
inline const ::std::string& TMTUpgradeDeviceInfo::cur_soft_ver() const {
  return *cur_soft_ver_;
}
inline void TMTUpgradeDeviceInfo::set_cur_soft_ver(const ::std::string& value) {
  set_has_cur_soft_ver();
  if (cur_soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    cur_soft_ver_ = new ::std::string;
  }
  cur_soft_ver_->assign(value);
}
inline void TMTUpgradeDeviceInfo::set_cur_soft_ver(const char* value) {
  set_has_cur_soft_ver();
  if (cur_soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    cur_soft_ver_ = new ::std::string;
  }
  cur_soft_ver_->assign(value);
}
inline void TMTUpgradeDeviceInfo::set_cur_soft_ver(const char* value, size_t size) {
  set_has_cur_soft_ver();
  if (cur_soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    cur_soft_ver_ = new ::std::string;
  }
  cur_soft_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeDeviceInfo::mutable_cur_soft_ver() {
  set_has_cur_soft_ver();
  if (cur_soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    cur_soft_ver_ = new ::std::string;
  }
  return cur_soft_ver_;
}
inline ::std::string* TMTUpgradeDeviceInfo::release_cur_soft_ver() {
  clear_has_cur_soft_ver();
  if (cur_soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cur_soft_ver_;
    cur_soft_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeDeviceInfo::set_allocated_cur_soft_ver(::std::string* cur_soft_ver) {
  if (cur_soft_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete cur_soft_ver_;
  }
  if (cur_soft_ver) {
    set_has_cur_soft_ver();
    cur_soft_ver_ = cur_soft_ver;
  } else {
    clear_has_cur_soft_ver();
    cur_soft_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 dev_ip = 5;
inline bool TMTUpgradeDeviceInfo::has_dev_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTUpgradeDeviceInfo::set_has_dev_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTUpgradeDeviceInfo::clear_has_dev_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTUpgradeDeviceInfo::clear_dev_ip() {
  dev_ip_ = 0u;
  clear_has_dev_ip();
}
inline ::google::protobuf::uint32 TMTUpgradeDeviceInfo::dev_ip() const {
  return dev_ip_;
}
inline void TMTUpgradeDeviceInfo::set_dev_ip(::google::protobuf::uint32 value) {
  set_has_dev_ip();
  dev_ip_ = value;
}

// -------------------------------------------------------------------

// TMTUpgradeClientInfo

// optional .mt.TMTUpgradeNetParam server_info = 1;
inline bool TMTUpgradeClientInfo::has_server_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUpgradeClientInfo::set_has_server_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUpgradeClientInfo::clear_has_server_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUpgradeClientInfo::clear_server_info() {
  if (server_info_ != NULL) server_info_->::mt::TMTUpgradeNetParam::Clear();
  clear_has_server_info();
}
inline const ::mt::TMTUpgradeNetParam& TMTUpgradeClientInfo::server_info() const {
  return server_info_ != NULL ? *server_info_ : *default_instance_->server_info_;
}
inline ::mt::TMTUpgradeNetParam* TMTUpgradeClientInfo::mutable_server_info() {
  set_has_server_info();
  if (server_info_ == NULL) server_info_ = new ::mt::TMTUpgradeNetParam;
  return server_info_;
}
inline ::mt::TMTUpgradeNetParam* TMTUpgradeClientInfo::release_server_info() {
  clear_has_server_info();
  ::mt::TMTUpgradeNetParam* temp = server_info_;
  server_info_ = NULL;
  return temp;
}
inline void TMTUpgradeClientInfo::set_allocated_server_info(::mt::TMTUpgradeNetParam* server_info) {
  delete server_info_;
  server_info_ = server_info;
  if (server_info) {
    set_has_server_info();
  } else {
    clear_has_server_info();
  }
}

// optional .mt.TMTUpgradeDeviceInfo dev_info = 2;
inline bool TMTUpgradeClientInfo::has_dev_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUpgradeClientInfo::set_has_dev_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUpgradeClientInfo::clear_has_dev_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUpgradeClientInfo::clear_dev_info() {
  if (dev_info_ != NULL) dev_info_->::mt::TMTUpgradeDeviceInfo::Clear();
  clear_has_dev_info();
}
inline const ::mt::TMTUpgradeDeviceInfo& TMTUpgradeClientInfo::dev_info() const {
  return dev_info_ != NULL ? *dev_info_ : *default_instance_->dev_info_;
}
inline ::mt::TMTUpgradeDeviceInfo* TMTUpgradeClientInfo::mutable_dev_info() {
  set_has_dev_info();
  if (dev_info_ == NULL) dev_info_ = new ::mt::TMTUpgradeDeviceInfo;
  return dev_info_;
}
inline ::mt::TMTUpgradeDeviceInfo* TMTUpgradeClientInfo::release_dev_info() {
  clear_has_dev_info();
  ::mt::TMTUpgradeDeviceInfo* temp = dev_info_;
  dev_info_ = NULL;
  return temp;
}
inline void TMTUpgradeClientInfo::set_allocated_dev_info(::mt::TMTUpgradeDeviceInfo* dev_info) {
  delete dev_info_;
  dev_info_ = dev_info;
  if (dev_info) {
    set_has_dev_info();
  } else {
    clear_has_dev_info();
  }
}

// -------------------------------------------------------------------

// TMTUpgradeGrayRange

// optional string moid_list = 1;
inline bool TMTUpgradeGrayRange::has_moid_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUpgradeGrayRange::set_has_moid_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUpgradeGrayRange::clear_has_moid_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUpgradeGrayRange::clear_moid_list() {
  if (moid_list_ != &::google::protobuf::internal::kEmptyString) {
    moid_list_->clear();
  }
  clear_has_moid_list();
}
inline const ::std::string& TMTUpgradeGrayRange::moid_list() const {
  return *moid_list_;
}
inline void TMTUpgradeGrayRange::set_moid_list(const ::std::string& value) {
  set_has_moid_list();
  if (moid_list_ == &::google::protobuf::internal::kEmptyString) {
    moid_list_ = new ::std::string;
  }
  moid_list_->assign(value);
}
inline void TMTUpgradeGrayRange::set_moid_list(const char* value) {
  set_has_moid_list();
  if (moid_list_ == &::google::protobuf::internal::kEmptyString) {
    moid_list_ = new ::std::string;
  }
  moid_list_->assign(value);
}
inline void TMTUpgradeGrayRange::set_moid_list(const char* value, size_t size) {
  set_has_moid_list();
  if (moid_list_ == &::google::protobuf::internal::kEmptyString) {
    moid_list_ = new ::std::string;
  }
  moid_list_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeGrayRange::mutable_moid_list() {
  set_has_moid_list();
  if (moid_list_ == &::google::protobuf::internal::kEmptyString) {
    moid_list_ = new ::std::string;
  }
  return moid_list_;
}
inline ::std::string* TMTUpgradeGrayRange::release_moid_list() {
  clear_has_moid_list();
  if (moid_list_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_list_;
    moid_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeGrayRange::set_allocated_moid_list(::std::string* moid_list) {
  if (moid_list_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_list_;
  }
  if (moid_list) {
    set_has_moid_list();
    moid_list_ = moid_list;
  } else {
    clear_has_moid_list();
    moid_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164_list = 2;
inline bool TMTUpgradeGrayRange::has_e164_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUpgradeGrayRange::set_has_e164_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUpgradeGrayRange::clear_has_e164_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUpgradeGrayRange::clear_e164_list() {
  if (e164_list_ != &::google::protobuf::internal::kEmptyString) {
    e164_list_->clear();
  }
  clear_has_e164_list();
}
inline const ::std::string& TMTUpgradeGrayRange::e164_list() const {
  return *e164_list_;
}
inline void TMTUpgradeGrayRange::set_e164_list(const ::std::string& value) {
  set_has_e164_list();
  if (e164_list_ == &::google::protobuf::internal::kEmptyString) {
    e164_list_ = new ::std::string;
  }
  e164_list_->assign(value);
}
inline void TMTUpgradeGrayRange::set_e164_list(const char* value) {
  set_has_e164_list();
  if (e164_list_ == &::google::protobuf::internal::kEmptyString) {
    e164_list_ = new ::std::string;
  }
  e164_list_->assign(value);
}
inline void TMTUpgradeGrayRange::set_e164_list(const char* value, size_t size) {
  set_has_e164_list();
  if (e164_list_ == &::google::protobuf::internal::kEmptyString) {
    e164_list_ = new ::std::string;
  }
  e164_list_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeGrayRange::mutable_e164_list() {
  set_has_e164_list();
  if (e164_list_ == &::google::protobuf::internal::kEmptyString) {
    e164_list_ = new ::std::string;
  }
  return e164_list_;
}
inline ::std::string* TMTUpgradeGrayRange::release_e164_list() {
  clear_has_e164_list();
  if (e164_list_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_list_;
    e164_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeGrayRange::set_allocated_e164_list(::std::string* e164_list) {
  if (e164_list_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_list_;
  }
  if (e164_list) {
    set_has_e164_list();
    e164_list_ = e164_list;
  } else {
    clear_has_e164_list();
    e164_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTUpgradeVersionInfo

// optional uint32 ver_id = 1;
inline bool TMTUpgradeVersionInfo::has_ver_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUpgradeVersionInfo::set_has_ver_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUpgradeVersionInfo::clear_has_ver_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUpgradeVersionInfo::clear_ver_id() {
  ver_id_ = 0u;
  clear_has_ver_id();
}
inline ::google::protobuf::uint32 TMTUpgradeVersionInfo::ver_id() const {
  return ver_id_;
}
inline void TMTUpgradeVersionInfo::set_ver_id(::google::protobuf::uint32 value) {
  set_has_ver_id();
  ver_id_ = value;
}

// optional string oem_mark = 2;
inline bool TMTUpgradeVersionInfo::has_oem_mark() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUpgradeVersionInfo::set_has_oem_mark() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUpgradeVersionInfo::clear_has_oem_mark() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUpgradeVersionInfo::clear_oem_mark() {
  if (oem_mark_ != &::google::protobuf::internal::kEmptyString) {
    oem_mark_->clear();
  }
  clear_has_oem_mark();
}
inline const ::std::string& TMTUpgradeVersionInfo::oem_mark() const {
  return *oem_mark_;
}
inline void TMTUpgradeVersionInfo::set_oem_mark(const ::std::string& value) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(value);
}
inline void TMTUpgradeVersionInfo::set_oem_mark(const char* value) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(value);
}
inline void TMTUpgradeVersionInfo::set_oem_mark(const char* value, size_t size) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeVersionInfo::mutable_oem_mark() {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  return oem_mark_;
}
inline ::std::string* TMTUpgradeVersionInfo::release_oem_mark() {
  clear_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oem_mark_;
    oem_mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeVersionInfo::set_allocated_oem_mark(::std::string* oem_mark) {
  if (oem_mark_ != &::google::protobuf::internal::kEmptyString) {
    delete oem_mark_;
  }
  if (oem_mark) {
    set_has_oem_mark();
    oem_mark_ = oem_mark;
  } else {
    clear_has_oem_mark();
    oem_mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dev_Type = 3;
inline bool TMTUpgradeVersionInfo::has_dev_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTUpgradeVersionInfo::set_has_dev_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTUpgradeVersionInfo::clear_has_dev_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTUpgradeVersionInfo::clear_dev_type() {
  if (dev_type_ != &::google::protobuf::internal::kEmptyString) {
    dev_type_->clear();
  }
  clear_has_dev_type();
}
inline const ::std::string& TMTUpgradeVersionInfo::dev_type() const {
  return *dev_type_;
}
inline void TMTUpgradeVersionInfo::set_dev_type(const ::std::string& value) {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  dev_type_->assign(value);
}
inline void TMTUpgradeVersionInfo::set_dev_type(const char* value) {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  dev_type_->assign(value);
}
inline void TMTUpgradeVersionInfo::set_dev_type(const char* value, size_t size) {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  dev_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeVersionInfo::mutable_dev_type() {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  return dev_type_;
}
inline ::std::string* TMTUpgradeVersionInfo::release_dev_type() {
  clear_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dev_type_;
    dev_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeVersionInfo::set_allocated_dev_type(::std::string* dev_type) {
  if (dev_type_ != &::google::protobuf::internal::kEmptyString) {
    delete dev_type_;
  }
  if (dev_type) {
    set_has_dev_type();
    dev_type_ = dev_type;
  } else {
    clear_has_dev_type();
    dev_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmUpgradeVerLevel ver_level = 4;
inline bool TMTUpgradeVersionInfo::has_ver_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTUpgradeVersionInfo::set_has_ver_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTUpgradeVersionInfo::clear_has_ver_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTUpgradeVersionInfo::clear_ver_level() {
  ver_level_ = 0;
  clear_has_ver_level();
}
inline ::mt::EmUpgradeVerLevel TMTUpgradeVersionInfo::ver_level() const {
  return static_cast< ::mt::EmUpgradeVerLevel >(ver_level_);
}
inline void TMTUpgradeVersionInfo::set_ver_level(::mt::EmUpgradeVerLevel value) {
  assert(::mt::EmUpgradeVerLevel_IsValid(value));
  set_has_ver_level();
  ver_level_ = value;
}

// optional string soft_ver = 5;
inline bool TMTUpgradeVersionInfo::has_soft_ver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTUpgradeVersionInfo::set_has_soft_ver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTUpgradeVersionInfo::clear_has_soft_ver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTUpgradeVersionInfo::clear_soft_ver() {
  if (soft_ver_ != &::google::protobuf::internal::kEmptyString) {
    soft_ver_->clear();
  }
  clear_has_soft_ver();
}
inline const ::std::string& TMTUpgradeVersionInfo::soft_ver() const {
  return *soft_ver_;
}
inline void TMTUpgradeVersionInfo::set_soft_ver(const ::std::string& value) {
  set_has_soft_ver();
  if (soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    soft_ver_ = new ::std::string;
  }
  soft_ver_->assign(value);
}
inline void TMTUpgradeVersionInfo::set_soft_ver(const char* value) {
  set_has_soft_ver();
  if (soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    soft_ver_ = new ::std::string;
  }
  soft_ver_->assign(value);
}
inline void TMTUpgradeVersionInfo::set_soft_ver(const char* value, size_t size) {
  set_has_soft_ver();
  if (soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    soft_ver_ = new ::std::string;
  }
  soft_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeVersionInfo::mutable_soft_ver() {
  set_has_soft_ver();
  if (soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    soft_ver_ = new ::std::string;
  }
  return soft_ver_;
}
inline ::std::string* TMTUpgradeVersionInfo::release_soft_ver() {
  clear_has_soft_ver();
  if (soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soft_ver_;
    soft_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeVersionInfo::set_allocated_soft_ver(::std::string* soft_ver) {
  if (soft_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete soft_ver_;
  }
  if (soft_ver) {
    set_has_soft_ver();
    soft_ver_ = soft_ver;
  } else {
    clear_has_soft_ver();
    soft_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ver_notes = 6;
inline bool TMTUpgradeVersionInfo::has_ver_notes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTUpgradeVersionInfo::set_has_ver_notes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTUpgradeVersionInfo::clear_has_ver_notes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTUpgradeVersionInfo::clear_ver_notes() {
  if (ver_notes_ != &::google::protobuf::internal::kEmptyString) {
    ver_notes_->clear();
  }
  clear_has_ver_notes();
}
inline const ::std::string& TMTUpgradeVersionInfo::ver_notes() const {
  return *ver_notes_;
}
inline void TMTUpgradeVersionInfo::set_ver_notes(const ::std::string& value) {
  set_has_ver_notes();
  if (ver_notes_ == &::google::protobuf::internal::kEmptyString) {
    ver_notes_ = new ::std::string;
  }
  ver_notes_->assign(value);
}
inline void TMTUpgradeVersionInfo::set_ver_notes(const char* value) {
  set_has_ver_notes();
  if (ver_notes_ == &::google::protobuf::internal::kEmptyString) {
    ver_notes_ = new ::std::string;
  }
  ver_notes_->assign(value);
}
inline void TMTUpgradeVersionInfo::set_ver_notes(const char* value, size_t size) {
  set_has_ver_notes();
  if (ver_notes_ == &::google::protobuf::internal::kEmptyString) {
    ver_notes_ = new ::std::string;
  }
  ver_notes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeVersionInfo::mutable_ver_notes() {
  set_has_ver_notes();
  if (ver_notes_ == &::google::protobuf::internal::kEmptyString) {
    ver_notes_ = new ::std::string;
  }
  return ver_notes_;
}
inline ::std::string* TMTUpgradeVersionInfo::release_ver_notes() {
  clear_has_ver_notes();
  if (ver_notes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ver_notes_;
    ver_notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeVersionInfo::set_allocated_ver_notes(::std::string* ver_notes) {
  if (ver_notes_ != &::google::protobuf::internal::kEmptyString) {
    delete ver_notes_;
  }
  if (ver_notes) {
    set_has_ver_notes();
    ver_notes_ = ver_notes;
  } else {
    clear_has_ver_notes();
    ver_notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 size = 7;
inline bool TMTUpgradeVersionInfo::has_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTUpgradeVersionInfo::set_has_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTUpgradeVersionInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTUpgradeVersionInfo::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 TMTUpgradeVersionInfo::size() const {
  return size_;
}
inline void TMTUpgradeVersionInfo::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// optional .mt.EmUpgradeReleaseAttr ver_attr = 8;
inline bool TMTUpgradeVersionInfo::has_ver_attr() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTUpgradeVersionInfo::set_has_ver_attr() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTUpgradeVersionInfo::clear_has_ver_attr() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTUpgradeVersionInfo::clear_ver_attr() {
  ver_attr_ = 0;
  clear_has_ver_attr();
}
inline ::mt::EmUpgradeReleaseAttr TMTUpgradeVersionInfo::ver_attr() const {
  return static_cast< ::mt::EmUpgradeReleaseAttr >(ver_attr_);
}
inline void TMTUpgradeVersionInfo::set_ver_attr(::mt::EmUpgradeReleaseAttr value) {
  assert(::mt::EmUpgradeReleaseAttr_IsValid(value));
  set_has_ver_attr();
  ver_attr_ = value;
}

// optional string file_name = 9;
inline bool TMTUpgradeVersionInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTUpgradeVersionInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTUpgradeVersionInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTUpgradeVersionInfo::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& TMTUpgradeVersionInfo::file_name() const {
  return *file_name_;
}
inline void TMTUpgradeVersionInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TMTUpgradeVersionInfo::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TMTUpgradeVersionInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeVersionInfo::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* TMTUpgradeVersionInfo::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeVersionInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMTUpgradeGrayRange gray_range = 10;
inline bool TMTUpgradeVersionInfo::has_gray_range() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTUpgradeVersionInfo::set_has_gray_range() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTUpgradeVersionInfo::clear_has_gray_range() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTUpgradeVersionInfo::clear_gray_range() {
  if (gray_range_ != NULL) gray_range_->::mt::TMTUpgradeGrayRange::Clear();
  clear_has_gray_range();
}
inline const ::mt::TMTUpgradeGrayRange& TMTUpgradeVersionInfo::gray_range() const {
  return gray_range_ != NULL ? *gray_range_ : *default_instance_->gray_range_;
}
inline ::mt::TMTUpgradeGrayRange* TMTUpgradeVersionInfo::mutable_gray_range() {
  set_has_gray_range();
  if (gray_range_ == NULL) gray_range_ = new ::mt::TMTUpgradeGrayRange;
  return gray_range_;
}
inline ::mt::TMTUpgradeGrayRange* TMTUpgradeVersionInfo::release_gray_range() {
  clear_has_gray_range();
  ::mt::TMTUpgradeGrayRange* temp = gray_range_;
  gray_range_ = NULL;
  return temp;
}
inline void TMTUpgradeVersionInfo::set_allocated_gray_range(::mt::TMTUpgradeGrayRange* gray_range) {
  delete gray_range_;
  gray_range_ = gray_range;
  if (gray_range) {
    set_has_gray_range();
  } else {
    clear_has_gray_range();
  }
}

// -------------------------------------------------------------------

// TMTUpgradeVersionInfoList

// optional bool is_get_recommend = 1;
inline bool TMTUpgradeVersionInfoList::has_is_get_recommend() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUpgradeVersionInfoList::set_has_is_get_recommend() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUpgradeVersionInfoList::clear_has_is_get_recommend() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUpgradeVersionInfoList::clear_is_get_recommend() {
  is_get_recommend_ = false;
  clear_has_is_get_recommend();
}
inline bool TMTUpgradeVersionInfoList::is_get_recommend() const {
  return is_get_recommend_;
}
inline void TMTUpgradeVersionInfoList::set_is_get_recommend(bool value) {
  set_has_is_get_recommend();
  is_get_recommend_ = value;
}

// repeated .mt.TMTUpgradeVersionInfo ver_list = 2;
inline int TMTUpgradeVersionInfoList::ver_list_size() const {
  return ver_list_.size();
}
inline void TMTUpgradeVersionInfoList::clear_ver_list() {
  ver_list_.Clear();
}
inline const ::mt::TMTUpgradeVersionInfo& TMTUpgradeVersionInfoList::ver_list(int index) const {
  return ver_list_.Get(index);
}
inline ::mt::TMTUpgradeVersionInfo* TMTUpgradeVersionInfoList::mutable_ver_list(int index) {
  return ver_list_.Mutable(index);
}
inline ::mt::TMTUpgradeVersionInfo* TMTUpgradeVersionInfoList::add_ver_list() {
  return ver_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUpgradeVersionInfo >&
TMTUpgradeVersionInfoList::ver_list() const {
  return ver_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUpgradeVersionInfo >*
TMTUpgradeVersionInfoList::mutable_ver_list() {
  return &ver_list_;
}

// -------------------------------------------------------------------

// TMTUpgradeDownloadInfo

// optional uint32 errcode = 1;
inline bool TMTUpgradeDownloadInfo::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUpgradeDownloadInfo::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUpgradeDownloadInfo::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUpgradeDownloadInfo::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 TMTUpgradeDownloadInfo::errcode() const {
  return errcode_;
}
inline void TMTUpgradeDownloadInfo::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
}

// optional uint32 total_percent = 2;
inline bool TMTUpgradeDownloadInfo::has_total_percent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUpgradeDownloadInfo::set_has_total_percent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUpgradeDownloadInfo::clear_has_total_percent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUpgradeDownloadInfo::clear_total_percent() {
  total_percent_ = 0u;
  clear_has_total_percent();
}
inline ::google::protobuf::uint32 TMTUpgradeDownloadInfo::total_percent() const {
  return total_percent_;
}
inline void TMTUpgradeDownloadInfo::set_total_percent(::google::protobuf::uint32 value) {
  set_has_total_percent();
  total_percent_ = value;
}

// optional uint32 cur_percent = 3;
inline bool TMTUpgradeDownloadInfo::has_cur_percent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTUpgradeDownloadInfo::set_has_cur_percent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTUpgradeDownloadInfo::clear_has_cur_percent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTUpgradeDownloadInfo::clear_cur_percent() {
  cur_percent_ = 0u;
  clear_has_cur_percent();
}
inline ::google::protobuf::uint32 TMTUpgradeDownloadInfo::cur_percent() const {
  return cur_percent_;
}
inline void TMTUpgradeDownloadInfo::set_cur_percent(::google::protobuf::uint32 value) {
  set_has_cur_percent();
  cur_percent_ = value;
}

// optional string cur_file_name = 4;
inline bool TMTUpgradeDownloadInfo::has_cur_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTUpgradeDownloadInfo::set_has_cur_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTUpgradeDownloadInfo::clear_has_cur_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTUpgradeDownloadInfo::clear_cur_file_name() {
  if (cur_file_name_ != &::google::protobuf::internal::kEmptyString) {
    cur_file_name_->clear();
  }
  clear_has_cur_file_name();
}
inline const ::std::string& TMTUpgradeDownloadInfo::cur_file_name() const {
  return *cur_file_name_;
}
inline void TMTUpgradeDownloadInfo::set_cur_file_name(const ::std::string& value) {
  set_has_cur_file_name();
  if (cur_file_name_ == &::google::protobuf::internal::kEmptyString) {
    cur_file_name_ = new ::std::string;
  }
  cur_file_name_->assign(value);
}
inline void TMTUpgradeDownloadInfo::set_cur_file_name(const char* value) {
  set_has_cur_file_name();
  if (cur_file_name_ == &::google::protobuf::internal::kEmptyString) {
    cur_file_name_ = new ::std::string;
  }
  cur_file_name_->assign(value);
}
inline void TMTUpgradeDownloadInfo::set_cur_file_name(const char* value, size_t size) {
  set_has_cur_file_name();
  if (cur_file_name_ == &::google::protobuf::internal::kEmptyString) {
    cur_file_name_ = new ::std::string;
  }
  cur_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUpgradeDownloadInfo::mutable_cur_file_name() {
  set_has_cur_file_name();
  if (cur_file_name_ == &::google::protobuf::internal::kEmptyString) {
    cur_file_name_ = new ::std::string;
  }
  return cur_file_name_;
}
inline ::std::string* TMTUpgradeDownloadInfo::release_cur_file_name() {
  clear_has_cur_file_name();
  if (cur_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cur_file_name_;
    cur_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUpgradeDownloadInfo::set_allocated_cur_file_name(::std::string* cur_file_name) {
  if (cur_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete cur_file_name_;
  }
  if (cur_file_name) {
    set_has_cur_file_name();
    cur_file_name_ = cur_file_name;
  } else {
    clear_has_cur_file_name();
    cur_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTUsedPort

// optional string name = 2;
inline bool TMTUsedPort::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUsedPort::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUsedPort::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUsedPort::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTUsedPort::name() const {
  return *name_;
}
inline void TMTUsedPort::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTUsedPort::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTUsedPort::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTUsedPort::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTUsedPort::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTUsedPort::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 1;
inline bool TMTUsedPort::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTUsedPort::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTUsedPort::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTUsedPort::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMTUsedPort::port() const {
  return port_;
}
inline void TMTUsedPort::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMTUsedPortList

// optional .mt.EmPortType type = 1;
inline bool TMTUsedPortList::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTUsedPortList::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTUsedPortList::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTUsedPortList::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmPortType TMTUsedPortList::type() const {
  return static_cast< ::mt::EmPortType >(type_);
}
inline void TMTUsedPortList::set_type(::mt::EmPortType value) {
  assert(::mt::EmPortType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .mt.TMTUsedPort list = 2;
inline int TMTUsedPortList::list_size() const {
  return list_.size();
}
inline void TMTUsedPortList::clear_list() {
  list_.Clear();
}
inline const ::mt::TMTUsedPort& TMTUsedPortList::list(int index) const {
  return list_.Get(index);
}
inline ::mt::TMTUsedPort* TMTUsedPortList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::mt::TMTUsedPort* TMTUsedPortList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUsedPort >&
TMTUsedPortList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUsedPort >*
TMTUsedPortList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// TMTTotalUsedPort

// repeated .mt.TMTUsedPortList list = 1;
inline int TMTTotalUsedPort::list_size() const {
  return list_.size();
}
inline void TMTTotalUsedPort::clear_list() {
  list_.Clear();
}
inline const ::mt::TMTUsedPortList& TMTTotalUsedPort::list(int index) const {
  return list_.Get(index);
}
inline ::mt::TMTUsedPortList* TMTTotalUsedPort::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::mt::TMTUsedPortList* TMTTotalUsedPort::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTUsedPortList >&
TMTTotalUsedPort::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTUsedPortList >*
TMTTotalUsedPort::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// TMTAudioPriorCfg

// optional .mt.EmAudFormat audio_format = 1;
inline bool TMTAudioPriorCfg::has_audio_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTAudioPriorCfg::set_has_audio_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTAudioPriorCfg::clear_has_audio_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTAudioPriorCfg::clear_audio_format() {
  audio_format_ = 0;
  clear_has_audio_format();
}
inline ::mt::EmAudFormat TMTAudioPriorCfg::audio_format() const {
  return static_cast< ::mt::EmAudFormat >(audio_format_);
}
inline void TMTAudioPriorCfg::set_audio_format(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_audio_format();
  audio_format_ = value;
}

// optional .mt.EmAacChnlNum aac_channel_num = 2;
inline bool TMTAudioPriorCfg::has_aac_channel_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTAudioPriorCfg::set_has_aac_channel_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTAudioPriorCfg::clear_has_aac_channel_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTAudioPriorCfg::clear_aac_channel_num() {
  aac_channel_num_ = 0;
  clear_has_aac_channel_num();
}
inline ::mt::EmAacChnlNum TMTAudioPriorCfg::aac_channel_num() const {
  return static_cast< ::mt::EmAacChnlNum >(aac_channel_num_);
}
inline void TMTAudioPriorCfg::set_aac_channel_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_aac_channel_num();
  aac_channel_num_ = value;
}

// optional .mt.EmAacSampFreq aac_samp_freq = 3;
inline bool TMTAudioPriorCfg::has_aac_samp_freq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTAudioPriorCfg::set_has_aac_samp_freq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTAudioPriorCfg::clear_has_aac_samp_freq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTAudioPriorCfg::clear_aac_samp_freq() {
  aac_samp_freq_ = 0;
  clear_has_aac_samp_freq();
}
inline ::mt::EmAacSampFreq TMTAudioPriorCfg::aac_samp_freq() const {
  return static_cast< ::mt::EmAacSampFreq >(aac_samp_freq_);
}
inline void TMTAudioPriorCfg::set_aac_samp_freq(::mt::EmAacSampFreq value) {
  assert(::mt::EmAacSampFreq_IsValid(value));
  set_has_aac_samp_freq();
  aac_samp_freq_ = value;
}

// -------------------------------------------------------------------

// TVidPriorParam

// optional .mt.EmVidFormat video_format = 1;
inline bool TVidPriorParam::has_video_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVidPriorParam::set_has_video_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVidPriorParam::clear_has_video_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVidPriorParam::clear_video_format() {
  video_format_ = 0;
  clear_has_video_format();
}
inline ::mt::EmVidFormat TVidPriorParam::video_format() const {
  return static_cast< ::mt::EmVidFormat >(video_format_);
}
inline void TVidPriorParam::set_video_format(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_video_format();
  video_format_ = value;
}

// optional .mt.EmMtResolution video_res = 2;
inline bool TVidPriorParam::has_video_res() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVidPriorParam::set_has_video_res() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVidPriorParam::clear_has_video_res() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVidPriorParam::clear_video_res() {
  video_res_ = 0;
  clear_has_video_res();
}
inline ::mt::EmMtResolution TVidPriorParam::video_res() const {
  return static_cast< ::mt::EmMtResolution >(video_res_);
}
inline void TVidPriorParam::set_video_res(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_video_res();
  video_res_ = value;
}

// -------------------------------------------------------------------

// TMTMainVideoPriorCfg

// repeated .mt.TVidPriorParam video_prior_param = 1;
inline int TMTMainVideoPriorCfg::video_prior_param_size() const {
  return video_prior_param_.size();
}
inline void TMTMainVideoPriorCfg::clear_video_prior_param() {
  video_prior_param_.Clear();
}
inline const ::mt::TVidPriorParam& TMTMainVideoPriorCfg::video_prior_param(int index) const {
  return video_prior_param_.Get(index);
}
inline ::mt::TVidPriorParam* TMTMainVideoPriorCfg::mutable_video_prior_param(int index) {
  return video_prior_param_.Mutable(index);
}
inline ::mt::TVidPriorParam* TMTMainVideoPriorCfg::add_video_prior_param() {
  return video_prior_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidPriorParam >&
TMTMainVideoPriorCfg::video_prior_param() const {
  return video_prior_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidPriorParam >*
TMTMainVideoPriorCfg::mutable_video_prior_param() {
  return &video_prior_param_;
}

// -------------------------------------------------------------------

// TMTCodecVidSrcInfo

// optional .mt.EmCodecComponentIndex codec_cp_index = 1;
inline bool TMTCodecVidSrcInfo::has_codec_cp_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCodecVidSrcInfo::set_has_codec_cp_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCodecVidSrcInfo::clear_has_codec_cp_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCodecVidSrcInfo::clear_codec_cp_index() {
  codec_cp_index_ = 0;
  clear_has_codec_cp_index();
}
inline ::mt::EmCodecComponentIndex TMTCodecVidSrcInfo::codec_cp_index() const {
  return static_cast< ::mt::EmCodecComponentIndex >(codec_cp_index_);
}
inline void TMTCodecVidSrcInfo::set_codec_cp_index(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_codec_cp_index();
  codec_cp_index_ = value;
}

// optional .mt.EmVidPort vid_port = 2;
inline bool TMTCodecVidSrcInfo::has_vid_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCodecVidSrcInfo::set_has_vid_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCodecVidSrcInfo::clear_has_vid_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCodecVidSrcInfo::clear_vid_port() {
  vid_port_ = 0;
  clear_has_vid_port();
}
inline ::mt::EmVidPort TMTCodecVidSrcInfo::vid_port() const {
  return static_cast< ::mt::EmVidPort >(vid_port_);
}
inline void TMTCodecVidSrcInfo::set_vid_port(::mt::EmVidPort value) {
  assert(::mt::EmVidPort_IsValid(value));
  set_has_vid_port();
  vid_port_ = value;
}

// -------------------------------------------------------------------

// TAdjustAecParamCfg

// optional bool bAudo = 1;
inline bool TAdjustAecParamCfg::has_baudo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAdjustAecParamCfg::set_has_baudo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAdjustAecParamCfg::clear_has_baudo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAdjustAecParamCfg::clear_baudo() {
  baudo_ = false;
  clear_has_baudo();
}
inline bool TAdjustAecParamCfg::baudo() const {
  return baudo_;
}
inline void TAdjustAecParamCfg::set_baudo(bool value) {
  set_has_baudo();
  baudo_ = value;
}

// optional uint32 Val = 2;
inline bool TAdjustAecParamCfg::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAdjustAecParamCfg::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAdjustAecParamCfg::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAdjustAecParamCfg::clear_val() {
  val_ = 0u;
  clear_has_val();
}
inline ::google::protobuf::uint32 TAdjustAecParamCfg::val() const {
  return val_;
}
inline void TAdjustAecParamCfg::set_val(::google::protobuf::uint32 value) {
  set_has_val();
  val_ = value;
}

// optional bool bEnable = 3;
inline bool TAdjustAecParamCfg::has_benable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAdjustAecParamCfg::set_has_benable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAdjustAecParamCfg::clear_has_benable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAdjustAecParamCfg::clear_benable() {
  benable_ = false;
  clear_has_benable();
}
inline bool TAdjustAecParamCfg::benable() const {
  return benable_;
}
inline void TAdjustAecParamCfg::set_benable(bool value) {
  set_has_benable();
  benable_ = value;
}

// optional uint32 manualVal = 4;
inline bool TAdjustAecParamCfg::has_manualval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAdjustAecParamCfg::set_has_manualval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAdjustAecParamCfg::clear_has_manualval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAdjustAecParamCfg::clear_manualval() {
  manualval_ = 0u;
  clear_has_manualval();
}
inline ::google::protobuf::uint32 TAdjustAecParamCfg::manualval() const {
  return manualval_;
}
inline void TAdjustAecParamCfg::set_manualval(::google::protobuf::uint32 value) {
  set_has_manualval();
  manualval_ = value;
}

// -------------------------------------------------------------------

// TMTRestoreDefaultCfgInfo

// repeated string key_list = 1;
inline int TMTRestoreDefaultCfgInfo::key_list_size() const {
  return key_list_.size();
}
inline void TMTRestoreDefaultCfgInfo::clear_key_list() {
  key_list_.Clear();
}
inline const ::std::string& TMTRestoreDefaultCfgInfo::key_list(int index) const {
  return key_list_.Get(index);
}
inline ::std::string* TMTRestoreDefaultCfgInfo::mutable_key_list(int index) {
  return key_list_.Mutable(index);
}
inline void TMTRestoreDefaultCfgInfo::set_key_list(int index, const ::std::string& value) {
  key_list_.Mutable(index)->assign(value);
}
inline void TMTRestoreDefaultCfgInfo::set_key_list(int index, const char* value) {
  key_list_.Mutable(index)->assign(value);
}
inline void TMTRestoreDefaultCfgInfo::set_key_list(int index, const char* value, size_t size) {
  key_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTRestoreDefaultCfgInfo::add_key_list() {
  return key_list_.Add();
}
inline void TMTRestoreDefaultCfgInfo::add_key_list(const ::std::string& value) {
  key_list_.Add()->assign(value);
}
inline void TMTRestoreDefaultCfgInfo::add_key_list(const char* value) {
  key_list_.Add()->assign(value);
}
inline void TMTRestoreDefaultCfgInfo::add_key_list(const char* value, size_t size) {
  key_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TMTRestoreDefaultCfgInfo::key_list() const {
  return key_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TMTRestoreDefaultCfgInfo::mutable_key_list() {
  return &key_list_;
}

// -------------------------------------------------------------------

// TMTVideoOutPortMode

// optional .mt.EmVideoOutPutMode first_priom_video_res = 1;
inline bool TMTVideoOutPortMode::has_first_priom_video_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVideoOutPortMode::set_has_first_priom_video_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVideoOutPortMode::clear_has_first_priom_video_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVideoOutPortMode::clear_first_priom_video_res() {
  first_priom_video_res_ = 0;
  clear_has_first_priom_video_res();
}
inline ::mt::EmVideoOutPutMode TMTVideoOutPortMode::first_priom_video_res() const {
  return static_cast< ::mt::EmVideoOutPutMode >(first_priom_video_res_);
}
inline void TMTVideoOutPortMode::set_first_priom_video_res(::mt::EmVideoOutPutMode value) {
  assert(::mt::EmVideoOutPutMode_IsValid(value));
  set_has_first_priom_video_res();
  first_priom_video_res_ = value;
}

// optional .mt.EmVideoOutPutMode first_priom_vga_res = 2;
inline bool TMTVideoOutPortMode::has_first_priom_vga_res() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVideoOutPortMode::set_has_first_priom_vga_res() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVideoOutPortMode::clear_has_first_priom_vga_res() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVideoOutPortMode::clear_first_priom_vga_res() {
  first_priom_vga_res_ = 0;
  clear_has_first_priom_vga_res();
}
inline ::mt::EmVideoOutPutMode TMTVideoOutPortMode::first_priom_vga_res() const {
  return static_cast< ::mt::EmVideoOutPutMode >(first_priom_vga_res_);
}
inline void TMTVideoOutPortMode::set_first_priom_vga_res(::mt::EmVideoOutPutMode value) {
  assert(::mt::EmVideoOutPutMode_IsValid(value));
  set_has_first_priom_vga_res();
  first_priom_vga_res_ = value;
}

// optional .mt.EmVideoOutPutMode second_priom_video_res = 3;
inline bool TMTVideoOutPortMode::has_second_priom_video_res() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTVideoOutPortMode::set_has_second_priom_video_res() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTVideoOutPortMode::clear_has_second_priom_video_res() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTVideoOutPortMode::clear_second_priom_video_res() {
  second_priom_video_res_ = 0;
  clear_has_second_priom_video_res();
}
inline ::mt::EmVideoOutPutMode TMTVideoOutPortMode::second_priom_video_res() const {
  return static_cast< ::mt::EmVideoOutPutMode >(second_priom_video_res_);
}
inline void TMTVideoOutPortMode::set_second_priom_video_res(::mt::EmVideoOutPutMode value) {
  assert(::mt::EmVideoOutPutMode_IsValid(value));
  set_has_second_priom_video_res();
  second_priom_video_res_ = value;
}

// optional .mt.EmVideoOutPutMode second_priom_vga_res = 4;
inline bool TMTVideoOutPortMode::has_second_priom_vga_res() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTVideoOutPortMode::set_has_second_priom_vga_res() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTVideoOutPortMode::clear_has_second_priom_vga_res() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTVideoOutPortMode::clear_second_priom_vga_res() {
  second_priom_vga_res_ = 0;
  clear_has_second_priom_vga_res();
}
inline ::mt::EmVideoOutPutMode TMTVideoOutPortMode::second_priom_vga_res() const {
  return static_cast< ::mt::EmVideoOutPutMode >(second_priom_vga_res_);
}
inline void TMTVideoOutPortMode::set_second_priom_vga_res(::mt::EmVideoOutPutMode value) {
  assert(::mt::EmVideoOutPutMode_IsValid(value));
  set_has_second_priom_vga_res();
  second_priom_vga_res_ = value;
}

// optional .mt.EmVideoOutPutMode ass_video_res = 5;
inline bool TMTVideoOutPortMode::has_ass_video_res() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTVideoOutPortMode::set_has_ass_video_res() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTVideoOutPortMode::clear_has_ass_video_res() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTVideoOutPortMode::clear_ass_video_res() {
  ass_video_res_ = 0;
  clear_has_ass_video_res();
}
inline ::mt::EmVideoOutPutMode TMTVideoOutPortMode::ass_video_res() const {
  return static_cast< ::mt::EmVideoOutPutMode >(ass_video_res_);
}
inline void TMTVideoOutPortMode::set_ass_video_res(::mt::EmVideoOutPutMode value) {
  assert(::mt::EmVideoOutPutMode_IsValid(value));
  set_has_ass_video_res();
  ass_video_res_ = value;
}

// -------------------------------------------------------------------

// TMTBannerInfo

// optional bool bEnable = 1;
inline bool TMTBannerInfo::has_benable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTBannerInfo::set_has_benable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTBannerInfo::clear_has_benable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTBannerInfo::clear_benable() {
  benable_ = false;
  clear_has_benable();
}
inline bool TMTBannerInfo::benable() const {
  return benable_;
}
inline void TMTBannerInfo::set_benable(bool value) {
  set_has_benable();
  benable_ = value;
}

// optional uint32 UseType = 2;
inline bool TMTBannerInfo::has_usetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTBannerInfo::set_has_usetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTBannerInfo::clear_has_usetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTBannerInfo::clear_usetype() {
  usetype_ = 0u;
  clear_has_usetype();
}
inline ::google::protobuf::uint32 TMTBannerInfo::usetype() const {
  return usetype_;
}
inline void TMTBannerInfo::set_usetype(::google::protobuf::uint32 value) {
  set_has_usetype();
  usetype_ = value;
}

// optional string bk_color = 3;
inline bool TMTBannerInfo::has_bk_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTBannerInfo::set_has_bk_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTBannerInfo::clear_has_bk_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTBannerInfo::clear_bk_color() {
  if (bk_color_ != &::google::protobuf::internal::kEmptyString) {
    bk_color_->clear();
  }
  clear_has_bk_color();
}
inline const ::std::string& TMTBannerInfo::bk_color() const {
  return *bk_color_;
}
inline void TMTBannerInfo::set_bk_color(const ::std::string& value) {
  set_has_bk_color();
  if (bk_color_ == &::google::protobuf::internal::kEmptyString) {
    bk_color_ = new ::std::string;
  }
  bk_color_->assign(value);
}
inline void TMTBannerInfo::set_bk_color(const char* value) {
  set_has_bk_color();
  if (bk_color_ == &::google::protobuf::internal::kEmptyString) {
    bk_color_ = new ::std::string;
  }
  bk_color_->assign(value);
}
inline void TMTBannerInfo::set_bk_color(const char* value, size_t size) {
  set_has_bk_color();
  if (bk_color_ == &::google::protobuf::internal::kEmptyString) {
    bk_color_ = new ::std::string;
  }
  bk_color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBannerInfo::mutable_bk_color() {
  set_has_bk_color();
  if (bk_color_ == &::google::protobuf::internal::kEmptyString) {
    bk_color_ = new ::std::string;
  }
  return bk_color_;
}
inline ::std::string* TMTBannerInfo::release_bk_color() {
  clear_has_bk_color();
  if (bk_color_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bk_color_;
    bk_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBannerInfo::set_allocated_bk_color(::std::string* bk_color) {
  if (bk_color_ != &::google::protobuf::internal::kEmptyString) {
    delete bk_color_;
  }
  if (bk_color) {
    set_has_bk_color();
    bk_color_ = bk_color;
  } else {
    clear_has_bk_color();
    bk_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmTextAlign TextAlign = 4;
inline bool TMTBannerInfo::has_textalign() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTBannerInfo::set_has_textalign() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTBannerInfo::clear_has_textalign() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTBannerInfo::clear_textalign() {
  textalign_ = 0;
  clear_has_textalign();
}
inline ::mt::EmTextAlign TMTBannerInfo::textalign() const {
  return static_cast< ::mt::EmTextAlign >(textalign_);
}
inline void TMTBannerInfo::set_textalign(::mt::EmTextAlign value) {
  assert(::mt::EmTextAlign_IsValid(value));
  set_has_textalign();
  textalign_ = value;
}

// optional .mt.EmRollMode RollMode = 5;
inline bool TMTBannerInfo::has_rollmode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTBannerInfo::set_has_rollmode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTBannerInfo::clear_has_rollmode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTBannerInfo::clear_rollmode() {
  rollmode_ = 0;
  clear_has_rollmode();
}
inline ::mt::EmRollMode TMTBannerInfo::rollmode() const {
  return static_cast< ::mt::EmRollMode >(rollmode_);
}
inline void TMTBannerInfo::set_rollmode(::mt::EmRollMode value) {
  assert(::mt::EmRollMode_IsValid(value));
  set_has_rollmode();
  rollmode_ = value;
}

// optional uint32 TransParent = 6;
inline bool TMTBannerInfo::has_transparent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTBannerInfo::set_has_transparent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTBannerInfo::clear_has_transparent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTBannerInfo::clear_transparent() {
  transparent_ = 0u;
  clear_has_transparent();
}
inline ::google::protobuf::uint32 TMTBannerInfo::transparent() const {
  return transparent_;
}
inline void TMTBannerInfo::set_transparent(::google::protobuf::uint32 value) {
  set_has_transparent();
  transparent_ = value;
}

// optional .mt.EmRollSpeed RollSpeed = 7;
inline bool TMTBannerInfo::has_rollspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTBannerInfo::set_has_rollspeed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTBannerInfo::clear_has_rollspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTBannerInfo::clear_rollspeed() {
  rollspeed_ = 0;
  clear_has_rollspeed();
}
inline ::mt::EmRollSpeed TMTBannerInfo::rollspeed() const {
  return static_cast< ::mt::EmRollSpeed >(rollspeed_);
}
inline void TMTBannerInfo::set_rollspeed(::mt::EmRollSpeed value) {
  assert(::mt::EmRollSpeed_IsValid(value));
  set_has_rollspeed();
  rollspeed_ = value;
}

// optional uint32 RollNum = 8;
inline bool TMTBannerInfo::has_rollnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTBannerInfo::set_has_rollnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTBannerInfo::clear_has_rollnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTBannerInfo::clear_rollnum() {
  rollnum_ = 0u;
  clear_has_rollnum();
}
inline ::google::protobuf::uint32 TMTBannerInfo::rollnum() const {
  return rollnum_;
}
inline void TMTBannerInfo::set_rollnum(::google::protobuf::uint32 value) {
  set_has_rollnum();
  rollnum_ = value;
}

// optional uint32 StayTime = 9;
inline bool TMTBannerInfo::has_staytime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMTBannerInfo::set_has_staytime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMTBannerInfo::clear_has_staytime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMTBannerInfo::clear_staytime() {
  staytime_ = 0u;
  clear_has_staytime();
}
inline ::google::protobuf::uint32 TMTBannerInfo::staytime() const {
  return staytime_;
}
inline void TMTBannerInfo::set_staytime(::google::protobuf::uint32 value) {
  set_has_staytime();
  staytime_ = value;
}

// optional .mt.TMTSymboPoint BannerCoordinate = 10;
inline bool TMTBannerInfo::has_bannercoordinate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMTBannerInfo::set_has_bannercoordinate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMTBannerInfo::clear_has_bannercoordinate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMTBannerInfo::clear_bannercoordinate() {
  if (bannercoordinate_ != NULL) bannercoordinate_->::mt::TMTSymboPoint::Clear();
  clear_has_bannercoordinate();
}
inline const ::mt::TMTSymboPoint& TMTBannerInfo::bannercoordinate() const {
  return bannercoordinate_ != NULL ? *bannercoordinate_ : *default_instance_->bannercoordinate_;
}
inline ::mt::TMTSymboPoint* TMTBannerInfo::mutable_bannercoordinate() {
  set_has_bannercoordinate();
  if (bannercoordinate_ == NULL) bannercoordinate_ = new ::mt::TMTSymboPoint;
  return bannercoordinate_;
}
inline ::mt::TMTSymboPoint* TMTBannerInfo::release_bannercoordinate() {
  clear_has_bannercoordinate();
  ::mt::TMTSymboPoint* temp = bannercoordinate_;
  bannercoordinate_ = NULL;
  return temp;
}
inline void TMTBannerInfo::set_allocated_bannercoordinate(::mt::TMTSymboPoint* bannercoordinate) {
  delete bannercoordinate_;
  bannercoordinate_ = bannercoordinate;
  if (bannercoordinate) {
    set_has_bannercoordinate();
  } else {
    clear_has_bannercoordinate();
  }
}

// optional uint32 DisplayWidth = 11;
inline bool TMTBannerInfo::has_displaywidth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMTBannerInfo::set_has_displaywidth() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMTBannerInfo::clear_has_displaywidth() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMTBannerInfo::clear_displaywidth() {
  displaywidth_ = 0u;
  clear_has_displaywidth();
}
inline ::google::protobuf::uint32 TMTBannerInfo::displaywidth() const {
  return displaywidth_;
}
inline void TMTBannerInfo::set_displaywidth(::google::protobuf::uint32 value) {
  set_has_displaywidth();
  displaywidth_ = value;
}

// optional uint32 DisplayHeight = 12;
inline bool TMTBannerInfo::has_displayheight() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMTBannerInfo::set_has_displayheight() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMTBannerInfo::clear_has_displayheight() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMTBannerInfo::clear_displayheight() {
  displayheight_ = 0u;
  clear_has_displayheight();
}
inline ::google::protobuf::uint32 TMTBannerInfo::displayheight() const {
  return displayheight_;
}
inline void TMTBannerInfo::set_displayheight(::google::protobuf::uint32 value) {
  set_has_displayheight();
  displayheight_ = value;
}

// optional uint32 TextLineSpace = 13;
inline bool TMTBannerInfo::has_textlinespace() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMTBannerInfo::set_has_textlinespace() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMTBannerInfo::clear_has_textlinespace() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMTBannerInfo::clear_textlinespace() {
  textlinespace_ = 0u;
  clear_has_textlinespace();
}
inline ::google::protobuf::uint32 TMTBannerInfo::textlinespace() const {
  return textlinespace_;
}
inline void TMTBannerInfo::set_textlinespace(::google::protobuf::uint32 value) {
  set_has_textlinespace();
  textlinespace_ = value;
}

// optional uint32 TextLineNum = 14;
inline bool TMTBannerInfo::has_textlinenum() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMTBannerInfo::set_has_textlinenum() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMTBannerInfo::clear_has_textlinenum() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMTBannerInfo::clear_textlinenum() {
  textlinenum_ = 0u;
  clear_has_textlinenum();
}
inline ::google::protobuf::uint32 TMTBannerInfo::textlinenum() const {
  return textlinenum_;
}
inline void TMTBannerInfo::set_textlinenum(::google::protobuf::uint32 value) {
  set_has_textlinenum();
  textlinenum_ = value;
}

// optional uint32 TextDisplayRatio = 15;
inline bool TMTBannerInfo::has_textdisplayratio() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMTBannerInfo::set_has_textdisplayratio() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMTBannerInfo::clear_has_textdisplayratio() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMTBannerInfo::clear_textdisplayratio() {
  textdisplayratio_ = 0u;
  clear_has_textdisplayratio();
}
inline ::google::protobuf::uint32 TMTBannerInfo::textdisplayratio() const {
  return textdisplayratio_;
}
inline void TMTBannerInfo::set_textdisplayratio(::google::protobuf::uint32 value) {
  set_has_textdisplayratio();
  textdisplayratio_ = value;
}

// repeated .mt.TStringAndTextFormat banner_context = 16;
inline int TMTBannerInfo::banner_context_size() const {
  return banner_context_.size();
}
inline void TMTBannerInfo::clear_banner_context() {
  banner_context_.Clear();
}
inline const ::mt::TStringAndTextFormat& TMTBannerInfo::banner_context(int index) const {
  return banner_context_.Get(index);
}
inline ::mt::TStringAndTextFormat* TMTBannerInfo::mutable_banner_context(int index) {
  return banner_context_.Mutable(index);
}
inline ::mt::TStringAndTextFormat* TMTBannerInfo::add_banner_context() {
  return banner_context_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TStringAndTextFormat >&
TMTBannerInfo::banner_context() const {
  return banner_context_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TStringAndTextFormat >*
TMTBannerInfo::mutable_banner_context() {
  return &banner_context_;
}

// optional string PictureName = 17;
inline bool TMTBannerInfo::has_picturename() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMTBannerInfo::set_has_picturename() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMTBannerInfo::clear_has_picturename() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMTBannerInfo::clear_picturename() {
  if (picturename_ != &::google::protobuf::internal::kEmptyString) {
    picturename_->clear();
  }
  clear_has_picturename();
}
inline const ::std::string& TMTBannerInfo::picturename() const {
  return *picturename_;
}
inline void TMTBannerInfo::set_picturename(const ::std::string& value) {
  set_has_picturename();
  if (picturename_ == &::google::protobuf::internal::kEmptyString) {
    picturename_ = new ::std::string;
  }
  picturename_->assign(value);
}
inline void TMTBannerInfo::set_picturename(const char* value) {
  set_has_picturename();
  if (picturename_ == &::google::protobuf::internal::kEmptyString) {
    picturename_ = new ::std::string;
  }
  picturename_->assign(value);
}
inline void TMTBannerInfo::set_picturename(const char* value, size_t size) {
  set_has_picturename();
  if (picturename_ == &::google::protobuf::internal::kEmptyString) {
    picturename_ = new ::std::string;
  }
  picturename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBannerInfo::mutable_picturename() {
  set_has_picturename();
  if (picturename_ == &::google::protobuf::internal::kEmptyString) {
    picturename_ = new ::std::string;
  }
  return picturename_;
}
inline ::std::string* TMTBannerInfo::release_picturename() {
  clear_has_picturename();
  if (picturename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picturename_;
    picturename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBannerInfo::set_allocated_picturename(::std::string* picturename) {
  if (picturename_ != &::google::protobuf::internal::kEmptyString) {
    delete picturename_;
  }
  if (picturename) {
    set_has_picturename();
    picturename_ = picturename;
  } else {
    clear_has_picturename();
    picturename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string PresetBannerName = 18;
inline bool TMTBannerInfo::has_presetbannername() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMTBannerInfo::set_has_presetbannername() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMTBannerInfo::clear_has_presetbannername() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMTBannerInfo::clear_presetbannername() {
  if (presetbannername_ != &::google::protobuf::internal::kEmptyString) {
    presetbannername_->clear();
  }
  clear_has_presetbannername();
}
inline const ::std::string& TMTBannerInfo::presetbannername() const {
  return *presetbannername_;
}
inline void TMTBannerInfo::set_presetbannername(const ::std::string& value) {
  set_has_presetbannername();
  if (presetbannername_ == &::google::protobuf::internal::kEmptyString) {
    presetbannername_ = new ::std::string;
  }
  presetbannername_->assign(value);
}
inline void TMTBannerInfo::set_presetbannername(const char* value) {
  set_has_presetbannername();
  if (presetbannername_ == &::google::protobuf::internal::kEmptyString) {
    presetbannername_ = new ::std::string;
  }
  presetbannername_->assign(value);
}
inline void TMTBannerInfo::set_presetbannername(const char* value, size_t size) {
  set_has_presetbannername();
  if (presetbannername_ == &::google::protobuf::internal::kEmptyString) {
    presetbannername_ = new ::std::string;
  }
  presetbannername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTBannerInfo::mutable_presetbannername() {
  set_has_presetbannername();
  if (presetbannername_ == &::google::protobuf::internal::kEmptyString) {
    presetbannername_ = new ::std::string;
  }
  return presetbannername_;
}
inline ::std::string* TMTBannerInfo::release_presetbannername() {
  clear_has_presetbannername();
  if (presetbannername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = presetbannername_;
    presetbannername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTBannerInfo::set_allocated_presetbannername(::std::string* presetbannername) {
  if (presetbannername_ != &::google::protobuf::internal::kEmptyString) {
    delete presetbannername_;
  }
  if (presetbannername) {
    set_has_presetbannername();
    presetbannername_ = presetbannername;
  } else {
    clear_has_presetbannername();
    presetbannername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 PresetBannerIndex = 19;
inline bool TMTBannerInfo::has_presetbannerindex() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMTBannerInfo::set_has_presetbannerindex() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMTBannerInfo::clear_has_presetbannerindex() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMTBannerInfo::clear_presetbannerindex() {
  presetbannerindex_ = 0u;
  clear_has_presetbannerindex();
}
inline ::google::protobuf::uint32 TMTBannerInfo::presetbannerindex() const {
  return presetbannerindex_;
}
inline void TMTBannerInfo::set_presetbannerindex(::google::protobuf::uint32 value) {
  set_has_presetbannerindex();
  presetbannerindex_ = value;
}

// -------------------------------------------------------------------

// TMTBannerInfoList

// repeated .mt.TMTBannerInfo banner_info = 1;
inline int TMTBannerInfoList::banner_info_size() const {
  return banner_info_.size();
}
inline void TMTBannerInfoList::clear_banner_info() {
  banner_info_.Clear();
}
inline const ::mt::TMTBannerInfo& TMTBannerInfoList::banner_info(int index) const {
  return banner_info_.Get(index);
}
inline ::mt::TMTBannerInfo* TMTBannerInfoList::mutable_banner_info(int index) {
  return banner_info_.Mutable(index);
}
inline ::mt::TMTBannerInfo* TMTBannerInfoList::add_banner_info() {
  return banner_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTBannerInfo >&
TMTBannerInfoList::banner_info() const {
  return banner_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTBannerInfo >*
TMTBannerInfoList::mutable_banner_info() {
  return &banner_info_;
}

// -------------------------------------------------------------------

// TMTEnablePresetBanner

// optional uint32 BannerIndex = 1;
inline bool TMTEnablePresetBanner::has_bannerindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTEnablePresetBanner::set_has_bannerindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTEnablePresetBanner::clear_has_bannerindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTEnablePresetBanner::clear_bannerindex() {
  bannerindex_ = 0u;
  clear_has_bannerindex();
}
inline ::google::protobuf::uint32 TMTEnablePresetBanner::bannerindex() const {
  return bannerindex_;
}
inline void TMTEnablePresetBanner::set_bannerindex(::google::protobuf::uint32 value) {
  set_has_bannerindex();
  bannerindex_ = value;
}

// optional bool bEnable = 2;
inline bool TMTEnablePresetBanner::has_benable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTEnablePresetBanner::set_has_benable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTEnablePresetBanner::clear_has_benable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTEnablePresetBanner::clear_benable() {
  benable_ = false;
  clear_has_benable();
}
inline bool TMTEnablePresetBanner::benable() const {
  return benable_;
}
inline void TMTEnablePresetBanner::set_benable(bool value) {
  set_has_benable();
  benable_ = value;
}

// -------------------------------------------------------------------

// TMTLabelInfo

// optional .mt.EmLabelType emLabelType = 1;
inline bool TMTLabelInfo::has_emlabeltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTLabelInfo::set_has_emlabeltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTLabelInfo::clear_has_emlabeltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTLabelInfo::clear_emlabeltype() {
  emlabeltype_ = 0;
  clear_has_emlabeltype();
}
inline ::mt::EmLabelType TMTLabelInfo::emlabeltype() const {
  return static_cast< ::mt::EmLabelType >(emlabeltype_);
}
inline void TMTLabelInfo::set_emlabeltype(::mt::EmLabelType value) {
  assert(::mt::EmLabelType_IsValid(value));
  set_has_emlabeltype();
  emlabeltype_ = value;
}

// optional .mt.TMTSymboPoint tLableCoordinate = 2;
inline bool TMTLabelInfo::has_tlablecoordinate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTLabelInfo::set_has_tlablecoordinate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTLabelInfo::clear_has_tlablecoordinate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTLabelInfo::clear_tlablecoordinate() {
  if (tlablecoordinate_ != NULL) tlablecoordinate_->::mt::TMTSymboPoint::Clear();
  clear_has_tlablecoordinate();
}
inline const ::mt::TMTSymboPoint& TMTLabelInfo::tlablecoordinate() const {
  return tlablecoordinate_ != NULL ? *tlablecoordinate_ : *default_instance_->tlablecoordinate_;
}
inline ::mt::TMTSymboPoint* TMTLabelInfo::mutable_tlablecoordinate() {
  set_has_tlablecoordinate();
  if (tlablecoordinate_ == NULL) tlablecoordinate_ = new ::mt::TMTSymboPoint;
  return tlablecoordinate_;
}
inline ::mt::TMTSymboPoint* TMTLabelInfo::release_tlablecoordinate() {
  clear_has_tlablecoordinate();
  ::mt::TMTSymboPoint* temp = tlablecoordinate_;
  tlablecoordinate_ = NULL;
  return temp;
}
inline void TMTLabelInfo::set_allocated_tlablecoordinate(::mt::TMTSymboPoint* tlablecoordinate) {
  delete tlablecoordinate_;
  tlablecoordinate_ = tlablecoordinate;
  if (tlablecoordinate) {
    set_has_tlablecoordinate();
  } else {
    clear_has_tlablecoordinate();
  }
}

// optional .mt.EmLabelPosType emLabelPosType = 3;
inline bool TMTLabelInfo::has_emlabelpostype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTLabelInfo::set_has_emlabelpostype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTLabelInfo::clear_has_emlabelpostype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTLabelInfo::clear_emlabelpostype() {
  emlabelpostype_ = 0;
  clear_has_emlabelpostype();
}
inline ::mt::EmLabelPosType TMTLabelInfo::emlabelpostype() const {
  return static_cast< ::mt::EmLabelPosType >(emlabelpostype_);
}
inline void TMTLabelInfo::set_emlabelpostype(::mt::EmLabelPosType value) {
  assert(::mt::EmLabelPosType_IsValid(value));
  set_has_emlabelpostype();
  emlabelpostype_ = value;
}

// repeated .mt.TStringAndTextFormat custom_label_content = 4;
inline int TMTLabelInfo::custom_label_content_size() const {
  return custom_label_content_.size();
}
inline void TMTLabelInfo::clear_custom_label_content() {
  custom_label_content_.Clear();
}
inline const ::mt::TStringAndTextFormat& TMTLabelInfo::custom_label_content(int index) const {
  return custom_label_content_.Get(index);
}
inline ::mt::TStringAndTextFormat* TMTLabelInfo::mutable_custom_label_content(int index) {
  return custom_label_content_.Mutable(index);
}
inline ::mt::TStringAndTextFormat* TMTLabelInfo::add_custom_label_content() {
  return custom_label_content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TStringAndTextFormat >&
TMTLabelInfo::custom_label_content() const {
  return custom_label_content_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TStringAndTextFormat >*
TMTLabelInfo::mutable_custom_label_content() {
  return &custom_label_content_;
}

// optional string PictureName = 5;
inline bool TMTLabelInfo::has_picturename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTLabelInfo::set_has_picturename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTLabelInfo::clear_has_picturename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTLabelInfo::clear_picturename() {
  if (picturename_ != &::google::protobuf::internal::kEmptyString) {
    picturename_->clear();
  }
  clear_has_picturename();
}
inline const ::std::string& TMTLabelInfo::picturename() const {
  return *picturename_;
}
inline void TMTLabelInfo::set_picturename(const ::std::string& value) {
  set_has_picturename();
  if (picturename_ == &::google::protobuf::internal::kEmptyString) {
    picturename_ = new ::std::string;
  }
  picturename_->assign(value);
}
inline void TMTLabelInfo::set_picturename(const char* value) {
  set_has_picturename();
  if (picturename_ == &::google::protobuf::internal::kEmptyString) {
    picturename_ = new ::std::string;
  }
  picturename_->assign(value);
}
inline void TMTLabelInfo::set_picturename(const char* value, size_t size) {
  set_has_picturename();
  if (picturename_ == &::google::protobuf::internal::kEmptyString) {
    picturename_ = new ::std::string;
  }
  picturename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTLabelInfo::mutable_picturename() {
  set_has_picturename();
  if (picturename_ == &::google::protobuf::internal::kEmptyString) {
    picturename_ = new ::std::string;
  }
  return picturename_;
}
inline ::std::string* TMTLabelInfo::release_picturename() {
  clear_has_picturename();
  if (picturename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picturename_;
    picturename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTLabelInfo::set_allocated_picturename(::std::string* picturename) {
  if (picturename_ != &::google::protobuf::internal::kEmptyString) {
    delete picturename_;
  }
  if (picturename) {
    set_has_picturename();
    picturename_ = picturename;
  } else {
    clear_has_picturename();
    picturename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string AutoTextContent = 6;
inline bool TMTLabelInfo::has_autotextcontent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTLabelInfo::set_has_autotextcontent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTLabelInfo::clear_has_autotextcontent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTLabelInfo::clear_autotextcontent() {
  if (autotextcontent_ != &::google::protobuf::internal::kEmptyString) {
    autotextcontent_->clear();
  }
  clear_has_autotextcontent();
}
inline const ::std::string& TMTLabelInfo::autotextcontent() const {
  return *autotextcontent_;
}
inline void TMTLabelInfo::set_autotextcontent(const ::std::string& value) {
  set_has_autotextcontent();
  if (autotextcontent_ == &::google::protobuf::internal::kEmptyString) {
    autotextcontent_ = new ::std::string;
  }
  autotextcontent_->assign(value);
}
inline void TMTLabelInfo::set_autotextcontent(const char* value) {
  set_has_autotextcontent();
  if (autotextcontent_ == &::google::protobuf::internal::kEmptyString) {
    autotextcontent_ = new ::std::string;
  }
  autotextcontent_->assign(value);
}
inline void TMTLabelInfo::set_autotextcontent(const char* value, size_t size) {
  set_has_autotextcontent();
  if (autotextcontent_ == &::google::protobuf::internal::kEmptyString) {
    autotextcontent_ = new ::std::string;
  }
  autotextcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTLabelInfo::mutable_autotextcontent() {
  set_has_autotextcontent();
  if (autotextcontent_ == &::google::protobuf::internal::kEmptyString) {
    autotextcontent_ = new ::std::string;
  }
  return autotextcontent_;
}
inline ::std::string* TMTLabelInfo::release_autotextcontent() {
  clear_has_autotextcontent();
  if (autotextcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = autotextcontent_;
    autotextcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTLabelInfo::set_allocated_autotextcontent(::std::string* autotextcontent) {
  if (autotextcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete autotextcontent_;
  }
  if (autotextcontent) {
    set_has_autotextcontent();
    autotextcontent_ = autotextcontent;
  } else {
    clear_has_autotextcontent();
    autotextcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TStringAndTextFormat

// optional string facename_type = 1;
inline bool TStringAndTextFormat::has_facename_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TStringAndTextFormat::set_has_facename_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TStringAndTextFormat::clear_has_facename_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TStringAndTextFormat::clear_facename_type() {
  if (facename_type_ != &::google::protobuf::internal::kEmptyString) {
    facename_type_->clear();
  }
  clear_has_facename_type();
}
inline const ::std::string& TStringAndTextFormat::facename_type() const {
  return *facename_type_;
}
inline void TStringAndTextFormat::set_facename_type(const ::std::string& value) {
  set_has_facename_type();
  if (facename_type_ == &::google::protobuf::internal::kEmptyString) {
    facename_type_ = new ::std::string;
  }
  facename_type_->assign(value);
}
inline void TStringAndTextFormat::set_facename_type(const char* value) {
  set_has_facename_type();
  if (facename_type_ == &::google::protobuf::internal::kEmptyString) {
    facename_type_ = new ::std::string;
  }
  facename_type_->assign(value);
}
inline void TStringAndTextFormat::set_facename_type(const char* value, size_t size) {
  set_has_facename_type();
  if (facename_type_ == &::google::protobuf::internal::kEmptyString) {
    facename_type_ = new ::std::string;
  }
  facename_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TStringAndTextFormat::mutable_facename_type() {
  set_has_facename_type();
  if (facename_type_ == &::google::protobuf::internal::kEmptyString) {
    facename_type_ = new ::std::string;
  }
  return facename_type_;
}
inline ::std::string* TStringAndTextFormat::release_facename_type() {
  clear_has_facename_type();
  if (facename_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = facename_type_;
    facename_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TStringAndTextFormat::set_allocated_facename_type(::std::string* facename_type) {
  if (facename_type_ != &::google::protobuf::internal::kEmptyString) {
    delete facename_type_;
  }
  if (facename_type) {
    set_has_facename_type();
    facename_type_ = facename_type;
  } else {
    clear_has_facename_type();
    facename_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string text_color = 2;
inline bool TStringAndTextFormat::has_text_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TStringAndTextFormat::set_has_text_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TStringAndTextFormat::clear_has_text_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TStringAndTextFormat::clear_text_color() {
  if (text_color_ != &::google::protobuf::internal::kEmptyString) {
    text_color_->clear();
  }
  clear_has_text_color();
}
inline const ::std::string& TStringAndTextFormat::text_color() const {
  return *text_color_;
}
inline void TStringAndTextFormat::set_text_color(const ::std::string& value) {
  set_has_text_color();
  if (text_color_ == &::google::protobuf::internal::kEmptyString) {
    text_color_ = new ::std::string;
  }
  text_color_->assign(value);
}
inline void TStringAndTextFormat::set_text_color(const char* value) {
  set_has_text_color();
  if (text_color_ == &::google::protobuf::internal::kEmptyString) {
    text_color_ = new ::std::string;
  }
  text_color_->assign(value);
}
inline void TStringAndTextFormat::set_text_color(const char* value, size_t size) {
  set_has_text_color();
  if (text_color_ == &::google::protobuf::internal::kEmptyString) {
    text_color_ = new ::std::string;
  }
  text_color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TStringAndTextFormat::mutable_text_color() {
  set_has_text_color();
  if (text_color_ == &::google::protobuf::internal::kEmptyString) {
    text_color_ = new ::std::string;
  }
  return text_color_;
}
inline ::std::string* TStringAndTextFormat::release_text_color() {
  clear_has_text_color();
  if (text_color_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_color_;
    text_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TStringAndTextFormat::set_allocated_text_color(::std::string* text_color) {
  if (text_color_ != &::google::protobuf::internal::kEmptyString) {
    delete text_color_;
  }
  if (text_color) {
    set_has_text_color();
    text_color_ = text_color;
  } else {
    clear_has_text_color();
    text_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string text_size = 3;
inline bool TStringAndTextFormat::has_text_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TStringAndTextFormat::set_has_text_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TStringAndTextFormat::clear_has_text_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TStringAndTextFormat::clear_text_size() {
  if (text_size_ != &::google::protobuf::internal::kEmptyString) {
    text_size_->clear();
  }
  clear_has_text_size();
}
inline const ::std::string& TStringAndTextFormat::text_size() const {
  return *text_size_;
}
inline void TStringAndTextFormat::set_text_size(const ::std::string& value) {
  set_has_text_size();
  if (text_size_ == &::google::protobuf::internal::kEmptyString) {
    text_size_ = new ::std::string;
  }
  text_size_->assign(value);
}
inline void TStringAndTextFormat::set_text_size(const char* value) {
  set_has_text_size();
  if (text_size_ == &::google::protobuf::internal::kEmptyString) {
    text_size_ = new ::std::string;
  }
  text_size_->assign(value);
}
inline void TStringAndTextFormat::set_text_size(const char* value, size_t size) {
  set_has_text_size();
  if (text_size_ == &::google::protobuf::internal::kEmptyString) {
    text_size_ = new ::std::string;
  }
  text_size_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TStringAndTextFormat::mutable_text_size() {
  set_has_text_size();
  if (text_size_ == &::google::protobuf::internal::kEmptyString) {
    text_size_ = new ::std::string;
  }
  return text_size_;
}
inline ::std::string* TStringAndTextFormat::release_text_size() {
  clear_has_text_size();
  if (text_size_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_size_;
    text_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TStringAndTextFormat::set_allocated_text_size(::std::string* text_size) {
  if (text_size_ != &::google::protobuf::internal::kEmptyString) {
    delete text_size_;
  }
  if (text_size) {
    set_has_text_size();
    text_size_ = text_size;
  } else {
    clear_has_text_size();
    text_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool text_bold = 4;
inline bool TStringAndTextFormat::has_text_bold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TStringAndTextFormat::set_has_text_bold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TStringAndTextFormat::clear_has_text_bold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TStringAndTextFormat::clear_text_bold() {
  text_bold_ = false;
  clear_has_text_bold();
}
inline bool TStringAndTextFormat::text_bold() const {
  return text_bold_;
}
inline void TStringAndTextFormat::set_text_bold(bool value) {
  set_has_text_bold();
  text_bold_ = value;
}

// optional bool text_italic = 5;
inline bool TStringAndTextFormat::has_text_italic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TStringAndTextFormat::set_has_text_italic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TStringAndTextFormat::clear_has_text_italic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TStringAndTextFormat::clear_text_italic() {
  text_italic_ = false;
  clear_has_text_italic();
}
inline bool TStringAndTextFormat::text_italic() const {
  return text_italic_;
}
inline void TStringAndTextFormat::set_text_italic(bool value) {
  set_has_text_italic();
  text_italic_ = value;
}

// optional bool text_underline = 6;
inline bool TStringAndTextFormat::has_text_underline() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TStringAndTextFormat::set_has_text_underline() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TStringAndTextFormat::clear_has_text_underline() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TStringAndTextFormat::clear_text_underline() {
  text_underline_ = false;
  clear_has_text_underline();
}
inline bool TStringAndTextFormat::text_underline() const {
  return text_underline_;
}
inline void TStringAndTextFormat::set_text_underline(bool value) {
  set_has_text_underline();
  text_underline_ = value;
}

// optional string text_content = 7;
inline bool TStringAndTextFormat::has_text_content() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TStringAndTextFormat::set_has_text_content() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TStringAndTextFormat::clear_has_text_content() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TStringAndTextFormat::clear_text_content() {
  if (text_content_ != &::google::protobuf::internal::kEmptyString) {
    text_content_->clear();
  }
  clear_has_text_content();
}
inline const ::std::string& TStringAndTextFormat::text_content() const {
  return *text_content_;
}
inline void TStringAndTextFormat::set_text_content(const ::std::string& value) {
  set_has_text_content();
  if (text_content_ == &::google::protobuf::internal::kEmptyString) {
    text_content_ = new ::std::string;
  }
  text_content_->assign(value);
}
inline void TStringAndTextFormat::set_text_content(const char* value) {
  set_has_text_content();
  if (text_content_ == &::google::protobuf::internal::kEmptyString) {
    text_content_ = new ::std::string;
  }
  text_content_->assign(value);
}
inline void TStringAndTextFormat::set_text_content(const char* value, size_t size) {
  set_has_text_content();
  if (text_content_ == &::google::protobuf::internal::kEmptyString) {
    text_content_ = new ::std::string;
  }
  text_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TStringAndTextFormat::mutable_text_content() {
  set_has_text_content();
  if (text_content_ == &::google::protobuf::internal::kEmptyString) {
    text_content_ = new ::std::string;
  }
  return text_content_;
}
inline ::std::string* TStringAndTextFormat::release_text_content() {
  clear_has_text_content();
  if (text_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_content_;
    text_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TStringAndTextFormat::set_allocated_text_content(::std::string* text_content) {
  if (text_content_ != &::google::protobuf::internal::kEmptyString) {
    delete text_content_;
  }
  if (text_content) {
    set_has_text_content();
    text_content_ = text_content;
  } else {
    clear_has_text_content();
    text_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool auto_wrap = 8;
inline bool TStringAndTextFormat::has_auto_wrap() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TStringAndTextFormat::set_has_auto_wrap() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TStringAndTextFormat::clear_has_auto_wrap() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TStringAndTextFormat::clear_auto_wrap() {
  auto_wrap_ = false;
  clear_has_auto_wrap();
}
inline bool TStringAndTextFormat::auto_wrap() const {
  return auto_wrap_;
}
inline void TStringAndTextFormat::set_auto_wrap(bool value) {
  set_has_auto_wrap();
  auto_wrap_ = value;
}

// -------------------------------------------------------------------

// TMTAutoSleep

// optional bool bEnable = 1;
inline bool TMTAutoSleep::has_benable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTAutoSleep::set_has_benable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTAutoSleep::clear_has_benable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTAutoSleep::clear_benable() {
  benable_ = false;
  clear_has_benable();
}
inline bool TMTAutoSleep::benable() const {
  return benable_;
}
inline void TMTAutoSleep::set_benable(bool value) {
  set_has_benable();
  benable_ = value;
}

// optional uint32 TimeOut = 2;
inline bool TMTAutoSleep::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTAutoSleep::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTAutoSleep::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTAutoSleep::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TMTAutoSleep::timeout() const {
  return timeout_;
}
inline void TMTAutoSleep::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional bool bAllowCall = 3;
inline bool TMTAutoSleep::has_ballowcall() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTAutoSleep::set_has_ballowcall() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTAutoSleep::clear_has_ballowcall() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTAutoSleep::clear_ballowcall() {
  ballowcall_ = false;
  clear_has_ballowcall();
}
inline bool TMTAutoSleep::ballowcall() const {
  return ballowcall_;
}
inline void TMTAutoSleep::set_ballowcall(bool value) {
  set_has_ballowcall();
  ballowcall_ = value;
}

// -------------------------------------------------------------------

// TMTCfgSystemTime

// optional bool bSyncServer = 1;
inline bool TMTCfgSystemTime::has_bsyncserver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCfgSystemTime::set_has_bsyncserver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCfgSystemTime::clear_has_bsyncserver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCfgSystemTime::clear_bsyncserver() {
  bsyncserver_ = false;
  clear_has_bsyncserver();
}
inline bool TMTCfgSystemTime::bsyncserver() const {
  return bsyncserver_;
}
inline void TMTCfgSystemTime::set_bsyncserver(bool value) {
  set_has_bsyncserver();
  bsyncserver_ = value;
}

// optional .mt.EmTimeZone emTimeZone = 2;
inline bool TMTCfgSystemTime::has_emtimezone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCfgSystemTime::set_has_emtimezone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCfgSystemTime::clear_has_emtimezone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCfgSystemTime::clear_emtimezone() {
  emtimezone_ = 0;
  clear_has_emtimezone();
}
inline ::mt::EmTimeZone TMTCfgSystemTime::emtimezone() const {
  return static_cast< ::mt::EmTimeZone >(emtimezone_);
}
inline void TMTCfgSystemTime::set_emtimezone(::mt::EmTimeZone value) {
  assert(::mt::EmTimeZone_IsValid(value));
  set_has_emtimezone();
  emtimezone_ = value;
}

// -------------------------------------------------------------------

// TMTVideoShowMode

// optional .mt.EmDualVideoShowMode emShowMode = 1;
inline bool TMTVideoShowMode::has_emshowmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVideoShowMode::set_has_emshowmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVideoShowMode::clear_has_emshowmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVideoShowMode::clear_emshowmode() {
  emshowmode_ = 1;
  clear_has_emshowmode();
}
inline ::mt::EmDualVideoShowMode TMTVideoShowMode::emshowmode() const {
  return static_cast< ::mt::EmDualVideoShowMode >(emshowmode_);
}
inline void TMTVideoShowMode::set_emshowmode(::mt::EmDualVideoShowMode value) {
  assert(::mt::EmDualVideoShowMode_IsValid(value));
  set_has_emshowmode();
  emshowmode_ = value;
}

// -------------------------------------------------------------------

// TMTHDAudInPort

// repeated .mt.EmHDAudPortIn emAudInPortList = 1;
inline int TMTHDAudInPort::emaudinportlist_size() const {
  return emaudinportlist_.size();
}
inline void TMTHDAudInPort::clear_emaudinportlist() {
  emaudinportlist_.Clear();
}
inline ::mt::EmHDAudPortIn TMTHDAudInPort::emaudinportlist(int index) const {
  return static_cast< ::mt::EmHDAudPortIn >(emaudinportlist_.Get(index));
}
inline void TMTHDAudInPort::set_emaudinportlist(int index, ::mt::EmHDAudPortIn value) {
  assert(::mt::EmHDAudPortIn_IsValid(value));
  emaudinportlist_.Set(index, value);
}
inline void TMTHDAudInPort::add_emaudinportlist(::mt::EmHDAudPortIn value) {
  assert(::mt::EmHDAudPortIn_IsValid(value));
  emaudinportlist_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TMTHDAudInPort::emaudinportlist() const {
  return emaudinportlist_;
}
inline ::google::protobuf::RepeatedField<int>*
TMTHDAudInPort::mutable_emaudinportlist() {
  return &emaudinportlist_;
}

// -------------------------------------------------------------------

// TMTHDAudInPortList

// optional .mt.TMTHDAudInPort emMainMicPortList = 1;
inline bool TMTHDAudInPortList::has_emmainmicportlist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTHDAudInPortList::set_has_emmainmicportlist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTHDAudInPortList::clear_has_emmainmicportlist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTHDAudInPortList::clear_emmainmicportlist() {
  if (emmainmicportlist_ != NULL) emmainmicportlist_->::mt::TMTHDAudInPort::Clear();
  clear_has_emmainmicportlist();
}
inline const ::mt::TMTHDAudInPort& TMTHDAudInPortList::emmainmicportlist() const {
  return emmainmicportlist_ != NULL ? *emmainmicportlist_ : *default_instance_->emmainmicportlist_;
}
inline ::mt::TMTHDAudInPort* TMTHDAudInPortList::mutable_emmainmicportlist() {
  set_has_emmainmicportlist();
  if (emmainmicportlist_ == NULL) emmainmicportlist_ = new ::mt::TMTHDAudInPort;
  return emmainmicportlist_;
}
inline ::mt::TMTHDAudInPort* TMTHDAudInPortList::release_emmainmicportlist() {
  clear_has_emmainmicportlist();
  ::mt::TMTHDAudInPort* temp = emmainmicportlist_;
  emmainmicportlist_ = NULL;
  return temp;
}
inline void TMTHDAudInPortList::set_allocated_emmainmicportlist(::mt::TMTHDAudInPort* emmainmicportlist) {
  delete emmainmicportlist_;
  emmainmicportlist_ = emmainmicportlist;
  if (emmainmicportlist) {
    set_has_emmainmicportlist();
  } else {
    clear_has_emmainmicportlist();
  }
}

// optional .mt.TMTHDAudInPort emLineInPortList = 2;
inline bool TMTHDAudInPortList::has_emlineinportlist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTHDAudInPortList::set_has_emlineinportlist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTHDAudInPortList::clear_has_emlineinportlist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTHDAudInPortList::clear_emlineinportlist() {
  if (emlineinportlist_ != NULL) emlineinportlist_->::mt::TMTHDAudInPort::Clear();
  clear_has_emlineinportlist();
}
inline const ::mt::TMTHDAudInPort& TMTHDAudInPortList::emlineinportlist() const {
  return emlineinportlist_ != NULL ? *emlineinportlist_ : *default_instance_->emlineinportlist_;
}
inline ::mt::TMTHDAudInPort* TMTHDAudInPortList::mutable_emlineinportlist() {
  set_has_emlineinportlist();
  if (emlineinportlist_ == NULL) emlineinportlist_ = new ::mt::TMTHDAudInPort;
  return emlineinportlist_;
}
inline ::mt::TMTHDAudInPort* TMTHDAudInPortList::release_emlineinportlist() {
  clear_has_emlineinportlist();
  ::mt::TMTHDAudInPort* temp = emlineinportlist_;
  emlineinportlist_ = NULL;
  return temp;
}
inline void TMTHDAudInPortList::set_allocated_emlineinportlist(::mt::TMTHDAudInPort* emlineinportlist) {
  delete emlineinportlist_;
  emlineinportlist_ = emlineinportlist;
  if (emlineinportlist) {
    set_has_emlineinportlist();
  } else {
    clear_has_emlineinportlist();
  }
}

// optional bool aux_is_mic = 3;
inline bool TMTHDAudInPortList::has_aux_is_mic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTHDAudInPortList::set_has_aux_is_mic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTHDAudInPortList::clear_has_aux_is_mic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTHDAudInPortList::clear_aux_is_mic() {
  aux_is_mic_ = false;
  clear_has_aux_is_mic();
}
inline bool TMTHDAudInPortList::aux_is_mic() const {
  return aux_is_mic_;
}
inline void TMTHDAudInPortList::set_aux_is_mic(bool value) {
  set_has_aux_is_mic();
  aux_is_mic_ = value;
}

// optional bool line_is_mic = 4;
inline bool TMTHDAudInPortList::has_line_is_mic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTHDAudInPortList::set_has_line_is_mic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTHDAudInPortList::clear_has_line_is_mic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTHDAudInPortList::clear_line_is_mic() {
  line_is_mic_ = false;
  clear_has_line_is_mic();
}
inline bool TMTHDAudInPortList::line_is_mic() const {
  return line_is_mic_;
}
inline void TMTHDAudInPortList::set_line_is_mic(bool value) {
  set_has_line_is_mic();
  line_is_mic_ = value;
}

// -------------------------------------------------------------------

// TMTHDAudOutPortList

// repeated .mt.EmHDAudPortOut emAudOutPortList = 1;
inline int TMTHDAudOutPortList::emaudoutportlist_size() const {
  return emaudoutportlist_.size();
}
inline void TMTHDAudOutPortList::clear_emaudoutportlist() {
  emaudoutportlist_.Clear();
}
inline ::mt::EmHDAudPortOut TMTHDAudOutPortList::emaudoutportlist(int index) const {
  return static_cast< ::mt::EmHDAudPortOut >(emaudoutportlist_.Get(index));
}
inline void TMTHDAudOutPortList::set_emaudoutportlist(int index, ::mt::EmHDAudPortOut value) {
  assert(::mt::EmHDAudPortOut_IsValid(value));
  emaudoutportlist_.Set(index, value);
}
inline void TMTHDAudOutPortList::add_emaudoutportlist(::mt::EmHDAudPortOut value) {
  assert(::mt::EmHDAudPortOut_IsValid(value));
  emaudoutportlist_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TMTHDAudOutPortList::emaudoutportlist() const {
  return emaudoutportlist_;
}
inline ::google::protobuf::RepeatedField<int>*
TMTHDAudOutPortList::mutable_emaudoutportlist() {
  return &emaudoutportlist_;
}

// -------------------------------------------------------------------

// TMTHDVidInPort

// optional .mt.EmVideoType emVideoType = 1;
inline bool TMTHDVidInPort::has_emvideotype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTHDVidInPort::set_has_emvideotype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTHDVidInPort::clear_has_emvideotype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTHDVidInPort::clear_emvideotype() {
  emvideotype_ = 0;
  clear_has_emvideotype();
}
inline ::mt::EmVideoType TMTHDVidInPort::emvideotype() const {
  return static_cast< ::mt::EmVideoType >(emvideotype_);
}
inline void TMTHDVidInPort::set_emvideotype(::mt::EmVideoType value) {
  assert(::mt::EmVideoType_IsValid(value));
  set_has_emvideotype();
  emvideotype_ = value;
}

// optional .mt.EmMtVideoPort emVideoInPort = 2;
inline bool TMTHDVidInPort::has_emvideoinport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTHDVidInPort::set_has_emvideoinport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTHDVidInPort::clear_has_emvideoinport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTHDVidInPort::clear_emvideoinport() {
  emvideoinport_ = 0;
  clear_has_emvideoinport();
}
inline ::mt::EmMtVideoPort TMTHDVidInPort::emvideoinport() const {
  return static_cast< ::mt::EmMtVideoPort >(emvideoinport_);
}
inline void TMTHDVidInPort::set_emvideoinport(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  set_has_emvideoinport();
  emvideoinport_ = value;
}

// -------------------------------------------------------------------

// TMTHDVidInPortCap

// optional .mt.EmVideoType video_type = 1;
inline bool TMTHDVidInPortCap::has_video_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTHDVidInPortCap::set_has_video_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTHDVidInPortCap::clear_has_video_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTHDVidInPortCap::clear_video_type() {
  video_type_ = 0;
  clear_has_video_type();
}
inline ::mt::EmVideoType TMTHDVidInPortCap::video_type() const {
  return static_cast< ::mt::EmVideoType >(video_type_);
}
inline void TMTHDVidInPortCap::set_video_type(::mt::EmVideoType value) {
  assert(::mt::EmVideoType_IsValid(value));
  set_has_video_type();
  video_type_ = value;
}

// repeated .mt.EmMtVideoPort video_port = 2;
inline int TMTHDVidInPortCap::video_port_size() const {
  return video_port_.size();
}
inline void TMTHDVidInPortCap::clear_video_port() {
  video_port_.Clear();
}
inline ::mt::EmMtVideoPort TMTHDVidInPortCap::video_port(int index) const {
  return static_cast< ::mt::EmMtVideoPort >(video_port_.Get(index));
}
inline void TMTHDVidInPortCap::set_video_port(int index, ::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  video_port_.Set(index, value);
}
inline void TMTHDVidInPortCap::add_video_port(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  video_port_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TMTHDVidInPortCap::video_port() const {
  return video_port_;
}
inline ::google::protobuf::RepeatedField<int>*
TMTHDVidInPortCap::mutable_video_port() {
  return &video_port_;
}

// -------------------------------------------------------------------

// TMTHDVidInPortCapList

// repeated .mt.TMTHDVidInPortCap video_cap_list = 1;
inline int TMTHDVidInPortCapList::video_cap_list_size() const {
  return video_cap_list_.size();
}
inline void TMTHDVidInPortCapList::clear_video_cap_list() {
  video_cap_list_.Clear();
}
inline const ::mt::TMTHDVidInPortCap& TMTHDVidInPortCapList::video_cap_list(int index) const {
  return video_cap_list_.Get(index);
}
inline ::mt::TMTHDVidInPortCap* TMTHDVidInPortCapList::mutable_video_cap_list(int index) {
  return video_cap_list_.Mutable(index);
}
inline ::mt::TMTHDVidInPortCap* TMTHDVidInPortCapList::add_video_cap_list() {
  return video_cap_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTHDVidInPortCap >&
TMTHDVidInPortCapList::video_cap_list() const {
  return video_cap_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTHDVidInPortCap >*
TMTHDVidInPortCapList::mutable_video_cap_list() {
  return &video_cap_list_;
}

// -------------------------------------------------------------------

// TMTHDMultiVideo

// optional .mt.EmHDMultiVideoSwitch emMVType = 1;
inline bool TMTHDMultiVideo::has_emmvtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTHDMultiVideo::set_has_emmvtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTHDMultiVideo::clear_has_emmvtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTHDMultiVideo::clear_emmvtype() {
  emmvtype_ = 0;
  clear_has_emmvtype();
}
inline ::mt::EmHDMultiVideoSwitch TMTHDMultiVideo::emmvtype() const {
  return static_cast< ::mt::EmHDMultiVideoSwitch >(emmvtype_);
}
inline void TMTHDMultiVideo::set_emmvtype(::mt::EmHDMultiVideoSwitch value) {
  assert(::mt::EmHDMultiVideoSwitch_IsValid(value));
  set_has_emmvtype();
  emmvtype_ = value;
}

// optional .mt.EmHDMultiViewMP emVMPType = 2;
inline bool TMTHDMultiVideo::has_emvmptype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTHDMultiVideo::set_has_emvmptype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTHDMultiVideo::clear_has_emvmptype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTHDMultiVideo::clear_emvmptype() {
  emvmptype_ = 0;
  clear_has_emvmptype();
}
inline ::mt::EmHDMultiViewMP TMTHDMultiVideo::emvmptype() const {
  return static_cast< ::mt::EmHDMultiViewMP >(emvmptype_);
}
inline void TMTHDMultiVideo::set_emvmptype(::mt::EmHDMultiViewMP value) {
  assert(::mt::EmHDMultiViewMP_IsValid(value));
  set_has_emvmptype();
  emvmptype_ = value;
}

// repeated .mt.EmMtVideoPort emVideoInPortList = 3;
inline int TMTHDMultiVideo::emvideoinportlist_size() const {
  return emvideoinportlist_.size();
}
inline void TMTHDMultiVideo::clear_emvideoinportlist() {
  emvideoinportlist_.Clear();
}
inline ::mt::EmMtVideoPort TMTHDMultiVideo::emvideoinportlist(int index) const {
  return static_cast< ::mt::EmMtVideoPort >(emvideoinportlist_.Get(index));
}
inline void TMTHDMultiVideo::set_emvideoinportlist(int index, ::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  emvideoinportlist_.Set(index, value);
}
inline void TMTHDMultiVideo::add_emvideoinportlist(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  emvideoinportlist_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TMTHDMultiVideo::emvideoinportlist() const {
  return emvideoinportlist_;
}
inline ::google::protobuf::RepeatedField<int>*
TMTHDMultiVideo::mutable_emvideoinportlist() {
  return &emvideoinportlist_;
}

// -------------------------------------------------------------------

// TMTDisplayRatio

// optional .mt.EmVideoType emVideoType = 1;
inline bool TMTDisplayRatio::has_emvideotype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTDisplayRatio::set_has_emvideotype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTDisplayRatio::clear_has_emvideotype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTDisplayRatio::clear_emvideotype() {
  emvideotype_ = 0;
  clear_has_emvideotype();
}
inline ::mt::EmVideoType TMTDisplayRatio::emvideotype() const {
  return static_cast< ::mt::EmVideoType >(emvideotype_);
}
inline void TMTDisplayRatio::set_emvideotype(::mt::EmVideoType value) {
  assert(::mt::EmVideoType_IsValid(value));
  set_has_emvideotype();
  emvideotype_ = value;
}

// optional .mt.EmDisplayRatio emRatio = 2;
inline bool TMTDisplayRatio::has_emratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTDisplayRatio::set_has_emratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTDisplayRatio::clear_has_emratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTDisplayRatio::clear_emratio() {
  emratio_ = 0;
  clear_has_emratio();
}
inline ::mt::EmDisplayRatio TMTDisplayRatio::emratio() const {
  return static_cast< ::mt::EmDisplayRatio >(emratio_);
}
inline void TMTDisplayRatio::set_emratio(::mt::EmDisplayRatio value) {
  assert(::mt::EmDisplayRatio_IsValid(value));
  set_has_emratio();
  emratio_ = value;
}

// -------------------------------------------------------------------

// TMTVidInPortMode

// optional .mt.EmMtVideoPort emVideoInPort = 1;
inline bool TMTVidInPortMode::has_emvideoinport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVidInPortMode::set_has_emvideoinport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVidInPortMode::clear_has_emvideoinport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVidInPortMode::clear_emvideoinport() {
  emvideoinport_ = 0;
  clear_has_emvideoinport();
}
inline ::mt::EmMtVideoPort TMTVidInPortMode::emvideoinport() const {
  return static_cast< ::mt::EmMtVideoPort >(emvideoinport_);
}
inline void TMTVidInPortMode::set_emvideoinport(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  set_has_emvideoinport();
  emvideoinport_ = value;
}

// optional .mt.EmHDVideoPortMode emInPortMode = 2;
inline bool TMTVidInPortMode::has_eminportmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVidInPortMode::set_has_eminportmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVidInPortMode::clear_has_eminportmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVidInPortMode::clear_eminportmode() {
  eminportmode_ = 0;
  clear_has_eminportmode();
}
inline ::mt::EmHDVideoPortMode TMTVidInPortMode::eminportmode() const {
  return static_cast< ::mt::EmHDVideoPortMode >(eminportmode_);
}
inline void TMTVidInPortMode::set_eminportmode(::mt::EmHDVideoPortMode value) {
  assert(::mt::EmHDVideoPortMode_IsValid(value));
  set_has_eminportmode();
  eminportmode_ = value;
}

// -------------------------------------------------------------------

// TMTVidOutPortMode

// optional .mt.EmHDVideoOutPortType emVideoOutPort = 1;
inline bool TMTVidOutPortMode::has_emvideooutport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVidOutPortMode::set_has_emvideooutport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVidOutPortMode::clear_has_emvideooutport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVidOutPortMode::clear_emvideooutport() {
  emvideooutport_ = 0;
  clear_has_emvideooutport();
}
inline ::mt::EmHDVideoOutPortType TMTVidOutPortMode::emvideooutport() const {
  return static_cast< ::mt::EmHDVideoOutPortType >(emvideooutport_);
}
inline void TMTVidOutPortMode::set_emvideooutport(::mt::EmHDVideoOutPortType value) {
  assert(::mt::EmHDVideoOutPortType_IsValid(value));
  set_has_emvideooutport();
  emvideooutport_ = value;
}

// optional .mt.EmHDVideoPortMode emOutPortMode = 2;
inline bool TMTVidOutPortMode::has_emoutportmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVidOutPortMode::set_has_emoutportmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVidOutPortMode::clear_has_emoutportmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVidOutPortMode::clear_emoutportmode() {
  emoutportmode_ = 0;
  clear_has_emoutportmode();
}
inline ::mt::EmHDVideoPortMode TMTVidOutPortMode::emoutportmode() const {
  return static_cast< ::mt::EmHDVideoPortMode >(emoutportmode_);
}
inline void TMTVidOutPortMode::set_emoutportmode(::mt::EmHDVideoPortMode value) {
  assert(::mt::EmHDVideoPortMode_IsValid(value));
  set_has_emoutportmode();
  emoutportmode_ = value;
}

// -------------------------------------------------------------------

// TMTVideoOutPort2InPort

// optional .mt.EmHDVideoOutPortType emVideoOutPort = 1;
inline bool TMTVideoOutPort2InPort::has_emvideooutport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVideoOutPort2InPort::set_has_emvideooutport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVideoOutPort2InPort::clear_has_emvideooutport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVideoOutPort2InPort::clear_emvideooutport() {
  emvideooutport_ = 0;
  clear_has_emvideooutport();
}
inline ::mt::EmHDVideoOutPortType TMTVideoOutPort2InPort::emvideooutport() const {
  return static_cast< ::mt::EmHDVideoOutPortType >(emvideooutport_);
}
inline void TMTVideoOutPort2InPort::set_emvideooutport(::mt::EmHDVideoOutPortType value) {
  assert(::mt::EmHDVideoOutPortType_IsValid(value));
  set_has_emvideooutport();
  emvideooutport_ = value;
}

// optional .mt.EmHDVideoSourceType emVideoOutType = 2;
inline bool TMTVideoOutPort2InPort::has_emvideoouttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVideoOutPort2InPort::set_has_emvideoouttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVideoOutPort2InPort::clear_has_emvideoouttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVideoOutPort2InPort::clear_emvideoouttype() {
  emvideoouttype_ = 0;
  clear_has_emvideoouttype();
}
inline ::mt::EmHDVideoSourceType TMTVideoOutPort2InPort::emvideoouttype() const {
  return static_cast< ::mt::EmHDVideoSourceType >(emvideoouttype_);
}
inline void TMTVideoOutPort2InPort::set_emvideoouttype(::mt::EmHDVideoSourceType value) {
  assert(::mt::EmHDVideoSourceType_IsValid(value));
  set_has_emvideoouttype();
  emvideoouttype_ = value;
}

// -------------------------------------------------------------------

// TMTVideoMatrixScheme

// optional uint32 SchemeID = 1;
inline bool TMTVideoMatrixScheme::has_schemeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVideoMatrixScheme::set_has_schemeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVideoMatrixScheme::clear_has_schemeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVideoMatrixScheme::clear_schemeid() {
  schemeid_ = 0u;
  clear_has_schemeid();
}
inline ::google::protobuf::uint32 TMTVideoMatrixScheme::schemeid() const {
  return schemeid_;
}
inline void TMTVideoMatrixScheme::set_schemeid(::google::protobuf::uint32 value) {
  set_has_schemeid();
  schemeid_ = value;
}

// optional string SchemeName = 2;
inline bool TMTVideoMatrixScheme::has_schemename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVideoMatrixScheme::set_has_schemename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVideoMatrixScheme::clear_has_schemename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVideoMatrixScheme::clear_schemename() {
  if (schemename_ != &::google::protobuf::internal::kEmptyString) {
    schemename_->clear();
  }
  clear_has_schemename();
}
inline const ::std::string& TMTVideoMatrixScheme::schemename() const {
  return *schemename_;
}
inline void TMTVideoMatrixScheme::set_schemename(const ::std::string& value) {
  set_has_schemename();
  if (schemename_ == &::google::protobuf::internal::kEmptyString) {
    schemename_ = new ::std::string;
  }
  schemename_->assign(value);
}
inline void TMTVideoMatrixScheme::set_schemename(const char* value) {
  set_has_schemename();
  if (schemename_ == &::google::protobuf::internal::kEmptyString) {
    schemename_ = new ::std::string;
  }
  schemename_->assign(value);
}
inline void TMTVideoMatrixScheme::set_schemename(const char* value, size_t size) {
  set_has_schemename();
  if (schemename_ == &::google::protobuf::internal::kEmptyString) {
    schemename_ = new ::std::string;
  }
  schemename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTVideoMatrixScheme::mutable_schemename() {
  set_has_schemename();
  if (schemename_ == &::google::protobuf::internal::kEmptyString) {
    schemename_ = new ::std::string;
  }
  return schemename_;
}
inline ::std::string* TMTVideoMatrixScheme::release_schemename() {
  clear_has_schemename();
  if (schemename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schemename_;
    schemename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTVideoMatrixScheme::set_allocated_schemename(::std::string* schemename) {
  if (schemename_ != &::google::protobuf::internal::kEmptyString) {
    delete schemename_;
  }
  if (schemename) {
    set_has_schemename();
    schemename_ = schemename;
  } else {
    clear_has_schemename();
    schemename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mt.TMTVidInPortMode tInPortMode = 3;
inline int TMTVideoMatrixScheme::tinportmode_size() const {
  return tinportmode_.size();
}
inline void TMTVideoMatrixScheme::clear_tinportmode() {
  tinportmode_.Clear();
}
inline const ::mt::TMTVidInPortMode& TMTVideoMatrixScheme::tinportmode(int index) const {
  return tinportmode_.Get(index);
}
inline ::mt::TMTVidInPortMode* TMTVideoMatrixScheme::mutable_tinportmode(int index) {
  return tinportmode_.Mutable(index);
}
inline ::mt::TMTVidInPortMode* TMTVideoMatrixScheme::add_tinportmode() {
  return tinportmode_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidInPortMode >&
TMTVideoMatrixScheme::tinportmode() const {
  return tinportmode_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidInPortMode >*
TMTVideoMatrixScheme::mutable_tinportmode() {
  return &tinportmode_;
}

// repeated .mt.TMTVidOutPortMode tOutPortMode = 4;
inline int TMTVideoMatrixScheme::toutportmode_size() const {
  return toutportmode_.size();
}
inline void TMTVideoMatrixScheme::clear_toutportmode() {
  toutportmode_.Clear();
}
inline const ::mt::TMTVidOutPortMode& TMTVideoMatrixScheme::toutportmode(int index) const {
  return toutportmode_.Get(index);
}
inline ::mt::TMTVidOutPortMode* TMTVideoMatrixScheme::mutable_toutportmode(int index) {
  return toutportmode_.Mutable(index);
}
inline ::mt::TMTVidOutPortMode* TMTVideoMatrixScheme::add_toutportmode() {
  return toutportmode_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVidOutPortMode >&
TMTVideoMatrixScheme::toutportmode() const {
  return toutportmode_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVidOutPortMode >*
TMTVideoMatrixScheme::mutable_toutportmode() {
  return &toutportmode_;
}

// repeated .mt.TMTVideoOutPort2InPort tOutPort2InPort = 5;
inline int TMTVideoMatrixScheme::toutport2inport_size() const {
  return toutport2inport_.size();
}
inline void TMTVideoMatrixScheme::clear_toutport2inport() {
  toutport2inport_.Clear();
}
inline const ::mt::TMTVideoOutPort2InPort& TMTVideoMatrixScheme::toutport2inport(int index) const {
  return toutport2inport_.Get(index);
}
inline ::mt::TMTVideoOutPort2InPort* TMTVideoMatrixScheme::mutable_toutport2inport(int index) {
  return toutport2inport_.Mutable(index);
}
inline ::mt::TMTVideoOutPort2InPort* TMTVideoMatrixScheme::add_toutport2inport() {
  return toutport2inport_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoOutPort2InPort >&
TMTVideoMatrixScheme::toutport2inport() const {
  return toutport2inport_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoOutPort2InPort >*
TMTVideoMatrixScheme::mutable_toutport2inport() {
  return &toutport2inport_;
}

// -------------------------------------------------------------------

// TMTAllVideoMatrixScheme

// optional uint32 SchemeID = 1;
inline bool TMTAllVideoMatrixScheme::has_schemeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTAllVideoMatrixScheme::set_has_schemeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTAllVideoMatrixScheme::clear_has_schemeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTAllVideoMatrixScheme::clear_schemeid() {
  schemeid_ = 0u;
  clear_has_schemeid();
}
inline ::google::protobuf::uint32 TMTAllVideoMatrixScheme::schemeid() const {
  return schemeid_;
}
inline void TMTAllVideoMatrixScheme::set_schemeid(::google::protobuf::uint32 value) {
  set_has_schemeid();
  schemeid_ = value;
}

// repeated .mt.TMTVideoMatrixScheme tMatrixScheme = 2;
inline int TMTAllVideoMatrixScheme::tmatrixscheme_size() const {
  return tmatrixscheme_.size();
}
inline void TMTAllVideoMatrixScheme::clear_tmatrixscheme() {
  tmatrixscheme_.Clear();
}
inline const ::mt::TMTVideoMatrixScheme& TMTAllVideoMatrixScheme::tmatrixscheme(int index) const {
  return tmatrixscheme_.Get(index);
}
inline ::mt::TMTVideoMatrixScheme* TMTAllVideoMatrixScheme::mutable_tmatrixscheme(int index) {
  return tmatrixscheme_.Mutable(index);
}
inline ::mt::TMTVideoMatrixScheme* TMTAllVideoMatrixScheme::add_tmatrixscheme() {
  return tmatrixscheme_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoMatrixScheme >&
TMTAllVideoMatrixScheme::tmatrixscheme() const {
  return tmatrixscheme_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTVideoMatrixScheme >*
TMTAllVideoMatrixScheme::mutable_tmatrixscheme() {
  return &tmatrixscheme_;
}

// -------------------------------------------------------------------

// TMTLastDisplay

// optional .mt.EmHDLastDisplay emLastDisplayType = 1;
inline bool TMTLastDisplay::has_emlastdisplaytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTLastDisplay::set_has_emlastdisplaytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTLastDisplay::clear_has_emlastdisplaytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTLastDisplay::clear_emlastdisplaytype() {
  emlastdisplaytype_ = 0;
  clear_has_emlastdisplaytype();
}
inline ::mt::EmHDLastDisplay TMTLastDisplay::emlastdisplaytype() const {
  return static_cast< ::mt::EmHDLastDisplay >(emlastdisplaytype_);
}
inline void TMTLastDisplay::set_emlastdisplaytype(::mt::EmHDLastDisplay value) {
  assert(::mt::EmHDLastDisplay_IsValid(value));
  set_has_emlastdisplaytype();
  emlastdisplaytype_ = value;
}

// optional uint32 wait_timer = 2;
inline bool TMTLastDisplay::has_wait_timer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTLastDisplay::set_has_wait_timer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTLastDisplay::clear_has_wait_timer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTLastDisplay::clear_wait_timer() {
  wait_timer_ = 0u;
  clear_has_wait_timer();
}
inline ::google::protobuf::uint32 TMTLastDisplay::wait_timer() const {
  return wait_timer_;
}
inline void TMTLastDisplay::set_wait_timer(::google::protobuf::uint32 value) {
  set_has_wait_timer();
  wait_timer_ = value;
}

// -------------------------------------------------------------------

// TMTHDImageNoise

// optional .mt.EmHDImageNoise emNoiseLevel = 1;
inline bool TMTHDImageNoise::has_emnoiselevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTHDImageNoise::set_has_emnoiselevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTHDImageNoise::clear_has_emnoiselevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTHDImageNoise::clear_emnoiselevel() {
  emnoiselevel_ = 0;
  clear_has_emnoiselevel();
}
inline ::mt::EmHDImageNoise TMTHDImageNoise::emnoiselevel() const {
  return static_cast< ::mt::EmHDImageNoise >(emnoiselevel_);
}
inline void TMTHDImageNoise::set_emnoiselevel(::mt::EmHDImageNoise value) {
  assert(::mt::EmHDImageNoise_IsValid(value));
  set_has_emnoiselevel();
  emnoiselevel_ = value;
}

// -------------------------------------------------------------------

// TMTHDImageDeformationTensile

// optional .mt.EmCodecComponent CodecType = 1;
inline bool TMTHDImageDeformationTensile::has_codectype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTHDImageDeformationTensile::set_has_codectype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTHDImageDeformationTensile::clear_has_codectype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTHDImageDeformationTensile::clear_codectype() {
  codectype_ = 0;
  clear_has_codectype();
}
inline ::mt::EmCodecComponent TMTHDImageDeformationTensile::codectype() const {
  return static_cast< ::mt::EmCodecComponent >(codectype_);
}
inline void TMTHDImageDeformationTensile::set_codectype(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_codectype();
  codectype_ = value;
}

// optional .mt.EmCodecComponentIndex CodecIndex = 2;
inline bool TMTHDImageDeformationTensile::has_codecindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTHDImageDeformationTensile::set_has_codecindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTHDImageDeformationTensile::clear_has_codecindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTHDImageDeformationTensile::clear_codecindex() {
  codecindex_ = 0;
  clear_has_codecindex();
}
inline ::mt::EmCodecComponentIndex TMTHDImageDeformationTensile::codecindex() const {
  return static_cast< ::mt::EmCodecComponentIndex >(codecindex_);
}
inline void TMTHDImageDeformationTensile::set_codecindex(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_codecindex();
  codecindex_ = value;
}

// optional uint32 left_right_number = 3;
inline bool TMTHDImageDeformationTensile::has_left_right_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTHDImageDeformationTensile::set_has_left_right_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTHDImageDeformationTensile::clear_has_left_right_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTHDImageDeformationTensile::clear_left_right_number() {
  left_right_number_ = 0u;
  clear_has_left_right_number();
}
inline ::google::protobuf::uint32 TMTHDImageDeformationTensile::left_right_number() const {
  return left_right_number_;
}
inline void TMTHDImageDeformationTensile::set_left_right_number(::google::protobuf::uint32 value) {
  set_has_left_right_number();
  left_right_number_ = value;
}

// optional uint32 up_down_number = 4;
inline bool TMTHDImageDeformationTensile::has_up_down_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTHDImageDeformationTensile::set_has_up_down_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTHDImageDeformationTensile::clear_has_up_down_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTHDImageDeformationTensile::clear_up_down_number() {
  up_down_number_ = 0u;
  clear_has_up_down_number();
}
inline ::google::protobuf::uint32 TMTHDImageDeformationTensile::up_down_number() const {
  return up_down_number_;
}
inline void TMTHDImageDeformationTensile::set_up_down_number(::google::protobuf::uint32 value) {
  set_has_up_down_number();
  up_down_number_ = value;
}

// -------------------------------------------------------------------

// TMTHDImageGeometricScaling

// optional .mt.EmCodecComponent CodecType = 1;
inline bool TMTHDImageGeometricScaling::has_codectype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTHDImageGeometricScaling::set_has_codectype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTHDImageGeometricScaling::clear_has_codectype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTHDImageGeometricScaling::clear_codectype() {
  codectype_ = 0;
  clear_has_codectype();
}
inline ::mt::EmCodecComponent TMTHDImageGeometricScaling::codectype() const {
  return static_cast< ::mt::EmCodecComponent >(codectype_);
}
inline void TMTHDImageGeometricScaling::set_codectype(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_codectype();
  codectype_ = value;
}

// optional .mt.EmCodecComponentIndex CodecIndex = 2;
inline bool TMTHDImageGeometricScaling::has_codecindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTHDImageGeometricScaling::set_has_codecindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTHDImageGeometricScaling::clear_has_codecindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTHDImageGeometricScaling::clear_codecindex() {
  codecindex_ = 0;
  clear_has_codecindex();
}
inline ::mt::EmCodecComponentIndex TMTHDImageGeometricScaling::codecindex() const {
  return static_cast< ::mt::EmCodecComponentIndex >(codecindex_);
}
inline void TMTHDImageGeometricScaling::set_codecindex(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_codecindex();
  codecindex_ = value;
}

// optional uint32 number = 3;
inline bool TMTHDImageGeometricScaling::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTHDImageGeometricScaling::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTHDImageGeometricScaling::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTHDImageGeometricScaling::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 TMTHDImageGeometricScaling::number() const {
  return number_;
}
inline void TMTHDImageGeometricScaling::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// TMTHDCameraCfg

// optional .mt.EmMtVideoPort video_index = 1;
inline bool TMTHDCameraCfg::has_video_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTHDCameraCfg::set_has_video_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTHDCameraCfg::clear_has_video_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTHDCameraCfg::clear_video_index() {
  video_index_ = 0;
  clear_has_video_index();
}
inline ::mt::EmMtVideoPort TMTHDCameraCfg::video_index() const {
  return static_cast< ::mt::EmMtVideoPort >(video_index_);
}
inline void TMTHDCameraCfg::set_video_index(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  set_has_video_index();
  video_index_ = value;
}

// optional string camera_type_name = 2;
inline bool TMTHDCameraCfg::has_camera_type_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTHDCameraCfg::set_has_camera_type_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTHDCameraCfg::clear_has_camera_type_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTHDCameraCfg::clear_camera_type_name() {
  if (camera_type_name_ != &::google::protobuf::internal::kEmptyString) {
    camera_type_name_->clear();
  }
  clear_has_camera_type_name();
}
inline const ::std::string& TMTHDCameraCfg::camera_type_name() const {
  return *camera_type_name_;
}
inline void TMTHDCameraCfg::set_camera_type_name(const ::std::string& value) {
  set_has_camera_type_name();
  if (camera_type_name_ == &::google::protobuf::internal::kEmptyString) {
    camera_type_name_ = new ::std::string;
  }
  camera_type_name_->assign(value);
}
inline void TMTHDCameraCfg::set_camera_type_name(const char* value) {
  set_has_camera_type_name();
  if (camera_type_name_ == &::google::protobuf::internal::kEmptyString) {
    camera_type_name_ = new ::std::string;
  }
  camera_type_name_->assign(value);
}
inline void TMTHDCameraCfg::set_camera_type_name(const char* value, size_t size) {
  set_has_camera_type_name();
  if (camera_type_name_ == &::google::protobuf::internal::kEmptyString) {
    camera_type_name_ = new ::std::string;
  }
  camera_type_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTHDCameraCfg::mutable_camera_type_name() {
  set_has_camera_type_name();
  if (camera_type_name_ == &::google::protobuf::internal::kEmptyString) {
    camera_type_name_ = new ::std::string;
  }
  return camera_type_name_;
}
inline ::std::string* TMTHDCameraCfg::release_camera_type_name() {
  clear_has_camera_type_name();
  if (camera_type_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = camera_type_name_;
    camera_type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTHDCameraCfg::set_allocated_camera_type_name(::std::string* camera_type_name) {
  if (camera_type_name_ != &::google::protobuf::internal::kEmptyString) {
    delete camera_type_name_;
  }
  if (camera_type_name) {
    set_has_camera_type_name();
    camera_type_name_ = camera_type_name;
  } else {
    clear_has_camera_type_name();
    camera_type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 address = 3;
inline bool TMTHDCameraCfg::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTHDCameraCfg::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTHDCameraCfg::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTHDCameraCfg::clear_address() {
  address_ = 0u;
  clear_has_address();
}
inline ::google::protobuf::uint32 TMTHDCameraCfg::address() const {
  return address_;
}
inline void TMTHDCameraCfg::set_address(::google::protobuf::uint32 value) {
  set_has_address();
  address_ = value;
}

// optional uint32 speed = 4;
inline bool TMTHDCameraCfg::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTHDCameraCfg::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTHDCameraCfg::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTHDCameraCfg::clear_speed() {
  speed_ = 0u;
  clear_has_speed();
}
inline ::google::protobuf::uint32 TMTHDCameraCfg::speed() const {
  return speed_;
}
inline void TMTHDCameraCfg::set_speed(::google::protobuf::uint32 value) {
  set_has_speed();
  speed_ = value;
}

// optional .mt.EmSerialType serial_type = 5;
inline bool TMTHDCameraCfg::has_serial_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTHDCameraCfg::set_has_serial_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTHDCameraCfg::clear_has_serial_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTHDCameraCfg::clear_serial_type() {
  serial_type_ = 0;
  clear_has_serial_type();
}
inline ::mt::EmSerialType TMTHDCameraCfg::serial_type() const {
  return static_cast< ::mt::EmSerialType >(serial_type_);
}
inline void TMTHDCameraCfg::set_serial_type(::mt::EmSerialType value) {
  assert(::mt::EmSerialType_IsValid(value));
  set_has_serial_type();
  serial_type_ = value;
}

// optional uint32 ip = 6;
inline bool TMTHDCameraCfg::has_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTHDCameraCfg::set_has_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTHDCameraCfg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTHDCameraCfg::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMTHDCameraCfg::ip() const {
  return ip_;
}
inline void TMTHDCameraCfg::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 7;
inline bool TMTHDCameraCfg::has_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTHDCameraCfg::set_has_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTHDCameraCfg::clear_has_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTHDCameraCfg::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMTHDCameraCfg::port() const {
  return port_;
}
inline void TMTHDCameraCfg::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TMTHDCameraList

// repeated .mt.TMTHDCameraCfg cameralist = 1;
inline int TMTHDCameraList::cameralist_size() const {
  return cameralist_.size();
}
inline void TMTHDCameraList::clear_cameralist() {
  cameralist_.Clear();
}
inline const ::mt::TMTHDCameraCfg& TMTHDCameraList::cameralist(int index) const {
  return cameralist_.Get(index);
}
inline ::mt::TMTHDCameraCfg* TMTHDCameraList::mutable_cameralist(int index) {
  return cameralist_.Mutable(index);
}
inline ::mt::TMTHDCameraCfg* TMTHDCameraList::add_cameralist() {
  return cameralist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTHDCameraCfg >&
TMTHDCameraList::cameralist() const {
  return cameralist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTHDCameraCfg >*
TMTHDCameraList::mutable_cameralist() {
  return &cameralist_;
}

// -------------------------------------------------------------------

// TMTHDCameraAiCfg

// optional .mt.EmMtVideoPort video_index = 1;
inline bool TMTHDCameraAiCfg::has_video_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTHDCameraAiCfg::set_has_video_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTHDCameraAiCfg::clear_has_video_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTHDCameraAiCfg::clear_video_index() {
  video_index_ = 0;
  clear_has_video_index();
}
inline ::mt::EmMtVideoPort TMTHDCameraAiCfg::video_index() const {
  return static_cast< ::mt::EmMtVideoPort >(video_index_);
}
inline void TMTHDCameraAiCfg::set_video_index(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  set_has_video_index();
  video_index_ = value;
}

// optional string camera_type_name = 2;
inline bool TMTHDCameraAiCfg::has_camera_type_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTHDCameraAiCfg::set_has_camera_type_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTHDCameraAiCfg::clear_has_camera_type_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTHDCameraAiCfg::clear_camera_type_name() {
  if (camera_type_name_ != &::google::protobuf::internal::kEmptyString) {
    camera_type_name_->clear();
  }
  clear_has_camera_type_name();
}
inline const ::std::string& TMTHDCameraAiCfg::camera_type_name() const {
  return *camera_type_name_;
}
inline void TMTHDCameraAiCfg::set_camera_type_name(const ::std::string& value) {
  set_has_camera_type_name();
  if (camera_type_name_ == &::google::protobuf::internal::kEmptyString) {
    camera_type_name_ = new ::std::string;
  }
  camera_type_name_->assign(value);
}
inline void TMTHDCameraAiCfg::set_camera_type_name(const char* value) {
  set_has_camera_type_name();
  if (camera_type_name_ == &::google::protobuf::internal::kEmptyString) {
    camera_type_name_ = new ::std::string;
  }
  camera_type_name_->assign(value);
}
inline void TMTHDCameraAiCfg::set_camera_type_name(const char* value, size_t size) {
  set_has_camera_type_name();
  if (camera_type_name_ == &::google::protobuf::internal::kEmptyString) {
    camera_type_name_ = new ::std::string;
  }
  camera_type_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTHDCameraAiCfg::mutable_camera_type_name() {
  set_has_camera_type_name();
  if (camera_type_name_ == &::google::protobuf::internal::kEmptyString) {
    camera_type_name_ = new ::std::string;
  }
  return camera_type_name_;
}
inline ::std::string* TMTHDCameraAiCfg::release_camera_type_name() {
  clear_has_camera_type_name();
  if (camera_type_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = camera_type_name_;
    camera_type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTHDCameraAiCfg::set_allocated_camera_type_name(::std::string* camera_type_name) {
  if (camera_type_name_ != &::google::protobuf::internal::kEmptyString) {
    delete camera_type_name_;
  }
  if (camera_type_name) {
    set_has_camera_type_name();
    camera_type_name_ = camera_type_name;
  } else {
    clear_has_camera_type_name();
    camera_type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 3;
inline bool TMTHDCameraAiCfg::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTHDCameraAiCfg::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTHDCameraAiCfg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTHDCameraAiCfg::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMTHDCameraAiCfg::ip() const {
  return ip_;
}
inline void TMTHDCameraAiCfg::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 4;
inline bool TMTHDCameraAiCfg::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTHDCameraAiCfg::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTHDCameraAiCfg::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTHDCameraAiCfg::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMTHDCameraAiCfg::port() const {
  return port_;
}
inline void TMTHDCameraAiCfg::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional bool en_people_cnt = 5;
inline bool TMTHDCameraAiCfg::has_en_people_cnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTHDCameraAiCfg::set_has_en_people_cnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTHDCameraAiCfg::clear_has_en_people_cnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTHDCameraAiCfg::clear_en_people_cnt() {
  en_people_cnt_ = false;
  clear_has_en_people_cnt();
}
inline bool TMTHDCameraAiCfg::en_people_cnt() const {
  return en_people_cnt_;
}
inline void TMTHDCameraAiCfg::set_en_people_cnt(bool value) {
  set_has_en_people_cnt();
  en_people_cnt_ = value;
}

// optional bool en_face_checkin = 6;
inline bool TMTHDCameraAiCfg::has_en_face_checkin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMTHDCameraAiCfg::set_has_en_face_checkin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMTHDCameraAiCfg::clear_has_en_face_checkin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMTHDCameraAiCfg::clear_en_face_checkin() {
  en_face_checkin_ = false;
  clear_has_en_face_checkin();
}
inline bool TMTHDCameraAiCfg::en_face_checkin() const {
  return en_face_checkin_;
}
inline void TMTHDCameraAiCfg::set_en_face_checkin(bool value) {
  set_has_en_face_checkin();
  en_face_checkin_ = value;
}

// optional bool en_dog_tag = 7;
inline bool TMTHDCameraAiCfg::has_en_dog_tag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMTHDCameraAiCfg::set_has_en_dog_tag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMTHDCameraAiCfg::clear_has_en_dog_tag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMTHDCameraAiCfg::clear_en_dog_tag() {
  en_dog_tag_ = false;
  clear_has_en_dog_tag();
}
inline bool TMTHDCameraAiCfg::en_dog_tag() const {
  return en_dog_tag_;
}
inline void TMTHDCameraAiCfg::set_en_dog_tag(bool value) {
  set_has_en_dog_tag();
  en_dog_tag_ = value;
}

// optional bool en_CameraAi = 8;
inline bool TMTHDCameraAiCfg::has_en_cameraai() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMTHDCameraAiCfg::set_has_en_cameraai() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMTHDCameraAiCfg::clear_has_en_cameraai() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMTHDCameraAiCfg::clear_en_cameraai() {
  en_cameraai_ = false;
  clear_has_en_cameraai();
}
inline bool TMTHDCameraAiCfg::en_cameraai() const {
  return en_cameraai_;
}
inline void TMTHDCameraAiCfg::set_en_cameraai(bool value) {
  set_has_en_cameraai();
  en_cameraai_ = value;
}

// -------------------------------------------------------------------

// TMTHDCameraAiList

// repeated .mt.TMTHDCameraAiCfg camera_ai_list = 1;
inline int TMTHDCameraAiList::camera_ai_list_size() const {
  return camera_ai_list_.size();
}
inline void TMTHDCameraAiList::clear_camera_ai_list() {
  camera_ai_list_.Clear();
}
inline const ::mt::TMTHDCameraAiCfg& TMTHDCameraAiList::camera_ai_list(int index) const {
  return camera_ai_list_.Get(index);
}
inline ::mt::TMTHDCameraAiCfg* TMTHDCameraAiList::mutable_camera_ai_list(int index) {
  return camera_ai_list_.Mutable(index);
}
inline ::mt::TMTHDCameraAiCfg* TMTHDCameraAiList::add_camera_ai_list() {
  return camera_ai_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTHDCameraAiCfg >&
TMTHDCameraAiList::camera_ai_list() const {
  return camera_ai_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTHDCameraAiCfg >*
TMTHDCameraAiList::mutable_camera_ai_list() {
  return &camera_ai_list_;
}

// -------------------------------------------------------------------

// TMTFaceCheckInInfo

// optional string name = 1;
inline bool TMTFaceCheckInInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTFaceCheckInInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTFaceCheckInInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTFaceCheckInInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMTFaceCheckInInfo::name() const {
  return *name_;
}
inline void TMTFaceCheckInInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTFaceCheckInInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMTFaceCheckInInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTFaceCheckInInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMTFaceCheckInInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTFaceCheckInInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 2;
inline bool TMTFaceCheckInInfo::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTFaceCheckInInfo::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTFaceCheckInInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTFaceCheckInInfo::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& TMTFaceCheckInInfo::time() const {
  return *time_;
}
inline void TMTFaceCheckInInfo::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void TMTFaceCheckInInfo::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void TMTFaceCheckInInfo::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTFaceCheckInInfo::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* TMTFaceCheckInInfo::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTFaceCheckInInfo::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string position = 3;
inline bool TMTFaceCheckInInfo::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTFaceCheckInInfo::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTFaceCheckInInfo::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTFaceCheckInInfo::clear_position() {
  if (position_ != &::google::protobuf::internal::kEmptyString) {
    position_->clear();
  }
  clear_has_position();
}
inline const ::std::string& TMTFaceCheckInInfo::position() const {
  return *position_;
}
inline void TMTFaceCheckInInfo::set_position(const ::std::string& value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(value);
}
inline void TMTFaceCheckInInfo::set_position(const char* value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(value);
}
inline void TMTFaceCheckInInfo::set_position(const char* value, size_t size) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTFaceCheckInInfo::mutable_position() {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  return position_;
}
inline ::std::string* TMTFaceCheckInInfo::release_position() {
  clear_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = position_;
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTFaceCheckInInfo::set_allocated_position(::std::string* position) {
  if (position_ != &::google::protobuf::internal::kEmptyString) {
    delete position_;
  }
  if (position) {
    set_has_position();
    position_ = position;
  } else {
    clear_has_position();
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTFaceCheckInList

// repeated .mt.TMTFaceCheckInInfo face_checkin = 1;
inline int TMTFaceCheckInList::face_checkin_size() const {
  return face_checkin_.size();
}
inline void TMTFaceCheckInList::clear_face_checkin() {
  face_checkin_.Clear();
}
inline const ::mt::TMTFaceCheckInInfo& TMTFaceCheckInList::face_checkin(int index) const {
  return face_checkin_.Get(index);
}
inline ::mt::TMTFaceCheckInInfo* TMTFaceCheckInList::mutable_face_checkin(int index) {
  return face_checkin_.Mutable(index);
}
inline ::mt::TMTFaceCheckInInfo* TMTFaceCheckInList::add_face_checkin() {
  return face_checkin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTFaceCheckInInfo >&
TMTFaceCheckInList::face_checkin() const {
  return face_checkin_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTFaceCheckInInfo >*
TMTFaceCheckInList::mutable_face_checkin() {
  return &face_checkin_;
}

// -------------------------------------------------------------------

// TMTHDSerialCtrl

// optional .mt.EmSerialType serial_type = 1;
inline bool TMTHDSerialCtrl::has_serial_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTHDSerialCtrl::set_has_serial_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTHDSerialCtrl::clear_has_serial_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTHDSerialCtrl::clear_serial_type() {
  serial_type_ = 0;
  clear_has_serial_type();
}
inline ::mt::EmSerialType TMTHDSerialCtrl::serial_type() const {
  return static_cast< ::mt::EmSerialType >(serial_type_);
}
inline void TMTHDSerialCtrl::set_serial_type(::mt::EmSerialType value) {
  assert(::mt::EmSerialType_IsValid(value));
  set_has_serial_type();
  serial_type_ = value;
}

// optional uint32 band_rate = 2;
inline bool TMTHDSerialCtrl::has_band_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTHDSerialCtrl::set_has_band_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTHDSerialCtrl::clear_has_band_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTHDSerialCtrl::clear_band_rate() {
  band_rate_ = 0u;
  clear_has_band_rate();
}
inline ::google::protobuf::uint32 TMTHDSerialCtrl::band_rate() const {
  return band_rate_;
}
inline void TMTHDSerialCtrl::set_band_rate(::google::protobuf::uint32 value) {
  set_has_band_rate();
  band_rate_ = value;
}

// optional uint32 byte_size = 3;
inline bool TMTHDSerialCtrl::has_byte_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTHDSerialCtrl::set_has_byte_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTHDSerialCtrl::clear_has_byte_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTHDSerialCtrl::clear_byte_size() {
  byte_size_ = 0u;
  clear_has_byte_size();
}
inline ::google::protobuf::uint32 TMTHDSerialCtrl::byte_size() const {
  return byte_size_;
}
inline void TMTHDSerialCtrl::set_byte_size(::google::protobuf::uint32 value) {
  set_has_byte_size();
  byte_size_ = value;
}

// optional .mt.EmStopBits stop_bits = 4;
inline bool TMTHDSerialCtrl::has_stop_bits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTHDSerialCtrl::set_has_stop_bits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTHDSerialCtrl::clear_has_stop_bits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTHDSerialCtrl::clear_stop_bits() {
  stop_bits_ = 0;
  clear_has_stop_bits();
}
inline ::mt::EmStopBits TMTHDSerialCtrl::stop_bits() const {
  return static_cast< ::mt::EmStopBits >(stop_bits_);
}
inline void TMTHDSerialCtrl::set_stop_bits(::mt::EmStopBits value) {
  assert(::mt::EmStopBits_IsValid(value));
  set_has_stop_bits();
  stop_bits_ = value;
}

// optional .mt.EmParityCheck parity_check = 5;
inline bool TMTHDSerialCtrl::has_parity_check() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMTHDSerialCtrl::set_has_parity_check() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMTHDSerialCtrl::clear_has_parity_check() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMTHDSerialCtrl::clear_parity_check() {
  parity_check_ = 0;
  clear_has_parity_check();
}
inline ::mt::EmParityCheck TMTHDSerialCtrl::parity_check() const {
  return static_cast< ::mt::EmParityCheck >(parity_check_);
}
inline void TMTHDSerialCtrl::set_parity_check(::mt::EmParityCheck value) {
  assert(::mt::EmParityCheck_IsValid(value));
  set_has_parity_check();
  parity_check_ = value;
}

// -------------------------------------------------------------------

// TMTHDSerialList

// repeated .mt.TMTHDSerialCtrl seriallist = 1;
inline int TMTHDSerialList::seriallist_size() const {
  return seriallist_.size();
}
inline void TMTHDSerialList::clear_seriallist() {
  seriallist_.Clear();
}
inline const ::mt::TMTHDSerialCtrl& TMTHDSerialList::seriallist(int index) const {
  return seriallist_.Get(index);
}
inline ::mt::TMTHDSerialCtrl* TMTHDSerialList::mutable_seriallist(int index) {
  return seriallist_.Mutable(index);
}
inline ::mt::TMTHDSerialCtrl* TMTHDSerialList::add_seriallist() {
  return seriallist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTHDSerialCtrl >&
TMTHDSerialList::seriallist() const {
  return seriallist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTHDSerialCtrl >*
TMTHDSerialList::mutable_seriallist() {
  return &seriallist_;
}

// -------------------------------------------------------------------

// TMTHDSerialMonitor

// optional .mt.EmSerialType serial_type = 1;
inline bool TMTHDSerialMonitor::has_serial_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTHDSerialMonitor::set_has_serial_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTHDSerialMonitor::clear_has_serial_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTHDSerialMonitor::clear_serial_type() {
  serial_type_ = 0;
  clear_has_serial_type();
}
inline ::mt::EmSerialType TMTHDSerialMonitor::serial_type() const {
  return static_cast< ::mt::EmSerialType >(serial_type_);
}
inline void TMTHDSerialMonitor::set_serial_type(::mt::EmSerialType value) {
  assert(::mt::EmSerialType_IsValid(value));
  set_has_serial_type();
  serial_type_ = value;
}

// optional bool enable_monitor = 2;
inline bool TMTHDSerialMonitor::has_enable_monitor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTHDSerialMonitor::set_has_enable_monitor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTHDSerialMonitor::clear_has_enable_monitor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTHDSerialMonitor::clear_enable_monitor() {
  enable_monitor_ = false;
  clear_has_enable_monitor();
}
inline bool TMTHDSerialMonitor::enable_monitor() const {
  return enable_monitor_;
}
inline void TMTHDSerialMonitor::set_enable_monitor(bool value) {
  set_has_enable_monitor();
  enable_monitor_ = value;
}

// -------------------------------------------------------------------

// TMTHDSerialMonitorList

// repeated .mt.TMTHDSerialMonitor monitorlist = 1;
inline int TMTHDSerialMonitorList::monitorlist_size() const {
  return monitorlist_.size();
}
inline void TMTHDSerialMonitorList::clear_monitorlist() {
  monitorlist_.Clear();
}
inline const ::mt::TMTHDSerialMonitor& TMTHDSerialMonitorList::monitorlist(int index) const {
  return monitorlist_.Get(index);
}
inline ::mt::TMTHDSerialMonitor* TMTHDSerialMonitorList::mutable_monitorlist(int index) {
  return monitorlist_.Mutable(index);
}
inline ::mt::TMTHDSerialMonitor* TMTHDSerialMonitorList::add_monitorlist() {
  return monitorlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTHDSerialMonitor >&
TMTHDSerialMonitorList::monitorlist() const {
  return monitorlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTHDSerialMonitor >*
TMTHDSerialMonitorList::mutable_monitorlist() {
  return &monitorlist_;
}

// -------------------------------------------------------------------

// TMTAllPreSetNameInfoCfg

// repeated .mt.TMTPreSetNameInfo pri1st_preset_name_info = 1;
inline int TMTAllPreSetNameInfoCfg::pri1st_preset_name_info_size() const {
  return pri1st_preset_name_info_.size();
}
inline void TMTAllPreSetNameInfoCfg::clear_pri1st_preset_name_info() {
  pri1st_preset_name_info_.Clear();
}
inline const ::mt::TMTPreSetNameInfo& TMTAllPreSetNameInfoCfg::pri1st_preset_name_info(int index) const {
  return pri1st_preset_name_info_.Get(index);
}
inline ::mt::TMTPreSetNameInfo* TMTAllPreSetNameInfoCfg::mutable_pri1st_preset_name_info(int index) {
  return pri1st_preset_name_info_.Mutable(index);
}
inline ::mt::TMTPreSetNameInfo* TMTAllPreSetNameInfoCfg::add_pri1st_preset_name_info() {
  return pri1st_preset_name_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >&
TMTAllPreSetNameInfoCfg::pri1st_preset_name_info() const {
  return pri1st_preset_name_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >*
TMTAllPreSetNameInfoCfg::mutable_pri1st_preset_name_info() {
  return &pri1st_preset_name_info_;
}

// repeated .mt.TMTPreSetNameInfo pri2nd_preset_name_info = 2;
inline int TMTAllPreSetNameInfoCfg::pri2nd_preset_name_info_size() const {
  return pri2nd_preset_name_info_.size();
}
inline void TMTAllPreSetNameInfoCfg::clear_pri2nd_preset_name_info() {
  pri2nd_preset_name_info_.Clear();
}
inline const ::mt::TMTPreSetNameInfo& TMTAllPreSetNameInfoCfg::pri2nd_preset_name_info(int index) const {
  return pri2nd_preset_name_info_.Get(index);
}
inline ::mt::TMTPreSetNameInfo* TMTAllPreSetNameInfoCfg::mutable_pri2nd_preset_name_info(int index) {
  return pri2nd_preset_name_info_.Mutable(index);
}
inline ::mt::TMTPreSetNameInfo* TMTAllPreSetNameInfoCfg::add_pri2nd_preset_name_info() {
  return pri2nd_preset_name_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >&
TMTAllPreSetNameInfoCfg::pri2nd_preset_name_info() const {
  return pri2nd_preset_name_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >*
TMTAllPreSetNameInfoCfg::mutable_pri2nd_preset_name_info() {
  return &pri2nd_preset_name_info_;
}

// repeated .mt.TMTPreSetNameInfo pri3rd_preset_name_info = 3;
inline int TMTAllPreSetNameInfoCfg::pri3rd_preset_name_info_size() const {
  return pri3rd_preset_name_info_.size();
}
inline void TMTAllPreSetNameInfoCfg::clear_pri3rd_preset_name_info() {
  pri3rd_preset_name_info_.Clear();
}
inline const ::mt::TMTPreSetNameInfo& TMTAllPreSetNameInfoCfg::pri3rd_preset_name_info(int index) const {
  return pri3rd_preset_name_info_.Get(index);
}
inline ::mt::TMTPreSetNameInfo* TMTAllPreSetNameInfoCfg::mutable_pri3rd_preset_name_info(int index) {
  return pri3rd_preset_name_info_.Mutable(index);
}
inline ::mt::TMTPreSetNameInfo* TMTAllPreSetNameInfoCfg::add_pri3rd_preset_name_info() {
  return pri3rd_preset_name_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >&
TMTAllPreSetNameInfoCfg::pri3rd_preset_name_info() const {
  return pri3rd_preset_name_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTPreSetNameInfo >*
TMTAllPreSetNameInfoCfg::mutable_pri3rd_preset_name_info() {
  return &pri3rd_preset_name_info_;
}

// -------------------------------------------------------------------

// TMTPreSetNameInfo

// optional uint32 pre_set_index = 1;
inline bool TMTPreSetNameInfo::has_pre_set_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTPreSetNameInfo::set_has_pre_set_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTPreSetNameInfo::clear_has_pre_set_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTPreSetNameInfo::clear_pre_set_index() {
  pre_set_index_ = 0u;
  clear_has_pre_set_index();
}
inline ::google::protobuf::uint32 TMTPreSetNameInfo::pre_set_index() const {
  return pre_set_index_;
}
inline void TMTPreSetNameInfo::set_pre_set_index(::google::protobuf::uint32 value) {
  set_has_pre_set_index();
  pre_set_index_ = value;
}

// optional string pre_set_name = 2;
inline bool TMTPreSetNameInfo::has_pre_set_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTPreSetNameInfo::set_has_pre_set_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTPreSetNameInfo::clear_has_pre_set_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTPreSetNameInfo::clear_pre_set_name() {
  if (pre_set_name_ != &::google::protobuf::internal::kEmptyString) {
    pre_set_name_->clear();
  }
  clear_has_pre_set_name();
}
inline const ::std::string& TMTPreSetNameInfo::pre_set_name() const {
  return *pre_set_name_;
}
inline void TMTPreSetNameInfo::set_pre_set_name(const ::std::string& value) {
  set_has_pre_set_name();
  if (pre_set_name_ == &::google::protobuf::internal::kEmptyString) {
    pre_set_name_ = new ::std::string;
  }
  pre_set_name_->assign(value);
}
inline void TMTPreSetNameInfo::set_pre_set_name(const char* value) {
  set_has_pre_set_name();
  if (pre_set_name_ == &::google::protobuf::internal::kEmptyString) {
    pre_set_name_ = new ::std::string;
  }
  pre_set_name_->assign(value);
}
inline void TMTPreSetNameInfo::set_pre_set_name(const char* value, size_t size) {
  set_has_pre_set_name();
  if (pre_set_name_ == &::google::protobuf::internal::kEmptyString) {
    pre_set_name_ = new ::std::string;
  }
  pre_set_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTPreSetNameInfo::mutable_pre_set_name() {
  set_has_pre_set_name();
  if (pre_set_name_ == &::google::protobuf::internal::kEmptyString) {
    pre_set_name_ = new ::std::string;
  }
  return pre_set_name_;
}
inline ::std::string* TMTPreSetNameInfo::release_pre_set_name() {
  clear_has_pre_set_name();
  if (pre_set_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pre_set_name_;
    pre_set_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTPreSetNameInfo::set_allocated_pre_set_name(::std::string* pre_set_name) {
  if (pre_set_name_ != &::google::protobuf::internal::kEmptyString) {
    delete pre_set_name_;
  }
  if (pre_set_name) {
    set_has_pre_set_name();
    pre_set_name_ = pre_set_name;
  } else {
    clear_has_pre_set_name();
    pre_set_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMTCodecPreSetIndex

// optional .mt.EmCodecComponentIndex codec_index = 1;
inline bool TMTCodecPreSetIndex::has_codec_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTCodecPreSetIndex::set_has_codec_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTCodecPreSetIndex::clear_has_codec_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTCodecPreSetIndex::clear_codec_index() {
  codec_index_ = 0;
  clear_has_codec_index();
}
inline ::mt::EmCodecComponentIndex TMTCodecPreSetIndex::codec_index() const {
  return static_cast< ::mt::EmCodecComponentIndex >(codec_index_);
}
inline void TMTCodecPreSetIndex::set_codec_index(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_codec_index();
  codec_index_ = value;
}

// optional uint32 pre_set_index = 2;
inline bool TMTCodecPreSetIndex::has_pre_set_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTCodecPreSetIndex::set_has_pre_set_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTCodecPreSetIndex::clear_has_pre_set_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTCodecPreSetIndex::clear_pre_set_index() {
  pre_set_index_ = 0u;
  clear_has_pre_set_index();
}
inline ::google::protobuf::uint32 TMTCodecPreSetIndex::pre_set_index() const {
  return pre_set_index_;
}
inline void TMTCodecPreSetIndex::set_pre_set_index(::google::protobuf::uint32 value) {
  set_has_pre_set_index();
  pre_set_index_ = value;
}

// -------------------------------------------------------------------

// TMTAllCodecPreSetIndex

// repeated .mt.TMTCodecPreSetIndex codec_pre_set_index = 1;
inline int TMTAllCodecPreSetIndex::codec_pre_set_index_size() const {
  return codec_pre_set_index_.size();
}
inline void TMTAllCodecPreSetIndex::clear_codec_pre_set_index() {
  codec_pre_set_index_.Clear();
}
inline const ::mt::TMTCodecPreSetIndex& TMTAllCodecPreSetIndex::codec_pre_set_index(int index) const {
  return codec_pre_set_index_.Get(index);
}
inline ::mt::TMTCodecPreSetIndex* TMTAllCodecPreSetIndex::mutable_codec_pre_set_index(int index) {
  return codec_pre_set_index_.Mutable(index);
}
inline ::mt::TMTCodecPreSetIndex* TMTAllCodecPreSetIndex::add_codec_pre_set_index() {
  return codec_pre_set_index_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMTCodecPreSetIndex >&
TMTAllCodecPreSetIndex::codec_pre_set_index() const {
  return codec_pre_set_index_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMTCodecPreSetIndex >*
TMTAllCodecPreSetIndex::mutable_codec_pre_set_index() {
  return &codec_pre_set_index_;
}

// -------------------------------------------------------------------

// TStaticPicCfg

// optional bool enable_send = 1;
inline bool TStaticPicCfg::has_enable_send() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TStaticPicCfg::set_has_enable_send() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TStaticPicCfg::clear_has_enable_send() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TStaticPicCfg::clear_enable_send() {
  enable_send_ = false;
  clear_has_enable_send();
}
inline bool TStaticPicCfg::enable_send() const {
  return enable_send_;
}
inline void TStaticPicCfg::set_enable_send(bool value) {
  set_has_enable_send();
  enable_send_ = value;
}

// optional string pic_path = 2;
inline bool TStaticPicCfg::has_pic_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TStaticPicCfg::set_has_pic_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TStaticPicCfg::clear_has_pic_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TStaticPicCfg::clear_pic_path() {
  if (pic_path_ != &::google::protobuf::internal::kEmptyString) {
    pic_path_->clear();
  }
  clear_has_pic_path();
}
inline const ::std::string& TStaticPicCfg::pic_path() const {
  return *pic_path_;
}
inline void TStaticPicCfg::set_pic_path(const ::std::string& value) {
  set_has_pic_path();
  if (pic_path_ == &::google::protobuf::internal::kEmptyString) {
    pic_path_ = new ::std::string;
  }
  pic_path_->assign(value);
}
inline void TStaticPicCfg::set_pic_path(const char* value) {
  set_has_pic_path();
  if (pic_path_ == &::google::protobuf::internal::kEmptyString) {
    pic_path_ = new ::std::string;
  }
  pic_path_->assign(value);
}
inline void TStaticPicCfg::set_pic_path(const char* value, size_t size) {
  set_has_pic_path();
  if (pic_path_ == &::google::protobuf::internal::kEmptyString) {
    pic_path_ = new ::std::string;
  }
  pic_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TStaticPicCfg::mutable_pic_path() {
  set_has_pic_path();
  if (pic_path_ == &::google::protobuf::internal::kEmptyString) {
    pic_path_ = new ::std::string;
  }
  return pic_path_;
}
inline ::std::string* TStaticPicCfg::release_pic_path() {
  clear_has_pic_path();
  if (pic_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pic_path_;
    pic_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TStaticPicCfg::set_allocated_pic_path(::std::string* pic_path) {
  if (pic_path_ != &::google::protobuf::internal::kEmptyString) {
    delete pic_path_;
  }
  if (pic_path) {
    set_has_pic_path();
    pic_path_ = pic_path;
  } else {
    clear_has_pic_path();
    pic_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TEthnetCardInfo

// optional bool enable_ip_dhcp = 1;
inline bool TEthnetCardInfo::has_enable_ip_dhcp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TEthnetCardInfo::set_has_enable_ip_dhcp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TEthnetCardInfo::clear_has_enable_ip_dhcp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TEthnetCardInfo::clear_enable_ip_dhcp() {
  enable_ip_dhcp_ = false;
  clear_has_enable_ip_dhcp();
}
inline bool TEthnetCardInfo::enable_ip_dhcp() const {
  return enable_ip_dhcp_;
}
inline void TEthnetCardInfo::set_enable_ip_dhcp(bool value) {
  set_has_enable_ip_dhcp();
  enable_ip_dhcp_ = value;
}

// optional uint32 static_ip = 2;
inline bool TEthnetCardInfo::has_static_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TEthnetCardInfo::set_has_static_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TEthnetCardInfo::clear_has_static_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TEthnetCardInfo::clear_static_ip() {
  static_ip_ = 0u;
  clear_has_static_ip();
}
inline ::google::protobuf::uint32 TEthnetCardInfo::static_ip() const {
  return static_ip_;
}
inline void TEthnetCardInfo::set_static_ip(::google::protobuf::uint32 value) {
  set_has_static_ip();
  static_ip_ = value;
}

// optional uint32 static_mask = 3;
inline bool TEthnetCardInfo::has_static_mask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TEthnetCardInfo::set_has_static_mask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TEthnetCardInfo::clear_has_static_mask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TEthnetCardInfo::clear_static_mask() {
  static_mask_ = 0u;
  clear_has_static_mask();
}
inline ::google::protobuf::uint32 TEthnetCardInfo::static_mask() const {
  return static_mask_;
}
inline void TEthnetCardInfo::set_static_mask(::google::protobuf::uint32 value) {
  set_has_static_mask();
  static_mask_ = value;
}

// optional uint32 static_gateway_ip = 4;
inline bool TEthnetCardInfo::has_static_gateway_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TEthnetCardInfo::set_has_static_gateway_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TEthnetCardInfo::clear_has_static_gateway_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TEthnetCardInfo::clear_static_gateway_ip() {
  static_gateway_ip_ = 0u;
  clear_has_static_gateway_ip();
}
inline ::google::protobuf::uint32 TEthnetCardInfo::static_gateway_ip() const {
  return static_gateway_ip_;
}
inline void TEthnetCardInfo::set_static_gateway_ip(::google::protobuf::uint32 value) {
  set_has_static_gateway_ip();
  static_gateway_ip_ = value;
}

// optional uint32 dhcp_ip = 5;
inline bool TEthnetCardInfo::has_dhcp_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TEthnetCardInfo::set_has_dhcp_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TEthnetCardInfo::clear_has_dhcp_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TEthnetCardInfo::clear_dhcp_ip() {
  dhcp_ip_ = 0u;
  clear_has_dhcp_ip();
}
inline ::google::protobuf::uint32 TEthnetCardInfo::dhcp_ip() const {
  return dhcp_ip_;
}
inline void TEthnetCardInfo::set_dhcp_ip(::google::protobuf::uint32 value) {
  set_has_dhcp_ip();
  dhcp_ip_ = value;
}

// optional uint32 dhcp_mask = 6;
inline bool TEthnetCardInfo::has_dhcp_mask() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TEthnetCardInfo::set_has_dhcp_mask() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TEthnetCardInfo::clear_has_dhcp_mask() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TEthnetCardInfo::clear_dhcp_mask() {
  dhcp_mask_ = 0u;
  clear_has_dhcp_mask();
}
inline ::google::protobuf::uint32 TEthnetCardInfo::dhcp_mask() const {
  return dhcp_mask_;
}
inline void TEthnetCardInfo::set_dhcp_mask(::google::protobuf::uint32 value) {
  set_has_dhcp_mask();
  dhcp_mask_ = value;
}

// optional uint32 dhcp_gateway = 7;
inline bool TEthnetCardInfo::has_dhcp_gateway() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TEthnetCardInfo::set_has_dhcp_gateway() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TEthnetCardInfo::clear_has_dhcp_gateway() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TEthnetCardInfo::clear_dhcp_gateway() {
  dhcp_gateway_ = 0u;
  clear_has_dhcp_gateway();
}
inline ::google::protobuf::uint32 TEthnetCardInfo::dhcp_gateway() const {
  return dhcp_gateway_;
}
inline void TEthnetCardInfo::set_dhcp_gateway(::google::protobuf::uint32 value) {
  set_has_dhcp_gateway();
  dhcp_gateway_ = value;
}

// optional bool enable_dns_dhcp = 8;
inline bool TEthnetCardInfo::has_enable_dns_dhcp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TEthnetCardInfo::set_has_enable_dns_dhcp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TEthnetCardInfo::clear_has_enable_dns_dhcp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TEthnetCardInfo::clear_enable_dns_dhcp() {
  enable_dns_dhcp_ = false;
  clear_has_enable_dns_dhcp();
}
inline bool TEthnetCardInfo::enable_dns_dhcp() const {
  return enable_dns_dhcp_;
}
inline void TEthnetCardInfo::set_enable_dns_dhcp(bool value) {
  set_has_enable_dns_dhcp();
  enable_dns_dhcp_ = value;
}

// optional uint32 static_dns = 9;
inline bool TEthnetCardInfo::has_static_dns() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TEthnetCardInfo::set_has_static_dns() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TEthnetCardInfo::clear_has_static_dns() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TEthnetCardInfo::clear_static_dns() {
  static_dns_ = 0u;
  clear_has_static_dns();
}
inline ::google::protobuf::uint32 TEthnetCardInfo::static_dns() const {
  return static_dns_;
}
inline void TEthnetCardInfo::set_static_dns(::google::protobuf::uint32 value) {
  set_has_static_dns();
  static_dns_ = value;
}

// optional uint32 static_dns_backup = 10;
inline bool TEthnetCardInfo::has_static_dns_backup() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TEthnetCardInfo::set_has_static_dns_backup() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TEthnetCardInfo::clear_has_static_dns_backup() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TEthnetCardInfo::clear_static_dns_backup() {
  static_dns_backup_ = 0u;
  clear_has_static_dns_backup();
}
inline ::google::protobuf::uint32 TEthnetCardInfo::static_dns_backup() const {
  return static_dns_backup_;
}
inline void TEthnetCardInfo::set_static_dns_backup(::google::protobuf::uint32 value) {
  set_has_static_dns_backup();
  static_dns_backup_ = value;
}

// optional uint32 dhcp_dns = 11;
inline bool TEthnetCardInfo::has_dhcp_dns() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TEthnetCardInfo::set_has_dhcp_dns() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TEthnetCardInfo::clear_has_dhcp_dns() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TEthnetCardInfo::clear_dhcp_dns() {
  dhcp_dns_ = 0u;
  clear_has_dhcp_dns();
}
inline ::google::protobuf::uint32 TEthnetCardInfo::dhcp_dns() const {
  return dhcp_dns_;
}
inline void TEthnetCardInfo::set_dhcp_dns(::google::protobuf::uint32 value) {
  set_has_dhcp_dns();
  dhcp_dns_ = value;
}

// optional uint32 dhcp_dns_backup = 12;
inline bool TEthnetCardInfo::has_dhcp_dns_backup() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TEthnetCardInfo::set_has_dhcp_dns_backup() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TEthnetCardInfo::clear_has_dhcp_dns_backup() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TEthnetCardInfo::clear_dhcp_dns_backup() {
  dhcp_dns_backup_ = 0u;
  clear_has_dhcp_dns_backup();
}
inline ::google::protobuf::uint32 TEthnetCardInfo::dhcp_dns_backup() const {
  return dhcp_dns_backup_;
}
inline void TEthnetCardInfo::set_dhcp_dns_backup(::google::protobuf::uint32 value) {
  set_has_dhcp_dns_backup();
  dhcp_dns_backup_ = value;
}

// -------------------------------------------------------------------

// TEthnetCfg

// optional .mt.EmEthInterfaceMode ethnet_backupmode = 1;
inline bool TEthnetCfg::has_ethnet_backupmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TEthnetCfg::set_has_ethnet_backupmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TEthnetCfg::clear_has_ethnet_backupmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TEthnetCfg::clear_ethnet_backupmode() {
  ethnet_backupmode_ = 0;
  clear_has_ethnet_backupmode();
}
inline ::mt::EmEthInterfaceMode TEthnetCfg::ethnet_backupmode() const {
  return static_cast< ::mt::EmEthInterfaceMode >(ethnet_backupmode_);
}
inline void TEthnetCfg::set_ethnet_backupmode(::mt::EmEthInterfaceMode value) {
  assert(::mt::EmEthInterfaceMode_IsValid(value));
  set_has_ethnet_backupmode();
  ethnet_backupmode_ = value;
}

// optional uint32 cur_cardid = 2;
inline bool TEthnetCfg::has_cur_cardid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TEthnetCfg::set_has_cur_cardid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TEthnetCfg::clear_has_cur_cardid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TEthnetCfg::clear_cur_cardid() {
  cur_cardid_ = 0u;
  clear_has_cur_cardid();
}
inline ::google::protobuf::uint32 TEthnetCfg::cur_cardid() const {
  return cur_cardid_;
}
inline void TEthnetCfg::set_cur_cardid(::google::protobuf::uint32 value) {
  set_has_cur_cardid();
  cur_cardid_ = value;
}

// optional .mt.TEthnetCardInfo eth1 = 3;
inline bool TEthnetCfg::has_eth1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TEthnetCfg::set_has_eth1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TEthnetCfg::clear_has_eth1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TEthnetCfg::clear_eth1() {
  if (eth1_ != NULL) eth1_->::mt::TEthnetCardInfo::Clear();
  clear_has_eth1();
}
inline const ::mt::TEthnetCardInfo& TEthnetCfg::eth1() const {
  return eth1_ != NULL ? *eth1_ : *default_instance_->eth1_;
}
inline ::mt::TEthnetCardInfo* TEthnetCfg::mutable_eth1() {
  set_has_eth1();
  if (eth1_ == NULL) eth1_ = new ::mt::TEthnetCardInfo;
  return eth1_;
}
inline ::mt::TEthnetCardInfo* TEthnetCfg::release_eth1() {
  clear_has_eth1();
  ::mt::TEthnetCardInfo* temp = eth1_;
  eth1_ = NULL;
  return temp;
}
inline void TEthnetCfg::set_allocated_eth1(::mt::TEthnetCardInfo* eth1) {
  delete eth1_;
  eth1_ = eth1;
  if (eth1) {
    set_has_eth1();
  } else {
    clear_has_eth1();
  }
}

// optional .mt.TEthnetCardInfo eth2 = 4;
inline bool TEthnetCfg::has_eth2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TEthnetCfg::set_has_eth2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TEthnetCfg::clear_has_eth2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TEthnetCfg::clear_eth2() {
  if (eth2_ != NULL) eth2_->::mt::TEthnetCardInfo::Clear();
  clear_has_eth2();
}
inline const ::mt::TEthnetCardInfo& TEthnetCfg::eth2() const {
  return eth2_ != NULL ? *eth2_ : *default_instance_->eth2_;
}
inline ::mt::TEthnetCardInfo* TEthnetCfg::mutable_eth2() {
  set_has_eth2();
  if (eth2_ == NULL) eth2_ = new ::mt::TEthnetCardInfo;
  return eth2_;
}
inline ::mt::TEthnetCardInfo* TEthnetCfg::release_eth2() {
  clear_has_eth2();
  ::mt::TEthnetCardInfo* temp = eth2_;
  eth2_ = NULL;
  return temp;
}
inline void TEthnetCfg::set_allocated_eth2(::mt::TEthnetCardInfo* eth2) {
  delete eth2_;
  eth2_ = eth2;
  if (eth2) {
    set_has_eth2();
  } else {
    clear_has_eth2();
  }
}

// -------------------------------------------------------------------

// TEthnetPPPoECfg

// optional bool enable = 1;
inline bool TEthnetPPPoECfg::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TEthnetPPPoECfg::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TEthnetPPPoECfg::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TEthnetPPPoECfg::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TEthnetPPPoECfg::enable() const {
  return enable_;
}
inline void TEthnetPPPoECfg::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional string username = 2;
inline bool TEthnetPPPoECfg::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TEthnetPPPoECfg::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TEthnetPPPoECfg::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TEthnetPPPoECfg::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TEthnetPPPoECfg::username() const {
  return *username_;
}
inline void TEthnetPPPoECfg::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TEthnetPPPoECfg::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TEthnetPPPoECfg::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TEthnetPPPoECfg::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TEthnetPPPoECfg::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TEthnetPPPoECfg::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 3;
inline bool TEthnetPPPoECfg::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TEthnetPPPoECfg::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TEthnetPPPoECfg::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TEthnetPPPoECfg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TEthnetPPPoECfg::password() const {
  return *password_;
}
inline void TEthnetPPPoECfg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TEthnetPPPoECfg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TEthnetPPPoECfg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TEthnetPPPoECfg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TEthnetPPPoECfg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TEthnetPPPoECfg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool autodial = 4;
inline bool TEthnetPPPoECfg::has_autodial() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TEthnetPPPoECfg::set_has_autodial() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TEthnetPPPoECfg::clear_has_autodial() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TEthnetPPPoECfg::clear_autodial() {
  autodial_ = false;
  clear_has_autodial();
}
inline bool TEthnetPPPoECfg::autodial() const {
  return autodial_;
}
inline void TEthnetPPPoECfg::set_autodial(bool value) {
  set_has_autodial();
  autodial_ = value;
}

// -------------------------------------------------------------------

// TE1Unit

// optional uint32 e1_id = 1;
inline bool TE1Unit::has_e1_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TE1Unit::set_has_e1_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TE1Unit::clear_has_e1_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TE1Unit::clear_e1_id() {
  e1_id_ = 0u;
  clear_has_e1_id();
}
inline ::google::protobuf::uint32 TE1Unit::e1_id() const {
  return e1_id_;
}
inline void TE1Unit::set_e1_id(::google::protobuf::uint32 value) {
  set_has_e1_id();
  e1_id_ = value;
}

// optional uint32 used_flag = 2;
inline bool TE1Unit::has_used_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TE1Unit::set_has_used_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TE1Unit::clear_has_used_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TE1Unit::clear_used_flag() {
  used_flag_ = 0u;
  clear_has_used_flag();
}
inline ::google::protobuf::uint32 TE1Unit::used_flag() const {
  return used_flag_;
}
inline void TE1Unit::set_used_flag(::google::protobuf::uint32 value) {
  set_has_used_flag();
  used_flag_ = value;
}

// optional uint32 e1_ts_mask = 3;
inline bool TE1Unit::has_e1_ts_mask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TE1Unit::set_has_e1_ts_mask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TE1Unit::clear_has_e1_ts_mask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TE1Unit::clear_e1_ts_mask() {
  e1_ts_mask_ = 0u;
  clear_has_e1_ts_mask();
}
inline ::google::protobuf::uint32 TE1Unit::e1_ts_mask() const {
  return e1_ts_mask_;
}
inline void TE1Unit::set_e1_ts_mask(::google::protobuf::uint32 value) {
  set_has_e1_ts_mask();
  e1_ts_mask_ = value;
}

// optional uint32 protocol_type = 4;
inline bool TE1Unit::has_protocol_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TE1Unit::set_has_protocol_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TE1Unit::clear_has_protocol_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TE1Unit::clear_protocol_type() {
  protocol_type_ = 0u;
  clear_has_protocol_type();
}
inline ::google::protobuf::uint32 TE1Unit::protocol_type() const {
  return protocol_type_;
}
inline void TE1Unit::set_protocol_type(::google::protobuf::uint32 value) {
  set_has_protocol_type();
  protocol_type_ = value;
}

// optional uint32 echo_interval = 5;
inline bool TE1Unit::has_echo_interval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TE1Unit::set_has_echo_interval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TE1Unit::clear_has_echo_interval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TE1Unit::clear_echo_interval() {
  echo_interval_ = 0u;
  clear_has_echo_interval();
}
inline ::google::protobuf::uint32 TE1Unit::echo_interval() const {
  return echo_interval_;
}
inline void TE1Unit::set_echo_interval(::google::protobuf::uint32 value) {
  set_has_echo_interval();
  echo_interval_ = value;
}

// optional uint32 echo_maxretry = 6;
inline bool TE1Unit::has_echo_maxretry() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TE1Unit::set_has_echo_maxretry() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TE1Unit::clear_has_echo_maxretry() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TE1Unit::clear_echo_maxretry() {
  echo_maxretry_ = 0u;
  clear_has_echo_maxretry();
}
inline ::google::protobuf::uint32 TE1Unit::echo_maxretry() const {
  return echo_maxretry_;
}
inline void TE1Unit::set_echo_maxretry(::google::protobuf::uint32 value) {
  set_has_echo_maxretry();
  echo_maxretry_ = value;
}

// -------------------------------------------------------------------

// TE1Group

// optional bool enable = 1;
inline bool TE1Group::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TE1Group::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TE1Group::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TE1Group::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TE1Group::enable() const {
  return enable_;
}
inline void TE1Group::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional uint32 unit_num = 2;
inline bool TE1Group::has_unit_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TE1Group::set_has_unit_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TE1Group::clear_has_unit_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TE1Group::clear_unit_num() {
  unit_num_ = 0u;
  clear_has_unit_num();
}
inline ::google::protobuf::uint32 TE1Group::unit_num() const {
  return unit_num_;
}
inline void TE1Group::set_unit_num(::google::protobuf::uint32 value) {
  set_has_unit_num();
  unit_num_ = value;
}

// optional uint32 is_bind = 3;
inline bool TE1Group::has_is_bind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TE1Group::set_has_is_bind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TE1Group::clear_has_is_bind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TE1Group::clear_is_bind() {
  is_bind_ = 0u;
  clear_has_is_bind();
}
inline ::google::protobuf::uint32 TE1Group::is_bind() const {
  return is_bind_;
}
inline void TE1Group::set_is_bind(::google::protobuf::uint32 value) {
  set_has_is_bind();
  is_bind_ = value;
}

// optional uint32 group_id = 4;
inline bool TE1Group::has_group_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TE1Group::set_has_group_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TE1Group::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TE1Group::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 TE1Group::group_id() const {
  return group_id_;
}
inline void TE1Group::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional uint32 ip = 5;
inline bool TE1Group::has_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TE1Group::set_has_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TE1Group::clear_has_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TE1Group::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TE1Group::ip() const {
  return ip_;
}
inline void TE1Group::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 mask = 6;
inline bool TE1Group::has_mask() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TE1Group::set_has_mask() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TE1Group::clear_has_mask() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TE1Group::clear_mask() {
  mask_ = 0u;
  clear_has_mask();
}
inline ::google::protobuf::uint32 TE1Group::mask() const {
  return mask_;
}
inline void TE1Group::set_mask(::google::protobuf::uint32 value) {
  set_has_mask();
  mask_ = value;
}

// optional uint32 auth_type = 7;
inline bool TE1Group::has_auth_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TE1Group::set_has_auth_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TE1Group::clear_has_auth_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TE1Group::clear_auth_type() {
  auth_type_ = 0u;
  clear_has_auth_type();
}
inline ::google::protobuf::uint32 TE1Group::auth_type() const {
  return auth_type_;
}
inline void TE1Group::set_auth_type(::google::protobuf::uint32 value) {
  set_has_auth_type();
  auth_type_ = value;
}

// optional uint32 frag_minpackage_len = 8;
inline bool TE1Group::has_frag_minpackage_len() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TE1Group::set_has_frag_minpackage_len() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TE1Group::clear_has_frag_minpackage_len() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TE1Group::clear_frag_minpackage_len() {
  frag_minpackage_len_ = 0u;
  clear_has_frag_minpackage_len();
}
inline ::google::protobuf::uint32 TE1Group::frag_minpackage_len() const {
  return frag_minpackage_len_;
}
inline void TE1Group::set_frag_minpackage_len(::google::protobuf::uint32 value) {
  set_has_frag_minpackage_len();
  frag_minpackage_len_ = value;
}

// optional string svr_usrname = 9;
inline bool TE1Group::has_svr_usrname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TE1Group::set_has_svr_usrname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TE1Group::clear_has_svr_usrname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TE1Group::clear_svr_usrname() {
  if (svr_usrname_ != &::google::protobuf::internal::kEmptyString) {
    svr_usrname_->clear();
  }
  clear_has_svr_usrname();
}
inline const ::std::string& TE1Group::svr_usrname() const {
  return *svr_usrname_;
}
inline void TE1Group::set_svr_usrname(const ::std::string& value) {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  svr_usrname_->assign(value);
}
inline void TE1Group::set_svr_usrname(const char* value) {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  svr_usrname_->assign(value);
}
inline void TE1Group::set_svr_usrname(const char* value, size_t size) {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  svr_usrname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1Group::mutable_svr_usrname() {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  return svr_usrname_;
}
inline ::std::string* TE1Group::release_svr_usrname() {
  clear_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_usrname_;
    svr_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1Group::set_allocated_svr_usrname(::std::string* svr_usrname) {
  if (svr_usrname_ != &::google::protobuf::internal::kEmptyString) {
    delete svr_usrname_;
  }
  if (svr_usrname) {
    set_has_svr_usrname();
    svr_usrname_ = svr_usrname;
  } else {
    clear_has_svr_usrname();
    svr_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string svr_usrpwd = 10;
inline bool TE1Group::has_svr_usrpwd() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TE1Group::set_has_svr_usrpwd() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TE1Group::clear_has_svr_usrpwd() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TE1Group::clear_svr_usrpwd() {
  if (svr_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_->clear();
  }
  clear_has_svr_usrpwd();
}
inline const ::std::string& TE1Group::svr_usrpwd() const {
  return *svr_usrpwd_;
}
inline void TE1Group::set_svr_usrpwd(const ::std::string& value) {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  svr_usrpwd_->assign(value);
}
inline void TE1Group::set_svr_usrpwd(const char* value) {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  svr_usrpwd_->assign(value);
}
inline void TE1Group::set_svr_usrpwd(const char* value, size_t size) {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  svr_usrpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1Group::mutable_svr_usrpwd() {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  return svr_usrpwd_;
}
inline ::std::string* TE1Group::release_svr_usrpwd() {
  clear_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_usrpwd_;
    svr_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1Group::set_allocated_svr_usrpwd(::std::string* svr_usrpwd) {
  if (svr_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete svr_usrpwd_;
  }
  if (svr_usrpwd) {
    set_has_svr_usrpwd();
    svr_usrpwd_ = svr_usrpwd;
  } else {
    clear_has_svr_usrpwd();
    svr_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sent_usrname = 11;
inline bool TE1Group::has_sent_usrname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TE1Group::set_has_sent_usrname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TE1Group::clear_has_sent_usrname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TE1Group::clear_sent_usrname() {
  if (sent_usrname_ != &::google::protobuf::internal::kEmptyString) {
    sent_usrname_->clear();
  }
  clear_has_sent_usrname();
}
inline const ::std::string& TE1Group::sent_usrname() const {
  return *sent_usrname_;
}
inline void TE1Group::set_sent_usrname(const ::std::string& value) {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  sent_usrname_->assign(value);
}
inline void TE1Group::set_sent_usrname(const char* value) {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  sent_usrname_->assign(value);
}
inline void TE1Group::set_sent_usrname(const char* value, size_t size) {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  sent_usrname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1Group::mutable_sent_usrname() {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  return sent_usrname_;
}
inline ::std::string* TE1Group::release_sent_usrname() {
  clear_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sent_usrname_;
    sent_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1Group::set_allocated_sent_usrname(::std::string* sent_usrname) {
  if (sent_usrname_ != &::google::protobuf::internal::kEmptyString) {
    delete sent_usrname_;
  }
  if (sent_usrname) {
    set_has_sent_usrname();
    sent_usrname_ = sent_usrname;
  } else {
    clear_has_sent_usrname();
    sent_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sent_usrpwd = 12;
inline bool TE1Group::has_sent_usrpwd() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TE1Group::set_has_sent_usrpwd() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TE1Group::clear_has_sent_usrpwd() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TE1Group::clear_sent_usrpwd() {
  if (sent_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_->clear();
  }
  clear_has_sent_usrpwd();
}
inline const ::std::string& TE1Group::sent_usrpwd() const {
  return *sent_usrpwd_;
}
inline void TE1Group::set_sent_usrpwd(const ::std::string& value) {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  sent_usrpwd_->assign(value);
}
inline void TE1Group::set_sent_usrpwd(const char* value) {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  sent_usrpwd_->assign(value);
}
inline void TE1Group::set_sent_usrpwd(const char* value, size_t size) {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  sent_usrpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1Group::mutable_sent_usrpwd() {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  return sent_usrpwd_;
}
inline ::std::string* TE1Group::release_sent_usrpwd() {
  clear_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sent_usrpwd_;
    sent_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1Group::set_allocated_sent_usrpwd(::std::string* sent_usrpwd) {
  if (sent_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete sent_usrpwd_;
  }
  if (sent_usrpwd) {
    set_has_sent_usrpwd();
    sent_usrpwd_ = sent_usrpwd;
  } else {
    clear_has_sent_usrpwd();
    sent_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mt.TE1Unit unit_list = 13;
inline int TE1Group::unit_list_size() const {
  return unit_list_.size();
}
inline void TE1Group::clear_unit_list() {
  unit_list_.Clear();
}
inline const ::mt::TE1Unit& TE1Group::unit_list(int index) const {
  return unit_list_.Get(index);
}
inline ::mt::TE1Unit* TE1Group::mutable_unit_list(int index) {
  return unit_list_.Mutable(index);
}
inline ::mt::TE1Unit* TE1Group::add_unit_list() {
  return unit_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TE1Unit >&
TE1Group::unit_list() const {
  return unit_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TE1Unit >*
TE1Group::mutable_unit_list() {
  return &unit_list_;
}

// -------------------------------------------------------------------

// TE1Cfg

// optional bool encrypt = 1;
inline bool TE1Cfg::has_encrypt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TE1Cfg::set_has_encrypt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TE1Cfg::clear_has_encrypt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TE1Cfg::clear_encrypt() {
  encrypt_ = false;
  clear_has_encrypt();
}
inline bool TE1Cfg::encrypt() const {
  return encrypt_;
}
inline void TE1Cfg::set_encrypt(bool value) {
  set_has_encrypt();
  encrypt_ = value;
}

// optional uint32 clock_type = 2;
inline bool TE1Cfg::has_clock_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TE1Cfg::set_has_clock_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TE1Cfg::clear_has_clock_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TE1Cfg::clear_clock_type() {
  clock_type_ = 0u;
  clear_has_clock_type();
}
inline ::google::protobuf::uint32 TE1Cfg::clock_type() const {
  return clock_type_;
}
inline void TE1Cfg::set_clock_type(::google::protobuf::uint32 value) {
  set_has_clock_type();
  clock_type_ = value;
}

// repeated .mt.TE1Group group_detail = 3;
inline int TE1Cfg::group_detail_size() const {
  return group_detail_.size();
}
inline void TE1Cfg::clear_group_detail() {
  group_detail_.Clear();
}
inline const ::mt::TE1Group& TE1Cfg::group_detail(int index) const {
  return group_detail_.Get(index);
}
inline ::mt::TE1Group* TE1Cfg::mutable_group_detail(int index) {
  return group_detail_.Mutable(index);
}
inline ::mt::TE1Group* TE1Cfg::add_group_detail() {
  return group_detail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TE1Group >&
TE1Cfg::group_detail() const {
  return group_detail_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TE1Group >*
TE1Cfg::mutable_group_detail() {
  return &group_detail_;
}

// -------------------------------------------------------------------

// TVidBitRationCfg

// optional .mt.EmVidRationStrategy ration_strategy = 1;
inline bool TVidBitRationCfg::has_ration_strategy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVidBitRationCfg::set_has_ration_strategy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVidBitRationCfg::clear_has_ration_strategy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVidBitRationCfg::clear_ration_strategy() {
  ration_strategy_ = 0;
  clear_has_ration_strategy();
}
inline ::mt::EmVidRationStrategy TVidBitRationCfg::ration_strategy() const {
  return static_cast< ::mt::EmVidRationStrategy >(ration_strategy_);
}
inline void TVidBitRationCfg::set_ration_strategy(::mt::EmVidRationStrategy value) {
  assert(::mt::EmVidRationStrategy_IsValid(value));
  set_has_ration_strategy();
  ration_strategy_ = value;
}

// repeated uint32 main_ration = 2;
inline int TVidBitRationCfg::main_ration_size() const {
  return main_ration_.size();
}
inline void TVidBitRationCfg::clear_main_ration() {
  main_ration_.Clear();
}
inline ::google::protobuf::uint32 TVidBitRationCfg::main_ration(int index) const {
  return main_ration_.Get(index);
}
inline void TVidBitRationCfg::set_main_ration(int index, ::google::protobuf::uint32 value) {
  main_ration_.Set(index, value);
}
inline void TVidBitRationCfg::add_main_ration(::google::protobuf::uint32 value) {
  main_ration_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TVidBitRationCfg::main_ration() const {
  return main_ration_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TVidBitRationCfg::mutable_main_ration() {
  return &main_ration_;
}

// repeated uint32 ass_ration = 3;
inline int TVidBitRationCfg::ass_ration_size() const {
  return ass_ration_.size();
}
inline void TVidBitRationCfg::clear_ass_ration() {
  ass_ration_.Clear();
}
inline ::google::protobuf::uint32 TVidBitRationCfg::ass_ration(int index) const {
  return ass_ration_.Get(index);
}
inline void TVidBitRationCfg::set_ass_ration(int index, ::google::protobuf::uint32 value) {
  ass_ration_.Set(index, value);
}
inline void TVidBitRationCfg::add_ass_ration(::google::protobuf::uint32 value) {
  ass_ration_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TVidBitRationCfg::ass_ration() const {
  return ass_ration_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TVidBitRationCfg::mutable_ass_ration() {
  return &ass_ration_;
}

// -------------------------------------------------------------------

// TMtVideoPortParam

// optional .mt.EmMtVideoPort video_port = 1;
inline bool TMtVideoPortParam::has_video_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtVideoPortParam::set_has_video_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtVideoPortParam::clear_has_video_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtVideoPortParam::clear_video_port() {
  video_port_ = 0;
  clear_has_video_port();
}
inline ::mt::EmMtVideoPort TMtVideoPortParam::video_port() const {
  return static_cast< ::mt::EmMtVideoPort >(video_port_);
}
inline void TMtVideoPortParam::set_video_port(::mt::EmMtVideoPort value) {
  assert(::mt::EmMtVideoPort_IsValid(value));
  set_has_video_port();
  video_port_ = value;
}

// optional uint32 video_param = 2;
inline bool TMtVideoPortParam::has_video_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtVideoPortParam::set_has_video_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtVideoPortParam::clear_has_video_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtVideoPortParam::clear_video_param() {
  video_param_ = 0u;
  clear_has_video_param();
}
inline ::google::protobuf::uint32 TMtVideoPortParam::video_param() const {
  return video_param_;
}
inline void TMtVideoPortParam::set_video_param(::google::protobuf::uint32 value) {
  set_has_video_param();
  video_param_ = value;
}

// -------------------------------------------------------------------

// TMtVideoPortParamList

// repeated .mt.TMtVideoPortParam param_list = 1;
inline int TMtVideoPortParamList::param_list_size() const {
  return param_list_.size();
}
inline void TMtVideoPortParamList::clear_param_list() {
  param_list_.Clear();
}
inline const ::mt::TMtVideoPortParam& TMtVideoPortParamList::param_list(int index) const {
  return param_list_.Get(index);
}
inline ::mt::TMtVideoPortParam* TMtVideoPortParamList::mutable_param_list(int index) {
  return param_list_.Mutable(index);
}
inline ::mt::TMtVideoPortParam* TMtVideoPortParamList::add_param_list() {
  return param_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtVideoPortParam >&
TMtVideoPortParamList::param_list() const {
  return param_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtVideoPortParam >*
TMtVideoPortParamList::mutable_param_list() {
  return &param_list_;
}

// -------------------------------------------------------------------

// TMTResizeMode

// optional .mt.EmResizeMode emResizeMode = 1;
inline bool TMTResizeMode::has_emresizemode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTResizeMode::set_has_emresizemode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTResizeMode::clear_has_emresizemode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTResizeMode::clear_emresizemode() {
  emresizemode_ = 0;
  clear_has_emresizemode();
}
inline ::mt::EmResizeMode TMTResizeMode::emresizemode() const {
  return static_cast< ::mt::EmResizeMode >(emresizemode_);
}
inline void TMTResizeMode::set_emresizemode(::mt::EmResizeMode value) {
  assert(::mt::EmResizeMode_IsValid(value));
  set_has_emresizemode();
  emresizemode_ = value;
}

// -------------------------------------------------------------------

// TDynamicPayload

// optional uint32 mtKeyRmtActivePT = 1;
inline bool TDynamicPayload::has_mtkeyrmtactivept() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDynamicPayload::set_has_mtkeyrmtactivept() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDynamicPayload::clear_has_mtkeyrmtactivept() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDynamicPayload::clear_mtkeyrmtactivept() {
  mtkeyrmtactivept_ = 0u;
  clear_has_mtkeyrmtactivept();
}
inline ::google::protobuf::uint32 TDynamicPayload::mtkeyrmtactivept() const {
  return mtkeyrmtactivept_;
}
inline void TDynamicPayload::set_mtkeyrmtactivept(::google::protobuf::uint32 value) {
  set_has_mtkeyrmtactivept();
  mtkeyrmtactivept_ = value;
}

// optional uint32 mtKeyRealPT = 2;
inline bool TDynamicPayload::has_mtkeyrealpt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDynamicPayload::set_has_mtkeyrealpt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDynamicPayload::clear_has_mtkeyrealpt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDynamicPayload::clear_mtkeyrealpt() {
  mtkeyrealpt_ = 0u;
  clear_has_mtkeyrealpt();
}
inline ::google::protobuf::uint32 TDynamicPayload::mtkeyrealpt() const {
  return mtkeyrealpt_;
}
inline void TDynamicPayload::set_mtkeyrealpt(::google::protobuf::uint32 value) {
  set_has_mtkeyrealpt();
  mtkeyrealpt_ = value;
}

// -------------------------------------------------------------------

// TRpDynamicPayload

// repeated .mt.TDynamicPayload payload_list = 1;
inline int TRpDynamicPayload::payload_list_size() const {
  return payload_list_.size();
}
inline void TRpDynamicPayload::clear_payload_list() {
  payload_list_.Clear();
}
inline const ::mt::TDynamicPayload& TRpDynamicPayload::payload_list(int index) const {
  return payload_list_.Get(index);
}
inline ::mt::TDynamicPayload* TRpDynamicPayload::mutable_payload_list(int index) {
  return payload_list_.Mutable(index);
}
inline ::mt::TDynamicPayload* TRpDynamicPayload::add_payload_list() {
  return payload_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TDynamicPayload >&
TRpDynamicPayload::payload_list() const {
  return payload_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TDynamicPayload >*
TRpDynamicPayload::mutable_payload_list() {
  return &payload_list_;
}

// -------------------------------------------------------------------

// TMtForceSetH323Stack

// optional bool enable = 1;
inline bool TMtForceSetH323Stack::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtForceSetH323Stack::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtForceSetH323Stack::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtForceSetH323Stack::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TMtForceSetH323Stack::enable() const {
  return enable_;
}
inline void TMtForceSetH323Stack::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional bool bstand = 2;
inline bool TMtForceSetH323Stack::has_bstand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtForceSetH323Stack::set_has_bstand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtForceSetH323Stack::clear_has_bstand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtForceSetH323Stack::clear_bstand() {
  bstand_ = false;
  clear_has_bstand();
}
inline bool TMtForceSetH323Stack::bstand() const {
  return bstand_;
}
inline void TMtForceSetH323Stack::set_bstand(bool value) {
  set_has_bstand();
  bstand_ = value;
}

// -------------------------------------------------------------------

// TRtpRtcpPairPort

// optional uint32 rtpport = 1;
inline bool TRtpRtcpPairPort::has_rtpport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRtpRtcpPairPort::set_has_rtpport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRtpRtcpPairPort::clear_has_rtpport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRtpRtcpPairPort::clear_rtpport() {
  rtpport_ = 0u;
  clear_has_rtpport();
}
inline ::google::protobuf::uint32 TRtpRtcpPairPort::rtpport() const {
  return rtpport_;
}
inline void TRtpRtcpPairPort::set_rtpport(::google::protobuf::uint32 value) {
  set_has_rtpport();
  rtpport_ = value;
}

// optional uint32 rtcpport = 2;
inline bool TRtpRtcpPairPort::has_rtcpport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRtpRtcpPairPort::set_has_rtcpport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRtpRtcpPairPort::clear_has_rtcpport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRtpRtcpPairPort::clear_rtcpport() {
  rtcpport_ = 0u;
  clear_has_rtcpport();
}
inline ::google::protobuf::uint32 TRtpRtcpPairPort::rtcpport() const {
  return rtcpport_;
}
inline void TRtpRtcpPairPort::set_rtcpport(::google::protobuf::uint32 value) {
  set_has_rtcpport();
  rtcpport_ = value;
}

// -------------------------------------------------------------------

// TMTInnerMCAvSWPort

// optional .mt.TRtpRtcpPairPort mtVidPort = 1;
inline bool TMTInnerMCAvSWPort::has_mtvidport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTInnerMCAvSWPort::set_has_mtvidport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTInnerMCAvSWPort::clear_has_mtvidport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTInnerMCAvSWPort::clear_mtvidport() {
  if (mtvidport_ != NULL) mtvidport_->::mt::TRtpRtcpPairPort::Clear();
  clear_has_mtvidport();
}
inline const ::mt::TRtpRtcpPairPort& TMTInnerMCAvSWPort::mtvidport() const {
  return mtvidport_ != NULL ? *mtvidport_ : *default_instance_->mtvidport_;
}
inline ::mt::TRtpRtcpPairPort* TMTInnerMCAvSWPort::mutable_mtvidport() {
  set_has_mtvidport();
  if (mtvidport_ == NULL) mtvidport_ = new ::mt::TRtpRtcpPairPort;
  return mtvidport_;
}
inline ::mt::TRtpRtcpPairPort* TMTInnerMCAvSWPort::release_mtvidport() {
  clear_has_mtvidport();
  ::mt::TRtpRtcpPairPort* temp = mtvidport_;
  mtvidport_ = NULL;
  return temp;
}
inline void TMTInnerMCAvSWPort::set_allocated_mtvidport(::mt::TRtpRtcpPairPort* mtvidport) {
  delete mtvidport_;
  mtvidport_ = mtvidport;
  if (mtvidport) {
    set_has_mtvidport();
  } else {
    clear_has_mtvidport();
  }
}

// optional .mt.TRtpRtcpPairPort mtAudPort = 2;
inline bool TMTInnerMCAvSWPort::has_mtaudport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTInnerMCAvSWPort::set_has_mtaudport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTInnerMCAvSWPort::clear_has_mtaudport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTInnerMCAvSWPort::clear_mtaudport() {
  if (mtaudport_ != NULL) mtaudport_->::mt::TRtpRtcpPairPort::Clear();
  clear_has_mtaudport();
}
inline const ::mt::TRtpRtcpPairPort& TMTInnerMCAvSWPort::mtaudport() const {
  return mtaudport_ != NULL ? *mtaudport_ : *default_instance_->mtaudport_;
}
inline ::mt::TRtpRtcpPairPort* TMTInnerMCAvSWPort::mutable_mtaudport() {
  set_has_mtaudport();
  if (mtaudport_ == NULL) mtaudport_ = new ::mt::TRtpRtcpPairPort;
  return mtaudport_;
}
inline ::mt::TRtpRtcpPairPort* TMTInnerMCAvSWPort::release_mtaudport() {
  clear_has_mtaudport();
  ::mt::TRtpRtcpPairPort* temp = mtaudport_;
  mtaudport_ = NULL;
  return temp;
}
inline void TMTInnerMCAvSWPort::set_allocated_mtaudport(::mt::TRtpRtcpPairPort* mtaudport) {
  delete mtaudport_;
  mtaudport_ = mtaudport;
  if (mtaudport) {
    set_has_mtaudport();
  } else {
    clear_has_mtaudport();
  }
}

// optional .mt.TRtpRtcpPairPort mtAssPort = 3;
inline bool TMTInnerMCAvSWPort::has_mtassport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTInnerMCAvSWPort::set_has_mtassport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTInnerMCAvSWPort::clear_has_mtassport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTInnerMCAvSWPort::clear_mtassport() {
  if (mtassport_ != NULL) mtassport_->::mt::TRtpRtcpPairPort::Clear();
  clear_has_mtassport();
}
inline const ::mt::TRtpRtcpPairPort& TMTInnerMCAvSWPort::mtassport() const {
  return mtassport_ != NULL ? *mtassport_ : *default_instance_->mtassport_;
}
inline ::mt::TRtpRtcpPairPort* TMTInnerMCAvSWPort::mutable_mtassport() {
  set_has_mtassport();
  if (mtassport_ == NULL) mtassport_ = new ::mt::TRtpRtcpPairPort;
  return mtassport_;
}
inline ::mt::TRtpRtcpPairPort* TMTInnerMCAvSWPort::release_mtassport() {
  clear_has_mtassport();
  ::mt::TRtpRtcpPairPort* temp = mtassport_;
  mtassport_ = NULL;
  return temp;
}
inline void TMTInnerMCAvSWPort::set_allocated_mtassport(::mt::TRtpRtcpPairPort* mtassport) {
  delete mtassport_;
  mtassport_ = mtassport;
  if (mtassport) {
    set_has_mtassport();
  } else {
    clear_has_mtassport();
  }
}

// -------------------------------------------------------------------

// TMTInnerMcRcvAddr

// repeated .mt.TRtpRtcpPairPort mtVidPort = 1;
inline int TMTInnerMcRcvAddr::mtvidport_size() const {
  return mtvidport_.size();
}
inline void TMTInnerMcRcvAddr::clear_mtvidport() {
  mtvidport_.Clear();
}
inline const ::mt::TRtpRtcpPairPort& TMTInnerMcRcvAddr::mtvidport(int index) const {
  return mtvidport_.Get(index);
}
inline ::mt::TRtpRtcpPairPort* TMTInnerMcRcvAddr::mutable_mtvidport(int index) {
  return mtvidport_.Mutable(index);
}
inline ::mt::TRtpRtcpPairPort* TMTInnerMcRcvAddr::add_mtvidport() {
  return mtvidport_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPairPort >&
TMTInnerMcRcvAddr::mtvidport() const {
  return mtvidport_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPairPort >*
TMTInnerMcRcvAddr::mutable_mtvidport() {
  return &mtvidport_;
}

// repeated .mt.TRtpRtcpPairPort mtAudPort = 2;
inline int TMTInnerMcRcvAddr::mtaudport_size() const {
  return mtaudport_.size();
}
inline void TMTInnerMcRcvAddr::clear_mtaudport() {
  mtaudport_.Clear();
}
inline const ::mt::TRtpRtcpPairPort& TMTInnerMcRcvAddr::mtaudport(int index) const {
  return mtaudport_.Get(index);
}
inline ::mt::TRtpRtcpPairPort* TMTInnerMcRcvAddr::mutable_mtaudport(int index) {
  return mtaudport_.Mutable(index);
}
inline ::mt::TRtpRtcpPairPort* TMTInnerMcRcvAddr::add_mtaudport() {
  return mtaudport_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPairPort >&
TMTInnerMcRcvAddr::mtaudport() const {
  return mtaudport_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TRtpRtcpPairPort >*
TMTInnerMcRcvAddr::mutable_mtaudport() {
  return &mtaudport_;
}

// -------------------------------------------------------------------

// TAudioEncParam

// optional .mt.EmAudFormat aud_format = 1;
inline bool TAudioEncParam::has_aud_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAudioEncParam::set_has_aud_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAudioEncParam::clear_has_aud_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAudioEncParam::clear_aud_format() {
  aud_format_ = 0;
  clear_has_aud_format();
}
inline ::mt::EmAudFormat TAudioEncParam::aud_format() const {
  return static_cast< ::mt::EmAudFormat >(aud_format_);
}
inline void TAudioEncParam::set_aud_format(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_aud_format();
  aud_format_ = value;
}

// optional .mt.EmAacChnlNum channel_num = 2;
inline bool TAudioEncParam::has_channel_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAudioEncParam::set_has_channel_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAudioEncParam::clear_has_channel_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAudioEncParam::clear_channel_num() {
  channel_num_ = 0;
  clear_has_channel_num();
}
inline ::mt::EmAacChnlNum TAudioEncParam::channel_num() const {
  return static_cast< ::mt::EmAacChnlNum >(channel_num_);
}
inline void TAudioEncParam::set_channel_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_channel_num();
  channel_num_ = value;
}

// optional .mt.EmAacSampFreq sample_rate = 3;
inline bool TAudioEncParam::has_sample_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAudioEncParam::set_has_sample_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAudioEncParam::clear_has_sample_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAudioEncParam::clear_sample_rate() {
  sample_rate_ = 0;
  clear_has_sample_rate();
}
inline ::mt::EmAacSampFreq TAudioEncParam::sample_rate() const {
  return static_cast< ::mt::EmAacSampFreq >(sample_rate_);
}
inline void TAudioEncParam::set_sample_rate(::mt::EmAacSampFreq value) {
  assert(::mt::EmAacSampFreq_IsValid(value));
  set_has_sample_rate();
  sample_rate_ = value;
}

// optional uint32 aud_rate = 4;
inline bool TAudioEncParam::has_aud_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAudioEncParam::set_has_aud_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAudioEncParam::clear_has_aud_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAudioEncParam::clear_aud_rate() {
  aud_rate_ = 0u;
  clear_has_aud_rate();
}
inline ::google::protobuf::uint32 TAudioEncParam::aud_rate() const {
  return aud_rate_;
}
inline void TAudioEncParam::set_aud_rate(::google::protobuf::uint32 value) {
  set_has_aud_rate();
  aud_rate_ = value;
}

// optional uint32 head_flag = 5;
inline bool TAudioEncParam::has_head_flag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TAudioEncParam::set_has_head_flag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TAudioEncParam::clear_has_head_flag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TAudioEncParam::clear_head_flag() {
  head_flag_ = 0u;
  clear_has_head_flag();
}
inline ::google::protobuf::uint32 TAudioEncParam::head_flag() const {
  return head_flag_;
}
inline void TAudioEncParam::set_head_flag(::google::protobuf::uint32 value) {
  set_has_head_flag();
  head_flag_ = value;
}

// optional uint32 aud_duration = 6;
inline bool TAudioEncParam::has_aud_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TAudioEncParam::set_has_aud_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TAudioEncParam::clear_has_aud_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TAudioEncParam::clear_aud_duration() {
  aud_duration_ = 0u;
  clear_has_aud_duration();
}
inline ::google::protobuf::uint32 TAudioEncParam::aud_duration() const {
  return aud_duration_;
}
inline void TAudioEncParam::set_aud_duration(::google::protobuf::uint32 value) {
  set_has_aud_duration();
  aud_duration_ = value;
}

// -------------------------------------------------------------------

// TAudioEncParamList

// repeated .mt.TAudioEncParam aud_enc_param = 1;
inline int TAudioEncParamList::aud_enc_param_size() const {
  return aud_enc_param_.size();
}
inline void TAudioEncParamList::clear_aud_enc_param() {
  aud_enc_param_.Clear();
}
inline const ::mt::TAudioEncParam& TAudioEncParamList::aud_enc_param(int index) const {
  return aud_enc_param_.Get(index);
}
inline ::mt::TAudioEncParam* TAudioEncParamList::mutable_aud_enc_param(int index) {
  return aud_enc_param_.Mutable(index);
}
inline ::mt::TAudioEncParam* TAudioEncParamList::add_aud_enc_param() {
  return aud_enc_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudioEncParam >&
TAudioEncParamList::aud_enc_param() const {
  return aud_enc_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudioEncParam >*
TAudioEncParamList::mutable_aud_enc_param() {
  return &aud_enc_param_;
}

// -------------------------------------------------------------------

// TLoginStrategy

// optional uint32 login_count = 1;
inline bool TLoginStrategy::has_login_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TLoginStrategy::set_has_login_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TLoginStrategy::clear_has_login_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TLoginStrategy::clear_login_count() {
  login_count_ = 0u;
  clear_has_login_count();
}
inline ::google::protobuf::uint32 TLoginStrategy::login_count() const {
  return login_count_;
}
inline void TLoginStrategy::set_login_count(::google::protobuf::uint32 value) {
  set_has_login_count();
  login_count_ = value;
}

// optional uint32 wait_time = 2;
inline bool TLoginStrategy::has_wait_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TLoginStrategy::set_has_wait_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TLoginStrategy::clear_has_wait_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TLoginStrategy::clear_wait_time() {
  wait_time_ = 0u;
  clear_has_wait_time();
}
inline ::google::protobuf::uint32 TLoginStrategy::wait_time() const {
  return wait_time_;
}
inline void TLoginStrategy::set_wait_time(::google::protobuf::uint32 value) {
  set_has_wait_time();
  wait_time_ = value;
}

// -------------------------------------------------------------------

// TMtQtAddr

// optional bool is_enable = 1;
inline bool TMtQtAddr::has_is_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtQtAddr::set_has_is_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtQtAddr::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtQtAddr::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMtQtAddr::is_enable() const {
  return is_enable_;
}
inline void TMtQtAddr::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// optional string ip = 2;
inline bool TMtQtAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtQtAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtQtAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtQtAddr::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& TMtQtAddr::ip() const {
  return *ip_;
}
inline void TMtQtAddr::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TMtQtAddr::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TMtQtAddr::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtQtAddr::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* TMtQtAddr::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtQtAddr::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 3;
inline bool TMtQtAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtQtAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtQtAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtQtAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TMtQtAddr::port() const {
  return port_;
}
inline void TMtQtAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string username = 4;
inline bool TMtQtAddr::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtQtAddr::set_has_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtQtAddr::clear_has_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtQtAddr::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMtQtAddr::username() const {
  return *username_;
}
inline void TMtQtAddr::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMtQtAddr::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMtQtAddr::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtQtAddr::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMtQtAddr::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtQtAddr::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 5;
inline bool TMtQtAddr::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtQtAddr::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtQtAddr::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtQtAddr::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtQtAddr::password() const {
  return *password_;
}
inline void TMtQtAddr::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtQtAddr::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtQtAddr::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtQtAddr::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtQtAddr::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtQtAddr::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtSecKeyUpdatePolicy

// optional .mt.EmSecKeyUpdateMode emseckeyupdatemode = 1;
inline bool TMtSecKeyUpdatePolicy::has_emseckeyupdatemode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSecKeyUpdatePolicy::set_has_emseckeyupdatemode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSecKeyUpdatePolicy::clear_has_emseckeyupdatemode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSecKeyUpdatePolicy::clear_emseckeyupdatemode() {
  emseckeyupdatemode_ = 0;
  clear_has_emseckeyupdatemode();
}
inline ::mt::EmSecKeyUpdateMode TMtSecKeyUpdatePolicy::emseckeyupdatemode() const {
  return static_cast< ::mt::EmSecKeyUpdateMode >(emseckeyupdatemode_);
}
inline void TMtSecKeyUpdatePolicy::set_emseckeyupdatemode(::mt::EmSecKeyUpdateMode value) {
  assert(::mt::EmSecKeyUpdateMode_IsValid(value));
  set_has_emseckeyupdatemode();
  emseckeyupdatemode_ = value;
}

// optional uint32 keyupdateperiod = 2;
inline bool TMtSecKeyUpdatePolicy::has_keyupdateperiod() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSecKeyUpdatePolicy::set_has_keyupdateperiod() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSecKeyUpdatePolicy::clear_has_keyupdateperiod() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSecKeyUpdatePolicy::clear_keyupdateperiod() {
  keyupdateperiod_ = 0u;
  clear_has_keyupdateperiod();
}
inline ::google::protobuf::uint32 TMtSecKeyUpdatePolicy::keyupdateperiod() const {
  return keyupdateperiod_;
}
inline void TMtSecKeyUpdatePolicy::set_keyupdateperiod(::google::protobuf::uint32 value) {
  set_has_keyupdateperiod();
  keyupdateperiod_ = value;
}

// optional uint32 keyupdatepackcnt = 3;
inline bool TMtSecKeyUpdatePolicy::has_keyupdatepackcnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtSecKeyUpdatePolicy::set_has_keyupdatepackcnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtSecKeyUpdatePolicy::clear_has_keyupdatepackcnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtSecKeyUpdatePolicy::clear_keyupdatepackcnt() {
  keyupdatepackcnt_ = 0u;
  clear_has_keyupdatepackcnt();
}
inline ::google::protobuf::uint32 TMtSecKeyUpdatePolicy::keyupdatepackcnt() const {
  return keyupdatepackcnt_;
}
inline void TMtSecKeyUpdatePolicy::set_keyupdatepackcnt(::google::protobuf::uint32 value) {
  set_has_keyupdatepackcnt();
  keyupdatepackcnt_ = value;
}

// -------------------------------------------------------------------

// TAudAacConfPrm

// optional bytes conf_para = 1;
inline bool TAudAacConfPrm::has_conf_para() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAudAacConfPrm::set_has_conf_para() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAudAacConfPrm::clear_has_conf_para() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAudAacConfPrm::clear_conf_para() {
  if (conf_para_ != &::google::protobuf::internal::kEmptyString) {
    conf_para_->clear();
  }
  clear_has_conf_para();
}
inline const ::std::string& TAudAacConfPrm::conf_para() const {
  return *conf_para_;
}
inline void TAudAacConfPrm::set_conf_para(const ::std::string& value) {
  set_has_conf_para();
  if (conf_para_ == &::google::protobuf::internal::kEmptyString) {
    conf_para_ = new ::std::string;
  }
  conf_para_->assign(value);
}
inline void TAudAacConfPrm::set_conf_para(const char* value) {
  set_has_conf_para();
  if (conf_para_ == &::google::protobuf::internal::kEmptyString) {
    conf_para_ = new ::std::string;
  }
  conf_para_->assign(value);
}
inline void TAudAacConfPrm::set_conf_para(const void* value, size_t size) {
  set_has_conf_para();
  if (conf_para_ == &::google::protobuf::internal::kEmptyString) {
    conf_para_ = new ::std::string;
  }
  conf_para_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TAudAacConfPrm::mutable_conf_para() {
  set_has_conf_para();
  if (conf_para_ == &::google::protobuf::internal::kEmptyString) {
    conf_para_ = new ::std::string;
  }
  return conf_para_;
}
inline ::std::string* TAudAacConfPrm::release_conf_para() {
  clear_has_conf_para();
  if (conf_para_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_para_;
    conf_para_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TAudAacConfPrm::set_allocated_conf_para(::std::string* conf_para) {
  if (conf_para_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_para_;
  }
  if (conf_para) {
    set_has_conf_para();
    conf_para_ = conf_para;
  } else {
    clear_has_conf_para();
    conf_para_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmAacChnlNum emchnl_num = 2;
inline bool TAudAacConfPrm::has_emchnl_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAudAacConfPrm::set_has_emchnl_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAudAacConfPrm::clear_has_emchnl_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAudAacConfPrm::clear_emchnl_num() {
  emchnl_num_ = 0;
  clear_has_emchnl_num();
}
inline ::mt::EmAacChnlNum TAudAacConfPrm::emchnl_num() const {
  return static_cast< ::mt::EmAacChnlNum >(emchnl_num_);
}
inline void TAudAacConfPrm::set_emchnl_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_emchnl_num();
  emchnl_num_ = value;
}

// optional .mt.EmAacSampFreq emsamp_freq = 3;
inline bool TAudAacConfPrm::has_emsamp_freq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAudAacConfPrm::set_has_emsamp_freq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAudAacConfPrm::clear_has_emsamp_freq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAudAacConfPrm::clear_emsamp_freq() {
  emsamp_freq_ = 0;
  clear_has_emsamp_freq();
}
inline ::mt::EmAacSampFreq TAudAacConfPrm::emsamp_freq() const {
  return static_cast< ::mt::EmAacSampFreq >(emsamp_freq_);
}
inline void TAudAacConfPrm::set_emsamp_freq(::mt::EmAacSampFreq value) {
  assert(::mt::EmAacSampFreq_IsValid(value));
  set_has_emsamp_freq();
  emsamp_freq_ = value;
}

// -------------------------------------------------------------------

// TAudAacConfPrmList

// repeated .mt.TAudAacConfPrm aud_aac_conf = 1;
inline int TAudAacConfPrmList::aud_aac_conf_size() const {
  return aud_aac_conf_.size();
}
inline void TAudAacConfPrmList::clear_aud_aac_conf() {
  aud_aac_conf_.Clear();
}
inline const ::mt::TAudAacConfPrm& TAudAacConfPrmList::aud_aac_conf(int index) const {
  return aud_aac_conf_.Get(index);
}
inline ::mt::TAudAacConfPrm* TAudAacConfPrmList::mutable_aud_aac_conf(int index) {
  return aud_aac_conf_.Mutable(index);
}
inline ::mt::TAudAacConfPrm* TAudAacConfPrmList::add_aud_aac_conf() {
  return aud_aac_conf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudAacConfPrm >&
TAudAacConfPrmList::aud_aac_conf() const {
  return aud_aac_conf_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudAacConfPrm >*
TAudAacConfPrmList::mutable_aud_aac_conf() {
  return &aud_aac_conf_;
}

// -------------------------------------------------------------------

// TServerLoginPort

// optional uint32 http_port = 1;
inline bool TServerLoginPort::has_http_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TServerLoginPort::set_has_http_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TServerLoginPort::clear_has_http_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TServerLoginPort::clear_http_port() {
  http_port_ = 0u;
  clear_has_http_port();
}
inline ::google::protobuf::uint32 TServerLoginPort::http_port() const {
  return http_port_;
}
inline void TServerLoginPort::set_http_port(::google::protobuf::uint32 value) {
  set_has_http_port();
  http_port_ = value;
}

// optional uint32 https_port = 2 [default = 60090];
inline bool TServerLoginPort::has_https_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TServerLoginPort::set_has_https_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TServerLoginPort::clear_has_https_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TServerLoginPort::clear_https_port() {
  https_port_ = 60090u;
  clear_has_https_port();
}
inline ::google::protobuf::uint32 TServerLoginPort::https_port() const {
  return https_port_;
}
inline void TServerLoginPort::set_https_port(::google::protobuf::uint32 value) {
  set_has_https_port();
  https_port_ = value;
}

// -------------------------------------------------------------------

// TPlatformType

// optional .mt.EmPlatform em_platform = 1;
inline bool TPlatformType::has_em_platform() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPlatformType::set_has_em_platform() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPlatformType::clear_has_em_platform() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPlatformType::clear_em_platform() {
  em_platform_ = 0;
  clear_has_em_platform();
}
inline ::mt::EmPlatform TPlatformType::em_platform() const {
  return static_cast< ::mt::EmPlatform >(em_platform_);
}
inline void TPlatformType::set_em_platform(::mt::EmPlatform value) {
  assert(::mt::EmPlatform_IsValid(value));
  set_has_em_platform();
  em_platform_ = value;
}

// optional bool https = 2;
inline bool TPlatformType::has_https() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TPlatformType::set_has_https() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TPlatformType::clear_has_https() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TPlatformType::clear_https() {
  https_ = false;
  clear_has_https();
}
inline bool TPlatformType::https() const {
  return https_;
}
inline void TPlatformType::set_https(bool value) {
  set_has_https();
  https_ = value;
}

// -------------------------------------------------------------------

// TMTAgentInfo

// optional bool is_agent = 1;
inline bool TMTAgentInfo::has_is_agent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTAgentInfo::set_has_is_agent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTAgentInfo::clear_has_is_agent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTAgentInfo::clear_is_agent() {
  is_agent_ = false;
  clear_has_is_agent();
}
inline bool TMTAgentInfo::is_agent() const {
  return is_agent_;
}
inline void TMTAgentInfo::set_is_agent(bool value) {
  set_has_is_agent();
  is_agent_ = value;
}

// optional uint32 agent_id = 2;
inline bool TMTAgentInfo::has_agent_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTAgentInfo::set_has_agent_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTAgentInfo::clear_has_agent_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTAgentInfo::clear_agent_id() {
  agent_id_ = 0u;
  clear_has_agent_id();
}
inline ::google::protobuf::uint32 TMTAgentInfo::agent_id() const {
  return agent_id_;
}
inline void TMTAgentInfo::set_agent_id(::google::protobuf::uint32 value) {
  set_has_agent_id();
  agent_id_ = value;
}

// -------------------------------------------------------------------

// TMTVgaImageOutAdjustCfg

// optional int32 vga1_imageout_offset = 1;
inline bool TMTVgaImageOutAdjustCfg::has_vga1_imageout_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTVgaImageOutAdjustCfg::set_has_vga1_imageout_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTVgaImageOutAdjustCfg::clear_has_vga1_imageout_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTVgaImageOutAdjustCfg::clear_vga1_imageout_offset() {
  vga1_imageout_offset_ = 0;
  clear_has_vga1_imageout_offset();
}
inline ::google::protobuf::int32 TMTVgaImageOutAdjustCfg::vga1_imageout_offset() const {
  return vga1_imageout_offset_;
}
inline void TMTVgaImageOutAdjustCfg::set_vga1_imageout_offset(::google::protobuf::int32 value) {
  set_has_vga1_imageout_offset();
  vga1_imageout_offset_ = value;
}

// optional int32 vga2_imageout_offset = 2;
inline bool TMTVgaImageOutAdjustCfg::has_vga2_imageout_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTVgaImageOutAdjustCfg::set_has_vga2_imageout_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTVgaImageOutAdjustCfg::clear_has_vga2_imageout_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTVgaImageOutAdjustCfg::clear_vga2_imageout_offset() {
  vga2_imageout_offset_ = 0;
  clear_has_vga2_imageout_offset();
}
inline ::google::protobuf::int32 TMTVgaImageOutAdjustCfg::vga2_imageout_offset() const {
  return vga2_imageout_offset_;
}
inline void TMTVgaImageOutAdjustCfg::set_vga2_imageout_offset(::google::protobuf::int32 value) {
  set_has_vga2_imageout_offset();
  vga2_imageout_offset_ = value;
}

// -------------------------------------------------------------------

// TMtPlatformInfo

// optional string version = 1;
inline bool TMtPlatformInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtPlatformInfo::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtPlatformInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtPlatformInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TMtPlatformInfo::version() const {
  return *version_;
}
inline void TMtPlatformInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TMtPlatformInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TMtPlatformInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtPlatformInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* TMtPlatformInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtPlatformInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TMtPlatformInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtPlatformInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtPlatformInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtPlatformInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TMtPlatformInfo::ip() const {
  return ip_;
}
inline void TMtPlatformInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional .mt.EmResourceType resource_type = 3;
inline bool TMtPlatformInfo::has_resource_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtPlatformInfo::set_has_resource_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtPlatformInfo::clear_has_resource_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtPlatformInfo::clear_resource_type() {
  resource_type_ = 0;
  clear_has_resource_type();
}
inline ::mt::EmResourceType TMtPlatformInfo::resource_type() const {
  return static_cast< ::mt::EmResourceType >(resource_type_);
}
inline void TMtPlatformInfo::set_resource_type(::mt::EmResourceType value) {
  assert(::mt::EmResourceType_IsValid(value));
  set_has_resource_type();
  resource_type_ = value;
}

// -------------------------------------------------------------------

// TMtCameraLastPos

// optional bool b_use = 1;
inline bool TMtCameraLastPos::has_b_use() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtCameraLastPos::set_has_b_use() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtCameraLastPos::clear_has_b_use() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtCameraLastPos::clear_b_use() {
  b_use_ = false;
  clear_has_b_use();
}
inline bool TMtCameraLastPos::b_use() const {
  return b_use_;
}
inline void TMtCameraLastPos::set_b_use(bool value) {
  set_has_b_use();
  b_use_ = value;
}

// optional int32 pos_x = 2;
inline bool TMtCameraLastPos::has_pos_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtCameraLastPos::set_has_pos_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtCameraLastPos::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtCameraLastPos::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline ::google::protobuf::int32 TMtCameraLastPos::pos_x() const {
  return pos_x_;
}
inline void TMtCameraLastPos::set_pos_x(::google::protobuf::int32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// optional int32 pos_y = 3;
inline bool TMtCameraLastPos::has_pos_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtCameraLastPos::set_has_pos_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtCameraLastPos::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtCameraLastPos::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline ::google::protobuf::int32 TMtCameraLastPos::pos_y() const {
  return pos_y_;
}
inline void TMtCameraLastPos::set_pos_y(::google::protobuf::int32 value) {
  set_has_pos_y();
  pos_y_ = value;
}

// optional int32 type = 4;
inline bool TMtCameraLastPos::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtCameraLastPos::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtCameraLastPos::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtCameraLastPos::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 TMtCameraLastPos::type() const {
  return type_;
}
inline void TMtCameraLastPos::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// TMtShortCutKey

// optional .mt.EmShortCutKeyType key_type = 1;
inline bool TMtShortCutKey::has_key_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtShortCutKey::set_has_key_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtShortCutKey::clear_has_key_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtShortCutKey::clear_key_type() {
  key_type_ = 0;
  clear_has_key_type();
}
inline ::mt::EmShortCutKeyType TMtShortCutKey::key_type() const {
  return static_cast< ::mt::EmShortCutKeyType >(key_type_);
}
inline void TMtShortCutKey::set_key_type(::mt::EmShortCutKeyType value) {
  assert(::mt::EmShortCutKeyType_IsValid(value));
  set_has_key_type();
  key_type_ = value;
}

// optional .mt.EmShortCutKeyFuc key_fuc = 2;
inline bool TMtShortCutKey::has_key_fuc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtShortCutKey::set_has_key_fuc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtShortCutKey::clear_has_key_fuc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtShortCutKey::clear_key_fuc() {
  key_fuc_ = 0;
  clear_has_key_fuc();
}
inline ::mt::EmShortCutKeyFuc TMtShortCutKey::key_fuc() const {
  return static_cast< ::mt::EmShortCutKeyFuc >(key_fuc_);
}
inline void TMtShortCutKey::set_key_fuc(::mt::EmShortCutKeyFuc value) {
  assert(::mt::EmShortCutKeyFuc_IsValid(value));
  set_has_key_fuc();
  key_fuc_ = value;
}

// -------------------------------------------------------------------

// TMtShortCutKeyList

// repeated .mt.TMtShortCutKey short_cut_key = 1;
inline int TMtShortCutKeyList::short_cut_key_size() const {
  return short_cut_key_.size();
}
inline void TMtShortCutKeyList::clear_short_cut_key() {
  short_cut_key_.Clear();
}
inline const ::mt::TMtShortCutKey& TMtShortCutKeyList::short_cut_key(int index) const {
  return short_cut_key_.Get(index);
}
inline ::mt::TMtShortCutKey* TMtShortCutKeyList::mutable_short_cut_key(int index) {
  return short_cut_key_.Mutable(index);
}
inline ::mt::TMtShortCutKey* TMtShortCutKeyList::add_short_cut_key() {
  return short_cut_key_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtShortCutKey >&
TMtShortCutKeyList::short_cut_key() const {
  return short_cut_key_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtShortCutKey >*
TMtShortCutKeyList::mutable_short_cut_key() {
  return &short_cut_key_;
}

// -------------------------------------------------------------------

// TMtFunctionIcon

// optional .mt.EmFunctionIcon icon_type = 1;
inline bool TMtFunctionIcon::has_icon_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtFunctionIcon::set_has_icon_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtFunctionIcon::clear_has_icon_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtFunctionIcon::clear_icon_type() {
  icon_type_ = 0;
  clear_has_icon_type();
}
inline ::mt::EmFunctionIcon TMtFunctionIcon::icon_type() const {
  return static_cast< ::mt::EmFunctionIcon >(icon_type_);
}
inline void TMtFunctionIcon::set_icon_type(::mt::EmFunctionIcon value) {
  assert(::mt::EmFunctionIcon_IsValid(value));
  set_has_icon_type();
  icon_type_ = value;
}

// optional bool is_enable = 2;
inline bool TMtFunctionIcon::has_is_enable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtFunctionIcon::set_has_is_enable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtFunctionIcon::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtFunctionIcon::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool TMtFunctionIcon::is_enable() const {
  return is_enable_;
}
inline void TMtFunctionIcon::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
}

// -------------------------------------------------------------------

// TMtFunctionIconList

// repeated .mt.TMtFunctionIcon function_icon = 1;
inline int TMtFunctionIconList::function_icon_size() const {
  return function_icon_.size();
}
inline void TMtFunctionIconList::clear_function_icon() {
  function_icon_.Clear();
}
inline const ::mt::TMtFunctionIcon& TMtFunctionIconList::function_icon(int index) const {
  return function_icon_.Get(index);
}
inline ::mt::TMtFunctionIcon* TMtFunctionIconList::mutable_function_icon(int index) {
  return function_icon_.Mutable(index);
}
inline ::mt::TMtFunctionIcon* TMtFunctionIconList::add_function_icon() {
  return function_icon_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtFunctionIcon >&
TMtFunctionIconList::function_icon() const {
  return function_icon_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtFunctionIcon >*
TMtFunctionIconList::mutable_function_icon() {
  return &function_icon_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mt

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_structcfg_2eproto__INCLUDED
