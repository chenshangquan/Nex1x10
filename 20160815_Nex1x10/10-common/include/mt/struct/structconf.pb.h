// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structconf.proto

#ifndef PROTOBUF_structconf_2eproto__INCLUDED
#define PROTOBUF_structconf_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "enum.pb.h"
#include "structcommon.pb.h"
// @@protoc_insertion_point(includes)

namespace mt {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_structconf_2eproto();
void protobuf_AssignDesc_structconf_2eproto();
void protobuf_ShutdownFile_structconf_2eproto();

class TMtRpRes;
class TVidDes;
class TVidFormatCap;
class TAudDes;
class TVidCapList;
class TAudCapList;
class TMtSendCap;
class TMtRecvCap;
class TDecCap;
class TDecSimuCap;
class TMtCap;
class TRpMtCap;
class TMtConfHandle;
class TMtChanAddr;
class TChanDsInfo;
class TMutiChanDsInfo;
class TOneChanDSInfo;
class TAudChanParam;
class TSrtpCrypto;
class TSrtpParamSetting;
class TAVCapSrtpParam;
class TVidChanParam;
class TRpAudChanParam;
class TRpVidChanParam;
class TMtAVChanParam;
class TMtConfBaseInfo;
class TRpMtConfList;
class TMtConfNameInfo;
class TRpMtConfNameInfo;
class TMtNewConfBaseInfo;
class TMtConfDetailInfo;
class TMtJoinConfParam;
class TMtJoinConfParamList;
class TMtCreateConfParam;
class TMtAutorecattrb;
class TMtVrsalias;
class TMtMiniPollInfo;
class TMtMiniVmpParam;
class TMtMiniVMPMember;
class TMtCallParam;
class TMultiMtCallParam;
class TMTSatelliteFlag;
class TMtCallLinkSate;
class TCodecPackStat;
class TMtStatusToPcdv;
class TAssVidStatus;
class TMtAssSndVidStatus;
class TMtAssRcvVidStatus;
class TMtSimpConfInfo;
class TMtTerLossRate;
class TMtChanLossRate;
class TMtConfInfo;
class TPeerCapabilityInfo;
class TMtMixParam;
class TMtVmpParam;
class TMtVmpItem;
class TMtPollInfo;
class TVideoSourceInfo;
class TRpVideoSourceInfo;
class TMtVideoAlias;
class TRpMtVideoAlias;
class TMtEntityStatus;
class TRpMtEntityStatus;
class TVideoInfo;
class TRpVideoInfo;
class TTerStatus;
class TShortMsg;
class TMtRegistReq;
class TGkRegInfo;
class TH323StackHandle;
class TMtRCFInfo;
class TMtACFInfo;
class TMtFeccMsg;
class TMtSeeing;
class TRpMtSeeing;
class TViewTerParam;
class TCloudRecordState;
class TInnerMCParam;
class TInnerMCRunInfo;
class TFastCall;
class TFastCallList;
class TMtSecCertDistinctName;
class TMtSecCertValidity;
class TMtSecCertInfo;
class TRpMtSecCaIDList;
class TMtTerAuthCmd;
class TMtTerAuthRequest;
class TMtTerAuthCancel;
class TMtTerAuthMsg;
class TMtSecCreateCertReq;
class TMtVrsUserInfo;
class TLicense;
class TMtAiInviteInfo;
class TMtAiInviteInfoList;
class TVendorCheckConfig;

// ===================================================================

class MTMSG_API TMtRpRes : public ::google::protobuf::Message {
 public:
  TMtRpRes();
  virtual ~TMtRpRes();

  TMtRpRes(const TMtRpRes& from);

  inline TMtRpRes& operator=(const TMtRpRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtRpRes& default_instance();

  void Swap(TMtRpRes* other);

  // implements Message ----------------------------------------------

  TMtRpRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtRpRes& from);
  void MergeFrom(const TMtRpRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.EmMtResolution res = 1;
  inline int res_size() const;
  inline void clear_res();
  static const int kResFieldNumber = 1;
  inline ::mt::EmMtResolution res(int index) const;
  inline void set_res(int index, ::mt::EmMtResolution value);
  inline void add_res(::mt::EmMtResolution value);
  inline const ::google::protobuf::RepeatedField<int>& res() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_res();

  // @@protoc_insertion_point(class_scope:mt.TMtRpRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> res_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtRpRes* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidDes : public ::google::protobuf::Message {
 public:
  TVidDes();
  virtual ~TVidDes();

  TVidDes(const TVidDes& from);

  inline TVidDes& operator=(const TVidDes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidDes& default_instance();

  void Swap(TVidDes* other);

  // implements Message ----------------------------------------------

  TVidDes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidDes& from);
  void MergeFrom(const TVidDes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtResolution res = 1;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 1;
  inline ::mt::EmMtResolution res() const;
  inline void set_res(::mt::EmMtResolution value);

  // optional uint32 mpi = 2;
  inline bool has_mpi() const;
  inline void clear_mpi();
  static const int kMpiFieldNumber = 2;
  inline ::google::protobuf::uint32 mpi() const;
  inline void set_mpi(::google::protobuf::uint32 value);

  // optional uint32 max_bitrate = 3;
  inline bool has_max_bitrate() const;
  inline void clear_max_bitrate();
  static const int kMaxBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 max_bitrate() const;
  inline void set_max_bitrate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TVidDes)
 private:
  inline void set_has_res();
  inline void clear_has_res();
  inline void set_has_mpi();
  inline void clear_has_mpi();
  inline void set_has_max_bitrate();
  inline void clear_has_max_bitrate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int res_;
  ::google::protobuf::uint32 mpi_;
  ::google::protobuf::uint32 max_bitrate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TVidDes* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidFormatCap : public ::google::protobuf::Message {
 public:
  TVidFormatCap();
  virtual ~TVidFormatCap();

  TVidFormatCap(const TVidFormatCap& from);

  inline TVidFormatCap& operator=(const TVidFormatCap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidFormatCap& default_instance();

  void Swap(TVidFormatCap* other);

  // implements Message ----------------------------------------------

  TVidFormatCap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidFormatCap& from);
  void MergeFrom(const TVidFormatCap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVidFormat format = 1;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 1;
  inline ::mt::EmVidFormat format() const;
  inline void set_format(::mt::EmVidFormat value);

  // repeated .mt.TVidDes item = 2;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::mt::TVidDes& item(int index) const;
  inline ::mt::TVidDes* mutable_item(int index);
  inline ::mt::TVidDes* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidDes >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidDes >*
      mutable_item();

  // optional .mt.EmH264Profile profile = 3;
  inline bool has_profile() const;
  inline void clear_profile();
  static const int kProfileFieldNumber = 3;
  inline ::mt::EmH264Profile profile() const;
  inline void set_profile(::mt::EmH264Profile value);

  // optional .mt.EmH264AdditionalModes h264_modes = 4;
  inline bool has_h264_modes() const;
  inline void clear_h264_modes();
  static const int kH264ModesFieldNumber = 4;
  inline ::mt::EmH264AdditionalModes h264_modes() const;
  inline void set_h264_modes(::mt::EmH264AdditionalModes value);

  // optional .mt.EmH265Profile h265_profile = 5;
  inline bool has_h265_profile() const;
  inline void clear_h265_profile();
  static const int kH265ProfileFieldNumber = 5;
  inline ::mt::EmH265Profile h265_profile() const;
  inline void set_h265_profile(::mt::EmH265Profile value);

  // @@protoc_insertion_point(class_scope:mt.TVidFormatCap)
 private:
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_profile();
  inline void clear_has_profile();
  inline void set_has_h264_modes();
  inline void clear_has_h264_modes();
  inline void set_has_h265_profile();
  inline void clear_has_h265_profile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVidDes > item_;
  int format_;
  int profile_;
  int h264_modes_;
  int h265_profile_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TVidFormatCap* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudDes : public ::google::protobuf::Message {
 public:
  TAudDes();
  virtual ~TAudDes();

  TAudDes(const TAudDes& from);

  inline TAudDes& operator=(const TAudDes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudDes& default_instance();

  void Swap(TAudDes* other);

  // implements Message ----------------------------------------------

  TAudDes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudDes& from);
  void MergeFrom(const TAudDes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmAudFormat format = 1;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 1;
  inline ::mt::EmAudFormat format() const;
  inline void set_format(::mt::EmAudFormat value);

  // optional uint32 pack_time = 2;
  inline bool has_pack_time() const;
  inline void clear_pack_time();
  static const int kPackTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 pack_time() const;
  inline void set_pack_time(::google::protobuf::uint32 value);

  // optional .mt.EmAacChnlNum chnl_num = 3;
  inline bool has_chnl_num() const;
  inline void clear_chnl_num();
  static const int kChnlNumFieldNumber = 3;
  inline ::mt::EmAacChnlNum chnl_num() const;
  inline void set_chnl_num(::mt::EmAacChnlNum value);

  // optional .mt.EmAacSampFreq samp_freq = 4;
  inline bool has_samp_freq() const;
  inline void clear_samp_freq();
  static const int kSampFreqFieldNumber = 4;
  inline ::mt::EmAacSampFreq samp_freq() const;
  inline void set_samp_freq(::mt::EmAacSampFreq value);

  // optional uint32 aac_rate = 5 [default = 96];
  inline bool has_aac_rate() const;
  inline void clear_aac_rate();
  static const int kAacRateFieldNumber = 5;
  inline ::google::protobuf::uint32 aac_rate() const;
  inline void set_aac_rate(::google::protobuf::uint32 value);

  // optional uint32 opus_min_rate = 6;
  inline bool has_opus_min_rate() const;
  inline void clear_opus_min_rate();
  static const int kOpusMinRateFieldNumber = 6;
  inline ::google::protobuf::uint32 opus_min_rate() const;
  inline void set_opus_min_rate(::google::protobuf::uint32 value);

  // optional uint32 opus_max_rate = 7;
  inline bool has_opus_max_rate() const;
  inline void clear_opus_max_rate();
  static const int kOpusMaxRateFieldNumber = 7;
  inline ::google::protobuf::uint32 opus_max_rate() const;
  inline void set_opus_max_rate(::google::protobuf::uint32 value);

  // optional uint32 g7221_rate = 8;
  inline bool has_g7221_rate() const;
  inline void clear_g7221_rate();
  static const int kG7221RateFieldNumber = 8;
  inline ::google::protobuf::uint32 g7221_rate() const;
  inline void set_g7221_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TAudDes)
 private:
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_pack_time();
  inline void clear_has_pack_time();
  inline void set_has_chnl_num();
  inline void clear_has_chnl_num();
  inline void set_has_samp_freq();
  inline void clear_has_samp_freq();
  inline void set_has_aac_rate();
  inline void clear_has_aac_rate();
  inline void set_has_opus_min_rate();
  inline void clear_has_opus_min_rate();
  inline void set_has_opus_max_rate();
  inline void clear_has_opus_max_rate();
  inline void set_has_g7221_rate();
  inline void clear_has_g7221_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int format_;
  ::google::protobuf::uint32 pack_time_;
  int chnl_num_;
  int samp_freq_;
  ::google::protobuf::uint32 aac_rate_;
  ::google::protobuf::uint32 opus_min_rate_;
  ::google::protobuf::uint32 opus_max_rate_;
  ::google::protobuf::uint32 g7221_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TAudDes* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidCapList : public ::google::protobuf::Message {
 public:
  TVidCapList();
  virtual ~TVidCapList();

  TVidCapList(const TVidCapList& from);

  inline TVidCapList& operator=(const TVidCapList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidCapList& default_instance();

  void Swap(TVidCapList* other);

  // implements Message ----------------------------------------------

  TVidCapList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidCapList& from);
  void MergeFrom(const TVidCapList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVidFormatCap vid_list = 1;
  inline int vid_list_size() const;
  inline void clear_vid_list();
  static const int kVidListFieldNumber = 1;
  inline const ::mt::TVidFormatCap& vid_list(int index) const;
  inline ::mt::TVidFormatCap* mutable_vid_list(int index);
  inline ::mt::TVidFormatCap* add_vid_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidFormatCap >&
      vid_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidFormatCap >*
      mutable_vid_list();

  // optional .mt.EmMtVidLabel vid_lab = 2;
  inline bool has_vid_lab() const;
  inline void clear_vid_lab();
  static const int kVidLabFieldNumber = 2;
  inline ::mt::EmMtVidLabel vid_lab() const;
  inline void set_vid_lab(::mt::EmMtVidLabel value);

  // optional uint32 app_chan = 3;
  inline bool has_app_chan() const;
  inline void clear_app_chan();
  static const int kAppChanFieldNumber = 3;
  inline ::google::protobuf::uint32 app_chan() const;
  inline void set_app_chan(::google::protobuf::uint32 value);

  // optional bool active = 4 [default = true];
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 4;
  inline bool active() const;
  inline void set_active(bool value);

  // optional uint32 percent = 5;
  inline bool has_percent() const;
  inline void clear_percent();
  static const int kPercentFieldNumber = 5;
  inline ::google::protobuf::uint32 percent() const;
  inline void set_percent(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TVidCapList)
 private:
  inline void set_has_vid_lab();
  inline void clear_has_vid_lab();
  inline void set_has_app_chan();
  inline void clear_has_app_chan();
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_percent();
  inline void clear_has_percent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVidFormatCap > vid_list_;
  int vid_lab_;
  ::google::protobuf::uint32 app_chan_;
  bool active_;
  ::google::protobuf::uint32 percent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TVidCapList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudCapList : public ::google::protobuf::Message {
 public:
  TAudCapList();
  virtual ~TAudCapList();

  TAudCapList(const TAudCapList& from);

  inline TAudCapList& operator=(const TAudCapList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudCapList& default_instance();

  void Swap(TAudCapList* other);

  // implements Message ----------------------------------------------

  TAudCapList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudCapList& from);
  void MergeFrom(const TAudCapList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAudDes aud_list = 1;
  inline int aud_list_size() const;
  inline void clear_aud_list();
  static const int kAudListFieldNumber = 1;
  inline const ::mt::TAudDes& aud_list(int index) const;
  inline ::mt::TAudDes* mutable_aud_list(int index);
  inline ::mt::TAudDes* add_aud_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudDes >&
      aud_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudDes >*
      mutable_aud_list();

  // optional .mt.EmMtAudLabel aud_lab = 2;
  inline bool has_aud_lab() const;
  inline void clear_aud_lab();
  static const int kAudLabFieldNumber = 2;
  inline ::mt::EmMtAudLabel aud_lab() const;
  inline void set_aud_lab(::mt::EmMtAudLabel value);

  // optional uint32 app_chan = 3;
  inline bool has_app_chan() const;
  inline void clear_app_chan();
  static const int kAppChanFieldNumber = 3;
  inline ::google::protobuf::uint32 app_chan() const;
  inline void set_app_chan(::google::protobuf::uint32 value);

  // optional bool active = 4 [default = true];
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 4;
  inline bool active() const;
  inline void set_active(bool value);

  // @@protoc_insertion_point(class_scope:mt.TAudCapList)
 private:
  inline void set_has_aud_lab();
  inline void clear_has_aud_lab();
  inline void set_has_app_chan();
  inline void clear_has_app_chan();
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAudDes > aud_list_;
  int aud_lab_;
  ::google::protobuf::uint32 app_chan_;
  bool active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TAudCapList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSendCap : public ::google::protobuf::Message {
 public:
  TMtSendCap();
  virtual ~TMtSendCap();

  TMtSendCap(const TMtSendCap& from);

  inline TMtSendCap& operator=(const TMtSendCap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSendCap& default_instance();

  void Swap(TMtSendCap* other);

  // implements Message ----------------------------------------------

  TMtSendCap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSendCap& from);
  void MergeFrom(const TMtSendCap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAudCapList main_aud_send_cap = 1;
  inline int main_aud_send_cap_size() const;
  inline void clear_main_aud_send_cap();
  static const int kMainAudSendCapFieldNumber = 1;
  inline const ::mt::TAudCapList& main_aud_send_cap(int index) const;
  inline ::mt::TAudCapList* mutable_main_aud_send_cap(int index);
  inline ::mt::TAudCapList* add_main_aud_send_cap();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >&
      main_aud_send_cap() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >*
      mutable_main_aud_send_cap();

  // repeated .mt.TVidCapList main_vid_send_cap = 2;
  inline int main_vid_send_cap_size() const;
  inline void clear_main_vid_send_cap();
  static const int kMainVidSendCapFieldNumber = 2;
  inline const ::mt::TVidCapList& main_vid_send_cap(int index) const;
  inline ::mt::TVidCapList* mutable_main_vid_send_cap(int index);
  inline ::mt::TVidCapList* add_main_vid_send_cap();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >&
      main_vid_send_cap() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >*
      mutable_main_vid_send_cap();

  // repeated .mt.TAudCapList ass_aud_send_cap = 3;
  inline int ass_aud_send_cap_size() const;
  inline void clear_ass_aud_send_cap();
  static const int kAssAudSendCapFieldNumber = 3;
  inline const ::mt::TAudCapList& ass_aud_send_cap(int index) const;
  inline ::mt::TAudCapList* mutable_ass_aud_send_cap(int index);
  inline ::mt::TAudCapList* add_ass_aud_send_cap();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >&
      ass_aud_send_cap() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >*
      mutable_ass_aud_send_cap();

  // repeated .mt.TVidCapList ass_vid_send_cap = 4;
  inline int ass_vid_send_cap_size() const;
  inline void clear_ass_vid_send_cap();
  static const int kAssVidSendCapFieldNumber = 4;
  inline const ::mt::TVidCapList& ass_vid_send_cap(int index) const;
  inline ::mt::TVidCapList* mutable_ass_vid_send_cap(int index);
  inline ::mt::TVidCapList* add_ass_vid_send_cap();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >&
      ass_vid_send_cap() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >*
      mutable_ass_vid_send_cap();

  // @@protoc_insertion_point(class_scope:mt.TMtSendCap)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList > main_aud_send_cap_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList > main_vid_send_cap_;
  ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList > ass_aud_send_cap_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList > ass_vid_send_cap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtSendCap* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtRecvCap : public ::google::protobuf::Message {
 public:
  TMtRecvCap();
  virtual ~TMtRecvCap();

  TMtRecvCap(const TMtRecvCap& from);

  inline TMtRecvCap& operator=(const TMtRecvCap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtRecvCap& default_instance();

  void Swap(TMtRecvCap* other);

  // implements Message ----------------------------------------------

  TMtRecvCap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtRecvCap& from);
  void MergeFrom(const TMtRecvCap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAudCapList main_aud_recv_cap = 1;
  inline int main_aud_recv_cap_size() const;
  inline void clear_main_aud_recv_cap();
  static const int kMainAudRecvCapFieldNumber = 1;
  inline const ::mt::TAudCapList& main_aud_recv_cap(int index) const;
  inline ::mt::TAudCapList* mutable_main_aud_recv_cap(int index);
  inline ::mt::TAudCapList* add_main_aud_recv_cap();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >&
      main_aud_recv_cap() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >*
      mutable_main_aud_recv_cap();

  // repeated .mt.TVidCapList main_vid_recv_cap = 2;
  inline int main_vid_recv_cap_size() const;
  inline void clear_main_vid_recv_cap();
  static const int kMainVidRecvCapFieldNumber = 2;
  inline const ::mt::TVidCapList& main_vid_recv_cap(int index) const;
  inline ::mt::TVidCapList* mutable_main_vid_recv_cap(int index);
  inline ::mt::TVidCapList* add_main_vid_recv_cap();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >&
      main_vid_recv_cap() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >*
      mutable_main_vid_recv_cap();

  // repeated .mt.TAudCapList ass_aud_recv_cap = 3;
  inline int ass_aud_recv_cap_size() const;
  inline void clear_ass_aud_recv_cap();
  static const int kAssAudRecvCapFieldNumber = 3;
  inline const ::mt::TAudCapList& ass_aud_recv_cap(int index) const;
  inline ::mt::TAudCapList* mutable_ass_aud_recv_cap(int index);
  inline ::mt::TAudCapList* add_ass_aud_recv_cap();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >&
      ass_aud_recv_cap() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >*
      mutable_ass_aud_recv_cap();

  // repeated .mt.TVidCapList ass_vid_recv_cap = 4;
  inline int ass_vid_recv_cap_size() const;
  inline void clear_ass_vid_recv_cap();
  static const int kAssVidRecvCapFieldNumber = 4;
  inline const ::mt::TVidCapList& ass_vid_recv_cap(int index) const;
  inline ::mt::TVidCapList* mutable_ass_vid_recv_cap(int index);
  inline ::mt::TVidCapList* add_ass_vid_recv_cap();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >&
      ass_vid_recv_cap() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >*
      mutable_ass_vid_recv_cap();

  // optional .mt.TDecCap h323_dec_cap = 5;
  inline bool has_h323_dec_cap() const;
  inline void clear_h323_dec_cap();
  static const int kH323DecCapFieldNumber = 5;
  inline const ::mt::TDecCap& h323_dec_cap() const;
  inline ::mt::TDecCap* mutable_h323_dec_cap();
  inline ::mt::TDecCap* release_h323_dec_cap();
  inline void set_allocated_h323_dec_cap(::mt::TDecCap* h323_dec_cap);

  // @@protoc_insertion_point(class_scope:mt.TMtRecvCap)
 private:
  inline void set_has_h323_dec_cap();
  inline void clear_has_h323_dec_cap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList > main_aud_recv_cap_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList > main_vid_recv_cap_;
  ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList > ass_aud_recv_cap_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList > ass_vid_recv_cap_;
  ::mt::TDecCap* h323_dec_cap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtRecvCap* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDecCap : public ::google::protobuf::Message {
 public:
  TDecCap();
  virtual ~TDecCap();

  TDecCap(const TDecCap& from);

  inline TDecCap& operator=(const TDecCap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDecCap& default_instance();

  void Swap(TDecCap* other);

  // implements Message ----------------------------------------------

  TDecCap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDecCap& from);
  void MergeFrom(const TDecCap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TDecSimuCap dec_simu_cap = 1;
  inline int dec_simu_cap_size() const;
  inline void clear_dec_simu_cap();
  static const int kDecSimuCapFieldNumber = 1;
  inline const ::mt::TDecSimuCap& dec_simu_cap(int index) const;
  inline ::mt::TDecSimuCap* mutable_dec_simu_cap(int index);
  inline ::mt::TDecSimuCap* add_dec_simu_cap();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TDecSimuCap >&
      dec_simu_cap() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TDecSimuCap >*
      mutable_dec_simu_cap();

  // @@protoc_insertion_point(class_scope:mt.TDecCap)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TDecSimuCap > dec_simu_cap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TDecCap* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TDecSimuCap : public ::google::protobuf::Message {
 public:
  TDecSimuCap();
  virtual ~TDecSimuCap();

  TDecSimuCap(const TDecSimuCap& from);

  inline TDecSimuCap& operator=(const TDecSimuCap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDecSimuCap& default_instance();

  void Swap(TDecSimuCap* other);

  // implements Message ----------------------------------------------

  TDecSimuCap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDecSimuCap& from);
  void MergeFrom(const TDecSimuCap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 aud_list = 1;
  inline int aud_list_size() const;
  inline void clear_aud_list();
  static const int kAudListFieldNumber = 1;
  inline ::google::protobuf::uint32 aud_list(int index) const;
  inline void set_aud_list(int index, ::google::protobuf::uint32 value);
  inline void add_aud_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      aud_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_aud_list();

  // repeated uint32 main_vid_list = 2;
  inline int main_vid_list_size() const;
  inline void clear_main_vid_list();
  static const int kMainVidListFieldNumber = 2;
  inline ::google::protobuf::uint32 main_vid_list(int index) const;
  inline void set_main_vid_list(int index, ::google::protobuf::uint32 value);
  inline void add_main_vid_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      main_vid_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_main_vid_list();

  // repeated uint32 ass_vid_list = 3;
  inline int ass_vid_list_size() const;
  inline void clear_ass_vid_list();
  static const int kAssVidListFieldNumber = 3;
  inline ::google::protobuf::uint32 ass_vid_list(int index) const;
  inline void set_ass_vid_list(int index, ::google::protobuf::uint32 value);
  inline void add_ass_vid_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ass_vid_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ass_vid_list();

  // @@protoc_insertion_point(class_scope:mt.TDecSimuCap)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > aud_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > main_vid_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ass_vid_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TDecSimuCap* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtCap : public ::google::protobuf::Message {
 public:
  TMtCap();
  virtual ~TMtCap();

  TMtCap(const TMtCap& from);

  inline TMtCap& operator=(const TMtCap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtCap& default_instance();

  void Swap(TMtCap* other);

  // implements Message ----------------------------------------------

  TMtCap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtCap& from);
  void MergeFrom(const TMtCap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMtSendCap send_cap = 1;
  inline bool has_send_cap() const;
  inline void clear_send_cap();
  static const int kSendCapFieldNumber = 1;
  inline const ::mt::TMtSendCap& send_cap() const;
  inline ::mt::TMtSendCap* mutable_send_cap();
  inline ::mt::TMtSendCap* release_send_cap();
  inline void set_allocated_send_cap(::mt::TMtSendCap* send_cap);

  // optional .mt.TMtRecvCap recv_cap = 2;
  inline bool has_recv_cap() const;
  inline void clear_recv_cap();
  static const int kRecvCapFieldNumber = 2;
  inline const ::mt::TMtRecvCap& recv_cap() const;
  inline ::mt::TMtRecvCap* mutable_recv_cap();
  inline ::mt::TMtRecvCap* release_recv_cap();
  inline void set_allocated_recv_cap(::mt::TMtRecvCap* recv_cap);

  // optional uint32 vendor = 3;
  inline bool has_vendor() const;
  inline void clear_vendor();
  static const int kVendorFieldNumber = 3;
  inline ::google::protobuf::uint32 vendor() const;
  inline void set_vendor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtCap)
 private:
  inline void set_has_send_cap();
  inline void clear_has_send_cap();
  inline void set_has_recv_cap();
  inline void clear_has_recv_cap();
  inline void set_has_vendor();
  inline void clear_has_vendor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMtSendCap* send_cap_;
  ::mt::TMtRecvCap* recv_cap_;
  ::google::protobuf::uint32 vendor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtCap* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtCap : public ::google::protobuf::Message {
 public:
  TRpMtCap();
  virtual ~TRpMtCap();

  TRpMtCap(const TRpMtCap& from);

  inline TRpMtCap& operator=(const TRpMtCap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtCap& default_instance();

  void Swap(TRpMtCap* other);

  // implements Message ----------------------------------------------

  TRpMtCap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtCap& from);
  void MergeFrom(const TRpMtCap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtCap mt_cap = 1;
  inline int mt_cap_size() const;
  inline void clear_mt_cap();
  static const int kMtCapFieldNumber = 1;
  inline const ::mt::TMtCap& mt_cap(int index) const;
  inline ::mt::TMtCap* mutable_mt_cap(int index);
  inline ::mt::TMtCap* add_mt_cap();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtCap >&
      mt_cap() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtCap >*
      mutable_mt_cap();

  // @@protoc_insertion_point(class_scope:mt.TRpMtCap)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtCap > mt_cap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TRpMtCap* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtConfHandle : public ::google::protobuf::Message {
 public:
  TMtConfHandle();
  virtual ~TMtConfHandle();

  TMtConfHandle(const TMtConfHandle& from);

  inline TMtConfHandle& operator=(const TMtConfHandle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtConfHandle& default_instance();

  void Swap(TMtConfHandle* other);

  // implements Message ----------------------------------------------

  TMtConfHandle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtConfHandle& from);
  void MergeFrom(const TMtConfHandle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 chan = 1;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 1;
  inline ::google::protobuf::uint32 chan() const;
  inline void set_chan(::google::protobuf::uint32 value);

  // optional uint32 app_chan = 2;
  inline bool has_app_chan() const;
  inline void clear_app_chan();
  static const int kAppChanFieldNumber = 2;
  inline ::google::protobuf::uint32 app_chan() const;
  inline void set_app_chan(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtConfHandle)
 private:
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_app_chan();
  inline void clear_has_app_chan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 chan_;
  ::google::protobuf::uint32 app_chan_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtConfHandle* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtChanAddr : public ::google::protobuf::Message {
 public:
  TMtChanAddr();
  virtual ~TMtChanAddr();

  TMtChanAddr(const TMtChanAddr& from);

  inline TMtChanAddr& operator=(const TMtChanAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtChanAddr& default_instance();

  void Swap(TMtChanAddr* other);

  // implements Message ----------------------------------------------

  TMtChanAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtChanAddr& from);
  void MergeFrom(const TMtChanAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TNetAddr local_rtp = 1;
  inline bool has_local_rtp() const;
  inline void clear_local_rtp();
  static const int kLocalRtpFieldNumber = 1;
  inline const ::mt::TNetAddr& local_rtp() const;
  inline ::mt::TNetAddr* mutable_local_rtp();
  inline ::mt::TNetAddr* release_local_rtp();
  inline void set_allocated_local_rtp(::mt::TNetAddr* local_rtp);

  // optional .mt.TNetAddr local_rtcp = 2;
  inline bool has_local_rtcp() const;
  inline void clear_local_rtcp();
  static const int kLocalRtcpFieldNumber = 2;
  inline const ::mt::TNetAddr& local_rtcp() const;
  inline ::mt::TNetAddr* mutable_local_rtcp();
  inline ::mt::TNetAddr* release_local_rtcp();
  inline void set_allocated_local_rtcp(::mt::TNetAddr* local_rtcp);

  // optional .mt.TNetAddr peer_rtp = 3;
  inline bool has_peer_rtp() const;
  inline void clear_peer_rtp();
  static const int kPeerRtpFieldNumber = 3;
  inline const ::mt::TNetAddr& peer_rtp() const;
  inline ::mt::TNetAddr* mutable_peer_rtp();
  inline ::mt::TNetAddr* release_peer_rtp();
  inline void set_allocated_peer_rtp(::mt::TNetAddr* peer_rtp);

  // optional .mt.TNetAddr peer_rtcp = 4;
  inline bool has_peer_rtcp() const;
  inline void clear_peer_rtcp();
  static const int kPeerRtcpFieldNumber = 4;
  inline const ::mt::TNetAddr& peer_rtcp() const;
  inline ::mt::TNetAddr* mutable_peer_rtcp();
  inline ::mt::TNetAddr* release_peer_rtcp();
  inline void set_allocated_peer_rtcp(::mt::TNetAddr* peer_rtcp);

  // @@protoc_insertion_point(class_scope:mt.TMtChanAddr)
 private:
  inline void set_has_local_rtp();
  inline void clear_has_local_rtp();
  inline void set_has_local_rtcp();
  inline void clear_has_local_rtcp();
  inline void set_has_peer_rtp();
  inline void clear_has_peer_rtp();
  inline void set_has_peer_rtcp();
  inline void clear_has_peer_rtcp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TNetAddr* local_rtp_;
  ::mt::TNetAddr* local_rtcp_;
  ::mt::TNetAddr* peer_rtp_;
  ::mt::TNetAddr* peer_rtcp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtChanAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TChanDsInfo : public ::google::protobuf::Message {
 public:
  TChanDsInfo();
  virtual ~TChanDsInfo();

  TChanDsInfo(const TChanDsInfo& from);

  inline TChanDsInfo& operator=(const TChanDsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TChanDsInfo& default_instance();

  void Swap(TChanDsInfo* other);

  // implements Message ----------------------------------------------

  TChanDsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TChanDsInfo& from);
  void MergeFrom(const TChanDsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtChanType chan_type = 1;
  inline bool has_chan_type() const;
  inline void clear_chan_type();
  static const int kChanTypeFieldNumber = 1;
  inline ::mt::EmMtChanType chan_type() const;
  inline void set_chan_type(::mt::EmMtChanType value);

  // repeated .mt.TOneChanDSInfo one_chan_info = 2;
  inline int one_chan_info_size() const;
  inline void clear_one_chan_info();
  static const int kOneChanInfoFieldNumber = 2;
  inline const ::mt::TOneChanDSInfo& one_chan_info(int index) const;
  inline ::mt::TOneChanDSInfo* mutable_one_chan_info(int index);
  inline ::mt::TOneChanDSInfo* add_one_chan_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TOneChanDSInfo >&
      one_chan_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TOneChanDSInfo >*
      mutable_one_chan_info();

  // @@protoc_insertion_point(class_scope:mt.TChanDsInfo)
 private:
  inline void set_has_chan_type();
  inline void clear_has_chan_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TOneChanDSInfo > one_chan_info_;
  int chan_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TChanDsInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMutiChanDsInfo : public ::google::protobuf::Message {
 public:
  TMutiChanDsInfo();
  virtual ~TMutiChanDsInfo();

  TMutiChanDsInfo(const TMutiChanDsInfo& from);

  inline TMutiChanDsInfo& operator=(const TMutiChanDsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMutiChanDsInfo& default_instance();

  void Swap(TMutiChanDsInfo* other);

  // implements Message ----------------------------------------------

  TMutiChanDsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMutiChanDsInfo& from);
  void MergeFrom(const TMutiChanDsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TChanDsInfo chan_info = 1;
  inline int chan_info_size() const;
  inline void clear_chan_info();
  static const int kChanInfoFieldNumber = 1;
  inline const ::mt::TChanDsInfo& chan_info(int index) const;
  inline ::mt::TChanDsInfo* mutable_chan_info(int index);
  inline ::mt::TChanDsInfo* add_chan_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TChanDsInfo >&
      chan_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TChanDsInfo >*
      mutable_chan_info();

  // @@protoc_insertion_point(class_scope:mt.TMutiChanDsInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TChanDsInfo > chan_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMutiChanDsInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TOneChanDSInfo : public ::google::protobuf::Message {
 public:
  TOneChanDSInfo();
  virtual ~TOneChanDSInfo();

  TOneChanDSInfo(const TOneChanDSInfo& from);

  inline TOneChanDSInfo& operator=(const TOneChanDSInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOneChanDSInfo& default_instance();

  void Swap(TOneChanDSInfo* other);

  // implements Message ----------------------------------------------

  TOneChanDSInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TOneChanDSInfo& from);
  void MergeFrom(const TOneChanDSInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtChanState chan_state = 1;
  inline bool has_chan_state() const;
  inline void clear_chan_state();
  static const int kChanStateFieldNumber = 1;
  inline ::mt::EmMtChanState chan_state() const;
  inline void set_chan_state(::mt::EmMtChanState value);

  // optional bool bactive = 2;
  inline bool has_bactive() const;
  inline void clear_bactive();
  static const int kBactiveFieldNumber = 2;
  inline bool bactive() const;
  inline void set_bactive(bool value);

  // optional .mt.TEncryptKey encry_key = 3;
  inline bool has_encry_key() const;
  inline void clear_encry_key();
  static const int kEncryKeyFieldNumber = 3;
  inline const ::mt::TEncryptKey& encry_key() const;
  inline ::mt::TEncryptKey* mutable_encry_key();
  inline ::mt::TEncryptKey* release_encry_key();
  inline void set_allocated_encry_key(::mt::TEncryptKey* encry_key);

  // optional .mt.TMtChanAddr chan_addr = 4;
  inline bool has_chan_addr() const;
  inline void clear_chan_addr();
  static const int kChanAddrFieldNumber = 4;
  inline const ::mt::TMtChanAddr& chan_addr() const;
  inline ::mt::TMtChanAddr* mutable_chan_addr();
  inline ::mt::TMtChanAddr* release_chan_addr();
  inline void set_allocated_chan_addr(::mt::TMtChanAddr* chan_addr);

  // optional .mt.EmMtAudLabel aud_label = 5;
  inline bool has_aud_label() const;
  inline void clear_aud_label();
  static const int kAudLabelFieldNumber = 5;
  inline ::mt::EmMtAudLabel aud_label() const;
  inline void set_aud_label(::mt::EmMtAudLabel value);

  // optional .mt.EmAudFormat aud_format = 6;
  inline bool has_aud_format() const;
  inline void clear_aud_format();
  static const int kAudFormatFieldNumber = 6;
  inline ::mt::EmAudFormat aud_format() const;
  inline void set_aud_format(::mt::EmAudFormat value);

  // optional .mt.EmAacChnlNum aac_chnl_num = 7;
  inline bool has_aac_chnl_num() const;
  inline void clear_aac_chnl_num();
  static const int kAacChnlNumFieldNumber = 7;
  inline ::mt::EmAacChnlNum aac_chnl_num() const;
  inline void set_aac_chnl_num(::mt::EmAacChnlNum value);

  // optional bool bg7221_reverse = 8;
  inline bool has_bg7221_reverse() const;
  inline void clear_bg7221_reverse();
  static const int kBg7221ReverseFieldNumber = 8;
  inline bool bg7221_reverse() const;
  inline void set_bg7221_reverse(bool value);

  // optional .mt.EmMtVidLabel vid_label = 9;
  inline bool has_vid_label() const;
  inline void clear_vid_label();
  static const int kVidLabelFieldNumber = 9;
  inline ::mt::EmMtVidLabel vid_label() const;
  inline void set_vid_label(::mt::EmMtVidLabel value);

  // optional .mt.EmVidFormat vid_format = 10;
  inline bool has_vid_format() const;
  inline void clear_vid_format();
  static const int kVidFormatFieldNumber = 10;
  inline ::mt::EmVidFormat vid_format() const;
  inline void set_vid_format(::mt::EmVidFormat value);

  // optional .mt.EmMtResolution vid_resolution = 11;
  inline bool has_vid_resolution() const;
  inline void clear_vid_resolution();
  static const int kVidResolutionFieldNumber = 11;
  inline ::mt::EmMtResolution vid_resolution() const;
  inline void set_vid_resolution(::mt::EmMtResolution value);

  // optional uint32 frame_rate = 12;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 12;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // optional .mt.EmH264Profile h264_profile = 13;
  inline bool has_h264_profile() const;
  inline void clear_h264_profile();
  static const int kH264ProfileFieldNumber = 13;
  inline ::mt::EmH264Profile h264_profile() const;
  inline void set_h264_profile(::mt::EmH264Profile value);

  // optional .mt.EmEncryptArithmetic emEncrypt = 14;
  inline bool has_emencrypt() const;
  inline void clear_emencrypt();
  static const int kEmEncryptFieldNumber = 14;
  inline ::mt::EmEncryptArithmetic emencrypt() const;
  inline void set_emencrypt(::mt::EmEncryptArithmetic value);

  // optional uint32 chanbitrate = 15;
  inline bool has_chanbitrate() const;
  inline void clear_chanbitrate();
  static const int kChanbitrateFieldNumber = 15;
  inline ::google::protobuf::uint32 chanbitrate() const;
  inline void set_chanbitrate(::google::protobuf::uint32 value);

  // optional uint32 payload = 16;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 16;
  inline ::google::protobuf::uint32 payload() const;
  inline void set_payload(::google::protobuf::uint32 value);

  // optional .mt.TNetAddr forward_rtp = 20;
  inline bool has_forward_rtp() const;
  inline void clear_forward_rtp();
  static const int kForwardRtpFieldNumber = 20;
  inline const ::mt::TNetAddr& forward_rtp() const;
  inline ::mt::TNetAddr* mutable_forward_rtp();
  inline ::mt::TNetAddr* release_forward_rtp();
  inline void set_allocated_forward_rtp(::mt::TNetAddr* forward_rtp);

  // optional .mt.TNetAddr forward_rtcp = 21;
  inline bool has_forward_rtcp() const;
  inline void clear_forward_rtcp();
  static const int kForwardRtcpFieldNumber = 21;
  inline const ::mt::TNetAddr& forward_rtcp() const;
  inline ::mt::TNetAddr* mutable_forward_rtcp();
  inline ::mt::TNetAddr* release_forward_rtcp();
  inline void set_allocated_forward_rtcp(::mt::TNetAddr* forward_rtcp);

  // optional .mt.TNetAddr pc_rtcp = 22;
  inline bool has_pc_rtcp() const;
  inline void clear_pc_rtcp();
  static const int kPcRtcpFieldNumber = 22;
  inline const ::mt::TNetAddr& pc_rtcp() const;
  inline ::mt::TNetAddr* mutable_pc_rtcp();
  inline ::mt::TNetAddr* release_pc_rtcp();
  inline void set_allocated_pc_rtcp(::mt::TNetAddr* pc_rtcp);

  // optional .mt.TMtConfHandle conf_handle = 23;
  inline bool has_conf_handle() const;
  inline void clear_conf_handle();
  static const int kConfHandleFieldNumber = 23;
  inline const ::mt::TMtConfHandle& conf_handle() const;
  inline ::mt::TMtConfHandle* mutable_conf_handle();
  inline ::mt::TMtConfHandle* release_conf_handle();
  inline void set_allocated_conf_handle(::mt::TMtConfHandle* conf_handle);

  // @@protoc_insertion_point(class_scope:mt.TOneChanDSInfo)
 private:
  inline void set_has_chan_state();
  inline void clear_has_chan_state();
  inline void set_has_bactive();
  inline void clear_has_bactive();
  inline void set_has_encry_key();
  inline void clear_has_encry_key();
  inline void set_has_chan_addr();
  inline void clear_has_chan_addr();
  inline void set_has_aud_label();
  inline void clear_has_aud_label();
  inline void set_has_aud_format();
  inline void clear_has_aud_format();
  inline void set_has_aac_chnl_num();
  inline void clear_has_aac_chnl_num();
  inline void set_has_bg7221_reverse();
  inline void clear_has_bg7221_reverse();
  inline void set_has_vid_label();
  inline void clear_has_vid_label();
  inline void set_has_vid_format();
  inline void clear_has_vid_format();
  inline void set_has_vid_resolution();
  inline void clear_has_vid_resolution();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();
  inline void set_has_h264_profile();
  inline void clear_has_h264_profile();
  inline void set_has_emencrypt();
  inline void clear_has_emencrypt();
  inline void set_has_chanbitrate();
  inline void clear_has_chanbitrate();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_forward_rtp();
  inline void clear_has_forward_rtp();
  inline void set_has_forward_rtcp();
  inline void clear_has_forward_rtcp();
  inline void set_has_pc_rtcp();
  inline void clear_has_pc_rtcp();
  inline void set_has_conf_handle();
  inline void clear_has_conf_handle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TEncryptKey* encry_key_;
  int chan_state_;
  int aud_label_;
  ::mt::TMtChanAddr* chan_addr_;
  bool bactive_;
  bool bg7221_reverse_;
  int aud_format_;
  int aac_chnl_num_;
  int vid_label_;
  int vid_format_;
  int vid_resolution_;
  ::google::protobuf::uint32 frame_rate_;
  int h264_profile_;
  int emencrypt_;
  ::google::protobuf::uint32 chanbitrate_;
  ::mt::TNetAddr* forward_rtp_;
  ::mt::TNetAddr* forward_rtcp_;
  ::mt::TNetAddr* pc_rtcp_;
  ::mt::TMtConfHandle* conf_handle_;
  ::google::protobuf::uint32 payload_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TOneChanDSInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAudChanParam : public ::google::protobuf::Message {
 public:
  TAudChanParam();
  virtual ~TAudChanParam();

  TAudChanParam(const TAudChanParam& from);

  inline TAudChanParam& operator=(const TAudChanParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAudChanParam& default_instance();

  void Swap(TAudChanParam* other);

  // implements Message ----------------------------------------------

  TAudChanParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAudChanParam& from);
  void MergeFrom(const TAudChanParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmAudFormat audio_format = 1;
  inline bool has_audio_format() const;
  inline void clear_audio_format();
  static const int kAudioFormatFieldNumber = 1;
  inline ::mt::EmAudFormat audio_format() const;
  inline void set_audio_format(::mt::EmAudFormat value);

  // optional uint32 payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline ::google::protobuf::uint32 payload() const;
  inline void set_payload(::google::protobuf::uint32 value);

  // optional .mt.TEncryptKey encry_key = 3;
  inline bool has_encry_key() const;
  inline void clear_encry_key();
  static const int kEncryKeyFieldNumber = 3;
  inline const ::mt::TEncryptKey& encry_key() const;
  inline ::mt::TEncryptKey* mutable_encry_key();
  inline ::mt::TEncryptKey* release_encry_key();
  inline void set_allocated_encry_key(::mt::TEncryptKey* encry_key);

  // optional .mt.EmEncryptArithmetic encrypt_arith = 4;
  inline bool has_encrypt_arith() const;
  inline void clear_encrypt_arith();
  static const int kEncryptArithFieldNumber = 4;
  inline ::mt::EmEncryptArithmetic encrypt_arith() const;
  inline void set_encrypt_arith(::mt::EmEncryptArithmetic value);

  // optional .mt.EmAacChnlNum aac_chnl_num = 5;
  inline bool has_aac_chnl_num() const;
  inline void clear_aac_chnl_num();
  static const int kAacChnlNumFieldNumber = 5;
  inline ::mt::EmAacChnlNum aac_chnl_num() const;
  inline void set_aac_chnl_num(::mt::EmAacChnlNum value);

  // optional .mt.EmAacSampFreq aac_samp_frq = 6;
  inline bool has_aac_samp_frq() const;
  inline void clear_aac_samp_frq();
  static const int kAacSampFrqFieldNumber = 6;
  inline ::mt::EmAacSampFreq aac_samp_frq() const;
  inline void set_aac_samp_frq(::mt::EmAacSampFreq value);

  // optional uint32 aac_bitrate = 7 [default = 96];
  inline bool has_aac_bitrate() const;
  inline void clear_aac_bitrate();
  static const int kAacBitrateFieldNumber = 7;
  inline ::google::protobuf::uint32 aac_bitrate() const;
  inline void set_aac_bitrate(::google::protobuf::uint32 value);

  // optional uint32 g7221_rate = 8;
  inline bool has_g7221_rate() const;
  inline void clear_g7221_rate();
  static const int kG7221RateFieldNumber = 8;
  inline ::google::protobuf::uint32 g7221_rate() const;
  inline void set_g7221_rate(::google::protobuf::uint32 value);

  // optional bool bg7221_reverse = 9;
  inline bool has_bg7221_reverse() const;
  inline void clear_bg7221_reverse();
  static const int kBg7221ReverseFieldNumber = 9;
  inline bool bg7221_reverse() const;
  inline void set_bg7221_reverse(bool value);

  // optional bool is_nat_traversal = 10;
  inline bool has_is_nat_traversal() const;
  inline void clear_is_nat_traversal();
  static const int kIsNatTraversalFieldNumber = 10;
  inline bool is_nat_traversal() const;
  inline void set_is_nat_traversal(bool value);

  // optional bytes aac_ld_MuxConfig = 11;
  inline bool has_aac_ld_muxconfig() const;
  inline void clear_aac_ld_muxconfig();
  static const int kAacLdMuxConfigFieldNumber = 11;
  inline const ::std::string& aac_ld_muxconfig() const;
  inline void set_aac_ld_muxconfig(const ::std::string& value);
  inline void set_aac_ld_muxconfig(const char* value);
  inline void set_aac_ld_muxconfig(const void* value, size_t size);
  inline ::std::string* mutable_aac_ld_muxconfig();
  inline ::std::string* release_aac_ld_muxconfig();
  inline void set_allocated_aac_ld_muxconfig(::std::string* aac_ld_muxconfig);

  // optional bool is_tlp_event = 12;
  inline bool has_is_tlp_event() const;
  inline void clear_is_tlp_event();
  static const int kIsTlpEventFieldNumber = 12;
  inline bool is_tlp_event() const;
  inline void set_is_tlp_event(bool value);

  // @@protoc_insertion_point(class_scope:mt.TAudChanParam)
 private:
  inline void set_has_audio_format();
  inline void clear_has_audio_format();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_encry_key();
  inline void clear_has_encry_key();
  inline void set_has_encrypt_arith();
  inline void clear_has_encrypt_arith();
  inline void set_has_aac_chnl_num();
  inline void clear_has_aac_chnl_num();
  inline void set_has_aac_samp_frq();
  inline void clear_has_aac_samp_frq();
  inline void set_has_aac_bitrate();
  inline void clear_has_aac_bitrate();
  inline void set_has_g7221_rate();
  inline void clear_has_g7221_rate();
  inline void set_has_bg7221_reverse();
  inline void clear_has_bg7221_reverse();
  inline void set_has_is_nat_traversal();
  inline void clear_has_is_nat_traversal();
  inline void set_has_aac_ld_muxconfig();
  inline void clear_has_aac_ld_muxconfig();
  inline void set_has_is_tlp_event();
  inline void clear_has_is_tlp_event();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int audio_format_;
  ::google::protobuf::uint32 payload_;
  ::mt::TEncryptKey* encry_key_;
  int encrypt_arith_;
  int aac_chnl_num_;
  int aac_samp_frq_;
  ::google::protobuf::uint32 aac_bitrate_;
  ::google::protobuf::uint32 g7221_rate_;
  bool bg7221_reverse_;
  bool is_nat_traversal_;
  bool is_tlp_event_;
  ::std::string* aac_ld_muxconfig_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TAudChanParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TSrtpCrypto : public ::google::protobuf::Message {
 public:
  TSrtpCrypto();
  virtual ~TSrtpCrypto();

  TSrtpCrypto(const TSrtpCrypto& from);

  inline TSrtpCrypto& operator=(const TSrtpCrypto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSrtpCrypto& default_instance();

  void Swap(TSrtpCrypto* other);

  // implements Message ----------------------------------------------

  TSrtpCrypto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSrtpCrypto& from);
  void MergeFrom(const TSrtpCrypto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmSrtpCryptoType srtp_crypto_type = 1;
  inline bool has_srtp_crypto_type() const;
  inline void clear_srtp_crypto_type();
  static const int kSrtpCryptoTypeFieldNumber = 1;
  inline ::mt::EmSrtpCryptoType srtp_crypto_type() const;
  inline void set_srtp_crypto_type(::mt::EmSrtpCryptoType value);

  // optional .mt.EmSrtpAuthType srtp_auth_type = 2;
  inline bool has_srtp_auth_type() const;
  inline void clear_srtp_auth_type();
  static const int kSrtpAuthTypeFieldNumber = 2;
  inline ::mt::EmSrtpAuthType srtp_auth_type() const;
  inline void set_srtp_auth_type(::mt::EmSrtpAuthType value);

  // optional uint32 srtp_tag = 3;
  inline bool has_srtp_tag() const;
  inline void clear_srtp_tag();
  static const int kSrtpTagFieldNumber = 3;
  inline ::google::protobuf::uint32 srtp_tag() const;
  inline void set_srtp_tag(::google::protobuf::uint32 value);

  // optional bytes crypto_key = 4;
  inline bool has_crypto_key() const;
  inline void clear_crypto_key();
  static const int kCryptoKeyFieldNumber = 4;
  inline const ::std::string& crypto_key() const;
  inline void set_crypto_key(const ::std::string& value);
  inline void set_crypto_key(const char* value);
  inline void set_crypto_key(const void* value, size_t size);
  inline ::std::string* mutable_crypto_key();
  inline ::std::string* release_crypto_key();
  inline void set_allocated_crypto_key(::std::string* crypto_key);

  // optional bytes crypto_keyid = 5;
  inline bool has_crypto_keyid() const;
  inline void clear_crypto_keyid();
  static const int kCryptoKeyidFieldNumber = 5;
  inline const ::std::string& crypto_keyid() const;
  inline void set_crypto_keyid(const ::std::string& value);
  inline void set_crypto_keyid(const char* value);
  inline void set_crypto_keyid(const void* value, size_t size);
  inline ::std::string* mutable_crypto_keyid();
  inline ::std::string* release_crypto_keyid();
  inline void set_allocated_crypto_keyid(::std::string* crypto_keyid);

  // optional uint32 crypto_keyid_len = 6;
  inline bool has_crypto_keyid_len() const;
  inline void clear_crypto_keyid_len();
  static const int kCryptoKeyidLenFieldNumber = 6;
  inline ::google::protobuf::uint32 crypto_keyid_len() const;
  inline void set_crypto_keyid_len(::google::protobuf::uint32 value);

  // optional bytes bkrtcp_crypto_key = 7;
  inline bool has_bkrtcp_crypto_key() const;
  inline void clear_bkrtcp_crypto_key();
  static const int kBkrtcpCryptoKeyFieldNumber = 7;
  inline const ::std::string& bkrtcp_crypto_key() const;
  inline void set_bkrtcp_crypto_key(const ::std::string& value);
  inline void set_bkrtcp_crypto_key(const char* value);
  inline void set_bkrtcp_crypto_key(const void* value, size_t size);
  inline ::std::string* mutable_bkrtcp_crypto_key();
  inline ::std::string* release_bkrtcp_crypto_key();
  inline void set_allocated_bkrtcp_crypto_key(::std::string* bkrtcp_crypto_key);

  // @@protoc_insertion_point(class_scope:mt.TSrtpCrypto)
 private:
  inline void set_has_srtp_crypto_type();
  inline void clear_has_srtp_crypto_type();
  inline void set_has_srtp_auth_type();
  inline void clear_has_srtp_auth_type();
  inline void set_has_srtp_tag();
  inline void clear_has_srtp_tag();
  inline void set_has_crypto_key();
  inline void clear_has_crypto_key();
  inline void set_has_crypto_keyid();
  inline void clear_has_crypto_keyid();
  inline void set_has_crypto_keyid_len();
  inline void clear_has_crypto_keyid_len();
  inline void set_has_bkrtcp_crypto_key();
  inline void clear_has_bkrtcp_crypto_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int srtp_crypto_type_;
  int srtp_auth_type_;
  ::std::string* crypto_key_;
  ::google::protobuf::uint32 srtp_tag_;
  ::google::protobuf::uint32 crypto_keyid_len_;
  ::std::string* crypto_keyid_;
  ::std::string* bkrtcp_crypto_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TSrtpCrypto* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TSrtpParamSetting : public ::google::protobuf::Message {
 public:
  TSrtpParamSetting();
  virtual ~TSrtpParamSetting();

  TSrtpParamSetting(const TSrtpParamSetting& from);

  inline TSrtpParamSetting& operator=(const TSrtpParamSetting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSrtpParamSetting& default_instance();

  void Swap(TSrtpParamSetting* other);

  // implements Message ----------------------------------------------

  TSrtpParamSetting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSrtpParamSetting& from);
  void MergeFrom(const TSrtpParamSetting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_srtp_enable = 1;
  inline bool has_is_srtp_enable() const;
  inline void clear_is_srtp_enable();
  static const int kIsSrtpEnableFieldNumber = 1;
  inline bool is_srtp_enable() const;
  inline void set_is_srtp_enable(bool value);

  // repeated .mt.TSrtpCrypto srtp_crypto_param = 2;
  inline int srtp_crypto_param_size() const;
  inline void clear_srtp_crypto_param();
  static const int kSrtpCryptoParamFieldNumber = 2;
  inline const ::mt::TSrtpCrypto& srtp_crypto_param(int index) const;
  inline ::mt::TSrtpCrypto* mutable_srtp_crypto_param(int index);
  inline ::mt::TSrtpCrypto* add_srtp_crypto_param();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TSrtpCrypto >&
      srtp_crypto_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TSrtpCrypto >*
      mutable_srtp_crypto_param();

  // @@protoc_insertion_point(class_scope:mt.TSrtpParamSetting)
 private:
  inline void set_has_is_srtp_enable();
  inline void clear_has_is_srtp_enable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TSrtpCrypto > srtp_crypto_param_;
  bool is_srtp_enable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TSrtpParamSetting* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAVCapSrtpParam : public ::google::protobuf::Message {
 public:
  TAVCapSrtpParam();
  virtual ~TAVCapSrtpParam();

  TAVCapSrtpParam(const TAVCapSrtpParam& from);

  inline TAVCapSrtpParam& operator=(const TAVCapSrtpParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAVCapSrtpParam& default_instance();

  void Swap(TAVCapSrtpParam* other);

  // implements Message ----------------------------------------------

  TAVCapSrtpParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAVCapSrtpParam& from);
  void MergeFrom(const TAVCapSrtpParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TSrtpParamSetting vid_srtp_param = 1;
  inline int vid_srtp_param_size() const;
  inline void clear_vid_srtp_param();
  static const int kVidSrtpParamFieldNumber = 1;
  inline const ::mt::TSrtpParamSetting& vid_srtp_param(int index) const;
  inline ::mt::TSrtpParamSetting* mutable_vid_srtp_param(int index);
  inline ::mt::TSrtpParamSetting* add_vid_srtp_param();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TSrtpParamSetting >&
      vid_srtp_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TSrtpParamSetting >*
      mutable_vid_srtp_param();

  // repeated .mt.TSrtpParamSetting aud_srtp_param = 2;
  inline int aud_srtp_param_size() const;
  inline void clear_aud_srtp_param();
  static const int kAudSrtpParamFieldNumber = 2;
  inline const ::mt::TSrtpParamSetting& aud_srtp_param(int index) const;
  inline ::mt::TSrtpParamSetting* mutable_aud_srtp_param(int index);
  inline ::mt::TSrtpParamSetting* add_aud_srtp_param();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TSrtpParamSetting >&
      aud_srtp_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TSrtpParamSetting >*
      mutable_aud_srtp_param();

  // @@protoc_insertion_point(class_scope:mt.TAVCapSrtpParam)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TSrtpParamSetting > vid_srtp_param_;
  ::google::protobuf::RepeatedPtrField< ::mt::TSrtpParamSetting > aud_srtp_param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TAVCapSrtpParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVidChanParam : public ::google::protobuf::Message {
 public:
  TVidChanParam();
  virtual ~TVidChanParam();

  TVidChanParam(const TVidChanParam& from);

  inline TVidChanParam& operator=(const TVidChanParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVidChanParam& default_instance();

  void Swap(TVidChanParam* other);

  // implements Message ----------------------------------------------

  TVidChanParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVidChanParam& from);
  void MergeFrom(const TVidChanParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVidFormat video_format = 1;
  inline bool has_video_format() const;
  inline void clear_video_format();
  static const int kVideoFormatFieldNumber = 1;
  inline ::mt::EmVidFormat video_format() const;
  inline void set_video_format(::mt::EmVidFormat value);

  // optional uint32 payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline ::google::protobuf::uint32 payload() const;
  inline void set_payload(::google::protobuf::uint32 value);

  // optional .mt.TEncryptKey encry_key = 3;
  inline bool has_encry_key() const;
  inline void clear_encry_key();
  static const int kEncryKeyFieldNumber = 3;
  inline const ::mt::TEncryptKey& encry_key() const;
  inline ::mt::TEncryptKey* mutable_encry_key();
  inline ::mt::TEncryptKey* release_encry_key();
  inline void set_allocated_encry_key(::mt::TEncryptKey* encry_key);

  // optional .mt.EmEncryptArithmetic encrypt_arith = 4;
  inline bool has_encrypt_arith() const;
  inline void clear_encrypt_arith();
  static const int kEncryptArithFieldNumber = 4;
  inline ::mt::EmEncryptArithmetic encrypt_arith() const;
  inline void set_encrypt_arith(::mt::EmEncryptArithmetic value);

  // optional .mt.EmMtResolution video_resolution = 5;
  inline bool has_video_resolution() const;
  inline void clear_video_resolution();
  static const int kVideoResolutionFieldNumber = 5;
  inline ::mt::EmMtResolution video_resolution() const;
  inline void set_video_resolution(::mt::EmMtResolution value);

  // optional uint32 frame_rate = 6;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 6;
  inline ::google::protobuf::uint32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::uint32 value);

  // optional uint32 chan_max_bitrate = 7;
  inline bool has_chan_max_bitrate() const;
  inline void clear_chan_max_bitrate();
  static const int kChanMaxBitrateFieldNumber = 7;
  inline ::google::protobuf::uint32 chan_max_bitrate() const;
  inline void set_chan_max_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmH264Profile h264_profile = 8;
  inline bool has_h264_profile() const;
  inline void clear_h264_profile();
  static const int kH264ProfileFieldNumber = 8;
  inline ::mt::EmH264Profile h264_profile() const;
  inline void set_h264_profile(::mt::EmH264Profile value);

  // optional bool h264_svc_enable = 9;
  inline bool has_h264_svc_enable() const;
  inline void clear_h264_svc_enable();
  static const int kH264SvcEnableFieldNumber = 9;
  inline bool h264_svc_enable() const;
  inline void set_h264_svc_enable(bool value);

  // optional bool is_nat_traversal = 10;
  inline bool has_is_nat_traversal() const;
  inline void clear_is_nat_traversal();
  static const int kIsNatTraversalFieldNumber = 10;
  inline bool is_nat_traversal() const;
  inline void set_is_nat_traversal(bool value);

  // optional .mt.EmH265Profile h265_profile = 11;
  inline bool has_h265_profile() const;
  inline void clear_h265_profile();
  static const int kH265ProfileFieldNumber = 11;
  inline ::mt::EmH265Profile h265_profile() const;
  inline void set_h265_profile(::mt::EmH265Profile value);

  // optional bool is_rtcp_fbpli = 12;
  inline bool has_is_rtcp_fbpli() const;
  inline void clear_is_rtcp_fbpli();
  static const int kIsRtcpFbpliFieldNumber = 12;
  inline bool is_rtcp_fbpli() const;
  inline void set_is_rtcp_fbpli(bool value);

  // optional bool is_rtcp_fbfir = 13;
  inline bool has_is_rtcp_fbfir() const;
  inline void clear_is_rtcp_fbfir();
  static const int kIsRtcpFbfirFieldNumber = 13;
  inline bool is_rtcp_fbfir() const;
  inline void set_is_rtcp_fbfir(bool value);

  // optional bool is_rtcp_fbtmmbr = 14;
  inline bool has_is_rtcp_fbtmmbr() const;
  inline void clear_is_rtcp_fbtmmbr();
  static const int kIsRtcpFbtmmbrFieldNumber = 14;
  inline bool is_rtcp_fbtmmbr() const;
  inline void set_is_rtcp_fbtmmbr(bool value);

  // optional bool is_h239 = 20;
  inline bool has_is_h239() const;
  inline void clear_is_h239();
  static const int kIsH239FieldNumber = 20;
  inline bool is_h239() const;
  inline void set_is_h239(bool value);

  // @@protoc_insertion_point(class_scope:mt.TVidChanParam)
 private:
  inline void set_has_video_format();
  inline void clear_has_video_format();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_encry_key();
  inline void clear_has_encry_key();
  inline void set_has_encrypt_arith();
  inline void clear_has_encrypt_arith();
  inline void set_has_video_resolution();
  inline void clear_has_video_resolution();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();
  inline void set_has_chan_max_bitrate();
  inline void clear_has_chan_max_bitrate();
  inline void set_has_h264_profile();
  inline void clear_has_h264_profile();
  inline void set_has_h264_svc_enable();
  inline void clear_has_h264_svc_enable();
  inline void set_has_is_nat_traversal();
  inline void clear_has_is_nat_traversal();
  inline void set_has_h265_profile();
  inline void clear_has_h265_profile();
  inline void set_has_is_rtcp_fbpli();
  inline void clear_has_is_rtcp_fbpli();
  inline void set_has_is_rtcp_fbfir();
  inline void clear_has_is_rtcp_fbfir();
  inline void set_has_is_rtcp_fbtmmbr();
  inline void clear_has_is_rtcp_fbtmmbr();
  inline void set_has_is_h239();
  inline void clear_has_is_h239();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_format_;
  ::google::protobuf::uint32 payload_;
  ::mt::TEncryptKey* encry_key_;
  int encrypt_arith_;
  int video_resolution_;
  ::google::protobuf::uint32 frame_rate_;
  ::google::protobuf::uint32 chan_max_bitrate_;
  int h264_profile_;
  int h265_profile_;
  bool h264_svc_enable_;
  bool is_nat_traversal_;
  bool is_rtcp_fbpli_;
  bool is_rtcp_fbfir_;
  bool is_rtcp_fbtmmbr_;
  bool is_h239_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TVidChanParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpAudChanParam : public ::google::protobuf::Message {
 public:
  TRpAudChanParam();
  virtual ~TRpAudChanParam();

  TRpAudChanParam(const TRpAudChanParam& from);

  inline TRpAudChanParam& operator=(const TRpAudChanParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpAudChanParam& default_instance();

  void Swap(TRpAudChanParam* other);

  // implements Message ----------------------------------------------

  TRpAudChanParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpAudChanParam& from);
  void MergeFrom(const TRpAudChanParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAudChanParam aud_param = 1;
  inline int aud_param_size() const;
  inline void clear_aud_param();
  static const int kAudParamFieldNumber = 1;
  inline const ::mt::TAudChanParam& aud_param(int index) const;
  inline ::mt::TAudChanParam* mutable_aud_param(int index);
  inline ::mt::TAudChanParam* add_aud_param();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudChanParam >&
      aud_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAudChanParam >*
      mutable_aud_param();

  // optional .mt.TSrtpParamSetting srtp_param = 2;
  inline bool has_srtp_param() const;
  inline void clear_srtp_param();
  static const int kSrtpParamFieldNumber = 2;
  inline const ::mt::TSrtpParamSetting& srtp_param() const;
  inline ::mt::TSrtpParamSetting* mutable_srtp_param();
  inline ::mt::TSrtpParamSetting* release_srtp_param();
  inline void set_allocated_srtp_param(::mt::TSrtpParamSetting* srtp_param);

  // @@protoc_insertion_point(class_scope:mt.TRpAudChanParam)
 private:
  inline void set_has_srtp_param();
  inline void clear_has_srtp_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAudChanParam > aud_param_;
  ::mt::TSrtpParamSetting* srtp_param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TRpAudChanParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpVidChanParam : public ::google::protobuf::Message {
 public:
  TRpVidChanParam();
  virtual ~TRpVidChanParam();

  TRpVidChanParam(const TRpVidChanParam& from);

  inline TRpVidChanParam& operator=(const TRpVidChanParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpVidChanParam& default_instance();

  void Swap(TRpVidChanParam* other);

  // implements Message ----------------------------------------------

  TRpVidChanParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpVidChanParam& from);
  void MergeFrom(const TRpVidChanParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVidChanParam vid_param = 1;
  inline int vid_param_size() const;
  inline void clear_vid_param();
  static const int kVidParamFieldNumber = 1;
  inline const ::mt::TVidChanParam& vid_param(int index) const;
  inline ::mt::TVidChanParam* mutable_vid_param(int index);
  inline ::mt::TVidChanParam* add_vid_param();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidChanParam >&
      vid_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVidChanParam >*
      mutable_vid_param();

  // optional .mt.TSrtpParamSetting srtp_param = 2;
  inline bool has_srtp_param() const;
  inline void clear_srtp_param();
  static const int kSrtpParamFieldNumber = 2;
  inline const ::mt::TSrtpParamSetting& srtp_param() const;
  inline ::mt::TSrtpParamSetting* mutable_srtp_param();
  inline ::mt::TSrtpParamSetting* release_srtp_param();
  inline void set_allocated_srtp_param(::mt::TSrtpParamSetting* srtp_param);

  // @@protoc_insertion_point(class_scope:mt.TRpVidChanParam)
 private:
  inline void set_has_srtp_param();
  inline void clear_has_srtp_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVidChanParam > vid_param_;
  ::mt::TSrtpParamSetting* srtp_param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TRpVidChanParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAVChanParam : public ::google::protobuf::Message {
 public:
  TMtAVChanParam();
  virtual ~TMtAVChanParam();

  TMtAVChanParam(const TMtAVChanParam& from);

  inline TMtAVChanParam& operator=(const TMtAVChanParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAVChanParam& default_instance();

  void Swap(TMtAVChanParam* other);

  // implements Message ----------------------------------------------

  TMtAVChanParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAVChanParam& from);
  void MergeFrom(const TMtAVChanParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TRpAudChanParam aud_chan_param = 1;
  inline bool has_aud_chan_param() const;
  inline void clear_aud_chan_param();
  static const int kAudChanParamFieldNumber = 1;
  inline const ::mt::TRpAudChanParam& aud_chan_param() const;
  inline ::mt::TRpAudChanParam* mutable_aud_chan_param();
  inline ::mt::TRpAudChanParam* release_aud_chan_param();
  inline void set_allocated_aud_chan_param(::mt::TRpAudChanParam* aud_chan_param);

  // optional .mt.TRpVidChanParam vid_chan_param = 2;
  inline bool has_vid_chan_param() const;
  inline void clear_vid_chan_param();
  static const int kVidChanParamFieldNumber = 2;
  inline const ::mt::TRpVidChanParam& vid_chan_param() const;
  inline ::mt::TRpVidChanParam* mutable_vid_chan_param();
  inline ::mt::TRpVidChanParam* release_vid_chan_param();
  inline void set_allocated_vid_chan_param(::mt::TRpVidChanParam* vid_chan_param);

  // @@protoc_insertion_point(class_scope:mt.TMtAVChanParam)
 private:
  inline void set_has_aud_chan_param();
  inline void clear_has_aud_chan_param();
  inline void set_has_vid_chan_param();
  inline void clear_has_vid_chan_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TRpAudChanParam* aud_chan_param_;
  ::mt::TRpVidChanParam* vid_chan_param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtAVChanParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtConfBaseInfo : public ::google::protobuf::Message {
 public:
  TMtConfBaseInfo();
  virtual ~TMtConfBaseInfo();

  TMtConfBaseInfo(const TMtConfBaseInfo& from);

  inline TMtConfBaseInfo& operator=(const TMtConfBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtConfBaseInfo& default_instance();

  void Swap(TMtConfBaseInfo* other);

  // implements Message ----------------------------------------------

  TMtConfBaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtConfBaseInfo& from);
  void MergeFrom(const TMtConfBaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string conf_id = 1;
  inline bool has_conf_id() const;
  inline void clear_conf_id();
  static const int kConfIdFieldNumber = 1;
  inline const ::std::string& conf_id() const;
  inline void set_conf_id(const ::std::string& value);
  inline void set_conf_id(const char* value);
  inline void set_conf_id(const char* value, size_t size);
  inline ::std::string* mutable_conf_id();
  inline ::std::string* release_conf_id();
  inline void set_allocated_conf_id(::std::string* conf_id);

  // optional string conf_name = 2;
  inline bool has_conf_name() const;
  inline void clear_conf_name();
  static const int kConfNameFieldNumber = 2;
  inline const ::std::string& conf_name() const;
  inline void set_conf_name(const ::std::string& value);
  inline void set_conf_name(const char* value);
  inline void set_conf_name(const char* value, size_t size);
  inline ::std::string* mutable_conf_name();
  inline ::std::string* release_conf_name();
  inline void set_allocated_conf_name(::std::string* conf_name);

  // optional string conf_number = 3;
  inline bool has_conf_number() const;
  inline void clear_conf_number();
  static const int kConfNumberFieldNumber = 3;
  inline const ::std::string& conf_number() const;
  inline void set_conf_number(const ::std::string& value);
  inline void set_conf_number(const char* value);
  inline void set_conf_number(const char* value, size_t size);
  inline ::std::string* mutable_conf_number();
  inline ::std::string* release_conf_number();
  inline void set_allocated_conf_number(::std::string* conf_number);

  // optional string conf_pwd = 4;
  inline bool has_conf_pwd() const;
  inline void clear_conf_pwd();
  static const int kConfPwdFieldNumber = 4;
  inline const ::std::string& conf_pwd() const;
  inline void set_conf_pwd(const ::std::string& value);
  inline void set_conf_pwd(const char* value);
  inline void set_conf_pwd(const char* value, size_t size);
  inline ::std::string* mutable_conf_pwd();
  inline ::std::string* release_conf_pwd();
  inline void set_allocated_conf_pwd(::std::string* conf_pwd);

  // optional bool bneed_pwd = 5;
  inline bool has_bneed_pwd() const;
  inline void clear_bneed_pwd();
  static const int kBneedPwdFieldNumber = 5;
  inline bool bneed_pwd() const;
  inline void set_bneed_pwd(bool value);

  // optional uint32 conf_duration = 6;
  inline bool has_conf_duration() const;
  inline void clear_conf_duration();
  static const int kConfDurationFieldNumber = 6;
  inline ::google::protobuf::uint32 conf_duration() const;
  inline void set_conf_duration(::google::protobuf::uint32 value);

  // optional .mt.EmEncryptArithmetic encry_type = 7;
  inline bool has_encry_type() const;
  inline void clear_encry_type();
  static const int kEncryTypeFieldNumber = 7;
  inline ::mt::EmEncryptArithmetic encry_type() const;
  inline void set_encry_type(::mt::EmEncryptArithmetic value);

  // optional .mt.EmVidFormat video_format = 8;
  inline bool has_video_format() const;
  inline void clear_video_format();
  static const int kVideoFormatFieldNumber = 8;
  inline ::mt::EmVidFormat video_format() const;
  inline void set_video_format(::mt::EmVidFormat value);

  // optional .mt.EmAudFormat audio_format = 9;
  inline bool has_audio_format() const;
  inline void clear_audio_format();
  static const int kAudioFormatFieldNumber = 9;
  inline ::mt::EmAudFormat audio_format() const;
  inline void set_audio_format(::mt::EmAudFormat value);

  // optional .mt.EmMtResolution resolution = 10;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 10;
  inline ::mt::EmMtResolution resolution() const;
  inline void set_resolution(::mt::EmMtResolution value);

  // optional .mt.EmAacChnlNum chnl_num = 11;
  inline bool has_chnl_num() const;
  inline void clear_chnl_num();
  static const int kChnlNumFieldNumber = 11;
  inline ::mt::EmAacChnlNum chnl_num() const;
  inline void set_chnl_num(::mt::EmAacChnlNum value);

  // optional .mt.EmVidFormat sec_video_format = 12;
  inline bool has_sec_video_format() const;
  inline void clear_sec_video_format();
  static const int kSecVideoFormatFieldNumber = 12;
  inline ::mt::EmVidFormat sec_video_format() const;
  inline void set_sec_video_format(::mt::EmVidFormat value);

  // optional .mt.EmMtResolution sec_vid_res = 13;
  inline bool has_sec_vid_res() const;
  inline void clear_sec_vid_res();
  static const int kSecVidResFieldNumber = 13;
  inline ::mt::EmMtResolution sec_vid_res() const;
  inline void set_sec_vid_res(::mt::EmMtResolution value);

  // optional uint32 sec_vid_fps = 14;
  inline bool has_sec_vid_fps() const;
  inline void clear_sec_vid_fps();
  static const int kSecVidFpsFieldNumber = 14;
  inline ::google::protobuf::uint32 sec_vid_fps() const;
  inline void set_sec_vid_fps(::google::protobuf::uint32 value);

  // optional bool is_auto_vmp = 15;
  inline bool has_is_auto_vmp() const;
  inline void clear_is_auto_vmp();
  static const int kIsAutoVmpFieldNumber = 15;
  inline bool is_auto_vmp() const;
  inline void set_is_auto_vmp(bool value);

  // optional bool is_mix = 16;
  inline bool has_is_mix() const;
  inline void clear_is_mix();
  static const int kIsMixFieldNumber = 16;
  inline bool is_mix() const;
  inline void set_is_mix(bool value);

  // optional .mt.EmH264Profile vid_h264Profile = 17;
  inline bool has_vid_h264profile() const;
  inline void clear_vid_h264profile();
  static const int kVidH264ProfileFieldNumber = 17;
  inline ::mt::EmH264Profile vid_h264profile() const;
  inline void set_vid_h264profile(::mt::EmH264Profile value);

  // optional uint32 conf_bitrate = 18;
  inline bool has_conf_bitrate() const;
  inline void clear_conf_bitrate();
  static const int kConfBitrateFieldNumber = 18;
  inline ::google::protobuf::uint32 conf_bitrate() const;
  inline void set_conf_bitrate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtConfBaseInfo)
 private:
  inline void set_has_conf_id();
  inline void clear_has_conf_id();
  inline void set_has_conf_name();
  inline void clear_has_conf_name();
  inline void set_has_conf_number();
  inline void clear_has_conf_number();
  inline void set_has_conf_pwd();
  inline void clear_has_conf_pwd();
  inline void set_has_bneed_pwd();
  inline void clear_has_bneed_pwd();
  inline void set_has_conf_duration();
  inline void clear_has_conf_duration();
  inline void set_has_encry_type();
  inline void clear_has_encry_type();
  inline void set_has_video_format();
  inline void clear_has_video_format();
  inline void set_has_audio_format();
  inline void clear_has_audio_format();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_chnl_num();
  inline void clear_has_chnl_num();
  inline void set_has_sec_video_format();
  inline void clear_has_sec_video_format();
  inline void set_has_sec_vid_res();
  inline void clear_has_sec_vid_res();
  inline void set_has_sec_vid_fps();
  inline void clear_has_sec_vid_fps();
  inline void set_has_is_auto_vmp();
  inline void clear_has_is_auto_vmp();
  inline void set_has_is_mix();
  inline void clear_has_is_mix();
  inline void set_has_vid_h264profile();
  inline void clear_has_vid_h264profile();
  inline void set_has_conf_bitrate();
  inline void clear_has_conf_bitrate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* conf_id_;
  ::std::string* conf_name_;
  ::std::string* conf_number_;
  ::std::string* conf_pwd_;
  ::google::protobuf::uint32 conf_duration_;
  int encry_type_;
  int video_format_;
  int audio_format_;
  int resolution_;
  int chnl_num_;
  int sec_video_format_;
  bool bneed_pwd_;
  bool is_auto_vmp_;
  bool is_mix_;
  int sec_vid_res_;
  ::google::protobuf::uint32 sec_vid_fps_;
  int vid_h264profile_;
  ::google::protobuf::uint32 conf_bitrate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtConfBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtConfList : public ::google::protobuf::Message {
 public:
  TRpMtConfList();
  virtual ~TRpMtConfList();

  TRpMtConfList(const TRpMtConfList& from);

  inline TRpMtConfList& operator=(const TRpMtConfList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtConfList& default_instance();

  void Swap(TRpMtConfList* other);

  // implements Message ----------------------------------------------

  TRpMtConfList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtConfList& from);
  void MergeFrom(const TRpMtConfList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtConfBaseInfo conf_info = 1;
  inline int conf_info_size() const;
  inline void clear_conf_info();
  static const int kConfInfoFieldNumber = 1;
  inline const ::mt::TMtConfBaseInfo& conf_info(int index) const;
  inline ::mt::TMtConfBaseInfo* mutable_conf_info(int index);
  inline ::mt::TMtConfBaseInfo* add_conf_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtConfBaseInfo >&
      conf_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtConfBaseInfo >*
      mutable_conf_info();

  // @@protoc_insertion_point(class_scope:mt.TRpMtConfList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtConfBaseInfo > conf_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TRpMtConfList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtConfNameInfo : public ::google::protobuf::Message {
 public:
  TMtConfNameInfo();
  virtual ~TMtConfNameInfo();

  TMtConfNameInfo(const TMtConfNameInfo& from);

  inline TMtConfNameInfo& operator=(const TMtConfNameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtConfNameInfo& default_instance();

  void Swap(TMtConfNameInfo* other);

  // implements Message ----------------------------------------------

  TMtConfNameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtConfNameInfo& from);
  void MergeFrom(const TMtConfNameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string conf_name = 1;
  inline bool has_conf_name() const;
  inline void clear_conf_name();
  static const int kConfNameFieldNumber = 1;
  inline const ::std::string& conf_name() const;
  inline void set_conf_name(const ::std::string& value);
  inline void set_conf_name(const char* value);
  inline void set_conf_name(const char* value, size_t size);
  inline ::std::string* mutable_conf_name();
  inline ::std::string* release_conf_name();
  inline void set_allocated_conf_name(::std::string* conf_name);

  // optional string conf_e164 = 2;
  inline bool has_conf_e164() const;
  inline void clear_conf_e164();
  static const int kConfE164FieldNumber = 2;
  inline const ::std::string& conf_e164() const;
  inline void set_conf_e164(const ::std::string& value);
  inline void set_conf_e164(const char* value);
  inline void set_conf_e164(const char* value, size_t size);
  inline ::std::string* mutable_conf_e164();
  inline ::std::string* release_conf_e164();
  inline void set_allocated_conf_e164(::std::string* conf_e164);

  // optional uint32 terlist_num = 3;
  inline bool has_terlist_num() const;
  inline void clear_terlist_num();
  static const int kTerlistNumFieldNumber = 3;
  inline ::google::protobuf::uint32 terlist_num() const;
  inline void set_terlist_num(::google::protobuf::uint32 value);

  // optional uint32 remain_time = 4;
  inline bool has_remain_time() const;
  inline void clear_remain_time();
  static const int kRemainTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 remain_time() const;
  inline void set_remain_time(::google::protobuf::uint32 value);

  // optional .mt.EmMtOpenMode open_mode = 5;
  inline bool has_open_mode() const;
  inline void clear_open_mode();
  static const int kOpenModeFieldNumber = 5;
  inline ::mt::EmMtOpenMode open_mode() const;
  inline void set_open_mode(::mt::EmMtOpenMode value);

  // optional .mt.EmMtClarity clarity_mode = 6;
  inline bool has_clarity_mode() const;
  inline void clear_clarity_mode();
  static const int kClarityModeFieldNumber = 6;
  inline ::mt::EmMtClarity clarity_mode() const;
  inline void set_clarity_mode(::mt::EmMtClarity value);

  // optional .mt.TMTTime conf_start_time = 7;
  inline bool has_conf_start_time() const;
  inline void clear_conf_start_time();
  static const int kConfStartTimeFieldNumber = 7;
  inline const ::mt::TMTTime& conf_start_time() const;
  inline ::mt::TMTTime* mutable_conf_start_time();
  inline ::mt::TMTTime* release_conf_start_time();
  inline void set_allocated_conf_start_time(::mt::TMTTime* conf_start_time);

  // optional bool is_satdcast_mode = 8;
  inline bool has_is_satdcast_mode() const;
  inline void clear_is_satdcast_mode();
  static const int kIsSatdcastModeFieldNumber = 8;
  inline bool is_satdcast_mode() const;
  inline void set_is_satdcast_mode(bool value);

  // optional bool is_public_conf = 9;
  inline bool has_is_public_conf() const;
  inline void clear_is_public_conf();
  static const int kIsPublicConfFieldNumber = 9;
  inline bool is_public_conf() const;
  inline void set_is_public_conf(bool value);

  // optional bool is_need_pwd = 10;
  inline bool has_is_need_pwd() const;
  inline void clear_is_need_pwd();
  static const int kIsNeedPwdFieldNumber = 10;
  inline bool is_need_pwd() const;
  inline void set_is_need_pwd(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtConfNameInfo)
 private:
  inline void set_has_conf_name();
  inline void clear_has_conf_name();
  inline void set_has_conf_e164();
  inline void clear_has_conf_e164();
  inline void set_has_terlist_num();
  inline void clear_has_terlist_num();
  inline void set_has_remain_time();
  inline void clear_has_remain_time();
  inline void set_has_open_mode();
  inline void clear_has_open_mode();
  inline void set_has_clarity_mode();
  inline void clear_has_clarity_mode();
  inline void set_has_conf_start_time();
  inline void clear_has_conf_start_time();
  inline void set_has_is_satdcast_mode();
  inline void clear_has_is_satdcast_mode();
  inline void set_has_is_public_conf();
  inline void clear_has_is_public_conf();
  inline void set_has_is_need_pwd();
  inline void clear_has_is_need_pwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* conf_name_;
  ::std::string* conf_e164_;
  ::google::protobuf::uint32 terlist_num_;
  ::google::protobuf::uint32 remain_time_;
  int open_mode_;
  int clarity_mode_;
  ::mt::TMTTime* conf_start_time_;
  bool is_satdcast_mode_;
  bool is_public_conf_;
  bool is_need_pwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtConfNameInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtConfNameInfo : public ::google::protobuf::Message {
 public:
  TRpMtConfNameInfo();
  virtual ~TRpMtConfNameInfo();

  TRpMtConfNameInfo(const TRpMtConfNameInfo& from);

  inline TRpMtConfNameInfo& operator=(const TRpMtConfNameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtConfNameInfo& default_instance();

  void Swap(TRpMtConfNameInfo* other);

  // implements Message ----------------------------------------------

  TRpMtConfNameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtConfNameInfo& from);
  void MergeFrom(const TRpMtConfNameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtConfNameInfo conf_name_info = 1;
  inline int conf_name_info_size() const;
  inline void clear_conf_name_info();
  static const int kConfNameInfoFieldNumber = 1;
  inline const ::mt::TMtConfNameInfo& conf_name_info(int index) const;
  inline ::mt::TMtConfNameInfo* mutable_conf_name_info(int index);
  inline ::mt::TMtConfNameInfo* add_conf_name_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtConfNameInfo >&
      conf_name_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtConfNameInfo >*
      mutable_conf_name_info();

  // @@protoc_insertion_point(class_scope:mt.TRpMtConfNameInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtConfNameInfo > conf_name_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TRpMtConfNameInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtNewConfBaseInfo : public ::google::protobuf::Message {
 public:
  TMtNewConfBaseInfo();
  virtual ~TMtNewConfBaseInfo();

  TMtNewConfBaseInfo(const TMtNewConfBaseInfo& from);

  inline TMtNewConfBaseInfo& operator=(const TMtNewConfBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtNewConfBaseInfo& default_instance();

  void Swap(TMtNewConfBaseInfo* other);

  // implements Message ----------------------------------------------

  TMtNewConfBaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtNewConfBaseInfo& from);
  void MergeFrom(const TMtNewConfBaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string conf_name = 1;
  inline bool has_conf_name() const;
  inline void clear_conf_name();
  static const int kConfNameFieldNumber = 1;
  inline const ::std::string& conf_name() const;
  inline void set_conf_name(const ::std::string& value);
  inline void set_conf_name(const char* value);
  inline void set_conf_name(const char* value, size_t size);
  inline ::std::string* mutable_conf_name();
  inline ::std::string* release_conf_name();
  inline void set_allocated_conf_name(::std::string* conf_name);

  // optional string conf_e164 = 2;
  inline bool has_conf_e164() const;
  inline void clear_conf_e164();
  static const int kConfE164FieldNumber = 2;
  inline const ::std::string& conf_e164() const;
  inline void set_conf_e164(const ::std::string& value);
  inline void set_conf_e164(const char* value);
  inline void set_conf_e164(const char* value, size_t size);
  inline ::std::string* mutable_conf_e164();
  inline ::std::string* release_conf_e164();
  inline void set_allocated_conf_e164(::std::string* conf_e164);

  // optional string domain_guid = 3;
  inline bool has_domain_guid() const;
  inline void clear_domain_guid();
  static const int kDomainGuidFieldNumber = 3;
  inline const ::std::string& domain_guid() const;
  inline void set_domain_guid(const ::std::string& value);
  inline void set_domain_guid(const char* value);
  inline void set_domain_guid(const char* value, size_t size);
  inline ::std::string* mutable_domain_guid();
  inline ::std::string* release_domain_guid();
  inline void set_allocated_domain_guid(::std::string* domain_guid);

  // optional string domain_name = 4;
  inline bool has_domain_name() const;
  inline void clear_domain_name();
  static const int kDomainNameFieldNumber = 4;
  inline const ::std::string& domain_name() const;
  inline void set_domain_name(const ::std::string& value);
  inline void set_domain_name(const char* value);
  inline void set_domain_name(const char* value, size_t size);
  inline ::std::string* mutable_domain_name();
  inline ::std::string* release_domain_name();
  inline void set_allocated_domain_name(::std::string* domain_name);

  // optional string domain_moid = 5;
  inline bool has_domain_moid() const;
  inline void clear_domain_moid();
  static const int kDomainMoidFieldNumber = 5;
  inline const ::std::string& domain_moid() const;
  inline void set_domain_moid(const ::std::string& value);
  inline void set_domain_moid(const char* value);
  inline void set_domain_moid(const char* value, size_t size);
  inline ::std::string* mutable_domain_moid();
  inline ::std::string* release_domain_moid();
  inline void set_allocated_domain_moid(::std::string* domain_moid);

  // @@protoc_insertion_point(class_scope:mt.TMtNewConfBaseInfo)
 private:
  inline void set_has_conf_name();
  inline void clear_has_conf_name();
  inline void set_has_conf_e164();
  inline void clear_has_conf_e164();
  inline void set_has_domain_guid();
  inline void clear_has_domain_guid();
  inline void set_has_domain_name();
  inline void clear_has_domain_name();
  inline void set_has_domain_moid();
  inline void clear_has_domain_moid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* conf_name_;
  ::std::string* conf_e164_;
  ::std::string* domain_guid_;
  ::std::string* domain_name_;
  ::std::string* domain_moid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtNewConfBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtConfDetailInfo : public ::google::protobuf::Message {
 public:
  TMtConfDetailInfo();
  virtual ~TMtConfDetailInfo();

  TMtConfDetailInfo(const TMtConfDetailInfo& from);

  inline TMtConfDetailInfo& operator=(const TMtConfDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtConfDetailInfo& default_instance();

  void Swap(TMtConfDetailInfo* other);

  // implements Message ----------------------------------------------

  TMtConfDetailInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtConfDetailInfo& from);
  void MergeFrom(const TMtConfDetailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMtNewConfBaseInfo new_conf_base_info = 1;
  inline bool has_new_conf_base_info() const;
  inline void clear_new_conf_base_info();
  static const int kNewConfBaseInfoFieldNumber = 1;
  inline const ::mt::TMtNewConfBaseInfo& new_conf_base_info() const;
  inline ::mt::TMtNewConfBaseInfo* mutable_new_conf_base_info();
  inline ::mt::TMtNewConfBaseInfo* release_new_conf_base_info();
  inline void set_allocated_new_conf_base_info(::mt::TMtNewConfBaseInfo* new_conf_base_info);

  // optional uint32 conf_style = 2;
  inline bool has_conf_style() const;
  inline void clear_conf_style();
  static const int kConfStyleFieldNumber = 2;
  inline ::google::protobuf::uint32 conf_style() const;
  inline void set_conf_style(::google::protobuf::uint32 value);

  // optional string short_num = 3;
  inline bool has_short_num() const;
  inline void clear_short_num();
  static const int kShortNumFieldNumber = 3;
  inline const ::std::string& short_num() const;
  inline void set_short_num(const ::std::string& value);
  inline void set_short_num(const char* value);
  inline void set_short_num(const char* value, size_t size);
  inline ::std::string* mutable_short_num();
  inline ::std::string* release_short_num();
  inline void set_allocated_short_num(::std::string* short_num);

  // optional .mt.EmEncryptArithmetic encrypt_mode = 4;
  inline bool has_encrypt_mode() const;
  inline void clear_encrypt_mode();
  static const int kEncryptModeFieldNumber = 4;
  inline ::mt::EmEncryptArithmetic encrypt_mode() const;
  inline void set_encrypt_mode(::mt::EmEncryptArithmetic value);

  // optional uint32 bitrate = 5;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 5;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmMtClarity clarity_mode = 6;
  inline bool has_clarity_mode() const;
  inline void clear_clarity_mode();
  static const int kClarityModeFieldNumber = 6;
  inline ::mt::EmMtClarity clarity_mode() const;
  inline void set_clarity_mode(::mt::EmMtClarity value);

  // optional .mt.EmMtResolution vid_res = 7;
  inline bool has_vid_res() const;
  inline void clear_vid_res();
  static const int kVidResFieldNumber = 7;
  inline ::mt::EmMtResolution vid_res() const;
  inline void set_vid_res(::mt::EmMtResolution value);

  // optional .mt.EmMtOpenMode open_mode = 8;
  inline bool has_open_mode() const;
  inline void clear_open_mode();
  static const int kOpenModeFieldNumber = 8;
  inline ::mt::EmMtOpenMode open_mode() const;
  inline void set_open_mode(::mt::EmMtOpenMode value);

  // optional bool is_discuss_conf = 9;
  inline bool has_is_discuss_conf() const;
  inline void clear_is_discuss_conf();
  static const int kIsDiscussConfFieldNumber = 9;
  inline bool is_discuss_conf() const;
  inline void set_is_discuss_conf(bool value);

  // optional .mt.TMTTime start_time = 10;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 10;
  inline const ::mt::TMTTime& start_time() const;
  inline ::mt::TMTTime* mutable_start_time();
  inline ::mt::TMTTime* release_start_time();
  inline void set_allocated_start_time(::mt::TMTTime* start_time);

  // optional uint32 duration = 11;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 11;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional string alias = 12;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 12;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // optional .mt.EmMtDualMode dual_mode = 13;
  inline bool has_dual_mode() const;
  inline void clear_dual_mode();
  static const int kDualModeFieldNumber = 13;
  inline ::mt::EmMtDualMode dual_mode() const;
  inline void set_dual_mode(::mt::EmMtDualMode value);

  // optional bool is_satdcast_mode = 14;
  inline bool has_is_satdcast_mode() const;
  inline void clear_is_satdcast_mode();
  static const int kIsSatdcastModeFieldNumber = 14;
  inline bool is_satdcast_mode() const;
  inline void set_is_satdcast_mode(bool value);

  // optional bool is_public_conf = 15;
  inline bool has_is_public_conf() const;
  inline void clear_is_public_conf();
  static const int kIsPublicConfFieldNumber = 15;
  inline bool is_public_conf() const;
  inline void set_is_public_conf(bool value);

  // optional bool is_port_mode = 16;
  inline bool has_is_port_mode() const;
  inline void clear_is_port_mode();
  static const int kIsPortModeFieldNumber = 16;
  inline bool is_port_mode() const;
  inline void set_is_port_mode(bool value);

  // optional bool is_conf_no_disturb = 17;
  inline bool has_is_conf_no_disturb() const;
  inline void clear_is_conf_no_disturb();
  static const int kIsConfNoDisturbFieldNumber = 17;
  inline bool is_conf_no_disturb() const;
  inline void set_is_conf_no_disturb(bool value);

  // optional bool is_need_pwd = 18;
  inline bool has_is_need_pwd() const;
  inline void clear_is_need_pwd();
  static const int kIsNeedPwdFieldNumber = 18;
  inline bool is_need_pwd() const;
  inline void set_is_need_pwd(bool value);

  // optional uint32 max_joined_mt = 19;
  inline bool has_max_joined_mt() const;
  inline void clear_max_joined_mt();
  static const int kMaxJoinedMtFieldNumber = 19;
  inline ::google::protobuf::uint32 max_joined_mt() const;
  inline void set_max_joined_mt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtConfDetailInfo)
 private:
  inline void set_has_new_conf_base_info();
  inline void clear_has_new_conf_base_info();
  inline void set_has_conf_style();
  inline void clear_has_conf_style();
  inline void set_has_short_num();
  inline void clear_has_short_num();
  inline void set_has_encrypt_mode();
  inline void clear_has_encrypt_mode();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_clarity_mode();
  inline void clear_has_clarity_mode();
  inline void set_has_vid_res();
  inline void clear_has_vid_res();
  inline void set_has_open_mode();
  inline void clear_has_open_mode();
  inline void set_has_is_discuss_conf();
  inline void clear_has_is_discuss_conf();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_dual_mode();
  inline void clear_has_dual_mode();
  inline void set_has_is_satdcast_mode();
  inline void clear_has_is_satdcast_mode();
  inline void set_has_is_public_conf();
  inline void clear_has_is_public_conf();
  inline void set_has_is_port_mode();
  inline void clear_has_is_port_mode();
  inline void set_has_is_conf_no_disturb();
  inline void clear_has_is_conf_no_disturb();
  inline void set_has_is_need_pwd();
  inline void clear_has_is_need_pwd();
  inline void set_has_max_joined_mt();
  inline void clear_has_max_joined_mt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMtNewConfBaseInfo* new_conf_base_info_;
  ::std::string* short_num_;
  ::google::protobuf::uint32 conf_style_;
  int encrypt_mode_;
  ::google::protobuf::uint32 bitrate_;
  int clarity_mode_;
  int vid_res_;
  int open_mode_;
  ::mt::TMTTime* start_time_;
  ::std::string* alias_;
  ::google::protobuf::uint32 duration_;
  int dual_mode_;
  bool is_discuss_conf_;
  bool is_satdcast_mode_;
  bool is_public_conf_;
  bool is_port_mode_;
  bool is_conf_no_disturb_;
  bool is_need_pwd_;
  ::google::protobuf::uint32 max_joined_mt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtConfDetailInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtJoinConfParam : public ::google::protobuf::Message {
 public:
  TMtJoinConfParam();
  virtual ~TMtJoinConfParam();

  TMtJoinConfParam(const TMtJoinConfParam& from);

  inline TMtJoinConfParam& operator=(const TMtJoinConfParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtJoinConfParam& default_instance();

  void Swap(TMtJoinConfParam* other);

  // implements Message ----------------------------------------------

  TMtJoinConfParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtJoinConfParam& from);
  void MergeFrom(const TMtJoinConfParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 call_rate = 1;
  inline bool has_call_rate() const;
  inline void clear_call_rate();
  static const int kCallRateFieldNumber = 1;
  inline ::google::protobuf::uint32 call_rate() const;
  inline void set_call_rate(::google::protobuf::uint32 value);

  // optional string conf_e164 = 2;
  inline bool has_conf_e164() const;
  inline void clear_conf_e164();
  static const int kConfE164FieldNumber = 2;
  inline const ::std::string& conf_e164() const;
  inline void set_conf_e164(const ::std::string& value);
  inline void set_conf_e164(const char* value);
  inline void set_conf_e164(const char* value, size_t size);
  inline ::std::string* mutable_conf_e164();
  inline ::std::string* release_conf_e164();
  inline void set_allocated_conf_e164(::std::string* conf_e164);

  // optional string conf_pwd = 3;
  inline bool has_conf_pwd() const;
  inline void clear_conf_pwd();
  static const int kConfPwdFieldNumber = 3;
  inline const ::std::string& conf_pwd() const;
  inline void set_conf_pwd(const ::std::string& value);
  inline void set_conf_pwd(const char* value);
  inline void set_conf_pwd(const char* value, size_t size);
  inline ::std::string* mutable_conf_pwd();
  inline ::std::string* release_conf_pwd();
  inline void set_allocated_conf_pwd(::std::string* conf_pwd);

  // optional bool is_dial = 4;
  inline bool has_is_dial() const;
  inline void clear_is_dial();
  static const int kIsDialFieldNumber = 4;
  inline bool is_dial() const;
  inline void set_is_dial(bool value);

  // optional string dial_num = 5;
  inline bool has_dial_num() const;
  inline void clear_dial_num();
  static const int kDialNumFieldNumber = 5;
  inline const ::std::string& dial_num() const;
  inline void set_dial_num(const ::std::string& value);
  inline void set_dial_num(const char* value);
  inline void set_dial_num(const char* value, size_t size);
  inline ::std::string* mutable_dial_num();
  inline ::std::string* release_dial_num();
  inline void set_allocated_dial_num(::std::string* dial_num);

  // optional string conf_name = 6;
  inline bool has_conf_name() const;
  inline void clear_conf_name();
  static const int kConfNameFieldNumber = 6;
  inline const ::std::string& conf_name() const;
  inline void set_conf_name(const ::std::string& value);
  inline void set_conf_name(const char* value);
  inline void set_conf_name(const char* value, size_t size);
  inline ::std::string* mutable_conf_name();
  inline ::std::string* release_conf_name();
  inline void set_allocated_conf_name(::std::string* conf_name);

  // optional string conf_name_ai = 7;
  inline bool has_conf_name_ai() const;
  inline void clear_conf_name_ai();
  static const int kConfNameAiFieldNumber = 7;
  inline const ::std::string& conf_name_ai() const;
  inline void set_conf_name_ai(const ::std::string& value);
  inline void set_conf_name_ai(const char* value);
  inline void set_conf_name_ai(const char* value, size_t size);
  inline ::std::string* mutable_conf_name_ai();
  inline ::std::string* release_conf_name_ai();
  inline void set_allocated_conf_name_ai(::std::string* conf_name_ai);

  // @@protoc_insertion_point(class_scope:mt.TMtJoinConfParam)
 private:
  inline void set_has_call_rate();
  inline void clear_has_call_rate();
  inline void set_has_conf_e164();
  inline void clear_has_conf_e164();
  inline void set_has_conf_pwd();
  inline void clear_has_conf_pwd();
  inline void set_has_is_dial();
  inline void clear_has_is_dial();
  inline void set_has_dial_num();
  inline void clear_has_dial_num();
  inline void set_has_conf_name();
  inline void clear_has_conf_name();
  inline void set_has_conf_name_ai();
  inline void clear_has_conf_name_ai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* conf_e164_;
  ::google::protobuf::uint32 call_rate_;
  bool is_dial_;
  ::std::string* conf_pwd_;
  ::std::string* dial_num_;
  ::std::string* conf_name_;
  ::std::string* conf_name_ai_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtJoinConfParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtJoinConfParamList : public ::google::protobuf::Message {
 public:
  TMtJoinConfParamList();
  virtual ~TMtJoinConfParamList();

  TMtJoinConfParamList(const TMtJoinConfParamList& from);

  inline TMtJoinConfParamList& operator=(const TMtJoinConfParamList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtJoinConfParamList& default_instance();

  void Swap(TMtJoinConfParamList* other);

  // implements Message ----------------------------------------------

  TMtJoinConfParamList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtJoinConfParamList& from);
  void MergeFrom(const TMtJoinConfParamList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtJoinConfParam list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::mt::TMtJoinConfParam& list(int index) const;
  inline ::mt::TMtJoinConfParam* mutable_list(int index);
  inline ::mt::TMtJoinConfParam* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtJoinConfParam >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtJoinConfParam >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:mt.TMtJoinConfParamList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtJoinConfParam > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtJoinConfParamList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtCreateConfParam : public ::google::protobuf::Message {
 public:
  TMtCreateConfParam();
  virtual ~TMtCreateConfParam();

  TMtCreateConfParam(const TMtCreateConfParam& from);

  inline TMtCreateConfParam& operator=(const TMtCreateConfParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtCreateConfParam& default_instance();

  void Swap(TMtCreateConfParam* other);

  // implements Message ----------------------------------------------

  TMtCreateConfParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtCreateConfParam& from);
  void MergeFrom(const TMtCreateConfParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string conf_pwd = 1;
  inline bool has_conf_pwd() const;
  inline void clear_conf_pwd();
  static const int kConfPwdFieldNumber = 1;
  inline const ::std::string& conf_pwd() const;
  inline void set_conf_pwd(const ::std::string& value);
  inline void set_conf_pwd(const char* value);
  inline void set_conf_pwd(const char* value, size_t size);
  inline ::std::string* mutable_conf_pwd();
  inline ::std::string* release_conf_pwd();
  inline void set_allocated_conf_pwd(::std::string* conf_pwd);

  // optional string conf_name = 2;
  inline bool has_conf_name() const;
  inline void clear_conf_name();
  static const int kConfNameFieldNumber = 2;
  inline const ::std::string& conf_name() const;
  inline void set_conf_name(const ::std::string& value);
  inline void set_conf_name(const char* value);
  inline void set_conf_name(const char* value, size_t size);
  inline ::std::string* mutable_conf_name();
  inline ::std::string* release_conf_name();
  inline void set_allocated_conf_name(::std::string* conf_name);

  // optional uint32 conf_duration = 3;
  inline bool has_conf_duration() const;
  inline void clear_conf_duration();
  static const int kConfDurationFieldNumber = 3;
  inline ::google::protobuf::uint32 conf_duration() const;
  inline void set_conf_duration(::google::protobuf::uint32 value);

  // optional uint32 conf_bitrate = 4;
  inline bool has_conf_bitrate() const;
  inline void clear_conf_bitrate();
  static const int kConfBitrateFieldNumber = 4;
  inline ::google::protobuf::uint32 conf_bitrate() const;
  inline void set_conf_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmMtOpenMode open_mode = 5;
  inline bool has_open_mode() const;
  inline void clear_open_mode();
  static const int kOpenModeFieldNumber = 5;
  inline ::mt::EmMtOpenMode open_mode() const;
  inline void set_open_mode(::mt::EmMtOpenMode value);

  // optional .mt.EmMtConfReleaseModeDef release_mode = 6;
  inline bool has_release_mode() const;
  inline void clear_release_mode();
  static const int kReleaseModeFieldNumber = 6;
  inline ::mt::EmMtConfReleaseModeDef release_mode() const;
  inline void set_release_mode(::mt::EmMtConfReleaseModeDef value);

  // optional bool is_all_init_dumb = 7;
  inline bool has_is_all_init_dumb() const;
  inline void clear_is_all_init_dumb();
  static const int kIsAllInitDumbFieldNumber = 7;
  inline bool is_all_init_dumb() const;
  inline void set_is_all_init_dumb(bool value);

  // optional .mt.EmEncryptArithmetic conf_encrypt = 8;
  inline bool has_conf_encrypt() const;
  inline void clear_conf_encrypt();
  static const int kConfEncryptFieldNumber = 8;
  inline ::mt::EmEncryptArithmetic conf_encrypt() const;
  inline void set_conf_encrypt(::mt::EmEncryptArithmetic value);

  // optional bytes enckey = 9;
  inline bool has_enckey() const;
  inline void clear_enckey();
  static const int kEnckeyFieldNumber = 9;
  inline const ::std::string& enckey() const;
  inline void set_enckey(const ::std::string& value);
  inline void set_enckey(const char* value);
  inline void set_enckey(const void* value, size_t size);
  inline ::std::string* mutable_enckey();
  inline ::std::string* release_enckey();
  inline void set_allocated_enckey(::std::string* enckey);

  // optional bool is_satdcast_mode = 10;
  inline bool has_is_satdcast_mode() const;
  inline void clear_is_satdcast_mode();
  static const int kIsSatdcastModeFieldNumber = 10;
  inline bool is_satdcast_mode() const;
  inline void set_is_satdcast_mode(bool value);

  // optional uint32 max_bitrate_for_opus = 11;
  inline bool has_max_bitrate_for_opus() const;
  inline void clear_max_bitrate_for_opus();
  static const int kMaxBitrateForOpusFieldNumber = 11;
  inline ::google::protobuf::uint32 max_bitrate_for_opus() const;
  inline void set_max_bitrate_for_opus(::google::protobuf::uint32 value);

  // optional uint32 min_bitrate_for_opus = 12;
  inline bool has_min_bitrate_for_opus() const;
  inline void clear_min_bitrate_for_opus();
  static const int kMinBitrateForOpusFieldNumber = 12;
  inline ::google::protobuf::uint32 min_bitrate_for_opus() const;
  inline void set_min_bitrate_for_opus(::google::protobuf::uint32 value);

  // optional bool is_public_conf = 13;
  inline bool has_is_public_conf() const;
  inline void clear_is_public_conf();
  static const int kIsPublicConfFieldNumber = 13;
  inline bool is_public_conf() const;
  inline void set_is_public_conf(bool value);

  // optional bool is_port_mode = 14;
  inline bool has_is_port_mode() const;
  inline void clear_is_port_mode();
  static const int kIsPortModeFieldNumber = 14;
  inline bool is_port_mode() const;
  inline void set_is_port_mode(bool value);

  // optional bool is_conf_nodisturb = 15;
  inline bool has_is_conf_nodisturb() const;
  inline void clear_is_conf_nodisturb();
  static const int kIsConfNodisturbFieldNumber = 15;
  inline bool is_conf_nodisturb() const;
  inline void set_is_conf_nodisturb(bool value);

  // optional .mt.EmVidFormat vid_format = 16;
  inline bool has_vid_format() const;
  inline void clear_vid_format();
  static const int kVidFormatFieldNumber = 16;
  inline ::mt::EmVidFormat vid_format() const;
  inline void set_vid_format(::mt::EmVidFormat value);

  // optional .mt.EmH264Profile h264_profile = 17;
  inline bool has_h264_profile() const;
  inline void clear_h264_profile();
  static const int kH264ProfileFieldNumber = 17;
  inline ::mt::EmH264Profile h264_profile() const;
  inline void set_h264_profile(::mt::EmH264Profile value);

  // optional .mt.EmMtResolution vid_res = 18;
  inline bool has_vid_res() const;
  inline void clear_vid_res();
  static const int kVidResFieldNumber = 18;
  inline ::mt::EmMtResolution vid_res() const;
  inline void set_vid_res(::mt::EmMtResolution value);

  // optional uint32 vid_fps = 19;
  inline bool has_vid_fps() const;
  inline void clear_vid_fps();
  static const int kVidFpsFieldNumber = 19;
  inline ::google::protobuf::uint32 vid_fps() const;
  inline void set_vid_fps(::google::protobuf::uint32 value);

  // optional .mt.EmVidFormat assvid_format = 20;
  inline bool has_assvid_format() const;
  inline void clear_assvid_format();
  static const int kAssvidFormatFieldNumber = 20;
  inline ::mt::EmVidFormat assvid_format() const;
  inline void set_assvid_format(::mt::EmVidFormat value);

  // optional .mt.EmMtResolution assvid_res = 21;
  inline bool has_assvid_res() const;
  inline void clear_assvid_res();
  static const int kAssvidResFieldNumber = 21;
  inline ::mt::EmMtResolution assvid_res() const;
  inline void set_assvid_res(::mt::EmMtResolution value);

  // optional uint32 assvid_fps = 22;
  inline bool has_assvid_fps() const;
  inline void clear_assvid_fps();
  static const int kAssvidFpsFieldNumber = 22;
  inline ::google::protobuf::uint32 assvid_fps() const;
  inline void set_assvid_fps(::google::protobuf::uint32 value);

  // optional .mt.EmAudFormat aud_format = 23;
  inline bool has_aud_format() const;
  inline void clear_aud_format();
  static const int kAudFormatFieldNumber = 23;
  inline ::mt::EmAudFormat aud_format() const;
  inline void set_aud_format(::mt::EmAudFormat value);

  // optional .mt.EmAacChnlNum chnl_num = 24;
  inline bool has_chnl_num() const;
  inline void clear_chnl_num();
  static const int kChnlNumFieldNumber = 24;
  inline ::mt::EmAacChnlNum chnl_num() const;
  inline void set_chnl_num(::mt::EmAacChnlNum value);

  // optional .mt.TMtAddr speaker = 25;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 25;
  inline const ::mt::TMtAddr& speaker() const;
  inline ::mt::TMtAddr* mutable_speaker();
  inline ::mt::TMtAddr* release_speaker();
  inline void set_allocated_speaker(::mt::TMtAddr* speaker);

  // optional uint32 calltimes = 26;
  inline bool has_calltimes() const;
  inline void clear_calltimes();
  static const int kCalltimesFieldNumber = 26;
  inline ::google::protobuf::uint32 calltimes() const;
  inline void set_calltimes(::google::protobuf::uint32 value);

  // optional uint32 callinterval = 27;
  inline bool has_callinterval() const;
  inline void clear_callinterval();
  static const int kCallintervalFieldNumber = 27;
  inline ::google::protobuf::uint32 callinterval() const;
  inline void set_callinterval(::google::protobuf::uint32 value);

  // optional bool is_callChase = 28;
  inline bool has_is_callchase() const;
  inline void clear_is_callchase();
  static const int kIsCallChaseFieldNumber = 28;
  inline bool is_callchase() const;
  inline void set_is_callchase(bool value);

  // optional .mt.EmRestVideoQuality video_quality = 29;
  inline bool has_video_quality() const;
  inline void clear_video_quality();
  static const int kVideoQualityFieldNumber = 29;
  inline ::mt::EmRestVideoQuality video_quality() const;
  inline void set_video_quality(::mt::EmRestVideoQuality value);

  // optional .mt.EmMtDualMode dual_mode = 30;
  inline bool has_dual_mode() const;
  inline void clear_dual_mode();
  static const int kDualModeFieldNumber = 30;
  inline ::mt::EmMtDualMode dual_mode() const;
  inline void set_dual_mode(::mt::EmMtDualMode value);

  // optional uint32 cascademode = 31;
  inline bool has_cascademode() const;
  inline void clear_cascademode();
  static const int kCascademodeFieldNumber = 31;
  inline ::google::protobuf::uint32 cascademode() const;
  inline void set_cascademode(::google::protobuf::uint32 value);

  // optional bool is_cascadeupload = 32;
  inline bool has_is_cascadeupload() const;
  inline void clear_is_cascadeupload();
  static const int kIsCascadeuploadFieldNumber = 32;
  inline bool is_cascadeupload() const;
  inline void set_is_cascadeupload(bool value);

  // optional bool is_cascadereturn = 33;
  inline bool has_is_cascadereturn() const;
  inline void clear_is_cascadereturn();
  static const int kIsCascadereturnFieldNumber = 33;
  inline bool is_cascadereturn() const;
  inline void set_is_cascadereturn(bool value);

  // optional uint32 cascadereturnpara = 34;
  inline bool has_cascadereturnpara() const;
  inline void clear_cascadereturnpara();
  static const int kCascadereturnparaFieldNumber = 34;
  inline ::google::protobuf::uint32 cascadereturnpara() const;
  inline void set_cascadereturnpara(::google::protobuf::uint32 value);

  // optional .mt.TNetAddr multicastaddr = 35;
  inline bool has_multicastaddr() const;
  inline void clear_multicastaddr();
  static const int kMulticastaddrFieldNumber = 35;
  inline const ::mt::TNetAddr& multicastaddr() const;
  inline ::mt::TNetAddr* mutable_multicastaddr();
  inline ::mt::TNetAddr* release_multicastaddr();
  inline void set_allocated_multicastaddr(::mt::TNetAddr* multicastaddr);

  // optional bool is_multicastenable = 36;
  inline bool has_is_multicastenable() const;
  inline void clear_is_multicastenable();
  static const int kIsMulticastenableFieldNumber = 36;
  inline bool is_multicastenable() const;
  inline void set_is_multicastenable(bool value);

  // repeated uint32 vip_list = 37;
  inline int vip_list_size() const;
  inline void clear_vip_list();
  static const int kVipListFieldNumber = 37;
  inline ::google::protobuf::uint32 vip_list(int index) const;
  inline void set_vip_list(int index, ::google::protobuf::uint32 value);
  inline void add_vip_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      vip_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_vip_list();

  // repeated uint32 call_chaselist = 38;
  inline int call_chaselist_size() const;
  inline void clear_call_chaselist();
  static const int kCallChaselistFieldNumber = 38;
  inline ::google::protobuf::uint32 call_chaselist(int index) const;
  inline void set_call_chaselist(int index, ::google::protobuf::uint32 value);
  inline void add_call_chaselist(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      call_chaselist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_call_chaselist();

  // optional .mt.TMtMiniPollInfo poll_Info = 39;
  inline bool has_poll_info() const;
  inline void clear_poll_info();
  static const int kPollInfoFieldNumber = 39;
  inline const ::mt::TMtMiniPollInfo& poll_info() const;
  inline ::mt::TMtMiniPollInfo* mutable_poll_info();
  inline ::mt::TMtMiniPollInfo* release_poll_info();
  inline void set_allocated_poll_info(::mt::TMtMiniPollInfo* poll_info);

  // optional .mt.TMtMiniVmpParam vmp_param = 40;
  inline bool has_vmp_param() const;
  inline void clear_vmp_param();
  static const int kVmpParamFieldNumber = 40;
  inline const ::mt::TMtMiniVmpParam& vmp_param() const;
  inline ::mt::TMtMiniVmpParam* mutable_vmp_param();
  inline ::mt::TMtMiniVmpParam* release_vmp_param();
  inline void set_allocated_vmp_param(::mt::TMtMiniVmpParam* vmp_param);

  // optional .mt.EmMtMixType mix_mode = 41;
  inline bool has_mix_mode() const;
  inline void clear_mix_mode();
  static const int kMixModeFieldNumber = 41;
  inline ::mt::EmMtMixType mix_mode() const;
  inline void set_mix_mode(::mt::EmMtMixType value);

  // repeated uint32 mix_list = 42;
  inline int mix_list_size() const;
  inline void clear_mix_list();
  static const int kMixListFieldNumber = 42;
  inline ::google::protobuf::uint32 mix_list(int index) const;
  inline void set_mix_list(int index, ::google::protobuf::uint32 value);
  inline void add_mix_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      mix_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_mix_list();

  // optional .mt.TRpMtAddr mt_list = 43;
  inline bool has_mt_list() const;
  inline void clear_mt_list();
  static const int kMtListFieldNumber = 43;
  inline const ::mt::TRpMtAddr& mt_list() const;
  inline ::mt::TRpMtAddr* mutable_mt_list();
  inline ::mt::TRpMtAddr* release_mt_list();
  inline void set_allocated_mt_list(::mt::TRpMtAddr* mt_list);

  // optional .mt.TMtAddr chairman = 44;
  inline bool has_chairman() const;
  inline void clear_chairman();
  static const int kChairmanFieldNumber = 44;
  inline const ::mt::TMtAddr& chairman() const;
  inline ::mt::TMtAddr* mutable_chairman();
  inline ::mt::TMtAddr* release_chairman();
  inline void set_allocated_chairman(::mt::TMtAddr* chairman);

  // optional .mt.TMtAutorecattrb autorecord = 45;
  inline bool has_autorecord() const;
  inline void clear_autorecord();
  static const int kAutorecordFieldNumber = 45;
  inline const ::mt::TMtAutorecattrb& autorecord() const;
  inline ::mt::TMtAutorecattrb* mutable_autorecord();
  inline ::mt::TMtAutorecattrb* release_autorecord();
  inline void set_allocated_autorecord(::mt::TMtAutorecattrb* autorecord);

  // optional uint32 mix_vacinterval = 46;
  inline bool has_mix_vacinterval() const;
  inline void clear_mix_vacinterval();
  static const int kMixVacintervalFieldNumber = 46;
  inline ::google::protobuf::uint32 mix_vacinterval() const;
  inline void set_mix_vacinterval(::google::protobuf::uint32 value);

  // optional bool is_onereforming = 47;
  inline bool has_is_onereforming() const;
  inline void clear_is_onereforming();
  static const int kIsOnereformingFieldNumber = 47;
  inline bool is_onereforming() const;
  inline void set_is_onereforming(bool value);

  // optional string conf_e164 = 48;
  inline bool has_conf_e164() const;
  inline void clear_conf_e164();
  static const int kConfE164FieldNumber = 48;
  inline const ::std::string& conf_e164() const;
  inline void set_conf_e164(const ::std::string& value);
  inline void set_conf_e164(const char* value);
  inline void set_conf_e164(const char* value, size_t size);
  inline ::std::string* mutable_conf_e164();
  inline ::std::string* release_conf_e164();
  inline void set_allocated_conf_e164(::std::string* conf_e164);

  // optional uint32 max_joined_mt = 49;
  inline bool has_max_joined_mt() const;
  inline void clear_max_joined_mt();
  static const int kMaxJoinedMtFieldNumber = 49;
  inline ::google::protobuf::uint32 max_joined_mt() const;
  inline void set_max_joined_mt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtCreateConfParam)
 private:
  inline void set_has_conf_pwd();
  inline void clear_has_conf_pwd();
  inline void set_has_conf_name();
  inline void clear_has_conf_name();
  inline void set_has_conf_duration();
  inline void clear_has_conf_duration();
  inline void set_has_conf_bitrate();
  inline void clear_has_conf_bitrate();
  inline void set_has_open_mode();
  inline void clear_has_open_mode();
  inline void set_has_release_mode();
  inline void clear_has_release_mode();
  inline void set_has_is_all_init_dumb();
  inline void clear_has_is_all_init_dumb();
  inline void set_has_conf_encrypt();
  inline void clear_has_conf_encrypt();
  inline void set_has_enckey();
  inline void clear_has_enckey();
  inline void set_has_is_satdcast_mode();
  inline void clear_has_is_satdcast_mode();
  inline void set_has_max_bitrate_for_opus();
  inline void clear_has_max_bitrate_for_opus();
  inline void set_has_min_bitrate_for_opus();
  inline void clear_has_min_bitrate_for_opus();
  inline void set_has_is_public_conf();
  inline void clear_has_is_public_conf();
  inline void set_has_is_port_mode();
  inline void clear_has_is_port_mode();
  inline void set_has_is_conf_nodisturb();
  inline void clear_has_is_conf_nodisturb();
  inline void set_has_vid_format();
  inline void clear_has_vid_format();
  inline void set_has_h264_profile();
  inline void clear_has_h264_profile();
  inline void set_has_vid_res();
  inline void clear_has_vid_res();
  inline void set_has_vid_fps();
  inline void clear_has_vid_fps();
  inline void set_has_assvid_format();
  inline void clear_has_assvid_format();
  inline void set_has_assvid_res();
  inline void clear_has_assvid_res();
  inline void set_has_assvid_fps();
  inline void clear_has_assvid_fps();
  inline void set_has_aud_format();
  inline void clear_has_aud_format();
  inline void set_has_chnl_num();
  inline void clear_has_chnl_num();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_calltimes();
  inline void clear_has_calltimes();
  inline void set_has_callinterval();
  inline void clear_has_callinterval();
  inline void set_has_is_callchase();
  inline void clear_has_is_callchase();
  inline void set_has_video_quality();
  inline void clear_has_video_quality();
  inline void set_has_dual_mode();
  inline void clear_has_dual_mode();
  inline void set_has_cascademode();
  inline void clear_has_cascademode();
  inline void set_has_is_cascadeupload();
  inline void clear_has_is_cascadeupload();
  inline void set_has_is_cascadereturn();
  inline void clear_has_is_cascadereturn();
  inline void set_has_cascadereturnpara();
  inline void clear_has_cascadereturnpara();
  inline void set_has_multicastaddr();
  inline void clear_has_multicastaddr();
  inline void set_has_is_multicastenable();
  inline void clear_has_is_multicastenable();
  inline void set_has_poll_info();
  inline void clear_has_poll_info();
  inline void set_has_vmp_param();
  inline void clear_has_vmp_param();
  inline void set_has_mix_mode();
  inline void clear_has_mix_mode();
  inline void set_has_mt_list();
  inline void clear_has_mt_list();
  inline void set_has_chairman();
  inline void clear_has_chairman();
  inline void set_has_autorecord();
  inline void clear_has_autorecord();
  inline void set_has_mix_vacinterval();
  inline void clear_has_mix_vacinterval();
  inline void set_has_is_onereforming();
  inline void clear_has_is_onereforming();
  inline void set_has_conf_e164();
  inline void clear_has_conf_e164();
  inline void set_has_max_joined_mt();
  inline void clear_has_max_joined_mt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* conf_pwd_;
  ::std::string* conf_name_;
  ::google::protobuf::uint32 conf_duration_;
  ::google::protobuf::uint32 conf_bitrate_;
  int open_mode_;
  int release_mode_;
  ::std::string* enckey_;
  int conf_encrypt_;
  ::google::protobuf::uint32 max_bitrate_for_opus_;
  bool is_all_init_dumb_;
  bool is_satdcast_mode_;
  bool is_public_conf_;
  bool is_port_mode_;
  ::google::protobuf::uint32 min_bitrate_for_opus_;
  int vid_format_;
  int h264_profile_;
  int vid_res_;
  ::google::protobuf::uint32 vid_fps_;
  int assvid_format_;
  int assvid_res_;
  ::google::protobuf::uint32 assvid_fps_;
  int aud_format_;
  ::mt::TMtAddr* speaker_;
  int chnl_num_;
  ::google::protobuf::uint32 calltimes_;
  ::google::protobuf::uint32 callinterval_;
  bool is_conf_nodisturb_;
  bool is_callchase_;
  bool is_cascadeupload_;
  bool is_cascadereturn_;
  int video_quality_;
  int dual_mode_;
  ::google::protobuf::uint32 cascademode_;
  ::google::protobuf::uint32 cascadereturnpara_;
  ::mt::TNetAddr* multicastaddr_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > vip_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > call_chaselist_;
  ::mt::TMtMiniPollInfo* poll_info_;
  ::mt::TMtMiniVmpParam* vmp_param_;
  int mix_mode_;
  bool is_multicastenable_;
  bool is_onereforming_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > mix_list_;
  ::mt::TRpMtAddr* mt_list_;
  ::mt::TMtAddr* chairman_;
  ::mt::TMtAutorecattrb* autorecord_;
  ::google::protobuf::uint32 mix_vacinterval_;
  ::google::protobuf::uint32 max_joined_mt_;
  ::std::string* conf_e164_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(49 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtCreateConfParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAutorecattrb : public ::google::protobuf::Message {
 public:
  TMtAutorecattrb();
  virtual ~TMtAutorecattrb();

  TMtAutorecattrb(const TMtAutorecattrb& from);

  inline TMtAutorecattrb& operator=(const TMtAutorecattrb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAutorecattrb& default_instance();

  void Swap(TMtAutorecattrb* other);

  // implements Message ----------------------------------------------

  TMtAutorecattrb* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAutorecattrb& from);
  void MergeFrom(const TMtAutorecattrb& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool autorec = 1;
  inline bool has_autorec() const;
  inline void clear_autorec();
  static const int kAutorecFieldNumber = 1;
  inline bool autorec() const;
  inline void set_autorec(bool value);

  // optional uint32 publishmode = 2;
  inline bool has_publishmode() const;
  inline void clear_publishmode();
  static const int kPublishmodeFieldNumber = 2;
  inline ::google::protobuf::uint32 publishmode() const;
  inline void set_publishmode(::google::protobuf::uint32 value);

  // optional bool isrecmainvideo = 3;
  inline bool has_isrecmainvideo() const;
  inline void clear_isrecmainvideo();
  static const int kIsrecmainvideoFieldNumber = 3;
  inline bool isrecmainvideo() const;
  inline void set_isrecmainvideo(bool value);

  // optional bool isrecdstream = 4;
  inline bool has_isrecdstream() const;
  inline void clear_isrecdstream();
  static const int kIsrecdstreamFieldNumber = 4;
  inline bool isrecdstream() const;
  inline void set_isrecdstream(bool value);

  // optional .mt.TMtVrsalias vrsalias = 5;
  inline bool has_vrsalias() const;
  inline void clear_vrsalias();
  static const int kVrsaliasFieldNumber = 5;
  inline const ::mt::TMtVrsalias& vrsalias() const;
  inline ::mt::TMtVrsalias* mutable_vrsalias();
  inline ::mt::TMtVrsalias* release_vrsalias();
  inline void set_allocated_vrsalias(::mt::TMtVrsalias* vrsalias);

  // @@protoc_insertion_point(class_scope:mt.TMtAutorecattrb)
 private:
  inline void set_has_autorec();
  inline void clear_has_autorec();
  inline void set_has_publishmode();
  inline void clear_has_publishmode();
  inline void set_has_isrecmainvideo();
  inline void clear_has_isrecmainvideo();
  inline void set_has_isrecdstream();
  inline void clear_has_isrecdstream();
  inline void set_has_vrsalias();
  inline void clear_has_vrsalias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 publishmode_;
  bool autorec_;
  bool isrecmainvideo_;
  bool isrecdstream_;
  ::mt::TMtVrsalias* vrsalias_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtAutorecattrb* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVrsalias : public ::google::protobuf::Message {
 public:
  TMtVrsalias();
  virtual ~TMtVrsalias();

  TMtVrsalias(const TMtVrsalias& from);

  inline TMtVrsalias& operator=(const TMtVrsalias& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVrsalias& default_instance();

  void Swap(TMtVrsalias* other);

  // implements Message ----------------------------------------------

  TMtVrsalias* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVrsalias& from);
  void MergeFrom(const TMtVrsalias& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 aliastype = 1;
  inline bool has_aliastype() const;
  inline void clear_aliastype();
  static const int kAliastypeFieldNumber = 1;
  inline ::google::protobuf::uint32 aliastype() const;
  inline void set_aliastype(::google::protobuf::uint32 value);

  // optional string addr = 2;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 2;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const char* value, size_t size);
  inline ::std::string* mutable_addr();
  inline ::std::string* release_addr();
  inline void set_allocated_addr(::std::string* addr);

  // optional string vrsno = 3;
  inline bool has_vrsno() const;
  inline void clear_vrsno();
  static const int kVrsnoFieldNumber = 3;
  inline const ::std::string& vrsno() const;
  inline void set_vrsno(const ::std::string& value);
  inline void set_vrsno(const char* value);
  inline void set_vrsno(const char* value, size_t size);
  inline ::std::string* mutable_vrsno();
  inline ::std::string* release_vrsno();
  inline void set_allocated_vrsno(::std::string* vrsno);

  // @@protoc_insertion_point(class_scope:mt.TMtVrsalias)
 private:
  inline void set_has_aliastype();
  inline void clear_has_aliastype();
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_vrsno();
  inline void clear_has_vrsno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* addr_;
  ::std::string* vrsno_;
  ::google::protobuf::uint32 aliastype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtVrsalias* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtMiniPollInfo : public ::google::protobuf::Message {
 public:
  TMtMiniPollInfo();
  virtual ~TMtMiniPollInfo();

  TMtMiniPollInfo(const TMtMiniPollInfo& from);

  inline TMtMiniPollInfo& operator=(const TMtMiniPollInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtMiniPollInfo& default_instance();

  void Swap(TMtMiniPollInfo* other);

  // implements Message ----------------------------------------------

  TMtMiniPollInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtMiniPollInfo& from);
  void MergeFrom(const TMtMiniPollInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtPollModeDef media_mode = 1;
  inline bool has_media_mode() const;
  inline void clear_media_mode();
  static const int kMediaModeFieldNumber = 1;
  inline ::mt::EmMtPollModeDef media_mode() const;
  inline void set_media_mode(::mt::EmMtPollModeDef value);

  // optional uint32 keep_time = 2;
  inline bool has_keep_time() const;
  inline void clear_keep_time();
  static const int kKeepTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 keep_time() const;
  inline void set_keep_time(::google::protobuf::uint32 value);

  // optional uint32 poll_num = 3;
  inline bool has_poll_num() const;
  inline void clear_poll_num();
  static const int kPollNumFieldNumber = 3;
  inline ::google::protobuf::uint32 poll_num() const;
  inline void set_poll_num(::google::protobuf::uint32 value);

  // repeated uint32 poll_mt = 4;
  inline int poll_mt_size() const;
  inline void clear_poll_mt();
  static const int kPollMtFieldNumber = 4;
  inline ::google::protobuf::uint32 poll_mt(int index) const;
  inline void set_poll_mt(int index, ::google::protobuf::uint32 value);
  inline void add_poll_mt(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      poll_mt() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_poll_mt();

  // @@protoc_insertion_point(class_scope:mt.TMtMiniPollInfo)
 private:
  inline void set_has_media_mode();
  inline void clear_has_media_mode();
  inline void set_has_keep_time();
  inline void clear_has_keep_time();
  inline void set_has_poll_num();
  inline void clear_has_poll_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int media_mode_;
  ::google::protobuf::uint32 keep_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > poll_mt_;
  ::google::protobuf::uint32 poll_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtMiniPollInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtMiniVmpParam : public ::google::protobuf::Message {
 public:
  TMtMiniVmpParam();
  virtual ~TMtMiniVmpParam();

  TMtMiniVmpParam(const TMtMiniVmpParam& from);

  inline TMtMiniVmpParam& operator=(const TMtMiniVmpParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtMiniVmpParam& default_instance();

  void Swap(TMtMiniVmpParam* other);

  // implements Message ----------------------------------------------

  TMtMiniVmpParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtMiniVmpParam& from);
  void MergeFrom(const TMtMiniVmpParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_vmp_brdst = 2;
  inline bool has_is_vmp_brdst() const;
  inline void clear_is_vmp_brdst();
  static const int kIsVmpBrdstFieldNumber = 2;
  inline bool is_vmp_brdst() const;
  inline void set_is_vmp_brdst(bool value);

  // optional .mt.EmMtVmpStyle vmp_style = 3;
  inline bool has_vmp_style() const;
  inline void clear_vmp_style();
  static const int kVmpStyleFieldNumber = 3;
  inline ::mt::EmMtVmpStyle vmp_style() const;
  inline void set_vmp_style(::mt::EmMtVmpStyle value);

  // optional .mt.EmMtVmpMode vmp_mode = 5;
  inline bool has_vmp_mode() const;
  inline void clear_vmp_mode();
  static const int kVmpModeFieldNumber = 5;
  inline ::mt::EmMtVmpMode vmp_mode() const;
  inline void set_vmp_mode(::mt::EmMtVmpMode value);

  // optional bool is_rim_enabled = 6;
  inline bool has_is_rim_enabled() const;
  inline void clear_is_rim_enabled();
  static const int kIsRimEnabledFieldNumber = 6;
  inline bool is_rim_enabled() const;
  inline void set_is_rim_enabled(bool value);

  // optional bool is_add_mmbalias = 7;
  inline bool has_is_add_mmbalias() const;
  inline void clear_is_add_mmbalias();
  static const int kIsAddMmbaliasFieldNumber = 7;
  inline bool is_add_mmbalias() const;
  inline void set_is_add_mmbalias(bool value);

  // optional bool is_vmp_batch_poll = 8;
  inline bool has_is_vmp_batch_poll() const;
  inline void clear_is_vmp_batch_poll();
  static const int kIsVmpBatchPollFieldNumber = 8;
  inline bool is_vmp_batch_poll() const;
  inline void set_is_vmp_batch_poll(bool value);

  // optional uint32 keep_poll_time = 9;
  inline bool has_keep_poll_time() const;
  inline void clear_keep_poll_time();
  static const int kKeepPollTimeFieldNumber = 9;
  inline ::google::protobuf::uint32 keep_poll_time() const;
  inline void set_keep_poll_time(::google::protobuf::uint32 value);

  // optional uint32 poll_num = 10;
  inline bool has_poll_num() const;
  inline void clear_poll_num();
  static const int kPollNumFieldNumber = 10;
  inline ::google::protobuf::uint32 poll_num() const;
  inline void set_poll_num(::google::protobuf::uint32 value);

  // repeated .mt.TMtMiniVMPMember vmp_member = 11;
  inline int vmp_member_size() const;
  inline void clear_vmp_member();
  static const int kVmpMemberFieldNumber = 11;
  inline const ::mt::TMtMiniVMPMember& vmp_member(int index) const;
  inline ::mt::TMtMiniVMPMember* mutable_vmp_member(int index);
  inline ::mt::TMtMiniVMPMember* add_vmp_member();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtMiniVMPMember >&
      vmp_member() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtMiniVMPMember >*
      mutable_vmp_member();

  // optional bool is_voice_hint = 12;
  inline bool has_is_voice_hint() const;
  inline void clear_is_voice_hint();
  static const int kIsVoiceHintFieldNumber = 12;
  inline bool is_voice_hint() const;
  inline void set_is_voice_hint(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtMiniVmpParam)
 private:
  inline void set_has_is_vmp_brdst();
  inline void clear_has_is_vmp_brdst();
  inline void set_has_vmp_style();
  inline void clear_has_vmp_style();
  inline void set_has_vmp_mode();
  inline void clear_has_vmp_mode();
  inline void set_has_is_rim_enabled();
  inline void clear_has_is_rim_enabled();
  inline void set_has_is_add_mmbalias();
  inline void clear_has_is_add_mmbalias();
  inline void set_has_is_vmp_batch_poll();
  inline void clear_has_is_vmp_batch_poll();
  inline void set_has_keep_poll_time();
  inline void clear_has_keep_poll_time();
  inline void set_has_poll_num();
  inline void clear_has_poll_num();
  inline void set_has_is_voice_hint();
  inline void clear_has_is_voice_hint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int vmp_style_;
  int vmp_mode_;
  bool is_vmp_brdst_;
  bool is_rim_enabled_;
  bool is_add_mmbalias_;
  bool is_vmp_batch_poll_;
  ::google::protobuf::uint32 keep_poll_time_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMtMiniVMPMember > vmp_member_;
  ::google::protobuf::uint32 poll_num_;
  bool is_voice_hint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtMiniVmpParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtMiniVMPMember : public ::google::protobuf::Message {
 public:
  TMtMiniVMPMember();
  virtual ~TMtMiniVMPMember();

  TMtMiniVMPMember(const TMtMiniVMPMember& from);

  inline TMtMiniVMPMember& operator=(const TMtMiniVMPMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtMiniVMPMember& default_instance();

  void Swap(TMtMiniVMPMember* other);

  // implements Message ----------------------------------------------

  TMtMiniVMPMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtMiniVMPMember& from);
  void MergeFrom(const TMtMiniVMPMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 member = 1;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 1;
  inline ::google::protobuf::uint32 member() const;
  inline void set_member(::google::protobuf::uint32 value);

  // optional .mt.EmMtVMPMmbType member_type = 2;
  inline bool has_member_type() const;
  inline void clear_member_type();
  static const int kMemberTypeFieldNumber = 2;
  inline ::mt::EmMtVMPMmbType member_type() const;
  inline void set_member_type(::mt::EmMtVMPMmbType value);

  // optional .mt.EmMtMemberStatusDef member_status = 3;
  inline bool has_member_status() const;
  inline void clear_member_status();
  static const int kMemberStatusFieldNumber = 3;
  inline ::mt::EmMtMemberStatusDef member_status() const;
  inline void set_member_status(::mt::EmMtMemberStatusDef value);

  // optional uint32 chnnl_index = 4;
  inline bool has_chnnl_index() const;
  inline void clear_chnnl_index();
  static const int kChnnlIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 chnnl_index() const;
  inline void set_chnnl_index(::google::protobuf::uint32 value);

  // optional uint32 mem_index = 5;
  inline bool has_mem_index() const;
  inline void clear_mem_index();
  static const int kMemIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 mem_index() const;
  inline void set_mem_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtMiniVMPMember)
 private:
  inline void set_has_member();
  inline void clear_has_member();
  inline void set_has_member_type();
  inline void clear_has_member_type();
  inline void set_has_member_status();
  inline void clear_has_member_status();
  inline void set_has_chnnl_index();
  inline void clear_has_chnnl_index();
  inline void set_has_mem_index();
  inline void clear_has_mem_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 member_;
  int member_type_;
  int member_status_;
  ::google::protobuf::uint32 chnnl_index_;
  ::google::protobuf::uint32 mem_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtMiniVMPMember* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtCallParam : public ::google::protobuf::Message {
 public:
  TMtCallParam();
  virtual ~TMtCallParam();

  TMtCallParam(const TMtCallParam& from);

  inline TMtCallParam& operator=(const TMtCallParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtCallParam& default_instance();

  void Swap(TMtCallParam* other);

  // implements Message ----------------------------------------------

  TMtCallParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtCallParam& from);
  void MergeFrom(const TMtCallParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtCallMode call_type = 1;
  inline bool has_call_type() const;
  inline void clear_call_type();
  static const int kCallTypeFieldNumber = 1;
  inline ::mt::EmMtCallMode call_type() const;
  inline void set_call_type(::mt::EmMtCallMode value);

  // optional uint32 call_rate = 2;
  inline bool has_call_rate() const;
  inline void clear_call_rate();
  static const int kCallRateFieldNumber = 2;
  inline ::google::protobuf::uint32 call_rate() const;
  inline void set_call_rate(::google::protobuf::uint32 value);

  // optional .mt.EmConfProtocol conf_protocol = 3;
  inline bool has_conf_protocol() const;
  inline void clear_conf_protocol();
  static const int kConfProtocolFieldNumber = 3;
  inline ::mt::EmConfProtocol conf_protocol() const;
  inline void set_conf_protocol(::mt::EmConfProtocol value);

  // optional .mt.EmMtAddrType call_addr_type = 4;
  inline bool has_call_addr_type() const;
  inline void clear_call_addr_type();
  static const int kCallAddrTypeFieldNumber = 4;
  inline ::mt::EmMtAddrType call_addr_type() const;
  inline void set_call_addr_type(::mt::EmMtAddrType value);

  // optional .mt.TNetAddr calling_addr = 5;
  inline bool has_calling_addr() const;
  inline void clear_calling_addr();
  static const int kCallingAddrFieldNumber = 5;
  inline const ::mt::TNetAddr& calling_addr() const;
  inline ::mt::TNetAddr* mutable_calling_addr();
  inline ::mt::TNetAddr* release_calling_addr();
  inline void set_allocated_calling_addr(::mt::TNetAddr* calling_addr);

  // optional .mt.TNetAddr called_addr = 6;
  inline bool has_called_addr() const;
  inline void clear_called_addr();
  static const int kCalledAddrFieldNumber = 6;
  inline const ::mt::TNetAddr& called_addr() const;
  inline ::mt::TNetAddr* mutable_called_addr();
  inline ::mt::TNetAddr* release_called_addr();
  inline void set_allocated_called_addr(::mt::TNetAddr* called_addr);

  // optional .mt.TRpMtAlias calling_alias = 7;
  inline bool has_calling_alias() const;
  inline void clear_calling_alias();
  static const int kCallingAliasFieldNumber = 7;
  inline const ::mt::TRpMtAlias& calling_alias() const;
  inline ::mt::TRpMtAlias* mutable_calling_alias();
  inline ::mt::TRpMtAlias* release_calling_alias();
  inline void set_allocated_calling_alias(::mt::TRpMtAlias* calling_alias);

  // optional .mt.TRpMtAlias called_alias = 8;
  inline bool has_called_alias() const;
  inline void clear_called_alias();
  static const int kCalledAliasFieldNumber = 8;
  inline const ::mt::TRpMtAlias& called_alias() const;
  inline ::mt::TRpMtAlias* mutable_called_alias();
  inline ::mt::TRpMtAlias* release_called_alias();
  inline void set_allocated_called_alias(::mt::TRpMtAlias* called_alias);

  // optional bool bcreate_conf = 9;
  inline bool has_bcreate_conf() const;
  inline void clear_bcreate_conf();
  static const int kBcreateConfFieldNumber = 9;
  inline bool bcreate_conf() const;
  inline void set_bcreate_conf(bool value);

  // optional .mt.TMtConfBaseInfo conf_base_info = 10;
  inline bool has_conf_base_info() const;
  inline void clear_conf_base_info();
  static const int kConfBaseInfoFieldNumber = 10;
  inline const ::mt::TMtConfBaseInfo& conf_base_info() const;
  inline ::mt::TMtConfBaseInfo* mutable_conf_base_info();
  inline ::mt::TMtConfBaseInfo* release_conf_base_info();
  inline void set_allocated_conf_base_info(::mt::TMtConfBaseInfo* conf_base_info);

  // optional .mt.TRpMtAddr mt_list = 11;
  inline bool has_mt_list() const;
  inline void clear_mt_list();
  static const int kMtListFieldNumber = 11;
  inline const ::mt::TRpMtAddr& mt_list() const;
  inline ::mt::TRpMtAddr* mutable_mt_list();
  inline ::mt::TRpMtAddr* release_mt_list();
  inline void set_allocated_mt_list(::mt::TRpMtAddr* mt_list);

  // optional string peer_product_id = 12;
  inline bool has_peer_product_id() const;
  inline void clear_peer_product_id();
  static const int kPeerProductIdFieldNumber = 12;
  inline const ::std::string& peer_product_id() const;
  inline void set_peer_product_id(const ::std::string& value);
  inline void set_peer_product_id(const char* value);
  inline void set_peer_product_id(const char* value, size_t size);
  inline ::std::string* mutable_peer_product_id();
  inline ::std::string* release_peer_product_id();
  inline void set_allocated_peer_product_id(::std::string* peer_product_id);

  // optional string peer_version_id = 13;
  inline bool has_peer_version_id() const;
  inline void clear_peer_version_id();
  static const int kPeerVersionIdFieldNumber = 13;
  inline const ::std::string& peer_version_id() const;
  inline void set_peer_version_id(const ::std::string& value);
  inline void set_peer_version_id(const char* value);
  inline void set_peer_version_id(const char* value, size_t size);
  inline ::std::string* mutable_peer_version_id();
  inline ::std::string* release_peer_version_id();
  inline void set_allocated_peer_version_id(::std::string* peer_version_id);

  // optional uint32 peer_vender_id = 14;
  inline bool has_peer_vender_id() const;
  inline void clear_peer_vender_id();
  static const int kPeerVenderIdFieldNumber = 14;
  inline ::google::protobuf::uint32 peer_vender_id() const;
  inline void set_peer_vender_id(::google::protobuf::uint32 value);

  // optional bool bencrypt = 15;
  inline bool has_bencrypt() const;
  inline void clear_bencrypt();
  static const int kBencryptFieldNumber = 15;
  inline bool bencrypt() const;
  inline void set_bencrypt(bool value);

  // optional .mt.EmEndpointType endpoint_type = 16;
  inline bool has_endpoint_type() const;
  inline void clear_endpoint_type();
  static const int kEndpointTypeFieldNumber = 16;
  inline ::mt::EmEndpointType endpoint_type() const;
  inline void set_endpoint_type(::mt::EmEndpointType value);

  // optional bytes nonstand = 17;
  inline bool has_nonstand() const;
  inline void clear_nonstand();
  static const int kNonstandFieldNumber = 17;
  inline const ::std::string& nonstand() const;
  inline void set_nonstand(const ::std::string& value);
  inline void set_nonstand(const char* value);
  inline void set_nonstand(const void* value, size_t size);
  inline ::std::string* mutable_nonstand();
  inline ::std::string* release_nonstand();
  inline void set_allocated_nonstand(::std::string* nonstand);

  // optional string callid = 18;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 18;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // optional bool is_peerstack_5p0 = 19;
  inline bool has_is_peerstack_5p0() const;
  inline void clear_is_peerstack_5p0();
  static const int kIsPeerstack5P0FieldNumber = 19;
  inline bool is_peerstack_5p0() const;
  inline void set_is_peerstack_5p0(bool value);

  // optional bool is_vidchanoff = 20;
  inline bool has_is_vidchanoff() const;
  inline void clear_is_vidchanoff();
  static const int kIsVidchanoffFieldNumber = 20;
  inline bool is_vidchanoff() const;
  inline void set_is_vidchanoff(bool value);

  // optional .mt.EmSipConnectType sipconnect_type = 21;
  inline bool has_sipconnect_type() const;
  inline void clear_sipconnect_type();
  static const int kSipconnectTypeFieldNumber = 21;
  inline ::mt::EmSipConnectType sipconnect_type() const;
  inline void set_sipconnect_type(::mt::EmSipConnectType value);

  // optional bool is_peer_support_confsub = 24;
  inline bool has_is_peer_support_confsub() const;
  inline void clear_is_peer_support_confsub();
  static const int kIsPeerSupportConfsubFieldNumber = 24;
  inline bool is_peer_support_confsub() const;
  inline void set_is_peer_support_confsub(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtCallParam)
 private:
  inline void set_has_call_type();
  inline void clear_has_call_type();
  inline void set_has_call_rate();
  inline void clear_has_call_rate();
  inline void set_has_conf_protocol();
  inline void clear_has_conf_protocol();
  inline void set_has_call_addr_type();
  inline void clear_has_call_addr_type();
  inline void set_has_calling_addr();
  inline void clear_has_calling_addr();
  inline void set_has_called_addr();
  inline void clear_has_called_addr();
  inline void set_has_calling_alias();
  inline void clear_has_calling_alias();
  inline void set_has_called_alias();
  inline void clear_has_called_alias();
  inline void set_has_bcreate_conf();
  inline void clear_has_bcreate_conf();
  inline void set_has_conf_base_info();
  inline void clear_has_conf_base_info();
  inline void set_has_mt_list();
  inline void clear_has_mt_list();
  inline void set_has_peer_product_id();
  inline void clear_has_peer_product_id();
  inline void set_has_peer_version_id();
  inline void clear_has_peer_version_id();
  inline void set_has_peer_vender_id();
  inline void clear_has_peer_vender_id();
  inline void set_has_bencrypt();
  inline void clear_has_bencrypt();
  inline void set_has_endpoint_type();
  inline void clear_has_endpoint_type();
  inline void set_has_nonstand();
  inline void clear_has_nonstand();
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_is_peerstack_5p0();
  inline void clear_has_is_peerstack_5p0();
  inline void set_has_is_vidchanoff();
  inline void clear_has_is_vidchanoff();
  inline void set_has_sipconnect_type();
  inline void clear_has_sipconnect_type();
  inline void set_has_is_peer_support_confsub();
  inline void clear_has_is_peer_support_confsub();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int call_type_;
  ::google::protobuf::uint32 call_rate_;
  int conf_protocol_;
  int call_addr_type_;
  ::mt::TNetAddr* calling_addr_;
  ::mt::TNetAddr* called_addr_;
  ::mt::TRpMtAlias* calling_alias_;
  ::mt::TRpMtAlias* called_alias_;
  ::mt::TMtConfBaseInfo* conf_base_info_;
  ::mt::TRpMtAddr* mt_list_;
  ::std::string* peer_product_id_;
  ::std::string* peer_version_id_;
  ::google::protobuf::uint32 peer_vender_id_;
  bool bcreate_conf_;
  bool bencrypt_;
  bool is_peerstack_5p0_;
  bool is_vidchanoff_;
  ::std::string* nonstand_;
  ::std::string* callid_;
  int endpoint_type_;
  int sipconnect_type_;
  bool is_peer_support_confsub_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtCallParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMultiMtCallParam : public ::google::protobuf::Message {
 public:
  TMultiMtCallParam();
  virtual ~TMultiMtCallParam();

  TMultiMtCallParam(const TMultiMtCallParam& from);

  inline TMultiMtCallParam& operator=(const TMultiMtCallParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMultiMtCallParam& default_instance();

  void Swap(TMultiMtCallParam* other);

  // implements Message ----------------------------------------------

  TMultiMtCallParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMultiMtCallParam& from);
  void MergeFrom(const TMultiMtCallParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtCallParam call_param = 1;
  inline int call_param_size() const;
  inline void clear_call_param();
  static const int kCallParamFieldNumber = 1;
  inline const ::mt::TMtCallParam& call_param(int index) const;
  inline ::mt::TMtCallParam* mutable_call_param(int index);
  inline ::mt::TMtCallParam* add_call_param();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtCallParam >&
      call_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtCallParam >*
      mutable_call_param();

  // @@protoc_insertion_point(class_scope:mt.TMultiMtCallParam)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtCallParam > call_param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMultiMtCallParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMTSatelliteFlag : public ::google::protobuf::Message {
 public:
  TMTSatelliteFlag();
  virtual ~TMTSatelliteFlag();

  TMTSatelliteFlag(const TMTSatelliteFlag& from);

  inline TMTSatelliteFlag& operator=(const TMTSatelliteFlag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTSatelliteFlag& default_instance();

  void Swap(TMTSatelliteFlag* other);

  // implements Message ----------------------------------------------

  TMTSatelliteFlag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTSatelliteFlag& from);
  void MergeFrom(const TMTSatelliteFlag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_sate = 1;
  inline bool has_is_sate() const;
  inline void clear_is_sate();
  static const int kIsSateFieldNumber = 1;
  inline bool is_sate() const;
  inline void set_is_sate(bool value);

  // optional bool p2p_enable = 2;
  inline bool has_p2p_enable() const;
  inline void clear_p2p_enable();
  static const int kP2PEnableFieldNumber = 2;
  inline bool p2p_enable() const;
  inline void set_p2p_enable(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMTSatelliteFlag)
 private:
  inline void set_has_is_sate();
  inline void clear_has_is_sate();
  inline void set_has_p2p_enable();
  inline void clear_has_p2p_enable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_sate_;
  bool p2p_enable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMTSatelliteFlag* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtCallLinkSate : public ::google::protobuf::Message {
 public:
  TMtCallLinkSate();
  virtual ~TMtCallLinkSate();

  TMtCallLinkSate(const TMtCallLinkSate& from);

  inline TMtCallLinkSate& operator=(const TMtCallLinkSate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtCallLinkSate& default_instance();

  void Swap(TMtCallLinkSate* other);

  // implements Message ----------------------------------------------

  TMtCallLinkSate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtCallLinkSate& from);
  void MergeFrom(const TMtCallLinkSate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtCallState call_state = 1;
  inline bool has_call_state() const;
  inline void clear_call_state();
  static const int kCallStateFieldNumber = 1;
  inline ::mt::EmMtCallState call_state() const;
  inline void set_call_state(::mt::EmMtCallState value);

  // optional .mt.EmConfProtocol conf_protocol = 2;
  inline bool has_conf_protocol() const;
  inline void clear_conf_protocol();
  static const int kConfProtocolFieldNumber = 2;
  inline ::mt::EmConfProtocol conf_protocol() const;
  inline void set_conf_protocol(::mt::EmConfProtocol value);

  // optional bool is_caller = 3;
  inline bool has_is_caller() const;
  inline void clear_is_caller();
  static const int kIsCallerFieldNumber = 3;
  inline bool is_caller() const;
  inline void set_is_caller(bool value);

  // optional uint32 call_rate = 4;
  inline bool has_call_rate() const;
  inline void clear_call_rate();
  static const int kCallRateFieldNumber = 4;
  inline ::google::protobuf::uint32 call_rate() const;
  inline void set_call_rate(::google::protobuf::uint32 value);

  // optional uint32 call_avial_up_rate = 5;
  inline bool has_call_avial_up_rate() const;
  inline void clear_call_avial_up_rate();
  static const int kCallAvialUpRateFieldNumber = 5;
  inline ::google::protobuf::uint32 call_avial_up_rate() const;
  inline void set_call_avial_up_rate(::google::protobuf::uint32 value);

  // optional uint32 call_avail_down_rate = 6;
  inline bool has_call_avail_down_rate() const;
  inline void clear_call_avail_down_rate();
  static const int kCallAvailDownRateFieldNumber = 6;
  inline ::google::protobuf::uint32 call_avail_down_rate() const;
  inline void set_call_avail_down_rate(::google::protobuf::uint32 value);

  // optional .mt.EmMtCallDisReason call_dis_reason = 7;
  inline bool has_call_dis_reason() const;
  inline void clear_call_dis_reason();
  static const int kCallDisReasonFieldNumber = 7;
  inline ::mt::EmMtCallDisReason call_dis_reason() const;
  inline void set_call_dis_reason(::mt::EmMtCallDisReason value);

  // optional .mt.TNetAddr peer_addr = 8;
  inline bool has_peer_addr() const;
  inline void clear_peer_addr();
  static const int kPeerAddrFieldNumber = 8;
  inline const ::mt::TNetAddr& peer_addr() const;
  inline ::mt::TNetAddr* mutable_peer_addr();
  inline ::mt::TNetAddr* release_peer_addr();
  inline void set_allocated_peer_addr(::mt::TNetAddr* peer_addr);

  // optional .mt.EmMtModel peer_model = 9;
  inline bool has_peer_model() const;
  inline void clear_peer_model();
  static const int kPeerModelFieldNumber = 9;
  inline ::mt::EmMtModel peer_model() const;
  inline void set_peer_model(::mt::EmMtModel value);

  // optional string peer_productid = 10;
  inline bool has_peer_productid() const;
  inline void clear_peer_productid();
  static const int kPeerProductidFieldNumber = 10;
  inline const ::std::string& peer_productid() const;
  inline void set_peer_productid(const ::std::string& value);
  inline void set_peer_productid(const char* value);
  inline void set_peer_productid(const char* value, size_t size);
  inline ::std::string* mutable_peer_productid();
  inline ::std::string* release_peer_productid();
  inline void set_allocated_peer_productid(::std::string* peer_productid);

  // optional .mt.TRpMtAlias peer_alias = 11;
  inline bool has_peer_alias() const;
  inline void clear_peer_alias();
  static const int kPeerAliasFieldNumber = 11;
  inline const ::mt::TRpMtAlias& peer_alias() const;
  inline ::mt::TRpMtAlias* mutable_peer_alias();
  inline ::mt::TRpMtAlias* release_peer_alias();
  inline void set_allocated_peer_alias(::mt::TRpMtAlias* peer_alias);

  // optional .mt.EmEndpointType peer_endpoint_type = 12;
  inline bool has_peer_endpoint_type() const;
  inline void clear_peer_endpoint_type();
  static const int kPeerEndpointTypeFieldNumber = 12;
  inline ::mt::EmEndpointType peer_endpoint_type() const;
  inline void set_peer_endpoint_type(::mt::EmEndpointType value);

  // optional .mt.TMTTime conf_established_time = 13;
  inline bool has_conf_established_time() const;
  inline void clear_conf_established_time();
  static const int kConfEstablishedTimeFieldNumber = 13;
  inline const ::mt::TMTTime& conf_established_time() const;
  inline ::mt::TMTTime* mutable_conf_established_time();
  inline ::mt::TMTTime* release_conf_established_time();
  inline void set_allocated_conf_established_time(::mt::TMTTime* conf_established_time);

  // optional .mt.EmMtCallingType calling_type = 14;
  inline bool has_calling_type() const;
  inline void clear_calling_type();
  static const int kCallingTypeFieldNumber = 14;
  inline ::mt::EmMtCallingType calling_type() const;
  inline void set_calling_type(::mt::EmMtCallingType value);

  // optional uint32 peer_Vendor = 15;
  inline bool has_peer_vendor() const;
  inline void clear_peer_vendor();
  static const int kPeerVendorFieldNumber = 15;
  inline ::google::protobuf::uint32 peer_vendor() const;
  inline void set_peer_vendor(::google::protobuf::uint32 value);

  // optional string peer_versionId = 16;
  inline bool has_peer_versionid() const;
  inline void clear_peer_versionid();
  static const int kPeerVersionIdFieldNumber = 16;
  inline const ::std::string& peer_versionid() const;
  inline void set_peer_versionid(const ::std::string& value);
  inline void set_peer_versionid(const char* value);
  inline void set_peer_versionid(const char* value, size_t size);
  inline ::std::string* mutable_peer_versionid();
  inline ::std::string* release_peer_versionid();
  inline void set_allocated_peer_versionid(::std::string* peer_versionid);

  // optional bool is_peerstackafter5p0 = 17;
  inline bool has_is_peerstackafter5p0() const;
  inline void clear_is_peerstackafter5p0();
  static const int kIsPeerstackafter5P0FieldNumber = 17;
  inline bool is_peerstackafter5p0() const;
  inline void set_is_peerstackafter5p0(bool value);

  // optional bool is_qt_call = 18;
  inline bool has_is_qt_call() const;
  inline void clear_is_qt_call();
  static const int kIsQtCallFieldNumber = 18;
  inline bool is_qt_call() const;
  inline void set_is_qt_call(bool value);

  // optional .mt.EmSipConnectType sipconnect_type = 19;
  inline bool has_sipconnect_type() const;
  inline void clear_sipconnect_type();
  static const int kSipconnectTypeFieldNumber = 19;
  inline ::mt::EmSipConnectType sipconnect_type() const;
  inline void set_sipconnect_type(::mt::EmSipConnectType value);

  // optional bool is_peer_spt_subconflist = 20;
  inline bool has_is_peer_spt_subconflist() const;
  inline void clear_is_peer_spt_subconflist();
  static const int kIsPeerSptSubconflistFieldNumber = 20;
  inline bool is_peer_spt_subconflist() const;
  inline void set_is_peer_spt_subconflist(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtCallLinkSate)
 private:
  inline void set_has_call_state();
  inline void clear_has_call_state();
  inline void set_has_conf_protocol();
  inline void clear_has_conf_protocol();
  inline void set_has_is_caller();
  inline void clear_has_is_caller();
  inline void set_has_call_rate();
  inline void clear_has_call_rate();
  inline void set_has_call_avial_up_rate();
  inline void clear_has_call_avial_up_rate();
  inline void set_has_call_avail_down_rate();
  inline void clear_has_call_avail_down_rate();
  inline void set_has_call_dis_reason();
  inline void clear_has_call_dis_reason();
  inline void set_has_peer_addr();
  inline void clear_has_peer_addr();
  inline void set_has_peer_model();
  inline void clear_has_peer_model();
  inline void set_has_peer_productid();
  inline void clear_has_peer_productid();
  inline void set_has_peer_alias();
  inline void clear_has_peer_alias();
  inline void set_has_peer_endpoint_type();
  inline void clear_has_peer_endpoint_type();
  inline void set_has_conf_established_time();
  inline void clear_has_conf_established_time();
  inline void set_has_calling_type();
  inline void clear_has_calling_type();
  inline void set_has_peer_vendor();
  inline void clear_has_peer_vendor();
  inline void set_has_peer_versionid();
  inline void clear_has_peer_versionid();
  inline void set_has_is_peerstackafter5p0();
  inline void clear_has_is_peerstackafter5p0();
  inline void set_has_is_qt_call();
  inline void clear_has_is_qt_call();
  inline void set_has_sipconnect_type();
  inline void clear_has_sipconnect_type();
  inline void set_has_is_peer_spt_subconflist();
  inline void clear_has_is_peer_spt_subconflist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int call_state_;
  int conf_protocol_;
  ::google::protobuf::uint32 call_rate_;
  ::google::protobuf::uint32 call_avial_up_rate_;
  ::google::protobuf::uint32 call_avail_down_rate_;
  int call_dis_reason_;
  ::mt::TNetAddr* peer_addr_;
  ::std::string* peer_productid_;
  int peer_model_;
  int peer_endpoint_type_;
  ::mt::TRpMtAlias* peer_alias_;
  ::mt::TMTTime* conf_established_time_;
  int calling_type_;
  bool is_caller_;
  bool is_peerstackafter5p0_;
  bool is_qt_call_;
  bool is_peer_spt_subconflist_;
  ::std::string* peer_versionid_;
  ::google::protobuf::uint32 peer_vendor_;
  int sipconnect_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtCallLinkSate* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TCodecPackStat : public ::google::protobuf::Message {
 public:
  TCodecPackStat();
  virtual ~TCodecPackStat();

  TCodecPackStat(const TCodecPackStat& from);

  inline TCodecPackStat& operator=(const TCodecPackStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCodecPackStat& default_instance();

  void Swap(TCodecPackStat* other);

  // implements Message ----------------------------------------------

  TCodecPackStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCodecPackStat& from);
  void MergeFrom(const TCodecPackStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 bitrate = 1;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 1;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional uint32 avr_bitrate = 2;
  inline bool has_avr_bitrate() const;
  inline void clear_avr_bitrate();
  static const int kAvrBitrateFieldNumber = 2;
  inline ::google::protobuf::uint32 avr_bitrate() const;
  inline void set_avr_bitrate(::google::protobuf::uint32 value);

  // optional uint32 lost_packs = 3;
  inline bool has_lost_packs() const;
  inline void clear_lost_packs();
  static const int kLostPacksFieldNumber = 3;
  inline ::google::protobuf::uint32 lost_packs() const;
  inline void set_lost_packs(::google::protobuf::uint32 value);

  // optional uint32 total_packs = 4;
  inline bool has_total_packs() const;
  inline void clear_total_packs();
  static const int kTotalPacksFieldNumber = 4;
  inline ::google::protobuf::uint32 total_packs() const;
  inline void set_total_packs(::google::protobuf::uint32 value);

  // optional uint32 frames = 5;
  inline bool has_frames() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 5;
  inline ::google::protobuf::uint32 frames() const;
  inline void set_frames(::google::protobuf::uint32 value);

  // optional uint32 lost_frame_rate = 6;
  inline bool has_lost_frame_rate() const;
  inline void clear_lost_frame_rate();
  static const int kLostFrameRateFieldNumber = 6;
  inline ::google::protobuf::uint32 lost_frame_rate() const;
  inline void set_lost_frame_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TCodecPackStat)
 private:
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_avr_bitrate();
  inline void clear_has_avr_bitrate();
  inline void set_has_lost_packs();
  inline void clear_has_lost_packs();
  inline void set_has_total_packs();
  inline void clear_has_total_packs();
  inline void set_has_frames();
  inline void clear_has_frames();
  inline void set_has_lost_frame_rate();
  inline void clear_has_lost_frame_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 bitrate_;
  ::google::protobuf::uint32 avr_bitrate_;
  ::google::protobuf::uint32 lost_packs_;
  ::google::protobuf::uint32 total_packs_;
  ::google::protobuf::uint32 frames_;
  ::google::protobuf::uint32 lost_frame_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TCodecPackStat* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtStatusToPcdv : public ::google::protobuf::Message {
 public:
  TMtStatusToPcdv();
  virtual ~TMtStatusToPcdv();

  TMtStatusToPcdv(const TMtStatusToPcdv& from);

  inline TMtStatusToPcdv& operator=(const TMtStatusToPcdv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtStatusToPcdv& default_instance();

  void Swap(TMtStatusToPcdv* other);

  // implements Message ----------------------------------------------

  TMtStatusToPcdv* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtStatusToPcdv& from);
  void MergeFrom(const TMtStatusToPcdv& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtModel mt_model = 1;
  inline bool has_mt_model() const;
  inline void clear_mt_model();
  static const int kMtModelFieldNumber = 1;
  inline ::mt::EmMtModel mt_model() const;
  inline void set_mt_model(::mt::EmMtModel value);

  // optional .mt.EmMtCallState call_sate = 2;
  inline bool has_call_sate() const;
  inline void clear_call_sate();
  static const int kCallSateFieldNumber = 2;
  inline ::mt::EmMtCallState call_sate() const;
  inline void set_call_sate(::mt::EmMtCallState value);

  // optional .mt.EmMtConfMode conf_mode = 3;
  inline bool has_conf_mode() const;
  inline void clear_conf_mode();
  static const int kConfModeFieldNumber = 3;
  inline ::mt::EmMtConfMode conf_mode() const;
  inline void set_conf_mode(::mt::EmMtConfMode value);

  // optional bool can_send_dual = 4;
  inline bool has_can_send_dual() const;
  inline void clear_can_send_dual();
  static const int kCanSendDualFieldNumber = 4;
  inline bool can_send_dual() const;
  inline void set_can_send_dual(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtStatusToPcdv)
 private:
  inline void set_has_mt_model();
  inline void clear_has_mt_model();
  inline void set_has_call_sate();
  inline void clear_has_call_sate();
  inline void set_has_conf_mode();
  inline void clear_has_conf_mode();
  inline void set_has_can_send_dual();
  inline void clear_has_can_send_dual();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int mt_model_;
  int call_sate_;
  int conf_mode_;
  bool can_send_dual_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtStatusToPcdv* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TAssVidStatus : public ::google::protobuf::Message {
 public:
  TAssVidStatus();
  virtual ~TAssVidStatus();

  TAssVidStatus(const TAssVidStatus& from);

  inline TAssVidStatus& operator=(const TAssVidStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TAssVidStatus& default_instance();

  void Swap(TAssVidStatus* other);

  // implements Message ----------------------------------------------

  TAssVidStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TAssVidStatus& from);
  void MergeFrom(const TAssVidStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtChanState chan_state = 1;
  inline bool has_chan_state() const;
  inline void clear_chan_state();
  static const int kChanStateFieldNumber = 1;
  inline ::mt::EmMtChanState chan_state() const;
  inline void set_chan_state(::mt::EmMtChanState value);

  // optional .mt.EmMtVidLabel vid_lab = 2;
  inline bool has_vid_lab() const;
  inline void clear_vid_lab();
  static const int kVidLabFieldNumber = 2;
  inline ::mt::EmMtVidLabel vid_lab() const;
  inline void set_vid_lab(::mt::EmMtVidLabel value);

  // optional bool bactive = 3;
  inline bool has_bactive() const;
  inline void clear_bactive();
  static const int kBactiveFieldNumber = 3;
  inline bool bactive() const;
  inline void set_bactive(bool value);

  // optional .mt.TMtcBaseInfo pc_ass_src = 4;
  inline bool has_pc_ass_src() const;
  inline void clear_pc_ass_src();
  static const int kPcAssSrcFieldNumber = 4;
  inline const ::mt::TMtcBaseInfo& pc_ass_src() const;
  inline ::mt::TMtcBaseInfo* mutable_pc_ass_src();
  inline ::mt::TMtcBaseInfo* release_pc_ass_src();
  inline void set_allocated_pc_ass_src(::mt::TMtcBaseInfo* pc_ass_src);

  // @@protoc_insertion_point(class_scope:mt.TAssVidStatus)
 private:
  inline void set_has_chan_state();
  inline void clear_has_chan_state();
  inline void set_has_vid_lab();
  inline void clear_has_vid_lab();
  inline void set_has_bactive();
  inline void clear_has_bactive();
  inline void set_has_pc_ass_src();
  inline void clear_has_pc_ass_src();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int chan_state_;
  int vid_lab_;
  ::mt::TMtcBaseInfo* pc_ass_src_;
  bool bactive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TAssVidStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAssSndVidStatus : public ::google::protobuf::Message {
 public:
  TMtAssSndVidStatus();
  virtual ~TMtAssSndVidStatus();

  TMtAssSndVidStatus(const TMtAssSndVidStatus& from);

  inline TMtAssSndVidStatus& operator=(const TMtAssSndVidStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAssSndVidStatus& default_instance();

  void Swap(TMtAssSndVidStatus* other);

  // implements Message ----------------------------------------------

  TMtAssSndVidStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAssSndVidStatus& from);
  void MergeFrom(const TMtAssSndVidStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAssVidStatus ass_vid_snd = 1;
  inline int ass_vid_snd_size() const;
  inline void clear_ass_vid_snd();
  static const int kAssVidSndFieldNumber = 1;
  inline const ::mt::TAssVidStatus& ass_vid_snd(int index) const;
  inline ::mt::TAssVidStatus* mutable_ass_vid_snd(int index);
  inline ::mt::TAssVidStatus* add_ass_vid_snd();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAssVidStatus >&
      ass_vid_snd() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAssVidStatus >*
      mutable_ass_vid_snd();

  // @@protoc_insertion_point(class_scope:mt.TMtAssSndVidStatus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAssVidStatus > ass_vid_snd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtAssSndVidStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAssRcvVidStatus : public ::google::protobuf::Message {
 public:
  TMtAssRcvVidStatus();
  virtual ~TMtAssRcvVidStatus();

  TMtAssRcvVidStatus(const TMtAssRcvVidStatus& from);

  inline TMtAssRcvVidStatus& operator=(const TMtAssRcvVidStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAssRcvVidStatus& default_instance();

  void Swap(TMtAssRcvVidStatus* other);

  // implements Message ----------------------------------------------

  TMtAssRcvVidStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAssRcvVidStatus& from);
  void MergeFrom(const TMtAssRcvVidStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TAssVidStatus ass_vid_rcv = 1;
  inline int ass_vid_rcv_size() const;
  inline void clear_ass_vid_rcv();
  static const int kAssVidRcvFieldNumber = 1;
  inline const ::mt::TAssVidStatus& ass_vid_rcv(int index) const;
  inline ::mt::TAssVidStatus* mutable_ass_vid_rcv(int index);
  inline ::mt::TAssVidStatus* add_ass_vid_rcv();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TAssVidStatus >&
      ass_vid_rcv() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TAssVidStatus >*
      mutable_ass_vid_rcv();

  // @@protoc_insertion_point(class_scope:mt.TMtAssRcvVidStatus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TAssVidStatus > ass_vid_rcv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtAssRcvVidStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSimpConfInfo : public ::google::protobuf::Message {
 public:
  TMtSimpConfInfo();
  virtual ~TMtSimpConfInfo();

  TMtSimpConfInfo(const TMtSimpConfInfo& from);

  inline TMtSimpConfInfo& operator=(const TMtSimpConfInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSimpConfInfo& default_instance();

  void Swap(TMtSimpConfInfo* other);

  // implements Message ----------------------------------------------

  TMtSimpConfInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSimpConfInfo& from);
  void MergeFrom(const TMtSimpConfInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMtId speaker = 1;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 1;
  inline const ::mt::TMtId& speaker() const;
  inline ::mt::TMtId* mutable_speaker();
  inline ::mt::TMtId* release_speaker();
  inline void set_allocated_speaker(::mt::TMtId* speaker);

  // optional .mt.TMtId chairman = 2;
  inline bool has_chairman() const;
  inline void clear_chairman();
  static const int kChairmanFieldNumber = 2;
  inline const ::mt::TMtId& chairman() const;
  inline ::mt::TMtId* mutable_chairman();
  inline ::mt::TMtId* release_chairman();
  inline void set_allocated_chairman(::mt::TMtId* chairman);

  // optional .mt.EmMtMixType discuss_mode = 3;
  inline bool has_discuss_mode() const;
  inline void clear_discuss_mode();
  static const int kDiscussModeFieldNumber = 3;
  inline ::mt::EmMtMixType discuss_mode() const;
  inline void set_discuss_mode(::mt::EmMtMixType value);

  // optional .mt.EmMtVmpMode vmp_mode = 4;
  inline bool has_vmp_mode() const;
  inline void clear_vmp_mode();
  static const int kVmpModeFieldNumber = 4;
  inline ::mt::EmMtVmpMode vmp_mode() const;
  inline void set_vmp_mode(::mt::EmMtVmpMode value);

  // @@protoc_insertion_point(class_scope:mt.TMtSimpConfInfo)
 private:
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_chairman();
  inline void clear_has_chairman();
  inline void set_has_discuss_mode();
  inline void clear_has_discuss_mode();
  inline void set_has_vmp_mode();
  inline void clear_has_vmp_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMtId* speaker_;
  ::mt::TMtId* chairman_;
  int discuss_mode_;
  int vmp_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtSimpConfInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtTerLossRate : public ::google::protobuf::Message {
 public:
  TMtTerLossRate();
  virtual ~TMtTerLossRate();

  TMtTerLossRate(const TMtTerLossRate& from);

  inline TMtTerLossRate& operator=(const TMtTerLossRate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtTerLossRate& default_instance();

  void Swap(TMtTerLossRate* other);

  // implements Message ----------------------------------------------

  TMtTerLossRate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtTerLossRate& from);
  void MergeFrom(const TMtTerLossRate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtChanLossRate one_chan = 1;
  inline int one_chan_size() const;
  inline void clear_one_chan();
  static const int kOneChanFieldNumber = 1;
  inline const ::mt::TMtChanLossRate& one_chan(int index) const;
  inline ::mt::TMtChanLossRate* mutable_one_chan(int index);
  inline ::mt::TMtChanLossRate* add_one_chan();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtChanLossRate >&
      one_chan() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtChanLossRate >*
      mutable_one_chan();

  // @@protoc_insertion_point(class_scope:mt.TMtTerLossRate)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtChanLossRate > one_chan_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtTerLossRate* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtChanLossRate : public ::google::protobuf::Message {
 public:
  TMtChanLossRate();
  virtual ~TMtChanLossRate();

  TMtChanLossRate(const TMtChanLossRate& from);

  inline TMtChanLossRate& operator=(const TMtChanLossRate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtChanLossRate& default_instance();

  void Swap(TMtChanLossRate* other);

  // implements Message ----------------------------------------------

  TMtChanLossRate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtChanLossRate& from);
  void MergeFrom(const TMtChanLossRate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMediaModeDef mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::mt::EmMediaModeDef mode() const;
  inline void set_mode(::mt::EmMediaModeDef value);

  // optional uint32 recv_idx = 2;
  inline bool has_recv_idx() const;
  inline void clear_recv_idx();
  static const int kRecvIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 recv_idx() const;
  inline void set_recv_idx(::google::protobuf::uint32 value);

  // optional uint32 packet_lost_rate = 3;
  inline bool has_packet_lost_rate() const;
  inline void clear_packet_lost_rate();
  static const int kPacketLostRateFieldNumber = 3;
  inline ::google::protobuf::uint32 packet_lost_rate() const;
  inline void set_packet_lost_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtChanLossRate)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_recv_idx();
  inline void clear_has_recv_idx();
  inline void set_has_packet_lost_rate();
  inline void clear_has_packet_lost_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int mode_;
  ::google::protobuf::uint32 recv_idx_;
  ::google::protobuf::uint32 packet_lost_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtChanLossRate* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtConfInfo : public ::google::protobuf::Message {
 public:
  TMtConfInfo();
  virtual ~TMtConfInfo();

  TMtConfInfo(const TMtConfInfo& from);

  inline TMtConfInfo& operator=(const TMtConfInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtConfInfo& default_instance();

  void Swap(TMtConfInfo* other);

  // implements Message ----------------------------------------------

  TMtConfInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtConfInfo& from);
  void MergeFrom(const TMtConfInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMTTime start_time = 1;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 1;
  inline const ::mt::TMTTime& start_time() const;
  inline ::mt::TMTTime* mutable_start_time();
  inline ::mt::TMTTime* release_start_time();
  inline void set_allocated_start_time(::mt::TMTTime* start_time);

  // optional uint32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 bitrate = 3;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 3;
  inline ::google::protobuf::uint32 bitrate() const;
  inline void set_bitrate(::google::protobuf::uint32 value);

  // optional uint32 sec_bitrate = 4;
  inline bool has_sec_bitrate() const;
  inline void clear_sec_bitrate();
  static const int kSecBitrateFieldNumber = 4;
  inline ::google::protobuf::uint32 sec_bitrate() const;
  inline void set_sec_bitrate(::google::protobuf::uint32 value);

  // optional .mt.EmMtResolution main_video_res = 5;
  inline bool has_main_video_res() const;
  inline void clear_main_video_res();
  static const int kMainVideoResFieldNumber = 5;
  inline ::mt::EmMtResolution main_video_res() const;
  inline void set_main_video_res(::mt::EmMtResolution value);

  // optional .mt.EmMtResolution ass_video_res = 6;
  inline bool has_ass_video_res() const;
  inline void clear_ass_video_res();
  static const int kAssVideoResFieldNumber = 6;
  inline ::mt::EmMtResolution ass_video_res() const;
  inline void set_ass_video_res(::mt::EmMtResolution value);

  // optional uint32 talk_hold_time = 7;
  inline bool has_talk_hold_time() const;
  inline void clear_talk_hold_time();
  static const int kTalkHoldTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 talk_hold_time() const;
  inline void set_talk_hold_time(::google::protobuf::uint32 value);

  // optional string conf_pwd = 8;
  inline bool has_conf_pwd() const;
  inline void clear_conf_pwd();
  static const int kConfPwdFieldNumber = 8;
  inline const ::std::string& conf_pwd() const;
  inline void set_conf_pwd(const ::std::string& value);
  inline void set_conf_pwd(const char* value);
  inline void set_conf_pwd(const char* value, size_t size);
  inline ::std::string* mutable_conf_pwd();
  inline ::std::string* release_conf_pwd();
  inline void set_allocated_conf_pwd(::std::string* conf_pwd);

  // optional string conf_name = 9;
  inline bool has_conf_name() const;
  inline void clear_conf_name();
  static const int kConfNameFieldNumber = 9;
  inline const ::std::string& conf_name() const;
  inline void set_conf_name(const ::std::string& value);
  inline void set_conf_name(const char* value);
  inline void set_conf_name(const char* value, size_t size);
  inline ::std::string* mutable_conf_name();
  inline ::std::string* release_conf_name();
  inline void set_allocated_conf_name(::std::string* conf_name);

  // optional string conf_e164 = 10;
  inline bool has_conf_e164() const;
  inline void clear_conf_e164();
  static const int kConfE164FieldNumber = 10;
  inline const ::std::string& conf_e164() const;
  inline void set_conf_e164(const ::std::string& value);
  inline void set_conf_e164(const char* value);
  inline void set_conf_e164(const char* value, size_t size);
  inline ::std::string* mutable_conf_e164();
  inline ::std::string* release_conf_e164();
  inline void set_allocated_conf_e164(::std::string* conf_e164);

  // optional .mt.TMtId chairman = 11;
  inline bool has_chairman() const;
  inline void clear_chairman();
  static const int kChairmanFieldNumber = 11;
  inline const ::mt::TMtId& chairman() const;
  inline ::mt::TMtId* mutable_chairman();
  inline ::mt::TMtId* release_chairman();
  inline void set_allocated_chairman(::mt::TMtId* chairman);

  // optional .mt.TMtId speaker = 12;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 12;
  inline const ::mt::TMtId& speaker() const;
  inline ::mt::TMtId* mutable_speaker();
  inline ::mt::TMtId* release_speaker();
  inline void set_allocated_speaker(::mt::TMtId* speaker);

  // optional .mt.TMtVmpParam vmp_param = 13;
  inline bool has_vmp_param() const;
  inline void clear_vmp_param();
  static const int kVmpParamFieldNumber = 13;
  inline const ::mt::TMtVmpParam& vmp_param() const;
  inline ::mt::TMtVmpParam* mutable_vmp_param();
  inline ::mt::TMtVmpParam* release_vmp_param();
  inline void set_allocated_vmp_param(::mt::TMtVmpParam* vmp_param);

  // optional .mt.TMtMixParam mix_param = 14;
  inline bool has_mix_param() const;
  inline void clear_mix_param();
  static const int kMixParamFieldNumber = 14;
  inline const ::mt::TMtMixParam& mix_param() const;
  inline ::mt::TMtMixParam* mutable_mix_param();
  inline ::mt::TMtMixParam* release_mix_param();
  inline void set_allocated_mix_param(::mt::TMtMixParam* mix_param);

  // optional bool bsat_dcast_mode = 15;
  inline bool has_bsat_dcast_mode() const;
  inline void clear_bsat_dcast_mode();
  static const int kBsatDcastModeFieldNumber = 15;
  inline bool bsat_dcast_mode() const;
  inline void set_bsat_dcast_mode(bool value);

  // optional .mt.EmMtOpenMode open_mode = 16;
  inline bool has_open_mode() const;
  inline void clear_open_mode();
  static const int kOpenModeFieldNumber = 16;
  inline ::mt::EmMtOpenMode open_mode() const;
  inline void set_open_mode(::mt::EmMtOpenMode value);

  // optional bool is_occupy_vpu = 17;
  inline bool has_is_occupy_vpu() const;
  inline void clear_is_occupy_vpu();
  static const int kIsOccupyVpuFieldNumber = 17;
  inline bool is_occupy_vpu() const;
  inline void set_is_occupy_vpu(bool value);

  // optional .mt.EmMtDualMode dual_mode = 18;
  inline bool has_dual_mode() const;
  inline void clear_dual_mode();
  static const int kDualModeFieldNumber = 18;
  inline ::mt::EmMtDualMode dual_mode() const;
  inline void set_dual_mode(::mt::EmMtDualMode value);

  // optional bool is_all_init_dumb = 19;
  inline bool has_is_all_init_dumb() const;
  inline void clear_is_all_init_dumb();
  static const int kIsAllInitDumbFieldNumber = 19;
  inline bool is_all_init_dumb() const;
  inline void set_is_all_init_dumb(bool value);

  // optional bool is_conf_no_disturb = 20;
  inline bool has_is_conf_no_disturb() const;
  inline void clear_is_conf_no_disturb();
  static const int kIsConfNoDisturbFieldNumber = 20;
  inline bool is_conf_no_disturb() const;
  inline void set_is_conf_no_disturb(bool value);

  // optional bool is_port_mode = 21;
  inline bool has_is_port_mode() const;
  inline void clear_is_port_mode();
  static const int kIsPortModeFieldNumber = 21;
  inline bool is_port_mode() const;
  inline void set_is_port_mode(bool value);

  // optional bool is_force_broadcast = 22;
  inline bool has_is_force_broadcast() const;
  inline void clear_is_force_broadcast();
  static const int kIsForceBroadcastFieldNumber = 22;
  inline bool is_force_broadcast() const;
  inline void set_is_force_broadcast(bool value);

  // optional uint32 record_mode = 23;
  inline bool has_record_mode() const;
  inline void clear_record_mode();
  static const int kRecordModeFieldNumber = 23;
  inline ::google::protobuf::uint32 record_mode() const;
  inline void set_record_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtConfInfo)
 private:
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_sec_bitrate();
  inline void clear_has_sec_bitrate();
  inline void set_has_main_video_res();
  inline void clear_has_main_video_res();
  inline void set_has_ass_video_res();
  inline void clear_has_ass_video_res();
  inline void set_has_talk_hold_time();
  inline void clear_has_talk_hold_time();
  inline void set_has_conf_pwd();
  inline void clear_has_conf_pwd();
  inline void set_has_conf_name();
  inline void clear_has_conf_name();
  inline void set_has_conf_e164();
  inline void clear_has_conf_e164();
  inline void set_has_chairman();
  inline void clear_has_chairman();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_vmp_param();
  inline void clear_has_vmp_param();
  inline void set_has_mix_param();
  inline void clear_has_mix_param();
  inline void set_has_bsat_dcast_mode();
  inline void clear_has_bsat_dcast_mode();
  inline void set_has_open_mode();
  inline void clear_has_open_mode();
  inline void set_has_is_occupy_vpu();
  inline void clear_has_is_occupy_vpu();
  inline void set_has_dual_mode();
  inline void clear_has_dual_mode();
  inline void set_has_is_all_init_dumb();
  inline void clear_has_is_all_init_dumb();
  inline void set_has_is_conf_no_disturb();
  inline void clear_has_is_conf_no_disturb();
  inline void set_has_is_port_mode();
  inline void clear_has_is_port_mode();
  inline void set_has_is_force_broadcast();
  inline void clear_has_is_force_broadcast();
  inline void set_has_record_mode();
  inline void clear_has_record_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTTime* start_time_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 bitrate_;
  ::google::protobuf::uint32 sec_bitrate_;
  int main_video_res_;
  int ass_video_res_;
  ::google::protobuf::uint32 talk_hold_time_;
  ::std::string* conf_pwd_;
  ::std::string* conf_name_;
  ::std::string* conf_e164_;
  ::mt::TMtId* chairman_;
  ::mt::TMtId* speaker_;
  ::mt::TMtVmpParam* vmp_param_;
  ::mt::TMtMixParam* mix_param_;
  int open_mode_;
  bool bsat_dcast_mode_;
  bool is_occupy_vpu_;
  bool is_all_init_dumb_;
  bool is_conf_no_disturb_;
  int dual_mode_;
  bool is_port_mode_;
  bool is_force_broadcast_;
  ::google::protobuf::uint32 record_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtConfInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TPeerCapabilityInfo : public ::google::protobuf::Message {
 public:
  TPeerCapabilityInfo();
  virtual ~TPeerCapabilityInfo();

  TPeerCapabilityInfo(const TPeerCapabilityInfo& from);

  inline TPeerCapabilityInfo& operator=(const TPeerCapabilityInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TPeerCapabilityInfo& default_instance();

  void Swap(TPeerCapabilityInfo* other);

  // implements Message ----------------------------------------------

  TPeerCapabilityInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TPeerCapabilityInfo& from);
  void MergeFrom(const TPeerCapabilityInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bMix = 1;
  inline bool has_bmix() const;
  inline void clear_bmix();
  static const int kBMixFieldNumber = 1;
  inline bool bmix() const;
  inline void set_bmix(bool value);

  // optional bool bVAC = 2;
  inline bool has_bvac() const;
  inline void clear_bvac();
  static const int kBVACFieldNumber = 2;
  inline bool bvac() const;
  inline void set_bvac(bool value);

  // optional bool bCustomVMP = 3;
  inline bool has_bcustomvmp() const;
  inline void clear_bcustomvmp();
  static const int kBCustomVMPFieldNumber = 3;
  inline bool bcustomvmp() const;
  inline void set_bcustomvmp(bool value);

  // optional bool bAutoVMP = 4;
  inline bool has_bautovmp() const;
  inline void clear_bautovmp();
  static const int kBAutoVMPFieldNumber = 4;
  inline bool bautovmp() const;
  inline void set_bautovmp(bool value);

  // optional bool bEndConf = 5;
  inline bool has_bendconf() const;
  inline void clear_bendconf();
  static const int kBEndConfFieldNumber = 5;
  inline bool bendconf() const;
  inline void set_bendconf(bool value);

  // optional bool bInvateMt = 6;
  inline bool has_binvatemt() const;
  inline void clear_binvatemt();
  static const int kBInvateMtFieldNumber = 6;
  inline bool binvatemt() const;
  inline void set_binvatemt(bool value);

  // optional bool bDropMt = 7;
  inline bool has_bdropmt() const;
  inline void clear_bdropmt();
  static const int kBDropMtFieldNumber = 7;
  inline bool bdropmt() const;
  inline void set_bdropmt(bool value);

  // optional bool bSelSpeaker = 8;
  inline bool has_bselspeaker() const;
  inline void clear_bselspeaker();
  static const int kBSelSpeakerFieldNumber = 8;
  inline bool bselspeaker() const;
  inline void set_bselspeaker(bool value);

  // optional bool bSelChair = 9;
  inline bool has_bselchair() const;
  inline void clear_bselchair();
  static const int kBSelChairFieldNumber = 9;
  inline bool bselchair() const;
  inline void set_bselchair(bool value);

  // optional bool bSelSource = 10;
  inline bool has_bselsource() const;
  inline void clear_bselsource();
  static const int kBSelSourceFieldNumber = 10;
  inline bool bselsource() const;
  inline void set_bselsource(bool value);

  // optional bool bFECC = 11;
  inline bool has_bfecc() const;
  inline void clear_bfecc();
  static const int kBFECCFieldNumber = 11;
  inline bool bfecc() const;
  inline void set_bfecc(bool value);

  // optional bool bQuiet = 12;
  inline bool has_bquiet() const;
  inline void clear_bquiet();
  static const int kBQuietFieldNumber = 12;
  inline bool bquiet() const;
  inline void set_bquiet(bool value);

  // optional bool bMute = 13;
  inline bool has_bmute() const;
  inline void clear_bmute();
  static const int kBMuteFieldNumber = 13;
  inline bool bmute() const;
  inline void set_bmute(bool value);

  // optional bool bConfReq = 14;
  inline bool has_bconfreq() const;
  inline void clear_bconfreq();
  static const int kBConfReqFieldNumber = 14;
  inline bool bconfreq() const;
  inline void set_bconfreq(bool value);

  // optional bool bOnlineList = 15;
  inline bool has_bonlinelist() const;
  inline void clear_bonlinelist();
  static const int kBOnlineListFieldNumber = 15;
  inline bool bonlinelist() const;
  inline void set_bonlinelist(bool value);

  // optional bool bOfflineList = 16;
  inline bool has_bofflinelist() const;
  inline void clear_bofflinelist();
  static const int kBOfflineListFieldNumber = 16;
  inline bool bofflinelist() const;
  inline void set_bofflinelist(bool value);

  // optional bool bPicSwitch = 17;
  inline bool has_bpicswitch() const;
  inline void clear_bpicswitch();
  static const int kBPicSwitchFieldNumber = 17;
  inline bool bpicswitch() const;
  inline void set_bpicswitch(bool value);

  // optional bool bSelSpeakingUser = 18;
  inline bool has_bselspeakinguser() const;
  inline void clear_bselspeakinguser();
  static const int kBSelSpeakingUserFieldNumber = 18;
  inline bool bselspeakinguser() const;
  inline void set_bselspeakinguser(bool value);

  // optional bool bForceBroadcast = 19;
  inline bool has_bforcebroadcast() const;
  inline void clear_bforcebroadcast();
  static const int kBForceBroadcastFieldNumber = 19;
  inline bool bforcebroadcast() const;
  inline void set_bforcebroadcast(bool value);

  // @@protoc_insertion_point(class_scope:mt.TPeerCapabilityInfo)
 private:
  inline void set_has_bmix();
  inline void clear_has_bmix();
  inline void set_has_bvac();
  inline void clear_has_bvac();
  inline void set_has_bcustomvmp();
  inline void clear_has_bcustomvmp();
  inline void set_has_bautovmp();
  inline void clear_has_bautovmp();
  inline void set_has_bendconf();
  inline void clear_has_bendconf();
  inline void set_has_binvatemt();
  inline void clear_has_binvatemt();
  inline void set_has_bdropmt();
  inline void clear_has_bdropmt();
  inline void set_has_bselspeaker();
  inline void clear_has_bselspeaker();
  inline void set_has_bselchair();
  inline void clear_has_bselchair();
  inline void set_has_bselsource();
  inline void clear_has_bselsource();
  inline void set_has_bfecc();
  inline void clear_has_bfecc();
  inline void set_has_bquiet();
  inline void clear_has_bquiet();
  inline void set_has_bmute();
  inline void clear_has_bmute();
  inline void set_has_bconfreq();
  inline void clear_has_bconfreq();
  inline void set_has_bonlinelist();
  inline void clear_has_bonlinelist();
  inline void set_has_bofflinelist();
  inline void clear_has_bofflinelist();
  inline void set_has_bpicswitch();
  inline void clear_has_bpicswitch();
  inline void set_has_bselspeakinguser();
  inline void clear_has_bselspeakinguser();
  inline void set_has_bforcebroadcast();
  inline void clear_has_bforcebroadcast();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool bmix_;
  bool bvac_;
  bool bcustomvmp_;
  bool bautovmp_;
  bool bendconf_;
  bool binvatemt_;
  bool bdropmt_;
  bool bselspeaker_;
  bool bselchair_;
  bool bselsource_;
  bool bfecc_;
  bool bquiet_;
  bool bmute_;
  bool bconfreq_;
  bool bonlinelist_;
  bool bofflinelist_;
  bool bpicswitch_;
  bool bselspeakinguser_;
  bool bforcebroadcast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TPeerCapabilityInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtMixParam : public ::google::protobuf::Message {
 public:
  TMtMixParam();
  virtual ~TMtMixParam();

  TMtMixParam(const TMtMixParam& from);

  inline TMtMixParam& operator=(const TMtMixParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtMixParam& default_instance();

  void Swap(TMtMixParam* other);

  // implements Message ----------------------------------------------

  TMtMixParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtMixParam& from);
  void MergeFrom(const TMtMixParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtMixType discuss_mode = 1;
  inline bool has_discuss_mode() const;
  inline void clear_discuss_mode();
  static const int kDiscussModeFieldNumber = 1;
  inline ::mt::EmMtMixType discuss_mode() const;
  inline void set_discuss_mode(::mt::EmMtMixType value);

  // optional .mt.TRpMtId mix_item = 2;
  inline bool has_mix_item() const;
  inline void clear_mix_item();
  static const int kMixItemFieldNumber = 2;
  inline const ::mt::TRpMtId& mix_item() const;
  inline ::mt::TRpMtId* mutable_mix_item();
  inline ::mt::TRpMtId* release_mix_item();
  inline void set_allocated_mix_item(::mt::TRpMtId* mix_item);

  // @@protoc_insertion_point(class_scope:mt.TMtMixParam)
 private:
  inline void set_has_discuss_mode();
  inline void clear_has_discuss_mode();
  inline void set_has_mix_item();
  inline void clear_has_mix_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TRpMtId* mix_item_;
  int discuss_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtMixParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVmpParam : public ::google::protobuf::Message {
 public:
  TMtVmpParam();
  virtual ~TMtVmpParam();

  TMtVmpParam(const TMtVmpParam& from);

  inline TMtVmpParam& operator=(const TMtVmpParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVmpParam& default_instance();

  void Swap(TMtVmpParam* other);

  // implements Message ----------------------------------------------

  TMtVmpParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVmpParam& from);
  void MergeFrom(const TMtVmpParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtVmpMode vmp_mode = 1;
  inline bool has_vmp_mode() const;
  inline void clear_vmp_mode();
  static const int kVmpModeFieldNumber = 1;
  inline ::mt::EmMtVmpMode vmp_mode() const;
  inline void set_vmp_mode(::mt::EmMtVmpMode value);

  // optional .mt.EmMtVmpStyle vmp_style = 2;
  inline bool has_vmp_style() const;
  inline void clear_vmp_style();
  static const int kVmpStyleFieldNumber = 2;
  inline ::mt::EmMtVmpStyle vmp_style() const;
  inline void set_vmp_style(::mt::EmMtVmpStyle value);

  // repeated .mt.TMtVmpItem mt_item = 3;
  inline int mt_item_size() const;
  inline void clear_mt_item();
  static const int kMtItemFieldNumber = 3;
  inline const ::mt::TMtVmpItem& mt_item(int index) const;
  inline ::mt::TMtVmpItem* mutable_mt_item(int index);
  inline ::mt::TMtVmpItem* add_mt_item();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtVmpItem >&
      mt_item() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtVmpItem >*
      mutable_mt_item();

  // optional bool bvmp_broadcast = 4;
  inline bool has_bvmp_broadcast() const;
  inline void clear_bvmp_broadcast();
  static const int kBvmpBroadcastFieldNumber = 4;
  inline bool bvmp_broadcast() const;
  inline void set_bvmp_broadcast(bool value);

  // optional bool badd_mmb_alias = 5;
  inline bool has_badd_mmb_alias() const;
  inline void clear_badd_mmb_alias();
  static const int kBaddMmbAliasFieldNumber = 5;
  inline bool badd_mmb_alias() const;
  inline void set_badd_mmb_alias(bool value);

  // @@protoc_insertion_point(class_scope:mt.TMtVmpParam)
 private:
  inline void set_has_vmp_mode();
  inline void clear_has_vmp_mode();
  inline void set_has_vmp_style();
  inline void clear_has_vmp_style();
  inline void set_has_bvmp_broadcast();
  inline void clear_has_bvmp_broadcast();
  inline void set_has_badd_mmb_alias();
  inline void clear_has_badd_mmb_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int vmp_mode_;
  int vmp_style_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMtVmpItem > mt_item_;
  bool bvmp_broadcast_;
  bool badd_mmb_alias_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtVmpParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVmpItem : public ::google::protobuf::Message {
 public:
  TMtVmpItem();
  virtual ~TMtVmpItem();

  TMtVmpItem(const TMtVmpItem& from);

  inline TMtVmpItem& operator=(const TMtVmpItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVmpItem& default_instance();

  void Swap(TMtVmpItem* other);

  // implements Message ----------------------------------------------

  TMtVmpItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVmpItem& from);
  void MergeFrom(const TMtVmpItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMtId mt_id = 1;
  inline bool has_mt_id() const;
  inline void clear_mt_id();
  static const int kMtIdFieldNumber = 1;
  inline const ::mt::TMtId& mt_id() const;
  inline ::mt::TMtId* mutable_mt_id();
  inline ::mt::TMtId* release_mt_id();
  inline void set_allocated_mt_id(::mt::TMtId* mt_id);

  // optional .mt.EmMtVMPMmbType mt_type = 2;
  inline bool has_mt_type() const;
  inline void clear_mt_type();
  static const int kMtTypeFieldNumber = 2;
  inline ::mt::EmMtVMPMmbType mt_type() const;
  inline void set_mt_type(::mt::EmMtVMPMmbType value);

  // optional .mt.EmCodecComponentIndex chan_idx = 3;
  inline bool has_chan_idx() const;
  inline void clear_chan_idx();
  static const int kChanIdxFieldNumber = 3;
  inline ::mt::EmCodecComponentIndex chan_idx() const;
  inline void set_chan_idx(::mt::EmCodecComponentIndex value);

  // optional uint32 mem_idx = 4;
  inline bool has_mem_idx() const;
  inline void clear_mem_idx();
  static const int kMemIdxFieldNumber = 4;
  inline ::google::protobuf::uint32 mem_idx() const;
  inline void set_mem_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtVmpItem)
 private:
  inline void set_has_mt_id();
  inline void clear_has_mt_id();
  inline void set_has_mt_type();
  inline void clear_has_mt_type();
  inline void set_has_chan_idx();
  inline void clear_has_chan_idx();
  inline void set_has_mem_idx();
  inline void clear_has_mem_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMtId* mt_id_;
  int mt_type_;
  int chan_idx_;
  ::google::protobuf::uint32 mem_idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtVmpItem* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtPollInfo : public ::google::protobuf::Message {
 public:
  TMtPollInfo();
  virtual ~TMtPollInfo();

  TMtPollInfo(const TMtPollInfo& from);

  inline TMtPollInfo& operator=(const TMtPollInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtPollInfo& default_instance();

  void Swap(TMtPollInfo* other);

  // implements Message ----------------------------------------------

  TMtPollInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtPollInfo& from);
  void MergeFrom(const TMtPollInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtMediaType media_type = 1;
  inline bool has_media_type() const;
  inline void clear_media_type();
  static const int kMediaTypeFieldNumber = 1;
  inline ::mt::EmMtMediaType media_type() const;
  inline void set_media_type(::mt::EmMtMediaType value);

  // optional .mt.EmAction action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline ::mt::EmAction action() const;
  inline void set_action(::mt::EmAction value);

  // optional uint32 keep_time = 3;
  inline bool has_keep_time() const;
  inline void clear_keep_time();
  static const int kKeepTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 keep_time() const;
  inline void set_keep_time(::google::protobuf::uint32 value);

  // repeated .mt.TMtId mtlist = 4;
  inline int mtlist_size() const;
  inline void clear_mtlist();
  static const int kMtlistFieldNumber = 4;
  inline const ::mt::TMtId& mtlist(int index) const;
  inline ::mt::TMtId* mutable_mtlist(int index);
  inline ::mt::TMtId* add_mtlist();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtId >&
      mtlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtId >*
      mutable_mtlist();

  // optional uint32 poll_scheme_id = 5;
  inline bool has_poll_scheme_id() const;
  inline void clear_poll_scheme_id();
  static const int kPollSchemeIdFieldNumber = 5;
  inline ::google::protobuf::uint32 poll_scheme_id() const;
  inline void set_poll_scheme_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtPollInfo)
 private:
  inline void set_has_media_type();
  inline void clear_has_media_type();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_keep_time();
  inline void clear_has_keep_time();
  inline void set_has_poll_scheme_id();
  inline void clear_has_poll_scheme_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int media_type_;
  int action_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMtId > mtlist_;
  ::google::protobuf::uint32 keep_time_;
  ::google::protobuf::uint32 poll_scheme_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtPollInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVideoSourceInfo : public ::google::protobuf::Message {
 public:
  TVideoSourceInfo();
  virtual ~TVideoSourceInfo();

  TVideoSourceInfo(const TVideoSourceInfo& from);

  inline TVideoSourceInfo& operator=(const TVideoSourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVideoSourceInfo& default_instance();

  void Swap(TVideoSourceInfo* other);

  // implements Message ----------------------------------------------

  TVideoSourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVideoSourceInfo& from);
  void MergeFrom(const TVideoSourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 vid_port = 1;
  inline bool has_vid_port() const;
  inline void clear_vid_port();
  static const int kVidPortFieldNumber = 1;
  inline ::google::protobuf::uint32 vid_port() const;
  inline void set_vid_port(::google::protobuf::uint32 value);

  // optional bytes port_name = 2;
  inline bool has_port_name() const;
  inline void clear_port_name();
  static const int kPortNameFieldNumber = 2;
  inline const ::std::string& port_name() const;
  inline void set_port_name(const ::std::string& value);
  inline void set_port_name(const char* value);
  inline void set_port_name(const void* value, size_t size);
  inline ::std::string* mutable_port_name();
  inline ::std::string* release_port_name();
  inline void set_allocated_port_name(::std::string* port_name);

  // @@protoc_insertion_point(class_scope:mt.TVideoSourceInfo)
 private:
  inline void set_has_vid_port();
  inline void clear_has_vid_port();
  inline void set_has_port_name();
  inline void clear_has_port_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* port_name_;
  ::google::protobuf::uint32 vid_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TVideoSourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpVideoSourceInfo : public ::google::protobuf::Message {
 public:
  TRpVideoSourceInfo();
  virtual ~TRpVideoSourceInfo();

  TRpVideoSourceInfo(const TRpVideoSourceInfo& from);

  inline TRpVideoSourceInfo& operator=(const TRpVideoSourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpVideoSourceInfo& default_instance();

  void Swap(TRpVideoSourceInfo* other);

  // implements Message ----------------------------------------------

  TRpVideoSourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpVideoSourceInfo& from);
  void MergeFrom(const TRpVideoSourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVideoSourceInfo vid_source_info = 1;
  inline int vid_source_info_size() const;
  inline void clear_vid_source_info();
  static const int kVidSourceInfoFieldNumber = 1;
  inline const ::mt::TVideoSourceInfo& vid_source_info(int index) const;
  inline ::mt::TVideoSourceInfo* mutable_vid_source_info(int index);
  inline ::mt::TVideoSourceInfo* add_vid_source_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVideoSourceInfo >&
      vid_source_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVideoSourceInfo >*
      mutable_vid_source_info();

  // @@protoc_insertion_point(class_scope:mt.TRpVideoSourceInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVideoSourceInfo > vid_source_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TRpVideoSourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVideoAlias : public ::google::protobuf::Message {
 public:
  TMtVideoAlias();
  virtual ~TMtVideoAlias();

  TMtVideoAlias(const TMtVideoAlias& from);

  inline TMtVideoAlias& operator=(const TMtVideoAlias& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVideoAlias& default_instance();

  void Swap(TMtVideoAlias* other);

  // implements Message ----------------------------------------------

  TMtVideoAlias* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVideoAlias& from);
  void MergeFrom(const TMtVideoAlias& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponent video_type = 1;
  inline bool has_video_type() const;
  inline void clear_video_type();
  static const int kVideoTypeFieldNumber = 1;
  inline ::mt::EmCodecComponent video_type() const;
  inline void set_video_type(::mt::EmCodecComponent value);

  // optional .mt.EmCodecComponentIndex video_id = 2;
  inline bool has_video_id() const;
  inline void clear_video_id();
  static const int kVideoIdFieldNumber = 2;
  inline ::mt::EmCodecComponentIndex video_id() const;
  inline void set_video_id(::mt::EmCodecComponentIndex value);

  // optional .mt.TRpVideoSourceInfo video_source_list = 3;
  inline bool has_video_source_list() const;
  inline void clear_video_source_list();
  static const int kVideoSourceListFieldNumber = 3;
  inline const ::mt::TRpVideoSourceInfo& video_source_list() const;
  inline ::mt::TRpVideoSourceInfo* mutable_video_source_list();
  inline ::mt::TRpVideoSourceInfo* release_video_source_list();
  inline void set_allocated_video_source_list(::mt::TRpVideoSourceInfo* video_source_list);

  // @@protoc_insertion_point(class_scope:mt.TMtVideoAlias)
 private:
  inline void set_has_video_type();
  inline void clear_has_video_type();
  inline void set_has_video_id();
  inline void clear_has_video_id();
  inline void set_has_video_source_list();
  inline void clear_has_video_source_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_type_;
  int video_id_;
  ::mt::TRpVideoSourceInfo* video_source_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtVideoAlias* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtVideoAlias : public ::google::protobuf::Message {
 public:
  TRpMtVideoAlias();
  virtual ~TRpMtVideoAlias();

  TRpMtVideoAlias(const TRpMtVideoAlias& from);

  inline TRpMtVideoAlias& operator=(const TRpMtVideoAlias& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtVideoAlias& default_instance();

  void Swap(TRpMtVideoAlias* other);

  // implements Message ----------------------------------------------

  TRpMtVideoAlias* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtVideoAlias& from);
  void MergeFrom(const TRpMtVideoAlias& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtVideoAlias video_alias_list = 1;
  inline int video_alias_list_size() const;
  inline void clear_video_alias_list();
  static const int kVideoAliasListFieldNumber = 1;
  inline const ::mt::TMtVideoAlias& video_alias_list(int index) const;
  inline ::mt::TMtVideoAlias* mutable_video_alias_list(int index);
  inline ::mt::TMtVideoAlias* add_video_alias_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtVideoAlias >&
      video_alias_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtVideoAlias >*
      mutable_video_alias_list();

  // @@protoc_insertion_point(class_scope:mt.TRpMtVideoAlias)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtVideoAlias > video_alias_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TRpMtVideoAlias* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtEntityStatus : public ::google::protobuf::Message {
 public:
  TMtEntityStatus();
  virtual ~TMtEntityStatus();

  TMtEntityStatus(const TMtEntityStatus& from);

  inline TMtEntityStatus& operator=(const TMtEntityStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtEntityStatus& default_instance();

  void Swap(TMtEntityStatus* other);

  // implements Message ----------------------------------------------

  TMtEntityStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtEntityStatus& from);
  void MergeFrom(const TMtEntityStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMtId label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::mt::TMtId& label() const;
  inline ::mt::TMtId* mutable_label();
  inline ::mt::TMtId* release_label();
  inline void set_allocated_label(::mt::TMtId* label);

  // optional .mt.TTerStatus ter_status = 2;
  inline bool has_ter_status() const;
  inline void clear_ter_status();
  static const int kTerStatusFieldNumber = 2;
  inline const ::mt::TTerStatus& ter_status() const;
  inline ::mt::TTerStatus* mutable_ter_status();
  inline ::mt::TTerStatus* release_ter_status();
  inline void set_allocated_ter_status(::mt::TTerStatus* ter_status);

  // @@protoc_insertion_point(class_scope:mt.TMtEntityStatus)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_ter_status();
  inline void clear_has_ter_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMtId* label_;
  ::mt::TTerStatus* ter_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtEntityStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtEntityStatus : public ::google::protobuf::Message {
 public:
  TRpMtEntityStatus();
  virtual ~TRpMtEntityStatus();

  TRpMtEntityStatus(const TRpMtEntityStatus& from);

  inline TRpMtEntityStatus& operator=(const TRpMtEntityStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtEntityStatus& default_instance();

  void Swap(TRpMtEntityStatus* other);

  // implements Message ----------------------------------------------

  TRpMtEntityStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtEntityStatus& from);
  void MergeFrom(const TRpMtEntityStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtEntityStatus mt_status = 1;
  inline int mt_status_size() const;
  inline void clear_mt_status();
  static const int kMtStatusFieldNumber = 1;
  inline const ::mt::TMtEntityStatus& mt_status(int index) const;
  inline ::mt::TMtEntityStatus* mutable_mt_status(int index);
  inline ::mt::TMtEntityStatus* add_mt_status();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtEntityStatus >&
      mt_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtEntityStatus >*
      mutable_mt_status();

  // @@protoc_insertion_point(class_scope:mt.TRpMtEntityStatus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtEntityStatus > mt_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TRpMtEntityStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVideoInfo : public ::google::protobuf::Message {
 public:
  TVideoInfo();
  virtual ~TVideoInfo();

  TVideoInfo(const TVideoInfo& from);

  inline TVideoInfo& operator=(const TVideoInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVideoInfo& default_instance();

  void Swap(TVideoInfo* other);

  // implements Message ----------------------------------------------

  TVideoInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVideoInfo& from);
  void MergeFrom(const TVideoInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional bool bfecc_enable = 2;
  inline bool has_bfecc_enable() const;
  inline void clear_bfecc_enable();
  static const int kBfeccEnableFieldNumber = 2;
  inline bool bfecc_enable() const;
  inline void set_bfecc_enable(bool value);

  // optional bool has_video = 3;
  inline bool has_has_video() const;
  inline void clear_has_video();
  static const int kHasVideoFieldNumber = 3;
  inline bool has_video() const;
  inline void set_has_video(bool value);

  // optional uint32 video_src = 4;
  inline bool has_video_src() const;
  inline void clear_video_src();
  static const int kVideoSrcFieldNumber = 4;
  inline ::google::protobuf::uint32 video_src() const;
  inline void set_video_src(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TVideoInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_bfecc_enable();
  inline void clear_has_bfecc_enable();
  inline void set_has_has_video();
  inline void clear_has_has_video();
  inline void set_has_video_src();
  inline void clear_has_video_src();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  bool bfecc_enable_;
  bool has_video_;
  ::google::protobuf::uint32 video_src_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TVideoInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpVideoInfo : public ::google::protobuf::Message {
 public:
  TRpVideoInfo();
  virtual ~TRpVideoInfo();

  TRpVideoInfo(const TRpVideoInfo& from);

  inline TRpVideoInfo& operator=(const TRpVideoInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpVideoInfo& default_instance();

  void Swap(TRpVideoInfo* other);

  // implements Message ----------------------------------------------

  TRpVideoInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpVideoInfo& from);
  void MergeFrom(const TRpVideoInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TVideoInfo videoinfo = 1;
  inline int videoinfo_size() const;
  inline void clear_videoinfo();
  static const int kVideoinfoFieldNumber = 1;
  inline const ::mt::TVideoInfo& videoinfo(int index) const;
  inline ::mt::TVideoInfo* mutable_videoinfo(int index);
  inline ::mt::TVideoInfo* add_videoinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVideoInfo >&
      videoinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVideoInfo >*
      mutable_videoinfo();

  // @@protoc_insertion_point(class_scope:mt.TRpVideoInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TVideoInfo > videoinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TRpVideoInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TTerStatus : public ::google::protobuf::Message {
 public:
  TTerStatus();
  virtual ~TTerStatus();

  TTerStatus(const TTerStatus& from);

  inline TTerStatus& operator=(const TTerStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTerStatus& default_instance();

  void Swap(TTerStatus* other);

  // implements Message ----------------------------------------------

  TTerStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TTerStatus& from);
  void MergeFrom(const TTerStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmMtModel mt_model = 1;
  inline bool has_mt_model() const;
  inline void clear_mt_model();
  static const int kMtModelFieldNumber = 1;
  inline ::mt::EmMtModel mt_model() const;
  inline void set_mt_model(::mt::EmMtModel value);

  // optional uint32 enc_vol = 2;
  inline bool has_enc_vol() const;
  inline void clear_enc_vol();
  static const int kEncVolFieldNumber = 2;
  inline ::google::protobuf::uint32 enc_vol() const;
  inline void set_enc_vol(::google::protobuf::uint32 value);

  // optional uint32 dec_vol = 3;
  inline bool has_dec_vol() const;
  inline void clear_dec_vol();
  static const int kDecVolFieldNumber = 3;
  inline ::google::protobuf::uint32 dec_vol() const;
  inline void set_dec_vol(::google::protobuf::uint32 value);

  // optional bool bmute = 4;
  inline bool has_bmute() const;
  inline void clear_bmute();
  static const int kBmuteFieldNumber = 4;
  inline bool bmute() const;
  inline void set_bmute(bool value);

  // optional bool bquiet = 5;
  inline bool has_bquiet() const;
  inline void clear_bquiet();
  static const int kBquietFieldNumber = 5;
  inline bool bquiet() const;
  inline void set_bquiet(bool value);

  // optional bool bmatrix = 6;
  inline bool has_bmatrix() const;
  inline void clear_bmatrix();
  static const int kBmatrixFieldNumber = 6;
  inline bool bmatrix() const;
  inline void set_bmatrix(bool value);

  // repeated .mt.TVideoInfo videoinfo = 7;
  inline int videoinfo_size() const;
  inline void clear_videoinfo();
  static const int kVideoinfoFieldNumber = 7;
  inline const ::mt::TVideoInfo& videoinfo(int index) const;
  inline ::mt::TVideoInfo* mutable_videoinfo(int index);
  inline ::mt::TVideoInfo* add_videoinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TVideoInfo >&
      videoinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TVideoInfo >*
      mutable_videoinfo();

  // optional .mt.EmMtMediaType view_type = 8;
  inline bool has_view_type() const;
  inline void clear_view_type();
  static const int kViewTypeFieldNumber = 8;
  inline ::mt::EmMtMediaType view_type() const;
  inline void set_view_type(::mt::EmMtMediaType value);

  // @@protoc_insertion_point(class_scope:mt.TTerStatus)
 private:
  inline void set_has_mt_model();
  inline void clear_has_mt_model();
  inline void set_has_enc_vol();
  inline void clear_has_enc_vol();
  inline void set_has_dec_vol();
  inline void clear_has_dec_vol();
  inline void set_has_bmute();
  inline void clear_has_bmute();
  inline void set_has_bquiet();
  inline void clear_has_bquiet();
  inline void set_has_bmatrix();
  inline void clear_has_bmatrix();
  inline void set_has_view_type();
  inline void clear_has_view_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int mt_model_;
  ::google::protobuf::uint32 enc_vol_;
  ::google::protobuf::uint32 dec_vol_;
  bool bmute_;
  bool bquiet_;
  bool bmatrix_;
  ::google::protobuf::RepeatedPtrField< ::mt::TVideoInfo > videoinfo_;
  int view_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TTerStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TShortMsg : public ::google::protobuf::Message {
 public:
  TShortMsg();
  virtual ~TShortMsg();

  TShortMsg(const TShortMsg& from);

  inline TShortMsg& operator=(const TShortMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TShortMsg& default_instance();

  void Swap(TShortMsg* other);

  // implements Message ----------------------------------------------

  TShortMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TShortMsg& from);
  void MergeFrom(const TShortMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmSMSType sms_type = 1;
  inline bool has_sms_type() const;
  inline void clear_sms_type();
  static const int kSmsTypeFieldNumber = 1;
  inline ::mt::EmSMSType sms_type() const;
  inline void set_sms_type(::mt::EmSMSType value);

  // optional .mt.TMtId mt_src = 2;
  inline bool has_mt_src() const;
  inline void clear_mt_src();
  static const int kMtSrcFieldNumber = 2;
  inline const ::mt::TMtId& mt_src() const;
  inline ::mt::TMtId* mutable_mt_src();
  inline ::mt::TMtId* release_mt_src();
  inline void set_allocated_mt_src(::mt::TMtId* mt_src);

  // repeated .mt.TMtId mt_dst = 3;
  inline int mt_dst_size() const;
  inline void clear_mt_dst();
  static const int kMtDstFieldNumber = 3;
  inline const ::mt::TMtId& mt_dst(int index) const;
  inline ::mt::TMtId* mutable_mt_dst(int index);
  inline ::mt::TMtId* add_mt_dst();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtId >&
      mt_dst() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtId >*
      mutable_mt_dst();

  // optional .mt.EmRollMsgSpeed roll_speed = 4;
  inline bool has_roll_speed() const;
  inline void clear_roll_speed();
  static const int kRollSpeedFieldNumber = 4;
  inline ::mt::EmRollMsgSpeed roll_speed() const;
  inline void set_roll_speed(::mt::EmRollMsgSpeed value);

  // optional uint32 roll_times = 5;
  inline bool has_roll_times() const;
  inline void clear_roll_times();
  static const int kRollTimesFieldNumber = 5;
  inline ::google::protobuf::uint32 roll_times() const;
  inline void set_roll_times(::google::protobuf::uint32 value);

  // optional string text = 6;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 6;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:mt.TShortMsg)
 private:
  inline void set_has_sms_type();
  inline void clear_has_sms_type();
  inline void set_has_mt_src();
  inline void clear_has_mt_src();
  inline void set_has_roll_speed();
  inline void clear_has_roll_speed();
  inline void set_has_roll_times();
  inline void clear_has_roll_times();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMtId* mt_src_;
  int sms_type_;
  int roll_speed_;
  ::google::protobuf::RepeatedPtrField< ::mt::TMtId > mt_dst_;
  ::std::string* text_;
  ::google::protobuf::uint32 roll_times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TShortMsg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtRegistReq : public ::google::protobuf::Message {
 public:
  TMtRegistReq();
  virtual ~TMtRegistReq();

  TMtRegistReq(const TMtRegistReq& from);

  inline TMtRegistReq& operator=(const TMtRegistReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtRegistReq& default_instance();

  void Swap(TMtRegistReq* other);

  // implements Message ----------------------------------------------

  TMtRegistReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtRegistReq& from);
  void MergeFrom(const TMtRegistReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TRpMtAlias alias = 1;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 1;
  inline const ::mt::TRpMtAlias& alias() const;
  inline ::mt::TRpMtAlias* mutable_alias();
  inline ::mt::TRpMtAlias* release_alias();
  inline void set_allocated_alias(::mt::TRpMtAlias* alias);

  // optional .mt.TNetAddr local_addr = 2;
  inline bool has_local_addr() const;
  inline void clear_local_addr();
  static const int kLocalAddrFieldNumber = 2;
  inline const ::mt::TNetAddr& local_addr() const;
  inline ::mt::TNetAddr* mutable_local_addr();
  inline ::mt::TNetAddr* release_local_addr();
  inline void set_allocated_local_addr(::mt::TNetAddr* local_addr);

  // optional .mt.TNetAddr gk_addr = 3;
  inline bool has_gk_addr() const;
  inline void clear_gk_addr();
  static const int kGkAddrFieldNumber = 3;
  inline const ::mt::TNetAddr& gk_addr() const;
  inline ::mt::TNetAddr* mutable_gk_addr();
  inline ::mt::TNetAddr* release_gk_addr();
  inline void set_allocated_gk_addr(::mt::TNetAddr* gk_addr);

  // optional .mt.TNetAddr sip_reg_addr = 4;
  inline bool has_sip_reg_addr() const;
  inline void clear_sip_reg_addr();
  static const int kSipRegAddrFieldNumber = 4;
  inline const ::mt::TNetAddr& sip_reg_addr() const;
  inline ::mt::TNetAddr* mutable_sip_reg_addr();
  inline ::mt::TNetAddr* release_sip_reg_addr();
  inline void set_allocated_sip_reg_addr(::mt::TNetAddr* sip_reg_addr);

  // optional uint32 time_live = 5;
  inline bool has_time_live() const;
  inline void clear_time_live();
  static const int kTimeLiveFieldNumber = 5;
  inline ::google::protobuf::uint32 time_live() const;
  inline void set_time_live(::google::protobuf::uint32 value);

  // optional .mt.TMtAlias username = 6;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 6;
  inline const ::mt::TMtAlias& username() const;
  inline ::mt::TMtAlias* mutable_username();
  inline ::mt::TMtAlias* release_username();
  inline void set_allocated_username(::mt::TMtAlias* username);

  // optional string password = 7;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 7;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string productid = 8;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductidFieldNumber = 8;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // optional string versionid = 9;
  inline bool has_versionid() const;
  inline void clear_versionid();
  static const int kVersionidFieldNumber = 9;
  inline const ::std::string& versionid() const;
  inline void set_versionid(const ::std::string& value);
  inline void set_versionid(const char* value);
  inline void set_versionid(const char* value, size_t size);
  inline ::std::string* mutable_versionid();
  inline ::std::string* release_versionid();
  inline void set_allocated_versionid(::std::string* versionid);

  // optional string sip_domain = 10;
  inline bool has_sip_domain() const;
  inline void clear_sip_domain();
  static const int kSipDomainFieldNumber = 10;
  inline const ::std::string& sip_domain() const;
  inline void set_sip_domain(const ::std::string& value);
  inline void set_sip_domain(const char* value);
  inline void set_sip_domain(const char* value, size_t size);
  inline ::std::string* mutable_sip_domain();
  inline ::std::string* release_sip_domain();
  inline void set_allocated_sip_domain(::std::string* sip_domain);

  // optional string domain = 11;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 11;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // @@protoc_insertion_point(class_scope:mt.TMtRegistReq)
 private:
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_local_addr();
  inline void clear_has_local_addr();
  inline void set_has_gk_addr();
  inline void clear_has_gk_addr();
  inline void set_has_sip_reg_addr();
  inline void clear_has_sip_reg_addr();
  inline void set_has_time_live();
  inline void clear_has_time_live();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_versionid();
  inline void clear_has_versionid();
  inline void set_has_sip_domain();
  inline void clear_has_sip_domain();
  inline void set_has_domain();
  inline void clear_has_domain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TRpMtAlias* alias_;
  ::mt::TNetAddr* local_addr_;
  ::mt::TNetAddr* gk_addr_;
  ::mt::TNetAddr* sip_reg_addr_;
  ::mt::TMtAlias* username_;
  ::std::string* password_;
  ::std::string* productid_;
  ::std::string* versionid_;
  ::std::string* sip_domain_;
  ::std::string* domain_;
  ::google::protobuf::uint32 time_live_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtRegistReq* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TGkRegInfo : public ::google::protobuf::Message {
 public:
  TGkRegInfo();
  virtual ~TGkRegInfo();

  TGkRegInfo(const TGkRegInfo& from);

  inline TGkRegInfo& operator=(const TGkRegInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGkRegInfo& default_instance();

  void Swap(TGkRegInfo* other);

  // implements Message ----------------------------------------------

  TGkRegInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGkRegInfo& from);
  void MergeFrom(const TGkRegInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bregisted = 1;
  inline bool has_bregisted() const;
  inline void clear_bregisted();
  static const int kBregistedFieldNumber = 1;
  inline bool bregisted() const;
  inline void set_bregisted(bool value);

  // optional .mt.EmRegFailedReason reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::mt::EmRegFailedReason reason() const;
  inline void set_reason(::mt::EmRegFailedReason value);

  // optional bool bauth_ok = 3;
  inline bool has_bauth_ok() const;
  inline void clear_bauth_ok();
  static const int kBauthOkFieldNumber = 3;
  inline bool bauth_ok() const;
  inline void set_bauth_ok(bool value);

  // @@protoc_insertion_point(class_scope:mt.TGkRegInfo)
 private:
  inline void set_has_bregisted();
  inline void clear_has_bregisted();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_bauth_ok();
  inline void clear_has_bauth_ok();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int reason_;
  bool bregisted_;
  bool bauth_ok_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TGkRegInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TH323StackHandle : public ::google::protobuf::Message {
 public:
  TH323StackHandle();
  virtual ~TH323StackHandle();

  TH323StackHandle(const TH323StackHandle& from);

  inline TH323StackHandle& operator=(const TH323StackHandle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TH323StackHandle& default_instance();

  void Swap(TH323StackHandle* other);

  // implements Message ----------------------------------------------

  TH323StackHandle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TH323StackHandle& from);
  void MergeFrom(const TH323StackHandle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 call = 1;
  inline bool has_call() const;
  inline void clear_call();
  static const int kCallFieldNumber = 1;
  inline ::google::protobuf::int64 call() const;
  inline void set_call(::google::protobuf::int64 value);

  // optional int64 app_call = 2;
  inline bool has_app_call() const;
  inline void clear_app_call();
  static const int kAppCallFieldNumber = 2;
  inline ::google::protobuf::int64 app_call() const;
  inline void set_app_call(::google::protobuf::int64 value);

  // optional int64 chan = 3;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 3;
  inline ::google::protobuf::int64 chan() const;
  inline void set_chan(::google::protobuf::int64 value);

  // optional int64 app_chan = 4;
  inline bool has_app_chan() const;
  inline void clear_app_chan();
  static const int kAppChanFieldNumber = 4;
  inline ::google::protobuf::int64 app_chan() const;
  inline void set_app_chan(::google::protobuf::int64 value);

  // optional int64 ras = 5;
  inline bool has_ras() const;
  inline void clear_ras();
  static const int kRasFieldNumber = 5;
  inline ::google::protobuf::int64 ras() const;
  inline void set_ras(::google::protobuf::int64 value);

  // optional int64 app_ras = 6;
  inline bool has_app_ras() const;
  inline void clear_app_ras();
  static const int kAppRasFieldNumber = 6;
  inline ::google::protobuf::int64 app_ras() const;
  inline void set_app_ras(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mt.TH323StackHandle)
 private:
  inline void set_has_call();
  inline void clear_has_call();
  inline void set_has_app_call();
  inline void clear_has_app_call();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_app_chan();
  inline void clear_has_app_chan();
  inline void set_has_ras();
  inline void clear_has_ras();
  inline void set_has_app_ras();
  inline void clear_has_app_ras();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 call_;
  ::google::protobuf::int64 app_call_;
  ::google::protobuf::int64 chan_;
  ::google::protobuf::int64 app_chan_;
  ::google::protobuf::int64 ras_;
  ::google::protobuf::int64 app_ras_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TH323StackHandle* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtRCFInfo : public ::google::protobuf::Message {
 public:
  TMtRCFInfo();
  virtual ~TMtRCFInfo();

  TMtRCFInfo(const TMtRCFInfo& from);

  inline TMtRCFInfo& operator=(const TMtRCFInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtRCFInfo& default_instance();

  void Swap(TMtRCFInfo* other);

  // implements Message ----------------------------------------------

  TMtRCFInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtRCFInfo& from);
  void MergeFrom(const TMtRCFInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMtAlias endpoint_id = 1;
  inline bool has_endpoint_id() const;
  inline void clear_endpoint_id();
  static const int kEndpointIdFieldNumber = 1;
  inline const ::mt::TMtAlias& endpoint_id() const;
  inline ::mt::TMtAlias* mutable_endpoint_id();
  inline ::mt::TMtAlias* release_endpoint_id();
  inline void set_allocated_endpoint_id(::mt::TMtAlias* endpoint_id);

  // optional .mt.TMtAlias gk_id = 2;
  inline bool has_gk_id() const;
  inline void clear_gk_id();
  static const int kGkIdFieldNumber = 2;
  inline const ::mt::TMtAlias& gk_id() const;
  inline ::mt::TMtAlias* mutable_gk_id();
  inline ::mt::TMtAlias* release_gk_id();
  inline void set_allocated_gk_id(::mt::TMtAlias* gk_id);

  // optional uint32 timetolive = 3;
  inline bool has_timetolive() const;
  inline void clear_timetolive();
  static const int kTimetoliveFieldNumber = 3;
  inline ::google::protobuf::uint32 timetolive() const;
  inline void set_timetolive(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtRCFInfo)
 private:
  inline void set_has_endpoint_id();
  inline void clear_has_endpoint_id();
  inline void set_has_gk_id();
  inline void clear_has_gk_id();
  inline void set_has_timetolive();
  inline void clear_has_timetolive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMtAlias* endpoint_id_;
  ::mt::TMtAlias* gk_id_;
  ::google::protobuf::uint32 timetolive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtRCFInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtACFInfo : public ::google::protobuf::Message {
 public:
  TMtACFInfo();
  virtual ~TMtACFInfo();

  TMtACFInfo(const TMtACFInfo& from);

  inline TMtACFInfo& operator=(const TMtACFInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtACFInfo& default_instance();

  void Swap(TMtACFInfo* other);

  // implements Message ----------------------------------------------

  TMtACFInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtACFInfo& from);
  void MergeFrom(const TMtACFInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gk_bandwidth = 1;
  inline bool has_gk_bandwidth() const;
  inline void clear_gk_bandwidth();
  static const int kGkBandwidthFieldNumber = 1;
  inline ::google::protobuf::uint32 gk_bandwidth() const;
  inline void set_gk_bandwidth(::google::protobuf::uint32 value);

  // optional .mt.TNetAddr peer_addr = 2;
  inline bool has_peer_addr() const;
  inline void clear_peer_addr();
  static const int kPeerAddrFieldNumber = 2;
  inline const ::mt::TNetAddr& peer_addr() const;
  inline ::mt::TNetAddr* mutable_peer_addr();
  inline ::mt::TNetAddr* release_peer_addr();
  inline void set_allocated_peer_addr(::mt::TNetAddr* peer_addr);

  // @@protoc_insertion_point(class_scope:mt.TMtACFInfo)
 private:
  inline void set_has_gk_bandwidth();
  inline void clear_has_gk_bandwidth();
  inline void set_has_peer_addr();
  inline void clear_has_peer_addr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TNetAddr* peer_addr_;
  ::google::protobuf::uint32 gk_bandwidth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtACFInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtFeccMsg : public ::google::protobuf::Message {
 public:
  TMtFeccMsg();
  virtual ~TMtFeccMsg();

  TMtFeccMsg(const TMtFeccMsg& from);

  inline TMtFeccMsg& operator=(const TMtFeccMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtFeccMsg& default_instance();

  void Swap(TMtFeccMsg* other);

  // implements Message ----------------------------------------------

  TMtFeccMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtFeccMsg& from);
  void MergeFrom(const TMtFeccMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::uint32 action() const;
  inline void set_action(::google::protobuf::uint32 value);

  // optional uint32 request = 2;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 2;
  inline ::google::protobuf::uint32 request() const;
  inline void set_request(::google::protobuf::uint32 value);

  // optional uint32 sourceno = 3;
  inline bool has_sourceno() const;
  inline void clear_sourceno();
  static const int kSourcenoFieldNumber = 3;
  inline ::google::protobuf::uint32 sourceno() const;
  inline void set_sourceno(::google::protobuf::uint32 value);

  // optional uint32 presetno = 4;
  inline bool has_presetno() const;
  inline void clear_presetno();
  static const int kPresetnoFieldNumber = 4;
  inline ::google::protobuf::uint32 presetno() const;
  inline void set_presetno(::google::protobuf::uint32 value);

  // optional uint32 timeout = 5;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 5;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional uint32 is_cme_msg = 6;
  inline bool has_is_cme_msg() const;
  inline void clear_is_cme_msg();
  static const int kIsCmeMsgFieldNumber = 6;
  inline ::google::protobuf::uint32 is_cme_msg() const;
  inline void set_is_cme_msg(::google::protobuf::uint32 value);

  // optional .mt.EmFeccCMEMsgType cme_msg_type = 7;
  inline bool has_cme_msg_type() const;
  inline void clear_cme_msg_type();
  static const int kCmeMsgTypeFieldNumber = 7;
  inline ::mt::EmFeccCMEMsgType cme_msg_type() const;
  inline void set_cme_msg_type(::mt::EmFeccCMEMsgType value);

  // optional uint32 com_idx = 8;
  inline bool has_com_idx() const;
  inline void clear_com_idx();
  static const int kComIdxFieldNumber = 8;
  inline ::google::protobuf::uint32 com_idx() const;
  inline void set_com_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtFeccMsg)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_sourceno();
  inline void clear_has_sourceno();
  inline void set_has_presetno();
  inline void clear_has_presetno();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_is_cme_msg();
  inline void clear_has_is_cme_msg();
  inline void set_has_cme_msg_type();
  inline void clear_has_cme_msg_type();
  inline void set_has_com_idx();
  inline void clear_has_com_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 action_;
  ::google::protobuf::uint32 request_;
  ::google::protobuf::uint32 sourceno_;
  ::google::protobuf::uint32 presetno_;
  ::google::protobuf::uint32 timeout_;
  ::google::protobuf::uint32 is_cme_msg_;
  int cme_msg_type_;
  ::google::protobuf::uint32 com_idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtFeccMsg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSeeing : public ::google::protobuf::Message {
 public:
  TMtSeeing();
  virtual ~TMtSeeing();

  TMtSeeing(const TMtSeeing& from);

  inline TMtSeeing& operator=(const TMtSeeing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSeeing& default_instance();

  void Swap(TMtSeeing* other);

  // implements Message ----------------------------------------------

  TMtSeeing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSeeing& from);
  void MergeFrom(const TMtSeeing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmCodecComponentIndex chan_idx = 1;
  inline bool has_chan_idx() const;
  inline void clear_chan_idx();
  static const int kChanIdxFieldNumber = 1;
  inline ::mt::EmCodecComponentIndex chan_idx() const;
  inline void set_chan_idx(::mt::EmCodecComponentIndex value);

  // optional .mt.TMtId mt_id = 2;
  inline bool has_mt_id() const;
  inline void clear_mt_id();
  static const int kMtIdFieldNumber = 2;
  inline const ::mt::TMtId& mt_id() const;
  inline ::mt::TMtId* mutable_mt_id();
  inline ::mt::TMtId* release_mt_id();
  inline void set_allocated_mt_id(::mt::TMtId* mt_id);

  // @@protoc_insertion_point(class_scope:mt.TMtSeeing)
 private:
  inline void set_has_chan_idx();
  inline void clear_has_chan_idx();
  inline void set_has_mt_id();
  inline void clear_has_mt_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMtId* mt_id_;
  int chan_idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtSeeing* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtSeeing : public ::google::protobuf::Message {
 public:
  TRpMtSeeing();
  virtual ~TRpMtSeeing();

  TRpMtSeeing(const TRpMtSeeing& from);

  inline TRpMtSeeing& operator=(const TRpMtSeeing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtSeeing& default_instance();

  void Swap(TRpMtSeeing* other);

  // implements Message ----------------------------------------------

  TRpMtSeeing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtSeeing& from);
  void MergeFrom(const TRpMtSeeing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtSeeing mt_see = 1;
  inline int mt_see_size() const;
  inline void clear_mt_see();
  static const int kMtSeeFieldNumber = 1;
  inline const ::mt::TMtSeeing& mt_see(int index) const;
  inline ::mt::TMtSeeing* mutable_mt_see(int index);
  inline ::mt::TMtSeeing* add_mt_see();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtSeeing >&
      mt_see() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtSeeing >*
      mutable_mt_see();

  // @@protoc_insertion_point(class_scope:mt.TRpMtSeeing)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtSeeing > mt_see_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TRpMtSeeing* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TViewTerParam : public ::google::protobuf::Message {
 public:
  TViewTerParam();
  virtual ~TViewTerParam();

  TViewTerParam(const TViewTerParam& from);

  inline TViewTerParam& operator=(const TViewTerParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TViewTerParam& default_instance();

  void Swap(TViewTerParam* other);

  // implements Message ----------------------------------------------

  TViewTerParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TViewTerParam& from);
  void MergeFrom(const TViewTerParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.TMtId mt = 1;
  inline bool has_mt() const;
  inline void clear_mt();
  static const int kMtFieldNumber = 1;
  inline const ::mt::TMtId& mt() const;
  inline ::mt::TMtId* mutable_mt();
  inline ::mt::TMtId* release_mt();
  inline void set_allocated_mt(::mt::TMtId* mt);

  // optional .mt.EmMtMediaType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mt::EmMtMediaType type() const;
  inline void set_type(::mt::EmMtMediaType value);

  // optional bool is_see_all_chan = 3;
  inline bool has_is_see_all_chan() const;
  inline void clear_is_see_all_chan();
  static const int kIsSeeAllChanFieldNumber = 3;
  inline bool is_see_all_chan() const;
  inline void set_is_see_all_chan(bool value);

  // optional .mt.EmCodecComponentIndex chan_idx = 4;
  inline bool has_chan_idx() const;
  inline void clear_chan_idx();
  static const int kChanIdxFieldNumber = 4;
  inline ::mt::EmCodecComponentIndex chan_idx() const;
  inline void set_chan_idx(::mt::EmCodecComponentIndex value);

  // @@protoc_insertion_point(class_scope:mt.TViewTerParam)
 private:
  inline void set_has_mt();
  inline void clear_has_mt();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_is_see_all_chan();
  inline void clear_has_is_see_all_chan();
  inline void set_has_chan_idx();
  inline void clear_has_chan_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMtId* mt_;
  int type_;
  bool is_see_all_chan_;
  int chan_idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TViewTerParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TCloudRecordState : public ::google::protobuf::Message {
 public:
  TCloudRecordState();
  virtual ~TCloudRecordState();

  TCloudRecordState(const TCloudRecordState& from);

  inline TCloudRecordState& operator=(const TCloudRecordState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCloudRecordState& default_instance();

  void Swap(TCloudRecordState* other);

  // implements Message ----------------------------------------------

  TCloudRecordState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCloudRecordState& from);
  void MergeFrom(const TCloudRecordState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_cloud_record = 1;
  inline bool has_is_cloud_record() const;
  inline void clear_is_cloud_record();
  static const int kIsCloudRecordFieldNumber = 1;
  inline bool is_cloud_record() const;
  inline void set_is_cloud_record(bool value);

  // optional .mt.TMTTime cloud_record_time = 2;
  inline bool has_cloud_record_time() const;
  inline void clear_cloud_record_time();
  static const int kCloudRecordTimeFieldNumber = 2;
  inline const ::mt::TMTTime& cloud_record_time() const;
  inline ::mt::TMTTime* mutable_cloud_record_time();
  inline ::mt::TMTTime* release_cloud_record_time();
  inline void set_allocated_cloud_record_time(::mt::TMTTime* cloud_record_time);

  // @@protoc_insertion_point(class_scope:mt.TCloudRecordState)
 private:
  inline void set_has_is_cloud_record();
  inline void clear_has_is_cloud_record();
  inline void set_has_cloud_record_time();
  inline void clear_has_cloud_record_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mt::TMTTime* cloud_record_time_;
  bool is_cloud_record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TCloudRecordState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TInnerMCParam : public ::google::protobuf::Message {
 public:
  TInnerMCParam();
  virtual ~TInnerMCParam();

  TInnerMCParam(const TInnerMCParam& from);

  inline TInnerMCParam& operator=(const TInnerMCParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TInnerMCParam& default_instance();

  void Swap(TInnerMCParam* other);

  // implements Message ----------------------------------------------

  TInnerMCParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TInnerMCParam& from);
  void MergeFrom(const TInnerMCParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 vmp_type = 1;
  inline bool has_vmp_type() const;
  inline void clear_vmp_type();
  static const int kVmpTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 vmp_type() const;
  inline void set_vmp_type(::google::protobuf::uint32 value);

  // optional .mt.EmMCMode mc_mode = 2;
  inline bool has_mc_mode() const;
  inline void clear_mc_mode();
  static const int kMcModeFieldNumber = 2;
  inline ::mt::EmMCMode mc_mode() const;
  inline void set_mc_mode(::mt::EmMCMode value);

  // optional string conf_name = 3;
  inline bool has_conf_name() const;
  inline void clear_conf_name();
  static const int kConfNameFieldNumber = 3;
  inline const ::std::string& conf_name() const;
  inline void set_conf_name(const ::std::string& value);
  inline void set_conf_name(const char* value);
  inline void set_conf_name(const char* value, size_t size);
  inline ::std::string* mutable_conf_name();
  inline ::std::string* release_conf_name();
  inline void set_allocated_conf_name(::std::string* conf_name);

  // optional uint32 conf_rate = 4;
  inline bool has_conf_rate() const;
  inline void clear_conf_rate();
  static const int kConfRateFieldNumber = 4;
  inline ::google::protobuf::uint32 conf_rate() const;
  inline void set_conf_rate(::google::protobuf::uint32 value);

  // optional .mt.EmConfProtocol conf_protocol = 5;
  inline bool has_conf_protocol() const;
  inline void clear_conf_protocol();
  static const int kConfProtocolFieldNumber = 5;
  inline ::mt::EmConfProtocol conf_protocol() const;
  inline void set_conf_protocol(::mt::EmConfProtocol value);

  // optional .mt.TVidFormatCap main_vid_cap = 6;
  inline bool has_main_vid_cap() const;
  inline void clear_main_vid_cap();
  static const int kMainVidCapFieldNumber = 6;
  inline const ::mt::TVidFormatCap& main_vid_cap() const;
  inline ::mt::TVidFormatCap* mutable_main_vid_cap();
  inline ::mt::TVidFormatCap* release_main_vid_cap();
  inline void set_allocated_main_vid_cap(::mt::TVidFormatCap* main_vid_cap);

  // optional .mt.TVidFormatCap assis_vid_cap = 7;
  inline bool has_assis_vid_cap() const;
  inline void clear_assis_vid_cap();
  static const int kAssisVidCapFieldNumber = 7;
  inline const ::mt::TVidFormatCap& assis_vid_cap() const;
  inline ::mt::TVidFormatCap* mutable_assis_vid_cap();
  inline ::mt::TVidFormatCap* release_assis_vid_cap();
  inline void set_allocated_assis_vid_cap(::mt::TVidFormatCap* assis_vid_cap);

  // optional .mt.TAudDes aud_cap = 8;
  inline bool has_aud_cap() const;
  inline void clear_aud_cap();
  static const int kAudCapFieldNumber = 8;
  inline const ::mt::TAudDes& aud_cap() const;
  inline ::mt::TAudDes* mutable_aud_cap();
  inline ::mt::TAudDes* release_aud_cap();
  inline void set_allocated_aud_cap(::mt::TAudDes* aud_cap);

  // optional bool bmc_used = 9;
  inline bool has_bmc_used() const;
  inline void clear_bmc_used();
  static const int kBmcUsedFieldNumber = 9;
  inline bool bmc_used() const;
  inline void set_bmc_used(bool value);

  // @@protoc_insertion_point(class_scope:mt.TInnerMCParam)
 private:
  inline void set_has_vmp_type();
  inline void clear_has_vmp_type();
  inline void set_has_mc_mode();
  inline void clear_has_mc_mode();
  inline void set_has_conf_name();
  inline void clear_has_conf_name();
  inline void set_has_conf_rate();
  inline void clear_has_conf_rate();
  inline void set_has_conf_protocol();
  inline void clear_has_conf_protocol();
  inline void set_has_main_vid_cap();
  inline void clear_has_main_vid_cap();
  inline void set_has_assis_vid_cap();
  inline void clear_has_assis_vid_cap();
  inline void set_has_aud_cap();
  inline void clear_has_aud_cap();
  inline void set_has_bmc_used();
  inline void clear_has_bmc_used();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 vmp_type_;
  int mc_mode_;
  ::std::string* conf_name_;
  ::google::protobuf::uint32 conf_rate_;
  int conf_protocol_;
  ::mt::TVidFormatCap* main_vid_cap_;
  ::mt::TVidFormatCap* assis_vid_cap_;
  ::mt::TAudDes* aud_cap_;
  bool bmc_used_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TInnerMCParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TInnerMCRunInfo : public ::google::protobuf::Message {
 public:
  TInnerMCRunInfo();
  virtual ~TInnerMCRunInfo();

  TInnerMCRunInfo(const TInnerMCRunInfo& from);

  inline TInnerMCRunInfo& operator=(const TInnerMCRunInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TInnerMCRunInfo& default_instance();

  void Swap(TInnerMCRunInfo* other);

  // implements Message ----------------------------------------------

  TInnerMCRunInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TInnerMCRunInfo& from);
  void MergeFrom(const TInnerMCRunInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool mc_is_exist = 1 [default = false];
  inline bool has_mc_is_exist() const;
  inline void clear_mc_is_exist();
  static const int kMcIsExistFieldNumber = 1;
  inline bool mc_is_exist() const;
  inline void set_mc_is_exist(bool value);

  // optional bool mc_is_active = 2 [default = false];
  inline bool has_mc_is_active() const;
  inline void clear_mc_is_active();
  static const int kMcIsActiveFieldNumber = 2;
  inline bool mc_is_active() const;
  inline void set_mc_is_active(bool value);

  // optional bool mc_is_inconf = 3 [default = false];
  inline bool has_mc_is_inconf() const;
  inline void clear_mc_is_inconf();
  static const int kMcIsInconfFieldNumber = 3;
  inline bool mc_is_inconf() const;
  inline void set_mc_is_inconf(bool value);

  // optional uint32 mc_mem_maxnum = 4;
  inline bool has_mc_mem_maxnum() const;
  inline void clear_mc_mem_maxnum();
  static const int kMcMemMaxnumFieldNumber = 4;
  inline ::google::protobuf::uint32 mc_mem_maxnum() const;
  inline void set_mc_mem_maxnum(::google::protobuf::uint32 value);

  // optional uint32 p2p_pa_handle = 5 [default = 0];
  inline bool has_p2p_pa_handle() const;
  inline void clear_p2p_pa_handle();
  static const int kP2PPaHandleFieldNumber = 5;
  inline ::google::protobuf::uint32 p2p_pa_handle() const;
  inline void set_p2p_pa_handle(::google::protobuf::uint32 value);

  // optional uint32 p2p_ep_handle = 6;
  inline bool has_p2p_ep_handle() const;
  inline void clear_p2p_ep_handle();
  static const int kP2PEpHandleFieldNumber = 6;
  inline ::google::protobuf::uint32 p2p_ep_handle() const;
  inline void set_p2p_ep_handle(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mt.TInnerMCRunInfo)
 private:
  inline void set_has_mc_is_exist();
  inline void clear_has_mc_is_exist();
  inline void set_has_mc_is_active();
  inline void clear_has_mc_is_active();
  inline void set_has_mc_is_inconf();
  inline void clear_has_mc_is_inconf();
  inline void set_has_mc_mem_maxnum();
  inline void clear_has_mc_mem_maxnum();
  inline void set_has_p2p_pa_handle();
  inline void clear_has_p2p_pa_handle();
  inline void set_has_p2p_ep_handle();
  inline void clear_has_p2p_ep_handle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool mc_is_exist_;
  bool mc_is_active_;
  bool mc_is_inconf_;
  ::google::protobuf::uint32 mc_mem_maxnum_;
  ::google::protobuf::uint32 p2p_pa_handle_;
  ::google::protobuf::uint32 p2p_ep_handle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TInnerMCRunInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TFastCall : public ::google::protobuf::Message {
 public:
  TFastCall();
  virtual ~TFastCall();

  TFastCall(const TFastCall& from);

  inline TFastCall& operator=(const TFastCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFastCall& default_instance();

  void Swap(TFastCall* other);

  // implements Message ----------------------------------------------

  TFastCall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFastCall& from);
  void MergeFrom(const TFastCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 call_rate = 1;
  inline bool has_call_rate() const;
  inline void clear_call_rate();
  static const int kCallRateFieldNumber = 1;
  inline ::google::protobuf::uint32 call_rate() const;
  inline void set_call_rate(::google::protobuf::uint32 value);

  // optional .mt.EmMtAddrType call_type = 2;
  inline bool has_call_type() const;
  inline void clear_call_type();
  static const int kCallTypeFieldNumber = 2;
  inline ::mt::EmMtAddrType call_type() const;
  inline void set_call_type(::mt::EmMtAddrType value);

  // optional uint32 peer_addr = 3;
  inline bool has_peer_addr() const;
  inline void clear_peer_addr();
  static const int kPeerAddrFieldNumber = 3;
  inline ::google::protobuf::uint32 peer_addr() const;
  inline void set_peer_addr(::google::protobuf::uint32 value);

  // optional string peer_e164 = 4;
  inline bool has_peer_e164() const;
  inline void clear_peer_e164();
  static const int kPeerE164FieldNumber = 4;
  inline const ::std::string& peer_e164() const;
  inline void set_peer_e164(const ::std::string& value);
  inline void set_peer_e164(const char* value);
  inline void set_peer_e164(const char* value, size_t size);
  inline ::std::string* mutable_peer_e164();
  inline ::std::string* release_peer_e164();
  inline void set_allocated_peer_e164(::std::string* peer_e164);

  // optional string peer_alias = 5;
  inline bool has_peer_alias() const;
  inline void clear_peer_alias();
  static const int kPeerAliasFieldNumber = 5;
  inline const ::std::string& peer_alias() const;
  inline void set_peer_alias(const ::std::string& value);
  inline void set_peer_alias(const char* value);
  inline void set_peer_alias(const char* value, size_t size);
  inline ::std::string* mutable_peer_alias();
  inline ::std::string* release_peer_alias();
  inline void set_allocated_peer_alias(::std::string* peer_alias);

  // @@protoc_insertion_point(class_scope:mt.TFastCall)
 private:
  inline void set_has_call_rate();
  inline void clear_has_call_rate();
  inline void set_has_call_type();
  inline void clear_has_call_type();
  inline void set_has_peer_addr();
  inline void clear_has_peer_addr();
  inline void set_has_peer_e164();
  inline void clear_has_peer_e164();
  inline void set_has_peer_alias();
  inline void clear_has_peer_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 call_rate_;
  int call_type_;
  ::std::string* peer_e164_;
  ::std::string* peer_alias_;
  ::google::protobuf::uint32 peer_addr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TFastCall* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TFastCallList : public ::google::protobuf::Message {
 public:
  TFastCallList();
  virtual ~TFastCallList();

  TFastCallList(const TFastCallList& from);

  inline TFastCallList& operator=(const TFastCallList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFastCallList& default_instance();

  void Swap(TFastCallList* other);

  // implements Message ----------------------------------------------

  TFastCallList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFastCallList& from);
  void MergeFrom(const TFastCallList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TFastCall fast_call = 1;
  inline int fast_call_size() const;
  inline void clear_fast_call();
  static const int kFastCallFieldNumber = 1;
  inline const ::mt::TFastCall& fast_call(int index) const;
  inline ::mt::TFastCall* mutable_fast_call(int index);
  inline ::mt::TFastCall* add_fast_call();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TFastCall >&
      fast_call() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TFastCall >*
      mutable_fast_call();

  // @@protoc_insertion_point(class_scope:mt.TFastCallList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TFastCall > fast_call_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TFastCallList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSecCertDistinctName : public ::google::protobuf::Message {
 public:
  TMtSecCertDistinctName();
  virtual ~TMtSecCertDistinctName();

  TMtSecCertDistinctName(const TMtSecCertDistinctName& from);

  inline TMtSecCertDistinctName& operator=(const TMtSecCertDistinctName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSecCertDistinctName& default_instance();

  void Swap(TMtSecCertDistinctName* other);

  // implements Message ----------------------------------------------

  TMtSecCertDistinctName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSecCertDistinctName& from);
  void MergeFrom(const TMtSecCertDistinctName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string country_name = 1;
  inline bool has_country_name() const;
  inline void clear_country_name();
  static const int kCountryNameFieldNumber = 1;
  inline const ::std::string& country_name() const;
  inline void set_country_name(const ::std::string& value);
  inline void set_country_name(const char* value);
  inline void set_country_name(const char* value, size_t size);
  inline ::std::string* mutable_country_name();
  inline ::std::string* release_country_name();
  inline void set_allocated_country_name(::std::string* country_name);

  // optional string state_or_province_name = 2;
  inline bool has_state_or_province_name() const;
  inline void clear_state_or_province_name();
  static const int kStateOrProvinceNameFieldNumber = 2;
  inline const ::std::string& state_or_province_name() const;
  inline void set_state_or_province_name(const ::std::string& value);
  inline void set_state_or_province_name(const char* value);
  inline void set_state_or_province_name(const char* value, size_t size);
  inline ::std::string* mutable_state_or_province_name();
  inline ::std::string* release_state_or_province_name();
  inline void set_allocated_state_or_province_name(::std::string* state_or_province_name);

  // optional string locality_name = 3;
  inline bool has_locality_name() const;
  inline void clear_locality_name();
  static const int kLocalityNameFieldNumber = 3;
  inline const ::std::string& locality_name() const;
  inline void set_locality_name(const ::std::string& value);
  inline void set_locality_name(const char* value);
  inline void set_locality_name(const char* value, size_t size);
  inline ::std::string* mutable_locality_name();
  inline ::std::string* release_locality_name();
  inline void set_allocated_locality_name(::std::string* locality_name);

  // optional string organization_name = 4;
  inline bool has_organization_name() const;
  inline void clear_organization_name();
  static const int kOrganizationNameFieldNumber = 4;
  inline const ::std::string& organization_name() const;
  inline void set_organization_name(const ::std::string& value);
  inline void set_organization_name(const char* value);
  inline void set_organization_name(const char* value, size_t size);
  inline ::std::string* mutable_organization_name();
  inline ::std::string* release_organization_name();
  inline void set_allocated_organization_name(::std::string* organization_name);

  // optional string organization_unit_name = 5;
  inline bool has_organization_unit_name() const;
  inline void clear_organization_unit_name();
  static const int kOrganizationUnitNameFieldNumber = 5;
  inline const ::std::string& organization_unit_name() const;
  inline void set_organization_unit_name(const ::std::string& value);
  inline void set_organization_unit_name(const char* value);
  inline void set_organization_unit_name(const char* value, size_t size);
  inline ::std::string* mutable_organization_unit_name();
  inline ::std::string* release_organization_unit_name();
  inline void set_allocated_organization_unit_name(::std::string* organization_unit_name);

  // optional string common_name = 6;
  inline bool has_common_name() const;
  inline void clear_common_name();
  static const int kCommonNameFieldNumber = 6;
  inline const ::std::string& common_name() const;
  inline void set_common_name(const ::std::string& value);
  inline void set_common_name(const char* value);
  inline void set_common_name(const char* value, size_t size);
  inline ::std::string* mutable_common_name();
  inline ::std::string* release_common_name();
  inline void set_allocated_common_name(::std::string* common_name);

  // optional string serial_number = 7;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 7;
  inline const ::std::string& serial_number() const;
  inline void set_serial_number(const ::std::string& value);
  inline void set_serial_number(const char* value);
  inline void set_serial_number(const char* value, size_t size);
  inline ::std::string* mutable_serial_number();
  inline ::std::string* release_serial_number();
  inline void set_allocated_serial_number(::std::string* serial_number);

  // optional string email_address = 8;
  inline bool has_email_address() const;
  inline void clear_email_address();
  static const int kEmailAddressFieldNumber = 8;
  inline const ::std::string& email_address() const;
  inline void set_email_address(const ::std::string& value);
  inline void set_email_address(const char* value);
  inline void set_email_address(const char* value, size_t size);
  inline ::std::string* mutable_email_address();
  inline ::std::string* release_email_address();
  inline void set_allocated_email_address(::std::string* email_address);

  // @@protoc_insertion_point(class_scope:mt.TMtSecCertDistinctName)
 private:
  inline void set_has_country_name();
  inline void clear_has_country_name();
  inline void set_has_state_or_province_name();
  inline void clear_has_state_or_province_name();
  inline void set_has_locality_name();
  inline void clear_has_locality_name();
  inline void set_has_organization_name();
  inline void clear_has_organization_name();
  inline void set_has_organization_unit_name();
  inline void clear_has_organization_unit_name();
  inline void set_has_common_name();
  inline void clear_has_common_name();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_email_address();
  inline void clear_has_email_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* country_name_;
  ::std::string* state_or_province_name_;
  ::std::string* locality_name_;
  ::std::string* organization_name_;
  ::std::string* organization_unit_name_;
  ::std::string* common_name_;
  ::std::string* serial_number_;
  ::std::string* email_address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtSecCertDistinctName* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSecCertValidity : public ::google::protobuf::Message {
 public:
  TMtSecCertValidity();
  virtual ~TMtSecCertValidity();

  TMtSecCertValidity(const TMtSecCertValidity& from);

  inline TMtSecCertValidity& operator=(const TMtSecCertValidity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSecCertValidity& default_instance();

  void Swap(TMtSecCertValidity* other);

  // implements Message ----------------------------------------------

  TMtSecCertValidity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSecCertValidity& from);
  void MergeFrom(const TMtSecCertValidity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nottime_before = 1;
  inline bool has_nottime_before() const;
  inline void clear_nottime_before();
  static const int kNottimeBeforeFieldNumber = 1;
  inline const ::std::string& nottime_before() const;
  inline void set_nottime_before(const ::std::string& value);
  inline void set_nottime_before(const char* value);
  inline void set_nottime_before(const char* value, size_t size);
  inline ::std::string* mutable_nottime_before();
  inline ::std::string* release_nottime_before();
  inline void set_allocated_nottime_before(::std::string* nottime_before);

  // optional string nottime_after = 2;
  inline bool has_nottime_after() const;
  inline void clear_nottime_after();
  static const int kNottimeAfterFieldNumber = 2;
  inline const ::std::string& nottime_after() const;
  inline void set_nottime_after(const ::std::string& value);
  inline void set_nottime_after(const char* value);
  inline void set_nottime_after(const char* value, size_t size);
  inline ::std::string* mutable_nottime_after();
  inline ::std::string* release_nottime_after();
  inline void set_allocated_nottime_after(::std::string* nottime_after);

  // @@protoc_insertion_point(class_scope:mt.TMtSecCertValidity)
 private:
  inline void set_has_nottime_before();
  inline void clear_has_nottime_before();
  inline void set_has_nottime_after();
  inline void clear_has_nottime_after();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nottime_before_;
  ::std::string* nottime_after_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtSecCertValidity* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSecCertInfo : public ::google::protobuf::Message {
 public:
  TMtSecCertInfo();
  virtual ~TMtSecCertInfo();

  TMtSecCertInfo(const TMtSecCertInfo& from);

  inline TMtSecCertInfo& operator=(const TMtSecCertInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSecCertInfo& default_instance();

  void Swap(TMtSecCertInfo* other);

  // implements Message ----------------------------------------------

  TMtSecCertInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSecCertInfo& from);
  void MergeFrom(const TMtSecCertInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional string serial_number = 2;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  inline const ::std::string& serial_number() const;
  inline void set_serial_number(const ::std::string& value);
  inline void set_serial_number(const char* value);
  inline void set_serial_number(const char* value, size_t size);
  inline ::std::string* mutable_serial_number();
  inline ::std::string* release_serial_number();
  inline void set_allocated_serial_number(::std::string* serial_number);

  // optional string sign_alg = 3;
  inline bool has_sign_alg() const;
  inline void clear_sign_alg();
  static const int kSignAlgFieldNumber = 3;
  inline const ::std::string& sign_alg() const;
  inline void set_sign_alg(const ::std::string& value);
  inline void set_sign_alg(const char* value);
  inline void set_sign_alg(const char* value, size_t size);
  inline ::std::string* mutable_sign_alg();
  inline ::std::string* release_sign_alg();
  inline void set_allocated_sign_alg(::std::string* sign_alg);

  // optional .mt.TMtSecCertDistinctName issuer_info = 4;
  inline bool has_issuer_info() const;
  inline void clear_issuer_info();
  static const int kIssuerInfoFieldNumber = 4;
  inline const ::mt::TMtSecCertDistinctName& issuer_info() const;
  inline ::mt::TMtSecCertDistinctName* mutable_issuer_info();
  inline ::mt::TMtSecCertDistinctName* release_issuer_info();
  inline void set_allocated_issuer_info(::mt::TMtSecCertDistinctName* issuer_info);

  // optional .mt.TMtSecCertValidity validity = 5;
  inline bool has_validity() const;
  inline void clear_validity();
  static const int kValidityFieldNumber = 5;
  inline const ::mt::TMtSecCertValidity& validity() const;
  inline ::mt::TMtSecCertValidity* mutable_validity();
  inline ::mt::TMtSecCertValidity* release_validity();
  inline void set_allocated_validity(::mt::TMtSecCertValidity* validity);

  // optional .mt.TMtSecCertDistinctName subject_info = 6;
  inline bool has_subject_info() const;
  inline void clear_subject_info();
  static const int kSubjectInfoFieldNumber = 6;
  inline const ::mt::TMtSecCertDistinctName& subject_info() const;
  inline ::mt::TMtSecCertDistinctName* mutable_subject_info();
  inline ::mt::TMtSecCertDistinctName* release_subject_info();
  inline void set_allocated_subject_info(::mt::TMtSecCertDistinctName* subject_info);

  // optional string pubkey_alg = 7;
  inline bool has_pubkey_alg() const;
  inline void clear_pubkey_alg();
  static const int kPubkeyAlgFieldNumber = 7;
  inline const ::std::string& pubkey_alg() const;
  inline void set_pubkey_alg(const ::std::string& value);
  inline void set_pubkey_alg(const char* value);
  inline void set_pubkey_alg(const char* value, size_t size);
  inline ::std::string* mutable_pubkey_alg();
  inline ::std::string* release_pubkey_alg();
  inline void set_allocated_pubkey_alg(::std::string* pubkey_alg);

  // optional bytes finger_print = 8;
  inline bool has_finger_print() const;
  inline void clear_finger_print();
  static const int kFingerPrintFieldNumber = 8;
  inline const ::std::string& finger_print() const;
  inline void set_finger_print(const ::std::string& value);
  inline void set_finger_print(const char* value);
  inline void set_finger_print(const void* value, size_t size);
  inline ::std::string* mutable_finger_print();
  inline ::std::string* release_finger_print();
  inline void set_allocated_finger_print(::std::string* finger_print);

  // optional int32 format = 9;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 9;
  inline ::google::protobuf::int32 format() const;
  inline void set_format(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt.TMtSecCertInfo)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_sign_alg();
  inline void clear_has_sign_alg();
  inline void set_has_issuer_info();
  inline void clear_has_issuer_info();
  inline void set_has_validity();
  inline void clear_has_validity();
  inline void set_has_subject_info();
  inline void clear_has_subject_info();
  inline void set_has_pubkey_alg();
  inline void clear_has_pubkey_alg();
  inline void set_has_finger_print();
  inline void clear_has_finger_print();
  inline void set_has_format();
  inline void clear_has_format();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* serial_number_;
  ::std::string* sign_alg_;
  ::mt::TMtSecCertDistinctName* issuer_info_;
  ::mt::TMtSecCertValidity* validity_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 format_;
  ::mt::TMtSecCertDistinctName* subject_info_;
  ::std::string* pubkey_alg_;
  ::std::string* finger_print_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtSecCertInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpMtSecCaIDList : public ::google::protobuf::Message {
 public:
  TRpMtSecCaIDList();
  virtual ~TRpMtSecCaIDList();

  TRpMtSecCaIDList(const TRpMtSecCaIDList& from);

  inline TRpMtSecCaIDList& operator=(const TRpMtSecCaIDList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpMtSecCaIDList& default_instance();

  void Swap(TRpMtSecCaIDList* other);

  // implements Message ----------------------------------------------

  TRpMtSecCaIDList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpMtSecCaIDList& from);
  void MergeFrom(const TRpMtSecCaIDList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes cacert_id = 1;
  inline int cacert_id_size() const;
  inline void clear_cacert_id();
  static const int kCacertIdFieldNumber = 1;
  inline const ::std::string& cacert_id(int index) const;
  inline ::std::string* mutable_cacert_id(int index);
  inline void set_cacert_id(int index, const ::std::string& value);
  inline void set_cacert_id(int index, const char* value);
  inline void set_cacert_id(int index, const void* value, size_t size);
  inline ::std::string* add_cacert_id();
  inline void add_cacert_id(const ::std::string& value);
  inline void add_cacert_id(const char* value);
  inline void add_cacert_id(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cacert_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cacert_id();

  // @@protoc_insertion_point(class_scope:mt.TRpMtSecCaIDList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> cacert_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TRpMtSecCaIDList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtTerAuthCmd : public ::google::protobuf::Message {
 public:
  TMtTerAuthCmd();
  virtual ~TMtTerAuthCmd();

  TMtTerAuthCmd(const TMtTerAuthCmd& from);

  inline TMtTerAuthCmd& operator=(const TMtTerAuthCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtTerAuthCmd& default_instance();

  void Swap(TMtTerAuthCmd* other);

  // implements Message ----------------------------------------------

  TMtTerAuthCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtTerAuthCmd& from);
  void MergeFrom(const TMtTerAuthCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string auther_name = 1;
  inline bool has_auther_name() const;
  inline void clear_auther_name();
  static const int kAutherNameFieldNumber = 1;
  inline const ::std::string& auther_name() const;
  inline void set_auther_name(const ::std::string& value);
  inline void set_auther_name(const char* value);
  inline void set_auther_name(const char* value, size_t size);
  inline ::std::string* mutable_auther_name();
  inline ::std::string* release_auther_name();
  inline void set_allocated_auther_name(::std::string* auther_name);

  // optional string authee_name = 2;
  inline bool has_authee_name() const;
  inline void clear_authee_name();
  static const int kAutheeNameFieldNumber = 2;
  inline const ::std::string& authee_name() const;
  inline void set_authee_name(const ::std::string& value);
  inline void set_authee_name(const char* value);
  inline void set_authee_name(const char* value, size_t size);
  inline ::std::string* mutable_authee_name();
  inline ::std::string* release_authee_name();
  inline void set_allocated_authee_name(::std::string* authee_name);

  // @@protoc_insertion_point(class_scope:mt.TMtTerAuthCmd)
 private:
  inline void set_has_auther_name();
  inline void clear_has_auther_name();
  inline void set_has_authee_name();
  inline void clear_has_authee_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* auther_name_;
  ::std::string* authee_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtTerAuthCmd* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtTerAuthRequest : public ::google::protobuf::Message {
 public:
  TMtTerAuthRequest();
  virtual ~TMtTerAuthRequest();

  TMtTerAuthRequest(const TMtTerAuthRequest& from);

  inline TMtTerAuthRequest& operator=(const TMtTerAuthRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtTerAuthRequest& default_instance();

  void Swap(TMtTerAuthRequest* other);

  // implements Message ----------------------------------------------

  TMtTerAuthRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtTerAuthRequest& from);
  void MergeFrom(const TMtTerAuthRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:mt.TMtTerAuthRequest)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtTerAuthRequest* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtTerAuthCancel : public ::google::protobuf::Message {
 public:
  TMtTerAuthCancel();
  virtual ~TMtTerAuthCancel();

  TMtTerAuthCancel(const TMtTerAuthCancel& from);

  inline TMtTerAuthCancel& operator=(const TMtTerAuthCancel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtTerAuthCancel& default_instance();

  void Swap(TMtTerAuthCancel* other);

  // implements Message ----------------------------------------------

  TMtTerAuthCancel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtTerAuthCancel& from);
  void MergeFrom(const TMtTerAuthCancel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string auther_name = 1;
  inline bool has_auther_name() const;
  inline void clear_auther_name();
  static const int kAutherNameFieldNumber = 1;
  inline const ::std::string& auther_name() const;
  inline void set_auther_name(const ::std::string& value);
  inline void set_auther_name(const char* value);
  inline void set_auther_name(const char* value, size_t size);
  inline ::std::string* mutable_auther_name();
  inline ::std::string* release_auther_name();
  inline void set_allocated_auther_name(::std::string* auther_name);

  // optional string authee_name = 2;
  inline bool has_authee_name() const;
  inline void clear_authee_name();
  static const int kAutheeNameFieldNumber = 2;
  inline const ::std::string& authee_name() const;
  inline void set_authee_name(const ::std::string& value);
  inline void set_authee_name(const char* value);
  inline void set_authee_name(const char* value, size_t size);
  inline ::std::string* mutable_authee_name();
  inline ::std::string* release_authee_name();
  inline void set_allocated_authee_name(::std::string* authee_name);

  // @@protoc_insertion_point(class_scope:mt.TMtTerAuthCancel)
 private:
  inline void set_has_auther_name();
  inline void clear_has_auther_name();
  inline void set_has_authee_name();
  inline void clear_has_authee_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* auther_name_;
  ::std::string* authee_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtTerAuthCancel* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtTerAuthMsg : public ::google::protobuf::Message {
 public:
  TMtTerAuthMsg();
  virtual ~TMtTerAuthMsg();

  TMtTerAuthMsg(const TMtTerAuthMsg& from);

  inline TMtTerAuthMsg& operator=(const TMtTerAuthMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtTerAuthMsg& default_instance();

  void Swap(TMtTerAuthMsg* other);

  // implements Message ----------------------------------------------

  TMtTerAuthMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtTerAuthMsg& from);
  void MergeFrom(const TMtTerAuthMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 is_authforcall = 1;
  inline bool has_is_authforcall() const;
  inline void clear_is_authforcall();
  static const int kIsAuthforcallFieldNumber = 1;
  inline ::google::protobuf::int32 is_authforcall() const;
  inline void set_is_authforcall(::google::protobuf::int32 value);

  // optional string callid = 2;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 2;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // @@protoc_insertion_point(class_scope:mt.TMtTerAuthMsg)
 private:
  inline void set_has_is_authforcall();
  inline void clear_has_is_authforcall();
  inline void set_has_callid();
  inline void clear_has_callid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* callid_;
  ::google::protobuf::int32 is_authforcall_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtTerAuthMsg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtSecCreateCertReq : public ::google::protobuf::Message {
 public:
  TMtSecCreateCertReq();
  virtual ~TMtSecCreateCertReq();

  TMtSecCreateCertReq(const TMtSecCreateCertReq& from);

  inline TMtSecCreateCertReq& operator=(const TMtSecCreateCertReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtSecCreateCertReq& default_instance();

  void Swap(TMtSecCreateCertReq* other);

  // implements Message ----------------------------------------------

  TMtSecCreateCertReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtSecCreateCertReq& from);
  void MergeFrom(const TMtSecCreateCertReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_sign = 1;
  inline bool has_is_sign() const;
  inline void clear_is_sign();
  static const int kIsSignFieldNumber = 1;
  inline bool is_sign() const;
  inline void set_is_sign(bool value);

  // optional bool is_resetpwd = 2;
  inline bool has_is_resetpwd() const;
  inline void clear_is_resetpwd();
  static const int kIsResetpwdFieldNumber = 2;
  inline bool is_resetpwd() const;
  inline void set_is_resetpwd(bool value);

  // optional string devicecert_fileName = 3;
  inline bool has_devicecert_filename() const;
  inline void clear_devicecert_filename();
  static const int kDevicecertFileNameFieldNumber = 3;
  inline const ::std::string& devicecert_filename() const;
  inline void set_devicecert_filename(const ::std::string& value);
  inline void set_devicecert_filename(const char* value);
  inline void set_devicecert_filename(const char* value, size_t size);
  inline ::std::string* mutable_devicecert_filename();
  inline ::std::string* release_devicecert_filename();
  inline void set_allocated_devicecert_filename(::std::string* devicecert_filename);

  // optional .mt.TMtSecCertDistinctName name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::mt::TMtSecCertDistinctName& name() const;
  inline ::mt::TMtSecCertDistinctName* mutable_name();
  inline ::mt::TMtSecCertDistinctName* release_name();
  inline void set_allocated_name(::mt::TMtSecCertDistinctName* name);

  // @@protoc_insertion_point(class_scope:mt.TMtSecCreateCertReq)
 private:
  inline void set_has_is_sign();
  inline void clear_has_is_sign();
  inline void set_has_is_resetpwd();
  inline void clear_has_is_resetpwd();
  inline void set_has_devicecert_filename();
  inline void clear_has_devicecert_filename();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* devicecert_filename_;
  ::mt::TMtSecCertDistinctName* name_;
  bool is_sign_;
  bool is_resetpwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtSecCreateCertReq* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtVrsUserInfo : public ::google::protobuf::Message {
 public:
  TMtVrsUserInfo();
  virtual ~TMtVrsUserInfo();

  TMtVrsUserInfo(const TMtVrsUserInfo& from);

  inline TMtVrsUserInfo& operator=(const TMtVrsUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtVrsUserInfo& default_instance();

  void Swap(TMtVrsUserInfo* other);

  // implements Message ----------------------------------------------

  TMtVrsUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtVrsUserInfo& from);
  void MergeFrom(const TMtVrsUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rightmask = 1;
  inline bool has_rightmask() const;
  inline void clear_rightmask();
  static const int kRightmaskFieldNumber = 1;
  inline ::google::protobuf::int32 rightmask() const;
  inline void set_rightmask(::google::protobuf::int32 value);

  // optional string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string userdomainmoid = 3;
  inline bool has_userdomainmoid() const;
  inline void clear_userdomainmoid();
  static const int kUserdomainmoidFieldNumber = 3;
  inline const ::std::string& userdomainmoid() const;
  inline void set_userdomainmoid(const ::std::string& value);
  inline void set_userdomainmoid(const char* value);
  inline void set_userdomainmoid(const char* value, size_t size);
  inline ::std::string* mutable_userdomainmoid();
  inline ::std::string* release_userdomainmoid();
  inline void set_allocated_userdomainmoid(::std::string* userdomainmoid);

  // optional string usermoid = 4;
  inline bool has_usermoid() const;
  inline void clear_usermoid();
  static const int kUsermoidFieldNumber = 4;
  inline const ::std::string& usermoid() const;
  inline void set_usermoid(const ::std::string& value);
  inline void set_usermoid(const char* value);
  inline void set_usermoid(const char* value, size_t size);
  inline ::std::string* mutable_usermoid();
  inline ::std::string* release_usermoid();
  inline void set_allocated_usermoid(::std::string* usermoid);

  // @@protoc_insertion_point(class_scope:mt.TMtVrsUserInfo)
 private:
  inline void set_has_rightmask();
  inline void clear_has_rightmask();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_userdomainmoid();
  inline void clear_has_userdomainmoid();
  inline void set_has_usermoid();
  inline void clear_has_usermoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::std::string* userdomainmoid_;
  ::std::string* usermoid_;
  ::google::protobuf::int32 rightmask_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtVrsUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TLicense : public ::google::protobuf::Message {
 public:
  TLicense();
  virtual ~TLicense();

  TLicense(const TLicense& from);

  inline TLicense& operator=(const TLicense& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLicense& default_instance();

  void Swap(TLicense* other);

  // implements Message ----------------------------------------------

  TLicense* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLicense& from);
  void MergeFrom(const TLicense& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mt.EmVersionType KeyVersion_Type = 1;
  inline bool has_keyversion_type() const;
  inline void clear_keyversion_type();
  static const int kKeyVersionTypeFieldNumber = 1;
  inline ::mt::EmVersionType keyversion_type() const;
  inline void set_keyversion_type(::mt::EmVersionType value);

  // optional .mt.EmMtModel emKeyTerminalType = 2;
  inline bool has_emkeyterminaltype() const;
  inline void clear_emkeyterminaltype();
  static const int kEmKeyTerminalTypeFieldNumber = 2;
  inline ::mt::EmMtModel emkeyterminaltype() const;
  inline void set_emkeyterminaltype(::mt::EmMtModel value);

  // optional bool KeyChannelAccess = 3;
  inline bool has_keychannelaccess() const;
  inline void clear_keychannelaccess();
  static const int kKeyChannelAccessFieldNumber = 3;
  inline bool keychannelaccess() const;
  inline void set_keychannelaccess(bool value);

  // optional bool KeyHybridcloudAccess = 4;
  inline bool has_keyhybridcloudaccess() const;
  inline void clear_keyhybridcloudaccess();
  static const int kKeyHybridcloudAccessFieldNumber = 4;
  inline bool keyhybridcloudaccess() const;
  inline void set_keyhybridcloudaccess(bool value);

  // optional bool KeyPubliccloudAccess = 5;
  inline bool has_keypubliccloudaccess() const;
  inline void clear_keypubliccloudaccess();
  static const int kKeyPubliccloudAccessFieldNumber = 5;
  inline bool keypubliccloudaccess() const;
  inline void set_keypubliccloudaccess(bool value);

  // optional string KeyTerminalDeviceId = 6;
  inline bool has_keyterminaldeviceid() const;
  inline void clear_keyterminaldeviceid();
  static const int kKeyTerminalDeviceIdFieldNumber = 6;
  inline const ::std::string& keyterminaldeviceid() const;
  inline void set_keyterminaldeviceid(const ::std::string& value);
  inline void set_keyterminaldeviceid(const char* value);
  inline void set_keyterminaldeviceid(const char* value, size_t size);
  inline ::std::string* mutable_keyterminaldeviceid();
  inline ::std::string* release_keyterminaldeviceid();
  inline void set_allocated_keyterminaldeviceid(::std::string* keyterminaldeviceid);

  // optional string UserType = 7;
  inline bool has_usertype() const;
  inline void clear_usertype();
  static const int kUserTypeFieldNumber = 7;
  inline const ::std::string& usertype() const;
  inline void set_usertype(const ::std::string& value);
  inline void set_usertype(const char* value);
  inline void set_usertype(const char* value, size_t size);
  inline ::std::string* mutable_usertype();
  inline ::std::string* release_usertype();
  inline void set_allocated_usertype(::std::string* usertype);

  // optional string ContractNode = 8;
  inline bool has_contractnode() const;
  inline void clear_contractnode();
  static const int kContractNodeFieldNumber = 8;
  inline const ::std::string& contractnode() const;
  inline void set_contractnode(const ::std::string& value);
  inline void set_contractnode(const char* value);
  inline void set_contractnode(const char* value, size_t size);
  inline ::std::string* mutable_contractnode();
  inline ::std::string* release_contractnode();
  inline void set_allocated_contractnode(::std::string* contractnode);

  // optional string CustomerName = 9;
  inline bool has_customername() const;
  inline void clear_customername();
  static const int kCustomerNameFieldNumber = 9;
  inline const ::std::string& customername() const;
  inline void set_customername(const ::std::string& value);
  inline void set_customername(const char* value);
  inline void set_customername(const char* value, size_t size);
  inline ::std::string* mutable_customername();
  inline ::std::string* release_customername();
  inline void set_allocated_customername(::std::string* customername);

  // optional string CustomerAddress = 10;
  inline bool has_customeraddress() const;
  inline void clear_customeraddress();
  static const int kCustomerAddressFieldNumber = 10;
  inline const ::std::string& customeraddress() const;
  inline void set_customeraddress(const ::std::string& value);
  inline void set_customeraddress(const char* value);
  inline void set_customeraddress(const char* value, size_t size);
  inline ::std::string* mutable_customeraddress();
  inline ::std::string* release_customeraddress();
  inline void set_allocated_customeraddress(::std::string* customeraddress);

  // optional string Serler = 11;
  inline bool has_serler() const;
  inline void clear_serler();
  static const int kSerlerFieldNumber = 11;
  inline const ::std::string& serler() const;
  inline void set_serler(const ::std::string& value);
  inline void set_serler(const char* value);
  inline void set_serler(const char* value, size_t size);
  inline ::std::string* mutable_serler();
  inline ::std::string* release_serler();
  inline void set_allocated_serler(::std::string* serler);

  // optional string Description = 12;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 12;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional .mt.EmLicenseKeyCheckValue CheckValue = 13;
  inline bool has_checkvalue() const;
  inline void clear_checkvalue();
  static const int kCheckValueFieldNumber = 13;
  inline ::mt::EmLicenseKeyCheckValue checkvalue() const;
  inline void set_checkvalue(::mt::EmLicenseKeyCheckValue value);

  // @@protoc_insertion_point(class_scope:mt.TLicense)
 private:
  inline void set_has_keyversion_type();
  inline void clear_has_keyversion_type();
  inline void set_has_emkeyterminaltype();
  inline void clear_has_emkeyterminaltype();
  inline void set_has_keychannelaccess();
  inline void clear_has_keychannelaccess();
  inline void set_has_keyhybridcloudaccess();
  inline void clear_has_keyhybridcloudaccess();
  inline void set_has_keypubliccloudaccess();
  inline void clear_has_keypubliccloudaccess();
  inline void set_has_keyterminaldeviceid();
  inline void clear_has_keyterminaldeviceid();
  inline void set_has_usertype();
  inline void clear_has_usertype();
  inline void set_has_contractnode();
  inline void clear_has_contractnode();
  inline void set_has_customername();
  inline void clear_has_customername();
  inline void set_has_customeraddress();
  inline void clear_has_customeraddress();
  inline void set_has_serler();
  inline void clear_has_serler();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_checkvalue();
  inline void clear_has_checkvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int keyversion_type_;
  int emkeyterminaltype_;
  ::std::string* keyterminaldeviceid_;
  bool keychannelaccess_;
  bool keyhybridcloudaccess_;
  bool keypubliccloudaccess_;
  int checkvalue_;
  ::std::string* usertype_;
  ::std::string* contractnode_;
  ::std::string* customername_;
  ::std::string* customeraddress_;
  ::std::string* serler_;
  ::std::string* description_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TLicense* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAiInviteInfo : public ::google::protobuf::Message {
 public:
  TMtAiInviteInfo();
  virtual ~TMtAiInviteInfo();

  TMtAiInviteInfo(const TMtAiInviteInfo& from);

  inline TMtAiInviteInfo& operator=(const TMtAiInviteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAiInviteInfo& default_instance();

  void Swap(TMtAiInviteInfo* other);

  // implements Message ----------------------------------------------

  TMtAiInviteInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAiInviteInfo& from);
  void MergeFrom(const TMtAiInviteInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string e164 = 2;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 2;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional .mt.EmAiContactType emContactType = 4;
  inline bool has_emcontacttype() const;
  inline void clear_emcontacttype();
  static const int kEmContactTypeFieldNumber = 4;
  inline ::mt::EmAiContactType emcontacttype() const;
  inline void set_emcontacttype(::mt::EmAiContactType value);

  // @@protoc_insertion_point(class_scope:mt.TMtAiInviteInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_emcontacttype();
  inline void clear_has_emcontacttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* e164_;
  ::std::string* ip_;
  int emcontacttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtAiInviteInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TMtAiInviteInfoList : public ::google::protobuf::Message {
 public:
  TMtAiInviteInfoList();
  virtual ~TMtAiInviteInfoList();

  TMtAiInviteInfoList(const TMtAiInviteInfoList& from);

  inline TMtAiInviteInfoList& operator=(const TMtAiInviteInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMtAiInviteInfoList& default_instance();

  void Swap(TMtAiInviteInfoList* other);

  // implements Message ----------------------------------------------

  TMtAiInviteInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMtAiInviteInfoList& from);
  void MergeFrom(const TMtAiInviteInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mt.TMtAiInviteInfo tAiInvite = 1;
  inline int taiinvite_size() const;
  inline void clear_taiinvite();
  static const int kTAiInviteFieldNumber = 1;
  inline const ::mt::TMtAiInviteInfo& taiinvite(int index) const;
  inline ::mt::TMtAiInviteInfo* mutable_taiinvite(int index);
  inline ::mt::TMtAiInviteInfo* add_taiinvite();
  inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAiInviteInfo >&
      taiinvite() const;
  inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAiInviteInfo >*
      mutable_taiinvite();

  // @@protoc_insertion_point(class_scope:mt.TMtAiInviteInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mt::TMtAiInviteInfo > taiinvite_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TMtAiInviteInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TVendorCheckConfig : public ::google::protobuf::Message {
 public:
  TVendorCheckConfig();
  virtual ~TVendorCheckConfig();

  TVendorCheckConfig(const TVendorCheckConfig& from);

  inline TVendorCheckConfig& operator=(const TVendorCheckConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVendorCheckConfig& default_instance();

  void Swap(TVendorCheckConfig* other);

  // implements Message ----------------------------------------------

  TVendorCheckConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TVendorCheckConfig& from);
  void MergeFrom(const TVendorCheckConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 peerip = 1;
  inline bool has_peerip() const;
  inline void clear_peerip();
  static const int kPeeripFieldNumber = 1;
  inline ::google::protobuf::uint32 peerip() const;
  inline void set_peerip(::google::protobuf::uint32 value);

  // optional uint32 peerport = 2;
  inline bool has_peerport() const;
  inline void clear_peerport();
  static const int kPeerportFieldNumber = 2;
  inline ::google::protobuf::uint32 peerport() const;
  inline void set_peerport(::google::protobuf::uint32 value);

  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional uint32 localport = 4;
  inline bool has_localport() const;
  inline void clear_localport();
  static const int kLocalportFieldNumber = 4;
  inline ::google::protobuf::uint32 localport() const;
  inline void set_localport(::google::protobuf::uint32 value);

  // optional bool is_platform = 5;
  inline bool has_is_platform() const;
  inline void clear_is_platform();
  static const int kIsPlatformFieldNumber = 5;
  inline bool is_platform() const;
  inline void set_is_platform(bool value);

  // @@protoc_insertion_point(class_scope:mt.TVendorCheckConfig)
 private:
  inline void set_has_peerip();
  inline void clear_has_peerip();
  inline void set_has_peerport();
  inline void clear_has_peerport();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_localport();
  inline void clear_has_localport();
  inline void set_has_is_platform();
  inline void clear_has_is_platform();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 peerip_;
  ::google::protobuf::uint32 peerport_;
  ::std::string* path_;
  ::google::protobuf::uint32 localport_;
  bool is_platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_structconf_2eproto();
  friend void protobuf_AssignDesc_structconf_2eproto();
  friend void protobuf_ShutdownFile_structconf_2eproto();

  void InitAsDefaultInstance();
  static TVendorCheckConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// TMtRpRes

// repeated .mt.EmMtResolution res = 1;
inline int TMtRpRes::res_size() const {
  return res_.size();
}
inline void TMtRpRes::clear_res() {
  res_.Clear();
}
inline ::mt::EmMtResolution TMtRpRes::res(int index) const {
  return static_cast< ::mt::EmMtResolution >(res_.Get(index));
}
inline void TMtRpRes::set_res(int index, ::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  res_.Set(index, value);
}
inline void TMtRpRes::add_res(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  res_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TMtRpRes::res() const {
  return res_;
}
inline ::google::protobuf::RepeatedField<int>*
TMtRpRes::mutable_res() {
  return &res_;
}

// -------------------------------------------------------------------

// TVidDes

// optional .mt.EmMtResolution res = 1;
inline bool TVidDes::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVidDes::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVidDes::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVidDes::clear_res() {
  res_ = 0;
  clear_has_res();
}
inline ::mt::EmMtResolution TVidDes::res() const {
  return static_cast< ::mt::EmMtResolution >(res_);
}
inline void TVidDes::set_res(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_res();
  res_ = value;
}

// optional uint32 mpi = 2;
inline bool TVidDes::has_mpi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVidDes::set_has_mpi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVidDes::clear_has_mpi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVidDes::clear_mpi() {
  mpi_ = 0u;
  clear_has_mpi();
}
inline ::google::protobuf::uint32 TVidDes::mpi() const {
  return mpi_;
}
inline void TVidDes::set_mpi(::google::protobuf::uint32 value) {
  set_has_mpi();
  mpi_ = value;
}

// optional uint32 max_bitrate = 3;
inline bool TVidDes::has_max_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVidDes::set_has_max_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVidDes::clear_has_max_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVidDes::clear_max_bitrate() {
  max_bitrate_ = 0u;
  clear_has_max_bitrate();
}
inline ::google::protobuf::uint32 TVidDes::max_bitrate() const {
  return max_bitrate_;
}
inline void TVidDes::set_max_bitrate(::google::protobuf::uint32 value) {
  set_has_max_bitrate();
  max_bitrate_ = value;
}

// -------------------------------------------------------------------

// TVidFormatCap

// optional .mt.EmVidFormat format = 1;
inline bool TVidFormatCap::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVidFormatCap::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVidFormatCap::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVidFormatCap::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::mt::EmVidFormat TVidFormatCap::format() const {
  return static_cast< ::mt::EmVidFormat >(format_);
}
inline void TVidFormatCap::set_format(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_format();
  format_ = value;
}

// repeated .mt.TVidDes item = 2;
inline int TVidFormatCap::item_size() const {
  return item_.size();
}
inline void TVidFormatCap::clear_item() {
  item_.Clear();
}
inline const ::mt::TVidDes& TVidFormatCap::item(int index) const {
  return item_.Get(index);
}
inline ::mt::TVidDes* TVidFormatCap::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::mt::TVidDes* TVidFormatCap::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidDes >&
TVidFormatCap::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidDes >*
TVidFormatCap::mutable_item() {
  return &item_;
}

// optional .mt.EmH264Profile profile = 3;
inline bool TVidFormatCap::has_profile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVidFormatCap::set_has_profile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVidFormatCap::clear_has_profile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVidFormatCap::clear_profile() {
  profile_ = 0;
  clear_has_profile();
}
inline ::mt::EmH264Profile TVidFormatCap::profile() const {
  return static_cast< ::mt::EmH264Profile >(profile_);
}
inline void TVidFormatCap::set_profile(::mt::EmH264Profile value) {
  assert(::mt::EmH264Profile_IsValid(value));
  set_has_profile();
  profile_ = value;
}

// optional .mt.EmH264AdditionalModes h264_modes = 4;
inline bool TVidFormatCap::has_h264_modes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVidFormatCap::set_has_h264_modes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVidFormatCap::clear_has_h264_modes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVidFormatCap::clear_h264_modes() {
  h264_modes_ = 0;
  clear_has_h264_modes();
}
inline ::mt::EmH264AdditionalModes TVidFormatCap::h264_modes() const {
  return static_cast< ::mt::EmH264AdditionalModes >(h264_modes_);
}
inline void TVidFormatCap::set_h264_modes(::mt::EmH264AdditionalModes value) {
  assert(::mt::EmH264AdditionalModes_IsValid(value));
  set_has_h264_modes();
  h264_modes_ = value;
}

// optional .mt.EmH265Profile h265_profile = 5;
inline bool TVidFormatCap::has_h265_profile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVidFormatCap::set_has_h265_profile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVidFormatCap::clear_has_h265_profile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVidFormatCap::clear_h265_profile() {
  h265_profile_ = 0;
  clear_has_h265_profile();
}
inline ::mt::EmH265Profile TVidFormatCap::h265_profile() const {
  return static_cast< ::mt::EmH265Profile >(h265_profile_);
}
inline void TVidFormatCap::set_h265_profile(::mt::EmH265Profile value) {
  assert(::mt::EmH265Profile_IsValid(value));
  set_has_h265_profile();
  h265_profile_ = value;
}

// -------------------------------------------------------------------

// TAudDes

// optional .mt.EmAudFormat format = 1;
inline bool TAudDes::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAudDes::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAudDes::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAudDes::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::mt::EmAudFormat TAudDes::format() const {
  return static_cast< ::mt::EmAudFormat >(format_);
}
inline void TAudDes::set_format(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_format();
  format_ = value;
}

// optional uint32 pack_time = 2;
inline bool TAudDes::has_pack_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAudDes::set_has_pack_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAudDes::clear_has_pack_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAudDes::clear_pack_time() {
  pack_time_ = 0u;
  clear_has_pack_time();
}
inline ::google::protobuf::uint32 TAudDes::pack_time() const {
  return pack_time_;
}
inline void TAudDes::set_pack_time(::google::protobuf::uint32 value) {
  set_has_pack_time();
  pack_time_ = value;
}

// optional .mt.EmAacChnlNum chnl_num = 3;
inline bool TAudDes::has_chnl_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAudDes::set_has_chnl_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAudDes::clear_has_chnl_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAudDes::clear_chnl_num() {
  chnl_num_ = 0;
  clear_has_chnl_num();
}
inline ::mt::EmAacChnlNum TAudDes::chnl_num() const {
  return static_cast< ::mt::EmAacChnlNum >(chnl_num_);
}
inline void TAudDes::set_chnl_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_chnl_num();
  chnl_num_ = value;
}

// optional .mt.EmAacSampFreq samp_freq = 4;
inline bool TAudDes::has_samp_freq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAudDes::set_has_samp_freq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAudDes::clear_has_samp_freq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAudDes::clear_samp_freq() {
  samp_freq_ = 0;
  clear_has_samp_freq();
}
inline ::mt::EmAacSampFreq TAudDes::samp_freq() const {
  return static_cast< ::mt::EmAacSampFreq >(samp_freq_);
}
inline void TAudDes::set_samp_freq(::mt::EmAacSampFreq value) {
  assert(::mt::EmAacSampFreq_IsValid(value));
  set_has_samp_freq();
  samp_freq_ = value;
}

// optional uint32 aac_rate = 5 [default = 96];
inline bool TAudDes::has_aac_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TAudDes::set_has_aac_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TAudDes::clear_has_aac_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TAudDes::clear_aac_rate() {
  aac_rate_ = 96u;
  clear_has_aac_rate();
}
inline ::google::protobuf::uint32 TAudDes::aac_rate() const {
  return aac_rate_;
}
inline void TAudDes::set_aac_rate(::google::protobuf::uint32 value) {
  set_has_aac_rate();
  aac_rate_ = value;
}

// optional uint32 opus_min_rate = 6;
inline bool TAudDes::has_opus_min_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TAudDes::set_has_opus_min_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TAudDes::clear_has_opus_min_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TAudDes::clear_opus_min_rate() {
  opus_min_rate_ = 0u;
  clear_has_opus_min_rate();
}
inline ::google::protobuf::uint32 TAudDes::opus_min_rate() const {
  return opus_min_rate_;
}
inline void TAudDes::set_opus_min_rate(::google::protobuf::uint32 value) {
  set_has_opus_min_rate();
  opus_min_rate_ = value;
}

// optional uint32 opus_max_rate = 7;
inline bool TAudDes::has_opus_max_rate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TAudDes::set_has_opus_max_rate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TAudDes::clear_has_opus_max_rate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TAudDes::clear_opus_max_rate() {
  opus_max_rate_ = 0u;
  clear_has_opus_max_rate();
}
inline ::google::protobuf::uint32 TAudDes::opus_max_rate() const {
  return opus_max_rate_;
}
inline void TAudDes::set_opus_max_rate(::google::protobuf::uint32 value) {
  set_has_opus_max_rate();
  opus_max_rate_ = value;
}

// optional uint32 g7221_rate = 8;
inline bool TAudDes::has_g7221_rate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TAudDes::set_has_g7221_rate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TAudDes::clear_has_g7221_rate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TAudDes::clear_g7221_rate() {
  g7221_rate_ = 0u;
  clear_has_g7221_rate();
}
inline ::google::protobuf::uint32 TAudDes::g7221_rate() const {
  return g7221_rate_;
}
inline void TAudDes::set_g7221_rate(::google::protobuf::uint32 value) {
  set_has_g7221_rate();
  g7221_rate_ = value;
}

// -------------------------------------------------------------------

// TVidCapList

// repeated .mt.TVidFormatCap vid_list = 1;
inline int TVidCapList::vid_list_size() const {
  return vid_list_.size();
}
inline void TVidCapList::clear_vid_list() {
  vid_list_.Clear();
}
inline const ::mt::TVidFormatCap& TVidCapList::vid_list(int index) const {
  return vid_list_.Get(index);
}
inline ::mt::TVidFormatCap* TVidCapList::mutable_vid_list(int index) {
  return vid_list_.Mutable(index);
}
inline ::mt::TVidFormatCap* TVidCapList::add_vid_list() {
  return vid_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidFormatCap >&
TVidCapList::vid_list() const {
  return vid_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidFormatCap >*
TVidCapList::mutable_vid_list() {
  return &vid_list_;
}

// optional .mt.EmMtVidLabel vid_lab = 2;
inline bool TVidCapList::has_vid_lab() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVidCapList::set_has_vid_lab() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVidCapList::clear_has_vid_lab() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVidCapList::clear_vid_lab() {
  vid_lab_ = 0;
  clear_has_vid_lab();
}
inline ::mt::EmMtVidLabel TVidCapList::vid_lab() const {
  return static_cast< ::mt::EmMtVidLabel >(vid_lab_);
}
inline void TVidCapList::set_vid_lab(::mt::EmMtVidLabel value) {
  assert(::mt::EmMtVidLabel_IsValid(value));
  set_has_vid_lab();
  vid_lab_ = value;
}

// optional uint32 app_chan = 3;
inline bool TVidCapList::has_app_chan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVidCapList::set_has_app_chan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVidCapList::clear_has_app_chan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVidCapList::clear_app_chan() {
  app_chan_ = 0u;
  clear_has_app_chan();
}
inline ::google::protobuf::uint32 TVidCapList::app_chan() const {
  return app_chan_;
}
inline void TVidCapList::set_app_chan(::google::protobuf::uint32 value) {
  set_has_app_chan();
  app_chan_ = value;
}

// optional bool active = 4 [default = true];
inline bool TVidCapList::has_active() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVidCapList::set_has_active() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVidCapList::clear_has_active() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVidCapList::clear_active() {
  active_ = true;
  clear_has_active();
}
inline bool TVidCapList::active() const {
  return active_;
}
inline void TVidCapList::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// optional uint32 percent = 5;
inline bool TVidCapList::has_percent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVidCapList::set_has_percent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVidCapList::clear_has_percent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVidCapList::clear_percent() {
  percent_ = 0u;
  clear_has_percent();
}
inline ::google::protobuf::uint32 TVidCapList::percent() const {
  return percent_;
}
inline void TVidCapList::set_percent(::google::protobuf::uint32 value) {
  set_has_percent();
  percent_ = value;
}

// -------------------------------------------------------------------

// TAudCapList

// repeated .mt.TAudDes aud_list = 1;
inline int TAudCapList::aud_list_size() const {
  return aud_list_.size();
}
inline void TAudCapList::clear_aud_list() {
  aud_list_.Clear();
}
inline const ::mt::TAudDes& TAudCapList::aud_list(int index) const {
  return aud_list_.Get(index);
}
inline ::mt::TAudDes* TAudCapList::mutable_aud_list(int index) {
  return aud_list_.Mutable(index);
}
inline ::mt::TAudDes* TAudCapList::add_aud_list() {
  return aud_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudDes >&
TAudCapList::aud_list() const {
  return aud_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudDes >*
TAudCapList::mutable_aud_list() {
  return &aud_list_;
}

// optional .mt.EmMtAudLabel aud_lab = 2;
inline bool TAudCapList::has_aud_lab() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAudCapList::set_has_aud_lab() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAudCapList::clear_has_aud_lab() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAudCapList::clear_aud_lab() {
  aud_lab_ = 0;
  clear_has_aud_lab();
}
inline ::mt::EmMtAudLabel TAudCapList::aud_lab() const {
  return static_cast< ::mt::EmMtAudLabel >(aud_lab_);
}
inline void TAudCapList::set_aud_lab(::mt::EmMtAudLabel value) {
  assert(::mt::EmMtAudLabel_IsValid(value));
  set_has_aud_lab();
  aud_lab_ = value;
}

// optional uint32 app_chan = 3;
inline bool TAudCapList::has_app_chan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAudCapList::set_has_app_chan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAudCapList::clear_has_app_chan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAudCapList::clear_app_chan() {
  app_chan_ = 0u;
  clear_has_app_chan();
}
inline ::google::protobuf::uint32 TAudCapList::app_chan() const {
  return app_chan_;
}
inline void TAudCapList::set_app_chan(::google::protobuf::uint32 value) {
  set_has_app_chan();
  app_chan_ = value;
}

// optional bool active = 4 [default = true];
inline bool TAudCapList::has_active() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAudCapList::set_has_active() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAudCapList::clear_has_active() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAudCapList::clear_active() {
  active_ = true;
  clear_has_active();
}
inline bool TAudCapList::active() const {
  return active_;
}
inline void TAudCapList::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// -------------------------------------------------------------------

// TMtSendCap

// repeated .mt.TAudCapList main_aud_send_cap = 1;
inline int TMtSendCap::main_aud_send_cap_size() const {
  return main_aud_send_cap_.size();
}
inline void TMtSendCap::clear_main_aud_send_cap() {
  main_aud_send_cap_.Clear();
}
inline const ::mt::TAudCapList& TMtSendCap::main_aud_send_cap(int index) const {
  return main_aud_send_cap_.Get(index);
}
inline ::mt::TAudCapList* TMtSendCap::mutable_main_aud_send_cap(int index) {
  return main_aud_send_cap_.Mutable(index);
}
inline ::mt::TAudCapList* TMtSendCap::add_main_aud_send_cap() {
  return main_aud_send_cap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >&
TMtSendCap::main_aud_send_cap() const {
  return main_aud_send_cap_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >*
TMtSendCap::mutable_main_aud_send_cap() {
  return &main_aud_send_cap_;
}

// repeated .mt.TVidCapList main_vid_send_cap = 2;
inline int TMtSendCap::main_vid_send_cap_size() const {
  return main_vid_send_cap_.size();
}
inline void TMtSendCap::clear_main_vid_send_cap() {
  main_vid_send_cap_.Clear();
}
inline const ::mt::TVidCapList& TMtSendCap::main_vid_send_cap(int index) const {
  return main_vid_send_cap_.Get(index);
}
inline ::mt::TVidCapList* TMtSendCap::mutable_main_vid_send_cap(int index) {
  return main_vid_send_cap_.Mutable(index);
}
inline ::mt::TVidCapList* TMtSendCap::add_main_vid_send_cap() {
  return main_vid_send_cap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >&
TMtSendCap::main_vid_send_cap() const {
  return main_vid_send_cap_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >*
TMtSendCap::mutable_main_vid_send_cap() {
  return &main_vid_send_cap_;
}

// repeated .mt.TAudCapList ass_aud_send_cap = 3;
inline int TMtSendCap::ass_aud_send_cap_size() const {
  return ass_aud_send_cap_.size();
}
inline void TMtSendCap::clear_ass_aud_send_cap() {
  ass_aud_send_cap_.Clear();
}
inline const ::mt::TAudCapList& TMtSendCap::ass_aud_send_cap(int index) const {
  return ass_aud_send_cap_.Get(index);
}
inline ::mt::TAudCapList* TMtSendCap::mutable_ass_aud_send_cap(int index) {
  return ass_aud_send_cap_.Mutable(index);
}
inline ::mt::TAudCapList* TMtSendCap::add_ass_aud_send_cap() {
  return ass_aud_send_cap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >&
TMtSendCap::ass_aud_send_cap() const {
  return ass_aud_send_cap_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >*
TMtSendCap::mutable_ass_aud_send_cap() {
  return &ass_aud_send_cap_;
}

// repeated .mt.TVidCapList ass_vid_send_cap = 4;
inline int TMtSendCap::ass_vid_send_cap_size() const {
  return ass_vid_send_cap_.size();
}
inline void TMtSendCap::clear_ass_vid_send_cap() {
  ass_vid_send_cap_.Clear();
}
inline const ::mt::TVidCapList& TMtSendCap::ass_vid_send_cap(int index) const {
  return ass_vid_send_cap_.Get(index);
}
inline ::mt::TVidCapList* TMtSendCap::mutable_ass_vid_send_cap(int index) {
  return ass_vid_send_cap_.Mutable(index);
}
inline ::mt::TVidCapList* TMtSendCap::add_ass_vid_send_cap() {
  return ass_vid_send_cap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >&
TMtSendCap::ass_vid_send_cap() const {
  return ass_vid_send_cap_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >*
TMtSendCap::mutable_ass_vid_send_cap() {
  return &ass_vid_send_cap_;
}

// -------------------------------------------------------------------

// TMtRecvCap

// repeated .mt.TAudCapList main_aud_recv_cap = 1;
inline int TMtRecvCap::main_aud_recv_cap_size() const {
  return main_aud_recv_cap_.size();
}
inline void TMtRecvCap::clear_main_aud_recv_cap() {
  main_aud_recv_cap_.Clear();
}
inline const ::mt::TAudCapList& TMtRecvCap::main_aud_recv_cap(int index) const {
  return main_aud_recv_cap_.Get(index);
}
inline ::mt::TAudCapList* TMtRecvCap::mutable_main_aud_recv_cap(int index) {
  return main_aud_recv_cap_.Mutable(index);
}
inline ::mt::TAudCapList* TMtRecvCap::add_main_aud_recv_cap() {
  return main_aud_recv_cap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >&
TMtRecvCap::main_aud_recv_cap() const {
  return main_aud_recv_cap_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >*
TMtRecvCap::mutable_main_aud_recv_cap() {
  return &main_aud_recv_cap_;
}

// repeated .mt.TVidCapList main_vid_recv_cap = 2;
inline int TMtRecvCap::main_vid_recv_cap_size() const {
  return main_vid_recv_cap_.size();
}
inline void TMtRecvCap::clear_main_vid_recv_cap() {
  main_vid_recv_cap_.Clear();
}
inline const ::mt::TVidCapList& TMtRecvCap::main_vid_recv_cap(int index) const {
  return main_vid_recv_cap_.Get(index);
}
inline ::mt::TVidCapList* TMtRecvCap::mutable_main_vid_recv_cap(int index) {
  return main_vid_recv_cap_.Mutable(index);
}
inline ::mt::TVidCapList* TMtRecvCap::add_main_vid_recv_cap() {
  return main_vid_recv_cap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >&
TMtRecvCap::main_vid_recv_cap() const {
  return main_vid_recv_cap_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >*
TMtRecvCap::mutable_main_vid_recv_cap() {
  return &main_vid_recv_cap_;
}

// repeated .mt.TAudCapList ass_aud_recv_cap = 3;
inline int TMtRecvCap::ass_aud_recv_cap_size() const {
  return ass_aud_recv_cap_.size();
}
inline void TMtRecvCap::clear_ass_aud_recv_cap() {
  ass_aud_recv_cap_.Clear();
}
inline const ::mt::TAudCapList& TMtRecvCap::ass_aud_recv_cap(int index) const {
  return ass_aud_recv_cap_.Get(index);
}
inline ::mt::TAudCapList* TMtRecvCap::mutable_ass_aud_recv_cap(int index) {
  return ass_aud_recv_cap_.Mutable(index);
}
inline ::mt::TAudCapList* TMtRecvCap::add_ass_aud_recv_cap() {
  return ass_aud_recv_cap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >&
TMtRecvCap::ass_aud_recv_cap() const {
  return ass_aud_recv_cap_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudCapList >*
TMtRecvCap::mutable_ass_aud_recv_cap() {
  return &ass_aud_recv_cap_;
}

// repeated .mt.TVidCapList ass_vid_recv_cap = 4;
inline int TMtRecvCap::ass_vid_recv_cap_size() const {
  return ass_vid_recv_cap_.size();
}
inline void TMtRecvCap::clear_ass_vid_recv_cap() {
  ass_vid_recv_cap_.Clear();
}
inline const ::mt::TVidCapList& TMtRecvCap::ass_vid_recv_cap(int index) const {
  return ass_vid_recv_cap_.Get(index);
}
inline ::mt::TVidCapList* TMtRecvCap::mutable_ass_vid_recv_cap(int index) {
  return ass_vid_recv_cap_.Mutable(index);
}
inline ::mt::TVidCapList* TMtRecvCap::add_ass_vid_recv_cap() {
  return ass_vid_recv_cap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >&
TMtRecvCap::ass_vid_recv_cap() const {
  return ass_vid_recv_cap_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidCapList >*
TMtRecvCap::mutable_ass_vid_recv_cap() {
  return &ass_vid_recv_cap_;
}

// optional .mt.TDecCap h323_dec_cap = 5;
inline bool TMtRecvCap::has_h323_dec_cap() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtRecvCap::set_has_h323_dec_cap() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtRecvCap::clear_has_h323_dec_cap() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtRecvCap::clear_h323_dec_cap() {
  if (h323_dec_cap_ != NULL) h323_dec_cap_->::mt::TDecCap::Clear();
  clear_has_h323_dec_cap();
}
inline const ::mt::TDecCap& TMtRecvCap::h323_dec_cap() const {
  return h323_dec_cap_ != NULL ? *h323_dec_cap_ : *default_instance_->h323_dec_cap_;
}
inline ::mt::TDecCap* TMtRecvCap::mutable_h323_dec_cap() {
  set_has_h323_dec_cap();
  if (h323_dec_cap_ == NULL) h323_dec_cap_ = new ::mt::TDecCap;
  return h323_dec_cap_;
}
inline ::mt::TDecCap* TMtRecvCap::release_h323_dec_cap() {
  clear_has_h323_dec_cap();
  ::mt::TDecCap* temp = h323_dec_cap_;
  h323_dec_cap_ = NULL;
  return temp;
}
inline void TMtRecvCap::set_allocated_h323_dec_cap(::mt::TDecCap* h323_dec_cap) {
  delete h323_dec_cap_;
  h323_dec_cap_ = h323_dec_cap;
  if (h323_dec_cap) {
    set_has_h323_dec_cap();
  } else {
    clear_has_h323_dec_cap();
  }
}

// -------------------------------------------------------------------

// TDecCap

// repeated .mt.TDecSimuCap dec_simu_cap = 1;
inline int TDecCap::dec_simu_cap_size() const {
  return dec_simu_cap_.size();
}
inline void TDecCap::clear_dec_simu_cap() {
  dec_simu_cap_.Clear();
}
inline const ::mt::TDecSimuCap& TDecCap::dec_simu_cap(int index) const {
  return dec_simu_cap_.Get(index);
}
inline ::mt::TDecSimuCap* TDecCap::mutable_dec_simu_cap(int index) {
  return dec_simu_cap_.Mutable(index);
}
inline ::mt::TDecSimuCap* TDecCap::add_dec_simu_cap() {
  return dec_simu_cap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TDecSimuCap >&
TDecCap::dec_simu_cap() const {
  return dec_simu_cap_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TDecSimuCap >*
TDecCap::mutable_dec_simu_cap() {
  return &dec_simu_cap_;
}

// -------------------------------------------------------------------

// TDecSimuCap

// repeated uint32 aud_list = 1;
inline int TDecSimuCap::aud_list_size() const {
  return aud_list_.size();
}
inline void TDecSimuCap::clear_aud_list() {
  aud_list_.Clear();
}
inline ::google::protobuf::uint32 TDecSimuCap::aud_list(int index) const {
  return aud_list_.Get(index);
}
inline void TDecSimuCap::set_aud_list(int index, ::google::protobuf::uint32 value) {
  aud_list_.Set(index, value);
}
inline void TDecSimuCap::add_aud_list(::google::protobuf::uint32 value) {
  aud_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TDecSimuCap::aud_list() const {
  return aud_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TDecSimuCap::mutable_aud_list() {
  return &aud_list_;
}

// repeated uint32 main_vid_list = 2;
inline int TDecSimuCap::main_vid_list_size() const {
  return main_vid_list_.size();
}
inline void TDecSimuCap::clear_main_vid_list() {
  main_vid_list_.Clear();
}
inline ::google::protobuf::uint32 TDecSimuCap::main_vid_list(int index) const {
  return main_vid_list_.Get(index);
}
inline void TDecSimuCap::set_main_vid_list(int index, ::google::protobuf::uint32 value) {
  main_vid_list_.Set(index, value);
}
inline void TDecSimuCap::add_main_vid_list(::google::protobuf::uint32 value) {
  main_vid_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TDecSimuCap::main_vid_list() const {
  return main_vid_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TDecSimuCap::mutable_main_vid_list() {
  return &main_vid_list_;
}

// repeated uint32 ass_vid_list = 3;
inline int TDecSimuCap::ass_vid_list_size() const {
  return ass_vid_list_.size();
}
inline void TDecSimuCap::clear_ass_vid_list() {
  ass_vid_list_.Clear();
}
inline ::google::protobuf::uint32 TDecSimuCap::ass_vid_list(int index) const {
  return ass_vid_list_.Get(index);
}
inline void TDecSimuCap::set_ass_vid_list(int index, ::google::protobuf::uint32 value) {
  ass_vid_list_.Set(index, value);
}
inline void TDecSimuCap::add_ass_vid_list(::google::protobuf::uint32 value) {
  ass_vid_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TDecSimuCap::ass_vid_list() const {
  return ass_vid_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TDecSimuCap::mutable_ass_vid_list() {
  return &ass_vid_list_;
}

// -------------------------------------------------------------------

// TMtCap

// optional .mt.TMtSendCap send_cap = 1;
inline bool TMtCap::has_send_cap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtCap::set_has_send_cap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtCap::clear_has_send_cap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtCap::clear_send_cap() {
  if (send_cap_ != NULL) send_cap_->::mt::TMtSendCap::Clear();
  clear_has_send_cap();
}
inline const ::mt::TMtSendCap& TMtCap::send_cap() const {
  return send_cap_ != NULL ? *send_cap_ : *default_instance_->send_cap_;
}
inline ::mt::TMtSendCap* TMtCap::mutable_send_cap() {
  set_has_send_cap();
  if (send_cap_ == NULL) send_cap_ = new ::mt::TMtSendCap;
  return send_cap_;
}
inline ::mt::TMtSendCap* TMtCap::release_send_cap() {
  clear_has_send_cap();
  ::mt::TMtSendCap* temp = send_cap_;
  send_cap_ = NULL;
  return temp;
}
inline void TMtCap::set_allocated_send_cap(::mt::TMtSendCap* send_cap) {
  delete send_cap_;
  send_cap_ = send_cap;
  if (send_cap) {
    set_has_send_cap();
  } else {
    clear_has_send_cap();
  }
}

// optional .mt.TMtRecvCap recv_cap = 2;
inline bool TMtCap::has_recv_cap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtCap::set_has_recv_cap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtCap::clear_has_recv_cap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtCap::clear_recv_cap() {
  if (recv_cap_ != NULL) recv_cap_->::mt::TMtRecvCap::Clear();
  clear_has_recv_cap();
}
inline const ::mt::TMtRecvCap& TMtCap::recv_cap() const {
  return recv_cap_ != NULL ? *recv_cap_ : *default_instance_->recv_cap_;
}
inline ::mt::TMtRecvCap* TMtCap::mutable_recv_cap() {
  set_has_recv_cap();
  if (recv_cap_ == NULL) recv_cap_ = new ::mt::TMtRecvCap;
  return recv_cap_;
}
inline ::mt::TMtRecvCap* TMtCap::release_recv_cap() {
  clear_has_recv_cap();
  ::mt::TMtRecvCap* temp = recv_cap_;
  recv_cap_ = NULL;
  return temp;
}
inline void TMtCap::set_allocated_recv_cap(::mt::TMtRecvCap* recv_cap) {
  delete recv_cap_;
  recv_cap_ = recv_cap;
  if (recv_cap) {
    set_has_recv_cap();
  } else {
    clear_has_recv_cap();
  }
}

// optional uint32 vendor = 3;
inline bool TMtCap::has_vendor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtCap::set_has_vendor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtCap::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtCap::clear_vendor() {
  vendor_ = 0u;
  clear_has_vendor();
}
inline ::google::protobuf::uint32 TMtCap::vendor() const {
  return vendor_;
}
inline void TMtCap::set_vendor(::google::protobuf::uint32 value) {
  set_has_vendor();
  vendor_ = value;
}

// -------------------------------------------------------------------

// TRpMtCap

// repeated .mt.TMtCap mt_cap = 1;
inline int TRpMtCap::mt_cap_size() const {
  return mt_cap_.size();
}
inline void TRpMtCap::clear_mt_cap() {
  mt_cap_.Clear();
}
inline const ::mt::TMtCap& TRpMtCap::mt_cap(int index) const {
  return mt_cap_.Get(index);
}
inline ::mt::TMtCap* TRpMtCap::mutable_mt_cap(int index) {
  return mt_cap_.Mutable(index);
}
inline ::mt::TMtCap* TRpMtCap::add_mt_cap() {
  return mt_cap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtCap >&
TRpMtCap::mt_cap() const {
  return mt_cap_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtCap >*
TRpMtCap::mutable_mt_cap() {
  return &mt_cap_;
}

// -------------------------------------------------------------------

// TMtConfHandle

// optional uint32 chan = 1;
inline bool TMtConfHandle::has_chan() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtConfHandle::set_has_chan() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtConfHandle::clear_has_chan() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtConfHandle::clear_chan() {
  chan_ = 0u;
  clear_has_chan();
}
inline ::google::protobuf::uint32 TMtConfHandle::chan() const {
  return chan_;
}
inline void TMtConfHandle::set_chan(::google::protobuf::uint32 value) {
  set_has_chan();
  chan_ = value;
}

// optional uint32 app_chan = 2;
inline bool TMtConfHandle::has_app_chan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtConfHandle::set_has_app_chan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtConfHandle::clear_has_app_chan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtConfHandle::clear_app_chan() {
  app_chan_ = 0u;
  clear_has_app_chan();
}
inline ::google::protobuf::uint32 TMtConfHandle::app_chan() const {
  return app_chan_;
}
inline void TMtConfHandle::set_app_chan(::google::protobuf::uint32 value) {
  set_has_app_chan();
  app_chan_ = value;
}

// -------------------------------------------------------------------

// TMtChanAddr

// optional .mt.TNetAddr local_rtp = 1;
inline bool TMtChanAddr::has_local_rtp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtChanAddr::set_has_local_rtp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtChanAddr::clear_has_local_rtp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtChanAddr::clear_local_rtp() {
  if (local_rtp_ != NULL) local_rtp_->::mt::TNetAddr::Clear();
  clear_has_local_rtp();
}
inline const ::mt::TNetAddr& TMtChanAddr::local_rtp() const {
  return local_rtp_ != NULL ? *local_rtp_ : *default_instance_->local_rtp_;
}
inline ::mt::TNetAddr* TMtChanAddr::mutable_local_rtp() {
  set_has_local_rtp();
  if (local_rtp_ == NULL) local_rtp_ = new ::mt::TNetAddr;
  return local_rtp_;
}
inline ::mt::TNetAddr* TMtChanAddr::release_local_rtp() {
  clear_has_local_rtp();
  ::mt::TNetAddr* temp = local_rtp_;
  local_rtp_ = NULL;
  return temp;
}
inline void TMtChanAddr::set_allocated_local_rtp(::mt::TNetAddr* local_rtp) {
  delete local_rtp_;
  local_rtp_ = local_rtp;
  if (local_rtp) {
    set_has_local_rtp();
  } else {
    clear_has_local_rtp();
  }
}

// optional .mt.TNetAddr local_rtcp = 2;
inline bool TMtChanAddr::has_local_rtcp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtChanAddr::set_has_local_rtcp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtChanAddr::clear_has_local_rtcp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtChanAddr::clear_local_rtcp() {
  if (local_rtcp_ != NULL) local_rtcp_->::mt::TNetAddr::Clear();
  clear_has_local_rtcp();
}
inline const ::mt::TNetAddr& TMtChanAddr::local_rtcp() const {
  return local_rtcp_ != NULL ? *local_rtcp_ : *default_instance_->local_rtcp_;
}
inline ::mt::TNetAddr* TMtChanAddr::mutable_local_rtcp() {
  set_has_local_rtcp();
  if (local_rtcp_ == NULL) local_rtcp_ = new ::mt::TNetAddr;
  return local_rtcp_;
}
inline ::mt::TNetAddr* TMtChanAddr::release_local_rtcp() {
  clear_has_local_rtcp();
  ::mt::TNetAddr* temp = local_rtcp_;
  local_rtcp_ = NULL;
  return temp;
}
inline void TMtChanAddr::set_allocated_local_rtcp(::mt::TNetAddr* local_rtcp) {
  delete local_rtcp_;
  local_rtcp_ = local_rtcp;
  if (local_rtcp) {
    set_has_local_rtcp();
  } else {
    clear_has_local_rtcp();
  }
}

// optional .mt.TNetAddr peer_rtp = 3;
inline bool TMtChanAddr::has_peer_rtp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtChanAddr::set_has_peer_rtp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtChanAddr::clear_has_peer_rtp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtChanAddr::clear_peer_rtp() {
  if (peer_rtp_ != NULL) peer_rtp_->::mt::TNetAddr::Clear();
  clear_has_peer_rtp();
}
inline const ::mt::TNetAddr& TMtChanAddr::peer_rtp() const {
  return peer_rtp_ != NULL ? *peer_rtp_ : *default_instance_->peer_rtp_;
}
inline ::mt::TNetAddr* TMtChanAddr::mutable_peer_rtp() {
  set_has_peer_rtp();
  if (peer_rtp_ == NULL) peer_rtp_ = new ::mt::TNetAddr;
  return peer_rtp_;
}
inline ::mt::TNetAddr* TMtChanAddr::release_peer_rtp() {
  clear_has_peer_rtp();
  ::mt::TNetAddr* temp = peer_rtp_;
  peer_rtp_ = NULL;
  return temp;
}
inline void TMtChanAddr::set_allocated_peer_rtp(::mt::TNetAddr* peer_rtp) {
  delete peer_rtp_;
  peer_rtp_ = peer_rtp;
  if (peer_rtp) {
    set_has_peer_rtp();
  } else {
    clear_has_peer_rtp();
  }
}

// optional .mt.TNetAddr peer_rtcp = 4;
inline bool TMtChanAddr::has_peer_rtcp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtChanAddr::set_has_peer_rtcp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtChanAddr::clear_has_peer_rtcp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtChanAddr::clear_peer_rtcp() {
  if (peer_rtcp_ != NULL) peer_rtcp_->::mt::TNetAddr::Clear();
  clear_has_peer_rtcp();
}
inline const ::mt::TNetAddr& TMtChanAddr::peer_rtcp() const {
  return peer_rtcp_ != NULL ? *peer_rtcp_ : *default_instance_->peer_rtcp_;
}
inline ::mt::TNetAddr* TMtChanAddr::mutable_peer_rtcp() {
  set_has_peer_rtcp();
  if (peer_rtcp_ == NULL) peer_rtcp_ = new ::mt::TNetAddr;
  return peer_rtcp_;
}
inline ::mt::TNetAddr* TMtChanAddr::release_peer_rtcp() {
  clear_has_peer_rtcp();
  ::mt::TNetAddr* temp = peer_rtcp_;
  peer_rtcp_ = NULL;
  return temp;
}
inline void TMtChanAddr::set_allocated_peer_rtcp(::mt::TNetAddr* peer_rtcp) {
  delete peer_rtcp_;
  peer_rtcp_ = peer_rtcp;
  if (peer_rtcp) {
    set_has_peer_rtcp();
  } else {
    clear_has_peer_rtcp();
  }
}

// -------------------------------------------------------------------

// TChanDsInfo

// optional .mt.EmMtChanType chan_type = 1;
inline bool TChanDsInfo::has_chan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TChanDsInfo::set_has_chan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TChanDsInfo::clear_has_chan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TChanDsInfo::clear_chan_type() {
  chan_type_ = 0;
  clear_has_chan_type();
}
inline ::mt::EmMtChanType TChanDsInfo::chan_type() const {
  return static_cast< ::mt::EmMtChanType >(chan_type_);
}
inline void TChanDsInfo::set_chan_type(::mt::EmMtChanType value) {
  assert(::mt::EmMtChanType_IsValid(value));
  set_has_chan_type();
  chan_type_ = value;
}

// repeated .mt.TOneChanDSInfo one_chan_info = 2;
inline int TChanDsInfo::one_chan_info_size() const {
  return one_chan_info_.size();
}
inline void TChanDsInfo::clear_one_chan_info() {
  one_chan_info_.Clear();
}
inline const ::mt::TOneChanDSInfo& TChanDsInfo::one_chan_info(int index) const {
  return one_chan_info_.Get(index);
}
inline ::mt::TOneChanDSInfo* TChanDsInfo::mutable_one_chan_info(int index) {
  return one_chan_info_.Mutable(index);
}
inline ::mt::TOneChanDSInfo* TChanDsInfo::add_one_chan_info() {
  return one_chan_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TOneChanDSInfo >&
TChanDsInfo::one_chan_info() const {
  return one_chan_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TOneChanDSInfo >*
TChanDsInfo::mutable_one_chan_info() {
  return &one_chan_info_;
}

// -------------------------------------------------------------------

// TMutiChanDsInfo

// repeated .mt.TChanDsInfo chan_info = 1;
inline int TMutiChanDsInfo::chan_info_size() const {
  return chan_info_.size();
}
inline void TMutiChanDsInfo::clear_chan_info() {
  chan_info_.Clear();
}
inline const ::mt::TChanDsInfo& TMutiChanDsInfo::chan_info(int index) const {
  return chan_info_.Get(index);
}
inline ::mt::TChanDsInfo* TMutiChanDsInfo::mutable_chan_info(int index) {
  return chan_info_.Mutable(index);
}
inline ::mt::TChanDsInfo* TMutiChanDsInfo::add_chan_info() {
  return chan_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TChanDsInfo >&
TMutiChanDsInfo::chan_info() const {
  return chan_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TChanDsInfo >*
TMutiChanDsInfo::mutable_chan_info() {
  return &chan_info_;
}

// -------------------------------------------------------------------

// TOneChanDSInfo

// optional .mt.EmMtChanState chan_state = 1;
inline bool TOneChanDSInfo::has_chan_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TOneChanDSInfo::set_has_chan_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TOneChanDSInfo::clear_has_chan_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TOneChanDSInfo::clear_chan_state() {
  chan_state_ = 0;
  clear_has_chan_state();
}
inline ::mt::EmMtChanState TOneChanDSInfo::chan_state() const {
  return static_cast< ::mt::EmMtChanState >(chan_state_);
}
inline void TOneChanDSInfo::set_chan_state(::mt::EmMtChanState value) {
  assert(::mt::EmMtChanState_IsValid(value));
  set_has_chan_state();
  chan_state_ = value;
}

// optional bool bactive = 2;
inline bool TOneChanDSInfo::has_bactive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TOneChanDSInfo::set_has_bactive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TOneChanDSInfo::clear_has_bactive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TOneChanDSInfo::clear_bactive() {
  bactive_ = false;
  clear_has_bactive();
}
inline bool TOneChanDSInfo::bactive() const {
  return bactive_;
}
inline void TOneChanDSInfo::set_bactive(bool value) {
  set_has_bactive();
  bactive_ = value;
}

// optional .mt.TEncryptKey encry_key = 3;
inline bool TOneChanDSInfo::has_encry_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TOneChanDSInfo::set_has_encry_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TOneChanDSInfo::clear_has_encry_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TOneChanDSInfo::clear_encry_key() {
  if (encry_key_ != NULL) encry_key_->::mt::TEncryptKey::Clear();
  clear_has_encry_key();
}
inline const ::mt::TEncryptKey& TOneChanDSInfo::encry_key() const {
  return encry_key_ != NULL ? *encry_key_ : *default_instance_->encry_key_;
}
inline ::mt::TEncryptKey* TOneChanDSInfo::mutable_encry_key() {
  set_has_encry_key();
  if (encry_key_ == NULL) encry_key_ = new ::mt::TEncryptKey;
  return encry_key_;
}
inline ::mt::TEncryptKey* TOneChanDSInfo::release_encry_key() {
  clear_has_encry_key();
  ::mt::TEncryptKey* temp = encry_key_;
  encry_key_ = NULL;
  return temp;
}
inline void TOneChanDSInfo::set_allocated_encry_key(::mt::TEncryptKey* encry_key) {
  delete encry_key_;
  encry_key_ = encry_key;
  if (encry_key) {
    set_has_encry_key();
  } else {
    clear_has_encry_key();
  }
}

// optional .mt.TMtChanAddr chan_addr = 4;
inline bool TOneChanDSInfo::has_chan_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TOneChanDSInfo::set_has_chan_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TOneChanDSInfo::clear_has_chan_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TOneChanDSInfo::clear_chan_addr() {
  if (chan_addr_ != NULL) chan_addr_->::mt::TMtChanAddr::Clear();
  clear_has_chan_addr();
}
inline const ::mt::TMtChanAddr& TOneChanDSInfo::chan_addr() const {
  return chan_addr_ != NULL ? *chan_addr_ : *default_instance_->chan_addr_;
}
inline ::mt::TMtChanAddr* TOneChanDSInfo::mutable_chan_addr() {
  set_has_chan_addr();
  if (chan_addr_ == NULL) chan_addr_ = new ::mt::TMtChanAddr;
  return chan_addr_;
}
inline ::mt::TMtChanAddr* TOneChanDSInfo::release_chan_addr() {
  clear_has_chan_addr();
  ::mt::TMtChanAddr* temp = chan_addr_;
  chan_addr_ = NULL;
  return temp;
}
inline void TOneChanDSInfo::set_allocated_chan_addr(::mt::TMtChanAddr* chan_addr) {
  delete chan_addr_;
  chan_addr_ = chan_addr;
  if (chan_addr) {
    set_has_chan_addr();
  } else {
    clear_has_chan_addr();
  }
}

// optional .mt.EmMtAudLabel aud_label = 5;
inline bool TOneChanDSInfo::has_aud_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TOneChanDSInfo::set_has_aud_label() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TOneChanDSInfo::clear_has_aud_label() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TOneChanDSInfo::clear_aud_label() {
  aud_label_ = 0;
  clear_has_aud_label();
}
inline ::mt::EmMtAudLabel TOneChanDSInfo::aud_label() const {
  return static_cast< ::mt::EmMtAudLabel >(aud_label_);
}
inline void TOneChanDSInfo::set_aud_label(::mt::EmMtAudLabel value) {
  assert(::mt::EmMtAudLabel_IsValid(value));
  set_has_aud_label();
  aud_label_ = value;
}

// optional .mt.EmAudFormat aud_format = 6;
inline bool TOneChanDSInfo::has_aud_format() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TOneChanDSInfo::set_has_aud_format() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TOneChanDSInfo::clear_has_aud_format() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TOneChanDSInfo::clear_aud_format() {
  aud_format_ = 0;
  clear_has_aud_format();
}
inline ::mt::EmAudFormat TOneChanDSInfo::aud_format() const {
  return static_cast< ::mt::EmAudFormat >(aud_format_);
}
inline void TOneChanDSInfo::set_aud_format(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_aud_format();
  aud_format_ = value;
}

// optional .mt.EmAacChnlNum aac_chnl_num = 7;
inline bool TOneChanDSInfo::has_aac_chnl_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TOneChanDSInfo::set_has_aac_chnl_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TOneChanDSInfo::clear_has_aac_chnl_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TOneChanDSInfo::clear_aac_chnl_num() {
  aac_chnl_num_ = 0;
  clear_has_aac_chnl_num();
}
inline ::mt::EmAacChnlNum TOneChanDSInfo::aac_chnl_num() const {
  return static_cast< ::mt::EmAacChnlNum >(aac_chnl_num_);
}
inline void TOneChanDSInfo::set_aac_chnl_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_aac_chnl_num();
  aac_chnl_num_ = value;
}

// optional bool bg7221_reverse = 8;
inline bool TOneChanDSInfo::has_bg7221_reverse() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TOneChanDSInfo::set_has_bg7221_reverse() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TOneChanDSInfo::clear_has_bg7221_reverse() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TOneChanDSInfo::clear_bg7221_reverse() {
  bg7221_reverse_ = false;
  clear_has_bg7221_reverse();
}
inline bool TOneChanDSInfo::bg7221_reverse() const {
  return bg7221_reverse_;
}
inline void TOneChanDSInfo::set_bg7221_reverse(bool value) {
  set_has_bg7221_reverse();
  bg7221_reverse_ = value;
}

// optional .mt.EmMtVidLabel vid_label = 9;
inline bool TOneChanDSInfo::has_vid_label() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TOneChanDSInfo::set_has_vid_label() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TOneChanDSInfo::clear_has_vid_label() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TOneChanDSInfo::clear_vid_label() {
  vid_label_ = 0;
  clear_has_vid_label();
}
inline ::mt::EmMtVidLabel TOneChanDSInfo::vid_label() const {
  return static_cast< ::mt::EmMtVidLabel >(vid_label_);
}
inline void TOneChanDSInfo::set_vid_label(::mt::EmMtVidLabel value) {
  assert(::mt::EmMtVidLabel_IsValid(value));
  set_has_vid_label();
  vid_label_ = value;
}

// optional .mt.EmVidFormat vid_format = 10;
inline bool TOneChanDSInfo::has_vid_format() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TOneChanDSInfo::set_has_vid_format() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TOneChanDSInfo::clear_has_vid_format() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TOneChanDSInfo::clear_vid_format() {
  vid_format_ = 0;
  clear_has_vid_format();
}
inline ::mt::EmVidFormat TOneChanDSInfo::vid_format() const {
  return static_cast< ::mt::EmVidFormat >(vid_format_);
}
inline void TOneChanDSInfo::set_vid_format(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_vid_format();
  vid_format_ = value;
}

// optional .mt.EmMtResolution vid_resolution = 11;
inline bool TOneChanDSInfo::has_vid_resolution() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TOneChanDSInfo::set_has_vid_resolution() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TOneChanDSInfo::clear_has_vid_resolution() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TOneChanDSInfo::clear_vid_resolution() {
  vid_resolution_ = 0;
  clear_has_vid_resolution();
}
inline ::mt::EmMtResolution TOneChanDSInfo::vid_resolution() const {
  return static_cast< ::mt::EmMtResolution >(vid_resolution_);
}
inline void TOneChanDSInfo::set_vid_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_vid_resolution();
  vid_resolution_ = value;
}

// optional uint32 frame_rate = 12;
inline bool TOneChanDSInfo::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TOneChanDSInfo::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TOneChanDSInfo::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TOneChanDSInfo::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TOneChanDSInfo::frame_rate() const {
  return frame_rate_;
}
inline void TOneChanDSInfo::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// optional .mt.EmH264Profile h264_profile = 13;
inline bool TOneChanDSInfo::has_h264_profile() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TOneChanDSInfo::set_has_h264_profile() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TOneChanDSInfo::clear_has_h264_profile() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TOneChanDSInfo::clear_h264_profile() {
  h264_profile_ = 0;
  clear_has_h264_profile();
}
inline ::mt::EmH264Profile TOneChanDSInfo::h264_profile() const {
  return static_cast< ::mt::EmH264Profile >(h264_profile_);
}
inline void TOneChanDSInfo::set_h264_profile(::mt::EmH264Profile value) {
  assert(::mt::EmH264Profile_IsValid(value));
  set_has_h264_profile();
  h264_profile_ = value;
}

// optional .mt.EmEncryptArithmetic emEncrypt = 14;
inline bool TOneChanDSInfo::has_emencrypt() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TOneChanDSInfo::set_has_emencrypt() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TOneChanDSInfo::clear_has_emencrypt() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TOneChanDSInfo::clear_emencrypt() {
  emencrypt_ = 0;
  clear_has_emencrypt();
}
inline ::mt::EmEncryptArithmetic TOneChanDSInfo::emencrypt() const {
  return static_cast< ::mt::EmEncryptArithmetic >(emencrypt_);
}
inline void TOneChanDSInfo::set_emencrypt(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_emencrypt();
  emencrypt_ = value;
}

// optional uint32 chanbitrate = 15;
inline bool TOneChanDSInfo::has_chanbitrate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TOneChanDSInfo::set_has_chanbitrate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TOneChanDSInfo::clear_has_chanbitrate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TOneChanDSInfo::clear_chanbitrate() {
  chanbitrate_ = 0u;
  clear_has_chanbitrate();
}
inline ::google::protobuf::uint32 TOneChanDSInfo::chanbitrate() const {
  return chanbitrate_;
}
inline void TOneChanDSInfo::set_chanbitrate(::google::protobuf::uint32 value) {
  set_has_chanbitrate();
  chanbitrate_ = value;
}

// optional uint32 payload = 16;
inline bool TOneChanDSInfo::has_payload() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TOneChanDSInfo::set_has_payload() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TOneChanDSInfo::clear_has_payload() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TOneChanDSInfo::clear_payload() {
  payload_ = 0u;
  clear_has_payload();
}
inline ::google::protobuf::uint32 TOneChanDSInfo::payload() const {
  return payload_;
}
inline void TOneChanDSInfo::set_payload(::google::protobuf::uint32 value) {
  set_has_payload();
  payload_ = value;
}

// optional .mt.TNetAddr forward_rtp = 20;
inline bool TOneChanDSInfo::has_forward_rtp() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TOneChanDSInfo::set_has_forward_rtp() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TOneChanDSInfo::clear_has_forward_rtp() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TOneChanDSInfo::clear_forward_rtp() {
  if (forward_rtp_ != NULL) forward_rtp_->::mt::TNetAddr::Clear();
  clear_has_forward_rtp();
}
inline const ::mt::TNetAddr& TOneChanDSInfo::forward_rtp() const {
  return forward_rtp_ != NULL ? *forward_rtp_ : *default_instance_->forward_rtp_;
}
inline ::mt::TNetAddr* TOneChanDSInfo::mutable_forward_rtp() {
  set_has_forward_rtp();
  if (forward_rtp_ == NULL) forward_rtp_ = new ::mt::TNetAddr;
  return forward_rtp_;
}
inline ::mt::TNetAddr* TOneChanDSInfo::release_forward_rtp() {
  clear_has_forward_rtp();
  ::mt::TNetAddr* temp = forward_rtp_;
  forward_rtp_ = NULL;
  return temp;
}
inline void TOneChanDSInfo::set_allocated_forward_rtp(::mt::TNetAddr* forward_rtp) {
  delete forward_rtp_;
  forward_rtp_ = forward_rtp;
  if (forward_rtp) {
    set_has_forward_rtp();
  } else {
    clear_has_forward_rtp();
  }
}

// optional .mt.TNetAddr forward_rtcp = 21;
inline bool TOneChanDSInfo::has_forward_rtcp() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TOneChanDSInfo::set_has_forward_rtcp() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TOneChanDSInfo::clear_has_forward_rtcp() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TOneChanDSInfo::clear_forward_rtcp() {
  if (forward_rtcp_ != NULL) forward_rtcp_->::mt::TNetAddr::Clear();
  clear_has_forward_rtcp();
}
inline const ::mt::TNetAddr& TOneChanDSInfo::forward_rtcp() const {
  return forward_rtcp_ != NULL ? *forward_rtcp_ : *default_instance_->forward_rtcp_;
}
inline ::mt::TNetAddr* TOneChanDSInfo::mutable_forward_rtcp() {
  set_has_forward_rtcp();
  if (forward_rtcp_ == NULL) forward_rtcp_ = new ::mt::TNetAddr;
  return forward_rtcp_;
}
inline ::mt::TNetAddr* TOneChanDSInfo::release_forward_rtcp() {
  clear_has_forward_rtcp();
  ::mt::TNetAddr* temp = forward_rtcp_;
  forward_rtcp_ = NULL;
  return temp;
}
inline void TOneChanDSInfo::set_allocated_forward_rtcp(::mt::TNetAddr* forward_rtcp) {
  delete forward_rtcp_;
  forward_rtcp_ = forward_rtcp;
  if (forward_rtcp) {
    set_has_forward_rtcp();
  } else {
    clear_has_forward_rtcp();
  }
}

// optional .mt.TNetAddr pc_rtcp = 22;
inline bool TOneChanDSInfo::has_pc_rtcp() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TOneChanDSInfo::set_has_pc_rtcp() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TOneChanDSInfo::clear_has_pc_rtcp() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TOneChanDSInfo::clear_pc_rtcp() {
  if (pc_rtcp_ != NULL) pc_rtcp_->::mt::TNetAddr::Clear();
  clear_has_pc_rtcp();
}
inline const ::mt::TNetAddr& TOneChanDSInfo::pc_rtcp() const {
  return pc_rtcp_ != NULL ? *pc_rtcp_ : *default_instance_->pc_rtcp_;
}
inline ::mt::TNetAddr* TOneChanDSInfo::mutable_pc_rtcp() {
  set_has_pc_rtcp();
  if (pc_rtcp_ == NULL) pc_rtcp_ = new ::mt::TNetAddr;
  return pc_rtcp_;
}
inline ::mt::TNetAddr* TOneChanDSInfo::release_pc_rtcp() {
  clear_has_pc_rtcp();
  ::mt::TNetAddr* temp = pc_rtcp_;
  pc_rtcp_ = NULL;
  return temp;
}
inline void TOneChanDSInfo::set_allocated_pc_rtcp(::mt::TNetAddr* pc_rtcp) {
  delete pc_rtcp_;
  pc_rtcp_ = pc_rtcp;
  if (pc_rtcp) {
    set_has_pc_rtcp();
  } else {
    clear_has_pc_rtcp();
  }
}

// optional .mt.TMtConfHandle conf_handle = 23;
inline bool TOneChanDSInfo::has_conf_handle() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TOneChanDSInfo::set_has_conf_handle() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TOneChanDSInfo::clear_has_conf_handle() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TOneChanDSInfo::clear_conf_handle() {
  if (conf_handle_ != NULL) conf_handle_->::mt::TMtConfHandle::Clear();
  clear_has_conf_handle();
}
inline const ::mt::TMtConfHandle& TOneChanDSInfo::conf_handle() const {
  return conf_handle_ != NULL ? *conf_handle_ : *default_instance_->conf_handle_;
}
inline ::mt::TMtConfHandle* TOneChanDSInfo::mutable_conf_handle() {
  set_has_conf_handle();
  if (conf_handle_ == NULL) conf_handle_ = new ::mt::TMtConfHandle;
  return conf_handle_;
}
inline ::mt::TMtConfHandle* TOneChanDSInfo::release_conf_handle() {
  clear_has_conf_handle();
  ::mt::TMtConfHandle* temp = conf_handle_;
  conf_handle_ = NULL;
  return temp;
}
inline void TOneChanDSInfo::set_allocated_conf_handle(::mt::TMtConfHandle* conf_handle) {
  delete conf_handle_;
  conf_handle_ = conf_handle;
  if (conf_handle) {
    set_has_conf_handle();
  } else {
    clear_has_conf_handle();
  }
}

// -------------------------------------------------------------------

// TAudChanParam

// optional .mt.EmAudFormat audio_format = 1;
inline bool TAudChanParam::has_audio_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAudChanParam::set_has_audio_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAudChanParam::clear_has_audio_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAudChanParam::clear_audio_format() {
  audio_format_ = 0;
  clear_has_audio_format();
}
inline ::mt::EmAudFormat TAudChanParam::audio_format() const {
  return static_cast< ::mt::EmAudFormat >(audio_format_);
}
inline void TAudChanParam::set_audio_format(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_audio_format();
  audio_format_ = value;
}

// optional uint32 payload = 2;
inline bool TAudChanParam::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAudChanParam::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAudChanParam::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAudChanParam::clear_payload() {
  payload_ = 0u;
  clear_has_payload();
}
inline ::google::protobuf::uint32 TAudChanParam::payload() const {
  return payload_;
}
inline void TAudChanParam::set_payload(::google::protobuf::uint32 value) {
  set_has_payload();
  payload_ = value;
}

// optional .mt.TEncryptKey encry_key = 3;
inline bool TAudChanParam::has_encry_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAudChanParam::set_has_encry_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAudChanParam::clear_has_encry_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAudChanParam::clear_encry_key() {
  if (encry_key_ != NULL) encry_key_->::mt::TEncryptKey::Clear();
  clear_has_encry_key();
}
inline const ::mt::TEncryptKey& TAudChanParam::encry_key() const {
  return encry_key_ != NULL ? *encry_key_ : *default_instance_->encry_key_;
}
inline ::mt::TEncryptKey* TAudChanParam::mutable_encry_key() {
  set_has_encry_key();
  if (encry_key_ == NULL) encry_key_ = new ::mt::TEncryptKey;
  return encry_key_;
}
inline ::mt::TEncryptKey* TAudChanParam::release_encry_key() {
  clear_has_encry_key();
  ::mt::TEncryptKey* temp = encry_key_;
  encry_key_ = NULL;
  return temp;
}
inline void TAudChanParam::set_allocated_encry_key(::mt::TEncryptKey* encry_key) {
  delete encry_key_;
  encry_key_ = encry_key;
  if (encry_key) {
    set_has_encry_key();
  } else {
    clear_has_encry_key();
  }
}

// optional .mt.EmEncryptArithmetic encrypt_arith = 4;
inline bool TAudChanParam::has_encrypt_arith() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAudChanParam::set_has_encrypt_arith() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAudChanParam::clear_has_encrypt_arith() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAudChanParam::clear_encrypt_arith() {
  encrypt_arith_ = 0;
  clear_has_encrypt_arith();
}
inline ::mt::EmEncryptArithmetic TAudChanParam::encrypt_arith() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encrypt_arith_);
}
inline void TAudChanParam::set_encrypt_arith(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encrypt_arith();
  encrypt_arith_ = value;
}

// optional .mt.EmAacChnlNum aac_chnl_num = 5;
inline bool TAudChanParam::has_aac_chnl_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TAudChanParam::set_has_aac_chnl_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TAudChanParam::clear_has_aac_chnl_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TAudChanParam::clear_aac_chnl_num() {
  aac_chnl_num_ = 0;
  clear_has_aac_chnl_num();
}
inline ::mt::EmAacChnlNum TAudChanParam::aac_chnl_num() const {
  return static_cast< ::mt::EmAacChnlNum >(aac_chnl_num_);
}
inline void TAudChanParam::set_aac_chnl_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_aac_chnl_num();
  aac_chnl_num_ = value;
}

// optional .mt.EmAacSampFreq aac_samp_frq = 6;
inline bool TAudChanParam::has_aac_samp_frq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TAudChanParam::set_has_aac_samp_frq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TAudChanParam::clear_has_aac_samp_frq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TAudChanParam::clear_aac_samp_frq() {
  aac_samp_frq_ = 0;
  clear_has_aac_samp_frq();
}
inline ::mt::EmAacSampFreq TAudChanParam::aac_samp_frq() const {
  return static_cast< ::mt::EmAacSampFreq >(aac_samp_frq_);
}
inline void TAudChanParam::set_aac_samp_frq(::mt::EmAacSampFreq value) {
  assert(::mt::EmAacSampFreq_IsValid(value));
  set_has_aac_samp_frq();
  aac_samp_frq_ = value;
}

// optional uint32 aac_bitrate = 7 [default = 96];
inline bool TAudChanParam::has_aac_bitrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TAudChanParam::set_has_aac_bitrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TAudChanParam::clear_has_aac_bitrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TAudChanParam::clear_aac_bitrate() {
  aac_bitrate_ = 96u;
  clear_has_aac_bitrate();
}
inline ::google::protobuf::uint32 TAudChanParam::aac_bitrate() const {
  return aac_bitrate_;
}
inline void TAudChanParam::set_aac_bitrate(::google::protobuf::uint32 value) {
  set_has_aac_bitrate();
  aac_bitrate_ = value;
}

// optional uint32 g7221_rate = 8;
inline bool TAudChanParam::has_g7221_rate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TAudChanParam::set_has_g7221_rate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TAudChanParam::clear_has_g7221_rate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TAudChanParam::clear_g7221_rate() {
  g7221_rate_ = 0u;
  clear_has_g7221_rate();
}
inline ::google::protobuf::uint32 TAudChanParam::g7221_rate() const {
  return g7221_rate_;
}
inline void TAudChanParam::set_g7221_rate(::google::protobuf::uint32 value) {
  set_has_g7221_rate();
  g7221_rate_ = value;
}

// optional bool bg7221_reverse = 9;
inline bool TAudChanParam::has_bg7221_reverse() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TAudChanParam::set_has_bg7221_reverse() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TAudChanParam::clear_has_bg7221_reverse() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TAudChanParam::clear_bg7221_reverse() {
  bg7221_reverse_ = false;
  clear_has_bg7221_reverse();
}
inline bool TAudChanParam::bg7221_reverse() const {
  return bg7221_reverse_;
}
inline void TAudChanParam::set_bg7221_reverse(bool value) {
  set_has_bg7221_reverse();
  bg7221_reverse_ = value;
}

// optional bool is_nat_traversal = 10;
inline bool TAudChanParam::has_is_nat_traversal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TAudChanParam::set_has_is_nat_traversal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TAudChanParam::clear_has_is_nat_traversal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TAudChanParam::clear_is_nat_traversal() {
  is_nat_traversal_ = false;
  clear_has_is_nat_traversal();
}
inline bool TAudChanParam::is_nat_traversal() const {
  return is_nat_traversal_;
}
inline void TAudChanParam::set_is_nat_traversal(bool value) {
  set_has_is_nat_traversal();
  is_nat_traversal_ = value;
}

// optional bytes aac_ld_MuxConfig = 11;
inline bool TAudChanParam::has_aac_ld_muxconfig() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TAudChanParam::set_has_aac_ld_muxconfig() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TAudChanParam::clear_has_aac_ld_muxconfig() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TAudChanParam::clear_aac_ld_muxconfig() {
  if (aac_ld_muxconfig_ != &::google::protobuf::internal::kEmptyString) {
    aac_ld_muxconfig_->clear();
  }
  clear_has_aac_ld_muxconfig();
}
inline const ::std::string& TAudChanParam::aac_ld_muxconfig() const {
  return *aac_ld_muxconfig_;
}
inline void TAudChanParam::set_aac_ld_muxconfig(const ::std::string& value) {
  set_has_aac_ld_muxconfig();
  if (aac_ld_muxconfig_ == &::google::protobuf::internal::kEmptyString) {
    aac_ld_muxconfig_ = new ::std::string;
  }
  aac_ld_muxconfig_->assign(value);
}
inline void TAudChanParam::set_aac_ld_muxconfig(const char* value) {
  set_has_aac_ld_muxconfig();
  if (aac_ld_muxconfig_ == &::google::protobuf::internal::kEmptyString) {
    aac_ld_muxconfig_ = new ::std::string;
  }
  aac_ld_muxconfig_->assign(value);
}
inline void TAudChanParam::set_aac_ld_muxconfig(const void* value, size_t size) {
  set_has_aac_ld_muxconfig();
  if (aac_ld_muxconfig_ == &::google::protobuf::internal::kEmptyString) {
    aac_ld_muxconfig_ = new ::std::string;
  }
  aac_ld_muxconfig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TAudChanParam::mutable_aac_ld_muxconfig() {
  set_has_aac_ld_muxconfig();
  if (aac_ld_muxconfig_ == &::google::protobuf::internal::kEmptyString) {
    aac_ld_muxconfig_ = new ::std::string;
  }
  return aac_ld_muxconfig_;
}
inline ::std::string* TAudChanParam::release_aac_ld_muxconfig() {
  clear_has_aac_ld_muxconfig();
  if (aac_ld_muxconfig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = aac_ld_muxconfig_;
    aac_ld_muxconfig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TAudChanParam::set_allocated_aac_ld_muxconfig(::std::string* aac_ld_muxconfig) {
  if (aac_ld_muxconfig_ != &::google::protobuf::internal::kEmptyString) {
    delete aac_ld_muxconfig_;
  }
  if (aac_ld_muxconfig) {
    set_has_aac_ld_muxconfig();
    aac_ld_muxconfig_ = aac_ld_muxconfig;
  } else {
    clear_has_aac_ld_muxconfig();
    aac_ld_muxconfig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_tlp_event = 12;
inline bool TAudChanParam::has_is_tlp_event() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TAudChanParam::set_has_is_tlp_event() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TAudChanParam::clear_has_is_tlp_event() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TAudChanParam::clear_is_tlp_event() {
  is_tlp_event_ = false;
  clear_has_is_tlp_event();
}
inline bool TAudChanParam::is_tlp_event() const {
  return is_tlp_event_;
}
inline void TAudChanParam::set_is_tlp_event(bool value) {
  set_has_is_tlp_event();
  is_tlp_event_ = value;
}

// -------------------------------------------------------------------

// TSrtpCrypto

// optional .mt.EmSrtpCryptoType srtp_crypto_type = 1;
inline bool TSrtpCrypto::has_srtp_crypto_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSrtpCrypto::set_has_srtp_crypto_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSrtpCrypto::clear_has_srtp_crypto_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSrtpCrypto::clear_srtp_crypto_type() {
  srtp_crypto_type_ = 0;
  clear_has_srtp_crypto_type();
}
inline ::mt::EmSrtpCryptoType TSrtpCrypto::srtp_crypto_type() const {
  return static_cast< ::mt::EmSrtpCryptoType >(srtp_crypto_type_);
}
inline void TSrtpCrypto::set_srtp_crypto_type(::mt::EmSrtpCryptoType value) {
  assert(::mt::EmSrtpCryptoType_IsValid(value));
  set_has_srtp_crypto_type();
  srtp_crypto_type_ = value;
}

// optional .mt.EmSrtpAuthType srtp_auth_type = 2;
inline bool TSrtpCrypto::has_srtp_auth_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TSrtpCrypto::set_has_srtp_auth_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TSrtpCrypto::clear_has_srtp_auth_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TSrtpCrypto::clear_srtp_auth_type() {
  srtp_auth_type_ = 0;
  clear_has_srtp_auth_type();
}
inline ::mt::EmSrtpAuthType TSrtpCrypto::srtp_auth_type() const {
  return static_cast< ::mt::EmSrtpAuthType >(srtp_auth_type_);
}
inline void TSrtpCrypto::set_srtp_auth_type(::mt::EmSrtpAuthType value) {
  assert(::mt::EmSrtpAuthType_IsValid(value));
  set_has_srtp_auth_type();
  srtp_auth_type_ = value;
}

// optional uint32 srtp_tag = 3;
inline bool TSrtpCrypto::has_srtp_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TSrtpCrypto::set_has_srtp_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TSrtpCrypto::clear_has_srtp_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TSrtpCrypto::clear_srtp_tag() {
  srtp_tag_ = 0u;
  clear_has_srtp_tag();
}
inline ::google::protobuf::uint32 TSrtpCrypto::srtp_tag() const {
  return srtp_tag_;
}
inline void TSrtpCrypto::set_srtp_tag(::google::protobuf::uint32 value) {
  set_has_srtp_tag();
  srtp_tag_ = value;
}

// optional bytes crypto_key = 4;
inline bool TSrtpCrypto::has_crypto_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TSrtpCrypto::set_has_crypto_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TSrtpCrypto::clear_has_crypto_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TSrtpCrypto::clear_crypto_key() {
  if (crypto_key_ != &::google::protobuf::internal::kEmptyString) {
    crypto_key_->clear();
  }
  clear_has_crypto_key();
}
inline const ::std::string& TSrtpCrypto::crypto_key() const {
  return *crypto_key_;
}
inline void TSrtpCrypto::set_crypto_key(const ::std::string& value) {
  set_has_crypto_key();
  if (crypto_key_ == &::google::protobuf::internal::kEmptyString) {
    crypto_key_ = new ::std::string;
  }
  crypto_key_->assign(value);
}
inline void TSrtpCrypto::set_crypto_key(const char* value) {
  set_has_crypto_key();
  if (crypto_key_ == &::google::protobuf::internal::kEmptyString) {
    crypto_key_ = new ::std::string;
  }
  crypto_key_->assign(value);
}
inline void TSrtpCrypto::set_crypto_key(const void* value, size_t size) {
  set_has_crypto_key();
  if (crypto_key_ == &::google::protobuf::internal::kEmptyString) {
    crypto_key_ = new ::std::string;
  }
  crypto_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSrtpCrypto::mutable_crypto_key() {
  set_has_crypto_key();
  if (crypto_key_ == &::google::protobuf::internal::kEmptyString) {
    crypto_key_ = new ::std::string;
  }
  return crypto_key_;
}
inline ::std::string* TSrtpCrypto::release_crypto_key() {
  clear_has_crypto_key();
  if (crypto_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crypto_key_;
    crypto_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSrtpCrypto::set_allocated_crypto_key(::std::string* crypto_key) {
  if (crypto_key_ != &::google::protobuf::internal::kEmptyString) {
    delete crypto_key_;
  }
  if (crypto_key) {
    set_has_crypto_key();
    crypto_key_ = crypto_key;
  } else {
    clear_has_crypto_key();
    crypto_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes crypto_keyid = 5;
inline bool TSrtpCrypto::has_crypto_keyid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TSrtpCrypto::set_has_crypto_keyid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TSrtpCrypto::clear_has_crypto_keyid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TSrtpCrypto::clear_crypto_keyid() {
  if (crypto_keyid_ != &::google::protobuf::internal::kEmptyString) {
    crypto_keyid_->clear();
  }
  clear_has_crypto_keyid();
}
inline const ::std::string& TSrtpCrypto::crypto_keyid() const {
  return *crypto_keyid_;
}
inline void TSrtpCrypto::set_crypto_keyid(const ::std::string& value) {
  set_has_crypto_keyid();
  if (crypto_keyid_ == &::google::protobuf::internal::kEmptyString) {
    crypto_keyid_ = new ::std::string;
  }
  crypto_keyid_->assign(value);
}
inline void TSrtpCrypto::set_crypto_keyid(const char* value) {
  set_has_crypto_keyid();
  if (crypto_keyid_ == &::google::protobuf::internal::kEmptyString) {
    crypto_keyid_ = new ::std::string;
  }
  crypto_keyid_->assign(value);
}
inline void TSrtpCrypto::set_crypto_keyid(const void* value, size_t size) {
  set_has_crypto_keyid();
  if (crypto_keyid_ == &::google::protobuf::internal::kEmptyString) {
    crypto_keyid_ = new ::std::string;
  }
  crypto_keyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSrtpCrypto::mutable_crypto_keyid() {
  set_has_crypto_keyid();
  if (crypto_keyid_ == &::google::protobuf::internal::kEmptyString) {
    crypto_keyid_ = new ::std::string;
  }
  return crypto_keyid_;
}
inline ::std::string* TSrtpCrypto::release_crypto_keyid() {
  clear_has_crypto_keyid();
  if (crypto_keyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crypto_keyid_;
    crypto_keyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSrtpCrypto::set_allocated_crypto_keyid(::std::string* crypto_keyid) {
  if (crypto_keyid_ != &::google::protobuf::internal::kEmptyString) {
    delete crypto_keyid_;
  }
  if (crypto_keyid) {
    set_has_crypto_keyid();
    crypto_keyid_ = crypto_keyid;
  } else {
    clear_has_crypto_keyid();
    crypto_keyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 crypto_keyid_len = 6;
inline bool TSrtpCrypto::has_crypto_keyid_len() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TSrtpCrypto::set_has_crypto_keyid_len() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TSrtpCrypto::clear_has_crypto_keyid_len() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TSrtpCrypto::clear_crypto_keyid_len() {
  crypto_keyid_len_ = 0u;
  clear_has_crypto_keyid_len();
}
inline ::google::protobuf::uint32 TSrtpCrypto::crypto_keyid_len() const {
  return crypto_keyid_len_;
}
inline void TSrtpCrypto::set_crypto_keyid_len(::google::protobuf::uint32 value) {
  set_has_crypto_keyid_len();
  crypto_keyid_len_ = value;
}

// optional bytes bkrtcp_crypto_key = 7;
inline bool TSrtpCrypto::has_bkrtcp_crypto_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TSrtpCrypto::set_has_bkrtcp_crypto_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TSrtpCrypto::clear_has_bkrtcp_crypto_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TSrtpCrypto::clear_bkrtcp_crypto_key() {
  if (bkrtcp_crypto_key_ != &::google::protobuf::internal::kEmptyString) {
    bkrtcp_crypto_key_->clear();
  }
  clear_has_bkrtcp_crypto_key();
}
inline const ::std::string& TSrtpCrypto::bkrtcp_crypto_key() const {
  return *bkrtcp_crypto_key_;
}
inline void TSrtpCrypto::set_bkrtcp_crypto_key(const ::std::string& value) {
  set_has_bkrtcp_crypto_key();
  if (bkrtcp_crypto_key_ == &::google::protobuf::internal::kEmptyString) {
    bkrtcp_crypto_key_ = new ::std::string;
  }
  bkrtcp_crypto_key_->assign(value);
}
inline void TSrtpCrypto::set_bkrtcp_crypto_key(const char* value) {
  set_has_bkrtcp_crypto_key();
  if (bkrtcp_crypto_key_ == &::google::protobuf::internal::kEmptyString) {
    bkrtcp_crypto_key_ = new ::std::string;
  }
  bkrtcp_crypto_key_->assign(value);
}
inline void TSrtpCrypto::set_bkrtcp_crypto_key(const void* value, size_t size) {
  set_has_bkrtcp_crypto_key();
  if (bkrtcp_crypto_key_ == &::google::protobuf::internal::kEmptyString) {
    bkrtcp_crypto_key_ = new ::std::string;
  }
  bkrtcp_crypto_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TSrtpCrypto::mutable_bkrtcp_crypto_key() {
  set_has_bkrtcp_crypto_key();
  if (bkrtcp_crypto_key_ == &::google::protobuf::internal::kEmptyString) {
    bkrtcp_crypto_key_ = new ::std::string;
  }
  return bkrtcp_crypto_key_;
}
inline ::std::string* TSrtpCrypto::release_bkrtcp_crypto_key() {
  clear_has_bkrtcp_crypto_key();
  if (bkrtcp_crypto_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bkrtcp_crypto_key_;
    bkrtcp_crypto_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TSrtpCrypto::set_allocated_bkrtcp_crypto_key(::std::string* bkrtcp_crypto_key) {
  if (bkrtcp_crypto_key_ != &::google::protobuf::internal::kEmptyString) {
    delete bkrtcp_crypto_key_;
  }
  if (bkrtcp_crypto_key) {
    set_has_bkrtcp_crypto_key();
    bkrtcp_crypto_key_ = bkrtcp_crypto_key;
  } else {
    clear_has_bkrtcp_crypto_key();
    bkrtcp_crypto_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TSrtpParamSetting

// optional bool is_srtp_enable = 1;
inline bool TSrtpParamSetting::has_is_srtp_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSrtpParamSetting::set_has_is_srtp_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSrtpParamSetting::clear_has_is_srtp_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSrtpParamSetting::clear_is_srtp_enable() {
  is_srtp_enable_ = false;
  clear_has_is_srtp_enable();
}
inline bool TSrtpParamSetting::is_srtp_enable() const {
  return is_srtp_enable_;
}
inline void TSrtpParamSetting::set_is_srtp_enable(bool value) {
  set_has_is_srtp_enable();
  is_srtp_enable_ = value;
}

// repeated .mt.TSrtpCrypto srtp_crypto_param = 2;
inline int TSrtpParamSetting::srtp_crypto_param_size() const {
  return srtp_crypto_param_.size();
}
inline void TSrtpParamSetting::clear_srtp_crypto_param() {
  srtp_crypto_param_.Clear();
}
inline const ::mt::TSrtpCrypto& TSrtpParamSetting::srtp_crypto_param(int index) const {
  return srtp_crypto_param_.Get(index);
}
inline ::mt::TSrtpCrypto* TSrtpParamSetting::mutable_srtp_crypto_param(int index) {
  return srtp_crypto_param_.Mutable(index);
}
inline ::mt::TSrtpCrypto* TSrtpParamSetting::add_srtp_crypto_param() {
  return srtp_crypto_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TSrtpCrypto >&
TSrtpParamSetting::srtp_crypto_param() const {
  return srtp_crypto_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TSrtpCrypto >*
TSrtpParamSetting::mutable_srtp_crypto_param() {
  return &srtp_crypto_param_;
}

// -------------------------------------------------------------------

// TAVCapSrtpParam

// repeated .mt.TSrtpParamSetting vid_srtp_param = 1;
inline int TAVCapSrtpParam::vid_srtp_param_size() const {
  return vid_srtp_param_.size();
}
inline void TAVCapSrtpParam::clear_vid_srtp_param() {
  vid_srtp_param_.Clear();
}
inline const ::mt::TSrtpParamSetting& TAVCapSrtpParam::vid_srtp_param(int index) const {
  return vid_srtp_param_.Get(index);
}
inline ::mt::TSrtpParamSetting* TAVCapSrtpParam::mutable_vid_srtp_param(int index) {
  return vid_srtp_param_.Mutable(index);
}
inline ::mt::TSrtpParamSetting* TAVCapSrtpParam::add_vid_srtp_param() {
  return vid_srtp_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TSrtpParamSetting >&
TAVCapSrtpParam::vid_srtp_param() const {
  return vid_srtp_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TSrtpParamSetting >*
TAVCapSrtpParam::mutable_vid_srtp_param() {
  return &vid_srtp_param_;
}

// repeated .mt.TSrtpParamSetting aud_srtp_param = 2;
inline int TAVCapSrtpParam::aud_srtp_param_size() const {
  return aud_srtp_param_.size();
}
inline void TAVCapSrtpParam::clear_aud_srtp_param() {
  aud_srtp_param_.Clear();
}
inline const ::mt::TSrtpParamSetting& TAVCapSrtpParam::aud_srtp_param(int index) const {
  return aud_srtp_param_.Get(index);
}
inline ::mt::TSrtpParamSetting* TAVCapSrtpParam::mutable_aud_srtp_param(int index) {
  return aud_srtp_param_.Mutable(index);
}
inline ::mt::TSrtpParamSetting* TAVCapSrtpParam::add_aud_srtp_param() {
  return aud_srtp_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TSrtpParamSetting >&
TAVCapSrtpParam::aud_srtp_param() const {
  return aud_srtp_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TSrtpParamSetting >*
TAVCapSrtpParam::mutable_aud_srtp_param() {
  return &aud_srtp_param_;
}

// -------------------------------------------------------------------

// TVidChanParam

// optional .mt.EmVidFormat video_format = 1;
inline bool TVidChanParam::has_video_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVidChanParam::set_has_video_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVidChanParam::clear_has_video_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVidChanParam::clear_video_format() {
  video_format_ = 0;
  clear_has_video_format();
}
inline ::mt::EmVidFormat TVidChanParam::video_format() const {
  return static_cast< ::mt::EmVidFormat >(video_format_);
}
inline void TVidChanParam::set_video_format(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_video_format();
  video_format_ = value;
}

// optional uint32 payload = 2;
inline bool TVidChanParam::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVidChanParam::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVidChanParam::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVidChanParam::clear_payload() {
  payload_ = 0u;
  clear_has_payload();
}
inline ::google::protobuf::uint32 TVidChanParam::payload() const {
  return payload_;
}
inline void TVidChanParam::set_payload(::google::protobuf::uint32 value) {
  set_has_payload();
  payload_ = value;
}

// optional .mt.TEncryptKey encry_key = 3;
inline bool TVidChanParam::has_encry_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVidChanParam::set_has_encry_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVidChanParam::clear_has_encry_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVidChanParam::clear_encry_key() {
  if (encry_key_ != NULL) encry_key_->::mt::TEncryptKey::Clear();
  clear_has_encry_key();
}
inline const ::mt::TEncryptKey& TVidChanParam::encry_key() const {
  return encry_key_ != NULL ? *encry_key_ : *default_instance_->encry_key_;
}
inline ::mt::TEncryptKey* TVidChanParam::mutable_encry_key() {
  set_has_encry_key();
  if (encry_key_ == NULL) encry_key_ = new ::mt::TEncryptKey;
  return encry_key_;
}
inline ::mt::TEncryptKey* TVidChanParam::release_encry_key() {
  clear_has_encry_key();
  ::mt::TEncryptKey* temp = encry_key_;
  encry_key_ = NULL;
  return temp;
}
inline void TVidChanParam::set_allocated_encry_key(::mt::TEncryptKey* encry_key) {
  delete encry_key_;
  encry_key_ = encry_key;
  if (encry_key) {
    set_has_encry_key();
  } else {
    clear_has_encry_key();
  }
}

// optional .mt.EmEncryptArithmetic encrypt_arith = 4;
inline bool TVidChanParam::has_encrypt_arith() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVidChanParam::set_has_encrypt_arith() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVidChanParam::clear_has_encrypt_arith() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVidChanParam::clear_encrypt_arith() {
  encrypt_arith_ = 0;
  clear_has_encrypt_arith();
}
inline ::mt::EmEncryptArithmetic TVidChanParam::encrypt_arith() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encrypt_arith_);
}
inline void TVidChanParam::set_encrypt_arith(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encrypt_arith();
  encrypt_arith_ = value;
}

// optional .mt.EmMtResolution video_resolution = 5;
inline bool TVidChanParam::has_video_resolution() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVidChanParam::set_has_video_resolution() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVidChanParam::clear_has_video_resolution() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVidChanParam::clear_video_resolution() {
  video_resolution_ = 0;
  clear_has_video_resolution();
}
inline ::mt::EmMtResolution TVidChanParam::video_resolution() const {
  return static_cast< ::mt::EmMtResolution >(video_resolution_);
}
inline void TVidChanParam::set_video_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_video_resolution();
  video_resolution_ = value;
}

// optional uint32 frame_rate = 6;
inline bool TVidChanParam::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVidChanParam::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVidChanParam::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVidChanParam::clear_frame_rate() {
  frame_rate_ = 0u;
  clear_has_frame_rate();
}
inline ::google::protobuf::uint32 TVidChanParam::frame_rate() const {
  return frame_rate_;
}
inline void TVidChanParam::set_frame_rate(::google::protobuf::uint32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// optional uint32 chan_max_bitrate = 7;
inline bool TVidChanParam::has_chan_max_bitrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVidChanParam::set_has_chan_max_bitrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVidChanParam::clear_has_chan_max_bitrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVidChanParam::clear_chan_max_bitrate() {
  chan_max_bitrate_ = 0u;
  clear_has_chan_max_bitrate();
}
inline ::google::protobuf::uint32 TVidChanParam::chan_max_bitrate() const {
  return chan_max_bitrate_;
}
inline void TVidChanParam::set_chan_max_bitrate(::google::protobuf::uint32 value) {
  set_has_chan_max_bitrate();
  chan_max_bitrate_ = value;
}

// optional .mt.EmH264Profile h264_profile = 8;
inline bool TVidChanParam::has_h264_profile() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TVidChanParam::set_has_h264_profile() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TVidChanParam::clear_has_h264_profile() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TVidChanParam::clear_h264_profile() {
  h264_profile_ = 0;
  clear_has_h264_profile();
}
inline ::mt::EmH264Profile TVidChanParam::h264_profile() const {
  return static_cast< ::mt::EmH264Profile >(h264_profile_);
}
inline void TVidChanParam::set_h264_profile(::mt::EmH264Profile value) {
  assert(::mt::EmH264Profile_IsValid(value));
  set_has_h264_profile();
  h264_profile_ = value;
}

// optional bool h264_svc_enable = 9;
inline bool TVidChanParam::has_h264_svc_enable() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TVidChanParam::set_has_h264_svc_enable() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TVidChanParam::clear_has_h264_svc_enable() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TVidChanParam::clear_h264_svc_enable() {
  h264_svc_enable_ = false;
  clear_has_h264_svc_enable();
}
inline bool TVidChanParam::h264_svc_enable() const {
  return h264_svc_enable_;
}
inline void TVidChanParam::set_h264_svc_enable(bool value) {
  set_has_h264_svc_enable();
  h264_svc_enable_ = value;
}

// optional bool is_nat_traversal = 10;
inline bool TVidChanParam::has_is_nat_traversal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TVidChanParam::set_has_is_nat_traversal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TVidChanParam::clear_has_is_nat_traversal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TVidChanParam::clear_is_nat_traversal() {
  is_nat_traversal_ = false;
  clear_has_is_nat_traversal();
}
inline bool TVidChanParam::is_nat_traversal() const {
  return is_nat_traversal_;
}
inline void TVidChanParam::set_is_nat_traversal(bool value) {
  set_has_is_nat_traversal();
  is_nat_traversal_ = value;
}

// optional .mt.EmH265Profile h265_profile = 11;
inline bool TVidChanParam::has_h265_profile() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TVidChanParam::set_has_h265_profile() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TVidChanParam::clear_has_h265_profile() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TVidChanParam::clear_h265_profile() {
  h265_profile_ = 0;
  clear_has_h265_profile();
}
inline ::mt::EmH265Profile TVidChanParam::h265_profile() const {
  return static_cast< ::mt::EmH265Profile >(h265_profile_);
}
inline void TVidChanParam::set_h265_profile(::mt::EmH265Profile value) {
  assert(::mt::EmH265Profile_IsValid(value));
  set_has_h265_profile();
  h265_profile_ = value;
}

// optional bool is_rtcp_fbpli = 12;
inline bool TVidChanParam::has_is_rtcp_fbpli() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TVidChanParam::set_has_is_rtcp_fbpli() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TVidChanParam::clear_has_is_rtcp_fbpli() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TVidChanParam::clear_is_rtcp_fbpli() {
  is_rtcp_fbpli_ = false;
  clear_has_is_rtcp_fbpli();
}
inline bool TVidChanParam::is_rtcp_fbpli() const {
  return is_rtcp_fbpli_;
}
inline void TVidChanParam::set_is_rtcp_fbpli(bool value) {
  set_has_is_rtcp_fbpli();
  is_rtcp_fbpli_ = value;
}

// optional bool is_rtcp_fbfir = 13;
inline bool TVidChanParam::has_is_rtcp_fbfir() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TVidChanParam::set_has_is_rtcp_fbfir() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TVidChanParam::clear_has_is_rtcp_fbfir() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TVidChanParam::clear_is_rtcp_fbfir() {
  is_rtcp_fbfir_ = false;
  clear_has_is_rtcp_fbfir();
}
inline bool TVidChanParam::is_rtcp_fbfir() const {
  return is_rtcp_fbfir_;
}
inline void TVidChanParam::set_is_rtcp_fbfir(bool value) {
  set_has_is_rtcp_fbfir();
  is_rtcp_fbfir_ = value;
}

// optional bool is_rtcp_fbtmmbr = 14;
inline bool TVidChanParam::has_is_rtcp_fbtmmbr() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TVidChanParam::set_has_is_rtcp_fbtmmbr() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TVidChanParam::clear_has_is_rtcp_fbtmmbr() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TVidChanParam::clear_is_rtcp_fbtmmbr() {
  is_rtcp_fbtmmbr_ = false;
  clear_has_is_rtcp_fbtmmbr();
}
inline bool TVidChanParam::is_rtcp_fbtmmbr() const {
  return is_rtcp_fbtmmbr_;
}
inline void TVidChanParam::set_is_rtcp_fbtmmbr(bool value) {
  set_has_is_rtcp_fbtmmbr();
  is_rtcp_fbtmmbr_ = value;
}

// optional bool is_h239 = 20;
inline bool TVidChanParam::has_is_h239() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TVidChanParam::set_has_is_h239() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TVidChanParam::clear_has_is_h239() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TVidChanParam::clear_is_h239() {
  is_h239_ = false;
  clear_has_is_h239();
}
inline bool TVidChanParam::is_h239() const {
  return is_h239_;
}
inline void TVidChanParam::set_is_h239(bool value) {
  set_has_is_h239();
  is_h239_ = value;
}

// -------------------------------------------------------------------

// TRpAudChanParam

// repeated .mt.TAudChanParam aud_param = 1;
inline int TRpAudChanParam::aud_param_size() const {
  return aud_param_.size();
}
inline void TRpAudChanParam::clear_aud_param() {
  aud_param_.Clear();
}
inline const ::mt::TAudChanParam& TRpAudChanParam::aud_param(int index) const {
  return aud_param_.Get(index);
}
inline ::mt::TAudChanParam* TRpAudChanParam::mutable_aud_param(int index) {
  return aud_param_.Mutable(index);
}
inline ::mt::TAudChanParam* TRpAudChanParam::add_aud_param() {
  return aud_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAudChanParam >&
TRpAudChanParam::aud_param() const {
  return aud_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAudChanParam >*
TRpAudChanParam::mutable_aud_param() {
  return &aud_param_;
}

// optional .mt.TSrtpParamSetting srtp_param = 2;
inline bool TRpAudChanParam::has_srtp_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRpAudChanParam::set_has_srtp_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRpAudChanParam::clear_has_srtp_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRpAudChanParam::clear_srtp_param() {
  if (srtp_param_ != NULL) srtp_param_->::mt::TSrtpParamSetting::Clear();
  clear_has_srtp_param();
}
inline const ::mt::TSrtpParamSetting& TRpAudChanParam::srtp_param() const {
  return srtp_param_ != NULL ? *srtp_param_ : *default_instance_->srtp_param_;
}
inline ::mt::TSrtpParamSetting* TRpAudChanParam::mutable_srtp_param() {
  set_has_srtp_param();
  if (srtp_param_ == NULL) srtp_param_ = new ::mt::TSrtpParamSetting;
  return srtp_param_;
}
inline ::mt::TSrtpParamSetting* TRpAudChanParam::release_srtp_param() {
  clear_has_srtp_param();
  ::mt::TSrtpParamSetting* temp = srtp_param_;
  srtp_param_ = NULL;
  return temp;
}
inline void TRpAudChanParam::set_allocated_srtp_param(::mt::TSrtpParamSetting* srtp_param) {
  delete srtp_param_;
  srtp_param_ = srtp_param;
  if (srtp_param) {
    set_has_srtp_param();
  } else {
    clear_has_srtp_param();
  }
}

// -------------------------------------------------------------------

// TRpVidChanParam

// repeated .mt.TVidChanParam vid_param = 1;
inline int TRpVidChanParam::vid_param_size() const {
  return vid_param_.size();
}
inline void TRpVidChanParam::clear_vid_param() {
  vid_param_.Clear();
}
inline const ::mt::TVidChanParam& TRpVidChanParam::vid_param(int index) const {
  return vid_param_.Get(index);
}
inline ::mt::TVidChanParam* TRpVidChanParam::mutable_vid_param(int index) {
  return vid_param_.Mutable(index);
}
inline ::mt::TVidChanParam* TRpVidChanParam::add_vid_param() {
  return vid_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVidChanParam >&
TRpVidChanParam::vid_param() const {
  return vid_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVidChanParam >*
TRpVidChanParam::mutable_vid_param() {
  return &vid_param_;
}

// optional .mt.TSrtpParamSetting srtp_param = 2;
inline bool TRpVidChanParam::has_srtp_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRpVidChanParam::set_has_srtp_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRpVidChanParam::clear_has_srtp_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRpVidChanParam::clear_srtp_param() {
  if (srtp_param_ != NULL) srtp_param_->::mt::TSrtpParamSetting::Clear();
  clear_has_srtp_param();
}
inline const ::mt::TSrtpParamSetting& TRpVidChanParam::srtp_param() const {
  return srtp_param_ != NULL ? *srtp_param_ : *default_instance_->srtp_param_;
}
inline ::mt::TSrtpParamSetting* TRpVidChanParam::mutable_srtp_param() {
  set_has_srtp_param();
  if (srtp_param_ == NULL) srtp_param_ = new ::mt::TSrtpParamSetting;
  return srtp_param_;
}
inline ::mt::TSrtpParamSetting* TRpVidChanParam::release_srtp_param() {
  clear_has_srtp_param();
  ::mt::TSrtpParamSetting* temp = srtp_param_;
  srtp_param_ = NULL;
  return temp;
}
inline void TRpVidChanParam::set_allocated_srtp_param(::mt::TSrtpParamSetting* srtp_param) {
  delete srtp_param_;
  srtp_param_ = srtp_param;
  if (srtp_param) {
    set_has_srtp_param();
  } else {
    clear_has_srtp_param();
  }
}

// -------------------------------------------------------------------

// TMtAVChanParam

// optional .mt.TRpAudChanParam aud_chan_param = 1;
inline bool TMtAVChanParam::has_aud_chan_param() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAVChanParam::set_has_aud_chan_param() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAVChanParam::clear_has_aud_chan_param() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAVChanParam::clear_aud_chan_param() {
  if (aud_chan_param_ != NULL) aud_chan_param_->::mt::TRpAudChanParam::Clear();
  clear_has_aud_chan_param();
}
inline const ::mt::TRpAudChanParam& TMtAVChanParam::aud_chan_param() const {
  return aud_chan_param_ != NULL ? *aud_chan_param_ : *default_instance_->aud_chan_param_;
}
inline ::mt::TRpAudChanParam* TMtAVChanParam::mutable_aud_chan_param() {
  set_has_aud_chan_param();
  if (aud_chan_param_ == NULL) aud_chan_param_ = new ::mt::TRpAudChanParam;
  return aud_chan_param_;
}
inline ::mt::TRpAudChanParam* TMtAVChanParam::release_aud_chan_param() {
  clear_has_aud_chan_param();
  ::mt::TRpAudChanParam* temp = aud_chan_param_;
  aud_chan_param_ = NULL;
  return temp;
}
inline void TMtAVChanParam::set_allocated_aud_chan_param(::mt::TRpAudChanParam* aud_chan_param) {
  delete aud_chan_param_;
  aud_chan_param_ = aud_chan_param;
  if (aud_chan_param) {
    set_has_aud_chan_param();
  } else {
    clear_has_aud_chan_param();
  }
}

// optional .mt.TRpVidChanParam vid_chan_param = 2;
inline bool TMtAVChanParam::has_vid_chan_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAVChanParam::set_has_vid_chan_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAVChanParam::clear_has_vid_chan_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAVChanParam::clear_vid_chan_param() {
  if (vid_chan_param_ != NULL) vid_chan_param_->::mt::TRpVidChanParam::Clear();
  clear_has_vid_chan_param();
}
inline const ::mt::TRpVidChanParam& TMtAVChanParam::vid_chan_param() const {
  return vid_chan_param_ != NULL ? *vid_chan_param_ : *default_instance_->vid_chan_param_;
}
inline ::mt::TRpVidChanParam* TMtAVChanParam::mutable_vid_chan_param() {
  set_has_vid_chan_param();
  if (vid_chan_param_ == NULL) vid_chan_param_ = new ::mt::TRpVidChanParam;
  return vid_chan_param_;
}
inline ::mt::TRpVidChanParam* TMtAVChanParam::release_vid_chan_param() {
  clear_has_vid_chan_param();
  ::mt::TRpVidChanParam* temp = vid_chan_param_;
  vid_chan_param_ = NULL;
  return temp;
}
inline void TMtAVChanParam::set_allocated_vid_chan_param(::mt::TRpVidChanParam* vid_chan_param) {
  delete vid_chan_param_;
  vid_chan_param_ = vid_chan_param;
  if (vid_chan_param) {
    set_has_vid_chan_param();
  } else {
    clear_has_vid_chan_param();
  }
}

// -------------------------------------------------------------------

// TMtConfBaseInfo

// optional string conf_id = 1;
inline bool TMtConfBaseInfo::has_conf_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtConfBaseInfo::set_has_conf_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtConfBaseInfo::clear_has_conf_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtConfBaseInfo::clear_conf_id() {
  if (conf_id_ != &::google::protobuf::internal::kEmptyString) {
    conf_id_->clear();
  }
  clear_has_conf_id();
}
inline const ::std::string& TMtConfBaseInfo::conf_id() const {
  return *conf_id_;
}
inline void TMtConfBaseInfo::set_conf_id(const ::std::string& value) {
  set_has_conf_id();
  if (conf_id_ == &::google::protobuf::internal::kEmptyString) {
    conf_id_ = new ::std::string;
  }
  conf_id_->assign(value);
}
inline void TMtConfBaseInfo::set_conf_id(const char* value) {
  set_has_conf_id();
  if (conf_id_ == &::google::protobuf::internal::kEmptyString) {
    conf_id_ = new ::std::string;
  }
  conf_id_->assign(value);
}
inline void TMtConfBaseInfo::set_conf_id(const char* value, size_t size) {
  set_has_conf_id();
  if (conf_id_ == &::google::protobuf::internal::kEmptyString) {
    conf_id_ = new ::std::string;
  }
  conf_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtConfBaseInfo::mutable_conf_id() {
  set_has_conf_id();
  if (conf_id_ == &::google::protobuf::internal::kEmptyString) {
    conf_id_ = new ::std::string;
  }
  return conf_id_;
}
inline ::std::string* TMtConfBaseInfo::release_conf_id() {
  clear_has_conf_id();
  if (conf_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_id_;
    conf_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtConfBaseInfo::set_allocated_conf_id(::std::string* conf_id) {
  if (conf_id_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_id_;
  }
  if (conf_id) {
    set_has_conf_id();
    conf_id_ = conf_id;
  } else {
    clear_has_conf_id();
    conf_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string conf_name = 2;
inline bool TMtConfBaseInfo::has_conf_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtConfBaseInfo::set_has_conf_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtConfBaseInfo::clear_has_conf_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtConfBaseInfo::clear_conf_name() {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    conf_name_->clear();
  }
  clear_has_conf_name();
}
inline const ::std::string& TMtConfBaseInfo::conf_name() const {
  return *conf_name_;
}
inline void TMtConfBaseInfo::set_conf_name(const ::std::string& value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtConfBaseInfo::set_conf_name(const char* value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtConfBaseInfo::set_conf_name(const char* value, size_t size) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtConfBaseInfo::mutable_conf_name() {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  return conf_name_;
}
inline ::std::string* TMtConfBaseInfo::release_conf_name() {
  clear_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_name_;
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtConfBaseInfo::set_allocated_conf_name(::std::string* conf_name) {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_name_;
  }
  if (conf_name) {
    set_has_conf_name();
    conf_name_ = conf_name;
  } else {
    clear_has_conf_name();
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string conf_number = 3;
inline bool TMtConfBaseInfo::has_conf_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtConfBaseInfo::set_has_conf_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtConfBaseInfo::clear_has_conf_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtConfBaseInfo::clear_conf_number() {
  if (conf_number_ != &::google::protobuf::internal::kEmptyString) {
    conf_number_->clear();
  }
  clear_has_conf_number();
}
inline const ::std::string& TMtConfBaseInfo::conf_number() const {
  return *conf_number_;
}
inline void TMtConfBaseInfo::set_conf_number(const ::std::string& value) {
  set_has_conf_number();
  if (conf_number_ == &::google::protobuf::internal::kEmptyString) {
    conf_number_ = new ::std::string;
  }
  conf_number_->assign(value);
}
inline void TMtConfBaseInfo::set_conf_number(const char* value) {
  set_has_conf_number();
  if (conf_number_ == &::google::protobuf::internal::kEmptyString) {
    conf_number_ = new ::std::string;
  }
  conf_number_->assign(value);
}
inline void TMtConfBaseInfo::set_conf_number(const char* value, size_t size) {
  set_has_conf_number();
  if (conf_number_ == &::google::protobuf::internal::kEmptyString) {
    conf_number_ = new ::std::string;
  }
  conf_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtConfBaseInfo::mutable_conf_number() {
  set_has_conf_number();
  if (conf_number_ == &::google::protobuf::internal::kEmptyString) {
    conf_number_ = new ::std::string;
  }
  return conf_number_;
}
inline ::std::string* TMtConfBaseInfo::release_conf_number() {
  clear_has_conf_number();
  if (conf_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_number_;
    conf_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtConfBaseInfo::set_allocated_conf_number(::std::string* conf_number) {
  if (conf_number_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_number_;
  }
  if (conf_number) {
    set_has_conf_number();
    conf_number_ = conf_number;
  } else {
    clear_has_conf_number();
    conf_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string conf_pwd = 4;
inline bool TMtConfBaseInfo::has_conf_pwd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtConfBaseInfo::set_has_conf_pwd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtConfBaseInfo::clear_has_conf_pwd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtConfBaseInfo::clear_conf_pwd() {
  if (conf_pwd_ != &::google::protobuf::internal::kEmptyString) {
    conf_pwd_->clear();
  }
  clear_has_conf_pwd();
}
inline const ::std::string& TMtConfBaseInfo::conf_pwd() const {
  return *conf_pwd_;
}
inline void TMtConfBaseInfo::set_conf_pwd(const ::std::string& value) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(value);
}
inline void TMtConfBaseInfo::set_conf_pwd(const char* value) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(value);
}
inline void TMtConfBaseInfo::set_conf_pwd(const char* value, size_t size) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtConfBaseInfo::mutable_conf_pwd() {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  return conf_pwd_;
}
inline ::std::string* TMtConfBaseInfo::release_conf_pwd() {
  clear_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_pwd_;
    conf_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtConfBaseInfo::set_allocated_conf_pwd(::std::string* conf_pwd) {
  if (conf_pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_pwd_;
  }
  if (conf_pwd) {
    set_has_conf_pwd();
    conf_pwd_ = conf_pwd;
  } else {
    clear_has_conf_pwd();
    conf_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool bneed_pwd = 5;
inline bool TMtConfBaseInfo::has_bneed_pwd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtConfBaseInfo::set_has_bneed_pwd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtConfBaseInfo::clear_has_bneed_pwd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtConfBaseInfo::clear_bneed_pwd() {
  bneed_pwd_ = false;
  clear_has_bneed_pwd();
}
inline bool TMtConfBaseInfo::bneed_pwd() const {
  return bneed_pwd_;
}
inline void TMtConfBaseInfo::set_bneed_pwd(bool value) {
  set_has_bneed_pwd();
  bneed_pwd_ = value;
}

// optional uint32 conf_duration = 6;
inline bool TMtConfBaseInfo::has_conf_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtConfBaseInfo::set_has_conf_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtConfBaseInfo::clear_has_conf_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtConfBaseInfo::clear_conf_duration() {
  conf_duration_ = 0u;
  clear_has_conf_duration();
}
inline ::google::protobuf::uint32 TMtConfBaseInfo::conf_duration() const {
  return conf_duration_;
}
inline void TMtConfBaseInfo::set_conf_duration(::google::protobuf::uint32 value) {
  set_has_conf_duration();
  conf_duration_ = value;
}

// optional .mt.EmEncryptArithmetic encry_type = 7;
inline bool TMtConfBaseInfo::has_encry_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtConfBaseInfo::set_has_encry_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtConfBaseInfo::clear_has_encry_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtConfBaseInfo::clear_encry_type() {
  encry_type_ = 0;
  clear_has_encry_type();
}
inline ::mt::EmEncryptArithmetic TMtConfBaseInfo::encry_type() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encry_type_);
}
inline void TMtConfBaseInfo::set_encry_type(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encry_type();
  encry_type_ = value;
}

// optional .mt.EmVidFormat video_format = 8;
inline bool TMtConfBaseInfo::has_video_format() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtConfBaseInfo::set_has_video_format() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtConfBaseInfo::clear_has_video_format() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtConfBaseInfo::clear_video_format() {
  video_format_ = 0;
  clear_has_video_format();
}
inline ::mt::EmVidFormat TMtConfBaseInfo::video_format() const {
  return static_cast< ::mt::EmVidFormat >(video_format_);
}
inline void TMtConfBaseInfo::set_video_format(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_video_format();
  video_format_ = value;
}

// optional .mt.EmAudFormat audio_format = 9;
inline bool TMtConfBaseInfo::has_audio_format() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMtConfBaseInfo::set_has_audio_format() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMtConfBaseInfo::clear_has_audio_format() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMtConfBaseInfo::clear_audio_format() {
  audio_format_ = 0;
  clear_has_audio_format();
}
inline ::mt::EmAudFormat TMtConfBaseInfo::audio_format() const {
  return static_cast< ::mt::EmAudFormat >(audio_format_);
}
inline void TMtConfBaseInfo::set_audio_format(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_audio_format();
  audio_format_ = value;
}

// optional .mt.EmMtResolution resolution = 10;
inline bool TMtConfBaseInfo::has_resolution() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMtConfBaseInfo::set_has_resolution() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMtConfBaseInfo::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMtConfBaseInfo::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::mt::EmMtResolution TMtConfBaseInfo::resolution() const {
  return static_cast< ::mt::EmMtResolution >(resolution_);
}
inline void TMtConfBaseInfo::set_resolution(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_resolution();
  resolution_ = value;
}

// optional .mt.EmAacChnlNum chnl_num = 11;
inline bool TMtConfBaseInfo::has_chnl_num() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMtConfBaseInfo::set_has_chnl_num() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMtConfBaseInfo::clear_has_chnl_num() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMtConfBaseInfo::clear_chnl_num() {
  chnl_num_ = 0;
  clear_has_chnl_num();
}
inline ::mt::EmAacChnlNum TMtConfBaseInfo::chnl_num() const {
  return static_cast< ::mt::EmAacChnlNum >(chnl_num_);
}
inline void TMtConfBaseInfo::set_chnl_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_chnl_num();
  chnl_num_ = value;
}

// optional .mt.EmVidFormat sec_video_format = 12;
inline bool TMtConfBaseInfo::has_sec_video_format() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMtConfBaseInfo::set_has_sec_video_format() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMtConfBaseInfo::clear_has_sec_video_format() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMtConfBaseInfo::clear_sec_video_format() {
  sec_video_format_ = 0;
  clear_has_sec_video_format();
}
inline ::mt::EmVidFormat TMtConfBaseInfo::sec_video_format() const {
  return static_cast< ::mt::EmVidFormat >(sec_video_format_);
}
inline void TMtConfBaseInfo::set_sec_video_format(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_sec_video_format();
  sec_video_format_ = value;
}

// optional .mt.EmMtResolution sec_vid_res = 13;
inline bool TMtConfBaseInfo::has_sec_vid_res() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMtConfBaseInfo::set_has_sec_vid_res() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMtConfBaseInfo::clear_has_sec_vid_res() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMtConfBaseInfo::clear_sec_vid_res() {
  sec_vid_res_ = 0;
  clear_has_sec_vid_res();
}
inline ::mt::EmMtResolution TMtConfBaseInfo::sec_vid_res() const {
  return static_cast< ::mt::EmMtResolution >(sec_vid_res_);
}
inline void TMtConfBaseInfo::set_sec_vid_res(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_sec_vid_res();
  sec_vid_res_ = value;
}

// optional uint32 sec_vid_fps = 14;
inline bool TMtConfBaseInfo::has_sec_vid_fps() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMtConfBaseInfo::set_has_sec_vid_fps() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMtConfBaseInfo::clear_has_sec_vid_fps() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMtConfBaseInfo::clear_sec_vid_fps() {
  sec_vid_fps_ = 0u;
  clear_has_sec_vid_fps();
}
inline ::google::protobuf::uint32 TMtConfBaseInfo::sec_vid_fps() const {
  return sec_vid_fps_;
}
inline void TMtConfBaseInfo::set_sec_vid_fps(::google::protobuf::uint32 value) {
  set_has_sec_vid_fps();
  sec_vid_fps_ = value;
}

// optional bool is_auto_vmp = 15;
inline bool TMtConfBaseInfo::has_is_auto_vmp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMtConfBaseInfo::set_has_is_auto_vmp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMtConfBaseInfo::clear_has_is_auto_vmp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMtConfBaseInfo::clear_is_auto_vmp() {
  is_auto_vmp_ = false;
  clear_has_is_auto_vmp();
}
inline bool TMtConfBaseInfo::is_auto_vmp() const {
  return is_auto_vmp_;
}
inline void TMtConfBaseInfo::set_is_auto_vmp(bool value) {
  set_has_is_auto_vmp();
  is_auto_vmp_ = value;
}

// optional bool is_mix = 16;
inline bool TMtConfBaseInfo::has_is_mix() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMtConfBaseInfo::set_has_is_mix() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMtConfBaseInfo::clear_has_is_mix() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMtConfBaseInfo::clear_is_mix() {
  is_mix_ = false;
  clear_has_is_mix();
}
inline bool TMtConfBaseInfo::is_mix() const {
  return is_mix_;
}
inline void TMtConfBaseInfo::set_is_mix(bool value) {
  set_has_is_mix();
  is_mix_ = value;
}

// optional .mt.EmH264Profile vid_h264Profile = 17;
inline bool TMtConfBaseInfo::has_vid_h264profile() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMtConfBaseInfo::set_has_vid_h264profile() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMtConfBaseInfo::clear_has_vid_h264profile() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMtConfBaseInfo::clear_vid_h264profile() {
  vid_h264profile_ = 0;
  clear_has_vid_h264profile();
}
inline ::mt::EmH264Profile TMtConfBaseInfo::vid_h264profile() const {
  return static_cast< ::mt::EmH264Profile >(vid_h264profile_);
}
inline void TMtConfBaseInfo::set_vid_h264profile(::mt::EmH264Profile value) {
  assert(::mt::EmH264Profile_IsValid(value));
  set_has_vid_h264profile();
  vid_h264profile_ = value;
}

// optional uint32 conf_bitrate = 18;
inline bool TMtConfBaseInfo::has_conf_bitrate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMtConfBaseInfo::set_has_conf_bitrate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMtConfBaseInfo::clear_has_conf_bitrate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMtConfBaseInfo::clear_conf_bitrate() {
  conf_bitrate_ = 0u;
  clear_has_conf_bitrate();
}
inline ::google::protobuf::uint32 TMtConfBaseInfo::conf_bitrate() const {
  return conf_bitrate_;
}
inline void TMtConfBaseInfo::set_conf_bitrate(::google::protobuf::uint32 value) {
  set_has_conf_bitrate();
  conf_bitrate_ = value;
}

// -------------------------------------------------------------------

// TRpMtConfList

// repeated .mt.TMtConfBaseInfo conf_info = 1;
inline int TRpMtConfList::conf_info_size() const {
  return conf_info_.size();
}
inline void TRpMtConfList::clear_conf_info() {
  conf_info_.Clear();
}
inline const ::mt::TMtConfBaseInfo& TRpMtConfList::conf_info(int index) const {
  return conf_info_.Get(index);
}
inline ::mt::TMtConfBaseInfo* TRpMtConfList::mutable_conf_info(int index) {
  return conf_info_.Mutable(index);
}
inline ::mt::TMtConfBaseInfo* TRpMtConfList::add_conf_info() {
  return conf_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtConfBaseInfo >&
TRpMtConfList::conf_info() const {
  return conf_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtConfBaseInfo >*
TRpMtConfList::mutable_conf_info() {
  return &conf_info_;
}

// -------------------------------------------------------------------

// TMtConfNameInfo

// optional string conf_name = 1;
inline bool TMtConfNameInfo::has_conf_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtConfNameInfo::set_has_conf_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtConfNameInfo::clear_has_conf_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtConfNameInfo::clear_conf_name() {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    conf_name_->clear();
  }
  clear_has_conf_name();
}
inline const ::std::string& TMtConfNameInfo::conf_name() const {
  return *conf_name_;
}
inline void TMtConfNameInfo::set_conf_name(const ::std::string& value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtConfNameInfo::set_conf_name(const char* value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtConfNameInfo::set_conf_name(const char* value, size_t size) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtConfNameInfo::mutable_conf_name() {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  return conf_name_;
}
inline ::std::string* TMtConfNameInfo::release_conf_name() {
  clear_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_name_;
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtConfNameInfo::set_allocated_conf_name(::std::string* conf_name) {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_name_;
  }
  if (conf_name) {
    set_has_conf_name();
    conf_name_ = conf_name;
  } else {
    clear_has_conf_name();
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string conf_e164 = 2;
inline bool TMtConfNameInfo::has_conf_e164() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtConfNameInfo::set_has_conf_e164() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtConfNameInfo::clear_has_conf_e164() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtConfNameInfo::clear_conf_e164() {
  if (conf_e164_ != &::google::protobuf::internal::kEmptyString) {
    conf_e164_->clear();
  }
  clear_has_conf_e164();
}
inline const ::std::string& TMtConfNameInfo::conf_e164() const {
  return *conf_e164_;
}
inline void TMtConfNameInfo::set_conf_e164(const ::std::string& value) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(value);
}
inline void TMtConfNameInfo::set_conf_e164(const char* value) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(value);
}
inline void TMtConfNameInfo::set_conf_e164(const char* value, size_t size) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtConfNameInfo::mutable_conf_e164() {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  return conf_e164_;
}
inline ::std::string* TMtConfNameInfo::release_conf_e164() {
  clear_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_e164_;
    conf_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtConfNameInfo::set_allocated_conf_e164(::std::string* conf_e164) {
  if (conf_e164_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_e164_;
  }
  if (conf_e164) {
    set_has_conf_e164();
    conf_e164_ = conf_e164;
  } else {
    clear_has_conf_e164();
    conf_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 terlist_num = 3;
inline bool TMtConfNameInfo::has_terlist_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtConfNameInfo::set_has_terlist_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtConfNameInfo::clear_has_terlist_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtConfNameInfo::clear_terlist_num() {
  terlist_num_ = 0u;
  clear_has_terlist_num();
}
inline ::google::protobuf::uint32 TMtConfNameInfo::terlist_num() const {
  return terlist_num_;
}
inline void TMtConfNameInfo::set_terlist_num(::google::protobuf::uint32 value) {
  set_has_terlist_num();
  terlist_num_ = value;
}

// optional uint32 remain_time = 4;
inline bool TMtConfNameInfo::has_remain_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtConfNameInfo::set_has_remain_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtConfNameInfo::clear_has_remain_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtConfNameInfo::clear_remain_time() {
  remain_time_ = 0u;
  clear_has_remain_time();
}
inline ::google::protobuf::uint32 TMtConfNameInfo::remain_time() const {
  return remain_time_;
}
inline void TMtConfNameInfo::set_remain_time(::google::protobuf::uint32 value) {
  set_has_remain_time();
  remain_time_ = value;
}

// optional .mt.EmMtOpenMode open_mode = 5;
inline bool TMtConfNameInfo::has_open_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtConfNameInfo::set_has_open_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtConfNameInfo::clear_has_open_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtConfNameInfo::clear_open_mode() {
  open_mode_ = 1;
  clear_has_open_mode();
}
inline ::mt::EmMtOpenMode TMtConfNameInfo::open_mode() const {
  return static_cast< ::mt::EmMtOpenMode >(open_mode_);
}
inline void TMtConfNameInfo::set_open_mode(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_open_mode();
  open_mode_ = value;
}

// optional .mt.EmMtClarity clarity_mode = 6;
inline bool TMtConfNameInfo::has_clarity_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtConfNameInfo::set_has_clarity_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtConfNameInfo::clear_has_clarity_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtConfNameInfo::clear_clarity_mode() {
  clarity_mode_ = 1;
  clear_has_clarity_mode();
}
inline ::mt::EmMtClarity TMtConfNameInfo::clarity_mode() const {
  return static_cast< ::mt::EmMtClarity >(clarity_mode_);
}
inline void TMtConfNameInfo::set_clarity_mode(::mt::EmMtClarity value) {
  assert(::mt::EmMtClarity_IsValid(value));
  set_has_clarity_mode();
  clarity_mode_ = value;
}

// optional .mt.TMTTime conf_start_time = 7;
inline bool TMtConfNameInfo::has_conf_start_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtConfNameInfo::set_has_conf_start_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtConfNameInfo::clear_has_conf_start_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtConfNameInfo::clear_conf_start_time() {
  if (conf_start_time_ != NULL) conf_start_time_->::mt::TMTTime::Clear();
  clear_has_conf_start_time();
}
inline const ::mt::TMTTime& TMtConfNameInfo::conf_start_time() const {
  return conf_start_time_ != NULL ? *conf_start_time_ : *default_instance_->conf_start_time_;
}
inline ::mt::TMTTime* TMtConfNameInfo::mutable_conf_start_time() {
  set_has_conf_start_time();
  if (conf_start_time_ == NULL) conf_start_time_ = new ::mt::TMTTime;
  return conf_start_time_;
}
inline ::mt::TMTTime* TMtConfNameInfo::release_conf_start_time() {
  clear_has_conf_start_time();
  ::mt::TMTTime* temp = conf_start_time_;
  conf_start_time_ = NULL;
  return temp;
}
inline void TMtConfNameInfo::set_allocated_conf_start_time(::mt::TMTTime* conf_start_time) {
  delete conf_start_time_;
  conf_start_time_ = conf_start_time;
  if (conf_start_time) {
    set_has_conf_start_time();
  } else {
    clear_has_conf_start_time();
  }
}

// optional bool is_satdcast_mode = 8;
inline bool TMtConfNameInfo::has_is_satdcast_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtConfNameInfo::set_has_is_satdcast_mode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtConfNameInfo::clear_has_is_satdcast_mode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtConfNameInfo::clear_is_satdcast_mode() {
  is_satdcast_mode_ = false;
  clear_has_is_satdcast_mode();
}
inline bool TMtConfNameInfo::is_satdcast_mode() const {
  return is_satdcast_mode_;
}
inline void TMtConfNameInfo::set_is_satdcast_mode(bool value) {
  set_has_is_satdcast_mode();
  is_satdcast_mode_ = value;
}

// optional bool is_public_conf = 9;
inline bool TMtConfNameInfo::has_is_public_conf() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMtConfNameInfo::set_has_is_public_conf() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMtConfNameInfo::clear_has_is_public_conf() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMtConfNameInfo::clear_is_public_conf() {
  is_public_conf_ = false;
  clear_has_is_public_conf();
}
inline bool TMtConfNameInfo::is_public_conf() const {
  return is_public_conf_;
}
inline void TMtConfNameInfo::set_is_public_conf(bool value) {
  set_has_is_public_conf();
  is_public_conf_ = value;
}

// optional bool is_need_pwd = 10;
inline bool TMtConfNameInfo::has_is_need_pwd() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMtConfNameInfo::set_has_is_need_pwd() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMtConfNameInfo::clear_has_is_need_pwd() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMtConfNameInfo::clear_is_need_pwd() {
  is_need_pwd_ = false;
  clear_has_is_need_pwd();
}
inline bool TMtConfNameInfo::is_need_pwd() const {
  return is_need_pwd_;
}
inline void TMtConfNameInfo::set_is_need_pwd(bool value) {
  set_has_is_need_pwd();
  is_need_pwd_ = value;
}

// -------------------------------------------------------------------

// TRpMtConfNameInfo

// repeated .mt.TMtConfNameInfo conf_name_info = 1;
inline int TRpMtConfNameInfo::conf_name_info_size() const {
  return conf_name_info_.size();
}
inline void TRpMtConfNameInfo::clear_conf_name_info() {
  conf_name_info_.Clear();
}
inline const ::mt::TMtConfNameInfo& TRpMtConfNameInfo::conf_name_info(int index) const {
  return conf_name_info_.Get(index);
}
inline ::mt::TMtConfNameInfo* TRpMtConfNameInfo::mutable_conf_name_info(int index) {
  return conf_name_info_.Mutable(index);
}
inline ::mt::TMtConfNameInfo* TRpMtConfNameInfo::add_conf_name_info() {
  return conf_name_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtConfNameInfo >&
TRpMtConfNameInfo::conf_name_info() const {
  return conf_name_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtConfNameInfo >*
TRpMtConfNameInfo::mutable_conf_name_info() {
  return &conf_name_info_;
}

// -------------------------------------------------------------------

// TMtNewConfBaseInfo

// optional string conf_name = 1;
inline bool TMtNewConfBaseInfo::has_conf_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtNewConfBaseInfo::set_has_conf_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtNewConfBaseInfo::clear_has_conf_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtNewConfBaseInfo::clear_conf_name() {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    conf_name_->clear();
  }
  clear_has_conf_name();
}
inline const ::std::string& TMtNewConfBaseInfo::conf_name() const {
  return *conf_name_;
}
inline void TMtNewConfBaseInfo::set_conf_name(const ::std::string& value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtNewConfBaseInfo::set_conf_name(const char* value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtNewConfBaseInfo::set_conf_name(const char* value, size_t size) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtNewConfBaseInfo::mutable_conf_name() {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  return conf_name_;
}
inline ::std::string* TMtNewConfBaseInfo::release_conf_name() {
  clear_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_name_;
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtNewConfBaseInfo::set_allocated_conf_name(::std::string* conf_name) {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_name_;
  }
  if (conf_name) {
    set_has_conf_name();
    conf_name_ = conf_name;
  } else {
    clear_has_conf_name();
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string conf_e164 = 2;
inline bool TMtNewConfBaseInfo::has_conf_e164() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtNewConfBaseInfo::set_has_conf_e164() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtNewConfBaseInfo::clear_has_conf_e164() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtNewConfBaseInfo::clear_conf_e164() {
  if (conf_e164_ != &::google::protobuf::internal::kEmptyString) {
    conf_e164_->clear();
  }
  clear_has_conf_e164();
}
inline const ::std::string& TMtNewConfBaseInfo::conf_e164() const {
  return *conf_e164_;
}
inline void TMtNewConfBaseInfo::set_conf_e164(const ::std::string& value) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(value);
}
inline void TMtNewConfBaseInfo::set_conf_e164(const char* value) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(value);
}
inline void TMtNewConfBaseInfo::set_conf_e164(const char* value, size_t size) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtNewConfBaseInfo::mutable_conf_e164() {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  return conf_e164_;
}
inline ::std::string* TMtNewConfBaseInfo::release_conf_e164() {
  clear_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_e164_;
    conf_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtNewConfBaseInfo::set_allocated_conf_e164(::std::string* conf_e164) {
  if (conf_e164_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_e164_;
  }
  if (conf_e164) {
    set_has_conf_e164();
    conf_e164_ = conf_e164;
  } else {
    clear_has_conf_e164();
    conf_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string domain_guid = 3;
inline bool TMtNewConfBaseInfo::has_domain_guid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtNewConfBaseInfo::set_has_domain_guid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtNewConfBaseInfo::clear_has_domain_guid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtNewConfBaseInfo::clear_domain_guid() {
  if (domain_guid_ != &::google::protobuf::internal::kEmptyString) {
    domain_guid_->clear();
  }
  clear_has_domain_guid();
}
inline const ::std::string& TMtNewConfBaseInfo::domain_guid() const {
  return *domain_guid_;
}
inline void TMtNewConfBaseInfo::set_domain_guid(const ::std::string& value) {
  set_has_domain_guid();
  if (domain_guid_ == &::google::protobuf::internal::kEmptyString) {
    domain_guid_ = new ::std::string;
  }
  domain_guid_->assign(value);
}
inline void TMtNewConfBaseInfo::set_domain_guid(const char* value) {
  set_has_domain_guid();
  if (domain_guid_ == &::google::protobuf::internal::kEmptyString) {
    domain_guid_ = new ::std::string;
  }
  domain_guid_->assign(value);
}
inline void TMtNewConfBaseInfo::set_domain_guid(const char* value, size_t size) {
  set_has_domain_guid();
  if (domain_guid_ == &::google::protobuf::internal::kEmptyString) {
    domain_guid_ = new ::std::string;
  }
  domain_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtNewConfBaseInfo::mutable_domain_guid() {
  set_has_domain_guid();
  if (domain_guid_ == &::google::protobuf::internal::kEmptyString) {
    domain_guid_ = new ::std::string;
  }
  return domain_guid_;
}
inline ::std::string* TMtNewConfBaseInfo::release_domain_guid() {
  clear_has_domain_guid();
  if (domain_guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_guid_;
    domain_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtNewConfBaseInfo::set_allocated_domain_guid(::std::string* domain_guid) {
  if (domain_guid_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_guid_;
  }
  if (domain_guid) {
    set_has_domain_guid();
    domain_guid_ = domain_guid;
  } else {
    clear_has_domain_guid();
    domain_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string domain_name = 4;
inline bool TMtNewConfBaseInfo::has_domain_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtNewConfBaseInfo::set_has_domain_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtNewConfBaseInfo::clear_has_domain_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtNewConfBaseInfo::clear_domain_name() {
  if (domain_name_ != &::google::protobuf::internal::kEmptyString) {
    domain_name_->clear();
  }
  clear_has_domain_name();
}
inline const ::std::string& TMtNewConfBaseInfo::domain_name() const {
  return *domain_name_;
}
inline void TMtNewConfBaseInfo::set_domain_name(const ::std::string& value) {
  set_has_domain_name();
  if (domain_name_ == &::google::protobuf::internal::kEmptyString) {
    domain_name_ = new ::std::string;
  }
  domain_name_->assign(value);
}
inline void TMtNewConfBaseInfo::set_domain_name(const char* value) {
  set_has_domain_name();
  if (domain_name_ == &::google::protobuf::internal::kEmptyString) {
    domain_name_ = new ::std::string;
  }
  domain_name_->assign(value);
}
inline void TMtNewConfBaseInfo::set_domain_name(const char* value, size_t size) {
  set_has_domain_name();
  if (domain_name_ == &::google::protobuf::internal::kEmptyString) {
    domain_name_ = new ::std::string;
  }
  domain_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtNewConfBaseInfo::mutable_domain_name() {
  set_has_domain_name();
  if (domain_name_ == &::google::protobuf::internal::kEmptyString) {
    domain_name_ = new ::std::string;
  }
  return domain_name_;
}
inline ::std::string* TMtNewConfBaseInfo::release_domain_name() {
  clear_has_domain_name();
  if (domain_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_name_;
    domain_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtNewConfBaseInfo::set_allocated_domain_name(::std::string* domain_name) {
  if (domain_name_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_name_;
  }
  if (domain_name) {
    set_has_domain_name();
    domain_name_ = domain_name;
  } else {
    clear_has_domain_name();
    domain_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string domain_moid = 5;
inline bool TMtNewConfBaseInfo::has_domain_moid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtNewConfBaseInfo::set_has_domain_moid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtNewConfBaseInfo::clear_has_domain_moid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtNewConfBaseInfo::clear_domain_moid() {
  if (domain_moid_ != &::google::protobuf::internal::kEmptyString) {
    domain_moid_->clear();
  }
  clear_has_domain_moid();
}
inline const ::std::string& TMtNewConfBaseInfo::domain_moid() const {
  return *domain_moid_;
}
inline void TMtNewConfBaseInfo::set_domain_moid(const ::std::string& value) {
  set_has_domain_moid();
  if (domain_moid_ == &::google::protobuf::internal::kEmptyString) {
    domain_moid_ = new ::std::string;
  }
  domain_moid_->assign(value);
}
inline void TMtNewConfBaseInfo::set_domain_moid(const char* value) {
  set_has_domain_moid();
  if (domain_moid_ == &::google::protobuf::internal::kEmptyString) {
    domain_moid_ = new ::std::string;
  }
  domain_moid_->assign(value);
}
inline void TMtNewConfBaseInfo::set_domain_moid(const char* value, size_t size) {
  set_has_domain_moid();
  if (domain_moid_ == &::google::protobuf::internal::kEmptyString) {
    domain_moid_ = new ::std::string;
  }
  domain_moid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtNewConfBaseInfo::mutable_domain_moid() {
  set_has_domain_moid();
  if (domain_moid_ == &::google::protobuf::internal::kEmptyString) {
    domain_moid_ = new ::std::string;
  }
  return domain_moid_;
}
inline ::std::string* TMtNewConfBaseInfo::release_domain_moid() {
  clear_has_domain_moid();
  if (domain_moid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_moid_;
    domain_moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtNewConfBaseInfo::set_allocated_domain_moid(::std::string* domain_moid) {
  if (domain_moid_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_moid_;
  }
  if (domain_moid) {
    set_has_domain_moid();
    domain_moid_ = domain_moid;
  } else {
    clear_has_domain_moid();
    domain_moid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtConfDetailInfo

// optional .mt.TMtNewConfBaseInfo new_conf_base_info = 1;
inline bool TMtConfDetailInfo::has_new_conf_base_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtConfDetailInfo::set_has_new_conf_base_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtConfDetailInfo::clear_has_new_conf_base_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtConfDetailInfo::clear_new_conf_base_info() {
  if (new_conf_base_info_ != NULL) new_conf_base_info_->::mt::TMtNewConfBaseInfo::Clear();
  clear_has_new_conf_base_info();
}
inline const ::mt::TMtNewConfBaseInfo& TMtConfDetailInfo::new_conf_base_info() const {
  return new_conf_base_info_ != NULL ? *new_conf_base_info_ : *default_instance_->new_conf_base_info_;
}
inline ::mt::TMtNewConfBaseInfo* TMtConfDetailInfo::mutable_new_conf_base_info() {
  set_has_new_conf_base_info();
  if (new_conf_base_info_ == NULL) new_conf_base_info_ = new ::mt::TMtNewConfBaseInfo;
  return new_conf_base_info_;
}
inline ::mt::TMtNewConfBaseInfo* TMtConfDetailInfo::release_new_conf_base_info() {
  clear_has_new_conf_base_info();
  ::mt::TMtNewConfBaseInfo* temp = new_conf_base_info_;
  new_conf_base_info_ = NULL;
  return temp;
}
inline void TMtConfDetailInfo::set_allocated_new_conf_base_info(::mt::TMtNewConfBaseInfo* new_conf_base_info) {
  delete new_conf_base_info_;
  new_conf_base_info_ = new_conf_base_info;
  if (new_conf_base_info) {
    set_has_new_conf_base_info();
  } else {
    clear_has_new_conf_base_info();
  }
}

// optional uint32 conf_style = 2;
inline bool TMtConfDetailInfo::has_conf_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtConfDetailInfo::set_has_conf_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtConfDetailInfo::clear_has_conf_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtConfDetailInfo::clear_conf_style() {
  conf_style_ = 0u;
  clear_has_conf_style();
}
inline ::google::protobuf::uint32 TMtConfDetailInfo::conf_style() const {
  return conf_style_;
}
inline void TMtConfDetailInfo::set_conf_style(::google::protobuf::uint32 value) {
  set_has_conf_style();
  conf_style_ = value;
}

// optional string short_num = 3;
inline bool TMtConfDetailInfo::has_short_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtConfDetailInfo::set_has_short_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtConfDetailInfo::clear_has_short_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtConfDetailInfo::clear_short_num() {
  if (short_num_ != &::google::protobuf::internal::kEmptyString) {
    short_num_->clear();
  }
  clear_has_short_num();
}
inline const ::std::string& TMtConfDetailInfo::short_num() const {
  return *short_num_;
}
inline void TMtConfDetailInfo::set_short_num(const ::std::string& value) {
  set_has_short_num();
  if (short_num_ == &::google::protobuf::internal::kEmptyString) {
    short_num_ = new ::std::string;
  }
  short_num_->assign(value);
}
inline void TMtConfDetailInfo::set_short_num(const char* value) {
  set_has_short_num();
  if (short_num_ == &::google::protobuf::internal::kEmptyString) {
    short_num_ = new ::std::string;
  }
  short_num_->assign(value);
}
inline void TMtConfDetailInfo::set_short_num(const char* value, size_t size) {
  set_has_short_num();
  if (short_num_ == &::google::protobuf::internal::kEmptyString) {
    short_num_ = new ::std::string;
  }
  short_num_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtConfDetailInfo::mutable_short_num() {
  set_has_short_num();
  if (short_num_ == &::google::protobuf::internal::kEmptyString) {
    short_num_ = new ::std::string;
  }
  return short_num_;
}
inline ::std::string* TMtConfDetailInfo::release_short_num() {
  clear_has_short_num();
  if (short_num_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = short_num_;
    short_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtConfDetailInfo::set_allocated_short_num(::std::string* short_num) {
  if (short_num_ != &::google::protobuf::internal::kEmptyString) {
    delete short_num_;
  }
  if (short_num) {
    set_has_short_num();
    short_num_ = short_num;
  } else {
    clear_has_short_num();
    short_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmEncryptArithmetic encrypt_mode = 4;
inline bool TMtConfDetailInfo::has_encrypt_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtConfDetailInfo::set_has_encrypt_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtConfDetailInfo::clear_has_encrypt_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtConfDetailInfo::clear_encrypt_mode() {
  encrypt_mode_ = 0;
  clear_has_encrypt_mode();
}
inline ::mt::EmEncryptArithmetic TMtConfDetailInfo::encrypt_mode() const {
  return static_cast< ::mt::EmEncryptArithmetic >(encrypt_mode_);
}
inline void TMtConfDetailInfo::set_encrypt_mode(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_encrypt_mode();
  encrypt_mode_ = value;
}

// optional uint32 bitrate = 5;
inline bool TMtConfDetailInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtConfDetailInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtConfDetailInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtConfDetailInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMtConfDetailInfo::bitrate() const {
  return bitrate_;
}
inline void TMtConfDetailInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional .mt.EmMtClarity clarity_mode = 6;
inline bool TMtConfDetailInfo::has_clarity_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtConfDetailInfo::set_has_clarity_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtConfDetailInfo::clear_has_clarity_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtConfDetailInfo::clear_clarity_mode() {
  clarity_mode_ = 1;
  clear_has_clarity_mode();
}
inline ::mt::EmMtClarity TMtConfDetailInfo::clarity_mode() const {
  return static_cast< ::mt::EmMtClarity >(clarity_mode_);
}
inline void TMtConfDetailInfo::set_clarity_mode(::mt::EmMtClarity value) {
  assert(::mt::EmMtClarity_IsValid(value));
  set_has_clarity_mode();
  clarity_mode_ = value;
}

// optional .mt.EmMtResolution vid_res = 7;
inline bool TMtConfDetailInfo::has_vid_res() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtConfDetailInfo::set_has_vid_res() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtConfDetailInfo::clear_has_vid_res() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtConfDetailInfo::clear_vid_res() {
  vid_res_ = 0;
  clear_has_vid_res();
}
inline ::mt::EmMtResolution TMtConfDetailInfo::vid_res() const {
  return static_cast< ::mt::EmMtResolution >(vid_res_);
}
inline void TMtConfDetailInfo::set_vid_res(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_vid_res();
  vid_res_ = value;
}

// optional .mt.EmMtOpenMode open_mode = 8;
inline bool TMtConfDetailInfo::has_open_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtConfDetailInfo::set_has_open_mode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtConfDetailInfo::clear_has_open_mode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtConfDetailInfo::clear_open_mode() {
  open_mode_ = 1;
  clear_has_open_mode();
}
inline ::mt::EmMtOpenMode TMtConfDetailInfo::open_mode() const {
  return static_cast< ::mt::EmMtOpenMode >(open_mode_);
}
inline void TMtConfDetailInfo::set_open_mode(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_open_mode();
  open_mode_ = value;
}

// optional bool is_discuss_conf = 9;
inline bool TMtConfDetailInfo::has_is_discuss_conf() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMtConfDetailInfo::set_has_is_discuss_conf() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMtConfDetailInfo::clear_has_is_discuss_conf() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMtConfDetailInfo::clear_is_discuss_conf() {
  is_discuss_conf_ = false;
  clear_has_is_discuss_conf();
}
inline bool TMtConfDetailInfo::is_discuss_conf() const {
  return is_discuss_conf_;
}
inline void TMtConfDetailInfo::set_is_discuss_conf(bool value) {
  set_has_is_discuss_conf();
  is_discuss_conf_ = value;
}

// optional .mt.TMTTime start_time = 10;
inline bool TMtConfDetailInfo::has_start_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMtConfDetailInfo::set_has_start_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMtConfDetailInfo::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMtConfDetailInfo::clear_start_time() {
  if (start_time_ != NULL) start_time_->::mt::TMTTime::Clear();
  clear_has_start_time();
}
inline const ::mt::TMTTime& TMtConfDetailInfo::start_time() const {
  return start_time_ != NULL ? *start_time_ : *default_instance_->start_time_;
}
inline ::mt::TMTTime* TMtConfDetailInfo::mutable_start_time() {
  set_has_start_time();
  if (start_time_ == NULL) start_time_ = new ::mt::TMTTime;
  return start_time_;
}
inline ::mt::TMTTime* TMtConfDetailInfo::release_start_time() {
  clear_has_start_time();
  ::mt::TMTTime* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline void TMtConfDetailInfo::set_allocated_start_time(::mt::TMTTime* start_time) {
  delete start_time_;
  start_time_ = start_time;
  if (start_time) {
    set_has_start_time();
  } else {
    clear_has_start_time();
  }
}

// optional uint32 duration = 11;
inline bool TMtConfDetailInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMtConfDetailInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMtConfDetailInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMtConfDetailInfo::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMtConfDetailInfo::duration() const {
  return duration_;
}
inline void TMtConfDetailInfo::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional string alias = 12;
inline bool TMtConfDetailInfo::has_alias() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMtConfDetailInfo::set_has_alias() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMtConfDetailInfo::clear_has_alias() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMtConfDetailInfo::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& TMtConfDetailInfo::alias() const {
  return *alias_;
}
inline void TMtConfDetailInfo::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMtConfDetailInfo::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TMtConfDetailInfo::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtConfDetailInfo::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* TMtConfDetailInfo::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtConfDetailInfo::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmMtDualMode dual_mode = 13;
inline bool TMtConfDetailInfo::has_dual_mode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMtConfDetailInfo::set_has_dual_mode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMtConfDetailInfo::clear_has_dual_mode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMtConfDetailInfo::clear_dual_mode() {
  dual_mode_ = 0;
  clear_has_dual_mode();
}
inline ::mt::EmMtDualMode TMtConfDetailInfo::dual_mode() const {
  return static_cast< ::mt::EmMtDualMode >(dual_mode_);
}
inline void TMtConfDetailInfo::set_dual_mode(::mt::EmMtDualMode value) {
  assert(::mt::EmMtDualMode_IsValid(value));
  set_has_dual_mode();
  dual_mode_ = value;
}

// optional bool is_satdcast_mode = 14;
inline bool TMtConfDetailInfo::has_is_satdcast_mode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMtConfDetailInfo::set_has_is_satdcast_mode() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMtConfDetailInfo::clear_has_is_satdcast_mode() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMtConfDetailInfo::clear_is_satdcast_mode() {
  is_satdcast_mode_ = false;
  clear_has_is_satdcast_mode();
}
inline bool TMtConfDetailInfo::is_satdcast_mode() const {
  return is_satdcast_mode_;
}
inline void TMtConfDetailInfo::set_is_satdcast_mode(bool value) {
  set_has_is_satdcast_mode();
  is_satdcast_mode_ = value;
}

// optional bool is_public_conf = 15;
inline bool TMtConfDetailInfo::has_is_public_conf() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMtConfDetailInfo::set_has_is_public_conf() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMtConfDetailInfo::clear_has_is_public_conf() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMtConfDetailInfo::clear_is_public_conf() {
  is_public_conf_ = false;
  clear_has_is_public_conf();
}
inline bool TMtConfDetailInfo::is_public_conf() const {
  return is_public_conf_;
}
inline void TMtConfDetailInfo::set_is_public_conf(bool value) {
  set_has_is_public_conf();
  is_public_conf_ = value;
}

// optional bool is_port_mode = 16;
inline bool TMtConfDetailInfo::has_is_port_mode() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMtConfDetailInfo::set_has_is_port_mode() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMtConfDetailInfo::clear_has_is_port_mode() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMtConfDetailInfo::clear_is_port_mode() {
  is_port_mode_ = false;
  clear_has_is_port_mode();
}
inline bool TMtConfDetailInfo::is_port_mode() const {
  return is_port_mode_;
}
inline void TMtConfDetailInfo::set_is_port_mode(bool value) {
  set_has_is_port_mode();
  is_port_mode_ = value;
}

// optional bool is_conf_no_disturb = 17;
inline bool TMtConfDetailInfo::has_is_conf_no_disturb() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMtConfDetailInfo::set_has_is_conf_no_disturb() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMtConfDetailInfo::clear_has_is_conf_no_disturb() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMtConfDetailInfo::clear_is_conf_no_disturb() {
  is_conf_no_disturb_ = false;
  clear_has_is_conf_no_disturb();
}
inline bool TMtConfDetailInfo::is_conf_no_disturb() const {
  return is_conf_no_disturb_;
}
inline void TMtConfDetailInfo::set_is_conf_no_disturb(bool value) {
  set_has_is_conf_no_disturb();
  is_conf_no_disturb_ = value;
}

// optional bool is_need_pwd = 18;
inline bool TMtConfDetailInfo::has_is_need_pwd() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMtConfDetailInfo::set_has_is_need_pwd() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMtConfDetailInfo::clear_has_is_need_pwd() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMtConfDetailInfo::clear_is_need_pwd() {
  is_need_pwd_ = false;
  clear_has_is_need_pwd();
}
inline bool TMtConfDetailInfo::is_need_pwd() const {
  return is_need_pwd_;
}
inline void TMtConfDetailInfo::set_is_need_pwd(bool value) {
  set_has_is_need_pwd();
  is_need_pwd_ = value;
}

// optional uint32 max_joined_mt = 19;
inline bool TMtConfDetailInfo::has_max_joined_mt() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMtConfDetailInfo::set_has_max_joined_mt() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMtConfDetailInfo::clear_has_max_joined_mt() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMtConfDetailInfo::clear_max_joined_mt() {
  max_joined_mt_ = 0u;
  clear_has_max_joined_mt();
}
inline ::google::protobuf::uint32 TMtConfDetailInfo::max_joined_mt() const {
  return max_joined_mt_;
}
inline void TMtConfDetailInfo::set_max_joined_mt(::google::protobuf::uint32 value) {
  set_has_max_joined_mt();
  max_joined_mt_ = value;
}

// -------------------------------------------------------------------

// TMtJoinConfParam

// optional uint32 call_rate = 1;
inline bool TMtJoinConfParam::has_call_rate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtJoinConfParam::set_has_call_rate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtJoinConfParam::clear_has_call_rate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtJoinConfParam::clear_call_rate() {
  call_rate_ = 0u;
  clear_has_call_rate();
}
inline ::google::protobuf::uint32 TMtJoinConfParam::call_rate() const {
  return call_rate_;
}
inline void TMtJoinConfParam::set_call_rate(::google::protobuf::uint32 value) {
  set_has_call_rate();
  call_rate_ = value;
}

// optional string conf_e164 = 2;
inline bool TMtJoinConfParam::has_conf_e164() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtJoinConfParam::set_has_conf_e164() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtJoinConfParam::clear_has_conf_e164() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtJoinConfParam::clear_conf_e164() {
  if (conf_e164_ != &::google::protobuf::internal::kEmptyString) {
    conf_e164_->clear();
  }
  clear_has_conf_e164();
}
inline const ::std::string& TMtJoinConfParam::conf_e164() const {
  return *conf_e164_;
}
inline void TMtJoinConfParam::set_conf_e164(const ::std::string& value) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(value);
}
inline void TMtJoinConfParam::set_conf_e164(const char* value) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(value);
}
inline void TMtJoinConfParam::set_conf_e164(const char* value, size_t size) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtJoinConfParam::mutable_conf_e164() {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  return conf_e164_;
}
inline ::std::string* TMtJoinConfParam::release_conf_e164() {
  clear_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_e164_;
    conf_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtJoinConfParam::set_allocated_conf_e164(::std::string* conf_e164) {
  if (conf_e164_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_e164_;
  }
  if (conf_e164) {
    set_has_conf_e164();
    conf_e164_ = conf_e164;
  } else {
    clear_has_conf_e164();
    conf_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string conf_pwd = 3;
inline bool TMtJoinConfParam::has_conf_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtJoinConfParam::set_has_conf_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtJoinConfParam::clear_has_conf_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtJoinConfParam::clear_conf_pwd() {
  if (conf_pwd_ != &::google::protobuf::internal::kEmptyString) {
    conf_pwd_->clear();
  }
  clear_has_conf_pwd();
}
inline const ::std::string& TMtJoinConfParam::conf_pwd() const {
  return *conf_pwd_;
}
inline void TMtJoinConfParam::set_conf_pwd(const ::std::string& value) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(value);
}
inline void TMtJoinConfParam::set_conf_pwd(const char* value) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(value);
}
inline void TMtJoinConfParam::set_conf_pwd(const char* value, size_t size) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtJoinConfParam::mutable_conf_pwd() {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  return conf_pwd_;
}
inline ::std::string* TMtJoinConfParam::release_conf_pwd() {
  clear_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_pwd_;
    conf_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtJoinConfParam::set_allocated_conf_pwd(::std::string* conf_pwd) {
  if (conf_pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_pwd_;
  }
  if (conf_pwd) {
    set_has_conf_pwd();
    conf_pwd_ = conf_pwd;
  } else {
    clear_has_conf_pwd();
    conf_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_dial = 4;
inline bool TMtJoinConfParam::has_is_dial() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtJoinConfParam::set_has_is_dial() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtJoinConfParam::clear_has_is_dial() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtJoinConfParam::clear_is_dial() {
  is_dial_ = false;
  clear_has_is_dial();
}
inline bool TMtJoinConfParam::is_dial() const {
  return is_dial_;
}
inline void TMtJoinConfParam::set_is_dial(bool value) {
  set_has_is_dial();
  is_dial_ = value;
}

// optional string dial_num = 5;
inline bool TMtJoinConfParam::has_dial_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtJoinConfParam::set_has_dial_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtJoinConfParam::clear_has_dial_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtJoinConfParam::clear_dial_num() {
  if (dial_num_ != &::google::protobuf::internal::kEmptyString) {
    dial_num_->clear();
  }
  clear_has_dial_num();
}
inline const ::std::string& TMtJoinConfParam::dial_num() const {
  return *dial_num_;
}
inline void TMtJoinConfParam::set_dial_num(const ::std::string& value) {
  set_has_dial_num();
  if (dial_num_ == &::google::protobuf::internal::kEmptyString) {
    dial_num_ = new ::std::string;
  }
  dial_num_->assign(value);
}
inline void TMtJoinConfParam::set_dial_num(const char* value) {
  set_has_dial_num();
  if (dial_num_ == &::google::protobuf::internal::kEmptyString) {
    dial_num_ = new ::std::string;
  }
  dial_num_->assign(value);
}
inline void TMtJoinConfParam::set_dial_num(const char* value, size_t size) {
  set_has_dial_num();
  if (dial_num_ == &::google::protobuf::internal::kEmptyString) {
    dial_num_ = new ::std::string;
  }
  dial_num_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtJoinConfParam::mutable_dial_num() {
  set_has_dial_num();
  if (dial_num_ == &::google::protobuf::internal::kEmptyString) {
    dial_num_ = new ::std::string;
  }
  return dial_num_;
}
inline ::std::string* TMtJoinConfParam::release_dial_num() {
  clear_has_dial_num();
  if (dial_num_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dial_num_;
    dial_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtJoinConfParam::set_allocated_dial_num(::std::string* dial_num) {
  if (dial_num_ != &::google::protobuf::internal::kEmptyString) {
    delete dial_num_;
  }
  if (dial_num) {
    set_has_dial_num();
    dial_num_ = dial_num;
  } else {
    clear_has_dial_num();
    dial_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string conf_name = 6;
inline bool TMtJoinConfParam::has_conf_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtJoinConfParam::set_has_conf_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtJoinConfParam::clear_has_conf_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtJoinConfParam::clear_conf_name() {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    conf_name_->clear();
  }
  clear_has_conf_name();
}
inline const ::std::string& TMtJoinConfParam::conf_name() const {
  return *conf_name_;
}
inline void TMtJoinConfParam::set_conf_name(const ::std::string& value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtJoinConfParam::set_conf_name(const char* value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtJoinConfParam::set_conf_name(const char* value, size_t size) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtJoinConfParam::mutable_conf_name() {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  return conf_name_;
}
inline ::std::string* TMtJoinConfParam::release_conf_name() {
  clear_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_name_;
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtJoinConfParam::set_allocated_conf_name(::std::string* conf_name) {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_name_;
  }
  if (conf_name) {
    set_has_conf_name();
    conf_name_ = conf_name;
  } else {
    clear_has_conf_name();
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string conf_name_ai = 7;
inline bool TMtJoinConfParam::has_conf_name_ai() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtJoinConfParam::set_has_conf_name_ai() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtJoinConfParam::clear_has_conf_name_ai() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtJoinConfParam::clear_conf_name_ai() {
  if (conf_name_ai_ != &::google::protobuf::internal::kEmptyString) {
    conf_name_ai_->clear();
  }
  clear_has_conf_name_ai();
}
inline const ::std::string& TMtJoinConfParam::conf_name_ai() const {
  return *conf_name_ai_;
}
inline void TMtJoinConfParam::set_conf_name_ai(const ::std::string& value) {
  set_has_conf_name_ai();
  if (conf_name_ai_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ai_ = new ::std::string;
  }
  conf_name_ai_->assign(value);
}
inline void TMtJoinConfParam::set_conf_name_ai(const char* value) {
  set_has_conf_name_ai();
  if (conf_name_ai_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ai_ = new ::std::string;
  }
  conf_name_ai_->assign(value);
}
inline void TMtJoinConfParam::set_conf_name_ai(const char* value, size_t size) {
  set_has_conf_name_ai();
  if (conf_name_ai_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ai_ = new ::std::string;
  }
  conf_name_ai_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtJoinConfParam::mutable_conf_name_ai() {
  set_has_conf_name_ai();
  if (conf_name_ai_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ai_ = new ::std::string;
  }
  return conf_name_ai_;
}
inline ::std::string* TMtJoinConfParam::release_conf_name_ai() {
  clear_has_conf_name_ai();
  if (conf_name_ai_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_name_ai_;
    conf_name_ai_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtJoinConfParam::set_allocated_conf_name_ai(::std::string* conf_name_ai) {
  if (conf_name_ai_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_name_ai_;
  }
  if (conf_name_ai) {
    set_has_conf_name_ai();
    conf_name_ai_ = conf_name_ai;
  } else {
    clear_has_conf_name_ai();
    conf_name_ai_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtJoinConfParamList

// repeated .mt.TMtJoinConfParam list = 1;
inline int TMtJoinConfParamList::list_size() const {
  return list_.size();
}
inline void TMtJoinConfParamList::clear_list() {
  list_.Clear();
}
inline const ::mt::TMtJoinConfParam& TMtJoinConfParamList::list(int index) const {
  return list_.Get(index);
}
inline ::mt::TMtJoinConfParam* TMtJoinConfParamList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::mt::TMtJoinConfParam* TMtJoinConfParamList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtJoinConfParam >&
TMtJoinConfParamList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtJoinConfParam >*
TMtJoinConfParamList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// TMtCreateConfParam

// optional string conf_pwd = 1;
inline bool TMtCreateConfParam::has_conf_pwd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtCreateConfParam::set_has_conf_pwd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtCreateConfParam::clear_has_conf_pwd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtCreateConfParam::clear_conf_pwd() {
  if (conf_pwd_ != &::google::protobuf::internal::kEmptyString) {
    conf_pwd_->clear();
  }
  clear_has_conf_pwd();
}
inline const ::std::string& TMtCreateConfParam::conf_pwd() const {
  return *conf_pwd_;
}
inline void TMtCreateConfParam::set_conf_pwd(const ::std::string& value) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(value);
}
inline void TMtCreateConfParam::set_conf_pwd(const char* value) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(value);
}
inline void TMtCreateConfParam::set_conf_pwd(const char* value, size_t size) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCreateConfParam::mutable_conf_pwd() {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  return conf_pwd_;
}
inline ::std::string* TMtCreateConfParam::release_conf_pwd() {
  clear_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_pwd_;
    conf_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCreateConfParam::set_allocated_conf_pwd(::std::string* conf_pwd) {
  if (conf_pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_pwd_;
  }
  if (conf_pwd) {
    set_has_conf_pwd();
    conf_pwd_ = conf_pwd;
  } else {
    clear_has_conf_pwd();
    conf_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string conf_name = 2;
inline bool TMtCreateConfParam::has_conf_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtCreateConfParam::set_has_conf_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtCreateConfParam::clear_has_conf_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtCreateConfParam::clear_conf_name() {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    conf_name_->clear();
  }
  clear_has_conf_name();
}
inline const ::std::string& TMtCreateConfParam::conf_name() const {
  return *conf_name_;
}
inline void TMtCreateConfParam::set_conf_name(const ::std::string& value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtCreateConfParam::set_conf_name(const char* value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtCreateConfParam::set_conf_name(const char* value, size_t size) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCreateConfParam::mutable_conf_name() {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  return conf_name_;
}
inline ::std::string* TMtCreateConfParam::release_conf_name() {
  clear_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_name_;
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCreateConfParam::set_allocated_conf_name(::std::string* conf_name) {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_name_;
  }
  if (conf_name) {
    set_has_conf_name();
    conf_name_ = conf_name;
  } else {
    clear_has_conf_name();
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 conf_duration = 3;
inline bool TMtCreateConfParam::has_conf_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtCreateConfParam::set_has_conf_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtCreateConfParam::clear_has_conf_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtCreateConfParam::clear_conf_duration() {
  conf_duration_ = 0u;
  clear_has_conf_duration();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::conf_duration() const {
  return conf_duration_;
}
inline void TMtCreateConfParam::set_conf_duration(::google::protobuf::uint32 value) {
  set_has_conf_duration();
  conf_duration_ = value;
}

// optional uint32 conf_bitrate = 4;
inline bool TMtCreateConfParam::has_conf_bitrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtCreateConfParam::set_has_conf_bitrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtCreateConfParam::clear_has_conf_bitrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtCreateConfParam::clear_conf_bitrate() {
  conf_bitrate_ = 0u;
  clear_has_conf_bitrate();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::conf_bitrate() const {
  return conf_bitrate_;
}
inline void TMtCreateConfParam::set_conf_bitrate(::google::protobuf::uint32 value) {
  set_has_conf_bitrate();
  conf_bitrate_ = value;
}

// optional .mt.EmMtOpenMode open_mode = 5;
inline bool TMtCreateConfParam::has_open_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtCreateConfParam::set_has_open_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtCreateConfParam::clear_has_open_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtCreateConfParam::clear_open_mode() {
  open_mode_ = 1;
  clear_has_open_mode();
}
inline ::mt::EmMtOpenMode TMtCreateConfParam::open_mode() const {
  return static_cast< ::mt::EmMtOpenMode >(open_mode_);
}
inline void TMtCreateConfParam::set_open_mode(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_open_mode();
  open_mode_ = value;
}

// optional .mt.EmMtConfReleaseModeDef release_mode = 6;
inline bool TMtCreateConfParam::has_release_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtCreateConfParam::set_has_release_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtCreateConfParam::clear_has_release_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtCreateConfParam::clear_release_mode() {
  release_mode_ = 0;
  clear_has_release_mode();
}
inline ::mt::EmMtConfReleaseModeDef TMtCreateConfParam::release_mode() const {
  return static_cast< ::mt::EmMtConfReleaseModeDef >(release_mode_);
}
inline void TMtCreateConfParam::set_release_mode(::mt::EmMtConfReleaseModeDef value) {
  assert(::mt::EmMtConfReleaseModeDef_IsValid(value));
  set_has_release_mode();
  release_mode_ = value;
}

// optional bool is_all_init_dumb = 7;
inline bool TMtCreateConfParam::has_is_all_init_dumb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtCreateConfParam::set_has_is_all_init_dumb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtCreateConfParam::clear_has_is_all_init_dumb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtCreateConfParam::clear_is_all_init_dumb() {
  is_all_init_dumb_ = false;
  clear_has_is_all_init_dumb();
}
inline bool TMtCreateConfParam::is_all_init_dumb() const {
  return is_all_init_dumb_;
}
inline void TMtCreateConfParam::set_is_all_init_dumb(bool value) {
  set_has_is_all_init_dumb();
  is_all_init_dumb_ = value;
}

// optional .mt.EmEncryptArithmetic conf_encrypt = 8;
inline bool TMtCreateConfParam::has_conf_encrypt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtCreateConfParam::set_has_conf_encrypt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtCreateConfParam::clear_has_conf_encrypt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtCreateConfParam::clear_conf_encrypt() {
  conf_encrypt_ = 0;
  clear_has_conf_encrypt();
}
inline ::mt::EmEncryptArithmetic TMtCreateConfParam::conf_encrypt() const {
  return static_cast< ::mt::EmEncryptArithmetic >(conf_encrypt_);
}
inline void TMtCreateConfParam::set_conf_encrypt(::mt::EmEncryptArithmetic value) {
  assert(::mt::EmEncryptArithmetic_IsValid(value));
  set_has_conf_encrypt();
  conf_encrypt_ = value;
}

// optional bytes enckey = 9;
inline bool TMtCreateConfParam::has_enckey() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMtCreateConfParam::set_has_enckey() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMtCreateConfParam::clear_has_enckey() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMtCreateConfParam::clear_enckey() {
  if (enckey_ != &::google::protobuf::internal::kEmptyString) {
    enckey_->clear();
  }
  clear_has_enckey();
}
inline const ::std::string& TMtCreateConfParam::enckey() const {
  return *enckey_;
}
inline void TMtCreateConfParam::set_enckey(const ::std::string& value) {
  set_has_enckey();
  if (enckey_ == &::google::protobuf::internal::kEmptyString) {
    enckey_ = new ::std::string;
  }
  enckey_->assign(value);
}
inline void TMtCreateConfParam::set_enckey(const char* value) {
  set_has_enckey();
  if (enckey_ == &::google::protobuf::internal::kEmptyString) {
    enckey_ = new ::std::string;
  }
  enckey_->assign(value);
}
inline void TMtCreateConfParam::set_enckey(const void* value, size_t size) {
  set_has_enckey();
  if (enckey_ == &::google::protobuf::internal::kEmptyString) {
    enckey_ = new ::std::string;
  }
  enckey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCreateConfParam::mutable_enckey() {
  set_has_enckey();
  if (enckey_ == &::google::protobuf::internal::kEmptyString) {
    enckey_ = new ::std::string;
  }
  return enckey_;
}
inline ::std::string* TMtCreateConfParam::release_enckey() {
  clear_has_enckey();
  if (enckey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enckey_;
    enckey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCreateConfParam::set_allocated_enckey(::std::string* enckey) {
  if (enckey_ != &::google::protobuf::internal::kEmptyString) {
    delete enckey_;
  }
  if (enckey) {
    set_has_enckey();
    enckey_ = enckey;
  } else {
    clear_has_enckey();
    enckey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_satdcast_mode = 10;
inline bool TMtCreateConfParam::has_is_satdcast_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMtCreateConfParam::set_has_is_satdcast_mode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMtCreateConfParam::clear_has_is_satdcast_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMtCreateConfParam::clear_is_satdcast_mode() {
  is_satdcast_mode_ = false;
  clear_has_is_satdcast_mode();
}
inline bool TMtCreateConfParam::is_satdcast_mode() const {
  return is_satdcast_mode_;
}
inline void TMtCreateConfParam::set_is_satdcast_mode(bool value) {
  set_has_is_satdcast_mode();
  is_satdcast_mode_ = value;
}

// optional uint32 max_bitrate_for_opus = 11;
inline bool TMtCreateConfParam::has_max_bitrate_for_opus() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMtCreateConfParam::set_has_max_bitrate_for_opus() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMtCreateConfParam::clear_has_max_bitrate_for_opus() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMtCreateConfParam::clear_max_bitrate_for_opus() {
  max_bitrate_for_opus_ = 0u;
  clear_has_max_bitrate_for_opus();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::max_bitrate_for_opus() const {
  return max_bitrate_for_opus_;
}
inline void TMtCreateConfParam::set_max_bitrate_for_opus(::google::protobuf::uint32 value) {
  set_has_max_bitrate_for_opus();
  max_bitrate_for_opus_ = value;
}

// optional uint32 min_bitrate_for_opus = 12;
inline bool TMtCreateConfParam::has_min_bitrate_for_opus() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMtCreateConfParam::set_has_min_bitrate_for_opus() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMtCreateConfParam::clear_has_min_bitrate_for_opus() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMtCreateConfParam::clear_min_bitrate_for_opus() {
  min_bitrate_for_opus_ = 0u;
  clear_has_min_bitrate_for_opus();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::min_bitrate_for_opus() const {
  return min_bitrate_for_opus_;
}
inline void TMtCreateConfParam::set_min_bitrate_for_opus(::google::protobuf::uint32 value) {
  set_has_min_bitrate_for_opus();
  min_bitrate_for_opus_ = value;
}

// optional bool is_public_conf = 13;
inline bool TMtCreateConfParam::has_is_public_conf() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMtCreateConfParam::set_has_is_public_conf() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMtCreateConfParam::clear_has_is_public_conf() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMtCreateConfParam::clear_is_public_conf() {
  is_public_conf_ = false;
  clear_has_is_public_conf();
}
inline bool TMtCreateConfParam::is_public_conf() const {
  return is_public_conf_;
}
inline void TMtCreateConfParam::set_is_public_conf(bool value) {
  set_has_is_public_conf();
  is_public_conf_ = value;
}

// optional bool is_port_mode = 14;
inline bool TMtCreateConfParam::has_is_port_mode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMtCreateConfParam::set_has_is_port_mode() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMtCreateConfParam::clear_has_is_port_mode() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMtCreateConfParam::clear_is_port_mode() {
  is_port_mode_ = false;
  clear_has_is_port_mode();
}
inline bool TMtCreateConfParam::is_port_mode() const {
  return is_port_mode_;
}
inline void TMtCreateConfParam::set_is_port_mode(bool value) {
  set_has_is_port_mode();
  is_port_mode_ = value;
}

// optional bool is_conf_nodisturb = 15;
inline bool TMtCreateConfParam::has_is_conf_nodisturb() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMtCreateConfParam::set_has_is_conf_nodisturb() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMtCreateConfParam::clear_has_is_conf_nodisturb() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMtCreateConfParam::clear_is_conf_nodisturb() {
  is_conf_nodisturb_ = false;
  clear_has_is_conf_nodisturb();
}
inline bool TMtCreateConfParam::is_conf_nodisturb() const {
  return is_conf_nodisturb_;
}
inline void TMtCreateConfParam::set_is_conf_nodisturb(bool value) {
  set_has_is_conf_nodisturb();
  is_conf_nodisturb_ = value;
}

// optional .mt.EmVidFormat vid_format = 16;
inline bool TMtCreateConfParam::has_vid_format() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMtCreateConfParam::set_has_vid_format() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMtCreateConfParam::clear_has_vid_format() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMtCreateConfParam::clear_vid_format() {
  vid_format_ = 0;
  clear_has_vid_format();
}
inline ::mt::EmVidFormat TMtCreateConfParam::vid_format() const {
  return static_cast< ::mt::EmVidFormat >(vid_format_);
}
inline void TMtCreateConfParam::set_vid_format(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_vid_format();
  vid_format_ = value;
}

// optional .mt.EmH264Profile h264_profile = 17;
inline bool TMtCreateConfParam::has_h264_profile() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMtCreateConfParam::set_has_h264_profile() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMtCreateConfParam::clear_has_h264_profile() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMtCreateConfParam::clear_h264_profile() {
  h264_profile_ = 0;
  clear_has_h264_profile();
}
inline ::mt::EmH264Profile TMtCreateConfParam::h264_profile() const {
  return static_cast< ::mt::EmH264Profile >(h264_profile_);
}
inline void TMtCreateConfParam::set_h264_profile(::mt::EmH264Profile value) {
  assert(::mt::EmH264Profile_IsValid(value));
  set_has_h264_profile();
  h264_profile_ = value;
}

// optional .mt.EmMtResolution vid_res = 18;
inline bool TMtCreateConfParam::has_vid_res() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMtCreateConfParam::set_has_vid_res() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMtCreateConfParam::clear_has_vid_res() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMtCreateConfParam::clear_vid_res() {
  vid_res_ = 0;
  clear_has_vid_res();
}
inline ::mt::EmMtResolution TMtCreateConfParam::vid_res() const {
  return static_cast< ::mt::EmMtResolution >(vid_res_);
}
inline void TMtCreateConfParam::set_vid_res(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_vid_res();
  vid_res_ = value;
}

// optional uint32 vid_fps = 19;
inline bool TMtCreateConfParam::has_vid_fps() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMtCreateConfParam::set_has_vid_fps() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMtCreateConfParam::clear_has_vid_fps() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMtCreateConfParam::clear_vid_fps() {
  vid_fps_ = 0u;
  clear_has_vid_fps();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::vid_fps() const {
  return vid_fps_;
}
inline void TMtCreateConfParam::set_vid_fps(::google::protobuf::uint32 value) {
  set_has_vid_fps();
  vid_fps_ = value;
}

// optional .mt.EmVidFormat assvid_format = 20;
inline bool TMtCreateConfParam::has_assvid_format() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMtCreateConfParam::set_has_assvid_format() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMtCreateConfParam::clear_has_assvid_format() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMtCreateConfParam::clear_assvid_format() {
  assvid_format_ = 0;
  clear_has_assvid_format();
}
inline ::mt::EmVidFormat TMtCreateConfParam::assvid_format() const {
  return static_cast< ::mt::EmVidFormat >(assvid_format_);
}
inline void TMtCreateConfParam::set_assvid_format(::mt::EmVidFormat value) {
  assert(::mt::EmVidFormat_IsValid(value));
  set_has_assvid_format();
  assvid_format_ = value;
}

// optional .mt.EmMtResolution assvid_res = 21;
inline bool TMtCreateConfParam::has_assvid_res() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMtCreateConfParam::set_has_assvid_res() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMtCreateConfParam::clear_has_assvid_res() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMtCreateConfParam::clear_assvid_res() {
  assvid_res_ = 0;
  clear_has_assvid_res();
}
inline ::mt::EmMtResolution TMtCreateConfParam::assvid_res() const {
  return static_cast< ::mt::EmMtResolution >(assvid_res_);
}
inline void TMtCreateConfParam::set_assvid_res(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_assvid_res();
  assvid_res_ = value;
}

// optional uint32 assvid_fps = 22;
inline bool TMtCreateConfParam::has_assvid_fps() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMtCreateConfParam::set_has_assvid_fps() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMtCreateConfParam::clear_has_assvid_fps() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMtCreateConfParam::clear_assvid_fps() {
  assvid_fps_ = 0u;
  clear_has_assvid_fps();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::assvid_fps() const {
  return assvid_fps_;
}
inline void TMtCreateConfParam::set_assvid_fps(::google::protobuf::uint32 value) {
  set_has_assvid_fps();
  assvid_fps_ = value;
}

// optional .mt.EmAudFormat aud_format = 23;
inline bool TMtCreateConfParam::has_aud_format() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMtCreateConfParam::set_has_aud_format() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMtCreateConfParam::clear_has_aud_format() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMtCreateConfParam::clear_aud_format() {
  aud_format_ = 0;
  clear_has_aud_format();
}
inline ::mt::EmAudFormat TMtCreateConfParam::aud_format() const {
  return static_cast< ::mt::EmAudFormat >(aud_format_);
}
inline void TMtCreateConfParam::set_aud_format(::mt::EmAudFormat value) {
  assert(::mt::EmAudFormat_IsValid(value));
  set_has_aud_format();
  aud_format_ = value;
}

// optional .mt.EmAacChnlNum chnl_num = 24;
inline bool TMtCreateConfParam::has_chnl_num() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TMtCreateConfParam::set_has_chnl_num() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TMtCreateConfParam::clear_has_chnl_num() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TMtCreateConfParam::clear_chnl_num() {
  chnl_num_ = 0;
  clear_has_chnl_num();
}
inline ::mt::EmAacChnlNum TMtCreateConfParam::chnl_num() const {
  return static_cast< ::mt::EmAacChnlNum >(chnl_num_);
}
inline void TMtCreateConfParam::set_chnl_num(::mt::EmAacChnlNum value) {
  assert(::mt::EmAacChnlNum_IsValid(value));
  set_has_chnl_num();
  chnl_num_ = value;
}

// optional .mt.TMtAddr speaker = 25;
inline bool TMtCreateConfParam::has_speaker() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TMtCreateConfParam::set_has_speaker() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TMtCreateConfParam::clear_has_speaker() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TMtCreateConfParam::clear_speaker() {
  if (speaker_ != NULL) speaker_->::mt::TMtAddr::Clear();
  clear_has_speaker();
}
inline const ::mt::TMtAddr& TMtCreateConfParam::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::mt::TMtAddr* TMtCreateConfParam::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::mt::TMtAddr;
  return speaker_;
}
inline ::mt::TMtAddr* TMtCreateConfParam::release_speaker() {
  clear_has_speaker();
  ::mt::TMtAddr* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void TMtCreateConfParam::set_allocated_speaker(::mt::TMtAddr* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional uint32 calltimes = 26;
inline bool TMtCreateConfParam::has_calltimes() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TMtCreateConfParam::set_has_calltimes() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TMtCreateConfParam::clear_has_calltimes() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TMtCreateConfParam::clear_calltimes() {
  calltimes_ = 0u;
  clear_has_calltimes();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::calltimes() const {
  return calltimes_;
}
inline void TMtCreateConfParam::set_calltimes(::google::protobuf::uint32 value) {
  set_has_calltimes();
  calltimes_ = value;
}

// optional uint32 callinterval = 27;
inline bool TMtCreateConfParam::has_callinterval() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TMtCreateConfParam::set_has_callinterval() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TMtCreateConfParam::clear_has_callinterval() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TMtCreateConfParam::clear_callinterval() {
  callinterval_ = 0u;
  clear_has_callinterval();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::callinterval() const {
  return callinterval_;
}
inline void TMtCreateConfParam::set_callinterval(::google::protobuf::uint32 value) {
  set_has_callinterval();
  callinterval_ = value;
}

// optional bool is_callChase = 28;
inline bool TMtCreateConfParam::has_is_callchase() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TMtCreateConfParam::set_has_is_callchase() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TMtCreateConfParam::clear_has_is_callchase() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TMtCreateConfParam::clear_is_callchase() {
  is_callchase_ = false;
  clear_has_is_callchase();
}
inline bool TMtCreateConfParam::is_callchase() const {
  return is_callchase_;
}
inline void TMtCreateConfParam::set_is_callchase(bool value) {
  set_has_is_callchase();
  is_callchase_ = value;
}

// optional .mt.EmRestVideoQuality video_quality = 29;
inline bool TMtCreateConfParam::has_video_quality() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TMtCreateConfParam::set_has_video_quality() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TMtCreateConfParam::clear_has_video_quality() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TMtCreateConfParam::clear_video_quality() {
  video_quality_ = 0;
  clear_has_video_quality();
}
inline ::mt::EmRestVideoQuality TMtCreateConfParam::video_quality() const {
  return static_cast< ::mt::EmRestVideoQuality >(video_quality_);
}
inline void TMtCreateConfParam::set_video_quality(::mt::EmRestVideoQuality value) {
  assert(::mt::EmRestVideoQuality_IsValid(value));
  set_has_video_quality();
  video_quality_ = value;
}

// optional .mt.EmMtDualMode dual_mode = 30;
inline bool TMtCreateConfParam::has_dual_mode() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TMtCreateConfParam::set_has_dual_mode() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TMtCreateConfParam::clear_has_dual_mode() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TMtCreateConfParam::clear_dual_mode() {
  dual_mode_ = 0;
  clear_has_dual_mode();
}
inline ::mt::EmMtDualMode TMtCreateConfParam::dual_mode() const {
  return static_cast< ::mt::EmMtDualMode >(dual_mode_);
}
inline void TMtCreateConfParam::set_dual_mode(::mt::EmMtDualMode value) {
  assert(::mt::EmMtDualMode_IsValid(value));
  set_has_dual_mode();
  dual_mode_ = value;
}

// optional uint32 cascademode = 31;
inline bool TMtCreateConfParam::has_cascademode() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TMtCreateConfParam::set_has_cascademode() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TMtCreateConfParam::clear_has_cascademode() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TMtCreateConfParam::clear_cascademode() {
  cascademode_ = 0u;
  clear_has_cascademode();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::cascademode() const {
  return cascademode_;
}
inline void TMtCreateConfParam::set_cascademode(::google::protobuf::uint32 value) {
  set_has_cascademode();
  cascademode_ = value;
}

// optional bool is_cascadeupload = 32;
inline bool TMtCreateConfParam::has_is_cascadeupload() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TMtCreateConfParam::set_has_is_cascadeupload() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TMtCreateConfParam::clear_has_is_cascadeupload() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TMtCreateConfParam::clear_is_cascadeupload() {
  is_cascadeupload_ = false;
  clear_has_is_cascadeupload();
}
inline bool TMtCreateConfParam::is_cascadeupload() const {
  return is_cascadeupload_;
}
inline void TMtCreateConfParam::set_is_cascadeupload(bool value) {
  set_has_is_cascadeupload();
  is_cascadeupload_ = value;
}

// optional bool is_cascadereturn = 33;
inline bool TMtCreateConfParam::has_is_cascadereturn() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TMtCreateConfParam::set_has_is_cascadereturn() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TMtCreateConfParam::clear_has_is_cascadereturn() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TMtCreateConfParam::clear_is_cascadereturn() {
  is_cascadereturn_ = false;
  clear_has_is_cascadereturn();
}
inline bool TMtCreateConfParam::is_cascadereturn() const {
  return is_cascadereturn_;
}
inline void TMtCreateConfParam::set_is_cascadereturn(bool value) {
  set_has_is_cascadereturn();
  is_cascadereturn_ = value;
}

// optional uint32 cascadereturnpara = 34;
inline bool TMtCreateConfParam::has_cascadereturnpara() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TMtCreateConfParam::set_has_cascadereturnpara() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TMtCreateConfParam::clear_has_cascadereturnpara() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TMtCreateConfParam::clear_cascadereturnpara() {
  cascadereturnpara_ = 0u;
  clear_has_cascadereturnpara();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::cascadereturnpara() const {
  return cascadereturnpara_;
}
inline void TMtCreateConfParam::set_cascadereturnpara(::google::protobuf::uint32 value) {
  set_has_cascadereturnpara();
  cascadereturnpara_ = value;
}

// optional .mt.TNetAddr multicastaddr = 35;
inline bool TMtCreateConfParam::has_multicastaddr() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TMtCreateConfParam::set_has_multicastaddr() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TMtCreateConfParam::clear_has_multicastaddr() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TMtCreateConfParam::clear_multicastaddr() {
  if (multicastaddr_ != NULL) multicastaddr_->::mt::TNetAddr::Clear();
  clear_has_multicastaddr();
}
inline const ::mt::TNetAddr& TMtCreateConfParam::multicastaddr() const {
  return multicastaddr_ != NULL ? *multicastaddr_ : *default_instance_->multicastaddr_;
}
inline ::mt::TNetAddr* TMtCreateConfParam::mutable_multicastaddr() {
  set_has_multicastaddr();
  if (multicastaddr_ == NULL) multicastaddr_ = new ::mt::TNetAddr;
  return multicastaddr_;
}
inline ::mt::TNetAddr* TMtCreateConfParam::release_multicastaddr() {
  clear_has_multicastaddr();
  ::mt::TNetAddr* temp = multicastaddr_;
  multicastaddr_ = NULL;
  return temp;
}
inline void TMtCreateConfParam::set_allocated_multicastaddr(::mt::TNetAddr* multicastaddr) {
  delete multicastaddr_;
  multicastaddr_ = multicastaddr;
  if (multicastaddr) {
    set_has_multicastaddr();
  } else {
    clear_has_multicastaddr();
  }
}

// optional bool is_multicastenable = 36;
inline bool TMtCreateConfParam::has_is_multicastenable() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TMtCreateConfParam::set_has_is_multicastenable() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TMtCreateConfParam::clear_has_is_multicastenable() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TMtCreateConfParam::clear_is_multicastenable() {
  is_multicastenable_ = false;
  clear_has_is_multicastenable();
}
inline bool TMtCreateConfParam::is_multicastenable() const {
  return is_multicastenable_;
}
inline void TMtCreateConfParam::set_is_multicastenable(bool value) {
  set_has_is_multicastenable();
  is_multicastenable_ = value;
}

// repeated uint32 vip_list = 37;
inline int TMtCreateConfParam::vip_list_size() const {
  return vip_list_.size();
}
inline void TMtCreateConfParam::clear_vip_list() {
  vip_list_.Clear();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::vip_list(int index) const {
  return vip_list_.Get(index);
}
inline void TMtCreateConfParam::set_vip_list(int index, ::google::protobuf::uint32 value) {
  vip_list_.Set(index, value);
}
inline void TMtCreateConfParam::add_vip_list(::google::protobuf::uint32 value) {
  vip_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TMtCreateConfParam::vip_list() const {
  return vip_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TMtCreateConfParam::mutable_vip_list() {
  return &vip_list_;
}

// repeated uint32 call_chaselist = 38;
inline int TMtCreateConfParam::call_chaselist_size() const {
  return call_chaselist_.size();
}
inline void TMtCreateConfParam::clear_call_chaselist() {
  call_chaselist_.Clear();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::call_chaselist(int index) const {
  return call_chaselist_.Get(index);
}
inline void TMtCreateConfParam::set_call_chaselist(int index, ::google::protobuf::uint32 value) {
  call_chaselist_.Set(index, value);
}
inline void TMtCreateConfParam::add_call_chaselist(::google::protobuf::uint32 value) {
  call_chaselist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TMtCreateConfParam::call_chaselist() const {
  return call_chaselist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TMtCreateConfParam::mutable_call_chaselist() {
  return &call_chaselist_;
}

// optional .mt.TMtMiniPollInfo poll_Info = 39;
inline bool TMtCreateConfParam::has_poll_info() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void TMtCreateConfParam::set_has_poll_info() {
  _has_bits_[1] |= 0x00000040u;
}
inline void TMtCreateConfParam::clear_has_poll_info() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void TMtCreateConfParam::clear_poll_info() {
  if (poll_info_ != NULL) poll_info_->::mt::TMtMiniPollInfo::Clear();
  clear_has_poll_info();
}
inline const ::mt::TMtMiniPollInfo& TMtCreateConfParam::poll_info() const {
  return poll_info_ != NULL ? *poll_info_ : *default_instance_->poll_info_;
}
inline ::mt::TMtMiniPollInfo* TMtCreateConfParam::mutable_poll_info() {
  set_has_poll_info();
  if (poll_info_ == NULL) poll_info_ = new ::mt::TMtMiniPollInfo;
  return poll_info_;
}
inline ::mt::TMtMiniPollInfo* TMtCreateConfParam::release_poll_info() {
  clear_has_poll_info();
  ::mt::TMtMiniPollInfo* temp = poll_info_;
  poll_info_ = NULL;
  return temp;
}
inline void TMtCreateConfParam::set_allocated_poll_info(::mt::TMtMiniPollInfo* poll_info) {
  delete poll_info_;
  poll_info_ = poll_info;
  if (poll_info) {
    set_has_poll_info();
  } else {
    clear_has_poll_info();
  }
}

// optional .mt.TMtMiniVmpParam vmp_param = 40;
inline bool TMtCreateConfParam::has_vmp_param() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void TMtCreateConfParam::set_has_vmp_param() {
  _has_bits_[1] |= 0x00000080u;
}
inline void TMtCreateConfParam::clear_has_vmp_param() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void TMtCreateConfParam::clear_vmp_param() {
  if (vmp_param_ != NULL) vmp_param_->::mt::TMtMiniVmpParam::Clear();
  clear_has_vmp_param();
}
inline const ::mt::TMtMiniVmpParam& TMtCreateConfParam::vmp_param() const {
  return vmp_param_ != NULL ? *vmp_param_ : *default_instance_->vmp_param_;
}
inline ::mt::TMtMiniVmpParam* TMtCreateConfParam::mutable_vmp_param() {
  set_has_vmp_param();
  if (vmp_param_ == NULL) vmp_param_ = new ::mt::TMtMiniVmpParam;
  return vmp_param_;
}
inline ::mt::TMtMiniVmpParam* TMtCreateConfParam::release_vmp_param() {
  clear_has_vmp_param();
  ::mt::TMtMiniVmpParam* temp = vmp_param_;
  vmp_param_ = NULL;
  return temp;
}
inline void TMtCreateConfParam::set_allocated_vmp_param(::mt::TMtMiniVmpParam* vmp_param) {
  delete vmp_param_;
  vmp_param_ = vmp_param;
  if (vmp_param) {
    set_has_vmp_param();
  } else {
    clear_has_vmp_param();
  }
}

// optional .mt.EmMtMixType mix_mode = 41;
inline bool TMtCreateConfParam::has_mix_mode() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void TMtCreateConfParam::set_has_mix_mode() {
  _has_bits_[1] |= 0x00000100u;
}
inline void TMtCreateConfParam::clear_has_mix_mode() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void TMtCreateConfParam::clear_mix_mode() {
  mix_mode_ = 0;
  clear_has_mix_mode();
}
inline ::mt::EmMtMixType TMtCreateConfParam::mix_mode() const {
  return static_cast< ::mt::EmMtMixType >(mix_mode_);
}
inline void TMtCreateConfParam::set_mix_mode(::mt::EmMtMixType value) {
  assert(::mt::EmMtMixType_IsValid(value));
  set_has_mix_mode();
  mix_mode_ = value;
}

// repeated uint32 mix_list = 42;
inline int TMtCreateConfParam::mix_list_size() const {
  return mix_list_.size();
}
inline void TMtCreateConfParam::clear_mix_list() {
  mix_list_.Clear();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::mix_list(int index) const {
  return mix_list_.Get(index);
}
inline void TMtCreateConfParam::set_mix_list(int index, ::google::protobuf::uint32 value) {
  mix_list_.Set(index, value);
}
inline void TMtCreateConfParam::add_mix_list(::google::protobuf::uint32 value) {
  mix_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TMtCreateConfParam::mix_list() const {
  return mix_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TMtCreateConfParam::mutable_mix_list() {
  return &mix_list_;
}

// optional .mt.TRpMtAddr mt_list = 43;
inline bool TMtCreateConfParam::has_mt_list() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void TMtCreateConfParam::set_has_mt_list() {
  _has_bits_[1] |= 0x00000400u;
}
inline void TMtCreateConfParam::clear_has_mt_list() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void TMtCreateConfParam::clear_mt_list() {
  if (mt_list_ != NULL) mt_list_->::mt::TRpMtAddr::Clear();
  clear_has_mt_list();
}
inline const ::mt::TRpMtAddr& TMtCreateConfParam::mt_list() const {
  return mt_list_ != NULL ? *mt_list_ : *default_instance_->mt_list_;
}
inline ::mt::TRpMtAddr* TMtCreateConfParam::mutable_mt_list() {
  set_has_mt_list();
  if (mt_list_ == NULL) mt_list_ = new ::mt::TRpMtAddr;
  return mt_list_;
}
inline ::mt::TRpMtAddr* TMtCreateConfParam::release_mt_list() {
  clear_has_mt_list();
  ::mt::TRpMtAddr* temp = mt_list_;
  mt_list_ = NULL;
  return temp;
}
inline void TMtCreateConfParam::set_allocated_mt_list(::mt::TRpMtAddr* mt_list) {
  delete mt_list_;
  mt_list_ = mt_list;
  if (mt_list) {
    set_has_mt_list();
  } else {
    clear_has_mt_list();
  }
}

// optional .mt.TMtAddr chairman = 44;
inline bool TMtCreateConfParam::has_chairman() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void TMtCreateConfParam::set_has_chairman() {
  _has_bits_[1] |= 0x00000800u;
}
inline void TMtCreateConfParam::clear_has_chairman() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void TMtCreateConfParam::clear_chairman() {
  if (chairman_ != NULL) chairman_->::mt::TMtAddr::Clear();
  clear_has_chairman();
}
inline const ::mt::TMtAddr& TMtCreateConfParam::chairman() const {
  return chairman_ != NULL ? *chairman_ : *default_instance_->chairman_;
}
inline ::mt::TMtAddr* TMtCreateConfParam::mutable_chairman() {
  set_has_chairman();
  if (chairman_ == NULL) chairman_ = new ::mt::TMtAddr;
  return chairman_;
}
inline ::mt::TMtAddr* TMtCreateConfParam::release_chairman() {
  clear_has_chairman();
  ::mt::TMtAddr* temp = chairman_;
  chairman_ = NULL;
  return temp;
}
inline void TMtCreateConfParam::set_allocated_chairman(::mt::TMtAddr* chairman) {
  delete chairman_;
  chairman_ = chairman;
  if (chairman) {
    set_has_chairman();
  } else {
    clear_has_chairman();
  }
}

// optional .mt.TMtAutorecattrb autorecord = 45;
inline bool TMtCreateConfParam::has_autorecord() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void TMtCreateConfParam::set_has_autorecord() {
  _has_bits_[1] |= 0x00001000u;
}
inline void TMtCreateConfParam::clear_has_autorecord() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void TMtCreateConfParam::clear_autorecord() {
  if (autorecord_ != NULL) autorecord_->::mt::TMtAutorecattrb::Clear();
  clear_has_autorecord();
}
inline const ::mt::TMtAutorecattrb& TMtCreateConfParam::autorecord() const {
  return autorecord_ != NULL ? *autorecord_ : *default_instance_->autorecord_;
}
inline ::mt::TMtAutorecattrb* TMtCreateConfParam::mutable_autorecord() {
  set_has_autorecord();
  if (autorecord_ == NULL) autorecord_ = new ::mt::TMtAutorecattrb;
  return autorecord_;
}
inline ::mt::TMtAutorecattrb* TMtCreateConfParam::release_autorecord() {
  clear_has_autorecord();
  ::mt::TMtAutorecattrb* temp = autorecord_;
  autorecord_ = NULL;
  return temp;
}
inline void TMtCreateConfParam::set_allocated_autorecord(::mt::TMtAutorecattrb* autorecord) {
  delete autorecord_;
  autorecord_ = autorecord;
  if (autorecord) {
    set_has_autorecord();
  } else {
    clear_has_autorecord();
  }
}

// optional uint32 mix_vacinterval = 46;
inline bool TMtCreateConfParam::has_mix_vacinterval() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void TMtCreateConfParam::set_has_mix_vacinterval() {
  _has_bits_[1] |= 0x00002000u;
}
inline void TMtCreateConfParam::clear_has_mix_vacinterval() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void TMtCreateConfParam::clear_mix_vacinterval() {
  mix_vacinterval_ = 0u;
  clear_has_mix_vacinterval();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::mix_vacinterval() const {
  return mix_vacinterval_;
}
inline void TMtCreateConfParam::set_mix_vacinterval(::google::protobuf::uint32 value) {
  set_has_mix_vacinterval();
  mix_vacinterval_ = value;
}

// optional bool is_onereforming = 47;
inline bool TMtCreateConfParam::has_is_onereforming() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void TMtCreateConfParam::set_has_is_onereforming() {
  _has_bits_[1] |= 0x00004000u;
}
inline void TMtCreateConfParam::clear_has_is_onereforming() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void TMtCreateConfParam::clear_is_onereforming() {
  is_onereforming_ = false;
  clear_has_is_onereforming();
}
inline bool TMtCreateConfParam::is_onereforming() const {
  return is_onereforming_;
}
inline void TMtCreateConfParam::set_is_onereforming(bool value) {
  set_has_is_onereforming();
  is_onereforming_ = value;
}

// optional string conf_e164 = 48;
inline bool TMtCreateConfParam::has_conf_e164() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void TMtCreateConfParam::set_has_conf_e164() {
  _has_bits_[1] |= 0x00008000u;
}
inline void TMtCreateConfParam::clear_has_conf_e164() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void TMtCreateConfParam::clear_conf_e164() {
  if (conf_e164_ != &::google::protobuf::internal::kEmptyString) {
    conf_e164_->clear();
  }
  clear_has_conf_e164();
}
inline const ::std::string& TMtCreateConfParam::conf_e164() const {
  return *conf_e164_;
}
inline void TMtCreateConfParam::set_conf_e164(const ::std::string& value) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(value);
}
inline void TMtCreateConfParam::set_conf_e164(const char* value) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(value);
}
inline void TMtCreateConfParam::set_conf_e164(const char* value, size_t size) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCreateConfParam::mutable_conf_e164() {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  return conf_e164_;
}
inline ::std::string* TMtCreateConfParam::release_conf_e164() {
  clear_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_e164_;
    conf_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCreateConfParam::set_allocated_conf_e164(::std::string* conf_e164) {
  if (conf_e164_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_e164_;
  }
  if (conf_e164) {
    set_has_conf_e164();
    conf_e164_ = conf_e164;
  } else {
    clear_has_conf_e164();
    conf_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 max_joined_mt = 49;
inline bool TMtCreateConfParam::has_max_joined_mt() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void TMtCreateConfParam::set_has_max_joined_mt() {
  _has_bits_[1] |= 0x00010000u;
}
inline void TMtCreateConfParam::clear_has_max_joined_mt() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void TMtCreateConfParam::clear_max_joined_mt() {
  max_joined_mt_ = 0u;
  clear_has_max_joined_mt();
}
inline ::google::protobuf::uint32 TMtCreateConfParam::max_joined_mt() const {
  return max_joined_mt_;
}
inline void TMtCreateConfParam::set_max_joined_mt(::google::protobuf::uint32 value) {
  set_has_max_joined_mt();
  max_joined_mt_ = value;
}

// -------------------------------------------------------------------

// TMtAutorecattrb

// optional bool autorec = 1;
inline bool TMtAutorecattrb::has_autorec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAutorecattrb::set_has_autorec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAutorecattrb::clear_has_autorec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAutorecattrb::clear_autorec() {
  autorec_ = false;
  clear_has_autorec();
}
inline bool TMtAutorecattrb::autorec() const {
  return autorec_;
}
inline void TMtAutorecattrb::set_autorec(bool value) {
  set_has_autorec();
  autorec_ = value;
}

// optional uint32 publishmode = 2;
inline bool TMtAutorecattrb::has_publishmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAutorecattrb::set_has_publishmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAutorecattrb::clear_has_publishmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAutorecattrb::clear_publishmode() {
  publishmode_ = 0u;
  clear_has_publishmode();
}
inline ::google::protobuf::uint32 TMtAutorecattrb::publishmode() const {
  return publishmode_;
}
inline void TMtAutorecattrb::set_publishmode(::google::protobuf::uint32 value) {
  set_has_publishmode();
  publishmode_ = value;
}

// optional bool isrecmainvideo = 3;
inline bool TMtAutorecattrb::has_isrecmainvideo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtAutorecattrb::set_has_isrecmainvideo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtAutorecattrb::clear_has_isrecmainvideo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtAutorecattrb::clear_isrecmainvideo() {
  isrecmainvideo_ = false;
  clear_has_isrecmainvideo();
}
inline bool TMtAutorecattrb::isrecmainvideo() const {
  return isrecmainvideo_;
}
inline void TMtAutorecattrb::set_isrecmainvideo(bool value) {
  set_has_isrecmainvideo();
  isrecmainvideo_ = value;
}

// optional bool isrecdstream = 4;
inline bool TMtAutorecattrb::has_isrecdstream() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtAutorecattrb::set_has_isrecdstream() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtAutorecattrb::clear_has_isrecdstream() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtAutorecattrb::clear_isrecdstream() {
  isrecdstream_ = false;
  clear_has_isrecdstream();
}
inline bool TMtAutorecattrb::isrecdstream() const {
  return isrecdstream_;
}
inline void TMtAutorecattrb::set_isrecdstream(bool value) {
  set_has_isrecdstream();
  isrecdstream_ = value;
}

// optional .mt.TMtVrsalias vrsalias = 5;
inline bool TMtAutorecattrb::has_vrsalias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtAutorecattrb::set_has_vrsalias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtAutorecattrb::clear_has_vrsalias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtAutorecattrb::clear_vrsalias() {
  if (vrsalias_ != NULL) vrsalias_->::mt::TMtVrsalias::Clear();
  clear_has_vrsalias();
}
inline const ::mt::TMtVrsalias& TMtAutorecattrb::vrsalias() const {
  return vrsalias_ != NULL ? *vrsalias_ : *default_instance_->vrsalias_;
}
inline ::mt::TMtVrsalias* TMtAutorecattrb::mutable_vrsalias() {
  set_has_vrsalias();
  if (vrsalias_ == NULL) vrsalias_ = new ::mt::TMtVrsalias;
  return vrsalias_;
}
inline ::mt::TMtVrsalias* TMtAutorecattrb::release_vrsalias() {
  clear_has_vrsalias();
  ::mt::TMtVrsalias* temp = vrsalias_;
  vrsalias_ = NULL;
  return temp;
}
inline void TMtAutorecattrb::set_allocated_vrsalias(::mt::TMtVrsalias* vrsalias) {
  delete vrsalias_;
  vrsalias_ = vrsalias;
  if (vrsalias) {
    set_has_vrsalias();
  } else {
    clear_has_vrsalias();
  }
}

// -------------------------------------------------------------------

// TMtVrsalias

// optional uint32 aliastype = 1;
inline bool TMtVrsalias::has_aliastype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtVrsalias::set_has_aliastype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtVrsalias::clear_has_aliastype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtVrsalias::clear_aliastype() {
  aliastype_ = 0u;
  clear_has_aliastype();
}
inline ::google::protobuf::uint32 TMtVrsalias::aliastype() const {
  return aliastype_;
}
inline void TMtVrsalias::set_aliastype(::google::protobuf::uint32 value) {
  set_has_aliastype();
  aliastype_ = value;
}

// optional string addr = 2;
inline bool TMtVrsalias::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtVrsalias::set_has_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtVrsalias::clear_has_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtVrsalias::clear_addr() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    addr_->clear();
  }
  clear_has_addr();
}
inline const ::std::string& TMtVrsalias::addr() const {
  return *addr_;
}
inline void TMtVrsalias::set_addr(const ::std::string& value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void TMtVrsalias::set_addr(const char* value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void TMtVrsalias::set_addr(const char* value, size_t size) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVrsalias::mutable_addr() {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  return addr_;
}
inline ::std::string* TMtVrsalias::release_addr() {
  clear_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_;
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVrsalias::set_allocated_addr(::std::string* addr) {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    delete addr_;
  }
  if (addr) {
    set_has_addr();
    addr_ = addr;
  } else {
    clear_has_addr();
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string vrsno = 3;
inline bool TMtVrsalias::has_vrsno() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtVrsalias::set_has_vrsno() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtVrsalias::clear_has_vrsno() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtVrsalias::clear_vrsno() {
  if (vrsno_ != &::google::protobuf::internal::kEmptyString) {
    vrsno_->clear();
  }
  clear_has_vrsno();
}
inline const ::std::string& TMtVrsalias::vrsno() const {
  return *vrsno_;
}
inline void TMtVrsalias::set_vrsno(const ::std::string& value) {
  set_has_vrsno();
  if (vrsno_ == &::google::protobuf::internal::kEmptyString) {
    vrsno_ = new ::std::string;
  }
  vrsno_->assign(value);
}
inline void TMtVrsalias::set_vrsno(const char* value) {
  set_has_vrsno();
  if (vrsno_ == &::google::protobuf::internal::kEmptyString) {
    vrsno_ = new ::std::string;
  }
  vrsno_->assign(value);
}
inline void TMtVrsalias::set_vrsno(const char* value, size_t size) {
  set_has_vrsno();
  if (vrsno_ == &::google::protobuf::internal::kEmptyString) {
    vrsno_ = new ::std::string;
  }
  vrsno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVrsalias::mutable_vrsno() {
  set_has_vrsno();
  if (vrsno_ == &::google::protobuf::internal::kEmptyString) {
    vrsno_ = new ::std::string;
  }
  return vrsno_;
}
inline ::std::string* TMtVrsalias::release_vrsno() {
  clear_has_vrsno();
  if (vrsno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vrsno_;
    vrsno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVrsalias::set_allocated_vrsno(::std::string* vrsno) {
  if (vrsno_ != &::google::protobuf::internal::kEmptyString) {
    delete vrsno_;
  }
  if (vrsno) {
    set_has_vrsno();
    vrsno_ = vrsno;
  } else {
    clear_has_vrsno();
    vrsno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtMiniPollInfo

// optional .mt.EmMtPollModeDef media_mode = 1;
inline bool TMtMiniPollInfo::has_media_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtMiniPollInfo::set_has_media_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtMiniPollInfo::clear_has_media_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtMiniPollInfo::clear_media_mode() {
  media_mode_ = 0;
  clear_has_media_mode();
}
inline ::mt::EmMtPollModeDef TMtMiniPollInfo::media_mode() const {
  return static_cast< ::mt::EmMtPollModeDef >(media_mode_);
}
inline void TMtMiniPollInfo::set_media_mode(::mt::EmMtPollModeDef value) {
  assert(::mt::EmMtPollModeDef_IsValid(value));
  set_has_media_mode();
  media_mode_ = value;
}

// optional uint32 keep_time = 2;
inline bool TMtMiniPollInfo::has_keep_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtMiniPollInfo::set_has_keep_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtMiniPollInfo::clear_has_keep_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtMiniPollInfo::clear_keep_time() {
  keep_time_ = 0u;
  clear_has_keep_time();
}
inline ::google::protobuf::uint32 TMtMiniPollInfo::keep_time() const {
  return keep_time_;
}
inline void TMtMiniPollInfo::set_keep_time(::google::protobuf::uint32 value) {
  set_has_keep_time();
  keep_time_ = value;
}

// optional uint32 poll_num = 3;
inline bool TMtMiniPollInfo::has_poll_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtMiniPollInfo::set_has_poll_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtMiniPollInfo::clear_has_poll_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtMiniPollInfo::clear_poll_num() {
  poll_num_ = 0u;
  clear_has_poll_num();
}
inline ::google::protobuf::uint32 TMtMiniPollInfo::poll_num() const {
  return poll_num_;
}
inline void TMtMiniPollInfo::set_poll_num(::google::protobuf::uint32 value) {
  set_has_poll_num();
  poll_num_ = value;
}

// repeated uint32 poll_mt = 4;
inline int TMtMiniPollInfo::poll_mt_size() const {
  return poll_mt_.size();
}
inline void TMtMiniPollInfo::clear_poll_mt() {
  poll_mt_.Clear();
}
inline ::google::protobuf::uint32 TMtMiniPollInfo::poll_mt(int index) const {
  return poll_mt_.Get(index);
}
inline void TMtMiniPollInfo::set_poll_mt(int index, ::google::protobuf::uint32 value) {
  poll_mt_.Set(index, value);
}
inline void TMtMiniPollInfo::add_poll_mt(::google::protobuf::uint32 value) {
  poll_mt_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TMtMiniPollInfo::poll_mt() const {
  return poll_mt_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TMtMiniPollInfo::mutable_poll_mt() {
  return &poll_mt_;
}

// -------------------------------------------------------------------

// TMtMiniVmpParam

// optional bool is_vmp_brdst = 2;
inline bool TMtMiniVmpParam::has_is_vmp_brdst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtMiniVmpParam::set_has_is_vmp_brdst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtMiniVmpParam::clear_has_is_vmp_brdst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtMiniVmpParam::clear_is_vmp_brdst() {
  is_vmp_brdst_ = false;
  clear_has_is_vmp_brdst();
}
inline bool TMtMiniVmpParam::is_vmp_brdst() const {
  return is_vmp_brdst_;
}
inline void TMtMiniVmpParam::set_is_vmp_brdst(bool value) {
  set_has_is_vmp_brdst();
  is_vmp_brdst_ = value;
}

// optional .mt.EmMtVmpStyle vmp_style = 3;
inline bool TMtMiniVmpParam::has_vmp_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtMiniVmpParam::set_has_vmp_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtMiniVmpParam::clear_has_vmp_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtMiniVmpParam::clear_vmp_style() {
  vmp_style_ = 0;
  clear_has_vmp_style();
}
inline ::mt::EmMtVmpStyle TMtMiniVmpParam::vmp_style() const {
  return static_cast< ::mt::EmMtVmpStyle >(vmp_style_);
}
inline void TMtMiniVmpParam::set_vmp_style(::mt::EmMtVmpStyle value) {
  assert(::mt::EmMtVmpStyle_IsValid(value));
  set_has_vmp_style();
  vmp_style_ = value;
}

// optional .mt.EmMtVmpMode vmp_mode = 5;
inline bool TMtMiniVmpParam::has_vmp_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtMiniVmpParam::set_has_vmp_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtMiniVmpParam::clear_has_vmp_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtMiniVmpParam::clear_vmp_mode() {
  vmp_mode_ = 0;
  clear_has_vmp_mode();
}
inline ::mt::EmMtVmpMode TMtMiniVmpParam::vmp_mode() const {
  return static_cast< ::mt::EmMtVmpMode >(vmp_mode_);
}
inline void TMtMiniVmpParam::set_vmp_mode(::mt::EmMtVmpMode value) {
  assert(::mt::EmMtVmpMode_IsValid(value));
  set_has_vmp_mode();
  vmp_mode_ = value;
}

// optional bool is_rim_enabled = 6;
inline bool TMtMiniVmpParam::has_is_rim_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtMiniVmpParam::set_has_is_rim_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtMiniVmpParam::clear_has_is_rim_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtMiniVmpParam::clear_is_rim_enabled() {
  is_rim_enabled_ = false;
  clear_has_is_rim_enabled();
}
inline bool TMtMiniVmpParam::is_rim_enabled() const {
  return is_rim_enabled_;
}
inline void TMtMiniVmpParam::set_is_rim_enabled(bool value) {
  set_has_is_rim_enabled();
  is_rim_enabled_ = value;
}

// optional bool is_add_mmbalias = 7;
inline bool TMtMiniVmpParam::has_is_add_mmbalias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtMiniVmpParam::set_has_is_add_mmbalias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtMiniVmpParam::clear_has_is_add_mmbalias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtMiniVmpParam::clear_is_add_mmbalias() {
  is_add_mmbalias_ = false;
  clear_has_is_add_mmbalias();
}
inline bool TMtMiniVmpParam::is_add_mmbalias() const {
  return is_add_mmbalias_;
}
inline void TMtMiniVmpParam::set_is_add_mmbalias(bool value) {
  set_has_is_add_mmbalias();
  is_add_mmbalias_ = value;
}

// optional bool is_vmp_batch_poll = 8;
inline bool TMtMiniVmpParam::has_is_vmp_batch_poll() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtMiniVmpParam::set_has_is_vmp_batch_poll() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtMiniVmpParam::clear_has_is_vmp_batch_poll() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtMiniVmpParam::clear_is_vmp_batch_poll() {
  is_vmp_batch_poll_ = false;
  clear_has_is_vmp_batch_poll();
}
inline bool TMtMiniVmpParam::is_vmp_batch_poll() const {
  return is_vmp_batch_poll_;
}
inline void TMtMiniVmpParam::set_is_vmp_batch_poll(bool value) {
  set_has_is_vmp_batch_poll();
  is_vmp_batch_poll_ = value;
}

// optional uint32 keep_poll_time = 9;
inline bool TMtMiniVmpParam::has_keep_poll_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtMiniVmpParam::set_has_keep_poll_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtMiniVmpParam::clear_has_keep_poll_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtMiniVmpParam::clear_keep_poll_time() {
  keep_poll_time_ = 0u;
  clear_has_keep_poll_time();
}
inline ::google::protobuf::uint32 TMtMiniVmpParam::keep_poll_time() const {
  return keep_poll_time_;
}
inline void TMtMiniVmpParam::set_keep_poll_time(::google::protobuf::uint32 value) {
  set_has_keep_poll_time();
  keep_poll_time_ = value;
}

// optional uint32 poll_num = 10;
inline bool TMtMiniVmpParam::has_poll_num() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtMiniVmpParam::set_has_poll_num() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtMiniVmpParam::clear_has_poll_num() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtMiniVmpParam::clear_poll_num() {
  poll_num_ = 0u;
  clear_has_poll_num();
}
inline ::google::protobuf::uint32 TMtMiniVmpParam::poll_num() const {
  return poll_num_;
}
inline void TMtMiniVmpParam::set_poll_num(::google::protobuf::uint32 value) {
  set_has_poll_num();
  poll_num_ = value;
}

// repeated .mt.TMtMiniVMPMember vmp_member = 11;
inline int TMtMiniVmpParam::vmp_member_size() const {
  return vmp_member_.size();
}
inline void TMtMiniVmpParam::clear_vmp_member() {
  vmp_member_.Clear();
}
inline const ::mt::TMtMiniVMPMember& TMtMiniVmpParam::vmp_member(int index) const {
  return vmp_member_.Get(index);
}
inline ::mt::TMtMiniVMPMember* TMtMiniVmpParam::mutable_vmp_member(int index) {
  return vmp_member_.Mutable(index);
}
inline ::mt::TMtMiniVMPMember* TMtMiniVmpParam::add_vmp_member() {
  return vmp_member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtMiniVMPMember >&
TMtMiniVmpParam::vmp_member() const {
  return vmp_member_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtMiniVMPMember >*
TMtMiniVmpParam::mutable_vmp_member() {
  return &vmp_member_;
}

// optional bool is_voice_hint = 12;
inline bool TMtMiniVmpParam::has_is_voice_hint() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMtMiniVmpParam::set_has_is_voice_hint() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMtMiniVmpParam::clear_has_is_voice_hint() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMtMiniVmpParam::clear_is_voice_hint() {
  is_voice_hint_ = false;
  clear_has_is_voice_hint();
}
inline bool TMtMiniVmpParam::is_voice_hint() const {
  return is_voice_hint_;
}
inline void TMtMiniVmpParam::set_is_voice_hint(bool value) {
  set_has_is_voice_hint();
  is_voice_hint_ = value;
}

// -------------------------------------------------------------------

// TMtMiniVMPMember

// optional uint32 member = 1;
inline bool TMtMiniVMPMember::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtMiniVMPMember::set_has_member() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtMiniVMPMember::clear_has_member() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtMiniVMPMember::clear_member() {
  member_ = 0u;
  clear_has_member();
}
inline ::google::protobuf::uint32 TMtMiniVMPMember::member() const {
  return member_;
}
inline void TMtMiniVMPMember::set_member(::google::protobuf::uint32 value) {
  set_has_member();
  member_ = value;
}

// optional .mt.EmMtVMPMmbType member_type = 2;
inline bool TMtMiniVMPMember::has_member_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtMiniVMPMember::set_has_member_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtMiniVMPMember::clear_has_member_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtMiniVMPMember::clear_member_type() {
  member_type_ = 0;
  clear_has_member_type();
}
inline ::mt::EmMtVMPMmbType TMtMiniVMPMember::member_type() const {
  return static_cast< ::mt::EmMtVMPMmbType >(member_type_);
}
inline void TMtMiniVMPMember::set_member_type(::mt::EmMtVMPMmbType value) {
  assert(::mt::EmMtVMPMmbType_IsValid(value));
  set_has_member_type();
  member_type_ = value;
}

// optional .mt.EmMtMemberStatusDef member_status = 3;
inline bool TMtMiniVMPMember::has_member_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtMiniVMPMember::set_has_member_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtMiniVMPMember::clear_has_member_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtMiniVMPMember::clear_member_status() {
  member_status_ = 0;
  clear_has_member_status();
}
inline ::mt::EmMtMemberStatusDef TMtMiniVMPMember::member_status() const {
  return static_cast< ::mt::EmMtMemberStatusDef >(member_status_);
}
inline void TMtMiniVMPMember::set_member_status(::mt::EmMtMemberStatusDef value) {
  assert(::mt::EmMtMemberStatusDef_IsValid(value));
  set_has_member_status();
  member_status_ = value;
}

// optional uint32 chnnl_index = 4;
inline bool TMtMiniVMPMember::has_chnnl_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtMiniVMPMember::set_has_chnnl_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtMiniVMPMember::clear_has_chnnl_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtMiniVMPMember::clear_chnnl_index() {
  chnnl_index_ = 0u;
  clear_has_chnnl_index();
}
inline ::google::protobuf::uint32 TMtMiniVMPMember::chnnl_index() const {
  return chnnl_index_;
}
inline void TMtMiniVMPMember::set_chnnl_index(::google::protobuf::uint32 value) {
  set_has_chnnl_index();
  chnnl_index_ = value;
}

// optional uint32 mem_index = 5;
inline bool TMtMiniVMPMember::has_mem_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtMiniVMPMember::set_has_mem_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtMiniVMPMember::clear_has_mem_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtMiniVMPMember::clear_mem_index() {
  mem_index_ = 0u;
  clear_has_mem_index();
}
inline ::google::protobuf::uint32 TMtMiniVMPMember::mem_index() const {
  return mem_index_;
}
inline void TMtMiniVMPMember::set_mem_index(::google::protobuf::uint32 value) {
  set_has_mem_index();
  mem_index_ = value;
}

// -------------------------------------------------------------------

// TMtCallParam

// optional .mt.EmMtCallMode call_type = 1;
inline bool TMtCallParam::has_call_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtCallParam::set_has_call_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtCallParam::clear_has_call_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtCallParam::clear_call_type() {
  call_type_ = 0;
  clear_has_call_type();
}
inline ::mt::EmMtCallMode TMtCallParam::call_type() const {
  return static_cast< ::mt::EmMtCallMode >(call_type_);
}
inline void TMtCallParam::set_call_type(::mt::EmMtCallMode value) {
  assert(::mt::EmMtCallMode_IsValid(value));
  set_has_call_type();
  call_type_ = value;
}

// optional uint32 call_rate = 2;
inline bool TMtCallParam::has_call_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtCallParam::set_has_call_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtCallParam::clear_has_call_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtCallParam::clear_call_rate() {
  call_rate_ = 0u;
  clear_has_call_rate();
}
inline ::google::protobuf::uint32 TMtCallParam::call_rate() const {
  return call_rate_;
}
inline void TMtCallParam::set_call_rate(::google::protobuf::uint32 value) {
  set_has_call_rate();
  call_rate_ = value;
}

// optional .mt.EmConfProtocol conf_protocol = 3;
inline bool TMtCallParam::has_conf_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtCallParam::set_has_conf_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtCallParam::clear_has_conf_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtCallParam::clear_conf_protocol() {
  conf_protocol_ = 0;
  clear_has_conf_protocol();
}
inline ::mt::EmConfProtocol TMtCallParam::conf_protocol() const {
  return static_cast< ::mt::EmConfProtocol >(conf_protocol_);
}
inline void TMtCallParam::set_conf_protocol(::mt::EmConfProtocol value) {
  assert(::mt::EmConfProtocol_IsValid(value));
  set_has_conf_protocol();
  conf_protocol_ = value;
}

// optional .mt.EmMtAddrType call_addr_type = 4;
inline bool TMtCallParam::has_call_addr_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtCallParam::set_has_call_addr_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtCallParam::clear_has_call_addr_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtCallParam::clear_call_addr_type() {
  call_addr_type_ = 0;
  clear_has_call_addr_type();
}
inline ::mt::EmMtAddrType TMtCallParam::call_addr_type() const {
  return static_cast< ::mt::EmMtAddrType >(call_addr_type_);
}
inline void TMtCallParam::set_call_addr_type(::mt::EmMtAddrType value) {
  assert(::mt::EmMtAddrType_IsValid(value));
  set_has_call_addr_type();
  call_addr_type_ = value;
}

// optional .mt.TNetAddr calling_addr = 5;
inline bool TMtCallParam::has_calling_addr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtCallParam::set_has_calling_addr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtCallParam::clear_has_calling_addr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtCallParam::clear_calling_addr() {
  if (calling_addr_ != NULL) calling_addr_->::mt::TNetAddr::Clear();
  clear_has_calling_addr();
}
inline const ::mt::TNetAddr& TMtCallParam::calling_addr() const {
  return calling_addr_ != NULL ? *calling_addr_ : *default_instance_->calling_addr_;
}
inline ::mt::TNetAddr* TMtCallParam::mutable_calling_addr() {
  set_has_calling_addr();
  if (calling_addr_ == NULL) calling_addr_ = new ::mt::TNetAddr;
  return calling_addr_;
}
inline ::mt::TNetAddr* TMtCallParam::release_calling_addr() {
  clear_has_calling_addr();
  ::mt::TNetAddr* temp = calling_addr_;
  calling_addr_ = NULL;
  return temp;
}
inline void TMtCallParam::set_allocated_calling_addr(::mt::TNetAddr* calling_addr) {
  delete calling_addr_;
  calling_addr_ = calling_addr;
  if (calling_addr) {
    set_has_calling_addr();
  } else {
    clear_has_calling_addr();
  }
}

// optional .mt.TNetAddr called_addr = 6;
inline bool TMtCallParam::has_called_addr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtCallParam::set_has_called_addr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtCallParam::clear_has_called_addr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtCallParam::clear_called_addr() {
  if (called_addr_ != NULL) called_addr_->::mt::TNetAddr::Clear();
  clear_has_called_addr();
}
inline const ::mt::TNetAddr& TMtCallParam::called_addr() const {
  return called_addr_ != NULL ? *called_addr_ : *default_instance_->called_addr_;
}
inline ::mt::TNetAddr* TMtCallParam::mutable_called_addr() {
  set_has_called_addr();
  if (called_addr_ == NULL) called_addr_ = new ::mt::TNetAddr;
  return called_addr_;
}
inline ::mt::TNetAddr* TMtCallParam::release_called_addr() {
  clear_has_called_addr();
  ::mt::TNetAddr* temp = called_addr_;
  called_addr_ = NULL;
  return temp;
}
inline void TMtCallParam::set_allocated_called_addr(::mt::TNetAddr* called_addr) {
  delete called_addr_;
  called_addr_ = called_addr;
  if (called_addr) {
    set_has_called_addr();
  } else {
    clear_has_called_addr();
  }
}

// optional .mt.TRpMtAlias calling_alias = 7;
inline bool TMtCallParam::has_calling_alias() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtCallParam::set_has_calling_alias() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtCallParam::clear_has_calling_alias() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtCallParam::clear_calling_alias() {
  if (calling_alias_ != NULL) calling_alias_->::mt::TRpMtAlias::Clear();
  clear_has_calling_alias();
}
inline const ::mt::TRpMtAlias& TMtCallParam::calling_alias() const {
  return calling_alias_ != NULL ? *calling_alias_ : *default_instance_->calling_alias_;
}
inline ::mt::TRpMtAlias* TMtCallParam::mutable_calling_alias() {
  set_has_calling_alias();
  if (calling_alias_ == NULL) calling_alias_ = new ::mt::TRpMtAlias;
  return calling_alias_;
}
inline ::mt::TRpMtAlias* TMtCallParam::release_calling_alias() {
  clear_has_calling_alias();
  ::mt::TRpMtAlias* temp = calling_alias_;
  calling_alias_ = NULL;
  return temp;
}
inline void TMtCallParam::set_allocated_calling_alias(::mt::TRpMtAlias* calling_alias) {
  delete calling_alias_;
  calling_alias_ = calling_alias;
  if (calling_alias) {
    set_has_calling_alias();
  } else {
    clear_has_calling_alias();
  }
}

// optional .mt.TRpMtAlias called_alias = 8;
inline bool TMtCallParam::has_called_alias() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtCallParam::set_has_called_alias() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtCallParam::clear_has_called_alias() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtCallParam::clear_called_alias() {
  if (called_alias_ != NULL) called_alias_->::mt::TRpMtAlias::Clear();
  clear_has_called_alias();
}
inline const ::mt::TRpMtAlias& TMtCallParam::called_alias() const {
  return called_alias_ != NULL ? *called_alias_ : *default_instance_->called_alias_;
}
inline ::mt::TRpMtAlias* TMtCallParam::mutable_called_alias() {
  set_has_called_alias();
  if (called_alias_ == NULL) called_alias_ = new ::mt::TRpMtAlias;
  return called_alias_;
}
inline ::mt::TRpMtAlias* TMtCallParam::release_called_alias() {
  clear_has_called_alias();
  ::mt::TRpMtAlias* temp = called_alias_;
  called_alias_ = NULL;
  return temp;
}
inline void TMtCallParam::set_allocated_called_alias(::mt::TRpMtAlias* called_alias) {
  delete called_alias_;
  called_alias_ = called_alias;
  if (called_alias) {
    set_has_called_alias();
  } else {
    clear_has_called_alias();
  }
}

// optional bool bcreate_conf = 9;
inline bool TMtCallParam::has_bcreate_conf() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMtCallParam::set_has_bcreate_conf() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMtCallParam::clear_has_bcreate_conf() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMtCallParam::clear_bcreate_conf() {
  bcreate_conf_ = false;
  clear_has_bcreate_conf();
}
inline bool TMtCallParam::bcreate_conf() const {
  return bcreate_conf_;
}
inline void TMtCallParam::set_bcreate_conf(bool value) {
  set_has_bcreate_conf();
  bcreate_conf_ = value;
}

// optional .mt.TMtConfBaseInfo conf_base_info = 10;
inline bool TMtCallParam::has_conf_base_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMtCallParam::set_has_conf_base_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMtCallParam::clear_has_conf_base_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMtCallParam::clear_conf_base_info() {
  if (conf_base_info_ != NULL) conf_base_info_->::mt::TMtConfBaseInfo::Clear();
  clear_has_conf_base_info();
}
inline const ::mt::TMtConfBaseInfo& TMtCallParam::conf_base_info() const {
  return conf_base_info_ != NULL ? *conf_base_info_ : *default_instance_->conf_base_info_;
}
inline ::mt::TMtConfBaseInfo* TMtCallParam::mutable_conf_base_info() {
  set_has_conf_base_info();
  if (conf_base_info_ == NULL) conf_base_info_ = new ::mt::TMtConfBaseInfo;
  return conf_base_info_;
}
inline ::mt::TMtConfBaseInfo* TMtCallParam::release_conf_base_info() {
  clear_has_conf_base_info();
  ::mt::TMtConfBaseInfo* temp = conf_base_info_;
  conf_base_info_ = NULL;
  return temp;
}
inline void TMtCallParam::set_allocated_conf_base_info(::mt::TMtConfBaseInfo* conf_base_info) {
  delete conf_base_info_;
  conf_base_info_ = conf_base_info;
  if (conf_base_info) {
    set_has_conf_base_info();
  } else {
    clear_has_conf_base_info();
  }
}

// optional .mt.TRpMtAddr mt_list = 11;
inline bool TMtCallParam::has_mt_list() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMtCallParam::set_has_mt_list() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMtCallParam::clear_has_mt_list() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMtCallParam::clear_mt_list() {
  if (mt_list_ != NULL) mt_list_->::mt::TRpMtAddr::Clear();
  clear_has_mt_list();
}
inline const ::mt::TRpMtAddr& TMtCallParam::mt_list() const {
  return mt_list_ != NULL ? *mt_list_ : *default_instance_->mt_list_;
}
inline ::mt::TRpMtAddr* TMtCallParam::mutable_mt_list() {
  set_has_mt_list();
  if (mt_list_ == NULL) mt_list_ = new ::mt::TRpMtAddr;
  return mt_list_;
}
inline ::mt::TRpMtAddr* TMtCallParam::release_mt_list() {
  clear_has_mt_list();
  ::mt::TRpMtAddr* temp = mt_list_;
  mt_list_ = NULL;
  return temp;
}
inline void TMtCallParam::set_allocated_mt_list(::mt::TRpMtAddr* mt_list) {
  delete mt_list_;
  mt_list_ = mt_list;
  if (mt_list) {
    set_has_mt_list();
  } else {
    clear_has_mt_list();
  }
}

// optional string peer_product_id = 12;
inline bool TMtCallParam::has_peer_product_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMtCallParam::set_has_peer_product_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMtCallParam::clear_has_peer_product_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMtCallParam::clear_peer_product_id() {
  if (peer_product_id_ != &::google::protobuf::internal::kEmptyString) {
    peer_product_id_->clear();
  }
  clear_has_peer_product_id();
}
inline const ::std::string& TMtCallParam::peer_product_id() const {
  return *peer_product_id_;
}
inline void TMtCallParam::set_peer_product_id(const ::std::string& value) {
  set_has_peer_product_id();
  if (peer_product_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_product_id_ = new ::std::string;
  }
  peer_product_id_->assign(value);
}
inline void TMtCallParam::set_peer_product_id(const char* value) {
  set_has_peer_product_id();
  if (peer_product_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_product_id_ = new ::std::string;
  }
  peer_product_id_->assign(value);
}
inline void TMtCallParam::set_peer_product_id(const char* value, size_t size) {
  set_has_peer_product_id();
  if (peer_product_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_product_id_ = new ::std::string;
  }
  peer_product_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCallParam::mutable_peer_product_id() {
  set_has_peer_product_id();
  if (peer_product_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_product_id_ = new ::std::string;
  }
  return peer_product_id_;
}
inline ::std::string* TMtCallParam::release_peer_product_id() {
  clear_has_peer_product_id();
  if (peer_product_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_product_id_;
    peer_product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCallParam::set_allocated_peer_product_id(::std::string* peer_product_id) {
  if (peer_product_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_product_id_;
  }
  if (peer_product_id) {
    set_has_peer_product_id();
    peer_product_id_ = peer_product_id;
  } else {
    clear_has_peer_product_id();
    peer_product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string peer_version_id = 13;
inline bool TMtCallParam::has_peer_version_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMtCallParam::set_has_peer_version_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMtCallParam::clear_has_peer_version_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMtCallParam::clear_peer_version_id() {
  if (peer_version_id_ != &::google::protobuf::internal::kEmptyString) {
    peer_version_id_->clear();
  }
  clear_has_peer_version_id();
}
inline const ::std::string& TMtCallParam::peer_version_id() const {
  return *peer_version_id_;
}
inline void TMtCallParam::set_peer_version_id(const ::std::string& value) {
  set_has_peer_version_id();
  if (peer_version_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_version_id_ = new ::std::string;
  }
  peer_version_id_->assign(value);
}
inline void TMtCallParam::set_peer_version_id(const char* value) {
  set_has_peer_version_id();
  if (peer_version_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_version_id_ = new ::std::string;
  }
  peer_version_id_->assign(value);
}
inline void TMtCallParam::set_peer_version_id(const char* value, size_t size) {
  set_has_peer_version_id();
  if (peer_version_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_version_id_ = new ::std::string;
  }
  peer_version_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCallParam::mutable_peer_version_id() {
  set_has_peer_version_id();
  if (peer_version_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_version_id_ = new ::std::string;
  }
  return peer_version_id_;
}
inline ::std::string* TMtCallParam::release_peer_version_id() {
  clear_has_peer_version_id();
  if (peer_version_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_version_id_;
    peer_version_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCallParam::set_allocated_peer_version_id(::std::string* peer_version_id) {
  if (peer_version_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_version_id_;
  }
  if (peer_version_id) {
    set_has_peer_version_id();
    peer_version_id_ = peer_version_id;
  } else {
    clear_has_peer_version_id();
    peer_version_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 peer_vender_id = 14;
inline bool TMtCallParam::has_peer_vender_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMtCallParam::set_has_peer_vender_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMtCallParam::clear_has_peer_vender_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMtCallParam::clear_peer_vender_id() {
  peer_vender_id_ = 0u;
  clear_has_peer_vender_id();
}
inline ::google::protobuf::uint32 TMtCallParam::peer_vender_id() const {
  return peer_vender_id_;
}
inline void TMtCallParam::set_peer_vender_id(::google::protobuf::uint32 value) {
  set_has_peer_vender_id();
  peer_vender_id_ = value;
}

// optional bool bencrypt = 15;
inline bool TMtCallParam::has_bencrypt() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMtCallParam::set_has_bencrypt() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMtCallParam::clear_has_bencrypt() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMtCallParam::clear_bencrypt() {
  bencrypt_ = false;
  clear_has_bencrypt();
}
inline bool TMtCallParam::bencrypt() const {
  return bencrypt_;
}
inline void TMtCallParam::set_bencrypt(bool value) {
  set_has_bencrypt();
  bencrypt_ = value;
}

// optional .mt.EmEndpointType endpoint_type = 16;
inline bool TMtCallParam::has_endpoint_type() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMtCallParam::set_has_endpoint_type() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMtCallParam::clear_has_endpoint_type() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMtCallParam::clear_endpoint_type() {
  endpoint_type_ = 0;
  clear_has_endpoint_type();
}
inline ::mt::EmEndpointType TMtCallParam::endpoint_type() const {
  return static_cast< ::mt::EmEndpointType >(endpoint_type_);
}
inline void TMtCallParam::set_endpoint_type(::mt::EmEndpointType value) {
  assert(::mt::EmEndpointType_IsValid(value));
  set_has_endpoint_type();
  endpoint_type_ = value;
}

// optional bytes nonstand = 17;
inline bool TMtCallParam::has_nonstand() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMtCallParam::set_has_nonstand() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMtCallParam::clear_has_nonstand() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMtCallParam::clear_nonstand() {
  if (nonstand_ != &::google::protobuf::internal::kEmptyString) {
    nonstand_->clear();
  }
  clear_has_nonstand();
}
inline const ::std::string& TMtCallParam::nonstand() const {
  return *nonstand_;
}
inline void TMtCallParam::set_nonstand(const ::std::string& value) {
  set_has_nonstand();
  if (nonstand_ == &::google::protobuf::internal::kEmptyString) {
    nonstand_ = new ::std::string;
  }
  nonstand_->assign(value);
}
inline void TMtCallParam::set_nonstand(const char* value) {
  set_has_nonstand();
  if (nonstand_ == &::google::protobuf::internal::kEmptyString) {
    nonstand_ = new ::std::string;
  }
  nonstand_->assign(value);
}
inline void TMtCallParam::set_nonstand(const void* value, size_t size) {
  set_has_nonstand();
  if (nonstand_ == &::google::protobuf::internal::kEmptyString) {
    nonstand_ = new ::std::string;
  }
  nonstand_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCallParam::mutable_nonstand() {
  set_has_nonstand();
  if (nonstand_ == &::google::protobuf::internal::kEmptyString) {
    nonstand_ = new ::std::string;
  }
  return nonstand_;
}
inline ::std::string* TMtCallParam::release_nonstand() {
  clear_has_nonstand();
  if (nonstand_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nonstand_;
    nonstand_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCallParam::set_allocated_nonstand(::std::string* nonstand) {
  if (nonstand_ != &::google::protobuf::internal::kEmptyString) {
    delete nonstand_;
  }
  if (nonstand) {
    set_has_nonstand();
    nonstand_ = nonstand;
  } else {
    clear_has_nonstand();
    nonstand_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string callid = 18;
inline bool TMtCallParam::has_callid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMtCallParam::set_has_callid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMtCallParam::clear_has_callid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMtCallParam::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& TMtCallParam::callid() const {
  return *callid_;
}
inline void TMtCallParam::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void TMtCallParam::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void TMtCallParam::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCallParam::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* TMtCallParam::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCallParam::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_peerstack_5p0 = 19;
inline bool TMtCallParam::has_is_peerstack_5p0() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMtCallParam::set_has_is_peerstack_5p0() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMtCallParam::clear_has_is_peerstack_5p0() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMtCallParam::clear_is_peerstack_5p0() {
  is_peerstack_5p0_ = false;
  clear_has_is_peerstack_5p0();
}
inline bool TMtCallParam::is_peerstack_5p0() const {
  return is_peerstack_5p0_;
}
inline void TMtCallParam::set_is_peerstack_5p0(bool value) {
  set_has_is_peerstack_5p0();
  is_peerstack_5p0_ = value;
}

// optional bool is_vidchanoff = 20;
inline bool TMtCallParam::has_is_vidchanoff() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMtCallParam::set_has_is_vidchanoff() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMtCallParam::clear_has_is_vidchanoff() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMtCallParam::clear_is_vidchanoff() {
  is_vidchanoff_ = false;
  clear_has_is_vidchanoff();
}
inline bool TMtCallParam::is_vidchanoff() const {
  return is_vidchanoff_;
}
inline void TMtCallParam::set_is_vidchanoff(bool value) {
  set_has_is_vidchanoff();
  is_vidchanoff_ = value;
}

// optional .mt.EmSipConnectType sipconnect_type = 21;
inline bool TMtCallParam::has_sipconnect_type() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMtCallParam::set_has_sipconnect_type() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMtCallParam::clear_has_sipconnect_type() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMtCallParam::clear_sipconnect_type() {
  sipconnect_type_ = 0;
  clear_has_sipconnect_type();
}
inline ::mt::EmSipConnectType TMtCallParam::sipconnect_type() const {
  return static_cast< ::mt::EmSipConnectType >(sipconnect_type_);
}
inline void TMtCallParam::set_sipconnect_type(::mt::EmSipConnectType value) {
  assert(::mt::EmSipConnectType_IsValid(value));
  set_has_sipconnect_type();
  sipconnect_type_ = value;
}

// optional bool is_peer_support_confsub = 24;
inline bool TMtCallParam::has_is_peer_support_confsub() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMtCallParam::set_has_is_peer_support_confsub() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMtCallParam::clear_has_is_peer_support_confsub() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMtCallParam::clear_is_peer_support_confsub() {
  is_peer_support_confsub_ = false;
  clear_has_is_peer_support_confsub();
}
inline bool TMtCallParam::is_peer_support_confsub() const {
  return is_peer_support_confsub_;
}
inline void TMtCallParam::set_is_peer_support_confsub(bool value) {
  set_has_is_peer_support_confsub();
  is_peer_support_confsub_ = value;
}

// -------------------------------------------------------------------

// TMultiMtCallParam

// repeated .mt.TMtCallParam call_param = 1;
inline int TMultiMtCallParam::call_param_size() const {
  return call_param_.size();
}
inline void TMultiMtCallParam::clear_call_param() {
  call_param_.Clear();
}
inline const ::mt::TMtCallParam& TMultiMtCallParam::call_param(int index) const {
  return call_param_.Get(index);
}
inline ::mt::TMtCallParam* TMultiMtCallParam::mutable_call_param(int index) {
  return call_param_.Mutable(index);
}
inline ::mt::TMtCallParam* TMultiMtCallParam::add_call_param() {
  return call_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtCallParam >&
TMultiMtCallParam::call_param() const {
  return call_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtCallParam >*
TMultiMtCallParam::mutable_call_param() {
  return &call_param_;
}

// -------------------------------------------------------------------

// TMTSatelliteFlag

// optional bool is_sate = 1;
inline bool TMTSatelliteFlag::has_is_sate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTSatelliteFlag::set_has_is_sate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTSatelliteFlag::clear_has_is_sate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTSatelliteFlag::clear_is_sate() {
  is_sate_ = false;
  clear_has_is_sate();
}
inline bool TMTSatelliteFlag::is_sate() const {
  return is_sate_;
}
inline void TMTSatelliteFlag::set_is_sate(bool value) {
  set_has_is_sate();
  is_sate_ = value;
}

// optional bool p2p_enable = 2;
inline bool TMTSatelliteFlag::has_p2p_enable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTSatelliteFlag::set_has_p2p_enable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTSatelliteFlag::clear_has_p2p_enable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTSatelliteFlag::clear_p2p_enable() {
  p2p_enable_ = false;
  clear_has_p2p_enable();
}
inline bool TMTSatelliteFlag::p2p_enable() const {
  return p2p_enable_;
}
inline void TMTSatelliteFlag::set_p2p_enable(bool value) {
  set_has_p2p_enable();
  p2p_enable_ = value;
}

// -------------------------------------------------------------------

// TMtCallLinkSate

// optional .mt.EmMtCallState call_state = 1;
inline bool TMtCallLinkSate::has_call_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtCallLinkSate::set_has_call_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtCallLinkSate::clear_has_call_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtCallLinkSate::clear_call_state() {
  call_state_ = 0;
  clear_has_call_state();
}
inline ::mt::EmMtCallState TMtCallLinkSate::call_state() const {
  return static_cast< ::mt::EmMtCallState >(call_state_);
}
inline void TMtCallLinkSate::set_call_state(::mt::EmMtCallState value) {
  assert(::mt::EmMtCallState_IsValid(value));
  set_has_call_state();
  call_state_ = value;
}

// optional .mt.EmConfProtocol conf_protocol = 2;
inline bool TMtCallLinkSate::has_conf_protocol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtCallLinkSate::set_has_conf_protocol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtCallLinkSate::clear_has_conf_protocol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtCallLinkSate::clear_conf_protocol() {
  conf_protocol_ = 0;
  clear_has_conf_protocol();
}
inline ::mt::EmConfProtocol TMtCallLinkSate::conf_protocol() const {
  return static_cast< ::mt::EmConfProtocol >(conf_protocol_);
}
inline void TMtCallLinkSate::set_conf_protocol(::mt::EmConfProtocol value) {
  assert(::mt::EmConfProtocol_IsValid(value));
  set_has_conf_protocol();
  conf_protocol_ = value;
}

// optional bool is_caller = 3;
inline bool TMtCallLinkSate::has_is_caller() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtCallLinkSate::set_has_is_caller() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtCallLinkSate::clear_has_is_caller() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtCallLinkSate::clear_is_caller() {
  is_caller_ = false;
  clear_has_is_caller();
}
inline bool TMtCallLinkSate::is_caller() const {
  return is_caller_;
}
inline void TMtCallLinkSate::set_is_caller(bool value) {
  set_has_is_caller();
  is_caller_ = value;
}

// optional uint32 call_rate = 4;
inline bool TMtCallLinkSate::has_call_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtCallLinkSate::set_has_call_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtCallLinkSate::clear_has_call_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtCallLinkSate::clear_call_rate() {
  call_rate_ = 0u;
  clear_has_call_rate();
}
inline ::google::protobuf::uint32 TMtCallLinkSate::call_rate() const {
  return call_rate_;
}
inline void TMtCallLinkSate::set_call_rate(::google::protobuf::uint32 value) {
  set_has_call_rate();
  call_rate_ = value;
}

// optional uint32 call_avial_up_rate = 5;
inline bool TMtCallLinkSate::has_call_avial_up_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtCallLinkSate::set_has_call_avial_up_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtCallLinkSate::clear_has_call_avial_up_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtCallLinkSate::clear_call_avial_up_rate() {
  call_avial_up_rate_ = 0u;
  clear_has_call_avial_up_rate();
}
inline ::google::protobuf::uint32 TMtCallLinkSate::call_avial_up_rate() const {
  return call_avial_up_rate_;
}
inline void TMtCallLinkSate::set_call_avial_up_rate(::google::protobuf::uint32 value) {
  set_has_call_avial_up_rate();
  call_avial_up_rate_ = value;
}

// optional uint32 call_avail_down_rate = 6;
inline bool TMtCallLinkSate::has_call_avail_down_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtCallLinkSate::set_has_call_avail_down_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtCallLinkSate::clear_has_call_avail_down_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtCallLinkSate::clear_call_avail_down_rate() {
  call_avail_down_rate_ = 0u;
  clear_has_call_avail_down_rate();
}
inline ::google::protobuf::uint32 TMtCallLinkSate::call_avail_down_rate() const {
  return call_avail_down_rate_;
}
inline void TMtCallLinkSate::set_call_avail_down_rate(::google::protobuf::uint32 value) {
  set_has_call_avail_down_rate();
  call_avail_down_rate_ = value;
}

// optional .mt.EmMtCallDisReason call_dis_reason = 7;
inline bool TMtCallLinkSate::has_call_dis_reason() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtCallLinkSate::set_has_call_dis_reason() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtCallLinkSate::clear_has_call_dis_reason() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtCallLinkSate::clear_call_dis_reason() {
  call_dis_reason_ = 0;
  clear_has_call_dis_reason();
}
inline ::mt::EmMtCallDisReason TMtCallLinkSate::call_dis_reason() const {
  return static_cast< ::mt::EmMtCallDisReason >(call_dis_reason_);
}
inline void TMtCallLinkSate::set_call_dis_reason(::mt::EmMtCallDisReason value) {
  assert(::mt::EmMtCallDisReason_IsValid(value));
  set_has_call_dis_reason();
  call_dis_reason_ = value;
}

// optional .mt.TNetAddr peer_addr = 8;
inline bool TMtCallLinkSate::has_peer_addr() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtCallLinkSate::set_has_peer_addr() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtCallLinkSate::clear_has_peer_addr() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtCallLinkSate::clear_peer_addr() {
  if (peer_addr_ != NULL) peer_addr_->::mt::TNetAddr::Clear();
  clear_has_peer_addr();
}
inline const ::mt::TNetAddr& TMtCallLinkSate::peer_addr() const {
  return peer_addr_ != NULL ? *peer_addr_ : *default_instance_->peer_addr_;
}
inline ::mt::TNetAddr* TMtCallLinkSate::mutable_peer_addr() {
  set_has_peer_addr();
  if (peer_addr_ == NULL) peer_addr_ = new ::mt::TNetAddr;
  return peer_addr_;
}
inline ::mt::TNetAddr* TMtCallLinkSate::release_peer_addr() {
  clear_has_peer_addr();
  ::mt::TNetAddr* temp = peer_addr_;
  peer_addr_ = NULL;
  return temp;
}
inline void TMtCallLinkSate::set_allocated_peer_addr(::mt::TNetAddr* peer_addr) {
  delete peer_addr_;
  peer_addr_ = peer_addr;
  if (peer_addr) {
    set_has_peer_addr();
  } else {
    clear_has_peer_addr();
  }
}

// optional .mt.EmMtModel peer_model = 9;
inline bool TMtCallLinkSate::has_peer_model() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMtCallLinkSate::set_has_peer_model() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMtCallLinkSate::clear_has_peer_model() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMtCallLinkSate::clear_peer_model() {
  peer_model_ = 0;
  clear_has_peer_model();
}
inline ::mt::EmMtModel TMtCallLinkSate::peer_model() const {
  return static_cast< ::mt::EmMtModel >(peer_model_);
}
inline void TMtCallLinkSate::set_peer_model(::mt::EmMtModel value) {
  assert(::mt::EmMtModel_IsValid(value));
  set_has_peer_model();
  peer_model_ = value;
}

// optional string peer_productid = 10;
inline bool TMtCallLinkSate::has_peer_productid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMtCallLinkSate::set_has_peer_productid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMtCallLinkSate::clear_has_peer_productid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMtCallLinkSate::clear_peer_productid() {
  if (peer_productid_ != &::google::protobuf::internal::kEmptyString) {
    peer_productid_->clear();
  }
  clear_has_peer_productid();
}
inline const ::std::string& TMtCallLinkSate::peer_productid() const {
  return *peer_productid_;
}
inline void TMtCallLinkSate::set_peer_productid(const ::std::string& value) {
  set_has_peer_productid();
  if (peer_productid_ == &::google::protobuf::internal::kEmptyString) {
    peer_productid_ = new ::std::string;
  }
  peer_productid_->assign(value);
}
inline void TMtCallLinkSate::set_peer_productid(const char* value) {
  set_has_peer_productid();
  if (peer_productid_ == &::google::protobuf::internal::kEmptyString) {
    peer_productid_ = new ::std::string;
  }
  peer_productid_->assign(value);
}
inline void TMtCallLinkSate::set_peer_productid(const char* value, size_t size) {
  set_has_peer_productid();
  if (peer_productid_ == &::google::protobuf::internal::kEmptyString) {
    peer_productid_ = new ::std::string;
  }
  peer_productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCallLinkSate::mutable_peer_productid() {
  set_has_peer_productid();
  if (peer_productid_ == &::google::protobuf::internal::kEmptyString) {
    peer_productid_ = new ::std::string;
  }
  return peer_productid_;
}
inline ::std::string* TMtCallLinkSate::release_peer_productid() {
  clear_has_peer_productid();
  if (peer_productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_productid_;
    peer_productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCallLinkSate::set_allocated_peer_productid(::std::string* peer_productid) {
  if (peer_productid_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_productid_;
  }
  if (peer_productid) {
    set_has_peer_productid();
    peer_productid_ = peer_productid;
  } else {
    clear_has_peer_productid();
    peer_productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TRpMtAlias peer_alias = 11;
inline bool TMtCallLinkSate::has_peer_alias() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMtCallLinkSate::set_has_peer_alias() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMtCallLinkSate::clear_has_peer_alias() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMtCallLinkSate::clear_peer_alias() {
  if (peer_alias_ != NULL) peer_alias_->::mt::TRpMtAlias::Clear();
  clear_has_peer_alias();
}
inline const ::mt::TRpMtAlias& TMtCallLinkSate::peer_alias() const {
  return peer_alias_ != NULL ? *peer_alias_ : *default_instance_->peer_alias_;
}
inline ::mt::TRpMtAlias* TMtCallLinkSate::mutable_peer_alias() {
  set_has_peer_alias();
  if (peer_alias_ == NULL) peer_alias_ = new ::mt::TRpMtAlias;
  return peer_alias_;
}
inline ::mt::TRpMtAlias* TMtCallLinkSate::release_peer_alias() {
  clear_has_peer_alias();
  ::mt::TRpMtAlias* temp = peer_alias_;
  peer_alias_ = NULL;
  return temp;
}
inline void TMtCallLinkSate::set_allocated_peer_alias(::mt::TRpMtAlias* peer_alias) {
  delete peer_alias_;
  peer_alias_ = peer_alias;
  if (peer_alias) {
    set_has_peer_alias();
  } else {
    clear_has_peer_alias();
  }
}

// optional .mt.EmEndpointType peer_endpoint_type = 12;
inline bool TMtCallLinkSate::has_peer_endpoint_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMtCallLinkSate::set_has_peer_endpoint_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMtCallLinkSate::clear_has_peer_endpoint_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMtCallLinkSate::clear_peer_endpoint_type() {
  peer_endpoint_type_ = 0;
  clear_has_peer_endpoint_type();
}
inline ::mt::EmEndpointType TMtCallLinkSate::peer_endpoint_type() const {
  return static_cast< ::mt::EmEndpointType >(peer_endpoint_type_);
}
inline void TMtCallLinkSate::set_peer_endpoint_type(::mt::EmEndpointType value) {
  assert(::mt::EmEndpointType_IsValid(value));
  set_has_peer_endpoint_type();
  peer_endpoint_type_ = value;
}

// optional .mt.TMTTime conf_established_time = 13;
inline bool TMtCallLinkSate::has_conf_established_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMtCallLinkSate::set_has_conf_established_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMtCallLinkSate::clear_has_conf_established_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMtCallLinkSate::clear_conf_established_time() {
  if (conf_established_time_ != NULL) conf_established_time_->::mt::TMTTime::Clear();
  clear_has_conf_established_time();
}
inline const ::mt::TMTTime& TMtCallLinkSate::conf_established_time() const {
  return conf_established_time_ != NULL ? *conf_established_time_ : *default_instance_->conf_established_time_;
}
inline ::mt::TMTTime* TMtCallLinkSate::mutable_conf_established_time() {
  set_has_conf_established_time();
  if (conf_established_time_ == NULL) conf_established_time_ = new ::mt::TMTTime;
  return conf_established_time_;
}
inline ::mt::TMTTime* TMtCallLinkSate::release_conf_established_time() {
  clear_has_conf_established_time();
  ::mt::TMTTime* temp = conf_established_time_;
  conf_established_time_ = NULL;
  return temp;
}
inline void TMtCallLinkSate::set_allocated_conf_established_time(::mt::TMTTime* conf_established_time) {
  delete conf_established_time_;
  conf_established_time_ = conf_established_time;
  if (conf_established_time) {
    set_has_conf_established_time();
  } else {
    clear_has_conf_established_time();
  }
}

// optional .mt.EmMtCallingType calling_type = 14;
inline bool TMtCallLinkSate::has_calling_type() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMtCallLinkSate::set_has_calling_type() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMtCallLinkSate::clear_has_calling_type() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMtCallLinkSate::clear_calling_type() {
  calling_type_ = 0;
  clear_has_calling_type();
}
inline ::mt::EmMtCallingType TMtCallLinkSate::calling_type() const {
  return static_cast< ::mt::EmMtCallingType >(calling_type_);
}
inline void TMtCallLinkSate::set_calling_type(::mt::EmMtCallingType value) {
  assert(::mt::EmMtCallingType_IsValid(value));
  set_has_calling_type();
  calling_type_ = value;
}

// optional uint32 peer_Vendor = 15;
inline bool TMtCallLinkSate::has_peer_vendor() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMtCallLinkSate::set_has_peer_vendor() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMtCallLinkSate::clear_has_peer_vendor() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMtCallLinkSate::clear_peer_vendor() {
  peer_vendor_ = 0u;
  clear_has_peer_vendor();
}
inline ::google::protobuf::uint32 TMtCallLinkSate::peer_vendor() const {
  return peer_vendor_;
}
inline void TMtCallLinkSate::set_peer_vendor(::google::protobuf::uint32 value) {
  set_has_peer_vendor();
  peer_vendor_ = value;
}

// optional string peer_versionId = 16;
inline bool TMtCallLinkSate::has_peer_versionid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMtCallLinkSate::set_has_peer_versionid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMtCallLinkSate::clear_has_peer_versionid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMtCallLinkSate::clear_peer_versionid() {
  if (peer_versionid_ != &::google::protobuf::internal::kEmptyString) {
    peer_versionid_->clear();
  }
  clear_has_peer_versionid();
}
inline const ::std::string& TMtCallLinkSate::peer_versionid() const {
  return *peer_versionid_;
}
inline void TMtCallLinkSate::set_peer_versionid(const ::std::string& value) {
  set_has_peer_versionid();
  if (peer_versionid_ == &::google::protobuf::internal::kEmptyString) {
    peer_versionid_ = new ::std::string;
  }
  peer_versionid_->assign(value);
}
inline void TMtCallLinkSate::set_peer_versionid(const char* value) {
  set_has_peer_versionid();
  if (peer_versionid_ == &::google::protobuf::internal::kEmptyString) {
    peer_versionid_ = new ::std::string;
  }
  peer_versionid_->assign(value);
}
inline void TMtCallLinkSate::set_peer_versionid(const char* value, size_t size) {
  set_has_peer_versionid();
  if (peer_versionid_ == &::google::protobuf::internal::kEmptyString) {
    peer_versionid_ = new ::std::string;
  }
  peer_versionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtCallLinkSate::mutable_peer_versionid() {
  set_has_peer_versionid();
  if (peer_versionid_ == &::google::protobuf::internal::kEmptyString) {
    peer_versionid_ = new ::std::string;
  }
  return peer_versionid_;
}
inline ::std::string* TMtCallLinkSate::release_peer_versionid() {
  clear_has_peer_versionid();
  if (peer_versionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_versionid_;
    peer_versionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtCallLinkSate::set_allocated_peer_versionid(::std::string* peer_versionid) {
  if (peer_versionid_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_versionid_;
  }
  if (peer_versionid) {
    set_has_peer_versionid();
    peer_versionid_ = peer_versionid;
  } else {
    clear_has_peer_versionid();
    peer_versionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_peerstackafter5p0 = 17;
inline bool TMtCallLinkSate::has_is_peerstackafter5p0() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMtCallLinkSate::set_has_is_peerstackafter5p0() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMtCallLinkSate::clear_has_is_peerstackafter5p0() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMtCallLinkSate::clear_is_peerstackafter5p0() {
  is_peerstackafter5p0_ = false;
  clear_has_is_peerstackafter5p0();
}
inline bool TMtCallLinkSate::is_peerstackafter5p0() const {
  return is_peerstackafter5p0_;
}
inline void TMtCallLinkSate::set_is_peerstackafter5p0(bool value) {
  set_has_is_peerstackafter5p0();
  is_peerstackafter5p0_ = value;
}

// optional bool is_qt_call = 18;
inline bool TMtCallLinkSate::has_is_qt_call() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMtCallLinkSate::set_has_is_qt_call() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMtCallLinkSate::clear_has_is_qt_call() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMtCallLinkSate::clear_is_qt_call() {
  is_qt_call_ = false;
  clear_has_is_qt_call();
}
inline bool TMtCallLinkSate::is_qt_call() const {
  return is_qt_call_;
}
inline void TMtCallLinkSate::set_is_qt_call(bool value) {
  set_has_is_qt_call();
  is_qt_call_ = value;
}

// optional .mt.EmSipConnectType sipconnect_type = 19;
inline bool TMtCallLinkSate::has_sipconnect_type() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMtCallLinkSate::set_has_sipconnect_type() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMtCallLinkSate::clear_has_sipconnect_type() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMtCallLinkSate::clear_sipconnect_type() {
  sipconnect_type_ = 0;
  clear_has_sipconnect_type();
}
inline ::mt::EmSipConnectType TMtCallLinkSate::sipconnect_type() const {
  return static_cast< ::mt::EmSipConnectType >(sipconnect_type_);
}
inline void TMtCallLinkSate::set_sipconnect_type(::mt::EmSipConnectType value) {
  assert(::mt::EmSipConnectType_IsValid(value));
  set_has_sipconnect_type();
  sipconnect_type_ = value;
}

// optional bool is_peer_spt_subconflist = 20;
inline bool TMtCallLinkSate::has_is_peer_spt_subconflist() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMtCallLinkSate::set_has_is_peer_spt_subconflist() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMtCallLinkSate::clear_has_is_peer_spt_subconflist() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMtCallLinkSate::clear_is_peer_spt_subconflist() {
  is_peer_spt_subconflist_ = false;
  clear_has_is_peer_spt_subconflist();
}
inline bool TMtCallLinkSate::is_peer_spt_subconflist() const {
  return is_peer_spt_subconflist_;
}
inline void TMtCallLinkSate::set_is_peer_spt_subconflist(bool value) {
  set_has_is_peer_spt_subconflist();
  is_peer_spt_subconflist_ = value;
}

// -------------------------------------------------------------------

// TCodecPackStat

// optional uint32 bitrate = 1;
inline bool TCodecPackStat::has_bitrate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCodecPackStat::set_has_bitrate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCodecPackStat::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCodecPackStat::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TCodecPackStat::bitrate() const {
  return bitrate_;
}
inline void TCodecPackStat::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional uint32 avr_bitrate = 2;
inline bool TCodecPackStat::has_avr_bitrate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCodecPackStat::set_has_avr_bitrate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCodecPackStat::clear_has_avr_bitrate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCodecPackStat::clear_avr_bitrate() {
  avr_bitrate_ = 0u;
  clear_has_avr_bitrate();
}
inline ::google::protobuf::uint32 TCodecPackStat::avr_bitrate() const {
  return avr_bitrate_;
}
inline void TCodecPackStat::set_avr_bitrate(::google::protobuf::uint32 value) {
  set_has_avr_bitrate();
  avr_bitrate_ = value;
}

// optional uint32 lost_packs = 3;
inline bool TCodecPackStat::has_lost_packs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TCodecPackStat::set_has_lost_packs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TCodecPackStat::clear_has_lost_packs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TCodecPackStat::clear_lost_packs() {
  lost_packs_ = 0u;
  clear_has_lost_packs();
}
inline ::google::protobuf::uint32 TCodecPackStat::lost_packs() const {
  return lost_packs_;
}
inline void TCodecPackStat::set_lost_packs(::google::protobuf::uint32 value) {
  set_has_lost_packs();
  lost_packs_ = value;
}

// optional uint32 total_packs = 4;
inline bool TCodecPackStat::has_total_packs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TCodecPackStat::set_has_total_packs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TCodecPackStat::clear_has_total_packs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TCodecPackStat::clear_total_packs() {
  total_packs_ = 0u;
  clear_has_total_packs();
}
inline ::google::protobuf::uint32 TCodecPackStat::total_packs() const {
  return total_packs_;
}
inline void TCodecPackStat::set_total_packs(::google::protobuf::uint32 value) {
  set_has_total_packs();
  total_packs_ = value;
}

// optional uint32 frames = 5;
inline bool TCodecPackStat::has_frames() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TCodecPackStat::set_has_frames() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TCodecPackStat::clear_has_frames() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TCodecPackStat::clear_frames() {
  frames_ = 0u;
  clear_has_frames();
}
inline ::google::protobuf::uint32 TCodecPackStat::frames() const {
  return frames_;
}
inline void TCodecPackStat::set_frames(::google::protobuf::uint32 value) {
  set_has_frames();
  frames_ = value;
}

// optional uint32 lost_frame_rate = 6;
inline bool TCodecPackStat::has_lost_frame_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TCodecPackStat::set_has_lost_frame_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TCodecPackStat::clear_has_lost_frame_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TCodecPackStat::clear_lost_frame_rate() {
  lost_frame_rate_ = 0u;
  clear_has_lost_frame_rate();
}
inline ::google::protobuf::uint32 TCodecPackStat::lost_frame_rate() const {
  return lost_frame_rate_;
}
inline void TCodecPackStat::set_lost_frame_rate(::google::protobuf::uint32 value) {
  set_has_lost_frame_rate();
  lost_frame_rate_ = value;
}

// -------------------------------------------------------------------

// TMtStatusToPcdv

// optional .mt.EmMtModel mt_model = 1;
inline bool TMtStatusToPcdv::has_mt_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtStatusToPcdv::set_has_mt_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtStatusToPcdv::clear_has_mt_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtStatusToPcdv::clear_mt_model() {
  mt_model_ = 0;
  clear_has_mt_model();
}
inline ::mt::EmMtModel TMtStatusToPcdv::mt_model() const {
  return static_cast< ::mt::EmMtModel >(mt_model_);
}
inline void TMtStatusToPcdv::set_mt_model(::mt::EmMtModel value) {
  assert(::mt::EmMtModel_IsValid(value));
  set_has_mt_model();
  mt_model_ = value;
}

// optional .mt.EmMtCallState call_sate = 2;
inline bool TMtStatusToPcdv::has_call_sate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtStatusToPcdv::set_has_call_sate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtStatusToPcdv::clear_has_call_sate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtStatusToPcdv::clear_call_sate() {
  call_sate_ = 0;
  clear_has_call_sate();
}
inline ::mt::EmMtCallState TMtStatusToPcdv::call_sate() const {
  return static_cast< ::mt::EmMtCallState >(call_sate_);
}
inline void TMtStatusToPcdv::set_call_sate(::mt::EmMtCallState value) {
  assert(::mt::EmMtCallState_IsValid(value));
  set_has_call_sate();
  call_sate_ = value;
}

// optional .mt.EmMtConfMode conf_mode = 3;
inline bool TMtStatusToPcdv::has_conf_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtStatusToPcdv::set_has_conf_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtStatusToPcdv::clear_has_conf_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtStatusToPcdv::clear_conf_mode() {
  conf_mode_ = 0;
  clear_has_conf_mode();
}
inline ::mt::EmMtConfMode TMtStatusToPcdv::conf_mode() const {
  return static_cast< ::mt::EmMtConfMode >(conf_mode_);
}
inline void TMtStatusToPcdv::set_conf_mode(::mt::EmMtConfMode value) {
  assert(::mt::EmMtConfMode_IsValid(value));
  set_has_conf_mode();
  conf_mode_ = value;
}

// optional bool can_send_dual = 4;
inline bool TMtStatusToPcdv::has_can_send_dual() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtStatusToPcdv::set_has_can_send_dual() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtStatusToPcdv::clear_has_can_send_dual() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtStatusToPcdv::clear_can_send_dual() {
  can_send_dual_ = false;
  clear_has_can_send_dual();
}
inline bool TMtStatusToPcdv::can_send_dual() const {
  return can_send_dual_;
}
inline void TMtStatusToPcdv::set_can_send_dual(bool value) {
  set_has_can_send_dual();
  can_send_dual_ = value;
}

// -------------------------------------------------------------------

// TAssVidStatus

// optional .mt.EmMtChanState chan_state = 1;
inline bool TAssVidStatus::has_chan_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TAssVidStatus::set_has_chan_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TAssVidStatus::clear_has_chan_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TAssVidStatus::clear_chan_state() {
  chan_state_ = 0;
  clear_has_chan_state();
}
inline ::mt::EmMtChanState TAssVidStatus::chan_state() const {
  return static_cast< ::mt::EmMtChanState >(chan_state_);
}
inline void TAssVidStatus::set_chan_state(::mt::EmMtChanState value) {
  assert(::mt::EmMtChanState_IsValid(value));
  set_has_chan_state();
  chan_state_ = value;
}

// optional .mt.EmMtVidLabel vid_lab = 2;
inline bool TAssVidStatus::has_vid_lab() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TAssVidStatus::set_has_vid_lab() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TAssVidStatus::clear_has_vid_lab() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TAssVidStatus::clear_vid_lab() {
  vid_lab_ = 0;
  clear_has_vid_lab();
}
inline ::mt::EmMtVidLabel TAssVidStatus::vid_lab() const {
  return static_cast< ::mt::EmMtVidLabel >(vid_lab_);
}
inline void TAssVidStatus::set_vid_lab(::mt::EmMtVidLabel value) {
  assert(::mt::EmMtVidLabel_IsValid(value));
  set_has_vid_lab();
  vid_lab_ = value;
}

// optional bool bactive = 3;
inline bool TAssVidStatus::has_bactive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TAssVidStatus::set_has_bactive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TAssVidStatus::clear_has_bactive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TAssVidStatus::clear_bactive() {
  bactive_ = false;
  clear_has_bactive();
}
inline bool TAssVidStatus::bactive() const {
  return bactive_;
}
inline void TAssVidStatus::set_bactive(bool value) {
  set_has_bactive();
  bactive_ = value;
}

// optional .mt.TMtcBaseInfo pc_ass_src = 4;
inline bool TAssVidStatus::has_pc_ass_src() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TAssVidStatus::set_has_pc_ass_src() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TAssVidStatus::clear_has_pc_ass_src() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TAssVidStatus::clear_pc_ass_src() {
  if (pc_ass_src_ != NULL) pc_ass_src_->::mt::TMtcBaseInfo::Clear();
  clear_has_pc_ass_src();
}
inline const ::mt::TMtcBaseInfo& TAssVidStatus::pc_ass_src() const {
  return pc_ass_src_ != NULL ? *pc_ass_src_ : *default_instance_->pc_ass_src_;
}
inline ::mt::TMtcBaseInfo* TAssVidStatus::mutable_pc_ass_src() {
  set_has_pc_ass_src();
  if (pc_ass_src_ == NULL) pc_ass_src_ = new ::mt::TMtcBaseInfo;
  return pc_ass_src_;
}
inline ::mt::TMtcBaseInfo* TAssVidStatus::release_pc_ass_src() {
  clear_has_pc_ass_src();
  ::mt::TMtcBaseInfo* temp = pc_ass_src_;
  pc_ass_src_ = NULL;
  return temp;
}
inline void TAssVidStatus::set_allocated_pc_ass_src(::mt::TMtcBaseInfo* pc_ass_src) {
  delete pc_ass_src_;
  pc_ass_src_ = pc_ass_src;
  if (pc_ass_src) {
    set_has_pc_ass_src();
  } else {
    clear_has_pc_ass_src();
  }
}

// -------------------------------------------------------------------

// TMtAssSndVidStatus

// repeated .mt.TAssVidStatus ass_vid_snd = 1;
inline int TMtAssSndVidStatus::ass_vid_snd_size() const {
  return ass_vid_snd_.size();
}
inline void TMtAssSndVidStatus::clear_ass_vid_snd() {
  ass_vid_snd_.Clear();
}
inline const ::mt::TAssVidStatus& TMtAssSndVidStatus::ass_vid_snd(int index) const {
  return ass_vid_snd_.Get(index);
}
inline ::mt::TAssVidStatus* TMtAssSndVidStatus::mutable_ass_vid_snd(int index) {
  return ass_vid_snd_.Mutable(index);
}
inline ::mt::TAssVidStatus* TMtAssSndVidStatus::add_ass_vid_snd() {
  return ass_vid_snd_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAssVidStatus >&
TMtAssSndVidStatus::ass_vid_snd() const {
  return ass_vid_snd_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAssVidStatus >*
TMtAssSndVidStatus::mutable_ass_vid_snd() {
  return &ass_vid_snd_;
}

// -------------------------------------------------------------------

// TMtAssRcvVidStatus

// repeated .mt.TAssVidStatus ass_vid_rcv = 1;
inline int TMtAssRcvVidStatus::ass_vid_rcv_size() const {
  return ass_vid_rcv_.size();
}
inline void TMtAssRcvVidStatus::clear_ass_vid_rcv() {
  ass_vid_rcv_.Clear();
}
inline const ::mt::TAssVidStatus& TMtAssRcvVidStatus::ass_vid_rcv(int index) const {
  return ass_vid_rcv_.Get(index);
}
inline ::mt::TAssVidStatus* TMtAssRcvVidStatus::mutable_ass_vid_rcv(int index) {
  return ass_vid_rcv_.Mutable(index);
}
inline ::mt::TAssVidStatus* TMtAssRcvVidStatus::add_ass_vid_rcv() {
  return ass_vid_rcv_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TAssVidStatus >&
TMtAssRcvVidStatus::ass_vid_rcv() const {
  return ass_vid_rcv_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TAssVidStatus >*
TMtAssRcvVidStatus::mutable_ass_vid_rcv() {
  return &ass_vid_rcv_;
}

// -------------------------------------------------------------------

// TMtSimpConfInfo

// optional .mt.TMtId speaker = 1;
inline bool TMtSimpConfInfo::has_speaker() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSimpConfInfo::set_has_speaker() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSimpConfInfo::clear_has_speaker() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSimpConfInfo::clear_speaker() {
  if (speaker_ != NULL) speaker_->::mt::TMtId::Clear();
  clear_has_speaker();
}
inline const ::mt::TMtId& TMtSimpConfInfo::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::mt::TMtId* TMtSimpConfInfo::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::mt::TMtId;
  return speaker_;
}
inline ::mt::TMtId* TMtSimpConfInfo::release_speaker() {
  clear_has_speaker();
  ::mt::TMtId* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void TMtSimpConfInfo::set_allocated_speaker(::mt::TMtId* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional .mt.TMtId chairman = 2;
inline bool TMtSimpConfInfo::has_chairman() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSimpConfInfo::set_has_chairman() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSimpConfInfo::clear_has_chairman() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSimpConfInfo::clear_chairman() {
  if (chairman_ != NULL) chairman_->::mt::TMtId::Clear();
  clear_has_chairman();
}
inline const ::mt::TMtId& TMtSimpConfInfo::chairman() const {
  return chairman_ != NULL ? *chairman_ : *default_instance_->chairman_;
}
inline ::mt::TMtId* TMtSimpConfInfo::mutable_chairman() {
  set_has_chairman();
  if (chairman_ == NULL) chairman_ = new ::mt::TMtId;
  return chairman_;
}
inline ::mt::TMtId* TMtSimpConfInfo::release_chairman() {
  clear_has_chairman();
  ::mt::TMtId* temp = chairman_;
  chairman_ = NULL;
  return temp;
}
inline void TMtSimpConfInfo::set_allocated_chairman(::mt::TMtId* chairman) {
  delete chairman_;
  chairman_ = chairman;
  if (chairman) {
    set_has_chairman();
  } else {
    clear_has_chairman();
  }
}

// optional .mt.EmMtMixType discuss_mode = 3;
inline bool TMtSimpConfInfo::has_discuss_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtSimpConfInfo::set_has_discuss_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtSimpConfInfo::clear_has_discuss_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtSimpConfInfo::clear_discuss_mode() {
  discuss_mode_ = 0;
  clear_has_discuss_mode();
}
inline ::mt::EmMtMixType TMtSimpConfInfo::discuss_mode() const {
  return static_cast< ::mt::EmMtMixType >(discuss_mode_);
}
inline void TMtSimpConfInfo::set_discuss_mode(::mt::EmMtMixType value) {
  assert(::mt::EmMtMixType_IsValid(value));
  set_has_discuss_mode();
  discuss_mode_ = value;
}

// optional .mt.EmMtVmpMode vmp_mode = 4;
inline bool TMtSimpConfInfo::has_vmp_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtSimpConfInfo::set_has_vmp_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtSimpConfInfo::clear_has_vmp_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtSimpConfInfo::clear_vmp_mode() {
  vmp_mode_ = 0;
  clear_has_vmp_mode();
}
inline ::mt::EmMtVmpMode TMtSimpConfInfo::vmp_mode() const {
  return static_cast< ::mt::EmMtVmpMode >(vmp_mode_);
}
inline void TMtSimpConfInfo::set_vmp_mode(::mt::EmMtVmpMode value) {
  assert(::mt::EmMtVmpMode_IsValid(value));
  set_has_vmp_mode();
  vmp_mode_ = value;
}

// -------------------------------------------------------------------

// TMtTerLossRate

// repeated .mt.TMtChanLossRate one_chan = 1;
inline int TMtTerLossRate::one_chan_size() const {
  return one_chan_.size();
}
inline void TMtTerLossRate::clear_one_chan() {
  one_chan_.Clear();
}
inline const ::mt::TMtChanLossRate& TMtTerLossRate::one_chan(int index) const {
  return one_chan_.Get(index);
}
inline ::mt::TMtChanLossRate* TMtTerLossRate::mutable_one_chan(int index) {
  return one_chan_.Mutable(index);
}
inline ::mt::TMtChanLossRate* TMtTerLossRate::add_one_chan() {
  return one_chan_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtChanLossRate >&
TMtTerLossRate::one_chan() const {
  return one_chan_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtChanLossRate >*
TMtTerLossRate::mutable_one_chan() {
  return &one_chan_;
}

// -------------------------------------------------------------------

// TMtChanLossRate

// optional .mt.EmMediaModeDef mode = 1;
inline bool TMtChanLossRate::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtChanLossRate::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtChanLossRate::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtChanLossRate::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mt::EmMediaModeDef TMtChanLossRate::mode() const {
  return static_cast< ::mt::EmMediaModeDef >(mode_);
}
inline void TMtChanLossRate::set_mode(::mt::EmMediaModeDef value) {
  assert(::mt::EmMediaModeDef_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// optional uint32 recv_idx = 2;
inline bool TMtChanLossRate::has_recv_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtChanLossRate::set_has_recv_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtChanLossRate::clear_has_recv_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtChanLossRate::clear_recv_idx() {
  recv_idx_ = 0u;
  clear_has_recv_idx();
}
inline ::google::protobuf::uint32 TMtChanLossRate::recv_idx() const {
  return recv_idx_;
}
inline void TMtChanLossRate::set_recv_idx(::google::protobuf::uint32 value) {
  set_has_recv_idx();
  recv_idx_ = value;
}

// optional uint32 packet_lost_rate = 3;
inline bool TMtChanLossRate::has_packet_lost_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtChanLossRate::set_has_packet_lost_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtChanLossRate::clear_has_packet_lost_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtChanLossRate::clear_packet_lost_rate() {
  packet_lost_rate_ = 0u;
  clear_has_packet_lost_rate();
}
inline ::google::protobuf::uint32 TMtChanLossRate::packet_lost_rate() const {
  return packet_lost_rate_;
}
inline void TMtChanLossRate::set_packet_lost_rate(::google::protobuf::uint32 value) {
  set_has_packet_lost_rate();
  packet_lost_rate_ = value;
}

// -------------------------------------------------------------------

// TMtConfInfo

// optional .mt.TMTTime start_time = 1;
inline bool TMtConfInfo::has_start_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtConfInfo::set_has_start_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtConfInfo::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtConfInfo::clear_start_time() {
  if (start_time_ != NULL) start_time_->::mt::TMTTime::Clear();
  clear_has_start_time();
}
inline const ::mt::TMTTime& TMtConfInfo::start_time() const {
  return start_time_ != NULL ? *start_time_ : *default_instance_->start_time_;
}
inline ::mt::TMTTime* TMtConfInfo::mutable_start_time() {
  set_has_start_time();
  if (start_time_ == NULL) start_time_ = new ::mt::TMTTime;
  return start_time_;
}
inline ::mt::TMTTime* TMtConfInfo::release_start_time() {
  clear_has_start_time();
  ::mt::TMTTime* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline void TMtConfInfo::set_allocated_start_time(::mt::TMTTime* start_time) {
  delete start_time_;
  start_time_ = start_time;
  if (start_time) {
    set_has_start_time();
  } else {
    clear_has_start_time();
  }
}

// optional uint32 duration = 2;
inline bool TMtConfInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtConfInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtConfInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtConfInfo::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TMtConfInfo::duration() const {
  return duration_;
}
inline void TMtConfInfo::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 bitrate = 3;
inline bool TMtConfInfo::has_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtConfInfo::set_has_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtConfInfo::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtConfInfo::clear_bitrate() {
  bitrate_ = 0u;
  clear_has_bitrate();
}
inline ::google::protobuf::uint32 TMtConfInfo::bitrate() const {
  return bitrate_;
}
inline void TMtConfInfo::set_bitrate(::google::protobuf::uint32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional uint32 sec_bitrate = 4;
inline bool TMtConfInfo::has_sec_bitrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtConfInfo::set_has_sec_bitrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtConfInfo::clear_has_sec_bitrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtConfInfo::clear_sec_bitrate() {
  sec_bitrate_ = 0u;
  clear_has_sec_bitrate();
}
inline ::google::protobuf::uint32 TMtConfInfo::sec_bitrate() const {
  return sec_bitrate_;
}
inline void TMtConfInfo::set_sec_bitrate(::google::protobuf::uint32 value) {
  set_has_sec_bitrate();
  sec_bitrate_ = value;
}

// optional .mt.EmMtResolution main_video_res = 5;
inline bool TMtConfInfo::has_main_video_res() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtConfInfo::set_has_main_video_res() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtConfInfo::clear_has_main_video_res() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtConfInfo::clear_main_video_res() {
  main_video_res_ = 0;
  clear_has_main_video_res();
}
inline ::mt::EmMtResolution TMtConfInfo::main_video_res() const {
  return static_cast< ::mt::EmMtResolution >(main_video_res_);
}
inline void TMtConfInfo::set_main_video_res(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_main_video_res();
  main_video_res_ = value;
}

// optional .mt.EmMtResolution ass_video_res = 6;
inline bool TMtConfInfo::has_ass_video_res() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtConfInfo::set_has_ass_video_res() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtConfInfo::clear_has_ass_video_res() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtConfInfo::clear_ass_video_res() {
  ass_video_res_ = 0;
  clear_has_ass_video_res();
}
inline ::mt::EmMtResolution TMtConfInfo::ass_video_res() const {
  return static_cast< ::mt::EmMtResolution >(ass_video_res_);
}
inline void TMtConfInfo::set_ass_video_res(::mt::EmMtResolution value) {
  assert(::mt::EmMtResolution_IsValid(value));
  set_has_ass_video_res();
  ass_video_res_ = value;
}

// optional uint32 talk_hold_time = 7;
inline bool TMtConfInfo::has_talk_hold_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtConfInfo::set_has_talk_hold_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtConfInfo::clear_has_talk_hold_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtConfInfo::clear_talk_hold_time() {
  talk_hold_time_ = 0u;
  clear_has_talk_hold_time();
}
inline ::google::protobuf::uint32 TMtConfInfo::talk_hold_time() const {
  return talk_hold_time_;
}
inline void TMtConfInfo::set_talk_hold_time(::google::protobuf::uint32 value) {
  set_has_talk_hold_time();
  talk_hold_time_ = value;
}

// optional string conf_pwd = 8;
inline bool TMtConfInfo::has_conf_pwd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtConfInfo::set_has_conf_pwd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtConfInfo::clear_has_conf_pwd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtConfInfo::clear_conf_pwd() {
  if (conf_pwd_ != &::google::protobuf::internal::kEmptyString) {
    conf_pwd_->clear();
  }
  clear_has_conf_pwd();
}
inline const ::std::string& TMtConfInfo::conf_pwd() const {
  return *conf_pwd_;
}
inline void TMtConfInfo::set_conf_pwd(const ::std::string& value) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(value);
}
inline void TMtConfInfo::set_conf_pwd(const char* value) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(value);
}
inline void TMtConfInfo::set_conf_pwd(const char* value, size_t size) {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  conf_pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtConfInfo::mutable_conf_pwd() {
  set_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    conf_pwd_ = new ::std::string;
  }
  return conf_pwd_;
}
inline ::std::string* TMtConfInfo::release_conf_pwd() {
  clear_has_conf_pwd();
  if (conf_pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_pwd_;
    conf_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtConfInfo::set_allocated_conf_pwd(::std::string* conf_pwd) {
  if (conf_pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_pwd_;
  }
  if (conf_pwd) {
    set_has_conf_pwd();
    conf_pwd_ = conf_pwd;
  } else {
    clear_has_conf_pwd();
    conf_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string conf_name = 9;
inline bool TMtConfInfo::has_conf_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMtConfInfo::set_has_conf_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMtConfInfo::clear_has_conf_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMtConfInfo::clear_conf_name() {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    conf_name_->clear();
  }
  clear_has_conf_name();
}
inline const ::std::string& TMtConfInfo::conf_name() const {
  return *conf_name_;
}
inline void TMtConfInfo::set_conf_name(const ::std::string& value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtConfInfo::set_conf_name(const char* value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TMtConfInfo::set_conf_name(const char* value, size_t size) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtConfInfo::mutable_conf_name() {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  return conf_name_;
}
inline ::std::string* TMtConfInfo::release_conf_name() {
  clear_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_name_;
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtConfInfo::set_allocated_conf_name(::std::string* conf_name) {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_name_;
  }
  if (conf_name) {
    set_has_conf_name();
    conf_name_ = conf_name;
  } else {
    clear_has_conf_name();
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string conf_e164 = 10;
inline bool TMtConfInfo::has_conf_e164() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMtConfInfo::set_has_conf_e164() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMtConfInfo::clear_has_conf_e164() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMtConfInfo::clear_conf_e164() {
  if (conf_e164_ != &::google::protobuf::internal::kEmptyString) {
    conf_e164_->clear();
  }
  clear_has_conf_e164();
}
inline const ::std::string& TMtConfInfo::conf_e164() const {
  return *conf_e164_;
}
inline void TMtConfInfo::set_conf_e164(const ::std::string& value) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(value);
}
inline void TMtConfInfo::set_conf_e164(const char* value) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(value);
}
inline void TMtConfInfo::set_conf_e164(const char* value, size_t size) {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  conf_e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtConfInfo::mutable_conf_e164() {
  set_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    conf_e164_ = new ::std::string;
  }
  return conf_e164_;
}
inline ::std::string* TMtConfInfo::release_conf_e164() {
  clear_has_conf_e164();
  if (conf_e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_e164_;
    conf_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtConfInfo::set_allocated_conf_e164(::std::string* conf_e164) {
  if (conf_e164_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_e164_;
  }
  if (conf_e164) {
    set_has_conf_e164();
    conf_e164_ = conf_e164;
  } else {
    clear_has_conf_e164();
    conf_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMtId chairman = 11;
inline bool TMtConfInfo::has_chairman() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMtConfInfo::set_has_chairman() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMtConfInfo::clear_has_chairman() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMtConfInfo::clear_chairman() {
  if (chairman_ != NULL) chairman_->::mt::TMtId::Clear();
  clear_has_chairman();
}
inline const ::mt::TMtId& TMtConfInfo::chairman() const {
  return chairman_ != NULL ? *chairman_ : *default_instance_->chairman_;
}
inline ::mt::TMtId* TMtConfInfo::mutable_chairman() {
  set_has_chairman();
  if (chairman_ == NULL) chairman_ = new ::mt::TMtId;
  return chairman_;
}
inline ::mt::TMtId* TMtConfInfo::release_chairman() {
  clear_has_chairman();
  ::mt::TMtId* temp = chairman_;
  chairman_ = NULL;
  return temp;
}
inline void TMtConfInfo::set_allocated_chairman(::mt::TMtId* chairman) {
  delete chairman_;
  chairman_ = chairman;
  if (chairman) {
    set_has_chairman();
  } else {
    clear_has_chairman();
  }
}

// optional .mt.TMtId speaker = 12;
inline bool TMtConfInfo::has_speaker() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMtConfInfo::set_has_speaker() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMtConfInfo::clear_has_speaker() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMtConfInfo::clear_speaker() {
  if (speaker_ != NULL) speaker_->::mt::TMtId::Clear();
  clear_has_speaker();
}
inline const ::mt::TMtId& TMtConfInfo::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::mt::TMtId* TMtConfInfo::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::mt::TMtId;
  return speaker_;
}
inline ::mt::TMtId* TMtConfInfo::release_speaker() {
  clear_has_speaker();
  ::mt::TMtId* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void TMtConfInfo::set_allocated_speaker(::mt::TMtId* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional .mt.TMtVmpParam vmp_param = 13;
inline bool TMtConfInfo::has_vmp_param() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMtConfInfo::set_has_vmp_param() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMtConfInfo::clear_has_vmp_param() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMtConfInfo::clear_vmp_param() {
  if (vmp_param_ != NULL) vmp_param_->::mt::TMtVmpParam::Clear();
  clear_has_vmp_param();
}
inline const ::mt::TMtVmpParam& TMtConfInfo::vmp_param() const {
  return vmp_param_ != NULL ? *vmp_param_ : *default_instance_->vmp_param_;
}
inline ::mt::TMtVmpParam* TMtConfInfo::mutable_vmp_param() {
  set_has_vmp_param();
  if (vmp_param_ == NULL) vmp_param_ = new ::mt::TMtVmpParam;
  return vmp_param_;
}
inline ::mt::TMtVmpParam* TMtConfInfo::release_vmp_param() {
  clear_has_vmp_param();
  ::mt::TMtVmpParam* temp = vmp_param_;
  vmp_param_ = NULL;
  return temp;
}
inline void TMtConfInfo::set_allocated_vmp_param(::mt::TMtVmpParam* vmp_param) {
  delete vmp_param_;
  vmp_param_ = vmp_param;
  if (vmp_param) {
    set_has_vmp_param();
  } else {
    clear_has_vmp_param();
  }
}

// optional .mt.TMtMixParam mix_param = 14;
inline bool TMtConfInfo::has_mix_param() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TMtConfInfo::set_has_mix_param() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TMtConfInfo::clear_has_mix_param() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TMtConfInfo::clear_mix_param() {
  if (mix_param_ != NULL) mix_param_->::mt::TMtMixParam::Clear();
  clear_has_mix_param();
}
inline const ::mt::TMtMixParam& TMtConfInfo::mix_param() const {
  return mix_param_ != NULL ? *mix_param_ : *default_instance_->mix_param_;
}
inline ::mt::TMtMixParam* TMtConfInfo::mutable_mix_param() {
  set_has_mix_param();
  if (mix_param_ == NULL) mix_param_ = new ::mt::TMtMixParam;
  return mix_param_;
}
inline ::mt::TMtMixParam* TMtConfInfo::release_mix_param() {
  clear_has_mix_param();
  ::mt::TMtMixParam* temp = mix_param_;
  mix_param_ = NULL;
  return temp;
}
inline void TMtConfInfo::set_allocated_mix_param(::mt::TMtMixParam* mix_param) {
  delete mix_param_;
  mix_param_ = mix_param;
  if (mix_param) {
    set_has_mix_param();
  } else {
    clear_has_mix_param();
  }
}

// optional bool bsat_dcast_mode = 15;
inline bool TMtConfInfo::has_bsat_dcast_mode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TMtConfInfo::set_has_bsat_dcast_mode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TMtConfInfo::clear_has_bsat_dcast_mode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TMtConfInfo::clear_bsat_dcast_mode() {
  bsat_dcast_mode_ = false;
  clear_has_bsat_dcast_mode();
}
inline bool TMtConfInfo::bsat_dcast_mode() const {
  return bsat_dcast_mode_;
}
inline void TMtConfInfo::set_bsat_dcast_mode(bool value) {
  set_has_bsat_dcast_mode();
  bsat_dcast_mode_ = value;
}

// optional .mt.EmMtOpenMode open_mode = 16;
inline bool TMtConfInfo::has_open_mode() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TMtConfInfo::set_has_open_mode() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TMtConfInfo::clear_has_open_mode() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TMtConfInfo::clear_open_mode() {
  open_mode_ = 1;
  clear_has_open_mode();
}
inline ::mt::EmMtOpenMode TMtConfInfo::open_mode() const {
  return static_cast< ::mt::EmMtOpenMode >(open_mode_);
}
inline void TMtConfInfo::set_open_mode(::mt::EmMtOpenMode value) {
  assert(::mt::EmMtOpenMode_IsValid(value));
  set_has_open_mode();
  open_mode_ = value;
}

// optional bool is_occupy_vpu = 17;
inline bool TMtConfInfo::has_is_occupy_vpu() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TMtConfInfo::set_has_is_occupy_vpu() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TMtConfInfo::clear_has_is_occupy_vpu() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TMtConfInfo::clear_is_occupy_vpu() {
  is_occupy_vpu_ = false;
  clear_has_is_occupy_vpu();
}
inline bool TMtConfInfo::is_occupy_vpu() const {
  return is_occupy_vpu_;
}
inline void TMtConfInfo::set_is_occupy_vpu(bool value) {
  set_has_is_occupy_vpu();
  is_occupy_vpu_ = value;
}

// optional .mt.EmMtDualMode dual_mode = 18;
inline bool TMtConfInfo::has_dual_mode() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TMtConfInfo::set_has_dual_mode() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TMtConfInfo::clear_has_dual_mode() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TMtConfInfo::clear_dual_mode() {
  dual_mode_ = 0;
  clear_has_dual_mode();
}
inline ::mt::EmMtDualMode TMtConfInfo::dual_mode() const {
  return static_cast< ::mt::EmMtDualMode >(dual_mode_);
}
inline void TMtConfInfo::set_dual_mode(::mt::EmMtDualMode value) {
  assert(::mt::EmMtDualMode_IsValid(value));
  set_has_dual_mode();
  dual_mode_ = value;
}

// optional bool is_all_init_dumb = 19;
inline bool TMtConfInfo::has_is_all_init_dumb() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TMtConfInfo::set_has_is_all_init_dumb() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TMtConfInfo::clear_has_is_all_init_dumb() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TMtConfInfo::clear_is_all_init_dumb() {
  is_all_init_dumb_ = false;
  clear_has_is_all_init_dumb();
}
inline bool TMtConfInfo::is_all_init_dumb() const {
  return is_all_init_dumb_;
}
inline void TMtConfInfo::set_is_all_init_dumb(bool value) {
  set_has_is_all_init_dumb();
  is_all_init_dumb_ = value;
}

// optional bool is_conf_no_disturb = 20;
inline bool TMtConfInfo::has_is_conf_no_disturb() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TMtConfInfo::set_has_is_conf_no_disturb() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TMtConfInfo::clear_has_is_conf_no_disturb() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TMtConfInfo::clear_is_conf_no_disturb() {
  is_conf_no_disturb_ = false;
  clear_has_is_conf_no_disturb();
}
inline bool TMtConfInfo::is_conf_no_disturb() const {
  return is_conf_no_disturb_;
}
inline void TMtConfInfo::set_is_conf_no_disturb(bool value) {
  set_has_is_conf_no_disturb();
  is_conf_no_disturb_ = value;
}

// optional bool is_port_mode = 21;
inline bool TMtConfInfo::has_is_port_mode() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TMtConfInfo::set_has_is_port_mode() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TMtConfInfo::clear_has_is_port_mode() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TMtConfInfo::clear_is_port_mode() {
  is_port_mode_ = false;
  clear_has_is_port_mode();
}
inline bool TMtConfInfo::is_port_mode() const {
  return is_port_mode_;
}
inline void TMtConfInfo::set_is_port_mode(bool value) {
  set_has_is_port_mode();
  is_port_mode_ = value;
}

// optional bool is_force_broadcast = 22;
inline bool TMtConfInfo::has_is_force_broadcast() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TMtConfInfo::set_has_is_force_broadcast() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TMtConfInfo::clear_has_is_force_broadcast() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TMtConfInfo::clear_is_force_broadcast() {
  is_force_broadcast_ = false;
  clear_has_is_force_broadcast();
}
inline bool TMtConfInfo::is_force_broadcast() const {
  return is_force_broadcast_;
}
inline void TMtConfInfo::set_is_force_broadcast(bool value) {
  set_has_is_force_broadcast();
  is_force_broadcast_ = value;
}

// optional uint32 record_mode = 23;
inline bool TMtConfInfo::has_record_mode() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TMtConfInfo::set_has_record_mode() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TMtConfInfo::clear_has_record_mode() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TMtConfInfo::clear_record_mode() {
  record_mode_ = 0u;
  clear_has_record_mode();
}
inline ::google::protobuf::uint32 TMtConfInfo::record_mode() const {
  return record_mode_;
}
inline void TMtConfInfo::set_record_mode(::google::protobuf::uint32 value) {
  set_has_record_mode();
  record_mode_ = value;
}

// -------------------------------------------------------------------

// TPeerCapabilityInfo

// optional bool bMix = 1;
inline bool TPeerCapabilityInfo::has_bmix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bmix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TPeerCapabilityInfo::clear_has_bmix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TPeerCapabilityInfo::clear_bmix() {
  bmix_ = false;
  clear_has_bmix();
}
inline bool TPeerCapabilityInfo::bmix() const {
  return bmix_;
}
inline void TPeerCapabilityInfo::set_bmix(bool value) {
  set_has_bmix();
  bmix_ = value;
}

// optional bool bVAC = 2;
inline bool TPeerCapabilityInfo::has_bvac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bvac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TPeerCapabilityInfo::clear_has_bvac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TPeerCapabilityInfo::clear_bvac() {
  bvac_ = false;
  clear_has_bvac();
}
inline bool TPeerCapabilityInfo::bvac() const {
  return bvac_;
}
inline void TPeerCapabilityInfo::set_bvac(bool value) {
  set_has_bvac();
  bvac_ = value;
}

// optional bool bCustomVMP = 3;
inline bool TPeerCapabilityInfo::has_bcustomvmp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bcustomvmp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TPeerCapabilityInfo::clear_has_bcustomvmp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TPeerCapabilityInfo::clear_bcustomvmp() {
  bcustomvmp_ = false;
  clear_has_bcustomvmp();
}
inline bool TPeerCapabilityInfo::bcustomvmp() const {
  return bcustomvmp_;
}
inline void TPeerCapabilityInfo::set_bcustomvmp(bool value) {
  set_has_bcustomvmp();
  bcustomvmp_ = value;
}

// optional bool bAutoVMP = 4;
inline bool TPeerCapabilityInfo::has_bautovmp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bautovmp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TPeerCapabilityInfo::clear_has_bautovmp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TPeerCapabilityInfo::clear_bautovmp() {
  bautovmp_ = false;
  clear_has_bautovmp();
}
inline bool TPeerCapabilityInfo::bautovmp() const {
  return bautovmp_;
}
inline void TPeerCapabilityInfo::set_bautovmp(bool value) {
  set_has_bautovmp();
  bautovmp_ = value;
}

// optional bool bEndConf = 5;
inline bool TPeerCapabilityInfo::has_bendconf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bendconf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TPeerCapabilityInfo::clear_has_bendconf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TPeerCapabilityInfo::clear_bendconf() {
  bendconf_ = false;
  clear_has_bendconf();
}
inline bool TPeerCapabilityInfo::bendconf() const {
  return bendconf_;
}
inline void TPeerCapabilityInfo::set_bendconf(bool value) {
  set_has_bendconf();
  bendconf_ = value;
}

// optional bool bInvateMt = 6;
inline bool TPeerCapabilityInfo::has_binvatemt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TPeerCapabilityInfo::set_has_binvatemt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TPeerCapabilityInfo::clear_has_binvatemt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TPeerCapabilityInfo::clear_binvatemt() {
  binvatemt_ = false;
  clear_has_binvatemt();
}
inline bool TPeerCapabilityInfo::binvatemt() const {
  return binvatemt_;
}
inline void TPeerCapabilityInfo::set_binvatemt(bool value) {
  set_has_binvatemt();
  binvatemt_ = value;
}

// optional bool bDropMt = 7;
inline bool TPeerCapabilityInfo::has_bdropmt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bdropmt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TPeerCapabilityInfo::clear_has_bdropmt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TPeerCapabilityInfo::clear_bdropmt() {
  bdropmt_ = false;
  clear_has_bdropmt();
}
inline bool TPeerCapabilityInfo::bdropmt() const {
  return bdropmt_;
}
inline void TPeerCapabilityInfo::set_bdropmt(bool value) {
  set_has_bdropmt();
  bdropmt_ = value;
}

// optional bool bSelSpeaker = 8;
inline bool TPeerCapabilityInfo::has_bselspeaker() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bselspeaker() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TPeerCapabilityInfo::clear_has_bselspeaker() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TPeerCapabilityInfo::clear_bselspeaker() {
  bselspeaker_ = false;
  clear_has_bselspeaker();
}
inline bool TPeerCapabilityInfo::bselspeaker() const {
  return bselspeaker_;
}
inline void TPeerCapabilityInfo::set_bselspeaker(bool value) {
  set_has_bselspeaker();
  bselspeaker_ = value;
}

// optional bool bSelChair = 9;
inline bool TPeerCapabilityInfo::has_bselchair() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bselchair() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TPeerCapabilityInfo::clear_has_bselchair() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TPeerCapabilityInfo::clear_bselchair() {
  bselchair_ = false;
  clear_has_bselchair();
}
inline bool TPeerCapabilityInfo::bselchair() const {
  return bselchair_;
}
inline void TPeerCapabilityInfo::set_bselchair(bool value) {
  set_has_bselchair();
  bselchair_ = value;
}

// optional bool bSelSource = 10;
inline bool TPeerCapabilityInfo::has_bselsource() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bselsource() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TPeerCapabilityInfo::clear_has_bselsource() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TPeerCapabilityInfo::clear_bselsource() {
  bselsource_ = false;
  clear_has_bselsource();
}
inline bool TPeerCapabilityInfo::bselsource() const {
  return bselsource_;
}
inline void TPeerCapabilityInfo::set_bselsource(bool value) {
  set_has_bselsource();
  bselsource_ = value;
}

// optional bool bFECC = 11;
inline bool TPeerCapabilityInfo::has_bfecc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bfecc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TPeerCapabilityInfo::clear_has_bfecc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TPeerCapabilityInfo::clear_bfecc() {
  bfecc_ = false;
  clear_has_bfecc();
}
inline bool TPeerCapabilityInfo::bfecc() const {
  return bfecc_;
}
inline void TPeerCapabilityInfo::set_bfecc(bool value) {
  set_has_bfecc();
  bfecc_ = value;
}

// optional bool bQuiet = 12;
inline bool TPeerCapabilityInfo::has_bquiet() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bquiet() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TPeerCapabilityInfo::clear_has_bquiet() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TPeerCapabilityInfo::clear_bquiet() {
  bquiet_ = false;
  clear_has_bquiet();
}
inline bool TPeerCapabilityInfo::bquiet() const {
  return bquiet_;
}
inline void TPeerCapabilityInfo::set_bquiet(bool value) {
  set_has_bquiet();
  bquiet_ = value;
}

// optional bool bMute = 13;
inline bool TPeerCapabilityInfo::has_bmute() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bmute() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TPeerCapabilityInfo::clear_has_bmute() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TPeerCapabilityInfo::clear_bmute() {
  bmute_ = false;
  clear_has_bmute();
}
inline bool TPeerCapabilityInfo::bmute() const {
  return bmute_;
}
inline void TPeerCapabilityInfo::set_bmute(bool value) {
  set_has_bmute();
  bmute_ = value;
}

// optional bool bConfReq = 14;
inline bool TPeerCapabilityInfo::has_bconfreq() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bconfreq() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TPeerCapabilityInfo::clear_has_bconfreq() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TPeerCapabilityInfo::clear_bconfreq() {
  bconfreq_ = false;
  clear_has_bconfreq();
}
inline bool TPeerCapabilityInfo::bconfreq() const {
  return bconfreq_;
}
inline void TPeerCapabilityInfo::set_bconfreq(bool value) {
  set_has_bconfreq();
  bconfreq_ = value;
}

// optional bool bOnlineList = 15;
inline bool TPeerCapabilityInfo::has_bonlinelist() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bonlinelist() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TPeerCapabilityInfo::clear_has_bonlinelist() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TPeerCapabilityInfo::clear_bonlinelist() {
  bonlinelist_ = false;
  clear_has_bonlinelist();
}
inline bool TPeerCapabilityInfo::bonlinelist() const {
  return bonlinelist_;
}
inline void TPeerCapabilityInfo::set_bonlinelist(bool value) {
  set_has_bonlinelist();
  bonlinelist_ = value;
}

// optional bool bOfflineList = 16;
inline bool TPeerCapabilityInfo::has_bofflinelist() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bofflinelist() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TPeerCapabilityInfo::clear_has_bofflinelist() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TPeerCapabilityInfo::clear_bofflinelist() {
  bofflinelist_ = false;
  clear_has_bofflinelist();
}
inline bool TPeerCapabilityInfo::bofflinelist() const {
  return bofflinelist_;
}
inline void TPeerCapabilityInfo::set_bofflinelist(bool value) {
  set_has_bofflinelist();
  bofflinelist_ = value;
}

// optional bool bPicSwitch = 17;
inline bool TPeerCapabilityInfo::has_bpicswitch() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bpicswitch() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TPeerCapabilityInfo::clear_has_bpicswitch() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TPeerCapabilityInfo::clear_bpicswitch() {
  bpicswitch_ = false;
  clear_has_bpicswitch();
}
inline bool TPeerCapabilityInfo::bpicswitch() const {
  return bpicswitch_;
}
inline void TPeerCapabilityInfo::set_bpicswitch(bool value) {
  set_has_bpicswitch();
  bpicswitch_ = value;
}

// optional bool bSelSpeakingUser = 18;
inline bool TPeerCapabilityInfo::has_bselspeakinguser() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bselspeakinguser() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TPeerCapabilityInfo::clear_has_bselspeakinguser() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TPeerCapabilityInfo::clear_bselspeakinguser() {
  bselspeakinguser_ = false;
  clear_has_bselspeakinguser();
}
inline bool TPeerCapabilityInfo::bselspeakinguser() const {
  return bselspeakinguser_;
}
inline void TPeerCapabilityInfo::set_bselspeakinguser(bool value) {
  set_has_bselspeakinguser();
  bselspeakinguser_ = value;
}

// optional bool bForceBroadcast = 19;
inline bool TPeerCapabilityInfo::has_bforcebroadcast() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TPeerCapabilityInfo::set_has_bforcebroadcast() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TPeerCapabilityInfo::clear_has_bforcebroadcast() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TPeerCapabilityInfo::clear_bforcebroadcast() {
  bforcebroadcast_ = false;
  clear_has_bforcebroadcast();
}
inline bool TPeerCapabilityInfo::bforcebroadcast() const {
  return bforcebroadcast_;
}
inline void TPeerCapabilityInfo::set_bforcebroadcast(bool value) {
  set_has_bforcebroadcast();
  bforcebroadcast_ = value;
}

// -------------------------------------------------------------------

// TMtMixParam

// optional .mt.EmMtMixType discuss_mode = 1;
inline bool TMtMixParam::has_discuss_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtMixParam::set_has_discuss_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtMixParam::clear_has_discuss_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtMixParam::clear_discuss_mode() {
  discuss_mode_ = 0;
  clear_has_discuss_mode();
}
inline ::mt::EmMtMixType TMtMixParam::discuss_mode() const {
  return static_cast< ::mt::EmMtMixType >(discuss_mode_);
}
inline void TMtMixParam::set_discuss_mode(::mt::EmMtMixType value) {
  assert(::mt::EmMtMixType_IsValid(value));
  set_has_discuss_mode();
  discuss_mode_ = value;
}

// optional .mt.TRpMtId mix_item = 2;
inline bool TMtMixParam::has_mix_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtMixParam::set_has_mix_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtMixParam::clear_has_mix_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtMixParam::clear_mix_item() {
  if (mix_item_ != NULL) mix_item_->::mt::TRpMtId::Clear();
  clear_has_mix_item();
}
inline const ::mt::TRpMtId& TMtMixParam::mix_item() const {
  return mix_item_ != NULL ? *mix_item_ : *default_instance_->mix_item_;
}
inline ::mt::TRpMtId* TMtMixParam::mutable_mix_item() {
  set_has_mix_item();
  if (mix_item_ == NULL) mix_item_ = new ::mt::TRpMtId;
  return mix_item_;
}
inline ::mt::TRpMtId* TMtMixParam::release_mix_item() {
  clear_has_mix_item();
  ::mt::TRpMtId* temp = mix_item_;
  mix_item_ = NULL;
  return temp;
}
inline void TMtMixParam::set_allocated_mix_item(::mt::TRpMtId* mix_item) {
  delete mix_item_;
  mix_item_ = mix_item;
  if (mix_item) {
    set_has_mix_item();
  } else {
    clear_has_mix_item();
  }
}

// -------------------------------------------------------------------

// TMtVmpParam

// optional .mt.EmMtVmpMode vmp_mode = 1;
inline bool TMtVmpParam::has_vmp_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtVmpParam::set_has_vmp_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtVmpParam::clear_has_vmp_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtVmpParam::clear_vmp_mode() {
  vmp_mode_ = 0;
  clear_has_vmp_mode();
}
inline ::mt::EmMtVmpMode TMtVmpParam::vmp_mode() const {
  return static_cast< ::mt::EmMtVmpMode >(vmp_mode_);
}
inline void TMtVmpParam::set_vmp_mode(::mt::EmMtVmpMode value) {
  assert(::mt::EmMtVmpMode_IsValid(value));
  set_has_vmp_mode();
  vmp_mode_ = value;
}

// optional .mt.EmMtVmpStyle vmp_style = 2;
inline bool TMtVmpParam::has_vmp_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtVmpParam::set_has_vmp_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtVmpParam::clear_has_vmp_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtVmpParam::clear_vmp_style() {
  vmp_style_ = 0;
  clear_has_vmp_style();
}
inline ::mt::EmMtVmpStyle TMtVmpParam::vmp_style() const {
  return static_cast< ::mt::EmMtVmpStyle >(vmp_style_);
}
inline void TMtVmpParam::set_vmp_style(::mt::EmMtVmpStyle value) {
  assert(::mt::EmMtVmpStyle_IsValid(value));
  set_has_vmp_style();
  vmp_style_ = value;
}

// repeated .mt.TMtVmpItem mt_item = 3;
inline int TMtVmpParam::mt_item_size() const {
  return mt_item_.size();
}
inline void TMtVmpParam::clear_mt_item() {
  mt_item_.Clear();
}
inline const ::mt::TMtVmpItem& TMtVmpParam::mt_item(int index) const {
  return mt_item_.Get(index);
}
inline ::mt::TMtVmpItem* TMtVmpParam::mutable_mt_item(int index) {
  return mt_item_.Mutable(index);
}
inline ::mt::TMtVmpItem* TMtVmpParam::add_mt_item() {
  return mt_item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtVmpItem >&
TMtVmpParam::mt_item() const {
  return mt_item_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtVmpItem >*
TMtVmpParam::mutable_mt_item() {
  return &mt_item_;
}

// optional bool bvmp_broadcast = 4;
inline bool TMtVmpParam::has_bvmp_broadcast() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtVmpParam::set_has_bvmp_broadcast() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtVmpParam::clear_has_bvmp_broadcast() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtVmpParam::clear_bvmp_broadcast() {
  bvmp_broadcast_ = false;
  clear_has_bvmp_broadcast();
}
inline bool TMtVmpParam::bvmp_broadcast() const {
  return bvmp_broadcast_;
}
inline void TMtVmpParam::set_bvmp_broadcast(bool value) {
  set_has_bvmp_broadcast();
  bvmp_broadcast_ = value;
}

// optional bool badd_mmb_alias = 5;
inline bool TMtVmpParam::has_badd_mmb_alias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtVmpParam::set_has_badd_mmb_alias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtVmpParam::clear_has_badd_mmb_alias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtVmpParam::clear_badd_mmb_alias() {
  badd_mmb_alias_ = false;
  clear_has_badd_mmb_alias();
}
inline bool TMtVmpParam::badd_mmb_alias() const {
  return badd_mmb_alias_;
}
inline void TMtVmpParam::set_badd_mmb_alias(bool value) {
  set_has_badd_mmb_alias();
  badd_mmb_alias_ = value;
}

// -------------------------------------------------------------------

// TMtVmpItem

// optional .mt.TMtId mt_id = 1;
inline bool TMtVmpItem::has_mt_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtVmpItem::set_has_mt_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtVmpItem::clear_has_mt_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtVmpItem::clear_mt_id() {
  if (mt_id_ != NULL) mt_id_->::mt::TMtId::Clear();
  clear_has_mt_id();
}
inline const ::mt::TMtId& TMtVmpItem::mt_id() const {
  return mt_id_ != NULL ? *mt_id_ : *default_instance_->mt_id_;
}
inline ::mt::TMtId* TMtVmpItem::mutable_mt_id() {
  set_has_mt_id();
  if (mt_id_ == NULL) mt_id_ = new ::mt::TMtId;
  return mt_id_;
}
inline ::mt::TMtId* TMtVmpItem::release_mt_id() {
  clear_has_mt_id();
  ::mt::TMtId* temp = mt_id_;
  mt_id_ = NULL;
  return temp;
}
inline void TMtVmpItem::set_allocated_mt_id(::mt::TMtId* mt_id) {
  delete mt_id_;
  mt_id_ = mt_id;
  if (mt_id) {
    set_has_mt_id();
  } else {
    clear_has_mt_id();
  }
}

// optional .mt.EmMtVMPMmbType mt_type = 2;
inline bool TMtVmpItem::has_mt_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtVmpItem::set_has_mt_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtVmpItem::clear_has_mt_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtVmpItem::clear_mt_type() {
  mt_type_ = 0;
  clear_has_mt_type();
}
inline ::mt::EmMtVMPMmbType TMtVmpItem::mt_type() const {
  return static_cast< ::mt::EmMtVMPMmbType >(mt_type_);
}
inline void TMtVmpItem::set_mt_type(::mt::EmMtVMPMmbType value) {
  assert(::mt::EmMtVMPMmbType_IsValid(value));
  set_has_mt_type();
  mt_type_ = value;
}

// optional .mt.EmCodecComponentIndex chan_idx = 3;
inline bool TMtVmpItem::has_chan_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtVmpItem::set_has_chan_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtVmpItem::clear_has_chan_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtVmpItem::clear_chan_idx() {
  chan_idx_ = 0;
  clear_has_chan_idx();
}
inline ::mt::EmCodecComponentIndex TMtVmpItem::chan_idx() const {
  return static_cast< ::mt::EmCodecComponentIndex >(chan_idx_);
}
inline void TMtVmpItem::set_chan_idx(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_chan_idx();
  chan_idx_ = value;
}

// optional uint32 mem_idx = 4;
inline bool TMtVmpItem::has_mem_idx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtVmpItem::set_has_mem_idx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtVmpItem::clear_has_mem_idx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtVmpItem::clear_mem_idx() {
  mem_idx_ = 0u;
  clear_has_mem_idx();
}
inline ::google::protobuf::uint32 TMtVmpItem::mem_idx() const {
  return mem_idx_;
}
inline void TMtVmpItem::set_mem_idx(::google::protobuf::uint32 value) {
  set_has_mem_idx();
  mem_idx_ = value;
}

// -------------------------------------------------------------------

// TMtPollInfo

// optional .mt.EmMtMediaType media_type = 1;
inline bool TMtPollInfo::has_media_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtPollInfo::set_has_media_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtPollInfo::clear_has_media_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtPollInfo::clear_media_type() {
  media_type_ = 0;
  clear_has_media_type();
}
inline ::mt::EmMtMediaType TMtPollInfo::media_type() const {
  return static_cast< ::mt::EmMtMediaType >(media_type_);
}
inline void TMtPollInfo::set_media_type(::mt::EmMtMediaType value) {
  assert(::mt::EmMtMediaType_IsValid(value));
  set_has_media_type();
  media_type_ = value;
}

// optional .mt.EmAction action = 2;
inline bool TMtPollInfo::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtPollInfo::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtPollInfo::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtPollInfo::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::mt::EmAction TMtPollInfo::action() const {
  return static_cast< ::mt::EmAction >(action_);
}
inline void TMtPollInfo::set_action(::mt::EmAction value) {
  assert(::mt::EmAction_IsValid(value));
  set_has_action();
  action_ = value;
}

// optional uint32 keep_time = 3;
inline bool TMtPollInfo::has_keep_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtPollInfo::set_has_keep_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtPollInfo::clear_has_keep_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtPollInfo::clear_keep_time() {
  keep_time_ = 0u;
  clear_has_keep_time();
}
inline ::google::protobuf::uint32 TMtPollInfo::keep_time() const {
  return keep_time_;
}
inline void TMtPollInfo::set_keep_time(::google::protobuf::uint32 value) {
  set_has_keep_time();
  keep_time_ = value;
}

// repeated .mt.TMtId mtlist = 4;
inline int TMtPollInfo::mtlist_size() const {
  return mtlist_.size();
}
inline void TMtPollInfo::clear_mtlist() {
  mtlist_.Clear();
}
inline const ::mt::TMtId& TMtPollInfo::mtlist(int index) const {
  return mtlist_.Get(index);
}
inline ::mt::TMtId* TMtPollInfo::mutable_mtlist(int index) {
  return mtlist_.Mutable(index);
}
inline ::mt::TMtId* TMtPollInfo::add_mtlist() {
  return mtlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtId >&
TMtPollInfo::mtlist() const {
  return mtlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtId >*
TMtPollInfo::mutable_mtlist() {
  return &mtlist_;
}

// optional uint32 poll_scheme_id = 5;
inline bool TMtPollInfo::has_poll_scheme_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtPollInfo::set_has_poll_scheme_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtPollInfo::clear_has_poll_scheme_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtPollInfo::clear_poll_scheme_id() {
  poll_scheme_id_ = 0u;
  clear_has_poll_scheme_id();
}
inline ::google::protobuf::uint32 TMtPollInfo::poll_scheme_id() const {
  return poll_scheme_id_;
}
inline void TMtPollInfo::set_poll_scheme_id(::google::protobuf::uint32 value) {
  set_has_poll_scheme_id();
  poll_scheme_id_ = value;
}

// -------------------------------------------------------------------

// TVideoSourceInfo

// optional uint32 vid_port = 1;
inline bool TVideoSourceInfo::has_vid_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVideoSourceInfo::set_has_vid_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVideoSourceInfo::clear_has_vid_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVideoSourceInfo::clear_vid_port() {
  vid_port_ = 0u;
  clear_has_vid_port();
}
inline ::google::protobuf::uint32 TVideoSourceInfo::vid_port() const {
  return vid_port_;
}
inline void TVideoSourceInfo::set_vid_port(::google::protobuf::uint32 value) {
  set_has_vid_port();
  vid_port_ = value;
}

// optional bytes port_name = 2;
inline bool TVideoSourceInfo::has_port_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVideoSourceInfo::set_has_port_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVideoSourceInfo::clear_has_port_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVideoSourceInfo::clear_port_name() {
  if (port_name_ != &::google::protobuf::internal::kEmptyString) {
    port_name_->clear();
  }
  clear_has_port_name();
}
inline const ::std::string& TVideoSourceInfo::port_name() const {
  return *port_name_;
}
inline void TVideoSourceInfo::set_port_name(const ::std::string& value) {
  set_has_port_name();
  if (port_name_ == &::google::protobuf::internal::kEmptyString) {
    port_name_ = new ::std::string;
  }
  port_name_->assign(value);
}
inline void TVideoSourceInfo::set_port_name(const char* value) {
  set_has_port_name();
  if (port_name_ == &::google::protobuf::internal::kEmptyString) {
    port_name_ = new ::std::string;
  }
  port_name_->assign(value);
}
inline void TVideoSourceInfo::set_port_name(const void* value, size_t size) {
  set_has_port_name();
  if (port_name_ == &::google::protobuf::internal::kEmptyString) {
    port_name_ = new ::std::string;
  }
  port_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVideoSourceInfo::mutable_port_name() {
  set_has_port_name();
  if (port_name_ == &::google::protobuf::internal::kEmptyString) {
    port_name_ = new ::std::string;
  }
  return port_name_;
}
inline ::std::string* TVideoSourceInfo::release_port_name() {
  clear_has_port_name();
  if (port_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = port_name_;
    port_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVideoSourceInfo::set_allocated_port_name(::std::string* port_name) {
  if (port_name_ != &::google::protobuf::internal::kEmptyString) {
    delete port_name_;
  }
  if (port_name) {
    set_has_port_name();
    port_name_ = port_name;
  } else {
    clear_has_port_name();
    port_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TRpVideoSourceInfo

// repeated .mt.TVideoSourceInfo vid_source_info = 1;
inline int TRpVideoSourceInfo::vid_source_info_size() const {
  return vid_source_info_.size();
}
inline void TRpVideoSourceInfo::clear_vid_source_info() {
  vid_source_info_.Clear();
}
inline const ::mt::TVideoSourceInfo& TRpVideoSourceInfo::vid_source_info(int index) const {
  return vid_source_info_.Get(index);
}
inline ::mt::TVideoSourceInfo* TRpVideoSourceInfo::mutable_vid_source_info(int index) {
  return vid_source_info_.Mutable(index);
}
inline ::mt::TVideoSourceInfo* TRpVideoSourceInfo::add_vid_source_info() {
  return vid_source_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVideoSourceInfo >&
TRpVideoSourceInfo::vid_source_info() const {
  return vid_source_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVideoSourceInfo >*
TRpVideoSourceInfo::mutable_vid_source_info() {
  return &vid_source_info_;
}

// -------------------------------------------------------------------

// TMtVideoAlias

// optional .mt.EmCodecComponent video_type = 1;
inline bool TMtVideoAlias::has_video_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtVideoAlias::set_has_video_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtVideoAlias::clear_has_video_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtVideoAlias::clear_video_type() {
  video_type_ = 0;
  clear_has_video_type();
}
inline ::mt::EmCodecComponent TMtVideoAlias::video_type() const {
  return static_cast< ::mt::EmCodecComponent >(video_type_);
}
inline void TMtVideoAlias::set_video_type(::mt::EmCodecComponent value) {
  assert(::mt::EmCodecComponent_IsValid(value));
  set_has_video_type();
  video_type_ = value;
}

// optional .mt.EmCodecComponentIndex video_id = 2;
inline bool TMtVideoAlias::has_video_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtVideoAlias::set_has_video_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtVideoAlias::clear_has_video_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtVideoAlias::clear_video_id() {
  video_id_ = 0;
  clear_has_video_id();
}
inline ::mt::EmCodecComponentIndex TMtVideoAlias::video_id() const {
  return static_cast< ::mt::EmCodecComponentIndex >(video_id_);
}
inline void TMtVideoAlias::set_video_id(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_video_id();
  video_id_ = value;
}

// optional .mt.TRpVideoSourceInfo video_source_list = 3;
inline bool TMtVideoAlias::has_video_source_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtVideoAlias::set_has_video_source_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtVideoAlias::clear_has_video_source_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtVideoAlias::clear_video_source_list() {
  if (video_source_list_ != NULL) video_source_list_->::mt::TRpVideoSourceInfo::Clear();
  clear_has_video_source_list();
}
inline const ::mt::TRpVideoSourceInfo& TMtVideoAlias::video_source_list() const {
  return video_source_list_ != NULL ? *video_source_list_ : *default_instance_->video_source_list_;
}
inline ::mt::TRpVideoSourceInfo* TMtVideoAlias::mutable_video_source_list() {
  set_has_video_source_list();
  if (video_source_list_ == NULL) video_source_list_ = new ::mt::TRpVideoSourceInfo;
  return video_source_list_;
}
inline ::mt::TRpVideoSourceInfo* TMtVideoAlias::release_video_source_list() {
  clear_has_video_source_list();
  ::mt::TRpVideoSourceInfo* temp = video_source_list_;
  video_source_list_ = NULL;
  return temp;
}
inline void TMtVideoAlias::set_allocated_video_source_list(::mt::TRpVideoSourceInfo* video_source_list) {
  delete video_source_list_;
  video_source_list_ = video_source_list;
  if (video_source_list) {
    set_has_video_source_list();
  } else {
    clear_has_video_source_list();
  }
}

// -------------------------------------------------------------------

// TRpMtVideoAlias

// repeated .mt.TMtVideoAlias video_alias_list = 1;
inline int TRpMtVideoAlias::video_alias_list_size() const {
  return video_alias_list_.size();
}
inline void TRpMtVideoAlias::clear_video_alias_list() {
  video_alias_list_.Clear();
}
inline const ::mt::TMtVideoAlias& TRpMtVideoAlias::video_alias_list(int index) const {
  return video_alias_list_.Get(index);
}
inline ::mt::TMtVideoAlias* TRpMtVideoAlias::mutable_video_alias_list(int index) {
  return video_alias_list_.Mutable(index);
}
inline ::mt::TMtVideoAlias* TRpMtVideoAlias::add_video_alias_list() {
  return video_alias_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtVideoAlias >&
TRpMtVideoAlias::video_alias_list() const {
  return video_alias_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtVideoAlias >*
TRpMtVideoAlias::mutable_video_alias_list() {
  return &video_alias_list_;
}

// -------------------------------------------------------------------

// TMtEntityStatus

// optional .mt.TMtId label = 1;
inline bool TMtEntityStatus::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtEntityStatus::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtEntityStatus::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtEntityStatus::clear_label() {
  if (label_ != NULL) label_->::mt::TMtId::Clear();
  clear_has_label();
}
inline const ::mt::TMtId& TMtEntityStatus::label() const {
  return label_ != NULL ? *label_ : *default_instance_->label_;
}
inline ::mt::TMtId* TMtEntityStatus::mutable_label() {
  set_has_label();
  if (label_ == NULL) label_ = new ::mt::TMtId;
  return label_;
}
inline ::mt::TMtId* TMtEntityStatus::release_label() {
  clear_has_label();
  ::mt::TMtId* temp = label_;
  label_ = NULL;
  return temp;
}
inline void TMtEntityStatus::set_allocated_label(::mt::TMtId* label) {
  delete label_;
  label_ = label;
  if (label) {
    set_has_label();
  } else {
    clear_has_label();
  }
}

// optional .mt.TTerStatus ter_status = 2;
inline bool TMtEntityStatus::has_ter_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtEntityStatus::set_has_ter_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtEntityStatus::clear_has_ter_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtEntityStatus::clear_ter_status() {
  if (ter_status_ != NULL) ter_status_->::mt::TTerStatus::Clear();
  clear_has_ter_status();
}
inline const ::mt::TTerStatus& TMtEntityStatus::ter_status() const {
  return ter_status_ != NULL ? *ter_status_ : *default_instance_->ter_status_;
}
inline ::mt::TTerStatus* TMtEntityStatus::mutable_ter_status() {
  set_has_ter_status();
  if (ter_status_ == NULL) ter_status_ = new ::mt::TTerStatus;
  return ter_status_;
}
inline ::mt::TTerStatus* TMtEntityStatus::release_ter_status() {
  clear_has_ter_status();
  ::mt::TTerStatus* temp = ter_status_;
  ter_status_ = NULL;
  return temp;
}
inline void TMtEntityStatus::set_allocated_ter_status(::mt::TTerStatus* ter_status) {
  delete ter_status_;
  ter_status_ = ter_status;
  if (ter_status) {
    set_has_ter_status();
  } else {
    clear_has_ter_status();
  }
}

// -------------------------------------------------------------------

// TRpMtEntityStatus

// repeated .mt.TMtEntityStatus mt_status = 1;
inline int TRpMtEntityStatus::mt_status_size() const {
  return mt_status_.size();
}
inline void TRpMtEntityStatus::clear_mt_status() {
  mt_status_.Clear();
}
inline const ::mt::TMtEntityStatus& TRpMtEntityStatus::mt_status(int index) const {
  return mt_status_.Get(index);
}
inline ::mt::TMtEntityStatus* TRpMtEntityStatus::mutable_mt_status(int index) {
  return mt_status_.Mutable(index);
}
inline ::mt::TMtEntityStatus* TRpMtEntityStatus::add_mt_status() {
  return mt_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtEntityStatus >&
TRpMtEntityStatus::mt_status() const {
  return mt_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtEntityStatus >*
TRpMtEntityStatus::mutable_mt_status() {
  return &mt_status_;
}

// -------------------------------------------------------------------

// TVideoInfo

// optional uint32 id = 1;
inline bool TVideoInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVideoInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVideoInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVideoInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TVideoInfo::id() const {
  return id_;
}
inline void TVideoInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional bool bfecc_enable = 2;
inline bool TVideoInfo::has_bfecc_enable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVideoInfo::set_has_bfecc_enable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVideoInfo::clear_has_bfecc_enable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVideoInfo::clear_bfecc_enable() {
  bfecc_enable_ = false;
  clear_has_bfecc_enable();
}
inline bool TVideoInfo::bfecc_enable() const {
  return bfecc_enable_;
}
inline void TVideoInfo::set_bfecc_enable(bool value) {
  set_has_bfecc_enable();
  bfecc_enable_ = value;
}

// optional bool has_video = 3;
inline bool TVideoInfo::has_has_video() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVideoInfo::set_has_has_video() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVideoInfo::clear_has_has_video() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVideoInfo::clear_has_video() {
  has_video_ = false;
  clear_has_has_video();
}
inline bool TVideoInfo::has_video() const {
  return has_video_;
}
inline void TVideoInfo::set_has_video(bool value) {
  set_has_has_video();
  has_video_ = value;
}

// optional uint32 video_src = 4;
inline bool TVideoInfo::has_video_src() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVideoInfo::set_has_video_src() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVideoInfo::clear_has_video_src() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVideoInfo::clear_video_src() {
  video_src_ = 0u;
  clear_has_video_src();
}
inline ::google::protobuf::uint32 TVideoInfo::video_src() const {
  return video_src_;
}
inline void TVideoInfo::set_video_src(::google::protobuf::uint32 value) {
  set_has_video_src();
  video_src_ = value;
}

// -------------------------------------------------------------------

// TRpVideoInfo

// repeated .mt.TVideoInfo videoinfo = 1;
inline int TRpVideoInfo::videoinfo_size() const {
  return videoinfo_.size();
}
inline void TRpVideoInfo::clear_videoinfo() {
  videoinfo_.Clear();
}
inline const ::mt::TVideoInfo& TRpVideoInfo::videoinfo(int index) const {
  return videoinfo_.Get(index);
}
inline ::mt::TVideoInfo* TRpVideoInfo::mutable_videoinfo(int index) {
  return videoinfo_.Mutable(index);
}
inline ::mt::TVideoInfo* TRpVideoInfo::add_videoinfo() {
  return videoinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVideoInfo >&
TRpVideoInfo::videoinfo() const {
  return videoinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVideoInfo >*
TRpVideoInfo::mutable_videoinfo() {
  return &videoinfo_;
}

// -------------------------------------------------------------------

// TTerStatus

// optional .mt.EmMtModel mt_model = 1;
inline bool TTerStatus::has_mt_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TTerStatus::set_has_mt_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TTerStatus::clear_has_mt_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TTerStatus::clear_mt_model() {
  mt_model_ = 0;
  clear_has_mt_model();
}
inline ::mt::EmMtModel TTerStatus::mt_model() const {
  return static_cast< ::mt::EmMtModel >(mt_model_);
}
inline void TTerStatus::set_mt_model(::mt::EmMtModel value) {
  assert(::mt::EmMtModel_IsValid(value));
  set_has_mt_model();
  mt_model_ = value;
}

// optional uint32 enc_vol = 2;
inline bool TTerStatus::has_enc_vol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TTerStatus::set_has_enc_vol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TTerStatus::clear_has_enc_vol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TTerStatus::clear_enc_vol() {
  enc_vol_ = 0u;
  clear_has_enc_vol();
}
inline ::google::protobuf::uint32 TTerStatus::enc_vol() const {
  return enc_vol_;
}
inline void TTerStatus::set_enc_vol(::google::protobuf::uint32 value) {
  set_has_enc_vol();
  enc_vol_ = value;
}

// optional uint32 dec_vol = 3;
inline bool TTerStatus::has_dec_vol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TTerStatus::set_has_dec_vol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TTerStatus::clear_has_dec_vol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TTerStatus::clear_dec_vol() {
  dec_vol_ = 0u;
  clear_has_dec_vol();
}
inline ::google::protobuf::uint32 TTerStatus::dec_vol() const {
  return dec_vol_;
}
inline void TTerStatus::set_dec_vol(::google::protobuf::uint32 value) {
  set_has_dec_vol();
  dec_vol_ = value;
}

// optional bool bmute = 4;
inline bool TTerStatus::has_bmute() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TTerStatus::set_has_bmute() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TTerStatus::clear_has_bmute() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TTerStatus::clear_bmute() {
  bmute_ = false;
  clear_has_bmute();
}
inline bool TTerStatus::bmute() const {
  return bmute_;
}
inline void TTerStatus::set_bmute(bool value) {
  set_has_bmute();
  bmute_ = value;
}

// optional bool bquiet = 5;
inline bool TTerStatus::has_bquiet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TTerStatus::set_has_bquiet() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TTerStatus::clear_has_bquiet() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TTerStatus::clear_bquiet() {
  bquiet_ = false;
  clear_has_bquiet();
}
inline bool TTerStatus::bquiet() const {
  return bquiet_;
}
inline void TTerStatus::set_bquiet(bool value) {
  set_has_bquiet();
  bquiet_ = value;
}

// optional bool bmatrix = 6;
inline bool TTerStatus::has_bmatrix() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TTerStatus::set_has_bmatrix() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TTerStatus::clear_has_bmatrix() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TTerStatus::clear_bmatrix() {
  bmatrix_ = false;
  clear_has_bmatrix();
}
inline bool TTerStatus::bmatrix() const {
  return bmatrix_;
}
inline void TTerStatus::set_bmatrix(bool value) {
  set_has_bmatrix();
  bmatrix_ = value;
}

// repeated .mt.TVideoInfo videoinfo = 7;
inline int TTerStatus::videoinfo_size() const {
  return videoinfo_.size();
}
inline void TTerStatus::clear_videoinfo() {
  videoinfo_.Clear();
}
inline const ::mt::TVideoInfo& TTerStatus::videoinfo(int index) const {
  return videoinfo_.Get(index);
}
inline ::mt::TVideoInfo* TTerStatus::mutable_videoinfo(int index) {
  return videoinfo_.Mutable(index);
}
inline ::mt::TVideoInfo* TTerStatus::add_videoinfo() {
  return videoinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TVideoInfo >&
TTerStatus::videoinfo() const {
  return videoinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TVideoInfo >*
TTerStatus::mutable_videoinfo() {
  return &videoinfo_;
}

// optional .mt.EmMtMediaType view_type = 8;
inline bool TTerStatus::has_view_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TTerStatus::set_has_view_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TTerStatus::clear_has_view_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TTerStatus::clear_view_type() {
  view_type_ = 0;
  clear_has_view_type();
}
inline ::mt::EmMtMediaType TTerStatus::view_type() const {
  return static_cast< ::mt::EmMtMediaType >(view_type_);
}
inline void TTerStatus::set_view_type(::mt::EmMtMediaType value) {
  assert(::mt::EmMtMediaType_IsValid(value));
  set_has_view_type();
  view_type_ = value;
}

// -------------------------------------------------------------------

// TShortMsg

// optional .mt.EmSMSType sms_type = 1;
inline bool TShortMsg::has_sms_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TShortMsg::set_has_sms_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TShortMsg::clear_has_sms_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TShortMsg::clear_sms_type() {
  sms_type_ = 0;
  clear_has_sms_type();
}
inline ::mt::EmSMSType TShortMsg::sms_type() const {
  return static_cast< ::mt::EmSMSType >(sms_type_);
}
inline void TShortMsg::set_sms_type(::mt::EmSMSType value) {
  assert(::mt::EmSMSType_IsValid(value));
  set_has_sms_type();
  sms_type_ = value;
}

// optional .mt.TMtId mt_src = 2;
inline bool TShortMsg::has_mt_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TShortMsg::set_has_mt_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TShortMsg::clear_has_mt_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TShortMsg::clear_mt_src() {
  if (mt_src_ != NULL) mt_src_->::mt::TMtId::Clear();
  clear_has_mt_src();
}
inline const ::mt::TMtId& TShortMsg::mt_src() const {
  return mt_src_ != NULL ? *mt_src_ : *default_instance_->mt_src_;
}
inline ::mt::TMtId* TShortMsg::mutable_mt_src() {
  set_has_mt_src();
  if (mt_src_ == NULL) mt_src_ = new ::mt::TMtId;
  return mt_src_;
}
inline ::mt::TMtId* TShortMsg::release_mt_src() {
  clear_has_mt_src();
  ::mt::TMtId* temp = mt_src_;
  mt_src_ = NULL;
  return temp;
}
inline void TShortMsg::set_allocated_mt_src(::mt::TMtId* mt_src) {
  delete mt_src_;
  mt_src_ = mt_src;
  if (mt_src) {
    set_has_mt_src();
  } else {
    clear_has_mt_src();
  }
}

// repeated .mt.TMtId mt_dst = 3;
inline int TShortMsg::mt_dst_size() const {
  return mt_dst_.size();
}
inline void TShortMsg::clear_mt_dst() {
  mt_dst_.Clear();
}
inline const ::mt::TMtId& TShortMsg::mt_dst(int index) const {
  return mt_dst_.Get(index);
}
inline ::mt::TMtId* TShortMsg::mutable_mt_dst(int index) {
  return mt_dst_.Mutable(index);
}
inline ::mt::TMtId* TShortMsg::add_mt_dst() {
  return mt_dst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtId >&
TShortMsg::mt_dst() const {
  return mt_dst_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtId >*
TShortMsg::mutable_mt_dst() {
  return &mt_dst_;
}

// optional .mt.EmRollMsgSpeed roll_speed = 4;
inline bool TShortMsg::has_roll_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TShortMsg::set_has_roll_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TShortMsg::clear_has_roll_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TShortMsg::clear_roll_speed() {
  roll_speed_ = 1;
  clear_has_roll_speed();
}
inline ::mt::EmRollMsgSpeed TShortMsg::roll_speed() const {
  return static_cast< ::mt::EmRollMsgSpeed >(roll_speed_);
}
inline void TShortMsg::set_roll_speed(::mt::EmRollMsgSpeed value) {
  assert(::mt::EmRollMsgSpeed_IsValid(value));
  set_has_roll_speed();
  roll_speed_ = value;
}

// optional uint32 roll_times = 5;
inline bool TShortMsg::has_roll_times() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TShortMsg::set_has_roll_times() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TShortMsg::clear_has_roll_times() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TShortMsg::clear_roll_times() {
  roll_times_ = 0u;
  clear_has_roll_times();
}
inline ::google::protobuf::uint32 TShortMsg::roll_times() const {
  return roll_times_;
}
inline void TShortMsg::set_roll_times(::google::protobuf::uint32 value) {
  set_has_roll_times();
  roll_times_ = value;
}

// optional string text = 6;
inline bool TShortMsg::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TShortMsg::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TShortMsg::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TShortMsg::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& TShortMsg::text() const {
  return *text_;
}
inline void TShortMsg::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TShortMsg::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TShortMsg::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TShortMsg::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* TShortMsg::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TShortMsg::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtRegistReq

// optional .mt.TRpMtAlias alias = 1;
inline bool TMtRegistReq::has_alias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtRegistReq::set_has_alias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtRegistReq::clear_has_alias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtRegistReq::clear_alias() {
  if (alias_ != NULL) alias_->::mt::TRpMtAlias::Clear();
  clear_has_alias();
}
inline const ::mt::TRpMtAlias& TMtRegistReq::alias() const {
  return alias_ != NULL ? *alias_ : *default_instance_->alias_;
}
inline ::mt::TRpMtAlias* TMtRegistReq::mutable_alias() {
  set_has_alias();
  if (alias_ == NULL) alias_ = new ::mt::TRpMtAlias;
  return alias_;
}
inline ::mt::TRpMtAlias* TMtRegistReq::release_alias() {
  clear_has_alias();
  ::mt::TRpMtAlias* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline void TMtRegistReq::set_allocated_alias(::mt::TRpMtAlias* alias) {
  delete alias_;
  alias_ = alias;
  if (alias) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
}

// optional .mt.TNetAddr local_addr = 2;
inline bool TMtRegistReq::has_local_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtRegistReq::set_has_local_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtRegistReq::clear_has_local_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtRegistReq::clear_local_addr() {
  if (local_addr_ != NULL) local_addr_->::mt::TNetAddr::Clear();
  clear_has_local_addr();
}
inline const ::mt::TNetAddr& TMtRegistReq::local_addr() const {
  return local_addr_ != NULL ? *local_addr_ : *default_instance_->local_addr_;
}
inline ::mt::TNetAddr* TMtRegistReq::mutable_local_addr() {
  set_has_local_addr();
  if (local_addr_ == NULL) local_addr_ = new ::mt::TNetAddr;
  return local_addr_;
}
inline ::mt::TNetAddr* TMtRegistReq::release_local_addr() {
  clear_has_local_addr();
  ::mt::TNetAddr* temp = local_addr_;
  local_addr_ = NULL;
  return temp;
}
inline void TMtRegistReq::set_allocated_local_addr(::mt::TNetAddr* local_addr) {
  delete local_addr_;
  local_addr_ = local_addr;
  if (local_addr) {
    set_has_local_addr();
  } else {
    clear_has_local_addr();
  }
}

// optional .mt.TNetAddr gk_addr = 3;
inline bool TMtRegistReq::has_gk_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtRegistReq::set_has_gk_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtRegistReq::clear_has_gk_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtRegistReq::clear_gk_addr() {
  if (gk_addr_ != NULL) gk_addr_->::mt::TNetAddr::Clear();
  clear_has_gk_addr();
}
inline const ::mt::TNetAddr& TMtRegistReq::gk_addr() const {
  return gk_addr_ != NULL ? *gk_addr_ : *default_instance_->gk_addr_;
}
inline ::mt::TNetAddr* TMtRegistReq::mutable_gk_addr() {
  set_has_gk_addr();
  if (gk_addr_ == NULL) gk_addr_ = new ::mt::TNetAddr;
  return gk_addr_;
}
inline ::mt::TNetAddr* TMtRegistReq::release_gk_addr() {
  clear_has_gk_addr();
  ::mt::TNetAddr* temp = gk_addr_;
  gk_addr_ = NULL;
  return temp;
}
inline void TMtRegistReq::set_allocated_gk_addr(::mt::TNetAddr* gk_addr) {
  delete gk_addr_;
  gk_addr_ = gk_addr;
  if (gk_addr) {
    set_has_gk_addr();
  } else {
    clear_has_gk_addr();
  }
}

// optional .mt.TNetAddr sip_reg_addr = 4;
inline bool TMtRegistReq::has_sip_reg_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtRegistReq::set_has_sip_reg_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtRegistReq::clear_has_sip_reg_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtRegistReq::clear_sip_reg_addr() {
  if (sip_reg_addr_ != NULL) sip_reg_addr_->::mt::TNetAddr::Clear();
  clear_has_sip_reg_addr();
}
inline const ::mt::TNetAddr& TMtRegistReq::sip_reg_addr() const {
  return sip_reg_addr_ != NULL ? *sip_reg_addr_ : *default_instance_->sip_reg_addr_;
}
inline ::mt::TNetAddr* TMtRegistReq::mutable_sip_reg_addr() {
  set_has_sip_reg_addr();
  if (sip_reg_addr_ == NULL) sip_reg_addr_ = new ::mt::TNetAddr;
  return sip_reg_addr_;
}
inline ::mt::TNetAddr* TMtRegistReq::release_sip_reg_addr() {
  clear_has_sip_reg_addr();
  ::mt::TNetAddr* temp = sip_reg_addr_;
  sip_reg_addr_ = NULL;
  return temp;
}
inline void TMtRegistReq::set_allocated_sip_reg_addr(::mt::TNetAddr* sip_reg_addr) {
  delete sip_reg_addr_;
  sip_reg_addr_ = sip_reg_addr;
  if (sip_reg_addr) {
    set_has_sip_reg_addr();
  } else {
    clear_has_sip_reg_addr();
  }
}

// optional uint32 time_live = 5;
inline bool TMtRegistReq::has_time_live() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtRegistReq::set_has_time_live() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtRegistReq::clear_has_time_live() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtRegistReq::clear_time_live() {
  time_live_ = 0u;
  clear_has_time_live();
}
inline ::google::protobuf::uint32 TMtRegistReq::time_live() const {
  return time_live_;
}
inline void TMtRegistReq::set_time_live(::google::protobuf::uint32 value) {
  set_has_time_live();
  time_live_ = value;
}

// optional .mt.TMtAlias username = 6;
inline bool TMtRegistReq::has_username() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtRegistReq::set_has_username() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtRegistReq::clear_has_username() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtRegistReq::clear_username() {
  if (username_ != NULL) username_->::mt::TMtAlias::Clear();
  clear_has_username();
}
inline const ::mt::TMtAlias& TMtRegistReq::username() const {
  return username_ != NULL ? *username_ : *default_instance_->username_;
}
inline ::mt::TMtAlias* TMtRegistReq::mutable_username() {
  set_has_username();
  if (username_ == NULL) username_ = new ::mt::TMtAlias;
  return username_;
}
inline ::mt::TMtAlias* TMtRegistReq::release_username() {
  clear_has_username();
  ::mt::TMtAlias* temp = username_;
  username_ = NULL;
  return temp;
}
inline void TMtRegistReq::set_allocated_username(::mt::TMtAlias* username) {
  delete username_;
  username_ = username;
  if (username) {
    set_has_username();
  } else {
    clear_has_username();
  }
}

// optional string password = 7;
inline bool TMtRegistReq::has_password() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtRegistReq::set_has_password() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtRegistReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtRegistReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtRegistReq::password() const {
  return *password_;
}
inline void TMtRegistReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtRegistReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtRegistReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtRegistReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtRegistReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtRegistReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string productid = 8;
inline bool TMtRegistReq::has_productid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtRegistReq::set_has_productid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtRegistReq::clear_has_productid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtRegistReq::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& TMtRegistReq::productid() const {
  return *productid_;
}
inline void TMtRegistReq::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void TMtRegistReq::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void TMtRegistReq::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtRegistReq::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* TMtRegistReq::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtRegistReq::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string versionid = 9;
inline bool TMtRegistReq::has_versionid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMtRegistReq::set_has_versionid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMtRegistReq::clear_has_versionid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMtRegistReq::clear_versionid() {
  if (versionid_ != &::google::protobuf::internal::kEmptyString) {
    versionid_->clear();
  }
  clear_has_versionid();
}
inline const ::std::string& TMtRegistReq::versionid() const {
  return *versionid_;
}
inline void TMtRegistReq::set_versionid(const ::std::string& value) {
  set_has_versionid();
  if (versionid_ == &::google::protobuf::internal::kEmptyString) {
    versionid_ = new ::std::string;
  }
  versionid_->assign(value);
}
inline void TMtRegistReq::set_versionid(const char* value) {
  set_has_versionid();
  if (versionid_ == &::google::protobuf::internal::kEmptyString) {
    versionid_ = new ::std::string;
  }
  versionid_->assign(value);
}
inline void TMtRegistReq::set_versionid(const char* value, size_t size) {
  set_has_versionid();
  if (versionid_ == &::google::protobuf::internal::kEmptyString) {
    versionid_ = new ::std::string;
  }
  versionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtRegistReq::mutable_versionid() {
  set_has_versionid();
  if (versionid_ == &::google::protobuf::internal::kEmptyString) {
    versionid_ = new ::std::string;
  }
  return versionid_;
}
inline ::std::string* TMtRegistReq::release_versionid() {
  clear_has_versionid();
  if (versionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = versionid_;
    versionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtRegistReq::set_allocated_versionid(::std::string* versionid) {
  if (versionid_ != &::google::protobuf::internal::kEmptyString) {
    delete versionid_;
  }
  if (versionid) {
    set_has_versionid();
    versionid_ = versionid;
  } else {
    clear_has_versionid();
    versionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sip_domain = 10;
inline bool TMtRegistReq::has_sip_domain() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMtRegistReq::set_has_sip_domain() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMtRegistReq::clear_has_sip_domain() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMtRegistReq::clear_sip_domain() {
  if (sip_domain_ != &::google::protobuf::internal::kEmptyString) {
    sip_domain_->clear();
  }
  clear_has_sip_domain();
}
inline const ::std::string& TMtRegistReq::sip_domain() const {
  return *sip_domain_;
}
inline void TMtRegistReq::set_sip_domain(const ::std::string& value) {
  set_has_sip_domain();
  if (sip_domain_ == &::google::protobuf::internal::kEmptyString) {
    sip_domain_ = new ::std::string;
  }
  sip_domain_->assign(value);
}
inline void TMtRegistReq::set_sip_domain(const char* value) {
  set_has_sip_domain();
  if (sip_domain_ == &::google::protobuf::internal::kEmptyString) {
    sip_domain_ = new ::std::string;
  }
  sip_domain_->assign(value);
}
inline void TMtRegistReq::set_sip_domain(const char* value, size_t size) {
  set_has_sip_domain();
  if (sip_domain_ == &::google::protobuf::internal::kEmptyString) {
    sip_domain_ = new ::std::string;
  }
  sip_domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtRegistReq::mutable_sip_domain() {
  set_has_sip_domain();
  if (sip_domain_ == &::google::protobuf::internal::kEmptyString) {
    sip_domain_ = new ::std::string;
  }
  return sip_domain_;
}
inline ::std::string* TMtRegistReq::release_sip_domain() {
  clear_has_sip_domain();
  if (sip_domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sip_domain_;
    sip_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtRegistReq::set_allocated_sip_domain(::std::string* sip_domain) {
  if (sip_domain_ != &::google::protobuf::internal::kEmptyString) {
    delete sip_domain_;
  }
  if (sip_domain) {
    set_has_sip_domain();
    sip_domain_ = sip_domain;
  } else {
    clear_has_sip_domain();
    sip_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string domain = 11;
inline bool TMtRegistReq::has_domain() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMtRegistReq::set_has_domain() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMtRegistReq::clear_has_domain() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMtRegistReq::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TMtRegistReq::domain() const {
  return *domain_;
}
inline void TMtRegistReq::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtRegistReq::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TMtRegistReq::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtRegistReq::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TMtRegistReq::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtRegistReq::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TGkRegInfo

// optional bool bregisted = 1;
inline bool TGkRegInfo::has_bregisted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGkRegInfo::set_has_bregisted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGkRegInfo::clear_has_bregisted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGkRegInfo::clear_bregisted() {
  bregisted_ = false;
  clear_has_bregisted();
}
inline bool TGkRegInfo::bregisted() const {
  return bregisted_;
}
inline void TGkRegInfo::set_bregisted(bool value) {
  set_has_bregisted();
  bregisted_ = value;
}

// optional .mt.EmRegFailedReason reason = 2;
inline bool TGkRegInfo::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TGkRegInfo::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TGkRegInfo::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TGkRegInfo::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::mt::EmRegFailedReason TGkRegInfo::reason() const {
  return static_cast< ::mt::EmRegFailedReason >(reason_);
}
inline void TGkRegInfo::set_reason(::mt::EmRegFailedReason value) {
  assert(::mt::EmRegFailedReason_IsValid(value));
  set_has_reason();
  reason_ = value;
}

// optional bool bauth_ok = 3;
inline bool TGkRegInfo::has_bauth_ok() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TGkRegInfo::set_has_bauth_ok() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TGkRegInfo::clear_has_bauth_ok() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TGkRegInfo::clear_bauth_ok() {
  bauth_ok_ = false;
  clear_has_bauth_ok();
}
inline bool TGkRegInfo::bauth_ok() const {
  return bauth_ok_;
}
inline void TGkRegInfo::set_bauth_ok(bool value) {
  set_has_bauth_ok();
  bauth_ok_ = value;
}

// -------------------------------------------------------------------

// TH323StackHandle

// optional int64 call = 1;
inline bool TH323StackHandle::has_call() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TH323StackHandle::set_has_call() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TH323StackHandle::clear_has_call() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TH323StackHandle::clear_call() {
  call_ = GOOGLE_LONGLONG(0);
  clear_has_call();
}
inline ::google::protobuf::int64 TH323StackHandle::call() const {
  return call_;
}
inline void TH323StackHandle::set_call(::google::protobuf::int64 value) {
  set_has_call();
  call_ = value;
}

// optional int64 app_call = 2;
inline bool TH323StackHandle::has_app_call() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TH323StackHandle::set_has_app_call() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TH323StackHandle::clear_has_app_call() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TH323StackHandle::clear_app_call() {
  app_call_ = GOOGLE_LONGLONG(0);
  clear_has_app_call();
}
inline ::google::protobuf::int64 TH323StackHandle::app_call() const {
  return app_call_;
}
inline void TH323StackHandle::set_app_call(::google::protobuf::int64 value) {
  set_has_app_call();
  app_call_ = value;
}

// optional int64 chan = 3;
inline bool TH323StackHandle::has_chan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TH323StackHandle::set_has_chan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TH323StackHandle::clear_has_chan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TH323StackHandle::clear_chan() {
  chan_ = GOOGLE_LONGLONG(0);
  clear_has_chan();
}
inline ::google::protobuf::int64 TH323StackHandle::chan() const {
  return chan_;
}
inline void TH323StackHandle::set_chan(::google::protobuf::int64 value) {
  set_has_chan();
  chan_ = value;
}

// optional int64 app_chan = 4;
inline bool TH323StackHandle::has_app_chan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TH323StackHandle::set_has_app_chan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TH323StackHandle::clear_has_app_chan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TH323StackHandle::clear_app_chan() {
  app_chan_ = GOOGLE_LONGLONG(0);
  clear_has_app_chan();
}
inline ::google::protobuf::int64 TH323StackHandle::app_chan() const {
  return app_chan_;
}
inline void TH323StackHandle::set_app_chan(::google::protobuf::int64 value) {
  set_has_app_chan();
  app_chan_ = value;
}

// optional int64 ras = 5;
inline bool TH323StackHandle::has_ras() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TH323StackHandle::set_has_ras() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TH323StackHandle::clear_has_ras() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TH323StackHandle::clear_ras() {
  ras_ = GOOGLE_LONGLONG(0);
  clear_has_ras();
}
inline ::google::protobuf::int64 TH323StackHandle::ras() const {
  return ras_;
}
inline void TH323StackHandle::set_ras(::google::protobuf::int64 value) {
  set_has_ras();
  ras_ = value;
}

// optional int64 app_ras = 6;
inline bool TH323StackHandle::has_app_ras() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TH323StackHandle::set_has_app_ras() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TH323StackHandle::clear_has_app_ras() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TH323StackHandle::clear_app_ras() {
  app_ras_ = GOOGLE_LONGLONG(0);
  clear_has_app_ras();
}
inline ::google::protobuf::int64 TH323StackHandle::app_ras() const {
  return app_ras_;
}
inline void TH323StackHandle::set_app_ras(::google::protobuf::int64 value) {
  set_has_app_ras();
  app_ras_ = value;
}

// -------------------------------------------------------------------

// TMtRCFInfo

// optional .mt.TMtAlias endpoint_id = 1;
inline bool TMtRCFInfo::has_endpoint_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtRCFInfo::set_has_endpoint_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtRCFInfo::clear_has_endpoint_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtRCFInfo::clear_endpoint_id() {
  if (endpoint_id_ != NULL) endpoint_id_->::mt::TMtAlias::Clear();
  clear_has_endpoint_id();
}
inline const ::mt::TMtAlias& TMtRCFInfo::endpoint_id() const {
  return endpoint_id_ != NULL ? *endpoint_id_ : *default_instance_->endpoint_id_;
}
inline ::mt::TMtAlias* TMtRCFInfo::mutable_endpoint_id() {
  set_has_endpoint_id();
  if (endpoint_id_ == NULL) endpoint_id_ = new ::mt::TMtAlias;
  return endpoint_id_;
}
inline ::mt::TMtAlias* TMtRCFInfo::release_endpoint_id() {
  clear_has_endpoint_id();
  ::mt::TMtAlias* temp = endpoint_id_;
  endpoint_id_ = NULL;
  return temp;
}
inline void TMtRCFInfo::set_allocated_endpoint_id(::mt::TMtAlias* endpoint_id) {
  delete endpoint_id_;
  endpoint_id_ = endpoint_id;
  if (endpoint_id) {
    set_has_endpoint_id();
  } else {
    clear_has_endpoint_id();
  }
}

// optional .mt.TMtAlias gk_id = 2;
inline bool TMtRCFInfo::has_gk_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtRCFInfo::set_has_gk_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtRCFInfo::clear_has_gk_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtRCFInfo::clear_gk_id() {
  if (gk_id_ != NULL) gk_id_->::mt::TMtAlias::Clear();
  clear_has_gk_id();
}
inline const ::mt::TMtAlias& TMtRCFInfo::gk_id() const {
  return gk_id_ != NULL ? *gk_id_ : *default_instance_->gk_id_;
}
inline ::mt::TMtAlias* TMtRCFInfo::mutable_gk_id() {
  set_has_gk_id();
  if (gk_id_ == NULL) gk_id_ = new ::mt::TMtAlias;
  return gk_id_;
}
inline ::mt::TMtAlias* TMtRCFInfo::release_gk_id() {
  clear_has_gk_id();
  ::mt::TMtAlias* temp = gk_id_;
  gk_id_ = NULL;
  return temp;
}
inline void TMtRCFInfo::set_allocated_gk_id(::mt::TMtAlias* gk_id) {
  delete gk_id_;
  gk_id_ = gk_id;
  if (gk_id) {
    set_has_gk_id();
  } else {
    clear_has_gk_id();
  }
}

// optional uint32 timetolive = 3;
inline bool TMtRCFInfo::has_timetolive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtRCFInfo::set_has_timetolive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtRCFInfo::clear_has_timetolive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtRCFInfo::clear_timetolive() {
  timetolive_ = 0u;
  clear_has_timetolive();
}
inline ::google::protobuf::uint32 TMtRCFInfo::timetolive() const {
  return timetolive_;
}
inline void TMtRCFInfo::set_timetolive(::google::protobuf::uint32 value) {
  set_has_timetolive();
  timetolive_ = value;
}

// -------------------------------------------------------------------

// TMtACFInfo

// optional uint32 gk_bandwidth = 1;
inline bool TMtACFInfo::has_gk_bandwidth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtACFInfo::set_has_gk_bandwidth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtACFInfo::clear_has_gk_bandwidth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtACFInfo::clear_gk_bandwidth() {
  gk_bandwidth_ = 0u;
  clear_has_gk_bandwidth();
}
inline ::google::protobuf::uint32 TMtACFInfo::gk_bandwidth() const {
  return gk_bandwidth_;
}
inline void TMtACFInfo::set_gk_bandwidth(::google::protobuf::uint32 value) {
  set_has_gk_bandwidth();
  gk_bandwidth_ = value;
}

// optional .mt.TNetAddr peer_addr = 2;
inline bool TMtACFInfo::has_peer_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtACFInfo::set_has_peer_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtACFInfo::clear_has_peer_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtACFInfo::clear_peer_addr() {
  if (peer_addr_ != NULL) peer_addr_->::mt::TNetAddr::Clear();
  clear_has_peer_addr();
}
inline const ::mt::TNetAddr& TMtACFInfo::peer_addr() const {
  return peer_addr_ != NULL ? *peer_addr_ : *default_instance_->peer_addr_;
}
inline ::mt::TNetAddr* TMtACFInfo::mutable_peer_addr() {
  set_has_peer_addr();
  if (peer_addr_ == NULL) peer_addr_ = new ::mt::TNetAddr;
  return peer_addr_;
}
inline ::mt::TNetAddr* TMtACFInfo::release_peer_addr() {
  clear_has_peer_addr();
  ::mt::TNetAddr* temp = peer_addr_;
  peer_addr_ = NULL;
  return temp;
}
inline void TMtACFInfo::set_allocated_peer_addr(::mt::TNetAddr* peer_addr) {
  delete peer_addr_;
  peer_addr_ = peer_addr;
  if (peer_addr) {
    set_has_peer_addr();
  } else {
    clear_has_peer_addr();
  }
}

// -------------------------------------------------------------------

// TMtFeccMsg

// optional uint32 action = 1;
inline bool TMtFeccMsg::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtFeccMsg::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtFeccMsg::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtFeccMsg::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 TMtFeccMsg::action() const {
  return action_;
}
inline void TMtFeccMsg::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
}

// optional uint32 request = 2;
inline bool TMtFeccMsg::has_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtFeccMsg::set_has_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtFeccMsg::clear_has_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtFeccMsg::clear_request() {
  request_ = 0u;
  clear_has_request();
}
inline ::google::protobuf::uint32 TMtFeccMsg::request() const {
  return request_;
}
inline void TMtFeccMsg::set_request(::google::protobuf::uint32 value) {
  set_has_request();
  request_ = value;
}

// optional uint32 sourceno = 3;
inline bool TMtFeccMsg::has_sourceno() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtFeccMsg::set_has_sourceno() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtFeccMsg::clear_has_sourceno() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtFeccMsg::clear_sourceno() {
  sourceno_ = 0u;
  clear_has_sourceno();
}
inline ::google::protobuf::uint32 TMtFeccMsg::sourceno() const {
  return sourceno_;
}
inline void TMtFeccMsg::set_sourceno(::google::protobuf::uint32 value) {
  set_has_sourceno();
  sourceno_ = value;
}

// optional uint32 presetno = 4;
inline bool TMtFeccMsg::has_presetno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtFeccMsg::set_has_presetno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtFeccMsg::clear_has_presetno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtFeccMsg::clear_presetno() {
  presetno_ = 0u;
  clear_has_presetno();
}
inline ::google::protobuf::uint32 TMtFeccMsg::presetno() const {
  return presetno_;
}
inline void TMtFeccMsg::set_presetno(::google::protobuf::uint32 value) {
  set_has_presetno();
  presetno_ = value;
}

// optional uint32 timeout = 5;
inline bool TMtFeccMsg::has_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtFeccMsg::set_has_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtFeccMsg::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtFeccMsg::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TMtFeccMsg::timeout() const {
  return timeout_;
}
inline void TMtFeccMsg::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional uint32 is_cme_msg = 6;
inline bool TMtFeccMsg::has_is_cme_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtFeccMsg::set_has_is_cme_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtFeccMsg::clear_has_is_cme_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtFeccMsg::clear_is_cme_msg() {
  is_cme_msg_ = 0u;
  clear_has_is_cme_msg();
}
inline ::google::protobuf::uint32 TMtFeccMsg::is_cme_msg() const {
  return is_cme_msg_;
}
inline void TMtFeccMsg::set_is_cme_msg(::google::protobuf::uint32 value) {
  set_has_is_cme_msg();
  is_cme_msg_ = value;
}

// optional .mt.EmFeccCMEMsgType cme_msg_type = 7;
inline bool TMtFeccMsg::has_cme_msg_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtFeccMsg::set_has_cme_msg_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtFeccMsg::clear_has_cme_msg_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtFeccMsg::clear_cme_msg_type() {
  cme_msg_type_ = 0;
  clear_has_cme_msg_type();
}
inline ::mt::EmFeccCMEMsgType TMtFeccMsg::cme_msg_type() const {
  return static_cast< ::mt::EmFeccCMEMsgType >(cme_msg_type_);
}
inline void TMtFeccMsg::set_cme_msg_type(::mt::EmFeccCMEMsgType value) {
  assert(::mt::EmFeccCMEMsgType_IsValid(value));
  set_has_cme_msg_type();
  cme_msg_type_ = value;
}

// optional uint32 com_idx = 8;
inline bool TMtFeccMsg::has_com_idx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtFeccMsg::set_has_com_idx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtFeccMsg::clear_has_com_idx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtFeccMsg::clear_com_idx() {
  com_idx_ = 0u;
  clear_has_com_idx();
}
inline ::google::protobuf::uint32 TMtFeccMsg::com_idx() const {
  return com_idx_;
}
inline void TMtFeccMsg::set_com_idx(::google::protobuf::uint32 value) {
  set_has_com_idx();
  com_idx_ = value;
}

// -------------------------------------------------------------------

// TMtSeeing

// optional .mt.EmCodecComponentIndex chan_idx = 1;
inline bool TMtSeeing::has_chan_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSeeing::set_has_chan_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSeeing::clear_has_chan_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSeeing::clear_chan_idx() {
  chan_idx_ = 0;
  clear_has_chan_idx();
}
inline ::mt::EmCodecComponentIndex TMtSeeing::chan_idx() const {
  return static_cast< ::mt::EmCodecComponentIndex >(chan_idx_);
}
inline void TMtSeeing::set_chan_idx(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_chan_idx();
  chan_idx_ = value;
}

// optional .mt.TMtId mt_id = 2;
inline bool TMtSeeing::has_mt_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSeeing::set_has_mt_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSeeing::clear_has_mt_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSeeing::clear_mt_id() {
  if (mt_id_ != NULL) mt_id_->::mt::TMtId::Clear();
  clear_has_mt_id();
}
inline const ::mt::TMtId& TMtSeeing::mt_id() const {
  return mt_id_ != NULL ? *mt_id_ : *default_instance_->mt_id_;
}
inline ::mt::TMtId* TMtSeeing::mutable_mt_id() {
  set_has_mt_id();
  if (mt_id_ == NULL) mt_id_ = new ::mt::TMtId;
  return mt_id_;
}
inline ::mt::TMtId* TMtSeeing::release_mt_id() {
  clear_has_mt_id();
  ::mt::TMtId* temp = mt_id_;
  mt_id_ = NULL;
  return temp;
}
inline void TMtSeeing::set_allocated_mt_id(::mt::TMtId* mt_id) {
  delete mt_id_;
  mt_id_ = mt_id;
  if (mt_id) {
    set_has_mt_id();
  } else {
    clear_has_mt_id();
  }
}

// -------------------------------------------------------------------

// TRpMtSeeing

// repeated .mt.TMtSeeing mt_see = 1;
inline int TRpMtSeeing::mt_see_size() const {
  return mt_see_.size();
}
inline void TRpMtSeeing::clear_mt_see() {
  mt_see_.Clear();
}
inline const ::mt::TMtSeeing& TRpMtSeeing::mt_see(int index) const {
  return mt_see_.Get(index);
}
inline ::mt::TMtSeeing* TRpMtSeeing::mutable_mt_see(int index) {
  return mt_see_.Mutable(index);
}
inline ::mt::TMtSeeing* TRpMtSeeing::add_mt_see() {
  return mt_see_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtSeeing >&
TRpMtSeeing::mt_see() const {
  return mt_see_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtSeeing >*
TRpMtSeeing::mutable_mt_see() {
  return &mt_see_;
}

// -------------------------------------------------------------------

// TViewTerParam

// optional .mt.TMtId mt = 1;
inline bool TViewTerParam::has_mt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TViewTerParam::set_has_mt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TViewTerParam::clear_has_mt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TViewTerParam::clear_mt() {
  if (mt_ != NULL) mt_->::mt::TMtId::Clear();
  clear_has_mt();
}
inline const ::mt::TMtId& TViewTerParam::mt() const {
  return mt_ != NULL ? *mt_ : *default_instance_->mt_;
}
inline ::mt::TMtId* TViewTerParam::mutable_mt() {
  set_has_mt();
  if (mt_ == NULL) mt_ = new ::mt::TMtId;
  return mt_;
}
inline ::mt::TMtId* TViewTerParam::release_mt() {
  clear_has_mt();
  ::mt::TMtId* temp = mt_;
  mt_ = NULL;
  return temp;
}
inline void TViewTerParam::set_allocated_mt(::mt::TMtId* mt) {
  delete mt_;
  mt_ = mt;
  if (mt) {
    set_has_mt();
  } else {
    clear_has_mt();
  }
}

// optional .mt.EmMtMediaType type = 2;
inline bool TViewTerParam::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TViewTerParam::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TViewTerParam::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TViewTerParam::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mt::EmMtMediaType TViewTerParam::type() const {
  return static_cast< ::mt::EmMtMediaType >(type_);
}
inline void TViewTerParam::set_type(::mt::EmMtMediaType value) {
  assert(::mt::EmMtMediaType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bool is_see_all_chan = 3;
inline bool TViewTerParam::has_is_see_all_chan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TViewTerParam::set_has_is_see_all_chan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TViewTerParam::clear_has_is_see_all_chan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TViewTerParam::clear_is_see_all_chan() {
  is_see_all_chan_ = false;
  clear_has_is_see_all_chan();
}
inline bool TViewTerParam::is_see_all_chan() const {
  return is_see_all_chan_;
}
inline void TViewTerParam::set_is_see_all_chan(bool value) {
  set_has_is_see_all_chan();
  is_see_all_chan_ = value;
}

// optional .mt.EmCodecComponentIndex chan_idx = 4;
inline bool TViewTerParam::has_chan_idx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TViewTerParam::set_has_chan_idx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TViewTerParam::clear_has_chan_idx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TViewTerParam::clear_chan_idx() {
  chan_idx_ = 0;
  clear_has_chan_idx();
}
inline ::mt::EmCodecComponentIndex TViewTerParam::chan_idx() const {
  return static_cast< ::mt::EmCodecComponentIndex >(chan_idx_);
}
inline void TViewTerParam::set_chan_idx(::mt::EmCodecComponentIndex value) {
  assert(::mt::EmCodecComponentIndex_IsValid(value));
  set_has_chan_idx();
  chan_idx_ = value;
}

// -------------------------------------------------------------------

// TCloudRecordState

// optional bool is_cloud_record = 1;
inline bool TCloudRecordState::has_is_cloud_record() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCloudRecordState::set_has_is_cloud_record() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCloudRecordState::clear_has_is_cloud_record() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCloudRecordState::clear_is_cloud_record() {
  is_cloud_record_ = false;
  clear_has_is_cloud_record();
}
inline bool TCloudRecordState::is_cloud_record() const {
  return is_cloud_record_;
}
inline void TCloudRecordState::set_is_cloud_record(bool value) {
  set_has_is_cloud_record();
  is_cloud_record_ = value;
}

// optional .mt.TMTTime cloud_record_time = 2;
inline bool TCloudRecordState::has_cloud_record_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCloudRecordState::set_has_cloud_record_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCloudRecordState::clear_has_cloud_record_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCloudRecordState::clear_cloud_record_time() {
  if (cloud_record_time_ != NULL) cloud_record_time_->::mt::TMTTime::Clear();
  clear_has_cloud_record_time();
}
inline const ::mt::TMTTime& TCloudRecordState::cloud_record_time() const {
  return cloud_record_time_ != NULL ? *cloud_record_time_ : *default_instance_->cloud_record_time_;
}
inline ::mt::TMTTime* TCloudRecordState::mutable_cloud_record_time() {
  set_has_cloud_record_time();
  if (cloud_record_time_ == NULL) cloud_record_time_ = new ::mt::TMTTime;
  return cloud_record_time_;
}
inline ::mt::TMTTime* TCloudRecordState::release_cloud_record_time() {
  clear_has_cloud_record_time();
  ::mt::TMTTime* temp = cloud_record_time_;
  cloud_record_time_ = NULL;
  return temp;
}
inline void TCloudRecordState::set_allocated_cloud_record_time(::mt::TMTTime* cloud_record_time) {
  delete cloud_record_time_;
  cloud_record_time_ = cloud_record_time;
  if (cloud_record_time) {
    set_has_cloud_record_time();
  } else {
    clear_has_cloud_record_time();
  }
}

// -------------------------------------------------------------------

// TInnerMCParam

// optional uint32 vmp_type = 1;
inline bool TInnerMCParam::has_vmp_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TInnerMCParam::set_has_vmp_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TInnerMCParam::clear_has_vmp_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TInnerMCParam::clear_vmp_type() {
  vmp_type_ = 0u;
  clear_has_vmp_type();
}
inline ::google::protobuf::uint32 TInnerMCParam::vmp_type() const {
  return vmp_type_;
}
inline void TInnerMCParam::set_vmp_type(::google::protobuf::uint32 value) {
  set_has_vmp_type();
  vmp_type_ = value;
}

// optional .mt.EmMCMode mc_mode = 2;
inline bool TInnerMCParam::has_mc_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TInnerMCParam::set_has_mc_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TInnerMCParam::clear_has_mc_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TInnerMCParam::clear_mc_mode() {
  mc_mode_ = 0;
  clear_has_mc_mode();
}
inline ::mt::EmMCMode TInnerMCParam::mc_mode() const {
  return static_cast< ::mt::EmMCMode >(mc_mode_);
}
inline void TInnerMCParam::set_mc_mode(::mt::EmMCMode value) {
  assert(::mt::EmMCMode_IsValid(value));
  set_has_mc_mode();
  mc_mode_ = value;
}

// optional string conf_name = 3;
inline bool TInnerMCParam::has_conf_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TInnerMCParam::set_has_conf_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TInnerMCParam::clear_has_conf_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TInnerMCParam::clear_conf_name() {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    conf_name_->clear();
  }
  clear_has_conf_name();
}
inline const ::std::string& TInnerMCParam::conf_name() const {
  return *conf_name_;
}
inline void TInnerMCParam::set_conf_name(const ::std::string& value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TInnerMCParam::set_conf_name(const char* value) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(value);
}
inline void TInnerMCParam::set_conf_name(const char* value, size_t size) {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  conf_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TInnerMCParam::mutable_conf_name() {
  set_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    conf_name_ = new ::std::string;
  }
  return conf_name_;
}
inline ::std::string* TInnerMCParam::release_conf_name() {
  clear_has_conf_name();
  if (conf_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conf_name_;
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TInnerMCParam::set_allocated_conf_name(::std::string* conf_name) {
  if (conf_name_ != &::google::protobuf::internal::kEmptyString) {
    delete conf_name_;
  }
  if (conf_name) {
    set_has_conf_name();
    conf_name_ = conf_name;
  } else {
    clear_has_conf_name();
    conf_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 conf_rate = 4;
inline bool TInnerMCParam::has_conf_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TInnerMCParam::set_has_conf_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TInnerMCParam::clear_has_conf_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TInnerMCParam::clear_conf_rate() {
  conf_rate_ = 0u;
  clear_has_conf_rate();
}
inline ::google::protobuf::uint32 TInnerMCParam::conf_rate() const {
  return conf_rate_;
}
inline void TInnerMCParam::set_conf_rate(::google::protobuf::uint32 value) {
  set_has_conf_rate();
  conf_rate_ = value;
}

// optional .mt.EmConfProtocol conf_protocol = 5;
inline bool TInnerMCParam::has_conf_protocol() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TInnerMCParam::set_has_conf_protocol() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TInnerMCParam::clear_has_conf_protocol() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TInnerMCParam::clear_conf_protocol() {
  conf_protocol_ = 0;
  clear_has_conf_protocol();
}
inline ::mt::EmConfProtocol TInnerMCParam::conf_protocol() const {
  return static_cast< ::mt::EmConfProtocol >(conf_protocol_);
}
inline void TInnerMCParam::set_conf_protocol(::mt::EmConfProtocol value) {
  assert(::mt::EmConfProtocol_IsValid(value));
  set_has_conf_protocol();
  conf_protocol_ = value;
}

// optional .mt.TVidFormatCap main_vid_cap = 6;
inline bool TInnerMCParam::has_main_vid_cap() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TInnerMCParam::set_has_main_vid_cap() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TInnerMCParam::clear_has_main_vid_cap() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TInnerMCParam::clear_main_vid_cap() {
  if (main_vid_cap_ != NULL) main_vid_cap_->::mt::TVidFormatCap::Clear();
  clear_has_main_vid_cap();
}
inline const ::mt::TVidFormatCap& TInnerMCParam::main_vid_cap() const {
  return main_vid_cap_ != NULL ? *main_vid_cap_ : *default_instance_->main_vid_cap_;
}
inline ::mt::TVidFormatCap* TInnerMCParam::mutable_main_vid_cap() {
  set_has_main_vid_cap();
  if (main_vid_cap_ == NULL) main_vid_cap_ = new ::mt::TVidFormatCap;
  return main_vid_cap_;
}
inline ::mt::TVidFormatCap* TInnerMCParam::release_main_vid_cap() {
  clear_has_main_vid_cap();
  ::mt::TVidFormatCap* temp = main_vid_cap_;
  main_vid_cap_ = NULL;
  return temp;
}
inline void TInnerMCParam::set_allocated_main_vid_cap(::mt::TVidFormatCap* main_vid_cap) {
  delete main_vid_cap_;
  main_vid_cap_ = main_vid_cap;
  if (main_vid_cap) {
    set_has_main_vid_cap();
  } else {
    clear_has_main_vid_cap();
  }
}

// optional .mt.TVidFormatCap assis_vid_cap = 7;
inline bool TInnerMCParam::has_assis_vid_cap() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TInnerMCParam::set_has_assis_vid_cap() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TInnerMCParam::clear_has_assis_vid_cap() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TInnerMCParam::clear_assis_vid_cap() {
  if (assis_vid_cap_ != NULL) assis_vid_cap_->::mt::TVidFormatCap::Clear();
  clear_has_assis_vid_cap();
}
inline const ::mt::TVidFormatCap& TInnerMCParam::assis_vid_cap() const {
  return assis_vid_cap_ != NULL ? *assis_vid_cap_ : *default_instance_->assis_vid_cap_;
}
inline ::mt::TVidFormatCap* TInnerMCParam::mutable_assis_vid_cap() {
  set_has_assis_vid_cap();
  if (assis_vid_cap_ == NULL) assis_vid_cap_ = new ::mt::TVidFormatCap;
  return assis_vid_cap_;
}
inline ::mt::TVidFormatCap* TInnerMCParam::release_assis_vid_cap() {
  clear_has_assis_vid_cap();
  ::mt::TVidFormatCap* temp = assis_vid_cap_;
  assis_vid_cap_ = NULL;
  return temp;
}
inline void TInnerMCParam::set_allocated_assis_vid_cap(::mt::TVidFormatCap* assis_vid_cap) {
  delete assis_vid_cap_;
  assis_vid_cap_ = assis_vid_cap;
  if (assis_vid_cap) {
    set_has_assis_vid_cap();
  } else {
    clear_has_assis_vid_cap();
  }
}

// optional .mt.TAudDes aud_cap = 8;
inline bool TInnerMCParam::has_aud_cap() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TInnerMCParam::set_has_aud_cap() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TInnerMCParam::clear_has_aud_cap() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TInnerMCParam::clear_aud_cap() {
  if (aud_cap_ != NULL) aud_cap_->::mt::TAudDes::Clear();
  clear_has_aud_cap();
}
inline const ::mt::TAudDes& TInnerMCParam::aud_cap() const {
  return aud_cap_ != NULL ? *aud_cap_ : *default_instance_->aud_cap_;
}
inline ::mt::TAudDes* TInnerMCParam::mutable_aud_cap() {
  set_has_aud_cap();
  if (aud_cap_ == NULL) aud_cap_ = new ::mt::TAudDes;
  return aud_cap_;
}
inline ::mt::TAudDes* TInnerMCParam::release_aud_cap() {
  clear_has_aud_cap();
  ::mt::TAudDes* temp = aud_cap_;
  aud_cap_ = NULL;
  return temp;
}
inline void TInnerMCParam::set_allocated_aud_cap(::mt::TAudDes* aud_cap) {
  delete aud_cap_;
  aud_cap_ = aud_cap;
  if (aud_cap) {
    set_has_aud_cap();
  } else {
    clear_has_aud_cap();
  }
}

// optional bool bmc_used = 9;
inline bool TInnerMCParam::has_bmc_used() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TInnerMCParam::set_has_bmc_used() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TInnerMCParam::clear_has_bmc_used() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TInnerMCParam::clear_bmc_used() {
  bmc_used_ = false;
  clear_has_bmc_used();
}
inline bool TInnerMCParam::bmc_used() const {
  return bmc_used_;
}
inline void TInnerMCParam::set_bmc_used(bool value) {
  set_has_bmc_used();
  bmc_used_ = value;
}

// -------------------------------------------------------------------

// TInnerMCRunInfo

// optional bool mc_is_exist = 1 [default = false];
inline bool TInnerMCRunInfo::has_mc_is_exist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TInnerMCRunInfo::set_has_mc_is_exist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TInnerMCRunInfo::clear_has_mc_is_exist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TInnerMCRunInfo::clear_mc_is_exist() {
  mc_is_exist_ = false;
  clear_has_mc_is_exist();
}
inline bool TInnerMCRunInfo::mc_is_exist() const {
  return mc_is_exist_;
}
inline void TInnerMCRunInfo::set_mc_is_exist(bool value) {
  set_has_mc_is_exist();
  mc_is_exist_ = value;
}

// optional bool mc_is_active = 2 [default = false];
inline bool TInnerMCRunInfo::has_mc_is_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TInnerMCRunInfo::set_has_mc_is_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TInnerMCRunInfo::clear_has_mc_is_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TInnerMCRunInfo::clear_mc_is_active() {
  mc_is_active_ = false;
  clear_has_mc_is_active();
}
inline bool TInnerMCRunInfo::mc_is_active() const {
  return mc_is_active_;
}
inline void TInnerMCRunInfo::set_mc_is_active(bool value) {
  set_has_mc_is_active();
  mc_is_active_ = value;
}

// optional bool mc_is_inconf = 3 [default = false];
inline bool TInnerMCRunInfo::has_mc_is_inconf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TInnerMCRunInfo::set_has_mc_is_inconf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TInnerMCRunInfo::clear_has_mc_is_inconf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TInnerMCRunInfo::clear_mc_is_inconf() {
  mc_is_inconf_ = false;
  clear_has_mc_is_inconf();
}
inline bool TInnerMCRunInfo::mc_is_inconf() const {
  return mc_is_inconf_;
}
inline void TInnerMCRunInfo::set_mc_is_inconf(bool value) {
  set_has_mc_is_inconf();
  mc_is_inconf_ = value;
}

// optional uint32 mc_mem_maxnum = 4;
inline bool TInnerMCRunInfo::has_mc_mem_maxnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TInnerMCRunInfo::set_has_mc_mem_maxnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TInnerMCRunInfo::clear_has_mc_mem_maxnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TInnerMCRunInfo::clear_mc_mem_maxnum() {
  mc_mem_maxnum_ = 0u;
  clear_has_mc_mem_maxnum();
}
inline ::google::protobuf::uint32 TInnerMCRunInfo::mc_mem_maxnum() const {
  return mc_mem_maxnum_;
}
inline void TInnerMCRunInfo::set_mc_mem_maxnum(::google::protobuf::uint32 value) {
  set_has_mc_mem_maxnum();
  mc_mem_maxnum_ = value;
}

// optional uint32 p2p_pa_handle = 5 [default = 0];
inline bool TInnerMCRunInfo::has_p2p_pa_handle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TInnerMCRunInfo::set_has_p2p_pa_handle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TInnerMCRunInfo::clear_has_p2p_pa_handle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TInnerMCRunInfo::clear_p2p_pa_handle() {
  p2p_pa_handle_ = 0u;
  clear_has_p2p_pa_handle();
}
inline ::google::protobuf::uint32 TInnerMCRunInfo::p2p_pa_handle() const {
  return p2p_pa_handle_;
}
inline void TInnerMCRunInfo::set_p2p_pa_handle(::google::protobuf::uint32 value) {
  set_has_p2p_pa_handle();
  p2p_pa_handle_ = value;
}

// optional uint32 p2p_ep_handle = 6;
inline bool TInnerMCRunInfo::has_p2p_ep_handle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TInnerMCRunInfo::set_has_p2p_ep_handle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TInnerMCRunInfo::clear_has_p2p_ep_handle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TInnerMCRunInfo::clear_p2p_ep_handle() {
  p2p_ep_handle_ = 0u;
  clear_has_p2p_ep_handle();
}
inline ::google::protobuf::uint32 TInnerMCRunInfo::p2p_ep_handle() const {
  return p2p_ep_handle_;
}
inline void TInnerMCRunInfo::set_p2p_ep_handle(::google::protobuf::uint32 value) {
  set_has_p2p_ep_handle();
  p2p_ep_handle_ = value;
}

// -------------------------------------------------------------------

// TFastCall

// optional uint32 call_rate = 1;
inline bool TFastCall::has_call_rate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TFastCall::set_has_call_rate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TFastCall::clear_has_call_rate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TFastCall::clear_call_rate() {
  call_rate_ = 0u;
  clear_has_call_rate();
}
inline ::google::protobuf::uint32 TFastCall::call_rate() const {
  return call_rate_;
}
inline void TFastCall::set_call_rate(::google::protobuf::uint32 value) {
  set_has_call_rate();
  call_rate_ = value;
}

// optional .mt.EmMtAddrType call_type = 2;
inline bool TFastCall::has_call_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TFastCall::set_has_call_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TFastCall::clear_has_call_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TFastCall::clear_call_type() {
  call_type_ = 0;
  clear_has_call_type();
}
inline ::mt::EmMtAddrType TFastCall::call_type() const {
  return static_cast< ::mt::EmMtAddrType >(call_type_);
}
inline void TFastCall::set_call_type(::mt::EmMtAddrType value) {
  assert(::mt::EmMtAddrType_IsValid(value));
  set_has_call_type();
  call_type_ = value;
}

// optional uint32 peer_addr = 3;
inline bool TFastCall::has_peer_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TFastCall::set_has_peer_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TFastCall::clear_has_peer_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TFastCall::clear_peer_addr() {
  peer_addr_ = 0u;
  clear_has_peer_addr();
}
inline ::google::protobuf::uint32 TFastCall::peer_addr() const {
  return peer_addr_;
}
inline void TFastCall::set_peer_addr(::google::protobuf::uint32 value) {
  set_has_peer_addr();
  peer_addr_ = value;
}

// optional string peer_e164 = 4;
inline bool TFastCall::has_peer_e164() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TFastCall::set_has_peer_e164() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TFastCall::clear_has_peer_e164() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TFastCall::clear_peer_e164() {
  if (peer_e164_ != &::google::protobuf::internal::kEmptyString) {
    peer_e164_->clear();
  }
  clear_has_peer_e164();
}
inline const ::std::string& TFastCall::peer_e164() const {
  return *peer_e164_;
}
inline void TFastCall::set_peer_e164(const ::std::string& value) {
  set_has_peer_e164();
  if (peer_e164_ == &::google::protobuf::internal::kEmptyString) {
    peer_e164_ = new ::std::string;
  }
  peer_e164_->assign(value);
}
inline void TFastCall::set_peer_e164(const char* value) {
  set_has_peer_e164();
  if (peer_e164_ == &::google::protobuf::internal::kEmptyString) {
    peer_e164_ = new ::std::string;
  }
  peer_e164_->assign(value);
}
inline void TFastCall::set_peer_e164(const char* value, size_t size) {
  set_has_peer_e164();
  if (peer_e164_ == &::google::protobuf::internal::kEmptyString) {
    peer_e164_ = new ::std::string;
  }
  peer_e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TFastCall::mutable_peer_e164() {
  set_has_peer_e164();
  if (peer_e164_ == &::google::protobuf::internal::kEmptyString) {
    peer_e164_ = new ::std::string;
  }
  return peer_e164_;
}
inline ::std::string* TFastCall::release_peer_e164() {
  clear_has_peer_e164();
  if (peer_e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_e164_;
    peer_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TFastCall::set_allocated_peer_e164(::std::string* peer_e164) {
  if (peer_e164_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_e164_;
  }
  if (peer_e164) {
    set_has_peer_e164();
    peer_e164_ = peer_e164;
  } else {
    clear_has_peer_e164();
    peer_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string peer_alias = 5;
inline bool TFastCall::has_peer_alias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TFastCall::set_has_peer_alias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TFastCall::clear_has_peer_alias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TFastCall::clear_peer_alias() {
  if (peer_alias_ != &::google::protobuf::internal::kEmptyString) {
    peer_alias_->clear();
  }
  clear_has_peer_alias();
}
inline const ::std::string& TFastCall::peer_alias() const {
  return *peer_alias_;
}
inline void TFastCall::set_peer_alias(const ::std::string& value) {
  set_has_peer_alias();
  if (peer_alias_ == &::google::protobuf::internal::kEmptyString) {
    peer_alias_ = new ::std::string;
  }
  peer_alias_->assign(value);
}
inline void TFastCall::set_peer_alias(const char* value) {
  set_has_peer_alias();
  if (peer_alias_ == &::google::protobuf::internal::kEmptyString) {
    peer_alias_ = new ::std::string;
  }
  peer_alias_->assign(value);
}
inline void TFastCall::set_peer_alias(const char* value, size_t size) {
  set_has_peer_alias();
  if (peer_alias_ == &::google::protobuf::internal::kEmptyString) {
    peer_alias_ = new ::std::string;
  }
  peer_alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TFastCall::mutable_peer_alias() {
  set_has_peer_alias();
  if (peer_alias_ == &::google::protobuf::internal::kEmptyString) {
    peer_alias_ = new ::std::string;
  }
  return peer_alias_;
}
inline ::std::string* TFastCall::release_peer_alias() {
  clear_has_peer_alias();
  if (peer_alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_alias_;
    peer_alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TFastCall::set_allocated_peer_alias(::std::string* peer_alias) {
  if (peer_alias_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_alias_;
  }
  if (peer_alias) {
    set_has_peer_alias();
    peer_alias_ = peer_alias;
  } else {
    clear_has_peer_alias();
    peer_alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TFastCallList

// repeated .mt.TFastCall fast_call = 1;
inline int TFastCallList::fast_call_size() const {
  return fast_call_.size();
}
inline void TFastCallList::clear_fast_call() {
  fast_call_.Clear();
}
inline const ::mt::TFastCall& TFastCallList::fast_call(int index) const {
  return fast_call_.Get(index);
}
inline ::mt::TFastCall* TFastCallList::mutable_fast_call(int index) {
  return fast_call_.Mutable(index);
}
inline ::mt::TFastCall* TFastCallList::add_fast_call() {
  return fast_call_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TFastCall >&
TFastCallList::fast_call() const {
  return fast_call_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TFastCall >*
TFastCallList::mutable_fast_call() {
  return &fast_call_;
}

// -------------------------------------------------------------------

// TMtSecCertDistinctName

// optional string country_name = 1;
inline bool TMtSecCertDistinctName::has_country_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSecCertDistinctName::set_has_country_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSecCertDistinctName::clear_has_country_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSecCertDistinctName::clear_country_name() {
  if (country_name_ != &::google::protobuf::internal::kEmptyString) {
    country_name_->clear();
  }
  clear_has_country_name();
}
inline const ::std::string& TMtSecCertDistinctName::country_name() const {
  return *country_name_;
}
inline void TMtSecCertDistinctName::set_country_name(const ::std::string& value) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_country_name(const char* value) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_country_name(const char* value, size_t size) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertDistinctName::mutable_country_name() {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  return country_name_;
}
inline ::std::string* TMtSecCertDistinctName::release_country_name() {
  clear_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_name_;
    country_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertDistinctName::set_allocated_country_name(::std::string* country_name) {
  if (country_name_ != &::google::protobuf::internal::kEmptyString) {
    delete country_name_;
  }
  if (country_name) {
    set_has_country_name();
    country_name_ = country_name;
  } else {
    clear_has_country_name();
    country_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state_or_province_name = 2;
inline bool TMtSecCertDistinctName::has_state_or_province_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSecCertDistinctName::set_has_state_or_province_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSecCertDistinctName::clear_has_state_or_province_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSecCertDistinctName::clear_state_or_province_name() {
  if (state_or_province_name_ != &::google::protobuf::internal::kEmptyString) {
    state_or_province_name_->clear();
  }
  clear_has_state_or_province_name();
}
inline const ::std::string& TMtSecCertDistinctName::state_or_province_name() const {
  return *state_or_province_name_;
}
inline void TMtSecCertDistinctName::set_state_or_province_name(const ::std::string& value) {
  set_has_state_or_province_name();
  if (state_or_province_name_ == &::google::protobuf::internal::kEmptyString) {
    state_or_province_name_ = new ::std::string;
  }
  state_or_province_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_state_or_province_name(const char* value) {
  set_has_state_or_province_name();
  if (state_or_province_name_ == &::google::protobuf::internal::kEmptyString) {
    state_or_province_name_ = new ::std::string;
  }
  state_or_province_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_state_or_province_name(const char* value, size_t size) {
  set_has_state_or_province_name();
  if (state_or_province_name_ == &::google::protobuf::internal::kEmptyString) {
    state_or_province_name_ = new ::std::string;
  }
  state_or_province_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertDistinctName::mutable_state_or_province_name() {
  set_has_state_or_province_name();
  if (state_or_province_name_ == &::google::protobuf::internal::kEmptyString) {
    state_or_province_name_ = new ::std::string;
  }
  return state_or_province_name_;
}
inline ::std::string* TMtSecCertDistinctName::release_state_or_province_name() {
  clear_has_state_or_province_name();
  if (state_or_province_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_or_province_name_;
    state_or_province_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertDistinctName::set_allocated_state_or_province_name(::std::string* state_or_province_name) {
  if (state_or_province_name_ != &::google::protobuf::internal::kEmptyString) {
    delete state_or_province_name_;
  }
  if (state_or_province_name) {
    set_has_state_or_province_name();
    state_or_province_name_ = state_or_province_name;
  } else {
    clear_has_state_or_province_name();
    state_or_province_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string locality_name = 3;
inline bool TMtSecCertDistinctName::has_locality_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtSecCertDistinctName::set_has_locality_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtSecCertDistinctName::clear_has_locality_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtSecCertDistinctName::clear_locality_name() {
  if (locality_name_ != &::google::protobuf::internal::kEmptyString) {
    locality_name_->clear();
  }
  clear_has_locality_name();
}
inline const ::std::string& TMtSecCertDistinctName::locality_name() const {
  return *locality_name_;
}
inline void TMtSecCertDistinctName::set_locality_name(const ::std::string& value) {
  set_has_locality_name();
  if (locality_name_ == &::google::protobuf::internal::kEmptyString) {
    locality_name_ = new ::std::string;
  }
  locality_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_locality_name(const char* value) {
  set_has_locality_name();
  if (locality_name_ == &::google::protobuf::internal::kEmptyString) {
    locality_name_ = new ::std::string;
  }
  locality_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_locality_name(const char* value, size_t size) {
  set_has_locality_name();
  if (locality_name_ == &::google::protobuf::internal::kEmptyString) {
    locality_name_ = new ::std::string;
  }
  locality_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertDistinctName::mutable_locality_name() {
  set_has_locality_name();
  if (locality_name_ == &::google::protobuf::internal::kEmptyString) {
    locality_name_ = new ::std::string;
  }
  return locality_name_;
}
inline ::std::string* TMtSecCertDistinctName::release_locality_name() {
  clear_has_locality_name();
  if (locality_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locality_name_;
    locality_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertDistinctName::set_allocated_locality_name(::std::string* locality_name) {
  if (locality_name_ != &::google::protobuf::internal::kEmptyString) {
    delete locality_name_;
  }
  if (locality_name) {
    set_has_locality_name();
    locality_name_ = locality_name;
  } else {
    clear_has_locality_name();
    locality_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organization_name = 4;
inline bool TMtSecCertDistinctName::has_organization_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtSecCertDistinctName::set_has_organization_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtSecCertDistinctName::clear_has_organization_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtSecCertDistinctName::clear_organization_name() {
  if (organization_name_ != &::google::protobuf::internal::kEmptyString) {
    organization_name_->clear();
  }
  clear_has_organization_name();
}
inline const ::std::string& TMtSecCertDistinctName::organization_name() const {
  return *organization_name_;
}
inline void TMtSecCertDistinctName::set_organization_name(const ::std::string& value) {
  set_has_organization_name();
  if (organization_name_ == &::google::protobuf::internal::kEmptyString) {
    organization_name_ = new ::std::string;
  }
  organization_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_organization_name(const char* value) {
  set_has_organization_name();
  if (organization_name_ == &::google::protobuf::internal::kEmptyString) {
    organization_name_ = new ::std::string;
  }
  organization_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_organization_name(const char* value, size_t size) {
  set_has_organization_name();
  if (organization_name_ == &::google::protobuf::internal::kEmptyString) {
    organization_name_ = new ::std::string;
  }
  organization_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertDistinctName::mutable_organization_name() {
  set_has_organization_name();
  if (organization_name_ == &::google::protobuf::internal::kEmptyString) {
    organization_name_ = new ::std::string;
  }
  return organization_name_;
}
inline ::std::string* TMtSecCertDistinctName::release_organization_name() {
  clear_has_organization_name();
  if (organization_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organization_name_;
    organization_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertDistinctName::set_allocated_organization_name(::std::string* organization_name) {
  if (organization_name_ != &::google::protobuf::internal::kEmptyString) {
    delete organization_name_;
  }
  if (organization_name) {
    set_has_organization_name();
    organization_name_ = organization_name;
  } else {
    clear_has_organization_name();
    organization_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organization_unit_name = 5;
inline bool TMtSecCertDistinctName::has_organization_unit_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtSecCertDistinctName::set_has_organization_unit_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtSecCertDistinctName::clear_has_organization_unit_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtSecCertDistinctName::clear_organization_unit_name() {
  if (organization_unit_name_ != &::google::protobuf::internal::kEmptyString) {
    organization_unit_name_->clear();
  }
  clear_has_organization_unit_name();
}
inline const ::std::string& TMtSecCertDistinctName::organization_unit_name() const {
  return *organization_unit_name_;
}
inline void TMtSecCertDistinctName::set_organization_unit_name(const ::std::string& value) {
  set_has_organization_unit_name();
  if (organization_unit_name_ == &::google::protobuf::internal::kEmptyString) {
    organization_unit_name_ = new ::std::string;
  }
  organization_unit_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_organization_unit_name(const char* value) {
  set_has_organization_unit_name();
  if (organization_unit_name_ == &::google::protobuf::internal::kEmptyString) {
    organization_unit_name_ = new ::std::string;
  }
  organization_unit_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_organization_unit_name(const char* value, size_t size) {
  set_has_organization_unit_name();
  if (organization_unit_name_ == &::google::protobuf::internal::kEmptyString) {
    organization_unit_name_ = new ::std::string;
  }
  organization_unit_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertDistinctName::mutable_organization_unit_name() {
  set_has_organization_unit_name();
  if (organization_unit_name_ == &::google::protobuf::internal::kEmptyString) {
    organization_unit_name_ = new ::std::string;
  }
  return organization_unit_name_;
}
inline ::std::string* TMtSecCertDistinctName::release_organization_unit_name() {
  clear_has_organization_unit_name();
  if (organization_unit_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organization_unit_name_;
    organization_unit_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertDistinctName::set_allocated_organization_unit_name(::std::string* organization_unit_name) {
  if (organization_unit_name_ != &::google::protobuf::internal::kEmptyString) {
    delete organization_unit_name_;
  }
  if (organization_unit_name) {
    set_has_organization_unit_name();
    organization_unit_name_ = organization_unit_name;
  } else {
    clear_has_organization_unit_name();
    organization_unit_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string common_name = 6;
inline bool TMtSecCertDistinctName::has_common_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtSecCertDistinctName::set_has_common_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtSecCertDistinctName::clear_has_common_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtSecCertDistinctName::clear_common_name() {
  if (common_name_ != &::google::protobuf::internal::kEmptyString) {
    common_name_->clear();
  }
  clear_has_common_name();
}
inline const ::std::string& TMtSecCertDistinctName::common_name() const {
  return *common_name_;
}
inline void TMtSecCertDistinctName::set_common_name(const ::std::string& value) {
  set_has_common_name();
  if (common_name_ == &::google::protobuf::internal::kEmptyString) {
    common_name_ = new ::std::string;
  }
  common_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_common_name(const char* value) {
  set_has_common_name();
  if (common_name_ == &::google::protobuf::internal::kEmptyString) {
    common_name_ = new ::std::string;
  }
  common_name_->assign(value);
}
inline void TMtSecCertDistinctName::set_common_name(const char* value, size_t size) {
  set_has_common_name();
  if (common_name_ == &::google::protobuf::internal::kEmptyString) {
    common_name_ = new ::std::string;
  }
  common_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertDistinctName::mutable_common_name() {
  set_has_common_name();
  if (common_name_ == &::google::protobuf::internal::kEmptyString) {
    common_name_ = new ::std::string;
  }
  return common_name_;
}
inline ::std::string* TMtSecCertDistinctName::release_common_name() {
  clear_has_common_name();
  if (common_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = common_name_;
    common_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertDistinctName::set_allocated_common_name(::std::string* common_name) {
  if (common_name_ != &::google::protobuf::internal::kEmptyString) {
    delete common_name_;
  }
  if (common_name) {
    set_has_common_name();
    common_name_ = common_name;
  } else {
    clear_has_common_name();
    common_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string serial_number = 7;
inline bool TMtSecCertDistinctName::has_serial_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtSecCertDistinctName::set_has_serial_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtSecCertDistinctName::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtSecCertDistinctName::clear_serial_number() {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    serial_number_->clear();
  }
  clear_has_serial_number();
}
inline const ::std::string& TMtSecCertDistinctName::serial_number() const {
  return *serial_number_;
}
inline void TMtSecCertDistinctName::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void TMtSecCertDistinctName::set_serial_number(const char* value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void TMtSecCertDistinctName::set_serial_number(const char* value, size_t size) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertDistinctName::mutable_serial_number() {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  return serial_number_;
}
inline ::std::string* TMtSecCertDistinctName::release_serial_number() {
  clear_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_number_;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertDistinctName::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  if (serial_number) {
    set_has_serial_number();
    serial_number_ = serial_number;
  } else {
    clear_has_serial_number();
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email_address = 8;
inline bool TMtSecCertDistinctName::has_email_address() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtSecCertDistinctName::set_has_email_address() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtSecCertDistinctName::clear_has_email_address() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtSecCertDistinctName::clear_email_address() {
  if (email_address_ != &::google::protobuf::internal::kEmptyString) {
    email_address_->clear();
  }
  clear_has_email_address();
}
inline const ::std::string& TMtSecCertDistinctName::email_address() const {
  return *email_address_;
}
inline void TMtSecCertDistinctName::set_email_address(const ::std::string& value) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(value);
}
inline void TMtSecCertDistinctName::set_email_address(const char* value) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(value);
}
inline void TMtSecCertDistinctName::set_email_address(const char* value, size_t size) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertDistinctName::mutable_email_address() {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  return email_address_;
}
inline ::std::string* TMtSecCertDistinctName::release_email_address() {
  clear_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_address_;
    email_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertDistinctName::set_allocated_email_address(::std::string* email_address) {
  if (email_address_ != &::google::protobuf::internal::kEmptyString) {
    delete email_address_;
  }
  if (email_address) {
    set_has_email_address();
    email_address_ = email_address;
  } else {
    clear_has_email_address();
    email_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtSecCertValidity

// optional string nottime_before = 1;
inline bool TMtSecCertValidity::has_nottime_before() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSecCertValidity::set_has_nottime_before() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSecCertValidity::clear_has_nottime_before() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSecCertValidity::clear_nottime_before() {
  if (nottime_before_ != &::google::protobuf::internal::kEmptyString) {
    nottime_before_->clear();
  }
  clear_has_nottime_before();
}
inline const ::std::string& TMtSecCertValidity::nottime_before() const {
  return *nottime_before_;
}
inline void TMtSecCertValidity::set_nottime_before(const ::std::string& value) {
  set_has_nottime_before();
  if (nottime_before_ == &::google::protobuf::internal::kEmptyString) {
    nottime_before_ = new ::std::string;
  }
  nottime_before_->assign(value);
}
inline void TMtSecCertValidity::set_nottime_before(const char* value) {
  set_has_nottime_before();
  if (nottime_before_ == &::google::protobuf::internal::kEmptyString) {
    nottime_before_ = new ::std::string;
  }
  nottime_before_->assign(value);
}
inline void TMtSecCertValidity::set_nottime_before(const char* value, size_t size) {
  set_has_nottime_before();
  if (nottime_before_ == &::google::protobuf::internal::kEmptyString) {
    nottime_before_ = new ::std::string;
  }
  nottime_before_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertValidity::mutable_nottime_before() {
  set_has_nottime_before();
  if (nottime_before_ == &::google::protobuf::internal::kEmptyString) {
    nottime_before_ = new ::std::string;
  }
  return nottime_before_;
}
inline ::std::string* TMtSecCertValidity::release_nottime_before() {
  clear_has_nottime_before();
  if (nottime_before_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nottime_before_;
    nottime_before_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertValidity::set_allocated_nottime_before(::std::string* nottime_before) {
  if (nottime_before_ != &::google::protobuf::internal::kEmptyString) {
    delete nottime_before_;
  }
  if (nottime_before) {
    set_has_nottime_before();
    nottime_before_ = nottime_before;
  } else {
    clear_has_nottime_before();
    nottime_before_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nottime_after = 2;
inline bool TMtSecCertValidity::has_nottime_after() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSecCertValidity::set_has_nottime_after() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSecCertValidity::clear_has_nottime_after() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSecCertValidity::clear_nottime_after() {
  if (nottime_after_ != &::google::protobuf::internal::kEmptyString) {
    nottime_after_->clear();
  }
  clear_has_nottime_after();
}
inline const ::std::string& TMtSecCertValidity::nottime_after() const {
  return *nottime_after_;
}
inline void TMtSecCertValidity::set_nottime_after(const ::std::string& value) {
  set_has_nottime_after();
  if (nottime_after_ == &::google::protobuf::internal::kEmptyString) {
    nottime_after_ = new ::std::string;
  }
  nottime_after_->assign(value);
}
inline void TMtSecCertValidity::set_nottime_after(const char* value) {
  set_has_nottime_after();
  if (nottime_after_ == &::google::protobuf::internal::kEmptyString) {
    nottime_after_ = new ::std::string;
  }
  nottime_after_->assign(value);
}
inline void TMtSecCertValidity::set_nottime_after(const char* value, size_t size) {
  set_has_nottime_after();
  if (nottime_after_ == &::google::protobuf::internal::kEmptyString) {
    nottime_after_ = new ::std::string;
  }
  nottime_after_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertValidity::mutable_nottime_after() {
  set_has_nottime_after();
  if (nottime_after_ == &::google::protobuf::internal::kEmptyString) {
    nottime_after_ = new ::std::string;
  }
  return nottime_after_;
}
inline ::std::string* TMtSecCertValidity::release_nottime_after() {
  clear_has_nottime_after();
  if (nottime_after_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nottime_after_;
    nottime_after_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertValidity::set_allocated_nottime_after(::std::string* nottime_after) {
  if (nottime_after_ != &::google::protobuf::internal::kEmptyString) {
    delete nottime_after_;
  }
  if (nottime_after) {
    set_has_nottime_after();
    nottime_after_ = nottime_after;
  } else {
    clear_has_nottime_after();
    nottime_after_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtSecCertInfo

// optional int32 version = 1;
inline bool TMtSecCertInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSecCertInfo::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSecCertInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSecCertInfo::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 TMtSecCertInfo::version() const {
  return version_;
}
inline void TMtSecCertInfo::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional string serial_number = 2;
inline bool TMtSecCertInfo::has_serial_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSecCertInfo::set_has_serial_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSecCertInfo::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSecCertInfo::clear_serial_number() {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    serial_number_->clear();
  }
  clear_has_serial_number();
}
inline const ::std::string& TMtSecCertInfo::serial_number() const {
  return *serial_number_;
}
inline void TMtSecCertInfo::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void TMtSecCertInfo::set_serial_number(const char* value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void TMtSecCertInfo::set_serial_number(const char* value, size_t size) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertInfo::mutable_serial_number() {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  return serial_number_;
}
inline ::std::string* TMtSecCertInfo::release_serial_number() {
  clear_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_number_;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertInfo::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  if (serial_number) {
    set_has_serial_number();
    serial_number_ = serial_number;
  } else {
    clear_has_serial_number();
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sign_alg = 3;
inline bool TMtSecCertInfo::has_sign_alg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtSecCertInfo::set_has_sign_alg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtSecCertInfo::clear_has_sign_alg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtSecCertInfo::clear_sign_alg() {
  if (sign_alg_ != &::google::protobuf::internal::kEmptyString) {
    sign_alg_->clear();
  }
  clear_has_sign_alg();
}
inline const ::std::string& TMtSecCertInfo::sign_alg() const {
  return *sign_alg_;
}
inline void TMtSecCertInfo::set_sign_alg(const ::std::string& value) {
  set_has_sign_alg();
  if (sign_alg_ == &::google::protobuf::internal::kEmptyString) {
    sign_alg_ = new ::std::string;
  }
  sign_alg_->assign(value);
}
inline void TMtSecCertInfo::set_sign_alg(const char* value) {
  set_has_sign_alg();
  if (sign_alg_ == &::google::protobuf::internal::kEmptyString) {
    sign_alg_ = new ::std::string;
  }
  sign_alg_->assign(value);
}
inline void TMtSecCertInfo::set_sign_alg(const char* value, size_t size) {
  set_has_sign_alg();
  if (sign_alg_ == &::google::protobuf::internal::kEmptyString) {
    sign_alg_ = new ::std::string;
  }
  sign_alg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertInfo::mutable_sign_alg() {
  set_has_sign_alg();
  if (sign_alg_ == &::google::protobuf::internal::kEmptyString) {
    sign_alg_ = new ::std::string;
  }
  return sign_alg_;
}
inline ::std::string* TMtSecCertInfo::release_sign_alg() {
  clear_has_sign_alg();
  if (sign_alg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_alg_;
    sign_alg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertInfo::set_allocated_sign_alg(::std::string* sign_alg) {
  if (sign_alg_ != &::google::protobuf::internal::kEmptyString) {
    delete sign_alg_;
  }
  if (sign_alg) {
    set_has_sign_alg();
    sign_alg_ = sign_alg;
  } else {
    clear_has_sign_alg();
    sign_alg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMtSecCertDistinctName issuer_info = 4;
inline bool TMtSecCertInfo::has_issuer_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtSecCertInfo::set_has_issuer_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtSecCertInfo::clear_has_issuer_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtSecCertInfo::clear_issuer_info() {
  if (issuer_info_ != NULL) issuer_info_->::mt::TMtSecCertDistinctName::Clear();
  clear_has_issuer_info();
}
inline const ::mt::TMtSecCertDistinctName& TMtSecCertInfo::issuer_info() const {
  return issuer_info_ != NULL ? *issuer_info_ : *default_instance_->issuer_info_;
}
inline ::mt::TMtSecCertDistinctName* TMtSecCertInfo::mutable_issuer_info() {
  set_has_issuer_info();
  if (issuer_info_ == NULL) issuer_info_ = new ::mt::TMtSecCertDistinctName;
  return issuer_info_;
}
inline ::mt::TMtSecCertDistinctName* TMtSecCertInfo::release_issuer_info() {
  clear_has_issuer_info();
  ::mt::TMtSecCertDistinctName* temp = issuer_info_;
  issuer_info_ = NULL;
  return temp;
}
inline void TMtSecCertInfo::set_allocated_issuer_info(::mt::TMtSecCertDistinctName* issuer_info) {
  delete issuer_info_;
  issuer_info_ = issuer_info;
  if (issuer_info) {
    set_has_issuer_info();
  } else {
    clear_has_issuer_info();
  }
}

// optional .mt.TMtSecCertValidity validity = 5;
inline bool TMtSecCertInfo::has_validity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMtSecCertInfo::set_has_validity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMtSecCertInfo::clear_has_validity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMtSecCertInfo::clear_validity() {
  if (validity_ != NULL) validity_->::mt::TMtSecCertValidity::Clear();
  clear_has_validity();
}
inline const ::mt::TMtSecCertValidity& TMtSecCertInfo::validity() const {
  return validity_ != NULL ? *validity_ : *default_instance_->validity_;
}
inline ::mt::TMtSecCertValidity* TMtSecCertInfo::mutable_validity() {
  set_has_validity();
  if (validity_ == NULL) validity_ = new ::mt::TMtSecCertValidity;
  return validity_;
}
inline ::mt::TMtSecCertValidity* TMtSecCertInfo::release_validity() {
  clear_has_validity();
  ::mt::TMtSecCertValidity* temp = validity_;
  validity_ = NULL;
  return temp;
}
inline void TMtSecCertInfo::set_allocated_validity(::mt::TMtSecCertValidity* validity) {
  delete validity_;
  validity_ = validity;
  if (validity) {
    set_has_validity();
  } else {
    clear_has_validity();
  }
}

// optional .mt.TMtSecCertDistinctName subject_info = 6;
inline bool TMtSecCertInfo::has_subject_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMtSecCertInfo::set_has_subject_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMtSecCertInfo::clear_has_subject_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMtSecCertInfo::clear_subject_info() {
  if (subject_info_ != NULL) subject_info_->::mt::TMtSecCertDistinctName::Clear();
  clear_has_subject_info();
}
inline const ::mt::TMtSecCertDistinctName& TMtSecCertInfo::subject_info() const {
  return subject_info_ != NULL ? *subject_info_ : *default_instance_->subject_info_;
}
inline ::mt::TMtSecCertDistinctName* TMtSecCertInfo::mutable_subject_info() {
  set_has_subject_info();
  if (subject_info_ == NULL) subject_info_ = new ::mt::TMtSecCertDistinctName;
  return subject_info_;
}
inline ::mt::TMtSecCertDistinctName* TMtSecCertInfo::release_subject_info() {
  clear_has_subject_info();
  ::mt::TMtSecCertDistinctName* temp = subject_info_;
  subject_info_ = NULL;
  return temp;
}
inline void TMtSecCertInfo::set_allocated_subject_info(::mt::TMtSecCertDistinctName* subject_info) {
  delete subject_info_;
  subject_info_ = subject_info;
  if (subject_info) {
    set_has_subject_info();
  } else {
    clear_has_subject_info();
  }
}

// optional string pubkey_alg = 7;
inline bool TMtSecCertInfo::has_pubkey_alg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMtSecCertInfo::set_has_pubkey_alg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMtSecCertInfo::clear_has_pubkey_alg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMtSecCertInfo::clear_pubkey_alg() {
  if (pubkey_alg_ != &::google::protobuf::internal::kEmptyString) {
    pubkey_alg_->clear();
  }
  clear_has_pubkey_alg();
}
inline const ::std::string& TMtSecCertInfo::pubkey_alg() const {
  return *pubkey_alg_;
}
inline void TMtSecCertInfo::set_pubkey_alg(const ::std::string& value) {
  set_has_pubkey_alg();
  if (pubkey_alg_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_alg_ = new ::std::string;
  }
  pubkey_alg_->assign(value);
}
inline void TMtSecCertInfo::set_pubkey_alg(const char* value) {
  set_has_pubkey_alg();
  if (pubkey_alg_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_alg_ = new ::std::string;
  }
  pubkey_alg_->assign(value);
}
inline void TMtSecCertInfo::set_pubkey_alg(const char* value, size_t size) {
  set_has_pubkey_alg();
  if (pubkey_alg_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_alg_ = new ::std::string;
  }
  pubkey_alg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertInfo::mutable_pubkey_alg() {
  set_has_pubkey_alg();
  if (pubkey_alg_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_alg_ = new ::std::string;
  }
  return pubkey_alg_;
}
inline ::std::string* TMtSecCertInfo::release_pubkey_alg() {
  clear_has_pubkey_alg();
  if (pubkey_alg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubkey_alg_;
    pubkey_alg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertInfo::set_allocated_pubkey_alg(::std::string* pubkey_alg) {
  if (pubkey_alg_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_alg_;
  }
  if (pubkey_alg) {
    set_has_pubkey_alg();
    pubkey_alg_ = pubkey_alg;
  } else {
    clear_has_pubkey_alg();
    pubkey_alg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes finger_print = 8;
inline bool TMtSecCertInfo::has_finger_print() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMtSecCertInfo::set_has_finger_print() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMtSecCertInfo::clear_has_finger_print() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMtSecCertInfo::clear_finger_print() {
  if (finger_print_ != &::google::protobuf::internal::kEmptyString) {
    finger_print_->clear();
  }
  clear_has_finger_print();
}
inline const ::std::string& TMtSecCertInfo::finger_print() const {
  return *finger_print_;
}
inline void TMtSecCertInfo::set_finger_print(const ::std::string& value) {
  set_has_finger_print();
  if (finger_print_ == &::google::protobuf::internal::kEmptyString) {
    finger_print_ = new ::std::string;
  }
  finger_print_->assign(value);
}
inline void TMtSecCertInfo::set_finger_print(const char* value) {
  set_has_finger_print();
  if (finger_print_ == &::google::protobuf::internal::kEmptyString) {
    finger_print_ = new ::std::string;
  }
  finger_print_->assign(value);
}
inline void TMtSecCertInfo::set_finger_print(const void* value, size_t size) {
  set_has_finger_print();
  if (finger_print_ == &::google::protobuf::internal::kEmptyString) {
    finger_print_ = new ::std::string;
  }
  finger_print_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCertInfo::mutable_finger_print() {
  set_has_finger_print();
  if (finger_print_ == &::google::protobuf::internal::kEmptyString) {
    finger_print_ = new ::std::string;
  }
  return finger_print_;
}
inline ::std::string* TMtSecCertInfo::release_finger_print() {
  clear_has_finger_print();
  if (finger_print_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = finger_print_;
    finger_print_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCertInfo::set_allocated_finger_print(::std::string* finger_print) {
  if (finger_print_ != &::google::protobuf::internal::kEmptyString) {
    delete finger_print_;
  }
  if (finger_print) {
    set_has_finger_print();
    finger_print_ = finger_print;
  } else {
    clear_has_finger_print();
    finger_print_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 format = 9;
inline bool TMtSecCertInfo::has_format() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMtSecCertInfo::set_has_format() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMtSecCertInfo::clear_has_format() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMtSecCertInfo::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::google::protobuf::int32 TMtSecCertInfo::format() const {
  return format_;
}
inline void TMtSecCertInfo::set_format(::google::protobuf::int32 value) {
  set_has_format();
  format_ = value;
}

// -------------------------------------------------------------------

// TRpMtSecCaIDList

// repeated bytes cacert_id = 1;
inline int TRpMtSecCaIDList::cacert_id_size() const {
  return cacert_id_.size();
}
inline void TRpMtSecCaIDList::clear_cacert_id() {
  cacert_id_.Clear();
}
inline const ::std::string& TRpMtSecCaIDList::cacert_id(int index) const {
  return cacert_id_.Get(index);
}
inline ::std::string* TRpMtSecCaIDList::mutable_cacert_id(int index) {
  return cacert_id_.Mutable(index);
}
inline void TRpMtSecCaIDList::set_cacert_id(int index, const ::std::string& value) {
  cacert_id_.Mutable(index)->assign(value);
}
inline void TRpMtSecCaIDList::set_cacert_id(int index, const char* value) {
  cacert_id_.Mutable(index)->assign(value);
}
inline void TRpMtSecCaIDList::set_cacert_id(int index, const void* value, size_t size) {
  cacert_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TRpMtSecCaIDList::add_cacert_id() {
  return cacert_id_.Add();
}
inline void TRpMtSecCaIDList::add_cacert_id(const ::std::string& value) {
  cacert_id_.Add()->assign(value);
}
inline void TRpMtSecCaIDList::add_cacert_id(const char* value) {
  cacert_id_.Add()->assign(value);
}
inline void TRpMtSecCaIDList::add_cacert_id(const void* value, size_t size) {
  cacert_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TRpMtSecCaIDList::cacert_id() const {
  return cacert_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TRpMtSecCaIDList::mutable_cacert_id() {
  return &cacert_id_;
}

// -------------------------------------------------------------------

// TMtTerAuthCmd

// optional string auther_name = 1;
inline bool TMtTerAuthCmd::has_auther_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtTerAuthCmd::set_has_auther_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtTerAuthCmd::clear_has_auther_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtTerAuthCmd::clear_auther_name() {
  if (auther_name_ != &::google::protobuf::internal::kEmptyString) {
    auther_name_->clear();
  }
  clear_has_auther_name();
}
inline const ::std::string& TMtTerAuthCmd::auther_name() const {
  return *auther_name_;
}
inline void TMtTerAuthCmd::set_auther_name(const ::std::string& value) {
  set_has_auther_name();
  if (auther_name_ == &::google::protobuf::internal::kEmptyString) {
    auther_name_ = new ::std::string;
  }
  auther_name_->assign(value);
}
inline void TMtTerAuthCmd::set_auther_name(const char* value) {
  set_has_auther_name();
  if (auther_name_ == &::google::protobuf::internal::kEmptyString) {
    auther_name_ = new ::std::string;
  }
  auther_name_->assign(value);
}
inline void TMtTerAuthCmd::set_auther_name(const char* value, size_t size) {
  set_has_auther_name();
  if (auther_name_ == &::google::protobuf::internal::kEmptyString) {
    auther_name_ = new ::std::string;
  }
  auther_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtTerAuthCmd::mutable_auther_name() {
  set_has_auther_name();
  if (auther_name_ == &::google::protobuf::internal::kEmptyString) {
    auther_name_ = new ::std::string;
  }
  return auther_name_;
}
inline ::std::string* TMtTerAuthCmd::release_auther_name() {
  clear_has_auther_name();
  if (auther_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auther_name_;
    auther_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtTerAuthCmd::set_allocated_auther_name(::std::string* auther_name) {
  if (auther_name_ != &::google::protobuf::internal::kEmptyString) {
    delete auther_name_;
  }
  if (auther_name) {
    set_has_auther_name();
    auther_name_ = auther_name;
  } else {
    clear_has_auther_name();
    auther_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string authee_name = 2;
inline bool TMtTerAuthCmd::has_authee_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtTerAuthCmd::set_has_authee_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtTerAuthCmd::clear_has_authee_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtTerAuthCmd::clear_authee_name() {
  if (authee_name_ != &::google::protobuf::internal::kEmptyString) {
    authee_name_->clear();
  }
  clear_has_authee_name();
}
inline const ::std::string& TMtTerAuthCmd::authee_name() const {
  return *authee_name_;
}
inline void TMtTerAuthCmd::set_authee_name(const ::std::string& value) {
  set_has_authee_name();
  if (authee_name_ == &::google::protobuf::internal::kEmptyString) {
    authee_name_ = new ::std::string;
  }
  authee_name_->assign(value);
}
inline void TMtTerAuthCmd::set_authee_name(const char* value) {
  set_has_authee_name();
  if (authee_name_ == &::google::protobuf::internal::kEmptyString) {
    authee_name_ = new ::std::string;
  }
  authee_name_->assign(value);
}
inline void TMtTerAuthCmd::set_authee_name(const char* value, size_t size) {
  set_has_authee_name();
  if (authee_name_ == &::google::protobuf::internal::kEmptyString) {
    authee_name_ = new ::std::string;
  }
  authee_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtTerAuthCmd::mutable_authee_name() {
  set_has_authee_name();
  if (authee_name_ == &::google::protobuf::internal::kEmptyString) {
    authee_name_ = new ::std::string;
  }
  return authee_name_;
}
inline ::std::string* TMtTerAuthCmd::release_authee_name() {
  clear_has_authee_name();
  if (authee_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authee_name_;
    authee_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtTerAuthCmd::set_allocated_authee_name(::std::string* authee_name) {
  if (authee_name_ != &::google::protobuf::internal::kEmptyString) {
    delete authee_name_;
  }
  if (authee_name) {
    set_has_authee_name();
    authee_name_ = authee_name;
  } else {
    clear_has_authee_name();
    authee_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtTerAuthRequest

// optional string username = 1;
inline bool TMtTerAuthRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtTerAuthRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtTerAuthRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtTerAuthRequest::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TMtTerAuthRequest::username() const {
  return *username_;
}
inline void TMtTerAuthRequest::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMtTerAuthRequest::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TMtTerAuthRequest::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtTerAuthRequest::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TMtTerAuthRequest::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtTerAuthRequest::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool TMtTerAuthRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtTerAuthRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtTerAuthRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtTerAuthRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TMtTerAuthRequest::password() const {
  return *password_;
}
inline void TMtTerAuthRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtTerAuthRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TMtTerAuthRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtTerAuthRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TMtTerAuthRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtTerAuthRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtTerAuthCancel

// optional string auther_name = 1;
inline bool TMtTerAuthCancel::has_auther_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtTerAuthCancel::set_has_auther_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtTerAuthCancel::clear_has_auther_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtTerAuthCancel::clear_auther_name() {
  if (auther_name_ != &::google::protobuf::internal::kEmptyString) {
    auther_name_->clear();
  }
  clear_has_auther_name();
}
inline const ::std::string& TMtTerAuthCancel::auther_name() const {
  return *auther_name_;
}
inline void TMtTerAuthCancel::set_auther_name(const ::std::string& value) {
  set_has_auther_name();
  if (auther_name_ == &::google::protobuf::internal::kEmptyString) {
    auther_name_ = new ::std::string;
  }
  auther_name_->assign(value);
}
inline void TMtTerAuthCancel::set_auther_name(const char* value) {
  set_has_auther_name();
  if (auther_name_ == &::google::protobuf::internal::kEmptyString) {
    auther_name_ = new ::std::string;
  }
  auther_name_->assign(value);
}
inline void TMtTerAuthCancel::set_auther_name(const char* value, size_t size) {
  set_has_auther_name();
  if (auther_name_ == &::google::protobuf::internal::kEmptyString) {
    auther_name_ = new ::std::string;
  }
  auther_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtTerAuthCancel::mutable_auther_name() {
  set_has_auther_name();
  if (auther_name_ == &::google::protobuf::internal::kEmptyString) {
    auther_name_ = new ::std::string;
  }
  return auther_name_;
}
inline ::std::string* TMtTerAuthCancel::release_auther_name() {
  clear_has_auther_name();
  if (auther_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auther_name_;
    auther_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtTerAuthCancel::set_allocated_auther_name(::std::string* auther_name) {
  if (auther_name_ != &::google::protobuf::internal::kEmptyString) {
    delete auther_name_;
  }
  if (auther_name) {
    set_has_auther_name();
    auther_name_ = auther_name;
  } else {
    clear_has_auther_name();
    auther_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string authee_name = 2;
inline bool TMtTerAuthCancel::has_authee_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtTerAuthCancel::set_has_authee_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtTerAuthCancel::clear_has_authee_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtTerAuthCancel::clear_authee_name() {
  if (authee_name_ != &::google::protobuf::internal::kEmptyString) {
    authee_name_->clear();
  }
  clear_has_authee_name();
}
inline const ::std::string& TMtTerAuthCancel::authee_name() const {
  return *authee_name_;
}
inline void TMtTerAuthCancel::set_authee_name(const ::std::string& value) {
  set_has_authee_name();
  if (authee_name_ == &::google::protobuf::internal::kEmptyString) {
    authee_name_ = new ::std::string;
  }
  authee_name_->assign(value);
}
inline void TMtTerAuthCancel::set_authee_name(const char* value) {
  set_has_authee_name();
  if (authee_name_ == &::google::protobuf::internal::kEmptyString) {
    authee_name_ = new ::std::string;
  }
  authee_name_->assign(value);
}
inline void TMtTerAuthCancel::set_authee_name(const char* value, size_t size) {
  set_has_authee_name();
  if (authee_name_ == &::google::protobuf::internal::kEmptyString) {
    authee_name_ = new ::std::string;
  }
  authee_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtTerAuthCancel::mutable_authee_name() {
  set_has_authee_name();
  if (authee_name_ == &::google::protobuf::internal::kEmptyString) {
    authee_name_ = new ::std::string;
  }
  return authee_name_;
}
inline ::std::string* TMtTerAuthCancel::release_authee_name() {
  clear_has_authee_name();
  if (authee_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authee_name_;
    authee_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtTerAuthCancel::set_allocated_authee_name(::std::string* authee_name) {
  if (authee_name_ != &::google::protobuf::internal::kEmptyString) {
    delete authee_name_;
  }
  if (authee_name) {
    set_has_authee_name();
    authee_name_ = authee_name;
  } else {
    clear_has_authee_name();
    authee_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtTerAuthMsg

// optional int32 is_authforcall = 1;
inline bool TMtTerAuthMsg::has_is_authforcall() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtTerAuthMsg::set_has_is_authforcall() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtTerAuthMsg::clear_has_is_authforcall() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtTerAuthMsg::clear_is_authforcall() {
  is_authforcall_ = 0;
  clear_has_is_authforcall();
}
inline ::google::protobuf::int32 TMtTerAuthMsg::is_authforcall() const {
  return is_authforcall_;
}
inline void TMtTerAuthMsg::set_is_authforcall(::google::protobuf::int32 value) {
  set_has_is_authforcall();
  is_authforcall_ = value;
}

// optional string callid = 2;
inline bool TMtTerAuthMsg::has_callid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtTerAuthMsg::set_has_callid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtTerAuthMsg::clear_has_callid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtTerAuthMsg::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& TMtTerAuthMsg::callid() const {
  return *callid_;
}
inline void TMtTerAuthMsg::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void TMtTerAuthMsg::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void TMtTerAuthMsg::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtTerAuthMsg::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* TMtTerAuthMsg::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtTerAuthMsg::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMtSecCreateCertReq

// optional bool is_sign = 1;
inline bool TMtSecCreateCertReq::has_is_sign() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtSecCreateCertReq::set_has_is_sign() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtSecCreateCertReq::clear_has_is_sign() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtSecCreateCertReq::clear_is_sign() {
  is_sign_ = false;
  clear_has_is_sign();
}
inline bool TMtSecCreateCertReq::is_sign() const {
  return is_sign_;
}
inline void TMtSecCreateCertReq::set_is_sign(bool value) {
  set_has_is_sign();
  is_sign_ = value;
}

// optional bool is_resetpwd = 2;
inline bool TMtSecCreateCertReq::has_is_resetpwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtSecCreateCertReq::set_has_is_resetpwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtSecCreateCertReq::clear_has_is_resetpwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtSecCreateCertReq::clear_is_resetpwd() {
  is_resetpwd_ = false;
  clear_has_is_resetpwd();
}
inline bool TMtSecCreateCertReq::is_resetpwd() const {
  return is_resetpwd_;
}
inline void TMtSecCreateCertReq::set_is_resetpwd(bool value) {
  set_has_is_resetpwd();
  is_resetpwd_ = value;
}

// optional string devicecert_fileName = 3;
inline bool TMtSecCreateCertReq::has_devicecert_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtSecCreateCertReq::set_has_devicecert_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtSecCreateCertReq::clear_has_devicecert_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtSecCreateCertReq::clear_devicecert_filename() {
  if (devicecert_filename_ != &::google::protobuf::internal::kEmptyString) {
    devicecert_filename_->clear();
  }
  clear_has_devicecert_filename();
}
inline const ::std::string& TMtSecCreateCertReq::devicecert_filename() const {
  return *devicecert_filename_;
}
inline void TMtSecCreateCertReq::set_devicecert_filename(const ::std::string& value) {
  set_has_devicecert_filename();
  if (devicecert_filename_ == &::google::protobuf::internal::kEmptyString) {
    devicecert_filename_ = new ::std::string;
  }
  devicecert_filename_->assign(value);
}
inline void TMtSecCreateCertReq::set_devicecert_filename(const char* value) {
  set_has_devicecert_filename();
  if (devicecert_filename_ == &::google::protobuf::internal::kEmptyString) {
    devicecert_filename_ = new ::std::string;
  }
  devicecert_filename_->assign(value);
}
inline void TMtSecCreateCertReq::set_devicecert_filename(const char* value, size_t size) {
  set_has_devicecert_filename();
  if (devicecert_filename_ == &::google::protobuf::internal::kEmptyString) {
    devicecert_filename_ = new ::std::string;
  }
  devicecert_filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtSecCreateCertReq::mutable_devicecert_filename() {
  set_has_devicecert_filename();
  if (devicecert_filename_ == &::google::protobuf::internal::kEmptyString) {
    devicecert_filename_ = new ::std::string;
  }
  return devicecert_filename_;
}
inline ::std::string* TMtSecCreateCertReq::release_devicecert_filename() {
  clear_has_devicecert_filename();
  if (devicecert_filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicecert_filename_;
    devicecert_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtSecCreateCertReq::set_allocated_devicecert_filename(::std::string* devicecert_filename) {
  if (devicecert_filename_ != &::google::protobuf::internal::kEmptyString) {
    delete devicecert_filename_;
  }
  if (devicecert_filename) {
    set_has_devicecert_filename();
    devicecert_filename_ = devicecert_filename;
  } else {
    clear_has_devicecert_filename();
    devicecert_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.TMtSecCertDistinctName name = 4;
inline bool TMtSecCreateCertReq::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtSecCreateCertReq::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtSecCreateCertReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtSecCreateCertReq::clear_name() {
  if (name_ != NULL) name_->::mt::TMtSecCertDistinctName::Clear();
  clear_has_name();
}
inline const ::mt::TMtSecCertDistinctName& TMtSecCreateCertReq::name() const {
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::mt::TMtSecCertDistinctName* TMtSecCreateCertReq::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::mt::TMtSecCertDistinctName;
  return name_;
}
inline ::mt::TMtSecCertDistinctName* TMtSecCreateCertReq::release_name() {
  clear_has_name();
  ::mt::TMtSecCertDistinctName* temp = name_;
  name_ = NULL;
  return temp;
}
inline void TMtSecCreateCertReq::set_allocated_name(::mt::TMtSecCertDistinctName* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
}

// -------------------------------------------------------------------

// TMtVrsUserInfo

// optional int32 rightmask = 1;
inline bool TMtVrsUserInfo::has_rightmask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtVrsUserInfo::set_has_rightmask() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtVrsUserInfo::clear_has_rightmask() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtVrsUserInfo::clear_rightmask() {
  rightmask_ = 0;
  clear_has_rightmask();
}
inline ::google::protobuf::int32 TMtVrsUserInfo::rightmask() const {
  return rightmask_;
}
inline void TMtVrsUserInfo::set_rightmask(::google::protobuf::int32 value) {
  set_has_rightmask();
  rightmask_ = value;
}

// optional string token = 2;
inline bool TMtVrsUserInfo::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtVrsUserInfo::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtVrsUserInfo::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtVrsUserInfo::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& TMtVrsUserInfo::token() const {
  return *token_;
}
inline void TMtVrsUserInfo::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void TMtVrsUserInfo::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void TMtVrsUserInfo::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVrsUserInfo::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* TMtVrsUserInfo::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVrsUserInfo::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdomainmoid = 3;
inline bool TMtVrsUserInfo::has_userdomainmoid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtVrsUserInfo::set_has_userdomainmoid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtVrsUserInfo::clear_has_userdomainmoid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtVrsUserInfo::clear_userdomainmoid() {
  if (userdomainmoid_ != &::google::protobuf::internal::kEmptyString) {
    userdomainmoid_->clear();
  }
  clear_has_userdomainmoid();
}
inline const ::std::string& TMtVrsUserInfo::userdomainmoid() const {
  return *userdomainmoid_;
}
inline void TMtVrsUserInfo::set_userdomainmoid(const ::std::string& value) {
  set_has_userdomainmoid();
  if (userdomainmoid_ == &::google::protobuf::internal::kEmptyString) {
    userdomainmoid_ = new ::std::string;
  }
  userdomainmoid_->assign(value);
}
inline void TMtVrsUserInfo::set_userdomainmoid(const char* value) {
  set_has_userdomainmoid();
  if (userdomainmoid_ == &::google::protobuf::internal::kEmptyString) {
    userdomainmoid_ = new ::std::string;
  }
  userdomainmoid_->assign(value);
}
inline void TMtVrsUserInfo::set_userdomainmoid(const char* value, size_t size) {
  set_has_userdomainmoid();
  if (userdomainmoid_ == &::google::protobuf::internal::kEmptyString) {
    userdomainmoid_ = new ::std::string;
  }
  userdomainmoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVrsUserInfo::mutable_userdomainmoid() {
  set_has_userdomainmoid();
  if (userdomainmoid_ == &::google::protobuf::internal::kEmptyString) {
    userdomainmoid_ = new ::std::string;
  }
  return userdomainmoid_;
}
inline ::std::string* TMtVrsUserInfo::release_userdomainmoid() {
  clear_has_userdomainmoid();
  if (userdomainmoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdomainmoid_;
    userdomainmoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVrsUserInfo::set_allocated_userdomainmoid(::std::string* userdomainmoid) {
  if (userdomainmoid_ != &::google::protobuf::internal::kEmptyString) {
    delete userdomainmoid_;
  }
  if (userdomainmoid) {
    set_has_userdomainmoid();
    userdomainmoid_ = userdomainmoid;
  } else {
    clear_has_userdomainmoid();
    userdomainmoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string usermoid = 4;
inline bool TMtVrsUserInfo::has_usermoid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtVrsUserInfo::set_has_usermoid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtVrsUserInfo::clear_has_usermoid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtVrsUserInfo::clear_usermoid() {
  if (usermoid_ != &::google::protobuf::internal::kEmptyString) {
    usermoid_->clear();
  }
  clear_has_usermoid();
}
inline const ::std::string& TMtVrsUserInfo::usermoid() const {
  return *usermoid_;
}
inline void TMtVrsUserInfo::set_usermoid(const ::std::string& value) {
  set_has_usermoid();
  if (usermoid_ == &::google::protobuf::internal::kEmptyString) {
    usermoid_ = new ::std::string;
  }
  usermoid_->assign(value);
}
inline void TMtVrsUserInfo::set_usermoid(const char* value) {
  set_has_usermoid();
  if (usermoid_ == &::google::protobuf::internal::kEmptyString) {
    usermoid_ = new ::std::string;
  }
  usermoid_->assign(value);
}
inline void TMtVrsUserInfo::set_usermoid(const char* value, size_t size) {
  set_has_usermoid();
  if (usermoid_ == &::google::protobuf::internal::kEmptyString) {
    usermoid_ = new ::std::string;
  }
  usermoid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtVrsUserInfo::mutable_usermoid() {
  set_has_usermoid();
  if (usermoid_ == &::google::protobuf::internal::kEmptyString) {
    usermoid_ = new ::std::string;
  }
  return usermoid_;
}
inline ::std::string* TMtVrsUserInfo::release_usermoid() {
  clear_has_usermoid();
  if (usermoid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usermoid_;
    usermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtVrsUserInfo::set_allocated_usermoid(::std::string* usermoid) {
  if (usermoid_ != &::google::protobuf::internal::kEmptyString) {
    delete usermoid_;
  }
  if (usermoid) {
    set_has_usermoid();
    usermoid_ = usermoid;
  } else {
    clear_has_usermoid();
    usermoid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TLicense

// optional .mt.EmVersionType KeyVersion_Type = 1;
inline bool TLicense::has_keyversion_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TLicense::set_has_keyversion_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TLicense::clear_has_keyversion_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TLicense::clear_keyversion_type() {
  keyversion_type_ = 0;
  clear_has_keyversion_type();
}
inline ::mt::EmVersionType TLicense::keyversion_type() const {
  return static_cast< ::mt::EmVersionType >(keyversion_type_);
}
inline void TLicense::set_keyversion_type(::mt::EmVersionType value) {
  assert(::mt::EmVersionType_IsValid(value));
  set_has_keyversion_type();
  keyversion_type_ = value;
}

// optional .mt.EmMtModel emKeyTerminalType = 2;
inline bool TLicense::has_emkeyterminaltype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TLicense::set_has_emkeyterminaltype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TLicense::clear_has_emkeyterminaltype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TLicense::clear_emkeyterminaltype() {
  emkeyterminaltype_ = 0;
  clear_has_emkeyterminaltype();
}
inline ::mt::EmMtModel TLicense::emkeyterminaltype() const {
  return static_cast< ::mt::EmMtModel >(emkeyterminaltype_);
}
inline void TLicense::set_emkeyterminaltype(::mt::EmMtModel value) {
  assert(::mt::EmMtModel_IsValid(value));
  set_has_emkeyterminaltype();
  emkeyterminaltype_ = value;
}

// optional bool KeyChannelAccess = 3;
inline bool TLicense::has_keychannelaccess() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TLicense::set_has_keychannelaccess() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TLicense::clear_has_keychannelaccess() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TLicense::clear_keychannelaccess() {
  keychannelaccess_ = false;
  clear_has_keychannelaccess();
}
inline bool TLicense::keychannelaccess() const {
  return keychannelaccess_;
}
inline void TLicense::set_keychannelaccess(bool value) {
  set_has_keychannelaccess();
  keychannelaccess_ = value;
}

// optional bool KeyHybridcloudAccess = 4;
inline bool TLicense::has_keyhybridcloudaccess() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TLicense::set_has_keyhybridcloudaccess() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TLicense::clear_has_keyhybridcloudaccess() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TLicense::clear_keyhybridcloudaccess() {
  keyhybridcloudaccess_ = false;
  clear_has_keyhybridcloudaccess();
}
inline bool TLicense::keyhybridcloudaccess() const {
  return keyhybridcloudaccess_;
}
inline void TLicense::set_keyhybridcloudaccess(bool value) {
  set_has_keyhybridcloudaccess();
  keyhybridcloudaccess_ = value;
}

// optional bool KeyPubliccloudAccess = 5;
inline bool TLicense::has_keypubliccloudaccess() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TLicense::set_has_keypubliccloudaccess() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TLicense::clear_has_keypubliccloudaccess() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TLicense::clear_keypubliccloudaccess() {
  keypubliccloudaccess_ = false;
  clear_has_keypubliccloudaccess();
}
inline bool TLicense::keypubliccloudaccess() const {
  return keypubliccloudaccess_;
}
inline void TLicense::set_keypubliccloudaccess(bool value) {
  set_has_keypubliccloudaccess();
  keypubliccloudaccess_ = value;
}

// optional string KeyTerminalDeviceId = 6;
inline bool TLicense::has_keyterminaldeviceid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TLicense::set_has_keyterminaldeviceid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TLicense::clear_has_keyterminaldeviceid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TLicense::clear_keyterminaldeviceid() {
  if (keyterminaldeviceid_ != &::google::protobuf::internal::kEmptyString) {
    keyterminaldeviceid_->clear();
  }
  clear_has_keyterminaldeviceid();
}
inline const ::std::string& TLicense::keyterminaldeviceid() const {
  return *keyterminaldeviceid_;
}
inline void TLicense::set_keyterminaldeviceid(const ::std::string& value) {
  set_has_keyterminaldeviceid();
  if (keyterminaldeviceid_ == &::google::protobuf::internal::kEmptyString) {
    keyterminaldeviceid_ = new ::std::string;
  }
  keyterminaldeviceid_->assign(value);
}
inline void TLicense::set_keyterminaldeviceid(const char* value) {
  set_has_keyterminaldeviceid();
  if (keyterminaldeviceid_ == &::google::protobuf::internal::kEmptyString) {
    keyterminaldeviceid_ = new ::std::string;
  }
  keyterminaldeviceid_->assign(value);
}
inline void TLicense::set_keyterminaldeviceid(const char* value, size_t size) {
  set_has_keyterminaldeviceid();
  if (keyterminaldeviceid_ == &::google::protobuf::internal::kEmptyString) {
    keyterminaldeviceid_ = new ::std::string;
  }
  keyterminaldeviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TLicense::mutable_keyterminaldeviceid() {
  set_has_keyterminaldeviceid();
  if (keyterminaldeviceid_ == &::google::protobuf::internal::kEmptyString) {
    keyterminaldeviceid_ = new ::std::string;
  }
  return keyterminaldeviceid_;
}
inline ::std::string* TLicense::release_keyterminaldeviceid() {
  clear_has_keyterminaldeviceid();
  if (keyterminaldeviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyterminaldeviceid_;
    keyterminaldeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TLicense::set_allocated_keyterminaldeviceid(::std::string* keyterminaldeviceid) {
  if (keyterminaldeviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete keyterminaldeviceid_;
  }
  if (keyterminaldeviceid) {
    set_has_keyterminaldeviceid();
    keyterminaldeviceid_ = keyterminaldeviceid;
  } else {
    clear_has_keyterminaldeviceid();
    keyterminaldeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string UserType = 7;
inline bool TLicense::has_usertype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TLicense::set_has_usertype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TLicense::clear_has_usertype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TLicense::clear_usertype() {
  if (usertype_ != &::google::protobuf::internal::kEmptyString) {
    usertype_->clear();
  }
  clear_has_usertype();
}
inline const ::std::string& TLicense::usertype() const {
  return *usertype_;
}
inline void TLicense::set_usertype(const ::std::string& value) {
  set_has_usertype();
  if (usertype_ == &::google::protobuf::internal::kEmptyString) {
    usertype_ = new ::std::string;
  }
  usertype_->assign(value);
}
inline void TLicense::set_usertype(const char* value) {
  set_has_usertype();
  if (usertype_ == &::google::protobuf::internal::kEmptyString) {
    usertype_ = new ::std::string;
  }
  usertype_->assign(value);
}
inline void TLicense::set_usertype(const char* value, size_t size) {
  set_has_usertype();
  if (usertype_ == &::google::protobuf::internal::kEmptyString) {
    usertype_ = new ::std::string;
  }
  usertype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TLicense::mutable_usertype() {
  set_has_usertype();
  if (usertype_ == &::google::protobuf::internal::kEmptyString) {
    usertype_ = new ::std::string;
  }
  return usertype_;
}
inline ::std::string* TLicense::release_usertype() {
  clear_has_usertype();
  if (usertype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usertype_;
    usertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TLicense::set_allocated_usertype(::std::string* usertype) {
  if (usertype_ != &::google::protobuf::internal::kEmptyString) {
    delete usertype_;
  }
  if (usertype) {
    set_has_usertype();
    usertype_ = usertype;
  } else {
    clear_has_usertype();
    usertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ContractNode = 8;
inline bool TLicense::has_contractnode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TLicense::set_has_contractnode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TLicense::clear_has_contractnode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TLicense::clear_contractnode() {
  if (contractnode_ != &::google::protobuf::internal::kEmptyString) {
    contractnode_->clear();
  }
  clear_has_contractnode();
}
inline const ::std::string& TLicense::contractnode() const {
  return *contractnode_;
}
inline void TLicense::set_contractnode(const ::std::string& value) {
  set_has_contractnode();
  if (contractnode_ == &::google::protobuf::internal::kEmptyString) {
    contractnode_ = new ::std::string;
  }
  contractnode_->assign(value);
}
inline void TLicense::set_contractnode(const char* value) {
  set_has_contractnode();
  if (contractnode_ == &::google::protobuf::internal::kEmptyString) {
    contractnode_ = new ::std::string;
  }
  contractnode_->assign(value);
}
inline void TLicense::set_contractnode(const char* value, size_t size) {
  set_has_contractnode();
  if (contractnode_ == &::google::protobuf::internal::kEmptyString) {
    contractnode_ = new ::std::string;
  }
  contractnode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TLicense::mutable_contractnode() {
  set_has_contractnode();
  if (contractnode_ == &::google::protobuf::internal::kEmptyString) {
    contractnode_ = new ::std::string;
  }
  return contractnode_;
}
inline ::std::string* TLicense::release_contractnode() {
  clear_has_contractnode();
  if (contractnode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contractnode_;
    contractnode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TLicense::set_allocated_contractnode(::std::string* contractnode) {
  if (contractnode_ != &::google::protobuf::internal::kEmptyString) {
    delete contractnode_;
  }
  if (contractnode) {
    set_has_contractnode();
    contractnode_ = contractnode;
  } else {
    clear_has_contractnode();
    contractnode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomerName = 9;
inline bool TLicense::has_customername() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TLicense::set_has_customername() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TLicense::clear_has_customername() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TLicense::clear_customername() {
  if (customername_ != &::google::protobuf::internal::kEmptyString) {
    customername_->clear();
  }
  clear_has_customername();
}
inline const ::std::string& TLicense::customername() const {
  return *customername_;
}
inline void TLicense::set_customername(const ::std::string& value) {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::kEmptyString) {
    customername_ = new ::std::string;
  }
  customername_->assign(value);
}
inline void TLicense::set_customername(const char* value) {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::kEmptyString) {
    customername_ = new ::std::string;
  }
  customername_->assign(value);
}
inline void TLicense::set_customername(const char* value, size_t size) {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::kEmptyString) {
    customername_ = new ::std::string;
  }
  customername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TLicense::mutable_customername() {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::kEmptyString) {
    customername_ = new ::std::string;
  }
  return customername_;
}
inline ::std::string* TLicense::release_customername() {
  clear_has_customername();
  if (customername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customername_;
    customername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TLicense::set_allocated_customername(::std::string* customername) {
  if (customername_ != &::google::protobuf::internal::kEmptyString) {
    delete customername_;
  }
  if (customername) {
    set_has_customername();
    customername_ = customername;
  } else {
    clear_has_customername();
    customername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomerAddress = 10;
inline bool TLicense::has_customeraddress() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TLicense::set_has_customeraddress() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TLicense::clear_has_customeraddress() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TLicense::clear_customeraddress() {
  if (customeraddress_ != &::google::protobuf::internal::kEmptyString) {
    customeraddress_->clear();
  }
  clear_has_customeraddress();
}
inline const ::std::string& TLicense::customeraddress() const {
  return *customeraddress_;
}
inline void TLicense::set_customeraddress(const ::std::string& value) {
  set_has_customeraddress();
  if (customeraddress_ == &::google::protobuf::internal::kEmptyString) {
    customeraddress_ = new ::std::string;
  }
  customeraddress_->assign(value);
}
inline void TLicense::set_customeraddress(const char* value) {
  set_has_customeraddress();
  if (customeraddress_ == &::google::protobuf::internal::kEmptyString) {
    customeraddress_ = new ::std::string;
  }
  customeraddress_->assign(value);
}
inline void TLicense::set_customeraddress(const char* value, size_t size) {
  set_has_customeraddress();
  if (customeraddress_ == &::google::protobuf::internal::kEmptyString) {
    customeraddress_ = new ::std::string;
  }
  customeraddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TLicense::mutable_customeraddress() {
  set_has_customeraddress();
  if (customeraddress_ == &::google::protobuf::internal::kEmptyString) {
    customeraddress_ = new ::std::string;
  }
  return customeraddress_;
}
inline ::std::string* TLicense::release_customeraddress() {
  clear_has_customeraddress();
  if (customeraddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customeraddress_;
    customeraddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TLicense::set_allocated_customeraddress(::std::string* customeraddress) {
  if (customeraddress_ != &::google::protobuf::internal::kEmptyString) {
    delete customeraddress_;
  }
  if (customeraddress) {
    set_has_customeraddress();
    customeraddress_ = customeraddress;
  } else {
    clear_has_customeraddress();
    customeraddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Serler = 11;
inline bool TLicense::has_serler() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TLicense::set_has_serler() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TLicense::clear_has_serler() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TLicense::clear_serler() {
  if (serler_ != &::google::protobuf::internal::kEmptyString) {
    serler_->clear();
  }
  clear_has_serler();
}
inline const ::std::string& TLicense::serler() const {
  return *serler_;
}
inline void TLicense::set_serler(const ::std::string& value) {
  set_has_serler();
  if (serler_ == &::google::protobuf::internal::kEmptyString) {
    serler_ = new ::std::string;
  }
  serler_->assign(value);
}
inline void TLicense::set_serler(const char* value) {
  set_has_serler();
  if (serler_ == &::google::protobuf::internal::kEmptyString) {
    serler_ = new ::std::string;
  }
  serler_->assign(value);
}
inline void TLicense::set_serler(const char* value, size_t size) {
  set_has_serler();
  if (serler_ == &::google::protobuf::internal::kEmptyString) {
    serler_ = new ::std::string;
  }
  serler_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TLicense::mutable_serler() {
  set_has_serler();
  if (serler_ == &::google::protobuf::internal::kEmptyString) {
    serler_ = new ::std::string;
  }
  return serler_;
}
inline ::std::string* TLicense::release_serler() {
  clear_has_serler();
  if (serler_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serler_;
    serler_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TLicense::set_allocated_serler(::std::string* serler) {
  if (serler_ != &::google::protobuf::internal::kEmptyString) {
    delete serler_;
  }
  if (serler) {
    set_has_serler();
    serler_ = serler;
  } else {
    clear_has_serler();
    serler_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Description = 12;
inline bool TLicense::has_description() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TLicense::set_has_description() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TLicense::clear_has_description() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TLicense::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& TLicense::description() const {
  return *description_;
}
inline void TLicense::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TLicense::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TLicense::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TLicense::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* TLicense::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TLicense::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmLicenseKeyCheckValue CheckValue = 13;
inline bool TLicense::has_checkvalue() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TLicense::set_has_checkvalue() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TLicense::clear_has_checkvalue() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TLicense::clear_checkvalue() {
  checkvalue_ = 0;
  clear_has_checkvalue();
}
inline ::mt::EmLicenseKeyCheckValue TLicense::checkvalue() const {
  return static_cast< ::mt::EmLicenseKeyCheckValue >(checkvalue_);
}
inline void TLicense::set_checkvalue(::mt::EmLicenseKeyCheckValue value) {
  assert(::mt::EmLicenseKeyCheckValue_IsValid(value));
  set_has_checkvalue();
  checkvalue_ = value;
}

// -------------------------------------------------------------------

// TMtAiInviteInfo

// optional string name = 1;
inline bool TMtAiInviteInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMtAiInviteInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMtAiInviteInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMtAiInviteInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMtAiInviteInfo::name() const {
  return *name_;
}
inline void TMtAiInviteInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMtAiInviteInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMtAiInviteInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtAiInviteInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMtAiInviteInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtAiInviteInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 2;
inline bool TMtAiInviteInfo::has_e164() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMtAiInviteInfo::set_has_e164() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMtAiInviteInfo::clear_has_e164() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMtAiInviteInfo::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TMtAiInviteInfo::e164() const {
  return *e164_;
}
inline void TMtAiInviteInfo::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMtAiInviteInfo::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TMtAiInviteInfo::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtAiInviteInfo::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TMtAiInviteInfo::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtAiInviteInfo::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 3;
inline bool TMtAiInviteInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMtAiInviteInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMtAiInviteInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMtAiInviteInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& TMtAiInviteInfo::ip() const {
  return *ip_;
}
inline void TMtAiInviteInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TMtAiInviteInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TMtAiInviteInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMtAiInviteInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* TMtAiInviteInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMtAiInviteInfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mt.EmAiContactType emContactType = 4;
inline bool TMtAiInviteInfo::has_emcontacttype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMtAiInviteInfo::set_has_emcontacttype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMtAiInviteInfo::clear_has_emcontacttype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMtAiInviteInfo::clear_emcontacttype() {
  emcontacttype_ = 0;
  clear_has_emcontacttype();
}
inline ::mt::EmAiContactType TMtAiInviteInfo::emcontacttype() const {
  return static_cast< ::mt::EmAiContactType >(emcontacttype_);
}
inline void TMtAiInviteInfo::set_emcontacttype(::mt::EmAiContactType value) {
  assert(::mt::EmAiContactType_IsValid(value));
  set_has_emcontacttype();
  emcontacttype_ = value;
}

// -------------------------------------------------------------------

// TMtAiInviteInfoList

// repeated .mt.TMtAiInviteInfo tAiInvite = 1;
inline int TMtAiInviteInfoList::taiinvite_size() const {
  return taiinvite_.size();
}
inline void TMtAiInviteInfoList::clear_taiinvite() {
  taiinvite_.Clear();
}
inline const ::mt::TMtAiInviteInfo& TMtAiInviteInfoList::taiinvite(int index) const {
  return taiinvite_.Get(index);
}
inline ::mt::TMtAiInviteInfo* TMtAiInviteInfoList::mutable_taiinvite(int index) {
  return taiinvite_.Mutable(index);
}
inline ::mt::TMtAiInviteInfo* TMtAiInviteInfoList::add_taiinvite() {
  return taiinvite_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mt::TMtAiInviteInfo >&
TMtAiInviteInfoList::taiinvite() const {
  return taiinvite_;
}
inline ::google::protobuf::RepeatedPtrField< ::mt::TMtAiInviteInfo >*
TMtAiInviteInfoList::mutable_taiinvite() {
  return &taiinvite_;
}

// -------------------------------------------------------------------

// TVendorCheckConfig

// optional uint32 peerip = 1;
inline bool TVendorCheckConfig::has_peerip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVendorCheckConfig::set_has_peerip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVendorCheckConfig::clear_has_peerip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVendorCheckConfig::clear_peerip() {
  peerip_ = 0u;
  clear_has_peerip();
}
inline ::google::protobuf::uint32 TVendorCheckConfig::peerip() const {
  return peerip_;
}
inline void TVendorCheckConfig::set_peerip(::google::protobuf::uint32 value) {
  set_has_peerip();
  peerip_ = value;
}

// optional uint32 peerport = 2;
inline bool TVendorCheckConfig::has_peerport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVendorCheckConfig::set_has_peerport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVendorCheckConfig::clear_has_peerport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVendorCheckConfig::clear_peerport() {
  peerport_ = 0u;
  clear_has_peerport();
}
inline ::google::protobuf::uint32 TVendorCheckConfig::peerport() const {
  return peerport_;
}
inline void TVendorCheckConfig::set_peerport(::google::protobuf::uint32 value) {
  set_has_peerport();
  peerport_ = value;
}

// optional string path = 3;
inline bool TVendorCheckConfig::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVendorCheckConfig::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVendorCheckConfig::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVendorCheckConfig::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TVendorCheckConfig::path() const {
  return *path_;
}
inline void TVendorCheckConfig::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TVendorCheckConfig::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TVendorCheckConfig::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TVendorCheckConfig::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TVendorCheckConfig::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TVendorCheckConfig::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 localport = 4;
inline bool TVendorCheckConfig::has_localport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVendorCheckConfig::set_has_localport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVendorCheckConfig::clear_has_localport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVendorCheckConfig::clear_localport() {
  localport_ = 0u;
  clear_has_localport();
}
inline ::google::protobuf::uint32 TVendorCheckConfig::localport() const {
  return localport_;
}
inline void TVendorCheckConfig::set_localport(::google::protobuf::uint32 value) {
  set_has_localport();
  localport_ = value;
}

// optional bool is_platform = 5;
inline bool TVendorCheckConfig::has_is_platform() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVendorCheckConfig::set_has_is_platform() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVendorCheckConfig::clear_has_is_platform() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVendorCheckConfig::clear_is_platform() {
  is_platform_ = false;
  clear_has_is_platform();
}
inline bool TVendorCheckConfig::is_platform() const {
  return is_platform_;
}
inline void TVendorCheckConfig::set_is_platform(bool value) {
  set_has_is_platform();
  is_platform_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mt

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_structconf_2eproto__INCLUDED
