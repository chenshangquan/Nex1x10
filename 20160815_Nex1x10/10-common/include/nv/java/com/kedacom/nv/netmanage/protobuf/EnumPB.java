// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nvenum.proto

package com.kedacom.nv.netmanage.protobuf;

public final class EnumPB {
  private EnumPB() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  /**
   * Protobuf enum {@code nv.EmNvSysStartMod}
   *
   * <pre>
   *子系统启动方式
   * </pre>
   */
  public enum EmNvSysStartMod
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvSysStartMod_By_lib = 0;</code>
     *
     * <pre>
     * 静态库加载
     * </pre>
     */
    emNvSysStartMod_By_lib(0, 0),
    /**
     * <code>emNvSysStartMod_By_Dll = 1;</code>
     *
     * <pre>
     * 动态库加载
     * </pre>
     */
    emNvSysStartMod_By_Dll(1, 1),
    /**
     * <code>emNvSysStartMod_By_Process = 2;</code>
     *
     * <pre>
     * 进程加载
     * </pre>
     */
    emNvSysStartMod_By_Process(2, 2),
    /**
     * <code>emNvSysStartMod_End = 3;</code>
     */
    emNvSysStartMod_End(3, 3),
    ;

    /**
     * <code>emNvSysStartMod_By_lib = 0;</code>
     *
     * <pre>
     * 静态库加载
     * </pre>
     */
    public static final int emNvSysStartMod_By_lib_VALUE = 0;
    /**
     * <code>emNvSysStartMod_By_Dll = 1;</code>
     *
     * <pre>
     * 动态库加载
     * </pre>
     */
    public static final int emNvSysStartMod_By_Dll_VALUE = 1;
    /**
     * <code>emNvSysStartMod_By_Process = 2;</code>
     *
     * <pre>
     * 进程加载
     * </pre>
     */
    public static final int emNvSysStartMod_By_Process_VALUE = 2;
    /**
     * <code>emNvSysStartMod_End = 3;</code>
     */
    public static final int emNvSysStartMod_End_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNvSysStartMod valueOf(int value) {
      switch (value) {
        case 0: return emNvSysStartMod_By_lib;
        case 1: return emNvSysStartMod_By_Dll;
        case 2: return emNvSysStartMod_By_Process;
        case 3: return emNvSysStartMod_End;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvSysStartMod>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvSysStartMod>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvSysStartMod>() {
            public EmNvSysStartMod findValueByNumber(int number) {
              return EmNvSysStartMod.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(0);
    }

    private static final EmNvSysStartMod[] VALUES = values();

    public static EmNvSysStartMod valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvSysStartMod(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvSysStartMod)
  }

  /**
   * Protobuf enum {@code nv.EmNvSysStartModFromUI}
   *
   * <pre>
   *子系统启动方式
   * </pre>
   */
  public enum EmNvSysStartModFromUI
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvSysStart_By_Dll = 0;</code>
     *
     * <pre>
     * 动态库加载
     * </pre>
     */
    emNvSysStart_By_Dll(0, 0),
    /**
     * <code>emNvSysStart_By_Process = 1;</code>
     *
     * <pre>
     * 进程加载
     * </pre>
     */
    emNvSysStart_By_Process(1, 1),
    /**
     * <code>emNvSysStart_End = 2;</code>
     */
    emNvSysStart_End(2, 2),
    ;

    /**
     * <code>emNvSysStart_By_Dll = 0;</code>
     *
     * <pre>
     * 动态库加载
     * </pre>
     */
    public static final int emNvSysStart_By_Dll_VALUE = 0;
    /**
     * <code>emNvSysStart_By_Process = 1;</code>
     *
     * <pre>
     * 进程加载
     * </pre>
     */
    public static final int emNvSysStart_By_Process_VALUE = 1;
    /**
     * <code>emNvSysStart_End = 2;</code>
     */
    public static final int emNvSysStart_End_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvSysStartModFromUI valueOf(int value) {
      switch (value) {
        case 0: return emNvSysStart_By_Dll;
        case 1: return emNvSysStart_By_Process;
        case 2: return emNvSysStart_End;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvSysStartModFromUI>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvSysStartModFromUI>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvSysStartModFromUI>() {
            public EmNvSysStartModFromUI findValueByNumber(int number) {
              return EmNvSysStartModFromUI.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(1);
    }

    private static final EmNvSysStartModFromUI[] VALUES = values();

    public static EmNvSysStartModFromUI valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvSysStartModFromUI(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvSysStartModFromUI)
  }

  /**
   * Protobuf enum {@code nv.EmNvSysSrvState}
   *
   * <pre>
   * 子系统运行状态
   * </pre>
   */
  public enum EmNvSysSrvState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvSysSrvState_Idle = 0;</code>
     *
     * <pre>
     * 空闲
     * </pre>
     */
    emNvSysSrvState_Idle(0, 0),
    /**
     * <code>emNvSysSrvState_Binded = 1;</code>
     *
     * <pre>
     * 是否绑定
     * </pre>
     */
    emNvSysSrvState_Binded(1, 1),
    /**
     * <code>emNvSysSrvState_Running = 2;</code>
     *
     * <pre>
     * 运行
     * </pre>
     */
    emNvSysSrvState_Running(2, 2),
    /**
     * <code>emNvSysSrvState_Stop = 3;</code>
     *
     * <pre>
     * 停止
     * </pre>
     */
    emNvSysSrvState_Stop(3, 3),
    /**
     * <code>emNvSysSrvState_Err = 4;</code>
     *
     * <pre>
     * 异常
     * </pre>
     */
    emNvSysSrvState_Err(4, 4),
    ;

    /**
     * <code>emNvSysSrvState_Idle = 0;</code>
     *
     * <pre>
     * 空闲
     * </pre>
     */
    public static final int emNvSysSrvState_Idle_VALUE = 0;
    /**
     * <code>emNvSysSrvState_Binded = 1;</code>
     *
     * <pre>
     * 是否绑定
     * </pre>
     */
    public static final int emNvSysSrvState_Binded_VALUE = 1;
    /**
     * <code>emNvSysSrvState_Running = 2;</code>
     *
     * <pre>
     * 运行
     * </pre>
     */
    public static final int emNvSysSrvState_Running_VALUE = 2;
    /**
     * <code>emNvSysSrvState_Stop = 3;</code>
     *
     * <pre>
     * 停止
     * </pre>
     */
    public static final int emNvSysSrvState_Stop_VALUE = 3;
    /**
     * <code>emNvSysSrvState_Err = 4;</code>
     *
     * <pre>
     * 异常
     * </pre>
     */
    public static final int emNvSysSrvState_Err_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmNvSysSrvState valueOf(int value) {
      switch (value) {
        case 0: return emNvSysSrvState_Idle;
        case 1: return emNvSysSrvState_Binded;
        case 2: return emNvSysSrvState_Running;
        case 3: return emNvSysSrvState_Stop;
        case 4: return emNvSysSrvState_Err;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvSysSrvState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvSysSrvState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvSysSrvState>() {
            public EmNvSysSrvState findValueByNumber(int number) {
              return EmNvSysSrvState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(2);
    }

    private static final EmNvSysSrvState[] VALUES = values();

    public static EmNvSysSrvState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvSysSrvState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvSysSrvState)
  }

  /**
   * Protobuf enum {@code nv.EmNvSysKeepLiveState}
   *
   * <pre>
   * 子系统存活状态
   * </pre>
   */
  public enum EmNvSysKeepLiveState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvSysKLState_Ready = 0;</code>
     *
     * <pre>
     * 准备就绪
     * </pre>
     */
    emNvSysKLState_Ready(0, 0),
    /**
     * <code>emNvSysKLState_Alive = 1;</code>
     *
     * <pre>
     * 存活
     * </pre>
     */
    emNvSysKLState_Alive(1, 1),
    /**
     * <code>emNvSysKLState_Err = 2;</code>
     *
     * <pre>
     * 异常
     * </pre>
     */
    emNvSysKLState_Err(2, 2),
    ;

    /**
     * <code>emNvSysKLState_Ready = 0;</code>
     *
     * <pre>
     * 准备就绪
     * </pre>
     */
    public static final int emNvSysKLState_Ready_VALUE = 0;
    /**
     * <code>emNvSysKLState_Alive = 1;</code>
     *
     * <pre>
     * 存活
     * </pre>
     */
    public static final int emNvSysKLState_Alive_VALUE = 1;
    /**
     * <code>emNvSysKLState_Err = 2;</code>
     *
     * <pre>
     * 异常
     * </pre>
     */
    public static final int emNvSysKLState_Err_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvSysKeepLiveState valueOf(int value) {
      switch (value) {
        case 0: return emNvSysKLState_Ready;
        case 1: return emNvSysKLState_Alive;
        case 2: return emNvSysKLState_Err;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvSysKeepLiveState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvSysKeepLiveState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvSysKeepLiveState>() {
            public EmNvSysKeepLiveState findValueByNumber(int number) {
              return EmNvSysKeepLiveState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(3);
    }

    private static final EmNvSysKeepLiveState[] VALUES = values();

    public static EmNvSysKeepLiveState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvSysKeepLiveState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvSysKeepLiveState)
  }

  /**
   * Protobuf enum {@code nv.EmNvIpAddrType}
   *
   * <pre>
   *IP地址类型
   * </pre>
   */
  public enum EmNvIpAddrType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvIpV4 = 0;</code>
     */
    emNvIpV4(0, 0),
    /**
     * <code>emNvIpV6 = 1;</code>
     */
    emNvIpV6(1, 1),
    ;

    /**
     * <code>emNvIpV4 = 0;</code>
     */
    public static final int emNvIpV4_VALUE = 0;
    /**
     * <code>emNvIpV6 = 1;</code>
     */
    public static final int emNvIpV6_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmNvIpAddrType valueOf(int value) {
      switch (value) {
        case 0: return emNvIpV4;
        case 1: return emNvIpV6;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvIpAddrType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvIpAddrType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvIpAddrType>() {
            public EmNvIpAddrType findValueByNumber(int number) {
              return EmNvIpAddrType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(4);
    }

    private static final EmNvIpAddrType[] VALUES = values();

    public static EmNvIpAddrType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvIpAddrType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvIpAddrType)
  }

  /**
   * Protobuf enum {@code nv.EmNvAliasType}
   */
  public enum EmNvAliasType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvBegin = 0;</code>
     */
    emNvBegin(0, 0),
    /**
     * <code>emNvE164 = 1;</code>
     *
     * <pre>
     *e164
     * </pre>
     */
    emNvE164(1, 1),
    /**
     * <code>emNvAlias = 2;</code>
     *
     * <pre>
     *别名
     * </pre>
     */
    emNvAlias(2, 2),
    /**
     * <code>emNvEmail = 3;</code>
     *
     * <pre>
     *email
     * </pre>
     */
    emNvEmail(3, 3),
    /**
     * <code>emNvEpID = 4;</code>
     *
     * <pre>
     *epid
     * </pre>
     */
    emNvEpID(4, 4),
    /**
     * <code>emNvGKID = 5;</code>
     *
     * <pre>
     *gkid	                  
     * </pre>
     */
    emNvGKID(5, 5),
    ;

    /**
     * <code>emNvBegin = 0;</code>
     */
    public static final int emNvBegin_VALUE = 0;
    /**
     * <code>emNvE164 = 1;</code>
     *
     * <pre>
     *e164
     * </pre>
     */
    public static final int emNvE164_VALUE = 1;
    /**
     * <code>emNvAlias = 2;</code>
     *
     * <pre>
     *别名
     * </pre>
     */
    public static final int emNvAlias_VALUE = 2;
    /**
     * <code>emNvEmail = 3;</code>
     *
     * <pre>
     *email
     * </pre>
     */
    public static final int emNvEmail_VALUE = 3;
    /**
     * <code>emNvEpID = 4;</code>
     *
     * <pre>
     *epid
     * </pre>
     */
    public static final int emNvEpID_VALUE = 4;
    /**
     * <code>emNvGKID = 5;</code>
     *
     * <pre>
     *gkid	                  
     * </pre>
     */
    public static final int emNvGKID_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmNvAliasType valueOf(int value) {
      switch (value) {
        case 0: return emNvBegin;
        case 1: return emNvE164;
        case 2: return emNvAlias;
        case 3: return emNvEmail;
        case 4: return emNvEpID;
        case 5: return emNvGKID;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvAliasType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvAliasType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvAliasType>() {
            public EmNvAliasType findValueByNumber(int number) {
              return EmNvAliasType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(5);
    }

    private static final EmNvAliasType[] VALUES = values();

    public static EmNvAliasType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvAliasType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvAliasType)
  }

  /**
   * Protobuf enum {@code nv.EmNvAddrType}
   *
   * <pre>
   *&#47;//终端地址类型
   * </pre>
   */
  public enum EmNvAddrType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvAddrIP = 0;</code>
     */
    emNvAddrIP(0, 0),
    /**
     * <code>emNvAddrE164 = 1;</code>
     */
    emNvAddrE164(1, 1),
    /**
     * <code>emNvAddrAlias = 2;</code>
     */
    emNvAddrAlias(2, 2),
    /**
     * <code>emNvDialNum = 3;</code>
     *
     * <pre>
     *&#47;/电话号码
     * </pre>
     */
    emNvDialNum(3, 3),
    /**
     * <code>emNvSipAddr = 4;</code>
     */
    emNvSipAddr(4, 4),
    /**
     * <code>emNvAddrMoid = 5;</code>
     */
    emNvAddrMoid(5, 5),
    ;

    /**
     * <code>emNvAddrIP = 0;</code>
     */
    public static final int emNvAddrIP_VALUE = 0;
    /**
     * <code>emNvAddrE164 = 1;</code>
     */
    public static final int emNvAddrE164_VALUE = 1;
    /**
     * <code>emNvAddrAlias = 2;</code>
     */
    public static final int emNvAddrAlias_VALUE = 2;
    /**
     * <code>emNvDialNum = 3;</code>
     *
     * <pre>
     *&#47;/电话号码
     * </pre>
     */
    public static final int emNvDialNum_VALUE = 3;
    /**
     * <code>emNvSipAddr = 4;</code>
     */
    public static final int emNvSipAddr_VALUE = 4;
    /**
     * <code>emNvAddrMoid = 5;</code>
     */
    public static final int emNvAddrMoid_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmNvAddrType valueOf(int value) {
      switch (value) {
        case 0: return emNvAddrIP;
        case 1: return emNvAddrE164;
        case 2: return emNvAddrAlias;
        case 3: return emNvDialNum;
        case 4: return emNvSipAddr;
        case 5: return emNvAddrMoid;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvAddrType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvAddrType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvAddrType>() {
            public EmNvAddrType findValueByNumber(int number) {
              return EmNvAddrType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(6);
    }

    private static final EmNvAddrType[] VALUES = values();

    public static EmNvAddrType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvAddrType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvAddrType)
  }

  /**
   * Protobuf enum {@code nv.EmNvChanType}
   *
   * <pre>
   *通道类型
   * </pre>
   */
  public enum EmNvChanType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvChanRecvAudio = 0;</code>
     */
    emNvChanRecvAudio(0, 0),
    /**
     * <code>emNvChanRecvVideo = 1;</code>
     */
    emNvChanRecvVideo(1, 1),
    /**
     * <code>emNvChanTypeEnd = 12;</code>
     */
    emNvChanTypeEnd(2, 12),
    ;

    /**
     * <code>emNvChanRecvAudio = 0;</code>
     */
    public static final int emNvChanRecvAudio_VALUE = 0;
    /**
     * <code>emNvChanRecvVideo = 1;</code>
     */
    public static final int emNvChanRecvVideo_VALUE = 1;
    /**
     * <code>emNvChanTypeEnd = 12;</code>
     */
    public static final int emNvChanTypeEnd_VALUE = 12;


    public final int getNumber() { return value; }

    public static EmNvChanType valueOf(int value) {
      switch (value) {
        case 0: return emNvChanRecvAudio;
        case 1: return emNvChanRecvVideo;
        case 12: return emNvChanTypeEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvChanType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvChanType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvChanType>() {
            public EmNvChanType findValueByNumber(int number) {
              return EmNvChanType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(7);
    }

    private static final EmNvChanType[] VALUES = values();

    public static EmNvChanType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvChanType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvChanType)
  }

  /**
   * Protobuf enum {@code nv.EmNvModel}
   *
   * <pre>
   *终端型号
   * </pre>
   */
  public enum EmNvModel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNv_ModelBegin = 0;</code>
     *
     * <pre>
     *无效值，
     * </pre>
     */
    emNv_ModelBegin(0, 0),
    /**
     * <code>emNv_Mode_Imix = 1;</code>
     */
    emNv_Mode_Imix(1, 1),
    /**
     * <code>emNv_Mode_QuickShare = 2;</code>
     */
    emNv_Mode_QuickShare(2, 2),
    /**
     * <code>emNv_Mode_Imix_S1 = 3;</code>
     */
    emNv_Mode_Imix_S1(3, 3),
    /**
     * <code>emNv_Mode_Imix_D1 = 4;</code>
     */
    emNv_Mode_Imix_D1(4, 4),
    /**
     * <code>emNv_Mode_Imix_S0 = 5;</code>
     */
    emNv_Mode_Imix_S0(5, 5),
    /**
     * <code>emNv_Mode_Imix_D0 = 6;</code>
     */
    emNv_Mode_Imix_D0(6, 6),
    ;

    /**
     * <code>emNv_ModelBegin = 0;</code>
     *
     * <pre>
     *无效值，
     * </pre>
     */
    public static final int emNv_ModelBegin_VALUE = 0;
    /**
     * <code>emNv_Mode_Imix = 1;</code>
     */
    public static final int emNv_Mode_Imix_VALUE = 1;
    /**
     * <code>emNv_Mode_QuickShare = 2;</code>
     */
    public static final int emNv_Mode_QuickShare_VALUE = 2;
    /**
     * <code>emNv_Mode_Imix_S1 = 3;</code>
     */
    public static final int emNv_Mode_Imix_S1_VALUE = 3;
    /**
     * <code>emNv_Mode_Imix_D1 = 4;</code>
     */
    public static final int emNv_Mode_Imix_D1_VALUE = 4;
    /**
     * <code>emNv_Mode_Imix_S0 = 5;</code>
     */
    public static final int emNv_Mode_Imix_S0_VALUE = 5;
    /**
     * <code>emNv_Mode_Imix_D0 = 6;</code>
     */
    public static final int emNv_Mode_Imix_D0_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmNvModel valueOf(int value) {
      switch (value) {
        case 0: return emNv_ModelBegin;
        case 1: return emNv_Mode_Imix;
        case 2: return emNv_Mode_QuickShare;
        case 3: return emNv_Mode_Imix_S1;
        case 4: return emNv_Mode_Imix_D1;
        case 5: return emNv_Mode_Imix_S0;
        case 6: return emNv_Mode_Imix_D0;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvModel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvModel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvModel>() {
            public EmNvModel findValueByNumber(int number) {
              return EmNvModel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(8);
    }

    private static final EmNvModel[] VALUES = values();

    public static EmNvModel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvModel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvModel)
  }

  /**
   * Protobuf enum {@code nv.EmNvCodecComponent}
   *
   * <pre>
   *codec组件
   * </pre>
   */
  public enum EmNvCodecComponent
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvVidMainEncoder = 0;</code>
     */
    emNvVidMainEncoder(0, 0),
    /**
     * <code>emNvVidMainDecoder = 1;</code>
     */
    emNvVidMainDecoder(1, 1),
    /**
     * <code>emNvAudMainEncoder = 2;</code>
     */
    emNvAudMainEncoder(2, 2),
    /**
     * <code>emNvAudMainDecoder = 3;</code>
     */
    emNvAudMainDecoder(3, 3),
    /**
     * <code>emNvCodecInvalid = 20;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    emNvCodecInvalid(4, 20),
    ;

    /**
     * <code>emNvVidMainEncoder = 0;</code>
     */
    public static final int emNvVidMainEncoder_VALUE = 0;
    /**
     * <code>emNvVidMainDecoder = 1;</code>
     */
    public static final int emNvVidMainDecoder_VALUE = 1;
    /**
     * <code>emNvAudMainEncoder = 2;</code>
     */
    public static final int emNvAudMainEncoder_VALUE = 2;
    /**
     * <code>emNvAudMainDecoder = 3;</code>
     */
    public static final int emNvAudMainDecoder_VALUE = 3;
    /**
     * <code>emNvCodecInvalid = 20;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    public static final int emNvCodecInvalid_VALUE = 20;


    public final int getNumber() { return value; }

    public static EmNvCodecComponent valueOf(int value) {
      switch (value) {
        case 0: return emNvVidMainEncoder;
        case 1: return emNvVidMainDecoder;
        case 2: return emNvAudMainEncoder;
        case 3: return emNvAudMainDecoder;
        case 20: return emNvCodecInvalid;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvCodecComponent>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvCodecComponent>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvCodecComponent>() {
            public EmNvCodecComponent findValueByNumber(int number) {
              return EmNvCodecComponent.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(9);
    }

    private static final EmNvCodecComponent[] VALUES = values();

    public static EmNvCodecComponent valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvCodecComponent(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvCodecComponent)
  }

  /**
   * Protobuf enum {@code nv.EmNvCodecComponentIndex}
   *
   * <pre>
   *codec组件码流索引
   * </pre>
   */
  public enum EmNvCodecComponentIndex
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNv1st = 0;</code>
     */
    emNv1st(0, 0),
    /**
     * <code>emNv2nd = 1;</code>
     */
    emNv2nd(1, 1),
    /**
     * <code>emNv3rd = 2;</code>
     */
    emNv3rd(2, 2),
    /**
     * <code>emNv4th = 3;</code>
     */
    emNv4th(3, 3),
    /**
     * <code>emNv5th = 4;</code>
     */
    emNv5th(4, 4),
    /**
     * <code>emNv6th = 5;</code>
     */
    emNv6th(5, 5),
    /**
     * <code>emNv7th = 6;</code>
     */
    emNv7th(6, 6),
    /**
     * <code>emNv8th = 7;</code>
     */
    emNv8th(7, 7),
    /**
     * <code>emNv9th = 8;</code>
     */
    emNv9th(8, 8),
    ;

    /**
     * <code>emNv1st = 0;</code>
     */
    public static final int emNv1st_VALUE = 0;
    /**
     * <code>emNv2nd = 1;</code>
     */
    public static final int emNv2nd_VALUE = 1;
    /**
     * <code>emNv3rd = 2;</code>
     */
    public static final int emNv3rd_VALUE = 2;
    /**
     * <code>emNv4th = 3;</code>
     */
    public static final int emNv4th_VALUE = 3;
    /**
     * <code>emNv5th = 4;</code>
     */
    public static final int emNv5th_VALUE = 4;
    /**
     * <code>emNv6th = 5;</code>
     */
    public static final int emNv6th_VALUE = 5;
    /**
     * <code>emNv7th = 6;</code>
     */
    public static final int emNv7th_VALUE = 6;
    /**
     * <code>emNv8th = 7;</code>
     */
    public static final int emNv8th_VALUE = 7;
    /**
     * <code>emNv9th = 8;</code>
     */
    public static final int emNv9th_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmNvCodecComponentIndex valueOf(int value) {
      switch (value) {
        case 0: return emNv1st;
        case 1: return emNv2nd;
        case 2: return emNv3rd;
        case 3: return emNv4th;
        case 4: return emNv5th;
        case 5: return emNv6th;
        case 6: return emNv7th;
        case 7: return emNv8th;
        case 8: return emNv9th;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvCodecComponentIndex>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvCodecComponentIndex>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvCodecComponentIndex>() {
            public EmNvCodecComponentIndex findValueByNumber(int number) {
              return EmNvCodecComponentIndex.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(10);
    }

    private static final EmNvCodecComponentIndex[] VALUES = values();

    public static EmNvCodecComponentIndex valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvCodecComponentIndex(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvCodecComponentIndex)
  }

  /**
   * Protobuf enum {@code nv.EmNvVidFormat}
   *
   * <pre>
   *视频格式
   * </pre>
   */
  public enum EmNvVidFormat
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvVH261 = 0;</code>
     */
    emNvVH261(0, 0),
    /**
     * <code>emNvVH262 = 1;</code>
     */
    emNvVH262(1, 1),
    /**
     * <code>emNvVH263 = 2;</code>
     */
    emNvVH263(2, 2),
    /**
     * <code>emNvVH263plus = 3;</code>
     */
    emNvVH263plus(3, 3),
    /**
     * <code>emNvVH264 = 4;</code>
     */
    emNvVH264(4, 4),
    /**
     * <code>emNvVMPEG4 = 5;</code>
     */
    emNvVMPEG4(5, 5),
    /**
     * <code>emNvVH265 = 6;</code>
     *
     * <pre>
     *暂未实现
     * </pre>
     */
    emNvVH265(6, 6),
    /**
     * <code>emNvVEnd = 7;</code>
     */
    emNvVEnd(7, 7),
    ;

    /**
     * <code>emNvVH261 = 0;</code>
     */
    public static final int emNvVH261_VALUE = 0;
    /**
     * <code>emNvVH262 = 1;</code>
     */
    public static final int emNvVH262_VALUE = 1;
    /**
     * <code>emNvVH263 = 2;</code>
     */
    public static final int emNvVH263_VALUE = 2;
    /**
     * <code>emNvVH263plus = 3;</code>
     */
    public static final int emNvVH263plus_VALUE = 3;
    /**
     * <code>emNvVH264 = 4;</code>
     */
    public static final int emNvVH264_VALUE = 4;
    /**
     * <code>emNvVMPEG4 = 5;</code>
     */
    public static final int emNvVMPEG4_VALUE = 5;
    /**
     * <code>emNvVH265 = 6;</code>
     *
     * <pre>
     *暂未实现
     * </pre>
     */
    public static final int emNvVH265_VALUE = 6;
    /**
     * <code>emNvVEnd = 7;</code>
     */
    public static final int emNvVEnd_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmNvVidFormat valueOf(int value) {
      switch (value) {
        case 0: return emNvVH261;
        case 1: return emNvVH262;
        case 2: return emNvVH263;
        case 3: return emNvVH263plus;
        case 4: return emNvVH264;
        case 5: return emNvVMPEG4;
        case 6: return emNvVH265;
        case 7: return emNvVEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvVidFormat>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvVidFormat>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvVidFormat>() {
            public EmNvVidFormat findValueByNumber(int number) {
              return EmNvVidFormat.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(11);
    }

    private static final EmNvVidFormat[] VALUES = values();

    public static EmNvVidFormat valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvVidFormat(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvVidFormat)
  }

  /**
   * Protobuf enum {@code nv.EmNvAudFormat}
   *
   * <pre>
   *音频格式
   * </pre>
   */
  public enum EmNvAudFormat
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvAG711a = 0;</code>
     */
    emNvAG711a(0, 0),
    /**
     * <code>emNvAG711u = 1;</code>
     */
    emNvAG711u(1, 1),
    /**
     * <code>emNvAG722 = 2;</code>
     */
    emNvAG722(2, 2),
    /**
     * <code>emNvAG7231 = 3;</code>
     */
    emNvAG7231(3, 3),
    /**
     * <code>emNvAG728 = 4;</code>
     */
    emNvAG728(4, 4),
    /**
     * <code>emNvAG729 = 5;</code>
     */
    emNvAG729(5, 5),
    /**
     * <code>emNvAMP3 = 6;</code>
     */
    emNvAMP3(6, 6),
    /**
     * <code>emNvAG721 = 7;</code>
     */
    emNvAG721(7, 7),
    /**
     * <code>emNvAG7221 = 8;</code>
     */
    emNvAG7221(8, 8),
    /**
     * <code>emNvAG719 = 9;</code>
     */
    emNvAG719(9, 9),
    /**
     * <code>emNvAMpegAACLC = 10;</code>
     */
    emNvAMpegAACLC(10, 10),
    /**
     * <code>emNvAMpegAACLD = 11;</code>
     */
    emNvAMpegAACLD(11, 11),
    /**
     * <code>emNvAOpus = 12;</code>
     */
    emNvAOpus(12, 12),
    /**
     * <code>emNvAudEnd = 13;</code>
     */
    emNvAudEnd(13, 13),
    ;

    /**
     * <code>emNvAG711a = 0;</code>
     */
    public static final int emNvAG711a_VALUE = 0;
    /**
     * <code>emNvAG711u = 1;</code>
     */
    public static final int emNvAG711u_VALUE = 1;
    /**
     * <code>emNvAG722 = 2;</code>
     */
    public static final int emNvAG722_VALUE = 2;
    /**
     * <code>emNvAG7231 = 3;</code>
     */
    public static final int emNvAG7231_VALUE = 3;
    /**
     * <code>emNvAG728 = 4;</code>
     */
    public static final int emNvAG728_VALUE = 4;
    /**
     * <code>emNvAG729 = 5;</code>
     */
    public static final int emNvAG729_VALUE = 5;
    /**
     * <code>emNvAMP3 = 6;</code>
     */
    public static final int emNvAMP3_VALUE = 6;
    /**
     * <code>emNvAG721 = 7;</code>
     */
    public static final int emNvAG721_VALUE = 7;
    /**
     * <code>emNvAG7221 = 8;</code>
     */
    public static final int emNvAG7221_VALUE = 8;
    /**
     * <code>emNvAG719 = 9;</code>
     */
    public static final int emNvAG719_VALUE = 9;
    /**
     * <code>emNvAMpegAACLC = 10;</code>
     */
    public static final int emNvAMpegAACLC_VALUE = 10;
    /**
     * <code>emNvAMpegAACLD = 11;</code>
     */
    public static final int emNvAMpegAACLD_VALUE = 11;
    /**
     * <code>emNvAOpus = 12;</code>
     */
    public static final int emNvAOpus_VALUE = 12;
    /**
     * <code>emNvAudEnd = 13;</code>
     */
    public static final int emNvAudEnd_VALUE = 13;


    public final int getNumber() { return value; }

    public static EmNvAudFormat valueOf(int value) {
      switch (value) {
        case 0: return emNvAG711a;
        case 1: return emNvAG711u;
        case 2: return emNvAG722;
        case 3: return emNvAG7231;
        case 4: return emNvAG728;
        case 5: return emNvAG729;
        case 6: return emNvAMP3;
        case 7: return emNvAG721;
        case 8: return emNvAG7221;
        case 9: return emNvAG719;
        case 10: return emNvAMpegAACLC;
        case 11: return emNvAMpegAACLD;
        case 12: return emNvAOpus;
        case 13: return emNvAudEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvAudFormat>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvAudFormat>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvAudFormat>() {
            public EmNvAudFormat findValueByNumber(int number) {
              return EmNvAudFormat.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(12);
    }

    private static final EmNvAudFormat[] VALUES = values();

    public static EmNvAudFormat valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvAudFormat(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvAudFormat)
  }

  /**
   * Protobuf enum {@code nv.EmNvResolution}
   *
   * <pre>
   *0-39分辨率和mcu定义的分辨率对应起来，后面的对应不起来
   * </pre>
   */
  public enum EmNvResolution
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvResAuto = 0;</code>
     *
     * <pre>
     *自适应
     * </pre>
     */
    emNvResAuto(0, 0),
    /**
     * <code>emNvSQCIF = 1;</code>
     *
     * <pre>
     *SQCIF 128*96
     * </pre>
     */
    emNvSQCIF(1, 1),
    /**
     * <code>emNvQCIF = 2;</code>
     *
     * <pre>
     *QCIF 176x144
     * </pre>
     */
    emNvQCIF(2, 2),
    /**
     * <code>emNvCIF = 3;</code>
     *
     * <pre>
     *CIF 352x288
     * </pre>
     */
    emNvCIF(3, 3),
    /**
     * <code>emNv2CIF = 4;</code>
     *
     * <pre>
     *2CIF 352x576
     * </pre>
     */
    emNv2CIF(4, 4),
    /**
     * <code>emNv4CIF = 5;</code>
     *
     * <pre>
     *4CIF 704x576
     * </pre>
     */
    emNv4CIF(5, 5),
    /**
     * <code>emNv16CIF = 6;</code>
     *
     * <pre>
     *16CIF 1408x1152
     * </pre>
     */
    emNv16CIF(6, 6),
    /**
     * <code>emNvVGA352x240 = 7;</code>
     *
     * <pre>
     *352x240  对应平台SIF
     * </pre>
     */
    emNvVGA352x240(7, 7),
    /**
     * <code>emNv2SIF = 8;</code>
     *
     * <pre>
     *对应平台2SIF，具体不知道多少*多少                  
     * </pre>
     */
    emNv2SIF(8, 8),
    /**
     * <code>emNvVGA704x480 = 9;</code>
     *
     * <pre>
     *704x480  对应平台4SIF
     * </pre>
     */
    emNvVGA704x480(9, 9),
    /**
     * <code>emNvVGA640x480 = 10;</code>
     *
     * <pre>
     *VGA 640x480                   
     * </pre>
     */
    emNvVGA640x480(10, 10),
    /**
     * <code>emNvVGA800x600 = 11;</code>
     *
     * <pre>
     *SVGA 800x600                     
     * </pre>
     */
    emNvVGA800x600(11, 11),
    /**
     * <code>emNvVGA1024x768 = 12;</code>
     *
     * <pre>
     *XGA 1024x768                     
     * </pre>
     */
    emNvVGA1024x768(12, 12),
    /**
     * <code>emNvVWCIF = 13;</code>
     *
     * <pre>
     *WCIF 512*288
     * </pre>
     */
    emNvVWCIF(13, 13),
    /**
     * <code>emNvVSQCIF112x96 = 14;</code>
     *
     * <pre>
     *仅用于终端分辨率改变	
     * </pre>
     */
    emNvVSQCIF112x96(14, 14),
    /**
     * <code>emNvVSQCIF96x80 = 15;</code>
     *
     * <pre>
     *SQCIF(96*80) 
     * </pre>
     */
    emNvVSQCIF96x80(15, 15),
    /**
     * <code>emNvVW4CIF = 16;</code>
     *
     * <pre>
     *&#47;///高清分辨率
     * </pre>
     */
    emNvVW4CIF(16, 16),
    /**
     * <code>emNvHD720p1280x720 = 17;</code>
     *
     * <pre>
     *720p 1280x720
     * </pre>
     */
    emNvHD720p1280x720(17, 17),
    /**
     * <code>emNvVGA1280x1024 = 18;</code>
     *
     * <pre>
     *SXGA 1280x1024
     * </pre>
     */
    emNvVGA1280x1024(18, 18),
    /**
     * <code>emNvVGA1600x1200 = 19;</code>
     *
     * <pre>
     *UXGA 1600x1200
     * </pre>
     */
    emNvVGA1600x1200(19, 19),
    /**
     * <code>emNvHD1080i1920x1080 = 20;</code>
     *
     * <pre>
     *1080i 1920x1080
     * </pre>
     */
    emNvHD1080i1920x1080(20, 20),
    /**
     * <code>emNvHD1080p1920x1080 = 21;</code>
     *
     * <pre>
     *1080p 1920x1080          
     * </pre>
     */
    emNvHD1080p1920x1080(21, 21),
    /**
     * <code>emNvVGA1280x800 = 22;</code>
     *
     * <pre>
     *WXGA 1280x800
     * </pre>
     */
    emNvVGA1280x800(22, 22),
    /**
     * <code>emNvVGA1440x900 = 23;</code>
     *
     * <pre>
     *WSXGA 1440x900                     
     * </pre>
     */
    emNvVGA1440x900(23, 23),
    /**
     * <code>emNvVGA1280x960 = 24;</code>
     *
     * <pre>
     *XVGA  1280x960                     
     * </pre>
     */
    emNvVGA1280x960(24, 24),
    /**
     * <code>emNvV1440x816 = 25;</code>
     *
     * <pre>
     *非标分辨率（1080p底图）－用于终端分辨率改变                     
     * </pre>
     */
    emNvV1440x816(25, 25),
    /**
     * <code>emNv1280x720 = 26;</code>
     *
     * <pre>
     *1280×720(2/3)
     * </pre>
     */
    emNv1280x720(26, 26),
    /**
     * <code>emNvV960x544 = 27;</code>
     *
     * <pre>
     *960×544(1/2)
     * </pre>
     */
    emNvV960x544(27, 27),
    /**
     * <code>emNvV640x368 = 28;</code>
     *
     * <pre>
     *640×368(1/3)
     * </pre>
     */
    emNvV640x368(28, 28),
    /**
     * <code>emNvV480x272 = 29;</code>
     *
     * <pre>
     *480×272(1/4)
     * </pre>
     */
    emNvV480x272(29, 29),
    /**
     * <code>emNv384x272 = 30;</code>
     *
     * <pre>
     *384×272(1/5)
     * </pre>
     */
    emNv384x272(30, 30),
    /**
     * <code>emNv640x544 = 31;</code>
     *
     * <pre>
     *640x544                       
     * </pre>
     */
    emNv640x544(31, 31),
    /**
     * <code>emNv320x272 = 32;</code>
     *
     * <pre>
     *320x272
     * </pre>
     */
    emNv320x272(32, 32),
    /**
     * <code>emNv_720_960x544 = 33;</code>
     *
     * <pre>
     *非标分辨率（720p底图） －用于终端分辨率改变
     * </pre>
     */
    emNv_720_960x544(33, 33),
    /**
     * <code>emNv_720_864x480 = 34;</code>
     *
     * <pre>
     *864×480(2/3)
     * </pre>
     */
    emNv_720_864x480(34, 34),
    /**
     * <code>emNv_720_640x368 = 35;</code>
     *
     * <pre>
     *640×368(1/2)
     * </pre>
     */
    emNv_720_640x368(35, 35),
    /**
     * <code>emNv_720_432x240 = 36;</code>
     *
     * <pre>
     *432×240(1/3)
     * </pre>
     */
    emNv_720_432x240(36, 36),
    /**
     * <code>emNv_720_320x192 = 37;</code>
     *
     * <pre>
     *320×192(1/4)
     * </pre>
     */
    emNv_720_320x192(37, 37),
    /**
     * <code>emNvVGA480x352 = 38;</code>
     *
     * <pre>
     *非标分辨率
     * </pre>
     */
    emNvVGA480x352(38, 38),
    /**
     * <code>emNvHD480i720x480 = 39;</code>
     *
     * <pre>
     *480i720x480
     * </pre>
     */
    emNvHD480i720x480(39, 39),
    /**
     * <code>emNvHD480p720x480 = 40;</code>
     *
     * <pre>
     *480p720x480
     * </pre>
     */
    emNvHD480p720x480(40, 40),
    /**
     * <code>emNvHD576i720x576 = 41;</code>
     *
     * <pre>
     *576i720x576
     * </pre>
     */
    emNvHD576i720x576(41, 41),
    /**
     * <code>emNvHD576p720x576 = 42;</code>
     *
     * <pre>
     *576p720x576              
     * </pre>
     */
    emNvHD576p720x576(42, 42),
    /**
     * <code>emNvVGA1280x768 = 43;</code>
     *
     * <pre>
     *WXGA1280x768
     * </pre>
     */
    emNvVGA1280x768(43, 43),
    /**
     * <code>emNvVGA1366x768 = 44;</code>
     *
     * <pre>
     *WXGA1366x768
     * </pre>
     */
    emNvVGA1366x768(44, 44),
    /**
     * <code>emNvVGA1280x854 = 45;</code>
     *
     * <pre>
     *WSXGA1280x854
     * </pre>
     */
    emNvVGA1280x854(45, 45),
    /**
     * <code>emNvVGA1680x1050 = 46;</code>
     *
     * <pre>
     *WSXGA+1680x1050
     * </pre>
     */
    emNvVGA1680x1050(46, 46),
    /**
     * <code>emNvVGA1920x1200 = 47;</code>
     *
     * <pre>
     *WUXGA1920x1200
     * </pre>
     */
    emNvVGA1920x1200(47, 47),
    /**
     * <code>emNvV3840x2160 = 48;</code>
     *
     * <pre>
     *4Kx2K3840x2160
     * </pre>
     */
    emNvV3840x2160(48, 48),
    /**
     * <code>emNv1280x600 = 49;</code>
     *
     * <pre>
     *1280*600
     * </pre>
     */
    emNv1280x600(49, 49),
    /**
     * <code>emNv1360x768 = 50;</code>
     *
     * <pre>
     *1360*768
     * </pre>
     */
    emNv1360x768(50, 50),
    /**
     * <code>emNvVResEnd = 100;</code>
     */
    emNvVResEnd(51, 100),
    ;

    /**
     * <code>emNvResAuto = 0;</code>
     *
     * <pre>
     *自适应
     * </pre>
     */
    public static final int emNvResAuto_VALUE = 0;
    /**
     * <code>emNvSQCIF = 1;</code>
     *
     * <pre>
     *SQCIF 128*96
     * </pre>
     */
    public static final int emNvSQCIF_VALUE = 1;
    /**
     * <code>emNvQCIF = 2;</code>
     *
     * <pre>
     *QCIF 176x144
     * </pre>
     */
    public static final int emNvQCIF_VALUE = 2;
    /**
     * <code>emNvCIF = 3;</code>
     *
     * <pre>
     *CIF 352x288
     * </pre>
     */
    public static final int emNvCIF_VALUE = 3;
    /**
     * <code>emNv2CIF = 4;</code>
     *
     * <pre>
     *2CIF 352x576
     * </pre>
     */
    public static final int emNv2CIF_VALUE = 4;
    /**
     * <code>emNv4CIF = 5;</code>
     *
     * <pre>
     *4CIF 704x576
     * </pre>
     */
    public static final int emNv4CIF_VALUE = 5;
    /**
     * <code>emNv16CIF = 6;</code>
     *
     * <pre>
     *16CIF 1408x1152
     * </pre>
     */
    public static final int emNv16CIF_VALUE = 6;
    /**
     * <code>emNvVGA352x240 = 7;</code>
     *
     * <pre>
     *352x240  对应平台SIF
     * </pre>
     */
    public static final int emNvVGA352x240_VALUE = 7;
    /**
     * <code>emNv2SIF = 8;</code>
     *
     * <pre>
     *对应平台2SIF，具体不知道多少*多少                  
     * </pre>
     */
    public static final int emNv2SIF_VALUE = 8;
    /**
     * <code>emNvVGA704x480 = 9;</code>
     *
     * <pre>
     *704x480  对应平台4SIF
     * </pre>
     */
    public static final int emNvVGA704x480_VALUE = 9;
    /**
     * <code>emNvVGA640x480 = 10;</code>
     *
     * <pre>
     *VGA 640x480                   
     * </pre>
     */
    public static final int emNvVGA640x480_VALUE = 10;
    /**
     * <code>emNvVGA800x600 = 11;</code>
     *
     * <pre>
     *SVGA 800x600                     
     * </pre>
     */
    public static final int emNvVGA800x600_VALUE = 11;
    /**
     * <code>emNvVGA1024x768 = 12;</code>
     *
     * <pre>
     *XGA 1024x768                     
     * </pre>
     */
    public static final int emNvVGA1024x768_VALUE = 12;
    /**
     * <code>emNvVWCIF = 13;</code>
     *
     * <pre>
     *WCIF 512*288
     * </pre>
     */
    public static final int emNvVWCIF_VALUE = 13;
    /**
     * <code>emNvVSQCIF112x96 = 14;</code>
     *
     * <pre>
     *仅用于终端分辨率改变	
     * </pre>
     */
    public static final int emNvVSQCIF112x96_VALUE = 14;
    /**
     * <code>emNvVSQCIF96x80 = 15;</code>
     *
     * <pre>
     *SQCIF(96*80) 
     * </pre>
     */
    public static final int emNvVSQCIF96x80_VALUE = 15;
    /**
     * <code>emNvVW4CIF = 16;</code>
     *
     * <pre>
     *&#47;///高清分辨率
     * </pre>
     */
    public static final int emNvVW4CIF_VALUE = 16;
    /**
     * <code>emNvHD720p1280x720 = 17;</code>
     *
     * <pre>
     *720p 1280x720
     * </pre>
     */
    public static final int emNvHD720p1280x720_VALUE = 17;
    /**
     * <code>emNvVGA1280x1024 = 18;</code>
     *
     * <pre>
     *SXGA 1280x1024
     * </pre>
     */
    public static final int emNvVGA1280x1024_VALUE = 18;
    /**
     * <code>emNvVGA1600x1200 = 19;</code>
     *
     * <pre>
     *UXGA 1600x1200
     * </pre>
     */
    public static final int emNvVGA1600x1200_VALUE = 19;
    /**
     * <code>emNvHD1080i1920x1080 = 20;</code>
     *
     * <pre>
     *1080i 1920x1080
     * </pre>
     */
    public static final int emNvHD1080i1920x1080_VALUE = 20;
    /**
     * <code>emNvHD1080p1920x1080 = 21;</code>
     *
     * <pre>
     *1080p 1920x1080          
     * </pre>
     */
    public static final int emNvHD1080p1920x1080_VALUE = 21;
    /**
     * <code>emNvVGA1280x800 = 22;</code>
     *
     * <pre>
     *WXGA 1280x800
     * </pre>
     */
    public static final int emNvVGA1280x800_VALUE = 22;
    /**
     * <code>emNvVGA1440x900 = 23;</code>
     *
     * <pre>
     *WSXGA 1440x900                     
     * </pre>
     */
    public static final int emNvVGA1440x900_VALUE = 23;
    /**
     * <code>emNvVGA1280x960 = 24;</code>
     *
     * <pre>
     *XVGA  1280x960                     
     * </pre>
     */
    public static final int emNvVGA1280x960_VALUE = 24;
    /**
     * <code>emNvV1440x816 = 25;</code>
     *
     * <pre>
     *非标分辨率（1080p底图）－用于终端分辨率改变                     
     * </pre>
     */
    public static final int emNvV1440x816_VALUE = 25;
    /**
     * <code>emNv1280x720 = 26;</code>
     *
     * <pre>
     *1280×720(2/3)
     * </pre>
     */
    public static final int emNv1280x720_VALUE = 26;
    /**
     * <code>emNvV960x544 = 27;</code>
     *
     * <pre>
     *960×544(1/2)
     * </pre>
     */
    public static final int emNvV960x544_VALUE = 27;
    /**
     * <code>emNvV640x368 = 28;</code>
     *
     * <pre>
     *640×368(1/3)
     * </pre>
     */
    public static final int emNvV640x368_VALUE = 28;
    /**
     * <code>emNvV480x272 = 29;</code>
     *
     * <pre>
     *480×272(1/4)
     * </pre>
     */
    public static final int emNvV480x272_VALUE = 29;
    /**
     * <code>emNv384x272 = 30;</code>
     *
     * <pre>
     *384×272(1/5)
     * </pre>
     */
    public static final int emNv384x272_VALUE = 30;
    /**
     * <code>emNv640x544 = 31;</code>
     *
     * <pre>
     *640x544                       
     * </pre>
     */
    public static final int emNv640x544_VALUE = 31;
    /**
     * <code>emNv320x272 = 32;</code>
     *
     * <pre>
     *320x272
     * </pre>
     */
    public static final int emNv320x272_VALUE = 32;
    /**
     * <code>emNv_720_960x544 = 33;</code>
     *
     * <pre>
     *非标分辨率（720p底图） －用于终端分辨率改变
     * </pre>
     */
    public static final int emNv_720_960x544_VALUE = 33;
    /**
     * <code>emNv_720_864x480 = 34;</code>
     *
     * <pre>
     *864×480(2/3)
     * </pre>
     */
    public static final int emNv_720_864x480_VALUE = 34;
    /**
     * <code>emNv_720_640x368 = 35;</code>
     *
     * <pre>
     *640×368(1/2)
     * </pre>
     */
    public static final int emNv_720_640x368_VALUE = 35;
    /**
     * <code>emNv_720_432x240 = 36;</code>
     *
     * <pre>
     *432×240(1/3)
     * </pre>
     */
    public static final int emNv_720_432x240_VALUE = 36;
    /**
     * <code>emNv_720_320x192 = 37;</code>
     *
     * <pre>
     *320×192(1/4)
     * </pre>
     */
    public static final int emNv_720_320x192_VALUE = 37;
    /**
     * <code>emNvVGA480x352 = 38;</code>
     *
     * <pre>
     *非标分辨率
     * </pre>
     */
    public static final int emNvVGA480x352_VALUE = 38;
    /**
     * <code>emNvHD480i720x480 = 39;</code>
     *
     * <pre>
     *480i720x480
     * </pre>
     */
    public static final int emNvHD480i720x480_VALUE = 39;
    /**
     * <code>emNvHD480p720x480 = 40;</code>
     *
     * <pre>
     *480p720x480
     * </pre>
     */
    public static final int emNvHD480p720x480_VALUE = 40;
    /**
     * <code>emNvHD576i720x576 = 41;</code>
     *
     * <pre>
     *576i720x576
     * </pre>
     */
    public static final int emNvHD576i720x576_VALUE = 41;
    /**
     * <code>emNvHD576p720x576 = 42;</code>
     *
     * <pre>
     *576p720x576              
     * </pre>
     */
    public static final int emNvHD576p720x576_VALUE = 42;
    /**
     * <code>emNvVGA1280x768 = 43;</code>
     *
     * <pre>
     *WXGA1280x768
     * </pre>
     */
    public static final int emNvVGA1280x768_VALUE = 43;
    /**
     * <code>emNvVGA1366x768 = 44;</code>
     *
     * <pre>
     *WXGA1366x768
     * </pre>
     */
    public static final int emNvVGA1366x768_VALUE = 44;
    /**
     * <code>emNvVGA1280x854 = 45;</code>
     *
     * <pre>
     *WSXGA1280x854
     * </pre>
     */
    public static final int emNvVGA1280x854_VALUE = 45;
    /**
     * <code>emNvVGA1680x1050 = 46;</code>
     *
     * <pre>
     *WSXGA+1680x1050
     * </pre>
     */
    public static final int emNvVGA1680x1050_VALUE = 46;
    /**
     * <code>emNvVGA1920x1200 = 47;</code>
     *
     * <pre>
     *WUXGA1920x1200
     * </pre>
     */
    public static final int emNvVGA1920x1200_VALUE = 47;
    /**
     * <code>emNvV3840x2160 = 48;</code>
     *
     * <pre>
     *4Kx2K3840x2160
     * </pre>
     */
    public static final int emNvV3840x2160_VALUE = 48;
    /**
     * <code>emNv1280x600 = 49;</code>
     *
     * <pre>
     *1280*600
     * </pre>
     */
    public static final int emNv1280x600_VALUE = 49;
    /**
     * <code>emNv1360x768 = 50;</code>
     *
     * <pre>
     *1360*768
     * </pre>
     */
    public static final int emNv1360x768_VALUE = 50;
    /**
     * <code>emNvVResEnd = 100;</code>
     */
    public static final int emNvVResEnd_VALUE = 100;


    public final int getNumber() { return value; }

    public static EmNvResolution valueOf(int value) {
      switch (value) {
        case 0: return emNvResAuto;
        case 1: return emNvSQCIF;
        case 2: return emNvQCIF;
        case 3: return emNvCIF;
        case 4: return emNv2CIF;
        case 5: return emNv4CIF;
        case 6: return emNv16CIF;
        case 7: return emNvVGA352x240;
        case 8: return emNv2SIF;
        case 9: return emNvVGA704x480;
        case 10: return emNvVGA640x480;
        case 11: return emNvVGA800x600;
        case 12: return emNvVGA1024x768;
        case 13: return emNvVWCIF;
        case 14: return emNvVSQCIF112x96;
        case 15: return emNvVSQCIF96x80;
        case 16: return emNvVW4CIF;
        case 17: return emNvHD720p1280x720;
        case 18: return emNvVGA1280x1024;
        case 19: return emNvVGA1600x1200;
        case 20: return emNvHD1080i1920x1080;
        case 21: return emNvHD1080p1920x1080;
        case 22: return emNvVGA1280x800;
        case 23: return emNvVGA1440x900;
        case 24: return emNvVGA1280x960;
        case 25: return emNvV1440x816;
        case 26: return emNv1280x720;
        case 27: return emNvV960x544;
        case 28: return emNvV640x368;
        case 29: return emNvV480x272;
        case 30: return emNv384x272;
        case 31: return emNv640x544;
        case 32: return emNv320x272;
        case 33: return emNv_720_960x544;
        case 34: return emNv_720_864x480;
        case 35: return emNv_720_640x368;
        case 36: return emNv_720_432x240;
        case 37: return emNv_720_320x192;
        case 38: return emNvVGA480x352;
        case 39: return emNvHD480i720x480;
        case 40: return emNvHD480p720x480;
        case 41: return emNvHD576i720x576;
        case 42: return emNvHD576p720x576;
        case 43: return emNvVGA1280x768;
        case 44: return emNvVGA1366x768;
        case 45: return emNvVGA1280x854;
        case 46: return emNvVGA1680x1050;
        case 47: return emNvVGA1920x1200;
        case 48: return emNvV3840x2160;
        case 49: return emNv1280x600;
        case 50: return emNv1360x768;
        case 100: return emNvVResEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvResolution>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvResolution>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvResolution>() {
            public EmNvResolution findValueByNumber(int number) {
              return EmNvResolution.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(13);
    }

    private static final EmNvResolution[] VALUES = values();

    public static EmNvResolution valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvResolution(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvResolution)
  }

  /**
   * Protobuf enum {@code nv.EmNvPathType}
   *
   * <pre>
   ** 数据路径类型 
   * </pre>
   */
  public enum EmNvPathType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvPathTypeBgn = 1;</code>
     */
    emNvPathTypeBgn(0, 1),
    /**
     * <code>emNvPathConfig = 2;</code>
     *
     * <pre>
     *终端配置
     * </pre>
     */
    emNvPathConfig(1, 2),
    /**
     * <code>emNvPathLog = 3;</code>
     *
     * <pre>
     *终端日志
     * </pre>
     */
    emNvPathLog(2, 3),
    /**
     * <code>emNvDataLog = 4;</code>
     *
     * <pre>
     *终端数据
     * </pre>
     */
    emNvDataLog(3, 4),
    /**
     * <code>emNvPathTypeEnd = 255;</code>
     */
    emNvPathTypeEnd(4, 255),
    ;

    /**
     * <code>emNvPathTypeBgn = 1;</code>
     */
    public static final int emNvPathTypeBgn_VALUE = 1;
    /**
     * <code>emNvPathConfig = 2;</code>
     *
     * <pre>
     *终端配置
     * </pre>
     */
    public static final int emNvPathConfig_VALUE = 2;
    /**
     * <code>emNvPathLog = 3;</code>
     *
     * <pre>
     *终端日志
     * </pre>
     */
    public static final int emNvPathLog_VALUE = 3;
    /**
     * <code>emNvDataLog = 4;</code>
     *
     * <pre>
     *终端数据
     * </pre>
     */
    public static final int emNvDataLog_VALUE = 4;
    /**
     * <code>emNvPathTypeEnd = 255;</code>
     */
    public static final int emNvPathTypeEnd_VALUE = 255;


    public final int getNumber() { return value; }

    public static EmNvPathType valueOf(int value) {
      switch (value) {
        case 1: return emNvPathTypeBgn;
        case 2: return emNvPathConfig;
        case 3: return emNvPathLog;
        case 4: return emNvDataLog;
        case 255: return emNvPathTypeEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvPathType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvPathType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvPathType>() {
            public EmNvPathType findValueByNumber(int number) {
              return EmNvPathType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(14);
    }

    private static final EmNvPathType[] VALUES = values();

    public static EmNvPathType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvPathType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvPathType)
  }

  /**
   * Protobuf enum {@code nv.EmNvFile}
   */
  public enum EmNvFile
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvFileBegin = 0;</code>
     *
     * <pre>
     *终端文件类型开始
     * </pre>
     */
    emNvFileBegin(0, 0),
    /**
     * <code>emNvConfigFile = 1;</code>
     *
     * <pre>
     *配置文件
     * </pre>
     */
    emNvConfigFile(1, 1),
    /**
     * <code>emNvDebugConfigFile = 2;</code>
     *
     * <pre>
     *调试配置文件	
     * </pre>
     */
    emNvDebugConfigFile(2, 2),
    /**
     * <code>emNvStaticPicFile = 3;</code>
     *
     * <pre>
     *终端静态图片文件
     * </pre>
     */
    emNvStaticPicFile(3, 3),
    /**
     * <code>emNvUpgradeStateFile = 4;</code>
     *
     * <pre>
     *终端升级状态信息保存文件（实现断点续传）
     * </pre>
     */
    emNvUpgradeStateFile(4, 4),
    /**
     * <code>emNvMcLicenseFile = 5;</code>
     *
     * <pre>
     *内置mc的license文件
     * </pre>
     */
    emNvMcLicenseFile(5, 5),
    /**
     * <code>emNvKdvlogCfgFile = 6;</code>
     *
     * <pre>
     *kdvlog模块需要的配置文件
     * </pre>
     */
    emNvKdvlogCfgFile(6, 6),
    /**
     * <code>emNvCorruptConfigFile = 7;</code>
     *
     * <pre>
     *已损坏的配置文件
     * </pre>
     */
    emNvCorruptConfigFile(7, 7),
    /**
     * <code>emNvExceptionFile = 8;</code>
     *
     * <pre>
     *终端崩溃异常文件
     * </pre>
     */
    emNvExceptionFile(8, 8),
    /**
     * <code>emNvLogFile = 9;</code>
     *
     * <pre>
     *终端日志文件路径
     * </pre>
     */
    emNvLogFile(9, 9),
    /**
     * <code>emNvFileEnd = 255;</code>
     *
     * <pre>
     *终端文件类型结束
     * </pre>
     */
    emNvFileEnd(10, 255),
    ;

    /**
     * <code>emNvFileBegin = 0;</code>
     *
     * <pre>
     *终端文件类型开始
     * </pre>
     */
    public static final int emNvFileBegin_VALUE = 0;
    /**
     * <code>emNvConfigFile = 1;</code>
     *
     * <pre>
     *配置文件
     * </pre>
     */
    public static final int emNvConfigFile_VALUE = 1;
    /**
     * <code>emNvDebugConfigFile = 2;</code>
     *
     * <pre>
     *调试配置文件	
     * </pre>
     */
    public static final int emNvDebugConfigFile_VALUE = 2;
    /**
     * <code>emNvStaticPicFile = 3;</code>
     *
     * <pre>
     *终端静态图片文件
     * </pre>
     */
    public static final int emNvStaticPicFile_VALUE = 3;
    /**
     * <code>emNvUpgradeStateFile = 4;</code>
     *
     * <pre>
     *终端升级状态信息保存文件（实现断点续传）
     * </pre>
     */
    public static final int emNvUpgradeStateFile_VALUE = 4;
    /**
     * <code>emNvMcLicenseFile = 5;</code>
     *
     * <pre>
     *内置mc的license文件
     * </pre>
     */
    public static final int emNvMcLicenseFile_VALUE = 5;
    /**
     * <code>emNvKdvlogCfgFile = 6;</code>
     *
     * <pre>
     *kdvlog模块需要的配置文件
     * </pre>
     */
    public static final int emNvKdvlogCfgFile_VALUE = 6;
    /**
     * <code>emNvCorruptConfigFile = 7;</code>
     *
     * <pre>
     *已损坏的配置文件
     * </pre>
     */
    public static final int emNvCorruptConfigFile_VALUE = 7;
    /**
     * <code>emNvExceptionFile = 8;</code>
     *
     * <pre>
     *终端崩溃异常文件
     * </pre>
     */
    public static final int emNvExceptionFile_VALUE = 8;
    /**
     * <code>emNvLogFile = 9;</code>
     *
     * <pre>
     *终端日志文件路径
     * </pre>
     */
    public static final int emNvLogFile_VALUE = 9;
    /**
     * <code>emNvFileEnd = 255;</code>
     *
     * <pre>
     *终端文件类型结束
     * </pre>
     */
    public static final int emNvFileEnd_VALUE = 255;


    public final int getNumber() { return value; }

    public static EmNvFile valueOf(int value) {
      switch (value) {
        case 0: return emNvFileBegin;
        case 1: return emNvConfigFile;
        case 2: return emNvDebugConfigFile;
        case 3: return emNvStaticPicFile;
        case 4: return emNvUpgradeStateFile;
        case 5: return emNvMcLicenseFile;
        case 6: return emNvKdvlogCfgFile;
        case 7: return emNvCorruptConfigFile;
        case 8: return emNvExceptionFile;
        case 9: return emNvLogFile;
        case 255: return emNvFileEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvFile>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvFile>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvFile>() {
            public EmNvFile findValueByNumber(int number) {
              return EmNvFile.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(15);
    }

    private static final EmNvFile[] VALUES = values();

    public static EmNvFile valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvFile(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvFile)
  }

  /**
   * Protobuf enum {@code nv.EmNvUpgradeType}
   */
  public enum EmNvUpgradeType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvSusUpgrade = 0;</code>
     *
     * <pre>
     *远端升级
     * </pre>
     */
    emNvSusUpgrade(0, 0),
    /**
     * <code>emNvLocalUpgrade = 1;</code>
     *
     * <pre>
     *本地升级
     * </pre>
     */
    emNvLocalUpgrade(1, 1),
    /**
     * <code>emNvNvcUpgrade = 2;</code>
     */
    emNvNvcUpgrade(2, 2),
    ;

    /**
     * <code>emNvSusUpgrade = 0;</code>
     *
     * <pre>
     *远端升级
     * </pre>
     */
    public static final int emNvSusUpgrade_VALUE = 0;
    /**
     * <code>emNvLocalUpgrade = 1;</code>
     *
     * <pre>
     *本地升级
     * </pre>
     */
    public static final int emNvLocalUpgrade_VALUE = 1;
    /**
     * <code>emNvNvcUpgrade = 2;</code>
     */
    public static final int emNvNvcUpgrade_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvUpgradeType valueOf(int value) {
      switch (value) {
        case 0: return emNvSusUpgrade;
        case 1: return emNvLocalUpgrade;
        case 2: return emNvNvcUpgrade;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeType>() {
            public EmNvUpgradeType findValueByNumber(int number) {
              return EmNvUpgradeType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(16);
    }

    private static final EmNvUpgradeType[] VALUES = values();

    public static EmNvUpgradeType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvUpgradeType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvUpgradeType)
  }

  /**
   * Protobuf enum {@code nv.EmNvUpgradeNotify}
   */
  public enum EmNvUpgradeNotify
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvFileCheckBgn = 0;</code>
     *
     * <pre>
     * 文件检查开始
     * </pre>
     */
    emNvFileCheckBgn(0, 0),
    /**
     * <code>emNvWholeUpgradeBgn = 1;</code>
     *
     * <pre>
     * 整体升级开始
     * </pre>
     */
    emNvWholeUpgradeBgn(1, 1),
    /**
     * <code>emNvFileCheckSuccess = 2;</code>
     *
     * <pre>
     * 文件校验成功
     * </pre>
     */
    emNvFileCheckSuccess(2, 2),
    /**
     * <code>emNvWholeUpgradeSuccess = 3;</code>
     *
     * <pre>
     * 整体升级成功
     * </pre>
     */
    emNvWholeUpgradeSuccess(3, 3),
    /**
     * <code>emNvUnknownErr = 4;</code>
     *
     * <pre>
     * 未知错误
     * </pre>
     */
    emNvUnknownErr(4, 4),
    /**
     * <code>emNvInvalidFileErr = 5;</code>
     *
     * <pre>
     * 升级包错误
     * </pre>
     */
    emNvInvalidFileErr(5, 5),
    /**
     * <code>emNvLoadXmlFileErr = 6;</code>
     *
     * <pre>
     * 解析xml错误
     * </pre>
     */
    emNvLoadXmlFileErr(6, 6),
    /**
     * <code>emNvFileCheckErr = 7;</code>
     *
     * <pre>
     * 文件校验失败
     * </pre>
     */
    emNvFileCheckErr(7, 7),
    /**
     * <code>emNvSysMountBakErr = 8;</code>
     *
     * <pre>
     * 挂载备份分区失败
     * </pre>
     */
    emNvSysMountBakErr(8, 8),
    /**
     * <code>emNvUpgradeDriverModuleErr = 9;</code>
     *
     * <pre>
     * 驱动模块升级失败
     * </pre>
     */
    emNvUpgradeDriverModuleErr(9, 9),
    /**
     * <code>emNvUpgradeAppModuleErr = 10;</code>
     *
     * <pre>
     * 应用模块升级失败
     * </pre>
     */
    emNvUpgradeAppModuleErr(10, 10),
    /**
     * <code>emNvUpgradeExeModuleErr = 11;</code>
     *
     * <pre>
     * 可执行模块升级失败
     * </pre>
     */
    emNvUpgradeExeModuleErr(11, 11),
    ;

    /**
     * <code>emNvFileCheckBgn = 0;</code>
     *
     * <pre>
     * 文件检查开始
     * </pre>
     */
    public static final int emNvFileCheckBgn_VALUE = 0;
    /**
     * <code>emNvWholeUpgradeBgn = 1;</code>
     *
     * <pre>
     * 整体升级开始
     * </pre>
     */
    public static final int emNvWholeUpgradeBgn_VALUE = 1;
    /**
     * <code>emNvFileCheckSuccess = 2;</code>
     *
     * <pre>
     * 文件校验成功
     * </pre>
     */
    public static final int emNvFileCheckSuccess_VALUE = 2;
    /**
     * <code>emNvWholeUpgradeSuccess = 3;</code>
     *
     * <pre>
     * 整体升级成功
     * </pre>
     */
    public static final int emNvWholeUpgradeSuccess_VALUE = 3;
    /**
     * <code>emNvUnknownErr = 4;</code>
     *
     * <pre>
     * 未知错误
     * </pre>
     */
    public static final int emNvUnknownErr_VALUE = 4;
    /**
     * <code>emNvInvalidFileErr = 5;</code>
     *
     * <pre>
     * 升级包错误
     * </pre>
     */
    public static final int emNvInvalidFileErr_VALUE = 5;
    /**
     * <code>emNvLoadXmlFileErr = 6;</code>
     *
     * <pre>
     * 解析xml错误
     * </pre>
     */
    public static final int emNvLoadXmlFileErr_VALUE = 6;
    /**
     * <code>emNvFileCheckErr = 7;</code>
     *
     * <pre>
     * 文件校验失败
     * </pre>
     */
    public static final int emNvFileCheckErr_VALUE = 7;
    /**
     * <code>emNvSysMountBakErr = 8;</code>
     *
     * <pre>
     * 挂载备份分区失败
     * </pre>
     */
    public static final int emNvSysMountBakErr_VALUE = 8;
    /**
     * <code>emNvUpgradeDriverModuleErr = 9;</code>
     *
     * <pre>
     * 驱动模块升级失败
     * </pre>
     */
    public static final int emNvUpgradeDriverModuleErr_VALUE = 9;
    /**
     * <code>emNvUpgradeAppModuleErr = 10;</code>
     *
     * <pre>
     * 应用模块升级失败
     * </pre>
     */
    public static final int emNvUpgradeAppModuleErr_VALUE = 10;
    /**
     * <code>emNvUpgradeExeModuleErr = 11;</code>
     *
     * <pre>
     * 可执行模块升级失败
     * </pre>
     */
    public static final int emNvUpgradeExeModuleErr_VALUE = 11;


    public final int getNumber() { return value; }

    public static EmNvUpgradeNotify valueOf(int value) {
      switch (value) {
        case 0: return emNvFileCheckBgn;
        case 1: return emNvWholeUpgradeBgn;
        case 2: return emNvFileCheckSuccess;
        case 3: return emNvWholeUpgradeSuccess;
        case 4: return emNvUnknownErr;
        case 5: return emNvInvalidFileErr;
        case 6: return emNvLoadXmlFileErr;
        case 7: return emNvFileCheckErr;
        case 8: return emNvSysMountBakErr;
        case 9: return emNvUpgradeDriverModuleErr;
        case 10: return emNvUpgradeAppModuleErr;
        case 11: return emNvUpgradeExeModuleErr;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeNotify>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeNotify>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeNotify>() {
            public EmNvUpgradeNotify findValueByNumber(int number) {
              return EmNvUpgradeNotify.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(17);
    }

    private static final EmNvUpgradeNotify[] VALUES = values();

    public static EmNvUpgradeNotify valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvUpgradeNotify(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvUpgradeNotify)
  }

  /**
   * Protobuf enum {@code nv.EmNvServerType}
   *
   * <pre>
   *服务器类型
   * </pre>
   */
  public enum EmNvServerType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvAPS = 0;</code>
     *
     * <pre>
     *接入
     * </pre>
     */
    emNvAPS(0, 0),
    /**
     * <code>emNvXNU = 1;</code>
     *
     * <pre>
     *短消息
     * </pre>
     */
    emNvXNU(1, 1),
    /**
     * <code>emNvSUS = 2;</code>
     *
     * <pre>
     *升级
     * </pre>
     */
    emNvSUS(2, 2),
    /**
     * <code>emNvNMS = 3;</code>
     *
     * <pre>
     *网管
     * </pre>
     */
    emNvNMS(3, 3),
    /**
     * <code>emNvNTS = 4;</code>
     *
     * <pre>
     *测速
     * </pre>
     */
    emNvNTS(4, 4),
    /**
     * <code>emNvSIP = 5;</code>
     *
     * <pre>
     *SIP呼叫
     * </pre>
     */
    emNvSIP(5, 5),
    /**
     * <code>emNvNonH323 = 6;</code>
     *
     * <pre>
     *非标H323
     * </pre>
     */
    emNvNonH323(6, 6),
    /**
     * <code>emNvStdH323 = 7;</code>
     *
     * <pre>
     *标准H323
     * </pre>
     */
    emNvStdH323(7, 7),
    /**
     * <code>emNvNTP = 8;</code>
     *
     * <pre>
     *NTP
     * </pre>
     */
    emNvNTP(8, 8),
    /**
     * <code>emNvVOD = 9;</code>
     *
     * <pre>
     *VOD
     * </pre>
     */
    emNvVOD(9, 9),
    /**
     * <code>emNvMoMeeting = 10;</code>
     *
     * <pre>
     *会管
     * </pre>
     */
    emNvMoMeeting(10, 10),
    /**
     * <code>emNvMoPlatform = 11;</code>
     *
     * <pre>
     *平台
     * </pre>
     */
    emNvMoPlatform(11, 11),
    /**
     * <code>emNvVRS = 12;</code>
     *
     * <pre>
     *会议录播
     * </pre>
     */
    emNvVRS(12, 12),
    /**
     * <code>emNvDCS = 13;</code>
     *
     * <pre>
     *数据会议
     * </pre>
     */
    emNvDCS(13, 13),
    /**
     * <code>emNvServerTypeEnd = 14;</code>
     */
    emNvServerTypeEnd(14, 14),
    ;

    /**
     * <code>emNvAPS = 0;</code>
     *
     * <pre>
     *接入
     * </pre>
     */
    public static final int emNvAPS_VALUE = 0;
    /**
     * <code>emNvXNU = 1;</code>
     *
     * <pre>
     *短消息
     * </pre>
     */
    public static final int emNvXNU_VALUE = 1;
    /**
     * <code>emNvSUS = 2;</code>
     *
     * <pre>
     *升级
     * </pre>
     */
    public static final int emNvSUS_VALUE = 2;
    /**
     * <code>emNvNMS = 3;</code>
     *
     * <pre>
     *网管
     * </pre>
     */
    public static final int emNvNMS_VALUE = 3;
    /**
     * <code>emNvNTS = 4;</code>
     *
     * <pre>
     *测速
     * </pre>
     */
    public static final int emNvNTS_VALUE = 4;
    /**
     * <code>emNvSIP = 5;</code>
     *
     * <pre>
     *SIP呼叫
     * </pre>
     */
    public static final int emNvSIP_VALUE = 5;
    /**
     * <code>emNvNonH323 = 6;</code>
     *
     * <pre>
     *非标H323
     * </pre>
     */
    public static final int emNvNonH323_VALUE = 6;
    /**
     * <code>emNvStdH323 = 7;</code>
     *
     * <pre>
     *标准H323
     * </pre>
     */
    public static final int emNvStdH323_VALUE = 7;
    /**
     * <code>emNvNTP = 8;</code>
     *
     * <pre>
     *NTP
     * </pre>
     */
    public static final int emNvNTP_VALUE = 8;
    /**
     * <code>emNvVOD = 9;</code>
     *
     * <pre>
     *VOD
     * </pre>
     */
    public static final int emNvVOD_VALUE = 9;
    /**
     * <code>emNvMoMeeting = 10;</code>
     *
     * <pre>
     *会管
     * </pre>
     */
    public static final int emNvMoMeeting_VALUE = 10;
    /**
     * <code>emNvMoPlatform = 11;</code>
     *
     * <pre>
     *平台
     * </pre>
     */
    public static final int emNvMoPlatform_VALUE = 11;
    /**
     * <code>emNvVRS = 12;</code>
     *
     * <pre>
     *会议录播
     * </pre>
     */
    public static final int emNvVRS_VALUE = 12;
    /**
     * <code>emNvDCS = 13;</code>
     *
     * <pre>
     *数据会议
     * </pre>
     */
    public static final int emNvDCS_VALUE = 13;
    /**
     * <code>emNvServerTypeEnd = 14;</code>
     */
    public static final int emNvServerTypeEnd_VALUE = 14;


    public final int getNumber() { return value; }

    public static EmNvServerType valueOf(int value) {
      switch (value) {
        case 0: return emNvAPS;
        case 1: return emNvXNU;
        case 2: return emNvSUS;
        case 3: return emNvNMS;
        case 4: return emNvNTS;
        case 5: return emNvSIP;
        case 6: return emNvNonH323;
        case 7: return emNvStdH323;
        case 8: return emNvNTP;
        case 9: return emNvVOD;
        case 10: return emNvMoMeeting;
        case 11: return emNvMoPlatform;
        case 12: return emNvVRS;
        case 13: return emNvDCS;
        case 14: return emNvServerTypeEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvServerType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvServerType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvServerType>() {
            public EmNvServerType findValueByNumber(int number) {
              return EmNvServerType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(18);
    }

    private static final EmNvServerType[] VALUES = values();

    public static EmNvServerType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvServerType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvServerType)
  }

  /**
   * Protobuf enum {@code nv.EmNvServerState}
   *
   * <pre>
   *服务器连接状态
   * </pre>
   */
  public enum EmNvServerState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvIdle = 0;</code>
     *
     * <pre>
     *空闲
     * </pre>
     */
    emNvIdle(0, 0),
    /**
     * <code>emNvDnsQuerying = 1;</code>
     *
     * <pre>
     *正在解析IP
     * </pre>
     */
    emNvDnsQuerying(1, 1),
    /**
     * <code>emNvLogging_In = 2;</code>
     *
     * <pre>
     *正在登录
     * </pre>
     */
    emNvLogging_In(2, 2),
    /**
     * <code>emNvLogin_Succ = 3;</code>
     *
     * <pre>
     *登录成功
     * </pre>
     */
    emNvLogin_Succ(3, 3),
    /**
     * <code>emNvLogging_Out = 4;</code>
     *
     * <pre>
     *正在登出
     * </pre>
     */
    emNvLogging_Out(4, 4),
    /**
     * <code>emNvDisconnected = 5;</code>
     *
     * <pre>
     *断链（适用于保持心跳的服务器）
     * </pre>
     */
    emNvDisconnected(5, 5),
    /**
     * <code>emNvLogin_Err = 6;</code>
     *
     * <pre>
     *登录失败
     * </pre>
     */
    emNvLogin_Err(6, 6),
    ;

    /**
     * <code>emNvIdle = 0;</code>
     *
     * <pre>
     *空闲
     * </pre>
     */
    public static final int emNvIdle_VALUE = 0;
    /**
     * <code>emNvDnsQuerying = 1;</code>
     *
     * <pre>
     *正在解析IP
     * </pre>
     */
    public static final int emNvDnsQuerying_VALUE = 1;
    /**
     * <code>emNvLogging_In = 2;</code>
     *
     * <pre>
     *正在登录
     * </pre>
     */
    public static final int emNvLogging_In_VALUE = 2;
    /**
     * <code>emNvLogin_Succ = 3;</code>
     *
     * <pre>
     *登录成功
     * </pre>
     */
    public static final int emNvLogin_Succ_VALUE = 3;
    /**
     * <code>emNvLogging_Out = 4;</code>
     *
     * <pre>
     *正在登出
     * </pre>
     */
    public static final int emNvLogging_Out_VALUE = 4;
    /**
     * <code>emNvDisconnected = 5;</code>
     *
     * <pre>
     *断链（适用于保持心跳的服务器）
     * </pre>
     */
    public static final int emNvDisconnected_VALUE = 5;
    /**
     * <code>emNvLogin_Err = 6;</code>
     *
     * <pre>
     *登录失败
     * </pre>
     */
    public static final int emNvLogin_Err_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmNvServerState valueOf(int value) {
      switch (value) {
        case 0: return emNvIdle;
        case 1: return emNvDnsQuerying;
        case 2: return emNvLogging_In;
        case 3: return emNvLogin_Succ;
        case 4: return emNvLogging_Out;
        case 5: return emNvDisconnected;
        case 6: return emNvLogin_Err;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvServerState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvServerState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvServerState>() {
            public EmNvServerState findValueByNumber(int number) {
              return EmNvServerState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(19);
    }

    private static final EmNvServerState[] VALUES = values();

    public static EmNvServerState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvServerState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvServerState)
  }

  /**
   * Protobuf enum {@code nv.EmNvUpgradeVerLevel}
   *
   * <pre>
   *升级包版本等级
   * </pre>
   */
  public enum EmNvUpgradeVerLevel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvUpgradeLevelForced = 0;</code>
     *
     * <pre>
     *强制
     * </pre>
     */
    emNvUpgradeLevelForced(0, 0),
    /**
     * <code>emNvUpgradeLevelSuggested = 1;</code>
     *
     * <pre>
     *建议
     * </pre>
     */
    emNvUpgradeLevelSuggested(1, 1),
    /**
     * <code>emNvUpgradeLevelNormal = 2;</code>
     *
     * <pre>
     *普通
     * </pre>
     */
    emNvUpgradeLevelNormal(2, 2),
    ;

    /**
     * <code>emNvUpgradeLevelForced = 0;</code>
     *
     * <pre>
     *强制
     * </pre>
     */
    public static final int emNvUpgradeLevelForced_VALUE = 0;
    /**
     * <code>emNvUpgradeLevelSuggested = 1;</code>
     *
     * <pre>
     *建议
     * </pre>
     */
    public static final int emNvUpgradeLevelSuggested_VALUE = 1;
    /**
     * <code>emNvUpgradeLevelNormal = 2;</code>
     *
     * <pre>
     *普通
     * </pre>
     */
    public static final int emNvUpgradeLevelNormal_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvUpgradeVerLevel valueOf(int value) {
      switch (value) {
        case 0: return emNvUpgradeLevelForced;
        case 1: return emNvUpgradeLevelSuggested;
        case 2: return emNvUpgradeLevelNormal;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeVerLevel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeVerLevel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeVerLevel>() {
            public EmNvUpgradeVerLevel findValueByNumber(int number) {
              return EmNvUpgradeVerLevel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(20);
    }

    private static final EmNvUpgradeVerLevel[] VALUES = values();

    public static EmNvUpgradeVerLevel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvUpgradeVerLevel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvUpgradeVerLevel)
  }

  /**
   * Protobuf enum {@code nv.EmNvUpgradeReleaseAttr}
   *
   * <pre>
   *版本发布属性
   * </pre>
   */
  public enum EmNvUpgradeReleaseAttr
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvUpgradeAttr = 0;</code>
     */
    emNvUpgradeAttr(0, 0),
    /**
     * <code>emNvUpgradeAttrCommon = 1;</code>
     *
     * <pre>
     *普通版本
     * </pre>
     */
    emNvUpgradeAttrCommon(1, 1),
    /**
     * <code>emNvUpgradeAttrRecommend = 2;</code>
     *
     * <pre>
     *推荐版本
     * </pre>
     */
    emNvUpgradeAttrRecommend(2, 2),
    /**
     * <code>emNvUpgradeAttrGray = 4;</code>
     *
     * <pre>
     *灰度版本
     * </pre>
     */
    emNvUpgradeAttrGray(3, 4),
    ;

    /**
     * <code>emNvUpgradeAttr = 0;</code>
     */
    public static final int emNvUpgradeAttr_VALUE = 0;
    /**
     * <code>emNvUpgradeAttrCommon = 1;</code>
     *
     * <pre>
     *普通版本
     * </pre>
     */
    public static final int emNvUpgradeAttrCommon_VALUE = 1;
    /**
     * <code>emNvUpgradeAttrRecommend = 2;</code>
     *
     * <pre>
     *推荐版本
     * </pre>
     */
    public static final int emNvUpgradeAttrRecommend_VALUE = 2;
    /**
     * <code>emNvUpgradeAttrGray = 4;</code>
     *
     * <pre>
     *灰度版本
     * </pre>
     */
    public static final int emNvUpgradeAttrGray_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmNvUpgradeReleaseAttr valueOf(int value) {
      switch (value) {
        case 0: return emNvUpgradeAttr;
        case 1: return emNvUpgradeAttrCommon;
        case 2: return emNvUpgradeAttrRecommend;
        case 4: return emNvUpgradeAttrGray;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeReleaseAttr>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeReleaseAttr>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvUpgradeReleaseAttr>() {
            public EmNvUpgradeReleaseAttr findValueByNumber(int number) {
              return EmNvUpgradeReleaseAttr.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(21);
    }

    private static final EmNvUpgradeReleaseAttr[] VALUES = values();

    public static EmNvUpgradeReleaseAttr valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvUpgradeReleaseAttr(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvUpgradeReleaseAttr)
  }

  /**
   * Protobuf enum {@code nv.EmNvNvcType}
   */
  public enum EmNvNvcType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvUnkownT = 0;</code>
     *
     * <pre>
     *表示未知类型
     * </pre>
     */
    emNvUnkownT(0, 0),
    /**
     * <code>emNvNvcT = 1;</code>
     *
     * <pre>
     *mtc类型终端客户端
     * </pre>
     */
    emNvNvcT(1, 1),
    /**
     * <code>emNvPcdvT = 2;</code>
     *
     * <pre>
     *pc流类型终端客户端
     * </pre>
     */
    emNvPcdvT(2, 2),
    /**
     * <code>emNvNctT = 3;</code>
     *
     * <pre>
     *服务器配置类型终端客户端
     * </pre>
     */
    emNvNctT(3, 3),
    /**
     * <code>emNvQuickShareT = 4;</code>
     *
     * <pre>
     *无线投屏发射端
     * </pre>
     */
    emNvQuickShareT(4, 4),
    /**
     * <code>emNvSystemUpgrade = 5;</code>
     *
     * <pre>
     *imix升级
     * </pre>
     */
    emNvSystemUpgrade(5, 5),
    /**
     * <code>emNvSystemSetting = 6;</code>
     *
     * <pre>
     *imix系统设置
     * </pre>
     */
    emNvSystemSetting(6, 6),
    /**
     * <code>emNvSystemToolbar = 7;</code>
     *
     * <pre>
     *imix切源
     * </pre>
     */
    emNvSystemToolbar(7, 7),
    /**
     * <code>emNvScreenDrawing = 8;</code>
     *
     * <pre>
     *imix快照
     * </pre>
     */
    emNvScreenDrawing(8, 8),
    /**
     * <code>emNvContainer = 9;</code>
     *
     * <pre>
     *PAD
     * </pre>
     */
    emNvContainer(9, 9),
    /**
     * <code>emNvPADUpgrade = 10;</code>
     *
     * <pre>
     *PAD升级
     * </pre>
     */
    emNvPADUpgrade(10, 10),
    ;

    /**
     * <code>emNvUnkownT = 0;</code>
     *
     * <pre>
     *表示未知类型
     * </pre>
     */
    public static final int emNvUnkownT_VALUE = 0;
    /**
     * <code>emNvNvcT = 1;</code>
     *
     * <pre>
     *mtc类型终端客户端
     * </pre>
     */
    public static final int emNvNvcT_VALUE = 1;
    /**
     * <code>emNvPcdvT = 2;</code>
     *
     * <pre>
     *pc流类型终端客户端
     * </pre>
     */
    public static final int emNvPcdvT_VALUE = 2;
    /**
     * <code>emNvNctT = 3;</code>
     *
     * <pre>
     *服务器配置类型终端客户端
     * </pre>
     */
    public static final int emNvNctT_VALUE = 3;
    /**
     * <code>emNvQuickShareT = 4;</code>
     *
     * <pre>
     *无线投屏发射端
     * </pre>
     */
    public static final int emNvQuickShareT_VALUE = 4;
    /**
     * <code>emNvSystemUpgrade = 5;</code>
     *
     * <pre>
     *imix升级
     * </pre>
     */
    public static final int emNvSystemUpgrade_VALUE = 5;
    /**
     * <code>emNvSystemSetting = 6;</code>
     *
     * <pre>
     *imix系统设置
     * </pre>
     */
    public static final int emNvSystemSetting_VALUE = 6;
    /**
     * <code>emNvSystemToolbar = 7;</code>
     *
     * <pre>
     *imix切源
     * </pre>
     */
    public static final int emNvSystemToolbar_VALUE = 7;
    /**
     * <code>emNvScreenDrawing = 8;</code>
     *
     * <pre>
     *imix快照
     * </pre>
     */
    public static final int emNvScreenDrawing_VALUE = 8;
    /**
     * <code>emNvContainer = 9;</code>
     *
     * <pre>
     *PAD
     * </pre>
     */
    public static final int emNvContainer_VALUE = 9;
    /**
     * <code>emNvPADUpgrade = 10;</code>
     *
     * <pre>
     *PAD升级
     * </pre>
     */
    public static final int emNvPADUpgrade_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmNvNvcType valueOf(int value) {
      switch (value) {
        case 0: return emNvUnkownT;
        case 1: return emNvNvcT;
        case 2: return emNvPcdvT;
        case 3: return emNvNctT;
        case 4: return emNvQuickShareT;
        case 5: return emNvSystemUpgrade;
        case 6: return emNvSystemSetting;
        case 7: return emNvSystemToolbar;
        case 8: return emNvScreenDrawing;
        case 9: return emNvContainer;
        case 10: return emNvPADUpgrade;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvNvcType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvNvcType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvNvcType>() {
            public EmNvNvcType findValueByNumber(int number) {
              return EmNvNvcType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(22);
    }

    private static final EmNvNvcType[] VALUES = values();

    public static EmNvNvcType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvNvcType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvNvcType)
  }

  /**
   * Protobuf enum {@code nv.EmNvNetAdapterWorkType}
   */
  public enum EmNvNetAdapterWorkType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvNetAdapterWorkType_None = 0;</code>
     *
     * <pre>
     *不可用
     * </pre>
     */
    emNvNetAdapterWorkType_None(0, 0),
    /**
     * <code>emNvNetAdapterWorkType_Wifi = 1;</code>
     *
     * <pre>
     *WIFI
     * </pre>
     */
    emNvNetAdapterWorkType_Wifi(1, 1),
    /**
     * <code>emNvNetAdapterWorkType_PPPoE = 2;</code>
     *
     * <pre>
     *PPPOE
     * </pre>
     */
    emNvNetAdapterWorkType_PPPoE(2, 2),
    /**
     * <code>emNvNetAdapterWorkType_MobileData = 3;</code>
     *
     * <pre>
     *移动数据3G/4G
     * </pre>
     */
    emNvNetAdapterWorkType_MobileData(3, 3),
    /**
     * <code>emNvNetAdapterWorkType_EthnetCard1 = 4;</code>
     *
     * <pre>
     *以太网Lan1
     * </pre>
     */
    emNvNetAdapterWorkType_EthnetCard1(4, 4),
    /**
     * <code>emNvNetAdapterWorkType_EthnetCard2 = 5;</code>
     *
     * <pre>
     *以太网Lan2
     * </pre>
     */
    emNvNetAdapterWorkType_EthnetCard2(5, 5),
    /**
     * <code>emNvNetAdapterWorkType_E1 = 6;</code>
     *
     * <pre>
     *E1通讯
     * </pre>
     */
    emNvNetAdapterWorkType_E1(6, 6),
    ;

    /**
     * <code>emNvNetAdapterWorkType_None = 0;</code>
     *
     * <pre>
     *不可用
     * </pre>
     */
    public static final int emNvNetAdapterWorkType_None_VALUE = 0;
    /**
     * <code>emNvNetAdapterWorkType_Wifi = 1;</code>
     *
     * <pre>
     *WIFI
     * </pre>
     */
    public static final int emNvNetAdapterWorkType_Wifi_VALUE = 1;
    /**
     * <code>emNvNetAdapterWorkType_PPPoE = 2;</code>
     *
     * <pre>
     *PPPOE
     * </pre>
     */
    public static final int emNvNetAdapterWorkType_PPPoE_VALUE = 2;
    /**
     * <code>emNvNetAdapterWorkType_MobileData = 3;</code>
     *
     * <pre>
     *移动数据3G/4G
     * </pre>
     */
    public static final int emNvNetAdapterWorkType_MobileData_VALUE = 3;
    /**
     * <code>emNvNetAdapterWorkType_EthnetCard1 = 4;</code>
     *
     * <pre>
     *以太网Lan1
     * </pre>
     */
    public static final int emNvNetAdapterWorkType_EthnetCard1_VALUE = 4;
    /**
     * <code>emNvNetAdapterWorkType_EthnetCard2 = 5;</code>
     *
     * <pre>
     *以太网Lan2
     * </pre>
     */
    public static final int emNvNetAdapterWorkType_EthnetCard2_VALUE = 5;
    /**
     * <code>emNvNetAdapterWorkType_E1 = 6;</code>
     *
     * <pre>
     *E1通讯
     * </pre>
     */
    public static final int emNvNetAdapterWorkType_E1_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmNvNetAdapterWorkType valueOf(int value) {
      switch (value) {
        case 0: return emNvNetAdapterWorkType_None;
        case 1: return emNvNetAdapterWorkType_Wifi;
        case 2: return emNvNetAdapterWorkType_PPPoE;
        case 3: return emNvNetAdapterWorkType_MobileData;
        case 4: return emNvNetAdapterWorkType_EthnetCard1;
        case 5: return emNvNetAdapterWorkType_EthnetCard2;
        case 6: return emNvNetAdapterWorkType_E1;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvNetAdapterWorkType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvNetAdapterWorkType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvNetAdapterWorkType>() {
            public EmNvNetAdapterWorkType findValueByNumber(int number) {
              return EmNvNetAdapterWorkType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(23);
    }

    private static final EmNvNetAdapterWorkType[] VALUES = values();

    public static EmNvNetAdapterWorkType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvNetAdapterWorkType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvNetAdapterWorkType)
  }

  /**
   * Protobuf enum {@code nv.EmNvRemoteType}
   */
  public enum EmNvRemoteType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvRemoteTypeUnknown = 0;</code>
     *
     * <pre>
     * 未知遥控器
     * </pre>
     */
    emNvRemoteTypeUnknown(0, 0),
    /**
     * <code>emNvRemoteTypeShortBlack = 1;</code>
     *
     * <pre>
     * 短黑色遥控器
     * </pre>
     */
    emNvRemoteTypeShortBlack(1, 1),
    /**
     * <code>emNvRemoteTypeLongBlack = 2;</code>
     *
     * <pre>
     * 长黑色遥控器
     * </pre>
     */
    emNvRemoteTypeLongBlack(2, 2),
    /**
     * <code>emNvRemoteTypeSilver = 3;</code>
     *
     * <pre>
     * 银色遥控器
     * </pre>
     */
    emNvRemoteTypeSilver(3, 3),
    /**
     * <code>emNvRemoteTypeV3CamCtrl = 4;</code>
     *
     * <pre>
     * V3Cam遥控器
     * </pre>
     */
    emNvRemoteTypeV3CamCtrl(4, 4),
    /**
     * <code>emNvRemoteTypeSkyWalker = 5;</code>
     *
     * <pre>
     * SkyWalker遥控器
     * </pre>
     */
    emNvRemoteTypeSkyWalker(5, 5),
    ;

    /**
     * <code>emNvRemoteTypeUnknown = 0;</code>
     *
     * <pre>
     * 未知遥控器
     * </pre>
     */
    public static final int emNvRemoteTypeUnknown_VALUE = 0;
    /**
     * <code>emNvRemoteTypeShortBlack = 1;</code>
     *
     * <pre>
     * 短黑色遥控器
     * </pre>
     */
    public static final int emNvRemoteTypeShortBlack_VALUE = 1;
    /**
     * <code>emNvRemoteTypeLongBlack = 2;</code>
     *
     * <pre>
     * 长黑色遥控器
     * </pre>
     */
    public static final int emNvRemoteTypeLongBlack_VALUE = 2;
    /**
     * <code>emNvRemoteTypeSilver = 3;</code>
     *
     * <pre>
     * 银色遥控器
     * </pre>
     */
    public static final int emNvRemoteTypeSilver_VALUE = 3;
    /**
     * <code>emNvRemoteTypeV3CamCtrl = 4;</code>
     *
     * <pre>
     * V3Cam遥控器
     * </pre>
     */
    public static final int emNvRemoteTypeV3CamCtrl_VALUE = 4;
    /**
     * <code>emNvRemoteTypeSkyWalker = 5;</code>
     *
     * <pre>
     * SkyWalker遥控器
     * </pre>
     */
    public static final int emNvRemoteTypeSkyWalker_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmNvRemoteType valueOf(int value) {
      switch (value) {
        case 0: return emNvRemoteTypeUnknown;
        case 1: return emNvRemoteTypeShortBlack;
        case 2: return emNvRemoteTypeLongBlack;
        case 3: return emNvRemoteTypeSilver;
        case 4: return emNvRemoteTypeV3CamCtrl;
        case 5: return emNvRemoteTypeSkyWalker;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvRemoteType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvRemoteType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvRemoteType>() {
            public EmNvRemoteType findValueByNumber(int number) {
              return EmNvRemoteType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(24);
    }

    private static final EmNvRemoteType[] VALUES = values();

    public static EmNvRemoteType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvRemoteType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvRemoteType)
  }

  /**
   * Protobuf enum {@code nv.EmNvRemoteScanCode}
   */
  public enum EmNvRemoteScanCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvScanCode0 = 0;</code>
     *
     * <pre>
     * 0 
     * </pre>
     */
    emNvScanCode0(0, 0),
    /**
     * <code>emNvScanCode1 = 1;</code>
     *
     * <pre>
     * 1 
     * </pre>
     */
    emNvScanCode1(1, 1),
    /**
     * <code>emNvScanCode2 = 2;</code>
     *
     * <pre>
     * 2 
     * </pre>
     */
    emNvScanCode2(2, 2),
    /**
     * <code>emNvScanCode3 = 3;</code>
     *
     * <pre>
     * 3 
     * </pre>
     */
    emNvScanCode3(3, 3),
    /**
     * <code>emNvScanCode4 = 4;</code>
     *
     * <pre>
     * 4 
     * </pre>
     */
    emNvScanCode4(4, 4),
    /**
     * <code>emNvScanCode5 = 5;</code>
     *
     * <pre>
     * 5 
     * </pre>
     */
    emNvScanCode5(5, 5),
    /**
     * <code>emNvScanCode6 = 6;</code>
     *
     * <pre>
     * 6 
     * </pre>
     */
    emNvScanCode6(6, 6),
    /**
     * <code>emNvScanCode7 = 7;</code>
     *
     * <pre>
     * 7 
     * </pre>
     */
    emNvScanCode7(7, 7),
    /**
     * <code>emNvScanCode8 = 8;</code>
     *
     * <pre>
     * 8 
     * </pre>
     */
    emNvScanCode8(8, 8),
    /**
     * <code>emNvScanCode9 = 9;</code>
     *
     * <pre>
     * 9   
     * </pre>
     */
    emNvScanCode9(9, 9),
    /**
     * <code>emNvScanCodePoint = 10;</code>
     *
     * <pre>
     * . 
     * </pre>
     */
    emNvScanCodePoint(10, 10),
    /**
     * <code>emNvScanCodeSharp = 11;</code>
     *
     * <pre>
     * #   
     * </pre>
     */
    emNvScanCodeSharp(11, 11),
    /**
     * <code>emNvScanCodeMenu = 12;</code>
     *
     * <pre>
     * 菜单 
     * </pre>
     */
    emNvScanCodeMenu(12, 12),
    /**
     * <code>emNvScanCodeBackspace = 13;</code>
     *
     * <pre>
     * 删除 
     * </pre>
     */
    emNvScanCodeBackspace(13, 13),
    /**
     * <code>emNvScanCodeEnter = 14;</code>
     *
     * <pre>
     * 确定 
     * </pre>
     */
    emNvScanCodeEnter(14, 14),
    /**
     * <code>emNvScanCodeUp = 15;</code>
     *
     * <pre>
     * 上 
     * </pre>
     */
    emNvScanCodeUp(15, 15),
    /**
     * <code>emNvScanCodeDown = 16;</code>
     *
     * <pre>
     * 下 
     * </pre>
     */
    emNvScanCodeDown(16, 16),
    /**
     * <code>emNvScanCodeLeft = 17;</code>
     *
     * <pre>
     * 左 
     * </pre>
     */
    emNvScanCodeLeft(17, 17),
    /**
     * <code>emNvScanCodeRight = 18;</code>
     *
     * <pre>
     * 右 
     * </pre>
     */
    emNvScanCodeRight(18, 18),
    /**
     * <code>emNvScanCodePower = 19;</code>
     *
     * <pre>
     * 电源 
     * </pre>
     */
    emNvScanCodePower(19, 19),
    /**
     * <code>emNvScanCodeMainVSrc = 20;</code>
     *
     * <pre>
     * 主视频源 
     * </pre>
     */
    emNvScanCodeMainVSrc(20, 20),
    /**
     * <code>emNvScanCodeAV = 21;</code>
     *
     * <pre>
     * AV
     * </pre>
     */
    emNvScanCodeAV(21, 21),
    /**
     * <code>emNvScanCodeFarCtrl = 22;</code>
     *
     * <pre>
     * 远遥
     * </pre>
     */
    emNvScanCodeFarCtrl(22, 22),
    /**
     * <code>emNvScanCodeMute = 23;</code>
     *
     * <pre>
     * 哑音
     * </pre>
     */
    emNvScanCodeMute(23, 23),
    /**
     * <code>emNvScanCodeQuiet = 24;</code>
     *
     * <pre>
     * 静音
     * </pre>
     */
    emNvScanCodeQuiet(24, 24),
    /**
     * <code>emNvScanCodeVGA = 25;</code>
     *
     * <pre>
     * VGA
     * </pre>
     */
    emNvScanCodeVGA(25, 25),
    /**
     * <code>emNvScanCodeS = 26;</code>
     *
     * <pre>
     * S端子
     * </pre>
     */
    emNvScanCodeS(26, 26),
    /**
     * <code>emNvScanCodeShotSnap = 27;</code>
     *
     * <pre>
     * 快照
     * </pre>
     */
    emNvScanCodeShotSnap(27, 27),
    /**
     * <code>emNvScanCodeVolumeUp = 28;</code>
     *
     * <pre>
     * 音量+
     * </pre>
     */
    emNvScanCodeVolumeUp(28, 28),
    /**
     * <code>emNvScanCodeVolumeDown = 29;</code>
     *
     * <pre>
     * 音量-
     * </pre>
     */
    emNvScanCodeVolumeDown(29, 29),
    /**
     * <code>emNvScanCodeConnect = 30;</code>
     *
     * <pre>
     * 拨号 
     * </pre>
     */
    emNvScanCodeConnect(30, 30),
    /**
     * <code>emNvScanCodeDisconnect = 31;</code>
     *
     * <pre>
     * 挂断 
     * </pre>
     */
    emNvScanCodeDisconnect(31, 31),
    /**
     * <code>emNvScanCodeDirectory = 32;</code>
     *
     * <pre>
     * 地址簿 
     * </pre>
     */
    emNvScanCodeDirectory(32, 32),
    /**
     * <code>emNvScanCodePipEnable = 33;</code>
     *
     * <pre>
     * 画中画 
     * </pre>
     */
    emNvScanCodePipEnable(33, 33),
    /**
     * <code>emNvScanCodePipAdjust = 34;</code>
     *
     * <pre>
     * 画中画缩放 
     * </pre>
     */
    emNvScanCodePipAdjust(34, 34),
    /**
     * <code>emNvScanCodeSelfTest = 35;</code>
     *
     * <pre>
     * 自检 
     * </pre>
     */
    emNvScanCodeSelfTest(35, 35),
    /**
     * <code>emNvScanCodeAutoFocus = 36;</code>
     *
     * <pre>
     * 自动调焦 
     * </pre>
     */
    emNvScanCodeAutoFocus(36, 36),
    /**
     * <code>emNvScanCodeNearZoom = 37;</code>
     *
     * <pre>
     * 近视 
     * </pre>
     */
    emNvScanCodeNearZoom(37, 37),
    /**
     * <code>emNvScanCodeFarZoom = 38;</code>
     *
     * <pre>
     * 远视 
     * </pre>
     */
    emNvScanCodeFarZoom(38, 38),
    /**
     * <code>emNvScanCodePreSave = 39;</code>
     *
     * <pre>
     * 保存预置位 
     * </pre>
     */
    emNvScanCodePreSave(39, 39),
    /**
     * <code>emNvScanCodePreMove = 40;</code>
     *
     * <pre>
     * 加载预置位 
     * </pre>
     */
    emNvScanCodePreMove(40, 40),
    /**
     * <code>emNvScanCodeChairReq = 41;</code>
     *
     * <pre>
     * 申请主席 
     * </pre>
     */
    emNvScanCodeChairReq(41, 41),
    /**
     * <code>emNvScanCodeSpeakReq = 42;</code>
     *
     * <pre>
     * 申请发言 
     * </pre>
     */
    emNvScanCodeSpeakReq(42, 42),
    /**
     * <code>emNvScanCodeQuitReq = 43;</code>
     *
     * <pre>
     * 退会 
     * </pre>
     */
    emNvScanCodeQuitReq(43, 43),
    /**
     * <code>emNvScanCodeState = 44;</code>
     *
     * <pre>
     * 状态 
     * </pre>
     */
    emNvScanCodeState(44, 44),
    /**
     * <code>emNvScanCodeHotLeft = 45;</code>
     *
     * <pre>
     * 快捷键1 
     * </pre>
     */
    emNvScanCodeHotLeft(45, 45),
    /**
     * <code>emNvScanCodeHotCenter = 46;</code>
     *
     * <pre>
     * 快捷键2 
     * </pre>
     */
    emNvScanCodeHotCenter(46, 46),
    /**
     * <code>emNvScanCodeHotRight = 47;</code>
     *
     * <pre>
     * 快捷键3 
     * </pre>
     */
    emNvScanCodeHotRight(47, 47),
    /**
     * <code>emNvScanCodeHelp = 48;</code>
     *
     * <pre>
     * 帮助 
     * </pre>
     */
    emNvScanCodeHelp(48, 48),
    /**
     * <code>emNvScanCodeBrightUp = 49;</code>
     *
     * <pre>
     * 亮度+
     * </pre>
     */
    emNvScanCodeBrightUp(49, 49),
    /**
     * <code>emNvScanCodeBrightDown = 50;</code>
     *
     * <pre>
     * 亮度-
     * </pre>
     */
    emNvScanCodeBrightDown(50, 50),
    /**
     * <code>emNvScanCodeDual = 51;</code>
     *
     * <pre>
     * 双流
     * </pre>
     */
    emNvScanCodeDual(51, 51),
    /**
     * <code>emNvScanCodeReturn = 52;</code>
     *
     * <pre>
     * 返回
     * </pre>
     */
    emNvScanCodeReturn(52, 52),
    /**
     * <code>emNvScanCodeFunc = 53;</code>
     *
     * <pre>
     * 功能
     * </pre>
     */
    emNvScanCodeFunc(53, 53),
    /**
     * <code>emNvScanCodeSearch = 54;</code>
     *
     * <pre>
     * 搜索
     * </pre>
     */
    emNvScanCodeSearch(54, 54),
    /**
     * <code>emNvScanCodeNull = 98;</code>
     *
     * <pre>
     * 无键值
     * </pre>
     */
    emNvScanCodeNull(55, 98),
    /**
     * <code>emNvScanCodeInvalid = 99;</code>
     *
     * <pre>
     * 无效键值
     * </pre>
     */
    emNvScanCodeInvalid(56, 99),
    ;

    /**
     * <code>emNvScanCode0 = 0;</code>
     *
     * <pre>
     * 0 
     * </pre>
     */
    public static final int emNvScanCode0_VALUE = 0;
    /**
     * <code>emNvScanCode1 = 1;</code>
     *
     * <pre>
     * 1 
     * </pre>
     */
    public static final int emNvScanCode1_VALUE = 1;
    /**
     * <code>emNvScanCode2 = 2;</code>
     *
     * <pre>
     * 2 
     * </pre>
     */
    public static final int emNvScanCode2_VALUE = 2;
    /**
     * <code>emNvScanCode3 = 3;</code>
     *
     * <pre>
     * 3 
     * </pre>
     */
    public static final int emNvScanCode3_VALUE = 3;
    /**
     * <code>emNvScanCode4 = 4;</code>
     *
     * <pre>
     * 4 
     * </pre>
     */
    public static final int emNvScanCode4_VALUE = 4;
    /**
     * <code>emNvScanCode5 = 5;</code>
     *
     * <pre>
     * 5 
     * </pre>
     */
    public static final int emNvScanCode5_VALUE = 5;
    /**
     * <code>emNvScanCode6 = 6;</code>
     *
     * <pre>
     * 6 
     * </pre>
     */
    public static final int emNvScanCode6_VALUE = 6;
    /**
     * <code>emNvScanCode7 = 7;</code>
     *
     * <pre>
     * 7 
     * </pre>
     */
    public static final int emNvScanCode7_VALUE = 7;
    /**
     * <code>emNvScanCode8 = 8;</code>
     *
     * <pre>
     * 8 
     * </pre>
     */
    public static final int emNvScanCode8_VALUE = 8;
    /**
     * <code>emNvScanCode9 = 9;</code>
     *
     * <pre>
     * 9   
     * </pre>
     */
    public static final int emNvScanCode9_VALUE = 9;
    /**
     * <code>emNvScanCodePoint = 10;</code>
     *
     * <pre>
     * . 
     * </pre>
     */
    public static final int emNvScanCodePoint_VALUE = 10;
    /**
     * <code>emNvScanCodeSharp = 11;</code>
     *
     * <pre>
     * #   
     * </pre>
     */
    public static final int emNvScanCodeSharp_VALUE = 11;
    /**
     * <code>emNvScanCodeMenu = 12;</code>
     *
     * <pre>
     * 菜单 
     * </pre>
     */
    public static final int emNvScanCodeMenu_VALUE = 12;
    /**
     * <code>emNvScanCodeBackspace = 13;</code>
     *
     * <pre>
     * 删除 
     * </pre>
     */
    public static final int emNvScanCodeBackspace_VALUE = 13;
    /**
     * <code>emNvScanCodeEnter = 14;</code>
     *
     * <pre>
     * 确定 
     * </pre>
     */
    public static final int emNvScanCodeEnter_VALUE = 14;
    /**
     * <code>emNvScanCodeUp = 15;</code>
     *
     * <pre>
     * 上 
     * </pre>
     */
    public static final int emNvScanCodeUp_VALUE = 15;
    /**
     * <code>emNvScanCodeDown = 16;</code>
     *
     * <pre>
     * 下 
     * </pre>
     */
    public static final int emNvScanCodeDown_VALUE = 16;
    /**
     * <code>emNvScanCodeLeft = 17;</code>
     *
     * <pre>
     * 左 
     * </pre>
     */
    public static final int emNvScanCodeLeft_VALUE = 17;
    /**
     * <code>emNvScanCodeRight = 18;</code>
     *
     * <pre>
     * 右 
     * </pre>
     */
    public static final int emNvScanCodeRight_VALUE = 18;
    /**
     * <code>emNvScanCodePower = 19;</code>
     *
     * <pre>
     * 电源 
     * </pre>
     */
    public static final int emNvScanCodePower_VALUE = 19;
    /**
     * <code>emNvScanCodeMainVSrc = 20;</code>
     *
     * <pre>
     * 主视频源 
     * </pre>
     */
    public static final int emNvScanCodeMainVSrc_VALUE = 20;
    /**
     * <code>emNvScanCodeAV = 21;</code>
     *
     * <pre>
     * AV
     * </pre>
     */
    public static final int emNvScanCodeAV_VALUE = 21;
    /**
     * <code>emNvScanCodeFarCtrl = 22;</code>
     *
     * <pre>
     * 远遥
     * </pre>
     */
    public static final int emNvScanCodeFarCtrl_VALUE = 22;
    /**
     * <code>emNvScanCodeMute = 23;</code>
     *
     * <pre>
     * 哑音
     * </pre>
     */
    public static final int emNvScanCodeMute_VALUE = 23;
    /**
     * <code>emNvScanCodeQuiet = 24;</code>
     *
     * <pre>
     * 静音
     * </pre>
     */
    public static final int emNvScanCodeQuiet_VALUE = 24;
    /**
     * <code>emNvScanCodeVGA = 25;</code>
     *
     * <pre>
     * VGA
     * </pre>
     */
    public static final int emNvScanCodeVGA_VALUE = 25;
    /**
     * <code>emNvScanCodeS = 26;</code>
     *
     * <pre>
     * S端子
     * </pre>
     */
    public static final int emNvScanCodeS_VALUE = 26;
    /**
     * <code>emNvScanCodeShotSnap = 27;</code>
     *
     * <pre>
     * 快照
     * </pre>
     */
    public static final int emNvScanCodeShotSnap_VALUE = 27;
    /**
     * <code>emNvScanCodeVolumeUp = 28;</code>
     *
     * <pre>
     * 音量+
     * </pre>
     */
    public static final int emNvScanCodeVolumeUp_VALUE = 28;
    /**
     * <code>emNvScanCodeVolumeDown = 29;</code>
     *
     * <pre>
     * 音量-
     * </pre>
     */
    public static final int emNvScanCodeVolumeDown_VALUE = 29;
    /**
     * <code>emNvScanCodeConnect = 30;</code>
     *
     * <pre>
     * 拨号 
     * </pre>
     */
    public static final int emNvScanCodeConnect_VALUE = 30;
    /**
     * <code>emNvScanCodeDisconnect = 31;</code>
     *
     * <pre>
     * 挂断 
     * </pre>
     */
    public static final int emNvScanCodeDisconnect_VALUE = 31;
    /**
     * <code>emNvScanCodeDirectory = 32;</code>
     *
     * <pre>
     * 地址簿 
     * </pre>
     */
    public static final int emNvScanCodeDirectory_VALUE = 32;
    /**
     * <code>emNvScanCodePipEnable = 33;</code>
     *
     * <pre>
     * 画中画 
     * </pre>
     */
    public static final int emNvScanCodePipEnable_VALUE = 33;
    /**
     * <code>emNvScanCodePipAdjust = 34;</code>
     *
     * <pre>
     * 画中画缩放 
     * </pre>
     */
    public static final int emNvScanCodePipAdjust_VALUE = 34;
    /**
     * <code>emNvScanCodeSelfTest = 35;</code>
     *
     * <pre>
     * 自检 
     * </pre>
     */
    public static final int emNvScanCodeSelfTest_VALUE = 35;
    /**
     * <code>emNvScanCodeAutoFocus = 36;</code>
     *
     * <pre>
     * 自动调焦 
     * </pre>
     */
    public static final int emNvScanCodeAutoFocus_VALUE = 36;
    /**
     * <code>emNvScanCodeNearZoom = 37;</code>
     *
     * <pre>
     * 近视 
     * </pre>
     */
    public static final int emNvScanCodeNearZoom_VALUE = 37;
    /**
     * <code>emNvScanCodeFarZoom = 38;</code>
     *
     * <pre>
     * 远视 
     * </pre>
     */
    public static final int emNvScanCodeFarZoom_VALUE = 38;
    /**
     * <code>emNvScanCodePreSave = 39;</code>
     *
     * <pre>
     * 保存预置位 
     * </pre>
     */
    public static final int emNvScanCodePreSave_VALUE = 39;
    /**
     * <code>emNvScanCodePreMove = 40;</code>
     *
     * <pre>
     * 加载预置位 
     * </pre>
     */
    public static final int emNvScanCodePreMove_VALUE = 40;
    /**
     * <code>emNvScanCodeChairReq = 41;</code>
     *
     * <pre>
     * 申请主席 
     * </pre>
     */
    public static final int emNvScanCodeChairReq_VALUE = 41;
    /**
     * <code>emNvScanCodeSpeakReq = 42;</code>
     *
     * <pre>
     * 申请发言 
     * </pre>
     */
    public static final int emNvScanCodeSpeakReq_VALUE = 42;
    /**
     * <code>emNvScanCodeQuitReq = 43;</code>
     *
     * <pre>
     * 退会 
     * </pre>
     */
    public static final int emNvScanCodeQuitReq_VALUE = 43;
    /**
     * <code>emNvScanCodeState = 44;</code>
     *
     * <pre>
     * 状态 
     * </pre>
     */
    public static final int emNvScanCodeState_VALUE = 44;
    /**
     * <code>emNvScanCodeHotLeft = 45;</code>
     *
     * <pre>
     * 快捷键1 
     * </pre>
     */
    public static final int emNvScanCodeHotLeft_VALUE = 45;
    /**
     * <code>emNvScanCodeHotCenter = 46;</code>
     *
     * <pre>
     * 快捷键2 
     * </pre>
     */
    public static final int emNvScanCodeHotCenter_VALUE = 46;
    /**
     * <code>emNvScanCodeHotRight = 47;</code>
     *
     * <pre>
     * 快捷键3 
     * </pre>
     */
    public static final int emNvScanCodeHotRight_VALUE = 47;
    /**
     * <code>emNvScanCodeHelp = 48;</code>
     *
     * <pre>
     * 帮助 
     * </pre>
     */
    public static final int emNvScanCodeHelp_VALUE = 48;
    /**
     * <code>emNvScanCodeBrightUp = 49;</code>
     *
     * <pre>
     * 亮度+
     * </pre>
     */
    public static final int emNvScanCodeBrightUp_VALUE = 49;
    /**
     * <code>emNvScanCodeBrightDown = 50;</code>
     *
     * <pre>
     * 亮度-
     * </pre>
     */
    public static final int emNvScanCodeBrightDown_VALUE = 50;
    /**
     * <code>emNvScanCodeDual = 51;</code>
     *
     * <pre>
     * 双流
     * </pre>
     */
    public static final int emNvScanCodeDual_VALUE = 51;
    /**
     * <code>emNvScanCodeReturn = 52;</code>
     *
     * <pre>
     * 返回
     * </pre>
     */
    public static final int emNvScanCodeReturn_VALUE = 52;
    /**
     * <code>emNvScanCodeFunc = 53;</code>
     *
     * <pre>
     * 功能
     * </pre>
     */
    public static final int emNvScanCodeFunc_VALUE = 53;
    /**
     * <code>emNvScanCodeSearch = 54;</code>
     *
     * <pre>
     * 搜索
     * </pre>
     */
    public static final int emNvScanCodeSearch_VALUE = 54;
    /**
     * <code>emNvScanCodeNull = 98;</code>
     *
     * <pre>
     * 无键值
     * </pre>
     */
    public static final int emNvScanCodeNull_VALUE = 98;
    /**
     * <code>emNvScanCodeInvalid = 99;</code>
     *
     * <pre>
     * 无效键值
     * </pre>
     */
    public static final int emNvScanCodeInvalid_VALUE = 99;


    public final int getNumber() { return value; }

    public static EmNvRemoteScanCode valueOf(int value) {
      switch (value) {
        case 0: return emNvScanCode0;
        case 1: return emNvScanCode1;
        case 2: return emNvScanCode2;
        case 3: return emNvScanCode3;
        case 4: return emNvScanCode4;
        case 5: return emNvScanCode5;
        case 6: return emNvScanCode6;
        case 7: return emNvScanCode7;
        case 8: return emNvScanCode8;
        case 9: return emNvScanCode9;
        case 10: return emNvScanCodePoint;
        case 11: return emNvScanCodeSharp;
        case 12: return emNvScanCodeMenu;
        case 13: return emNvScanCodeBackspace;
        case 14: return emNvScanCodeEnter;
        case 15: return emNvScanCodeUp;
        case 16: return emNvScanCodeDown;
        case 17: return emNvScanCodeLeft;
        case 18: return emNvScanCodeRight;
        case 19: return emNvScanCodePower;
        case 20: return emNvScanCodeMainVSrc;
        case 21: return emNvScanCodeAV;
        case 22: return emNvScanCodeFarCtrl;
        case 23: return emNvScanCodeMute;
        case 24: return emNvScanCodeQuiet;
        case 25: return emNvScanCodeVGA;
        case 26: return emNvScanCodeS;
        case 27: return emNvScanCodeShotSnap;
        case 28: return emNvScanCodeVolumeUp;
        case 29: return emNvScanCodeVolumeDown;
        case 30: return emNvScanCodeConnect;
        case 31: return emNvScanCodeDisconnect;
        case 32: return emNvScanCodeDirectory;
        case 33: return emNvScanCodePipEnable;
        case 34: return emNvScanCodePipAdjust;
        case 35: return emNvScanCodeSelfTest;
        case 36: return emNvScanCodeAutoFocus;
        case 37: return emNvScanCodeNearZoom;
        case 38: return emNvScanCodeFarZoom;
        case 39: return emNvScanCodePreSave;
        case 40: return emNvScanCodePreMove;
        case 41: return emNvScanCodeChairReq;
        case 42: return emNvScanCodeSpeakReq;
        case 43: return emNvScanCodeQuitReq;
        case 44: return emNvScanCodeState;
        case 45: return emNvScanCodeHotLeft;
        case 46: return emNvScanCodeHotCenter;
        case 47: return emNvScanCodeHotRight;
        case 48: return emNvScanCodeHelp;
        case 49: return emNvScanCodeBrightUp;
        case 50: return emNvScanCodeBrightDown;
        case 51: return emNvScanCodeDual;
        case 52: return emNvScanCodeReturn;
        case 53: return emNvScanCodeFunc;
        case 54: return emNvScanCodeSearch;
        case 98: return emNvScanCodeNull;
        case 99: return emNvScanCodeInvalid;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvRemoteScanCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvRemoteScanCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvRemoteScanCode>() {
            public EmNvRemoteScanCode findValueByNumber(int number) {
              return EmNvRemoteScanCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(25);
    }

    private static final EmNvRemoteScanCode[] VALUES = values();

    public static EmNvRemoteScanCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvRemoteScanCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvRemoteScanCode)
  }

  /**
   * Protobuf enum {@code nv.EmNvStopBits}
   *
   * <pre>
   *串口停止位
   * </pre>
   */
  public enum EmNvStopBits
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNv1StopBit = 0;</code>
     */
    emNv1StopBit(0, 0),
    /**
     * <code>emNv1HalfStopBit = 1;</code>
     */
    emNv1HalfStopBit(1, 1),
    /**
     * <code>emNv2StopBit = 2;</code>
     */
    emNv2StopBit(2, 2),
    ;

    /**
     * <code>emNv1StopBit = 0;</code>
     */
    public static final int emNv1StopBit_VALUE = 0;
    /**
     * <code>emNv1HalfStopBit = 1;</code>
     */
    public static final int emNv1HalfStopBit_VALUE = 1;
    /**
     * <code>emNv2StopBit = 2;</code>
     */
    public static final int emNv2StopBit_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvStopBits valueOf(int value) {
      switch (value) {
        case 0: return emNv1StopBit;
        case 1: return emNv1HalfStopBit;
        case 2: return emNv2StopBit;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvStopBits>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvStopBits>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvStopBits>() {
            public EmNvStopBits findValueByNumber(int number) {
              return EmNvStopBits.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(26);
    }

    private static final EmNvStopBits[] VALUES = values();

    public static EmNvStopBits valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvStopBits(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvStopBits)
  }

  /**
   * Protobuf enum {@code nv.EmNvParityCheck}
   *
   * <pre>
   *串口校验位
   * </pre>
   */
  public enum EmNvParityCheck
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvNoCheck = 0;</code>
     */
    emNvNoCheck(0, 0),
    /**
     * <code>emNvOddCheck = 1;</code>
     */
    emNvOddCheck(1, 1),
    /**
     * <code>emNvEvenCheck = 2;</code>
     */
    emNvEvenCheck(2, 2),
    ;

    /**
     * <code>emNvNoCheck = 0;</code>
     */
    public static final int emNvNoCheck_VALUE = 0;
    /**
     * <code>emNvOddCheck = 1;</code>
     */
    public static final int emNvOddCheck_VALUE = 1;
    /**
     * <code>emNvEvenCheck = 2;</code>
     */
    public static final int emNvEvenCheck_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvParityCheck valueOf(int value) {
      switch (value) {
        case 0: return emNvNoCheck;
        case 1: return emNvOddCheck;
        case 2: return emNvEvenCheck;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvParityCheck>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvParityCheck>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvParityCheck>() {
            public EmNvParityCheck findValueByNumber(int number) {
              return EmNvParityCheck.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(27);
    }

    private static final EmNvParityCheck[] VALUES = values();

    public static EmNvParityCheck valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvParityCheck(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvParityCheck)
  }

  /**
   * Protobuf enum {@code nv.EmNvSerialType}
   *
   * <pre>
   *串口类型
   * </pre>
   */
  public enum EmNvSerialType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvRS232_0 = 0;</code>
     *
     * <pre>
     *     0接 iface
     * </pre>
     */
    emNvRS232_0(0, 0),
    /**
     * <code>emNvRS232_1 = 1;</code>
     *
     * <pre>
     *     1接 ops控制
     * </pre>
     */
    emNvRS232_1(1, 1),
    /**
     * <code>emNvRS232_2 = 2;</code>
     *
     * <pre>
     * 	2接 17LD板子
     * </pre>
     */
    emNvRS232_2(2, 2),
    /**
     * <code>emNvRS232_3 = 3;</code>
     *
     * <pre>
     * 	3接 232调试辅助串口
     * </pre>
     */
    emNvRS232_3(3, 3),
    /**
     * <code>emNvRS232_4 = 4;</code>
     *
     * <pre>
     * 	4接 控制电视机的串口
     * </pre>
     */
    emNvRS232_4(4, 4),
    /**
     * <code>emNvRS232_5 = 5;</code>
     *
     * <pre>
     * 	5接 LED板
     * </pre>
     */
    emNvRS232_5(5, 5),
    /**
     * <code>emNvRS232_6 = 6;</code>
     *
     * <pre>
     * 	6接 SWITCH
     * </pre>
     */
    emNvRS232_6(6, 6),
    /**
     * <code>emNvRS232_7 = 7;</code>
     *
     * <pre>
     * 	7接 COM
     * </pre>
     */
    emNvRS232_7(7, 7),
    ;

    /**
     * <code>emNvRS232_0 = 0;</code>
     *
     * <pre>
     *     0接 iface
     * </pre>
     */
    public static final int emNvRS232_0_VALUE = 0;
    /**
     * <code>emNvRS232_1 = 1;</code>
     *
     * <pre>
     *     1接 ops控制
     * </pre>
     */
    public static final int emNvRS232_1_VALUE = 1;
    /**
     * <code>emNvRS232_2 = 2;</code>
     *
     * <pre>
     * 	2接 17LD板子
     * </pre>
     */
    public static final int emNvRS232_2_VALUE = 2;
    /**
     * <code>emNvRS232_3 = 3;</code>
     *
     * <pre>
     * 	3接 232调试辅助串口
     * </pre>
     */
    public static final int emNvRS232_3_VALUE = 3;
    /**
     * <code>emNvRS232_4 = 4;</code>
     *
     * <pre>
     * 	4接 控制电视机的串口
     * </pre>
     */
    public static final int emNvRS232_4_VALUE = 4;
    /**
     * <code>emNvRS232_5 = 5;</code>
     *
     * <pre>
     * 	5接 LED板
     * </pre>
     */
    public static final int emNvRS232_5_VALUE = 5;
    /**
     * <code>emNvRS232_6 = 6;</code>
     *
     * <pre>
     * 	6接 SWITCH
     * </pre>
     */
    public static final int emNvRS232_6_VALUE = 6;
    /**
     * <code>emNvRS232_7 = 7;</code>
     *
     * <pre>
     * 	7接 COM
     * </pre>
     */
    public static final int emNvRS232_7_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmNvSerialType valueOf(int value) {
      switch (value) {
        case 0: return emNvRS232_0;
        case 1: return emNvRS232_1;
        case 2: return emNvRS232_2;
        case 3: return emNvRS232_3;
        case 4: return emNvRS232_4;
        case 5: return emNvRS232_5;
        case 6: return emNvRS232_6;
        case 7: return emNvRS232_7;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvSerialType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvSerialType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvSerialType>() {
            public EmNvSerialType findValueByNumber(int number) {
              return EmNvSerialType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(28);
    }

    private static final EmNvSerialType[] VALUES = values();

    public static EmNvSerialType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvSerialType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvSerialType)
  }

  /**
   * Protobuf enum {@code nv.EmNvAlarmCode}
   *
   * <pre>
   *告警码
   * </pre>
   */
  public enum EmNvAlarmCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvAlarmFileSysErr = 1010;</code>
     *
     * <pre>
     *文件系统出错
     * </pre>
     */
    emNvAlarmFileSysErr(0, 1010),
    /**
     * <code>emNvAlarmSysBusy = 1011;</code>
     *
     * <pre>
     *系统任务忙
     * </pre>
     */
    emNvAlarmSysBusy(1, 1011),
    /**
     * <code>emNvAlarmFanErr = 1016;</code>
     *
     * <pre>
     *设备风扇异常
     * </pre>
     */
    emNvAlarmFanErr(2, 1016),
    /**
     * <code>emNvAlarmTempHigh = 1017;</code>
     *
     * <pre>
     *设备温度过高
     * </pre>
     */
    emNvAlarmTempHigh(3, 1017),
    /**
     * <code>emNvAlarmVoltageHigh = 1018;</code>
     *
     * <pre>
     *设备电压过高
     * </pre>
     */
    emNvAlarmVoltageHigh(4, 1018),
    ;

    /**
     * <code>emNvAlarmFileSysErr = 1010;</code>
     *
     * <pre>
     *文件系统出错
     * </pre>
     */
    public static final int emNvAlarmFileSysErr_VALUE = 1010;
    /**
     * <code>emNvAlarmSysBusy = 1011;</code>
     *
     * <pre>
     *系统任务忙
     * </pre>
     */
    public static final int emNvAlarmSysBusy_VALUE = 1011;
    /**
     * <code>emNvAlarmFanErr = 1016;</code>
     *
     * <pre>
     *设备风扇异常
     * </pre>
     */
    public static final int emNvAlarmFanErr_VALUE = 1016;
    /**
     * <code>emNvAlarmTempHigh = 1017;</code>
     *
     * <pre>
     *设备温度过高
     * </pre>
     */
    public static final int emNvAlarmTempHigh_VALUE = 1017;
    /**
     * <code>emNvAlarmVoltageHigh = 1018;</code>
     *
     * <pre>
     *设备电压过高
     * </pre>
     */
    public static final int emNvAlarmVoltageHigh_VALUE = 1018;


    public final int getNumber() { return value; }

    public static EmNvAlarmCode valueOf(int value) {
      switch (value) {
        case 1010: return emNvAlarmFileSysErr;
        case 1011: return emNvAlarmSysBusy;
        case 1016: return emNvAlarmFanErr;
        case 1017: return emNvAlarmTempHigh;
        case 1018: return emNvAlarmVoltageHigh;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvAlarmCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvAlarmCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvAlarmCode>() {
            public EmNvAlarmCode findValueByNumber(int number) {
              return EmNvAlarmCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(29);
    }

    private static final EmNvAlarmCode[] VALUES = values();

    public static EmNvAlarmCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvAlarmCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvAlarmCode)
  }

  /**
   * Protobuf enum {@code nv.EmNvEthInterfaceMode}
   *
   * <pre>
   ** 以太网多网口模式 
   * </pre>
   */
  public enum EmNvEthInterfaceMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvEthInterfaceModeBackup = 0;</code>
     *
     * <pre>
     *备份
     * </pre>
     */
    emNvEthInterfaceModeBackup(0, 0),
    /**
     * <code>emNvEthInterfaceModeMulti = 1;</code>
     *
     * <pre>
     *多网口
     * </pre>
     */
    emNvEthInterfaceModeMulti(1, 1),
    ;

    /**
     * <code>emNvEthInterfaceModeBackup = 0;</code>
     *
     * <pre>
     *备份
     * </pre>
     */
    public static final int emNvEthInterfaceModeBackup_VALUE = 0;
    /**
     * <code>emNvEthInterfaceModeMulti = 1;</code>
     *
     * <pre>
     *多网口
     * </pre>
     */
    public static final int emNvEthInterfaceModeMulti_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmNvEthInterfaceMode valueOf(int value) {
      switch (value) {
        case 0: return emNvEthInterfaceModeBackup;
        case 1: return emNvEthInterfaceModeMulti;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvEthInterfaceMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvEthInterfaceMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvEthInterfaceMode>() {
            public EmNvEthInterfaceMode findValueByNumber(int number) {
              return EmNvEthInterfaceMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(30);
    }

    private static final EmNvEthInterfaceMode[] VALUES = values();

    public static EmNvEthInterfaceMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvEthInterfaceMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvEthInterfaceMode)
  }

  /**
   * Protobuf enum {@code nv.EmNvSystemFileType}
   */
  public enum EmNvSystemFileType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvFileNormal = 0;</code>
     *
     * <pre>
     *普通文件
     * </pre>
     */
    emNvFileNormal(0, 0),
    /**
     * <code>emNvFileDirectory = 1;</code>
     *
     * <pre>
     *目录文件
     * </pre>
     */
    emNvFileDirectory(1, 1),
    /**
     * <code>emNvFileLink = 2;</code>
     *
     * <pre>
     *链接文件
     * </pre>
     */
    emNvFileLink(2, 2),
    /**
     * <code>emNvFilePipe = 3;</code>
     *
     * <pre>
     *管道
     * </pre>
     */
    emNvFilePipe(3, 3),
    ;

    /**
     * <code>emNvFileNormal = 0;</code>
     *
     * <pre>
     *普通文件
     * </pre>
     */
    public static final int emNvFileNormal_VALUE = 0;
    /**
     * <code>emNvFileDirectory = 1;</code>
     *
     * <pre>
     *目录文件
     * </pre>
     */
    public static final int emNvFileDirectory_VALUE = 1;
    /**
     * <code>emNvFileLink = 2;</code>
     *
     * <pre>
     *链接文件
     * </pre>
     */
    public static final int emNvFileLink_VALUE = 2;
    /**
     * <code>emNvFilePipe = 3;</code>
     *
     * <pre>
     *管道
     * </pre>
     */
    public static final int emNvFilePipe_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNvSystemFileType valueOf(int value) {
      switch (value) {
        case 0: return emNvFileNormal;
        case 1: return emNvFileDirectory;
        case 2: return emNvFileLink;
        case 3: return emNvFilePipe;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvSystemFileType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvSystemFileType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvSystemFileType>() {
            public EmNvSystemFileType findValueByNumber(int number) {
              return EmNvSystemFileType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(31);
    }

    private static final EmNvSystemFileType[] VALUES = values();

    public static EmNvSystemFileType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvSystemFileType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvSystemFileType)
  }

  /**
   * Protobuf enum {@code nv.EmNvFileCopyErr}
   *
   * <pre>
   *文件拷贝错误码
   * </pre>
   */
  public enum EmNvFileCopyErr
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvCopySuccess = 0;</code>
     *
     * <pre>
     *成功
     * </pre>
     */
    emNvCopySuccess(0, 0),
    /**
     * <code>emNvCopyUnknownErr = 1;</code>
     *
     * <pre>
     *未知错误
     * </pre>
     */
    emNvCopyUnknownErr(1, 1),
    /**
     * <code>emNvCopyNoSpace = 2;</code>
     *
     * <pre>
     *空间不足
     * </pre>
     */
    emNvCopyNoSpace(2, 2),
    /**
     * <code>emNvCopySrcFileNotFound = 3;</code>
     *
     * <pre>
     *源文件不存在
     * </pre>
     */
    emNvCopySrcFileNotFound(3, 3),
    /**
     * <code>emNvCopyDstPathNotFound = 4;</code>
     *
     * <pre>
     *目标路径不存在
     * </pre>
     */
    emNvCopyDstPathNotFound(4, 4),
    /**
     * <code>emNvCopyStop = 5;</code>
     *
     * <pre>
     *停止拷贝
     * </pre>
     */
    emNvCopyStop(5, 5),
    ;

    /**
     * <code>emNvCopySuccess = 0;</code>
     *
     * <pre>
     *成功
     * </pre>
     */
    public static final int emNvCopySuccess_VALUE = 0;
    /**
     * <code>emNvCopyUnknownErr = 1;</code>
     *
     * <pre>
     *未知错误
     * </pre>
     */
    public static final int emNvCopyUnknownErr_VALUE = 1;
    /**
     * <code>emNvCopyNoSpace = 2;</code>
     *
     * <pre>
     *空间不足
     * </pre>
     */
    public static final int emNvCopyNoSpace_VALUE = 2;
    /**
     * <code>emNvCopySrcFileNotFound = 3;</code>
     *
     * <pre>
     *源文件不存在
     * </pre>
     */
    public static final int emNvCopySrcFileNotFound_VALUE = 3;
    /**
     * <code>emNvCopyDstPathNotFound = 4;</code>
     *
     * <pre>
     *目标路径不存在
     * </pre>
     */
    public static final int emNvCopyDstPathNotFound_VALUE = 4;
    /**
     * <code>emNvCopyStop = 5;</code>
     *
     * <pre>
     *停止拷贝
     * </pre>
     */
    public static final int emNvCopyStop_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmNvFileCopyErr valueOf(int value) {
      switch (value) {
        case 0: return emNvCopySuccess;
        case 1: return emNvCopyUnknownErr;
        case 2: return emNvCopyNoSpace;
        case 3: return emNvCopySrcFileNotFound;
        case 4: return emNvCopyDstPathNotFound;
        case 5: return emNvCopyStop;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvFileCopyErr>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvFileCopyErr>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvFileCopyErr>() {
            public EmNvFileCopyErr findValueByNumber(int number) {
              return EmNvFileCopyErr.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(32);
    }

    private static final EmNvFileCopyErr[] VALUES = values();

    public static EmNvFileCopyErr valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvFileCopyErr(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvFileCopyErr)
  }

  /**
   * Protobuf enum {@code nv.EmNvDisplayRatio}
   */
  public enum EmNvDisplayRatio
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvDR4to3 = 0;</code>
     */
    emNvDR4to3(0, 0),
    /**
     * <code>emNvDR16to9 = 1;</code>
     */
    emNvDR16to9(1, 1),
    /**
     * <code>emNvDRAuto = 2;</code>
     */
    emNvDRAuto(2, 2),
    ;

    /**
     * <code>emNvDR4to3 = 0;</code>
     */
    public static final int emNvDR4to3_VALUE = 0;
    /**
     * <code>emNvDR16to9 = 1;</code>
     */
    public static final int emNvDR16to9_VALUE = 1;
    /**
     * <code>emNvDRAuto = 2;</code>
     */
    public static final int emNvDRAuto_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvDisplayRatio valueOf(int value) {
      switch (value) {
        case 0: return emNvDR4to3;
        case 1: return emNvDR16to9;
        case 2: return emNvDRAuto;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvDisplayRatio>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvDisplayRatio>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvDisplayRatio>() {
            public EmNvDisplayRatio findValueByNumber(int number) {
              return EmNvDisplayRatio.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(33);
    }

    private static final EmNvDisplayRatio[] VALUES = values();

    public static EmNvDisplayRatio valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvDisplayRatio(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvDisplayRatio)
  }

  /**
   * Protobuf enum {@code nv.EmNvCallState}
   */
  public enum EmNvCallState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvCallIdle = 0;</code>
     */
    emNvCallIdle(0, 0),
    /**
     * <code>emNvCallIng = 1;</code>
     */
    emNvCallIng(1, 1),
    /**
     * <code>emNvCallConnected = 2;</code>
     */
    emNvCallConnected(2, 2),
    ;

    /**
     * <code>emNvCallIdle = 0;</code>
     */
    public static final int emNvCallIdle_VALUE = 0;
    /**
     * <code>emNvCallIng = 1;</code>
     */
    public static final int emNvCallIng_VALUE = 1;
    /**
     * <code>emNvCallConnected = 2;</code>
     */
    public static final int emNvCallConnected_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvCallState valueOf(int value) {
      switch (value) {
        case 0: return emNvCallIdle;
        case 1: return emNvCallIng;
        case 2: return emNvCallConnected;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvCallState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvCallState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvCallState>() {
            public EmNvCallState findValueByNumber(int number) {
              return EmNvCallState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(34);
    }

    private static final EmNvCallState[] VALUES = values();

    public static EmNvCallState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvCallState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvCallState)
  }

  /**
   * Protobuf enum {@code nv.EmNvVideoOutPutMode}
   *
   * <pre>
   *视频输出制式
   * </pre>
   */
  public enum EmNvVideoOutPutMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvVOM_HD_ORIGIN = 0;</code>
     *
     * <pre>
     *原始比例播放
     * </pre>
     */
    emNvVOM_HD_ORIGIN(0, 0),
    /**
     * <code>emNvVOM_HD_720P50 = 1;</code>
     *
     * <pre>
     *固定按 720p50输出
     * </pre>
     */
    emNvVOM_HD_720P50(1, 1),
    /**
     * <code>emNvVOM_HD_720P60 = 2;</code>
     *
     * <pre>
     *固定按 720p60输出
     * </pre>
     */
    emNvVOM_HD_720P60(2, 2),
    /**
     * <code>emNvVOM_HD_1080P24 = 3;</code>
     *
     * <pre>
     *固定按1080p24输出
     * </pre>
     */
    emNvVOM_HD_1080P24(3, 3),
    /**
     * <code>emNvVOM_HD_1080P25 = 4;</code>
     *
     * <pre>
     *固定按1080p25输出
     * </pre>
     */
    emNvVOM_HD_1080P25(4, 4),
    /**
     * <code>emNvVOM_HD_1080P30 = 5;</code>
     *
     * <pre>
     *固定按1080p30输出
     * </pre>
     */
    emNvVOM_HD_1080P30(5, 5),
    /**
     * <code>emNvVOM_HD_1080P50 = 6;</code>
     *
     * <pre>
     *固定按1080p50输出
     * </pre>
     */
    emNvVOM_HD_1080P50(6, 6),
    /**
     * <code>emNvVOM_HD_1080P60 = 7;</code>
     *
     * <pre>
     *固定按1080p60输出 
     * </pre>
     */
    emNvVOM_HD_1080P60(7, 7),
    /**
     * <code>emNvVOM_HD_XGA60 = 8;</code>
     *
     * <pre>
     *固定按XGA 60HZ输出 1024x768
     * </pre>
     */
    emNvVOM_HD_XGA60(8, 8),
    /**
     * <code>emNvVOM_HD_SXGA60 = 9;</code>
     *
     * <pre>
     *固定按SXGA 60HZ输出  1280x1024
     * </pre>
     */
    emNvVOM_HD_SXGA60(9, 9),
    /**
     * <code>emNvVOM_HD_WXGA1280x800_60 = 10;</code>
     *
     * <pre>
     *固定按WXGA 60HZ输出 1280x800
     * </pre>
     */
    emNvVOM_HD_WXGA1280x800_60(10, 10),
    /**
     * <code>emNvVOM_HD_WXGA1366x768_60 = 11;</code>
     *
     * <pre>
     *固定按WXGA 60HZ输出 1360x768
     * </pre>
     */
    emNvVOM_HD_WXGA1366x768_60(11, 11),
    /**
     * <code>emNvVOM_HD_WSXGA60 = 12;</code>
     *
     * <pre>
     *固定按WSXGA 60HZ输出 1440x900
     * </pre>
     */
    emNvVOM_HD_WSXGA60(12, 12),
    /**
     * <code>emNvVOM_HD_WSXGAPLUS60 = 13;</code>
     *
     * <pre>
     *固定按SXGA+ 60HZ输出 1680x1050
     * </pre>
     */
    emNvVOM_HD_WSXGAPLUS60(13, 13),
    /**
     * <code>emNvVOM_HD_2160P30 = 14;</code>
     *
     * <pre>
     *固定按2160P30输出 3860*2160
     * </pre>
     */
    emNvVOM_HD_2160P30(14, 14),
    /**
     * <code>emNvVOM_HD_2160P60 = 15;</code>
     *
     * <pre>
     *固定按2160P60输出 3860*2160  
     * </pre>
     */
    emNvVOM_HD_2160P60(15, 15),
    ;

    /**
     * <code>emNvVOM_HD_ORIGIN = 0;</code>
     *
     * <pre>
     *原始比例播放
     * </pre>
     */
    public static final int emNvVOM_HD_ORIGIN_VALUE = 0;
    /**
     * <code>emNvVOM_HD_720P50 = 1;</code>
     *
     * <pre>
     *固定按 720p50输出
     * </pre>
     */
    public static final int emNvVOM_HD_720P50_VALUE = 1;
    /**
     * <code>emNvVOM_HD_720P60 = 2;</code>
     *
     * <pre>
     *固定按 720p60输出
     * </pre>
     */
    public static final int emNvVOM_HD_720P60_VALUE = 2;
    /**
     * <code>emNvVOM_HD_1080P24 = 3;</code>
     *
     * <pre>
     *固定按1080p24输出
     * </pre>
     */
    public static final int emNvVOM_HD_1080P24_VALUE = 3;
    /**
     * <code>emNvVOM_HD_1080P25 = 4;</code>
     *
     * <pre>
     *固定按1080p25输出
     * </pre>
     */
    public static final int emNvVOM_HD_1080P25_VALUE = 4;
    /**
     * <code>emNvVOM_HD_1080P30 = 5;</code>
     *
     * <pre>
     *固定按1080p30输出
     * </pre>
     */
    public static final int emNvVOM_HD_1080P30_VALUE = 5;
    /**
     * <code>emNvVOM_HD_1080P50 = 6;</code>
     *
     * <pre>
     *固定按1080p50输出
     * </pre>
     */
    public static final int emNvVOM_HD_1080P50_VALUE = 6;
    /**
     * <code>emNvVOM_HD_1080P60 = 7;</code>
     *
     * <pre>
     *固定按1080p60输出 
     * </pre>
     */
    public static final int emNvVOM_HD_1080P60_VALUE = 7;
    /**
     * <code>emNvVOM_HD_XGA60 = 8;</code>
     *
     * <pre>
     *固定按XGA 60HZ输出 1024x768
     * </pre>
     */
    public static final int emNvVOM_HD_XGA60_VALUE = 8;
    /**
     * <code>emNvVOM_HD_SXGA60 = 9;</code>
     *
     * <pre>
     *固定按SXGA 60HZ输出  1280x1024
     * </pre>
     */
    public static final int emNvVOM_HD_SXGA60_VALUE = 9;
    /**
     * <code>emNvVOM_HD_WXGA1280x800_60 = 10;</code>
     *
     * <pre>
     *固定按WXGA 60HZ输出 1280x800
     * </pre>
     */
    public static final int emNvVOM_HD_WXGA1280x800_60_VALUE = 10;
    /**
     * <code>emNvVOM_HD_WXGA1366x768_60 = 11;</code>
     *
     * <pre>
     *固定按WXGA 60HZ输出 1360x768
     * </pre>
     */
    public static final int emNvVOM_HD_WXGA1366x768_60_VALUE = 11;
    /**
     * <code>emNvVOM_HD_WSXGA60 = 12;</code>
     *
     * <pre>
     *固定按WSXGA 60HZ输出 1440x900
     * </pre>
     */
    public static final int emNvVOM_HD_WSXGA60_VALUE = 12;
    /**
     * <code>emNvVOM_HD_WSXGAPLUS60 = 13;</code>
     *
     * <pre>
     *固定按SXGA+ 60HZ输出 1680x1050
     * </pre>
     */
    public static final int emNvVOM_HD_WSXGAPLUS60_VALUE = 13;
    /**
     * <code>emNvVOM_HD_2160P30 = 14;</code>
     *
     * <pre>
     *固定按2160P30输出 3860*2160
     * </pre>
     */
    public static final int emNvVOM_HD_2160P30_VALUE = 14;
    /**
     * <code>emNvVOM_HD_2160P60 = 15;</code>
     *
     * <pre>
     *固定按2160P60输出 3860*2160  
     * </pre>
     */
    public static final int emNvVOM_HD_2160P60_VALUE = 15;


    public final int getNumber() { return value; }

    public static EmNvVideoOutPutMode valueOf(int value) {
      switch (value) {
        case 0: return emNvVOM_HD_ORIGIN;
        case 1: return emNvVOM_HD_720P50;
        case 2: return emNvVOM_HD_720P60;
        case 3: return emNvVOM_HD_1080P24;
        case 4: return emNvVOM_HD_1080P25;
        case 5: return emNvVOM_HD_1080P30;
        case 6: return emNvVOM_HD_1080P50;
        case 7: return emNvVOM_HD_1080P60;
        case 8: return emNvVOM_HD_XGA60;
        case 9: return emNvVOM_HD_SXGA60;
        case 10: return emNvVOM_HD_WXGA1280x800_60;
        case 11: return emNvVOM_HD_WXGA1366x768_60;
        case 12: return emNvVOM_HD_WSXGA60;
        case 13: return emNvVOM_HD_WSXGAPLUS60;
        case 14: return emNvVOM_HD_2160P30;
        case 15: return emNvVOM_HD_2160P60;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoOutPutMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoOutPutMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvVideoOutPutMode>() {
            public EmNvVideoOutPutMode findValueByNumber(int number) {
              return EmNvVideoOutPutMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(35);
    }

    private static final EmNvVideoOutPutMode[] VALUES = values();

    public static EmNvVideoOutPutMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvVideoOutPutMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvVideoOutPutMode)
  }

  /**
   * Protobuf enum {@code nv.EmNvAacChnlNum}
   *
   * <pre>
   *aaclc、aacld的声道数
   * </pre>
   */
  public enum EmNvAacChnlNum
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvCnNumCust = 0;</code>
     */
    emNvCnNumCust(0, 0),
    /**
     * <code>emNvCnNum1 = 1;</code>
     */
    emNvCnNum1(1, 1),
    /**
     * <code>emNvCnNum2 = 2;</code>
     */
    emNvCnNum2(2, 2),
    /**
     * <code>emNvCnNum3 = 4;</code>
     */
    emNvCnNum3(3, 4),
    /**
     * <code>emNvCnNum4 = 8;</code>
     */
    emNvCnNum4(4, 8),
    /**
     * <code>emNvCnNum5 = 16;</code>
     */
    emNvCnNum5(5, 16),
    /**
     * <code>emNvCnNum5dot1 = 32;</code>
     */
    emNvCnNum5dot1(6, 32),
    /**
     * <code>emNvCnNum7dot1 = 64;</code>
     */
    emNvCnNum7dot1(7, 64),
    ;

    /**
     * <code>emNvCnNumCust = 0;</code>
     */
    public static final int emNvCnNumCust_VALUE = 0;
    /**
     * <code>emNvCnNum1 = 1;</code>
     */
    public static final int emNvCnNum1_VALUE = 1;
    /**
     * <code>emNvCnNum2 = 2;</code>
     */
    public static final int emNvCnNum2_VALUE = 2;
    /**
     * <code>emNvCnNum3 = 4;</code>
     */
    public static final int emNvCnNum3_VALUE = 4;
    /**
     * <code>emNvCnNum4 = 8;</code>
     */
    public static final int emNvCnNum4_VALUE = 8;
    /**
     * <code>emNvCnNum5 = 16;</code>
     */
    public static final int emNvCnNum5_VALUE = 16;
    /**
     * <code>emNvCnNum5dot1 = 32;</code>
     */
    public static final int emNvCnNum5dot1_VALUE = 32;
    /**
     * <code>emNvCnNum7dot1 = 64;</code>
     */
    public static final int emNvCnNum7dot1_VALUE = 64;


    public final int getNumber() { return value; }

    public static EmNvAacChnlNum valueOf(int value) {
      switch (value) {
        case 0: return emNvCnNumCust;
        case 1: return emNvCnNum1;
        case 2: return emNvCnNum2;
        case 4: return emNvCnNum3;
        case 8: return emNvCnNum4;
        case 16: return emNvCnNum5;
        case 32: return emNvCnNum5dot1;
        case 64: return emNvCnNum7dot1;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvAacChnlNum>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvAacChnlNum>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvAacChnlNum>() {
            public EmNvAacChnlNum findValueByNumber(int number) {
              return EmNvAacChnlNum.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(36);
    }

    private static final EmNvAacChnlNum[] VALUES = values();

    public static EmNvAacChnlNum valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvAacChnlNum(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvAacChnlNum)
  }

  /**
   * Protobuf enum {@code nv.EmNvAacSampFreq}
   *
   * <pre>
   *aaclc、aacld采样码率
   * </pre>
   */
  public enum EmNvAacSampFreq
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvASF96000 = 0;</code>
     */
    emNvASF96000(0, 0),
    /**
     * <code>emNvASF88200 = 1;</code>
     */
    emNvASF88200(1, 1),
    /**
     * <code>emNvASF64000 = 2;</code>
     */
    emNvASF64000(2, 2),
    /**
     * <code>emNvASF48000 = 3;</code>
     */
    emNvASF48000(3, 3),
    /**
     * <code>emNvASF44100 = 4;</code>
     */
    emNvASF44100(4, 4),
    /**
     * <code>emNvASF32000 = 5;</code>
     */
    emNvASF32000(5, 5),
    /**
     * <code>emNvASF24000 = 6;</code>
     */
    emNvASF24000(6, 6),
    /**
     * <code>emNvASF22050 = 7;</code>
     */
    emNvASF22050(7, 7),
    /**
     * <code>emNvASF16000 = 8;</code>
     */
    emNvASF16000(8, 8),
    /**
     * <code>emNvASF12000 = 9;</code>
     */
    emNvASF12000(9, 9),
    /**
     * <code>emNvASF11025 = 10;</code>
     */
    emNvASF11025(10, 10),
    /**
     * <code>emNvASF8000 = 11;</code>
     */
    emNvASF8000(11, 11),
    ;

    /**
     * <code>emNvASF96000 = 0;</code>
     */
    public static final int emNvASF96000_VALUE = 0;
    /**
     * <code>emNvASF88200 = 1;</code>
     */
    public static final int emNvASF88200_VALUE = 1;
    /**
     * <code>emNvASF64000 = 2;</code>
     */
    public static final int emNvASF64000_VALUE = 2;
    /**
     * <code>emNvASF48000 = 3;</code>
     */
    public static final int emNvASF48000_VALUE = 3;
    /**
     * <code>emNvASF44100 = 4;</code>
     */
    public static final int emNvASF44100_VALUE = 4;
    /**
     * <code>emNvASF32000 = 5;</code>
     */
    public static final int emNvASF32000_VALUE = 5;
    /**
     * <code>emNvASF24000 = 6;</code>
     */
    public static final int emNvASF24000_VALUE = 6;
    /**
     * <code>emNvASF22050 = 7;</code>
     */
    public static final int emNvASF22050_VALUE = 7;
    /**
     * <code>emNvASF16000 = 8;</code>
     */
    public static final int emNvASF16000_VALUE = 8;
    /**
     * <code>emNvASF12000 = 9;</code>
     */
    public static final int emNvASF12000_VALUE = 9;
    /**
     * <code>emNvASF11025 = 10;</code>
     */
    public static final int emNvASF11025_VALUE = 10;
    /**
     * <code>emNvASF8000 = 11;</code>
     */
    public static final int emNvASF8000_VALUE = 11;


    public final int getNumber() { return value; }

    public static EmNvAacSampFreq valueOf(int value) {
      switch (value) {
        case 0: return emNvASF96000;
        case 1: return emNvASF88200;
        case 2: return emNvASF64000;
        case 3: return emNvASF48000;
        case 4: return emNvASF44100;
        case 5: return emNvASF32000;
        case 6: return emNvASF24000;
        case 7: return emNvASF22050;
        case 8: return emNvASF16000;
        case 9: return emNvASF12000;
        case 10: return emNvASF11025;
        case 11: return emNvASF8000;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvAacSampFreq>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvAacSampFreq>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvAacSampFreq>() {
            public EmNvAacSampFreq findValueByNumber(int number) {
              return EmNvAacSampFreq.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(37);
    }

    private static final EmNvAacSampFreq[] VALUES = values();

    public static EmNvAacSampFreq valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvAacSampFreq(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvAacSampFreq)
  }

  /**
   * Protobuf enum {@code nv.EmNvH264AdditionalModes}
   */
  public enum EmNvH264AdditionalModes
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvModeNone = 0;</code>
     */
    emNvModeNone(0, 0),
    /**
     * <code>emNvModeRCD0 = 64;</code>
     *
     * <pre>
     *RCD0
     * </pre>
     */
    emNvModeRCD0(1, 64),
    /**
     * <code>emNvModeSBP = 32;</code>
     *
     * <pre>
     *SCALABLE bp
     * </pre>
     */
    emNvModeSBP(2, 32),
    /**
     * <code>emNvModeSHP = 16;</code>
     *
     * <pre>
     *SCALABLE hp
     * </pre>
     */
    emNvModeSHP(3, 16),
    ;

    /**
     * <code>emNvModeNone = 0;</code>
     */
    public static final int emNvModeNone_VALUE = 0;
    /**
     * <code>emNvModeRCD0 = 64;</code>
     *
     * <pre>
     *RCD0
     * </pre>
     */
    public static final int emNvModeRCD0_VALUE = 64;
    /**
     * <code>emNvModeSBP = 32;</code>
     *
     * <pre>
     *SCALABLE bp
     * </pre>
     */
    public static final int emNvModeSBP_VALUE = 32;
    /**
     * <code>emNvModeSHP = 16;</code>
     *
     * <pre>
     *SCALABLE hp
     * </pre>
     */
    public static final int emNvModeSHP_VALUE = 16;


    public final int getNumber() { return value; }

    public static EmNvH264AdditionalModes valueOf(int value) {
      switch (value) {
        case 0: return emNvModeNone;
        case 64: return emNvModeRCD0;
        case 32: return emNvModeSBP;
        case 16: return emNvModeSHP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvH264AdditionalModes>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvH264AdditionalModes>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvH264AdditionalModes>() {
            public EmNvH264AdditionalModes findValueByNumber(int number) {
              return EmNvH264AdditionalModes.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(38);
    }

    private static final EmNvH264AdditionalModes[] VALUES = values();

    public static EmNvH264AdditionalModes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvH264AdditionalModes(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvH264AdditionalModes)
  }

  /**
   * Protobuf enum {@code nv.EmNvH264Profile}
   *
   * <pre>
   *h.264profile
   * </pre>
   */
  public enum EmNvH264Profile
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvInvalid = 0;</code>
     */
    emNvInvalid(0, 0),
    /**
     * <code>emNvBaseline = 1;</code>
     */
    emNvBaseline(1, 1),
    /**
     * <code>emNvMain = 2;</code>
     */
    emNvMain(2, 2),
    /**
     * <code>emNvExtended = 4;</code>
     */
    emNvExtended(3, 4),
    /**
     * <code>emNvHigh = 8;</code>
     */
    emNvHigh(4, 8),
    /**
     * <code>emNvHigh10 = 16;</code>
     */
    emNvHigh10(5, 16),
    /**
     * <code>emNvHigh422 = 32;</code>
     */
    emNvHigh422(6, 32),
    /**
     * <code>emNvHigh444 = 64;</code>
     */
    emNvHigh444(7, 64),
    ;

    /**
     * <code>emNvInvalid = 0;</code>
     */
    public static final int emNvInvalid_VALUE = 0;
    /**
     * <code>emNvBaseline = 1;</code>
     */
    public static final int emNvBaseline_VALUE = 1;
    /**
     * <code>emNvMain = 2;</code>
     */
    public static final int emNvMain_VALUE = 2;
    /**
     * <code>emNvExtended = 4;</code>
     */
    public static final int emNvExtended_VALUE = 4;
    /**
     * <code>emNvHigh = 8;</code>
     */
    public static final int emNvHigh_VALUE = 8;
    /**
     * <code>emNvHigh10 = 16;</code>
     */
    public static final int emNvHigh10_VALUE = 16;
    /**
     * <code>emNvHigh422 = 32;</code>
     */
    public static final int emNvHigh422_VALUE = 32;
    /**
     * <code>emNvHigh444 = 64;</code>
     */
    public static final int emNvHigh444_VALUE = 64;


    public final int getNumber() { return value; }

    public static EmNvH264Profile valueOf(int value) {
      switch (value) {
        case 0: return emNvInvalid;
        case 1: return emNvBaseline;
        case 2: return emNvMain;
        case 4: return emNvExtended;
        case 8: return emNvHigh;
        case 16: return emNvHigh10;
        case 32: return emNvHigh422;
        case 64: return emNvHigh444;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvH264Profile>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvH264Profile>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvH264Profile>() {
            public EmNvH264Profile findValueByNumber(int number) {
              return EmNvH264Profile.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(39);
    }

    private static final EmNvH264Profile[] VALUES = values();

    public static EmNvH264Profile valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvH264Profile(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvH264Profile)
  }

  /**
   * Protobuf enum {@code nv.EmNvH265Profile}
   */
  public enum EmNvH265Profile
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvProfileMain = 0;</code>
     */
    emNvProfileMain(0, 0),
    /**
     * <code>emNvProfileMain10 = 1;</code>
     */
    emNvProfileMain10(1, 1),
    /**
     * <code>emNvProfileMainStill = 2;</code>
     */
    emNvProfileMainStill(2, 2),
    ;

    /**
     * <code>emNvProfileMain = 0;</code>
     */
    public static final int emNvProfileMain_VALUE = 0;
    /**
     * <code>emNvProfileMain10 = 1;</code>
     */
    public static final int emNvProfileMain10_VALUE = 1;
    /**
     * <code>emNvProfileMainStill = 2;</code>
     */
    public static final int emNvProfileMainStill_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvH265Profile valueOf(int value) {
      switch (value) {
        case 0: return emNvProfileMain;
        case 1: return emNvProfileMain10;
        case 2: return emNvProfileMainStill;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvH265Profile>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvH265Profile>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvH265Profile>() {
            public EmNvH265Profile findValueByNumber(int number) {
              return EmNvH265Profile.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(40);
    }

    private static final EmNvH265Profile[] VALUES = values();

    public static EmNvH265Profile valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvH265Profile(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvH265Profile)
  }

  /**
   * Protobuf enum {@code nv.EmNvLostPackStrategy}
   *
   * <pre>
   *解码器丢包恢复策略
   * </pre>
   */
  public enum EmNvLostPackStrategy
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvLPSQualityFirst = 0;</code>
     */
    emNvLPSQualityFirst(0, 0),
    /**
     * <code>emNvLPSSpeedSlow = 1;</code>
     */
    emNvLPSSpeedSlow(1, 1),
    /**
     * <code>emNvLPSSpeedNormal = 2;</code>
     */
    emNvLPSSpeedNormal(2, 2),
    /**
     * <code>emNvLPSSpeedFast = 3;</code>
     */
    emNvLPSSpeedFast(3, 3),
    ;

    /**
     * <code>emNvLPSQualityFirst = 0;</code>
     */
    public static final int emNvLPSQualityFirst_VALUE = 0;
    /**
     * <code>emNvLPSSpeedSlow = 1;</code>
     */
    public static final int emNvLPSSpeedSlow_VALUE = 1;
    /**
     * <code>emNvLPSSpeedNormal = 2;</code>
     */
    public static final int emNvLPSSpeedNormal_VALUE = 2;
    /**
     * <code>emNvLPSSpeedFast = 3;</code>
     */
    public static final int emNvLPSSpeedFast_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNvLostPackStrategy valueOf(int value) {
      switch (value) {
        case 0: return emNvLPSQualityFirst;
        case 1: return emNvLPSSpeedSlow;
        case 2: return emNvLPSSpeedNormal;
        case 3: return emNvLPSSpeedFast;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvLostPackStrategy>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvLostPackStrategy>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvLostPackStrategy>() {
            public EmNvLostPackStrategy findValueByNumber(int number) {
              return EmNvLostPackStrategy.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(41);
    }

    private static final EmNvLostPackStrategy[] VALUES = values();

    public static EmNvLostPackStrategy valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvLostPackStrategy(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvLostPackStrategy)
  }

  /**
   * Protobuf enum {@code nv.EmNvPiPMode}
   *
   * <pre>
   *画中画显示模式
   * </pre>
   */
  public enum EmNvPiPMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvPiPClose = 1;</code>
     *
     * <pre>
     *画中画关闭
     * </pre>
     */
    emNvPiPClose(0, 1),
    /**
     * <code>emNvPIPLeftRight = 2;</code>
     *
     * <pre>
     *两画面，左右对等
     * </pre>
     */
    emNvPIPLeftRight(1, 2),
    /**
     * <code>emNvPiPRightBottom = 3;</code>
     *
     * <pre>
     *画中画小画面显示在右下角
     * </pre>
     */
    emNvPiPRightBottom(2, 3),
    /**
     * <code>emNvPiPLeftBottom = 4;</code>
     *
     * <pre>
     *画中画小画面显示在左下角
     * </pre>
     */
    emNvPiPLeftBottom(3, 4),
    /**
     * <code>emNvPiPLeftTop = 5;</code>
     *
     * <pre>
     *画中画小画面显示在左上角
     * </pre>
     */
    emNvPiPLeftTop(4, 5),
    /**
     * <code>emNvPiPRightTop = 6;</code>
     *
     * <pre>
     *画中画小画面显示在右上角
     * </pre>
     */
    emNvPiPRightTop(5, 6),
    /**
     * <code>emNvPiPTwoSmallLeftInOneBig = 7;</code>
     *
     * <pre>
     *一大两小，大画面包含两个小画面(小画面靠左)	
     * </pre>
     */
    emNvPiPTwoSmallLeftInOneBig(6, 7),
    /**
     * <code>emNvPiPTwoSmallRightInOneBig = 8;</code>
     *
     * <pre>
     *一大两小，大画面包含两个小画面(小画面靠右)	
     * </pre>
     */
    emNvPiPTwoSmallRightInOneBig(7, 8),
    /**
     * <code>emNvPiPOneBigAndTwoSmall = 9;</code>
     *
     * <pre>
     *一大两小，大画面右侧画外有两个小画面	
     * </pre>
     */
    emNvPiPOneBigAndTwoSmall(8, 9),
    /**
     * <code>emNvPiPThree = 10;</code>
     *
     * <pre>
     *三画面,品字形
     * </pre>
     */
    emNvPiPThree(9, 10),
    ;

    /**
     * <code>emNvPiPClose = 1;</code>
     *
     * <pre>
     *画中画关闭
     * </pre>
     */
    public static final int emNvPiPClose_VALUE = 1;
    /**
     * <code>emNvPIPLeftRight = 2;</code>
     *
     * <pre>
     *两画面，左右对等
     * </pre>
     */
    public static final int emNvPIPLeftRight_VALUE = 2;
    /**
     * <code>emNvPiPRightBottom = 3;</code>
     *
     * <pre>
     *画中画小画面显示在右下角
     * </pre>
     */
    public static final int emNvPiPRightBottom_VALUE = 3;
    /**
     * <code>emNvPiPLeftBottom = 4;</code>
     *
     * <pre>
     *画中画小画面显示在左下角
     * </pre>
     */
    public static final int emNvPiPLeftBottom_VALUE = 4;
    /**
     * <code>emNvPiPLeftTop = 5;</code>
     *
     * <pre>
     *画中画小画面显示在左上角
     * </pre>
     */
    public static final int emNvPiPLeftTop_VALUE = 5;
    /**
     * <code>emNvPiPRightTop = 6;</code>
     *
     * <pre>
     *画中画小画面显示在右上角
     * </pre>
     */
    public static final int emNvPiPRightTop_VALUE = 6;
    /**
     * <code>emNvPiPTwoSmallLeftInOneBig = 7;</code>
     *
     * <pre>
     *一大两小，大画面包含两个小画面(小画面靠左)	
     * </pre>
     */
    public static final int emNvPiPTwoSmallLeftInOneBig_VALUE = 7;
    /**
     * <code>emNvPiPTwoSmallRightInOneBig = 8;</code>
     *
     * <pre>
     *一大两小，大画面包含两个小画面(小画面靠右)	
     * </pre>
     */
    public static final int emNvPiPTwoSmallRightInOneBig_VALUE = 8;
    /**
     * <code>emNvPiPOneBigAndTwoSmall = 9;</code>
     *
     * <pre>
     *一大两小，大画面右侧画外有两个小画面	
     * </pre>
     */
    public static final int emNvPiPOneBigAndTwoSmall_VALUE = 9;
    /**
     * <code>emNvPiPThree = 10;</code>
     *
     * <pre>
     *三画面,品字形
     * </pre>
     */
    public static final int emNvPiPThree_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmNvPiPMode valueOf(int value) {
      switch (value) {
        case 1: return emNvPiPClose;
        case 2: return emNvPIPLeftRight;
        case 3: return emNvPiPRightBottom;
        case 4: return emNvPiPLeftBottom;
        case 5: return emNvPiPLeftTop;
        case 6: return emNvPiPRightTop;
        case 7: return emNvPiPTwoSmallLeftInOneBig;
        case 8: return emNvPiPTwoSmallRightInOneBig;
        case 9: return emNvPiPOneBigAndTwoSmall;
        case 10: return emNvPiPThree;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvPiPMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvPiPMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvPiPMode>() {
            public EmNvPiPMode findValueByNumber(int number) {
              return EmNvPiPMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(42);
    }

    private static final EmNvPiPMode[] VALUES = values();

    public static EmNvPiPMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvPiPMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvPiPMode)
  }

  /**
   * Protobuf enum {@code nv.EmNvHDLastDisplay}
   *
   * <pre>
   *无图像显示输出配置
   * </pre>
   */
  public enum EmNvHDLastDisplay
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvLD_LastFrame = 0;</code>
     *
     * <pre>
     *最后一帧
     * </pre>
     */
    emNvLD_LastFrame(0, 0),
    /**
     * <code>emNvLD_BlueScreen = 1;</code>
     *
     * <pre>
     *蓝屏
     * </pre>
     */
    emNvLD_BlueScreen(1, 1),
    /**
     * <code>emNvLD_StaticBMP = 2;</code>
     *
     * <pre>
     *静态图片 
     * </pre>
     */
    emNvLD_StaticBMP(2, 2),
    /**
     * <code>emNvLD_CustomBMP = 3;</code>
     *
     * <pre>
     *用户自定义图片 
     * </pre>
     */
    emNvLD_CustomBMP(3, 3),
    ;

    /**
     * <code>emNvLD_LastFrame = 0;</code>
     *
     * <pre>
     *最后一帧
     * </pre>
     */
    public static final int emNvLD_LastFrame_VALUE = 0;
    /**
     * <code>emNvLD_BlueScreen = 1;</code>
     *
     * <pre>
     *蓝屏
     * </pre>
     */
    public static final int emNvLD_BlueScreen_VALUE = 1;
    /**
     * <code>emNvLD_StaticBMP = 2;</code>
     *
     * <pre>
     *静态图片 
     * </pre>
     */
    public static final int emNvLD_StaticBMP_VALUE = 2;
    /**
     * <code>emNvLD_CustomBMP = 3;</code>
     *
     * <pre>
     *用户自定义图片 
     * </pre>
     */
    public static final int emNvLD_CustomBMP_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNvHDLastDisplay valueOf(int value) {
      switch (value) {
        case 0: return emNvLD_LastFrame;
        case 1: return emNvLD_BlueScreen;
        case 2: return emNvLD_StaticBMP;
        case 3: return emNvLD_CustomBMP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvHDLastDisplay>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvHDLastDisplay>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvHDLastDisplay>() {
            public EmNvHDLastDisplay findValueByNumber(int number) {
              return EmNvHDLastDisplay.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(43);
    }

    private static final EmNvHDLastDisplay[] VALUES = values();

    public static EmNvHDLastDisplay valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvHDLastDisplay(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvHDLastDisplay)
  }

  /**
   * Protobuf enum {@code nv.EmNvResizeMode}
   *
   * <pre>
   *解码后处理策略
   * </pre>
   */
  public enum EmNvResizeMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvBlackEdge = 0;</code>
     *
     * <pre>
     *加黑边
     * </pre>
     */
    emNvBlackEdge(0, 0),
    /**
     * <code>emNvCutEdge = 1;</code>
     *
     * <pre>
     *裁边
     * </pre>
     */
    emNvCutEdge(1, 1),
    /**
     * <code>emNvNoProportionally = 2;</code>
     *
     * <pre>
     *非等比
     * </pre>
     */
    emNvNoProportionally(2, 2),
    ;

    /**
     * <code>emNvBlackEdge = 0;</code>
     *
     * <pre>
     *加黑边
     * </pre>
     */
    public static final int emNvBlackEdge_VALUE = 0;
    /**
     * <code>emNvCutEdge = 1;</code>
     *
     * <pre>
     *裁边
     * </pre>
     */
    public static final int emNvCutEdge_VALUE = 1;
    /**
     * <code>emNvNoProportionally = 2;</code>
     *
     * <pre>
     *非等比
     * </pre>
     */
    public static final int emNvNoProportionally_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvResizeMode valueOf(int value) {
      switch (value) {
        case 0: return emNvBlackEdge;
        case 1: return emNvCutEdge;
        case 2: return emNvNoProportionally;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvResizeMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvResizeMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvResizeMode>() {
            public EmNvResizeMode findValueByNumber(int number) {
              return EmNvResizeMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(44);
    }

    private static final EmNvResizeMode[] VALUES = values();

    public static EmNvResizeMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvResizeMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvResizeMode)
  }

  /**
   * Protobuf enum {@code nv.EmNvHDImageNoise}
   *
   * <pre>
   *图像降噪
   * </pre>
   */
  public enum EmNvHDImageNoise
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvImageNoise_Disable = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    emNvImageNoise_Disable(0, 0),
    /**
     * <code>emNvImageNoise_Low = 1;</code>
     *
     * <pre>
     *微弱
     * </pre>
     */
    emNvImageNoise_Low(1, 1),
    /**
     * <code>emNvImageNoise_Med = 2;</code>
     *
     * <pre>
     *弱
     * </pre>
     */
    emNvImageNoise_Med(2, 2),
    /**
     * <code>emNvImageNoise_High = 3;</code>
     *
     * <pre>
     *强
     * </pre>
     */
    emNvImageNoise_High(3, 3),
    /**
     * <code>emNvImageNoise_UltraHigh = 4;</code>
     *
     * <pre>
     *超强
     * </pre>
     */
    emNvImageNoise_UltraHigh(4, 4),
    ;

    /**
     * <code>emNvImageNoise_Disable = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    public static final int emNvImageNoise_Disable_VALUE = 0;
    /**
     * <code>emNvImageNoise_Low = 1;</code>
     *
     * <pre>
     *微弱
     * </pre>
     */
    public static final int emNvImageNoise_Low_VALUE = 1;
    /**
     * <code>emNvImageNoise_Med = 2;</code>
     *
     * <pre>
     *弱
     * </pre>
     */
    public static final int emNvImageNoise_Med_VALUE = 2;
    /**
     * <code>emNvImageNoise_High = 3;</code>
     *
     * <pre>
     *强
     * </pre>
     */
    public static final int emNvImageNoise_High_VALUE = 3;
    /**
     * <code>emNvImageNoise_UltraHigh = 4;</code>
     *
     * <pre>
     *超强
     * </pre>
     */
    public static final int emNvImageNoise_UltraHigh_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmNvHDImageNoise valueOf(int value) {
      switch (value) {
        case 0: return emNvImageNoise_Disable;
        case 1: return emNvImageNoise_Low;
        case 2: return emNvImageNoise_Med;
        case 3: return emNvImageNoise_High;
        case 4: return emNvImageNoise_UltraHigh;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvHDImageNoise>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvHDImageNoise>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvHDImageNoise>() {
            public EmNvHDImageNoise findValueByNumber(int number) {
              return EmNvHDImageNoise.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(45);
    }

    private static final EmNvHDImageNoise[] VALUES = values();

    public static EmNvHDImageNoise valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvHDImageNoise(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvHDImageNoise)
  }

  /**
   * Protobuf enum {@code nv.EmNvLocalSoundIndex}
   *
   * <pre>
   *本地音效索引
   * </pre>
   */
  public enum EmNvLocalSoundIndex
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvSound1st = 0;</code>
     */
    emNvSound1st(0, 0),
    /**
     * <code>emNvSound2nd = 1;</code>
     */
    emNvSound2nd(1, 1),
    /**
     * <code>emNvSound3rd = 2;</code>
     */
    emNvSound3rd(2, 2),
    /**
     * <code>emNvSound4th = 3;</code>
     */
    emNvSound4th(3, 3),
    /**
     * <code>emNvSound5th = 4;</code>
     */
    emNvSound5th(4, 4),
    /**
     * <code>emNvSound6th = 5;</code>
     */
    emNvSound6th(5, 5),
    /**
     * <code>emNvSound7th = 6;</code>
     */
    emNvSound7th(6, 6),
    /**
     * <code>emNvSound8th = 7;</code>
     */
    emNvSound8th(7, 7),
    /**
     * <code>emNvSound9th = 8;</code>
     */
    emNvSound9th(8, 8),
    ;

    /**
     * <code>emNvSound1st = 0;</code>
     */
    public static final int emNvSound1st_VALUE = 0;
    /**
     * <code>emNvSound2nd = 1;</code>
     */
    public static final int emNvSound2nd_VALUE = 1;
    /**
     * <code>emNvSound3rd = 2;</code>
     */
    public static final int emNvSound3rd_VALUE = 2;
    /**
     * <code>emNvSound4th = 3;</code>
     */
    public static final int emNvSound4th_VALUE = 3;
    /**
     * <code>emNvSound5th = 4;</code>
     */
    public static final int emNvSound5th_VALUE = 4;
    /**
     * <code>emNvSound6th = 5;</code>
     */
    public static final int emNvSound6th_VALUE = 5;
    /**
     * <code>emNvSound7th = 6;</code>
     */
    public static final int emNvSound7th_VALUE = 6;
    /**
     * <code>emNvSound8th = 7;</code>
     */
    public static final int emNvSound8th_VALUE = 7;
    /**
     * <code>emNvSound9th = 8;</code>
     */
    public static final int emNvSound9th_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmNvLocalSoundIndex valueOf(int value) {
      switch (value) {
        case 0: return emNvSound1st;
        case 1: return emNvSound2nd;
        case 2: return emNvSound3rd;
        case 3: return emNvSound4th;
        case 4: return emNvSound5th;
        case 5: return emNvSound6th;
        case 6: return emNvSound7th;
        case 7: return emNvSound8th;
        case 8: return emNvSound9th;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvLocalSoundIndex>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvLocalSoundIndex>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvLocalSoundIndex>() {
            public EmNvLocalSoundIndex findValueByNumber(int number) {
              return EmNvLocalSoundIndex.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(46);
    }

    private static final EmNvLocalSoundIndex[] VALUES = values();

    public static EmNvLocalSoundIndex valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvLocalSoundIndex(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvLocalSoundIndex)
  }

  /**
   * Protobuf enum {@code nv.EmNvUISynchronizeReason}
   *
   * <pre>
   ** 同步原因 
   * </pre>
   */
  public enum EmNvUISynchronizeReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvSynchronize_Upgrade = 0;</code>
     *
     * <pre>
     *&#47;&lt; 升级
     * </pre>
     */
    emNvSynchronize_Upgrade(0, 0),
    /**
     * <code>emNvSynchronize_BeginDspSleep = 1;</code>
     *
     * <pre>
     *&#47;&lt; 开始待机倒计时
     * </pre>
     */
    emNvSynchronize_BeginDspSleep(1, 1),
    /**
     * <code>emNvSynchronize_CancelDspSleeep = 2;</code>
     *
     * <pre>
     *&#47;&lt; 取消待机倒计时
     * </pre>
     */
    emNvSynchronize_CancelDspSleeep(2, 2),
    /**
     * <code>emNvSynchronize_RecountAutoSleepTime = 3;</code>
     *
     * <pre>
     *&#47;&lt; 重新计算待机时间
     * </pre>
     */
    emNvSynchronize_RecountAutoSleepTime(3, 3),
    ;

    /**
     * <code>emNvSynchronize_Upgrade = 0;</code>
     *
     * <pre>
     *&#47;&lt; 升级
     * </pre>
     */
    public static final int emNvSynchronize_Upgrade_VALUE = 0;
    /**
     * <code>emNvSynchronize_BeginDspSleep = 1;</code>
     *
     * <pre>
     *&#47;&lt; 开始待机倒计时
     * </pre>
     */
    public static final int emNvSynchronize_BeginDspSleep_VALUE = 1;
    /**
     * <code>emNvSynchronize_CancelDspSleeep = 2;</code>
     *
     * <pre>
     *&#47;&lt; 取消待机倒计时
     * </pre>
     */
    public static final int emNvSynchronize_CancelDspSleeep_VALUE = 2;
    /**
     * <code>emNvSynchronize_RecountAutoSleepTime = 3;</code>
     *
     * <pre>
     *&#47;&lt; 重新计算待机时间
     * </pre>
     */
    public static final int emNvSynchronize_RecountAutoSleepTime_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNvUISynchronizeReason valueOf(int value) {
      switch (value) {
        case 0: return emNvSynchronize_Upgrade;
        case 1: return emNvSynchronize_BeginDspSleep;
        case 2: return emNvSynchronize_CancelDspSleeep;
        case 3: return emNvSynchronize_RecountAutoSleepTime;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvUISynchronizeReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvUISynchronizeReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvUISynchronizeReason>() {
            public EmNvUISynchronizeReason findValueByNumber(int number) {
              return EmNvUISynchronizeReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(47);
    }

    private static final EmNvUISynchronizeReason[] VALUES = values();

    public static EmNvUISynchronizeReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvUISynchronizeReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvUISynchronizeReason)
  }

  /**
   * Protobuf enum {@code nv.EmNvVideoOutPort}
   *
   * <pre>
   *视频输出接口定义
   * </pre>
   */
  public enum EmNvVideoOutPort
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNv_OUT_HDMI0 = 0;</code>
     *
     * <pre>
     *输出到主流(单屏)、辅流屏（双屏),osd画面
     * </pre>
     */
    emNv_OUT_HDMI0(0, 0),
    /**
     * <code>emNv_OUT_HDMI1 = 1;</code>
     *
     * <pre>
     *输出到I-FACE板HDMI矩阵
     * </pre>
     */
    emNv_OUT_HDMI1(1, 1),
    ;

    /**
     * <code>emNv_OUT_HDMI0 = 0;</code>
     *
     * <pre>
     *输出到主流(单屏)、辅流屏（双屏),osd画面
     * </pre>
     */
    public static final int emNv_OUT_HDMI0_VALUE = 0;
    /**
     * <code>emNv_OUT_HDMI1 = 1;</code>
     *
     * <pre>
     *输出到I-FACE板HDMI矩阵
     * </pre>
     */
    public static final int emNv_OUT_HDMI1_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmNvVideoOutPort valueOf(int value) {
      switch (value) {
        case 0: return emNv_OUT_HDMI0;
        case 1: return emNv_OUT_HDMI1;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoOutPort>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoOutPort>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvVideoOutPort>() {
            public EmNvVideoOutPort findValueByNumber(int number) {
              return EmNvVideoOutPort.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(48);
    }

    private static final EmNvVideoOutPort[] VALUES = values();

    public static EmNvVideoOutPort valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvVideoOutPort(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvVideoOutPort)
  }

  /**
   * Protobuf enum {@code nv.EmNvVideoInPort}
   *
   * <pre>
   *视频输入源定义
   * </pre>
   */
  public enum EmNvVideoInPort
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNv_IN_HDMI0 = 0;</code>
     *
     * <pre>
     *OPSTV port a
     * </pre>
     */
    emNv_IN_HDMI0(0, 0),
    /**
     * <code>emNv_IN_HDMI1 = 1;</code>
     *
     * <pre>
     *Terminal
     * </pre>
     */
    emNv_IN_HDMI1(1, 1),
    /**
     * <code>emNv_IN_HDMI2 = 2;</code>
     *
     * <pre>
     *OPSTV port b
     * </pre>
     */
    emNv_IN_HDMI2(2, 2),
    /**
     * <code>emNv_IN_DSP_VP = 3;</code>
     *
     * <pre>
     *IMix not as Osd
     * </pre>
     */
    emNv_IN_DSP_VP(3, 3),
    /**
     * <code>emNv_IN_OSD_VP = 4;</code>
     *
     * <pre>
     *IMix as Osd
     * </pre>
     */
    emNv_IN_OSD_VP(4, 4),
    ;

    /**
     * <code>emNv_IN_HDMI0 = 0;</code>
     *
     * <pre>
     *OPSTV port a
     * </pre>
     */
    public static final int emNv_IN_HDMI0_VALUE = 0;
    /**
     * <code>emNv_IN_HDMI1 = 1;</code>
     *
     * <pre>
     *Terminal
     * </pre>
     */
    public static final int emNv_IN_HDMI1_VALUE = 1;
    /**
     * <code>emNv_IN_HDMI2 = 2;</code>
     *
     * <pre>
     *OPSTV port b
     * </pre>
     */
    public static final int emNv_IN_HDMI2_VALUE = 2;
    /**
     * <code>emNv_IN_DSP_VP = 3;</code>
     *
     * <pre>
     *IMix not as Osd
     * </pre>
     */
    public static final int emNv_IN_DSP_VP_VALUE = 3;
    /**
     * <code>emNv_IN_OSD_VP = 4;</code>
     *
     * <pre>
     *IMix as Osd
     * </pre>
     */
    public static final int emNv_IN_OSD_VP_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmNvVideoInPort valueOf(int value) {
      switch (value) {
        case 0: return emNv_IN_HDMI0;
        case 1: return emNv_IN_HDMI1;
        case 2: return emNv_IN_HDMI2;
        case 3: return emNv_IN_DSP_VP;
        case 4: return emNv_IN_OSD_VP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoInPort>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoInPort>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvVideoInPort>() {
            public EmNvVideoInPort findValueByNumber(int number) {
              return EmNvVideoInPort.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(49);
    }

    private static final EmNvVideoInPort[] VALUES = values();

    public static EmNvVideoInPort valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvVideoInPort(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvVideoInPort)
  }

  /**
   * Protobuf enum {@code nv.EmNvImixVidSrcType}
   *
   * <pre>
   *视频源类型
   * </pre>
   */
  public enum EmNvImixVidSrcType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNv_Vid_Invalid = 0;</code>
     */
    emNv_Vid_Invalid(0, 0),
    /**
     * <code>emNv_Vid_IMIX = 1;</code>
     *
     * <pre>
     *imix主界面
     * </pre>
     */
    emNv_Vid_IMIX(1, 1),
    /**
     * <code>emNv_Vid_OPS = 2;</code>
     *
     * <pre>
     *计算机
     * </pre>
     */
    emNv_Vid_OPS(2, 2),
    /**
     * <code>emNv_Vid_TV_HDMI = 3;</code>
     *
     * <pre>
     *电视机前hdmi  对应HDMI2
     * </pre>
     */
    emNv_Vid_TV_HDMI(3, 3),
    /**
     * <code>emNv_Vid_MT = 4;</code>
     *
     * <pre>
     *视频会议终端  对应HDMI1
     * </pre>
     */
    emNv_Vid_MT(4, 4),
    /**
     * <code>emNv_Vid_VGA = 5;</code>
     *
     * <pre>
     *终端辅流vga
     * </pre>
     */
    emNv_Vid_VGA(5, 5),
    /**
     * <code>emNv_Vid_HDMI = 6;</code>
     *
     * <pre>
     *终端辅流hdmi
     * </pre>
     */
    emNv_Vid_HDMI(6, 6),
    /**
     * <code>emNv_Vid_QuickShare1 = 7;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    emNv_Vid_QuickShare1(7, 7),
    /**
     * <code>emNv_Vid_QuickShare2 = 8;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    emNv_Vid_QuickShare2(8, 8),
    /**
     * <code>emNv_Vid_QuickShare3 = 9;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    emNv_Vid_QuickShare3(9, 9),
    /**
     * <code>emNv_Vid_QuickShare4 = 10;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    emNv_Vid_QuickShare4(10, 10),
    /**
     * <code>emNv_Vid_QuickShare5 = 11;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    emNv_Vid_QuickShare5(11, 11),
    /**
     * <code>emNv_Vid_QuickShare6 = 12;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    emNv_Vid_QuickShare6(12, 12),
    /**
     * <code>emNv_Vid_QuickShare7 = 13;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    emNv_Vid_QuickShare7(13, 13),
    /**
     * <code>emNv_Vid_QuickShare8 = 14;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    emNv_Vid_QuickShare8(14, 14),
    /**
     * <code>emNv_Vid_DLNA = 15;</code>
     *
     * <pre>
     *DLNA多媒体投影
     * </pre>
     */
    emNv_Vid_DLNA(15, 15),
    /**
     * <code>emNv_Vid_ScreenDraw = 16;</code>
     *
     * <pre>
     *批注
     * </pre>
     */
    emNv_Vid_ScreenDraw(16, 16),
    /**
     * <code>emNv_Vid_UDisk1 = 17;</code>
     *
     * <pre>
     *u盘1
     * </pre>
     */
    emNv_Vid_UDisk1(17, 17),
    /**
     * <code>emNv_Vid_UDisk2 = 18;</code>
     *
     * <pre>
     *u盘2
     * </pre>
     */
    emNv_Vid_UDisk2(18, 18),
    /**
     * <code>emNv_Vid_LocalEcho = 19;</code>
     *
     * <pre>
     *本地回显
     * </pre>
     */
    emNv_Vid_LocalEcho(19, 19),
    ;

    /**
     * <code>emNv_Vid_Invalid = 0;</code>
     */
    public static final int emNv_Vid_Invalid_VALUE = 0;
    /**
     * <code>emNv_Vid_IMIX = 1;</code>
     *
     * <pre>
     *imix主界面
     * </pre>
     */
    public static final int emNv_Vid_IMIX_VALUE = 1;
    /**
     * <code>emNv_Vid_OPS = 2;</code>
     *
     * <pre>
     *计算机
     * </pre>
     */
    public static final int emNv_Vid_OPS_VALUE = 2;
    /**
     * <code>emNv_Vid_TV_HDMI = 3;</code>
     *
     * <pre>
     *电视机前hdmi  对应HDMI2
     * </pre>
     */
    public static final int emNv_Vid_TV_HDMI_VALUE = 3;
    /**
     * <code>emNv_Vid_MT = 4;</code>
     *
     * <pre>
     *视频会议终端  对应HDMI1
     * </pre>
     */
    public static final int emNv_Vid_MT_VALUE = 4;
    /**
     * <code>emNv_Vid_VGA = 5;</code>
     *
     * <pre>
     *终端辅流vga
     * </pre>
     */
    public static final int emNv_Vid_VGA_VALUE = 5;
    /**
     * <code>emNv_Vid_HDMI = 6;</code>
     *
     * <pre>
     *终端辅流hdmi
     * </pre>
     */
    public static final int emNv_Vid_HDMI_VALUE = 6;
    /**
     * <code>emNv_Vid_QuickShare1 = 7;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    public static final int emNv_Vid_QuickShare1_VALUE = 7;
    /**
     * <code>emNv_Vid_QuickShare2 = 8;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    public static final int emNv_Vid_QuickShare2_VALUE = 8;
    /**
     * <code>emNv_Vid_QuickShare3 = 9;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    public static final int emNv_Vid_QuickShare3_VALUE = 9;
    /**
     * <code>emNv_Vid_QuickShare4 = 10;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    public static final int emNv_Vid_QuickShare4_VALUE = 10;
    /**
     * <code>emNv_Vid_QuickShare5 = 11;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    public static final int emNv_Vid_QuickShare5_VALUE = 11;
    /**
     * <code>emNv_Vid_QuickShare6 = 12;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    public static final int emNv_Vid_QuickShare6_VALUE = 12;
    /**
     * <code>emNv_Vid_QuickShare7 = 13;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    public static final int emNv_Vid_QuickShare7_VALUE = 13;
    /**
     * <code>emNv_Vid_QuickShare8 = 14;</code>
     *
     * <pre>
     *pc无线投影
     * </pre>
     */
    public static final int emNv_Vid_QuickShare8_VALUE = 14;
    /**
     * <code>emNv_Vid_DLNA = 15;</code>
     *
     * <pre>
     *DLNA多媒体投影
     * </pre>
     */
    public static final int emNv_Vid_DLNA_VALUE = 15;
    /**
     * <code>emNv_Vid_ScreenDraw = 16;</code>
     *
     * <pre>
     *批注
     * </pre>
     */
    public static final int emNv_Vid_ScreenDraw_VALUE = 16;
    /**
     * <code>emNv_Vid_UDisk1 = 17;</code>
     *
     * <pre>
     *u盘1
     * </pre>
     */
    public static final int emNv_Vid_UDisk1_VALUE = 17;
    /**
     * <code>emNv_Vid_UDisk2 = 18;</code>
     *
     * <pre>
     *u盘2
     * </pre>
     */
    public static final int emNv_Vid_UDisk2_VALUE = 18;
    /**
     * <code>emNv_Vid_LocalEcho = 19;</code>
     *
     * <pre>
     *本地回显
     * </pre>
     */
    public static final int emNv_Vid_LocalEcho_VALUE = 19;


    public final int getNumber() { return value; }

    public static EmNvImixVidSrcType valueOf(int value) {
      switch (value) {
        case 0: return emNv_Vid_Invalid;
        case 1: return emNv_Vid_IMIX;
        case 2: return emNv_Vid_OPS;
        case 3: return emNv_Vid_TV_HDMI;
        case 4: return emNv_Vid_MT;
        case 5: return emNv_Vid_VGA;
        case 6: return emNv_Vid_HDMI;
        case 7: return emNv_Vid_QuickShare1;
        case 8: return emNv_Vid_QuickShare2;
        case 9: return emNv_Vid_QuickShare3;
        case 10: return emNv_Vid_QuickShare4;
        case 11: return emNv_Vid_QuickShare5;
        case 12: return emNv_Vid_QuickShare6;
        case 13: return emNv_Vid_QuickShare7;
        case 14: return emNv_Vid_QuickShare8;
        case 15: return emNv_Vid_DLNA;
        case 16: return emNv_Vid_ScreenDraw;
        case 17: return emNv_Vid_UDisk1;
        case 18: return emNv_Vid_UDisk2;
        case 19: return emNv_Vid_LocalEcho;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvImixVidSrcType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvImixVidSrcType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvImixVidSrcType>() {
            public EmNvImixVidSrcType findValueByNumber(int number) {
              return EmNvImixVidSrcType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(50);
    }

    private static final EmNvImixVidSrcType[] VALUES = values();

    public static EmNvImixVidSrcType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvImixVidSrcType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvImixVidSrcType)
  }

  /**
   * Protobuf enum {@code nv.EmNvMtSvType}
   *
   * <pre>
   *终端辅流输入源类型
   * </pre>
   */
  public enum EmNvMtSvType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNv_MtSv_Hdmi = 0;</code>
     */
    emNv_MtSv_Hdmi(0, 0),
    /**
     * <code>emNv_MtSv_Vga = 1;</code>
     */
    emNv_MtSv_Vga(1, 1),
    ;

    /**
     * <code>emNv_MtSv_Hdmi = 0;</code>
     */
    public static final int emNv_MtSv_Hdmi_VALUE = 0;
    /**
     * <code>emNv_MtSv_Vga = 1;</code>
     */
    public static final int emNv_MtSv_Vga_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmNvMtSvType valueOf(int value) {
      switch (value) {
        case 0: return emNv_MtSv_Hdmi;
        case 1: return emNv_MtSv_Vga;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvMtSvType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvMtSvType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvMtSvType>() {
            public EmNvMtSvType findValueByNumber(int number) {
              return EmNvMtSvType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(51);
    }

    private static final EmNvMtSvType[] VALUES = values();

    public static EmNvMtSvType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvMtSvType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvMtSvType)
  }

  /**
   * Protobuf enum {@code nv.EmNvApiMode}
   *
   * <pre>
   ** nvapi使用方式 
   * </pre>
   */
  public enum EmNvApiMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvLocMode = 0;</code>
     *
     * <pre>
     *&#47;&lt; 本地模式(终端)
     * </pre>
     */
    emNvLocMode(0, 0),
    /**
     * <code>emNvRnvMode = 1;</code>
     *
     * <pre>
     *&#47;&lt; 远程模式(终控)
     * </pre>
     */
    emNvRnvMode(1, 1),
    ;

    /**
     * <code>emNvLocMode = 0;</code>
     *
     * <pre>
     *&#47;&lt; 本地模式(终端)
     * </pre>
     */
    public static final int emNvLocMode_VALUE = 0;
    /**
     * <code>emNvRnvMode = 1;</code>
     *
     * <pre>
     *&#47;&lt; 远程模式(终控)
     * </pre>
     */
    public static final int emNvRnvMode_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmNvApiMode valueOf(int value) {
      switch (value) {
        case 0: return emNvLocMode;
        case 1: return emNvRnvMode;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvApiMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvApiMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvApiMode>() {
            public EmNvApiMode findValueByNumber(int number) {
              return EmNvApiMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(52);
    }

    private static final EmNvApiMode[] VALUES = values();

    public static EmNvApiMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvApiMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvApiMode)
  }

  /**
   * Protobuf enum {@code nv.EmNvSleepFailReason}
   *
   * <pre>
   *待机失败原因
   * </pre>
   */
  public enum EmNvSleepFailReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvSFRNoError = 0;</code>
     *
     * <pre>
     *没有失败，允许待机
     * </pre>
     */
    emNvSFRNoError(0, 0),
    /**
     * <code>emNvSFRProtectionTime = 1;</code>
     *
     * <pre>
     *待机保护时间(30秒)
     * </pre>
     */
    emNvSFRProtectionTime(1, 1),
    /**
     * <code>emNvSFRMonitor = 2;</code>
     *
     * <pre>
     *监控
     * </pre>
     */
    emNvSFRMonitor(2, 2),
    /**
     * <code>emNvSFRInConf = 3;</code>
     *
     * <pre>
     *会议
     * </pre>
     */
    emNvSFRInConf(3, 3),
    /**
     * <code>emNvSFRLoop = 4;</code>
     *
     * <pre>
     *自环
     * </pre>
     */
    emNvSFRLoop(4, 4),
    /**
     * <code>emNvSFRRibbonTest = 5;</code>
     *
     * <pre>
     *色带测试
     * </pre>
     */
    emNvSFRRibbonTest(5, 5),
    /**
     * <code>emNvSFRSnapView = 6;</code>
     *
     * <pre>
     *快照浏览
     * </pre>
     */
    emNvSFRSnapView(6, 6),
    /**
     * <code>emNvSFRVrs = 7;</code>
     *
     * <pre>
     *VRS
     * </pre>
     */
    emNvSFRVrs(7, 7),
    /**
     * <code>emNvSFRUpgrade = 8;</code>
     *
     * <pre>
     *升级
     * </pre>
     */
    emNvSFRUpgrade(8, 8),
    /**
     * <code>emNvSFRSusUpgrade = 9;</code>
     *
     * <pre>
     *SUS升级
     * </pre>
     */
    emNvSFRSusUpgrade(9, 9),
    /**
     * <code>emNvSFRNetCap = 10;</code>
     *
     * <pre>
     *抓包
     * </pre>
     */
    emNvSFRNetCap(10, 10),
    /**
     * <code>emNvSFRAddrbook = 11;</code>
     *
     * <pre>
     *地址簿导入或导出
     * </pre>
     */
    emNvSFRAddrbook(11, 11),
    /**
     * <code>emNvSFRSnapExport = 12;</code>
     *
     * <pre>
     *快照导出
     * </pre>
     */
    emNvSFRSnapExport(12, 12),
    /**
     * <code>emNvSFRInConfByPower = 30;</code>
     *
     * <pre>
     *会议时按总开关待机
     * </pre>
     */
    emNvSFRInConfByPower(13, 30),
    /**
     * <code>emNvSFRInSysUpGrade = 31;</code>
     *
     * <pre>
     *待机时系统升级通知
     * </pre>
     */
    emNvSFRInSysUpGrade(14, 31),
    /**
     * <code>emNvSFRInQkupgrade = 32;</code>
     *
     * <pre>
     *待机时qk升级通知
     * </pre>
     */
    emNvSFRInQkupgrade(15, 32),
    ;

    /**
     * <code>emNvSFRNoError = 0;</code>
     *
     * <pre>
     *没有失败，允许待机
     * </pre>
     */
    public static final int emNvSFRNoError_VALUE = 0;
    /**
     * <code>emNvSFRProtectionTime = 1;</code>
     *
     * <pre>
     *待机保护时间(30秒)
     * </pre>
     */
    public static final int emNvSFRProtectionTime_VALUE = 1;
    /**
     * <code>emNvSFRMonitor = 2;</code>
     *
     * <pre>
     *监控
     * </pre>
     */
    public static final int emNvSFRMonitor_VALUE = 2;
    /**
     * <code>emNvSFRInConf = 3;</code>
     *
     * <pre>
     *会议
     * </pre>
     */
    public static final int emNvSFRInConf_VALUE = 3;
    /**
     * <code>emNvSFRLoop = 4;</code>
     *
     * <pre>
     *自环
     * </pre>
     */
    public static final int emNvSFRLoop_VALUE = 4;
    /**
     * <code>emNvSFRRibbonTest = 5;</code>
     *
     * <pre>
     *色带测试
     * </pre>
     */
    public static final int emNvSFRRibbonTest_VALUE = 5;
    /**
     * <code>emNvSFRSnapView = 6;</code>
     *
     * <pre>
     *快照浏览
     * </pre>
     */
    public static final int emNvSFRSnapView_VALUE = 6;
    /**
     * <code>emNvSFRVrs = 7;</code>
     *
     * <pre>
     *VRS
     * </pre>
     */
    public static final int emNvSFRVrs_VALUE = 7;
    /**
     * <code>emNvSFRUpgrade = 8;</code>
     *
     * <pre>
     *升级
     * </pre>
     */
    public static final int emNvSFRUpgrade_VALUE = 8;
    /**
     * <code>emNvSFRSusUpgrade = 9;</code>
     *
     * <pre>
     *SUS升级
     * </pre>
     */
    public static final int emNvSFRSusUpgrade_VALUE = 9;
    /**
     * <code>emNvSFRNetCap = 10;</code>
     *
     * <pre>
     *抓包
     * </pre>
     */
    public static final int emNvSFRNetCap_VALUE = 10;
    /**
     * <code>emNvSFRAddrbook = 11;</code>
     *
     * <pre>
     *地址簿导入或导出
     * </pre>
     */
    public static final int emNvSFRAddrbook_VALUE = 11;
    /**
     * <code>emNvSFRSnapExport = 12;</code>
     *
     * <pre>
     *快照导出
     * </pre>
     */
    public static final int emNvSFRSnapExport_VALUE = 12;
    /**
     * <code>emNvSFRInConfByPower = 30;</code>
     *
     * <pre>
     *会议时按总开关待机
     * </pre>
     */
    public static final int emNvSFRInConfByPower_VALUE = 30;
    /**
     * <code>emNvSFRInSysUpGrade = 31;</code>
     *
     * <pre>
     *待机时系统升级通知
     * </pre>
     */
    public static final int emNvSFRInSysUpGrade_VALUE = 31;
    /**
     * <code>emNvSFRInQkupgrade = 32;</code>
     *
     * <pre>
     *待机时qk升级通知
     * </pre>
     */
    public static final int emNvSFRInQkupgrade_VALUE = 32;


    public final int getNumber() { return value; }

    public static EmNvSleepFailReason valueOf(int value) {
      switch (value) {
        case 0: return emNvSFRNoError;
        case 1: return emNvSFRProtectionTime;
        case 2: return emNvSFRMonitor;
        case 3: return emNvSFRInConf;
        case 4: return emNvSFRLoop;
        case 5: return emNvSFRRibbonTest;
        case 6: return emNvSFRSnapView;
        case 7: return emNvSFRVrs;
        case 8: return emNvSFRUpgrade;
        case 9: return emNvSFRSusUpgrade;
        case 10: return emNvSFRNetCap;
        case 11: return emNvSFRAddrbook;
        case 12: return emNvSFRSnapExport;
        case 30: return emNvSFRInConfByPower;
        case 31: return emNvSFRInSysUpGrade;
        case 32: return emNvSFRInQkupgrade;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvSleepFailReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvSleepFailReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvSleepFailReason>() {
            public EmNvSleepFailReason findValueByNumber(int number) {
              return EmNvSleepFailReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(53);
    }

    private static final EmNvSleepFailReason[] VALUES = values();

    public static EmNvSleepFailReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvSleepFailReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvSleepFailReason)
  }

  /**
   * Protobuf enum {@code nv.EmNvTimeZone}
   *
   * <pre>
   *时区选项内容
   * </pre>
   */
  public enum EmNvTimeZone
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvTimeZone_GMT = 0;</code>
     *
     * <pre>
     * 格林威治标准时间 GMT
     * </pre>
     */
    emNvTimeZone_GMT(0, 0),
    /**
     * <code>emNvTimeZone_UTC = 1;</code>
     *
     * <pre>
     * 全球标准时间 GMT 
     * </pre>
     */
    emNvTimeZone_UTC(1, 1),
    /**
     * <code>emNvTimeZone_ECT = 2;</code>
     *
     * <pre>
     *欧洲中部时间 GMT+1:00 
     * </pre>
     */
    emNvTimeZone_ECT(2, 2),
    /**
     * <code>emNvTimeZone_EET = 3;</code>
     *
     * <pre>
     *东欧时间 GMT+2:00 
     * </pre>
     */
    emNvTimeZone_EET(3, 3),
    /**
     * <code>emNvTimeZone_ART = 4;</code>
     *
     * <pre>
     *（阿拉伯）埃及标准时间 GMT+2:00
     * </pre>
     */
    emNvTimeZone_ART(4, 4),
    /**
     * <code>emNvTimeZone_EAT = 5;</code>
     *
     * <pre>
     *东非时间 GMT+3:00 
     * </pre>
     */
    emNvTimeZone_EAT(5, 5),
    /**
     * <code>emNvTimeZone_MET = 6;</code>
     *
     * <pre>
     *中东时间 GMT+3:30 
     * </pre>
     */
    emNvTimeZone_MET(6, 6),
    /**
     * <code>emNvTimeZone_NET = 7;</code>
     *
     * <pre>
     *近东时间 GMT+4:00 
     * </pre>
     */
    emNvTimeZone_NET(7, 7),
    /**
     * <code>emNvTimeZone_PLT = 8;</code>
     *
     * <pre>
     *巴基斯坦拉合尔时间 GMT+5:00 
     * </pre>
     */
    emNvTimeZone_PLT(8, 8),
    /**
     * <code>emNvTimeZone_IST = 9;</code>
     *
     * <pre>
     *印度标准时间 GMT+5:30 
     * </pre>
     */
    emNvTimeZone_IST(9, 9),
    /**
     * <code>emNvTimeZone_BST = 10;</code>
     *
     * <pre>
     *孟加拉国标准时间 GMT+6:00 
     * </pre>
     */
    emNvTimeZone_BST(10, 10),
    /**
     * <code>emNvTimeZone_VST = 11;</code>
     *
     * <pre>
     *越南标准时间 GMT+7:00 
     * </pre>
     */
    emNvTimeZone_VST(11, 11),
    /**
     * <code>emNvTimeZone_CTT = 12;</code>
     *
     * <pre>
     *中国北京时间 GMT+8:00 
     * </pre>
     */
    emNvTimeZone_CTT(12, 12),
    /**
     * <code>emNvTimeZone_JST = 13;</code>
     *
     * <pre>
     *日本标准时间 GMT+9:00 
     * </pre>
     */
    emNvTimeZone_JST(13, 13),
    /**
     * <code>emNvTimeZone_ACT = 14;</code>
     *
     * <pre>
     *澳大利亚中部时间 GMT+9:30 
     * </pre>
     */
    emNvTimeZone_ACT(14, 14),
    /**
     * <code>emNvTimeZone_AET = 15;</code>
     *
     * <pre>
     *澳大利亚东部时间 GMT+10:00
     * </pre>
     */
    emNvTimeZone_AET(15, 15),
    /**
     * <code>emNvTimeZone_SST = 16;</code>
     *
     * <pre>
     *所罗门标准时间 GMT+11:00 
     * </pre>
     */
    emNvTimeZone_SST(16, 16),
    /**
     * <code>emNvTimeZone_NST = 17;</code>
     *
     * <pre>
     *新西兰标准时间 GMT+12:00 
     * </pre>
     */
    emNvTimeZone_NST(17, 17),
    /**
     * <code>emNvTimeZone_MIT = 18;</code>
     *
     * <pre>
     *中途岛时间 GMT-11:00 
     * </pre>
     */
    emNvTimeZone_MIT(18, 18),
    /**
     * <code>emNvTimeZone_HST = 19;</code>
     *
     * <pre>
     *夏威夷标准时间 GMT-10:00 
     * </pre>
     */
    emNvTimeZone_HST(19, 19),
    /**
     * <code>emNvTimeZone_AST = 20;</code>
     *
     * <pre>
     *阿拉斯加标准时间 GMT-9:00 
     * </pre>
     */
    emNvTimeZone_AST(20, 20),
    /**
     * <code>emNvTimeZone_PST = 21;</code>
     *
     * <pre>
     *太平洋标准时间 GMT-8:00 
     * </pre>
     */
    emNvTimeZone_PST(21, 21),
    /**
     * <code>emNvTimeZone_PNT = 22;</code>
     *
     * <pre>
     *菲尼克斯标准时间 GMT-7:00 
     * </pre>
     */
    emNvTimeZone_PNT(22, 22),
    /**
     * <code>emNvTimeZone_MST = 23;</code>
     *
     * <pre>
     *西部山脉标准时间 GMT-7:00 
     * </pre>
     */
    emNvTimeZone_MST(23, 23),
    /**
     * <code>emNvTimeZone_CST = 24;</code>
     *
     * <pre>
     *中部标准时间 GMT-6:00 
     * </pre>
     */
    emNvTimeZone_CST(24, 24),
    /**
     * <code>emNvTimeZone_EST = 25;</code>
     *
     * <pre>
     *东部标准时间 GMT-5:00 
     * </pre>
     */
    emNvTimeZone_EST(25, 25),
    /**
     * <code>emNvTimeZone_IET = 26;</code>
     *
     * <pre>
     *印第安那东部标准时间 GMT-5:00 
     * </pre>
     */
    emNvTimeZone_IET(26, 26),
    /**
     * <code>emNvTimeZone_PRT = 27;</code>
     *
     * <pre>
     *波多黎各和美属维尔京群岛时间 GMT-4:00 
     * </pre>
     */
    emNvTimeZone_PRT(27, 27),
    /**
     * <code>emNvTimeZone_CNT = 28;</code>
     *
     * <pre>
     *加拿大纽芬兰时间 GMT-3:30 
     * </pre>
     */
    emNvTimeZone_CNT(28, 28),
    /**
     * <code>emNvTimeZone_AGT = 29;</code>
     *
     * <pre>
     *阿根廷标准时间 GMT-3:00 
     * </pre>
     */
    emNvTimeZone_AGT(29, 29),
    /**
     * <code>emNvTimeZone_BET = 30;</code>
     *
     * <pre>
     *巴西东部时间 GMT-3:00 
     * </pre>
     */
    emNvTimeZone_BET(30, 30),
    /**
     * <code>emNvTimeZone_CAT = 31;</code>
     *
     * <pre>
     *中非时间 GMT-1:00
     * </pre>
     */
    emNvTimeZone_CAT(31, 31),
    ;

    /**
     * <code>emNvTimeZone_GMT = 0;</code>
     *
     * <pre>
     * 格林威治标准时间 GMT
     * </pre>
     */
    public static final int emNvTimeZone_GMT_VALUE = 0;
    /**
     * <code>emNvTimeZone_UTC = 1;</code>
     *
     * <pre>
     * 全球标准时间 GMT 
     * </pre>
     */
    public static final int emNvTimeZone_UTC_VALUE = 1;
    /**
     * <code>emNvTimeZone_ECT = 2;</code>
     *
     * <pre>
     *欧洲中部时间 GMT+1:00 
     * </pre>
     */
    public static final int emNvTimeZone_ECT_VALUE = 2;
    /**
     * <code>emNvTimeZone_EET = 3;</code>
     *
     * <pre>
     *东欧时间 GMT+2:00 
     * </pre>
     */
    public static final int emNvTimeZone_EET_VALUE = 3;
    /**
     * <code>emNvTimeZone_ART = 4;</code>
     *
     * <pre>
     *（阿拉伯）埃及标准时间 GMT+2:00
     * </pre>
     */
    public static final int emNvTimeZone_ART_VALUE = 4;
    /**
     * <code>emNvTimeZone_EAT = 5;</code>
     *
     * <pre>
     *东非时间 GMT+3:00 
     * </pre>
     */
    public static final int emNvTimeZone_EAT_VALUE = 5;
    /**
     * <code>emNvTimeZone_MET = 6;</code>
     *
     * <pre>
     *中东时间 GMT+3:30 
     * </pre>
     */
    public static final int emNvTimeZone_MET_VALUE = 6;
    /**
     * <code>emNvTimeZone_NET = 7;</code>
     *
     * <pre>
     *近东时间 GMT+4:00 
     * </pre>
     */
    public static final int emNvTimeZone_NET_VALUE = 7;
    /**
     * <code>emNvTimeZone_PLT = 8;</code>
     *
     * <pre>
     *巴基斯坦拉合尔时间 GMT+5:00 
     * </pre>
     */
    public static final int emNvTimeZone_PLT_VALUE = 8;
    /**
     * <code>emNvTimeZone_IST = 9;</code>
     *
     * <pre>
     *印度标准时间 GMT+5:30 
     * </pre>
     */
    public static final int emNvTimeZone_IST_VALUE = 9;
    /**
     * <code>emNvTimeZone_BST = 10;</code>
     *
     * <pre>
     *孟加拉国标准时间 GMT+6:00 
     * </pre>
     */
    public static final int emNvTimeZone_BST_VALUE = 10;
    /**
     * <code>emNvTimeZone_VST = 11;</code>
     *
     * <pre>
     *越南标准时间 GMT+7:00 
     * </pre>
     */
    public static final int emNvTimeZone_VST_VALUE = 11;
    /**
     * <code>emNvTimeZone_CTT = 12;</code>
     *
     * <pre>
     *中国北京时间 GMT+8:00 
     * </pre>
     */
    public static final int emNvTimeZone_CTT_VALUE = 12;
    /**
     * <code>emNvTimeZone_JST = 13;</code>
     *
     * <pre>
     *日本标准时间 GMT+9:00 
     * </pre>
     */
    public static final int emNvTimeZone_JST_VALUE = 13;
    /**
     * <code>emNvTimeZone_ACT = 14;</code>
     *
     * <pre>
     *澳大利亚中部时间 GMT+9:30 
     * </pre>
     */
    public static final int emNvTimeZone_ACT_VALUE = 14;
    /**
     * <code>emNvTimeZone_AET = 15;</code>
     *
     * <pre>
     *澳大利亚东部时间 GMT+10:00
     * </pre>
     */
    public static final int emNvTimeZone_AET_VALUE = 15;
    /**
     * <code>emNvTimeZone_SST = 16;</code>
     *
     * <pre>
     *所罗门标准时间 GMT+11:00 
     * </pre>
     */
    public static final int emNvTimeZone_SST_VALUE = 16;
    /**
     * <code>emNvTimeZone_NST = 17;</code>
     *
     * <pre>
     *新西兰标准时间 GMT+12:00 
     * </pre>
     */
    public static final int emNvTimeZone_NST_VALUE = 17;
    /**
     * <code>emNvTimeZone_MIT = 18;</code>
     *
     * <pre>
     *中途岛时间 GMT-11:00 
     * </pre>
     */
    public static final int emNvTimeZone_MIT_VALUE = 18;
    /**
     * <code>emNvTimeZone_HST = 19;</code>
     *
     * <pre>
     *夏威夷标准时间 GMT-10:00 
     * </pre>
     */
    public static final int emNvTimeZone_HST_VALUE = 19;
    /**
     * <code>emNvTimeZone_AST = 20;</code>
     *
     * <pre>
     *阿拉斯加标准时间 GMT-9:00 
     * </pre>
     */
    public static final int emNvTimeZone_AST_VALUE = 20;
    /**
     * <code>emNvTimeZone_PST = 21;</code>
     *
     * <pre>
     *太平洋标准时间 GMT-8:00 
     * </pre>
     */
    public static final int emNvTimeZone_PST_VALUE = 21;
    /**
     * <code>emNvTimeZone_PNT = 22;</code>
     *
     * <pre>
     *菲尼克斯标准时间 GMT-7:00 
     * </pre>
     */
    public static final int emNvTimeZone_PNT_VALUE = 22;
    /**
     * <code>emNvTimeZone_MST = 23;</code>
     *
     * <pre>
     *西部山脉标准时间 GMT-7:00 
     * </pre>
     */
    public static final int emNvTimeZone_MST_VALUE = 23;
    /**
     * <code>emNvTimeZone_CST = 24;</code>
     *
     * <pre>
     *中部标准时间 GMT-6:00 
     * </pre>
     */
    public static final int emNvTimeZone_CST_VALUE = 24;
    /**
     * <code>emNvTimeZone_EST = 25;</code>
     *
     * <pre>
     *东部标准时间 GMT-5:00 
     * </pre>
     */
    public static final int emNvTimeZone_EST_VALUE = 25;
    /**
     * <code>emNvTimeZone_IET = 26;</code>
     *
     * <pre>
     *印第安那东部标准时间 GMT-5:00 
     * </pre>
     */
    public static final int emNvTimeZone_IET_VALUE = 26;
    /**
     * <code>emNvTimeZone_PRT = 27;</code>
     *
     * <pre>
     *波多黎各和美属维尔京群岛时间 GMT-4:00 
     * </pre>
     */
    public static final int emNvTimeZone_PRT_VALUE = 27;
    /**
     * <code>emNvTimeZone_CNT = 28;</code>
     *
     * <pre>
     *加拿大纽芬兰时间 GMT-3:30 
     * </pre>
     */
    public static final int emNvTimeZone_CNT_VALUE = 28;
    /**
     * <code>emNvTimeZone_AGT = 29;</code>
     *
     * <pre>
     *阿根廷标准时间 GMT-3:00 
     * </pre>
     */
    public static final int emNvTimeZone_AGT_VALUE = 29;
    /**
     * <code>emNvTimeZone_BET = 30;</code>
     *
     * <pre>
     *巴西东部时间 GMT-3:00 
     * </pre>
     */
    public static final int emNvTimeZone_BET_VALUE = 30;
    /**
     * <code>emNvTimeZone_CAT = 31;</code>
     *
     * <pre>
     *中非时间 GMT-1:00
     * </pre>
     */
    public static final int emNvTimeZone_CAT_VALUE = 31;


    public final int getNumber() { return value; }

    public static EmNvTimeZone valueOf(int value) {
      switch (value) {
        case 0: return emNvTimeZone_GMT;
        case 1: return emNvTimeZone_UTC;
        case 2: return emNvTimeZone_ECT;
        case 3: return emNvTimeZone_EET;
        case 4: return emNvTimeZone_ART;
        case 5: return emNvTimeZone_EAT;
        case 6: return emNvTimeZone_MET;
        case 7: return emNvTimeZone_NET;
        case 8: return emNvTimeZone_PLT;
        case 9: return emNvTimeZone_IST;
        case 10: return emNvTimeZone_BST;
        case 11: return emNvTimeZone_VST;
        case 12: return emNvTimeZone_CTT;
        case 13: return emNvTimeZone_JST;
        case 14: return emNvTimeZone_ACT;
        case 15: return emNvTimeZone_AET;
        case 16: return emNvTimeZone_SST;
        case 17: return emNvTimeZone_NST;
        case 18: return emNvTimeZone_MIT;
        case 19: return emNvTimeZone_HST;
        case 20: return emNvTimeZone_AST;
        case 21: return emNvTimeZone_PST;
        case 22: return emNvTimeZone_PNT;
        case 23: return emNvTimeZone_MST;
        case 24: return emNvTimeZone_CST;
        case 25: return emNvTimeZone_EST;
        case 26: return emNvTimeZone_IET;
        case 27: return emNvTimeZone_PRT;
        case 28: return emNvTimeZone_CNT;
        case 29: return emNvTimeZone_AGT;
        case 30: return emNvTimeZone_BET;
        case 31: return emNvTimeZone_CAT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvTimeZone>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvTimeZone>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvTimeZone>() {
            public EmNvTimeZone findValueByNumber(int number) {
              return EmNvTimeZone.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(54);
    }

    private static final EmNvTimeZone[] VALUES = values();

    public static EmNvTimeZone valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvTimeZone(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvTimeZone)
  }

  /**
   * Protobuf enum {@code nv.EmNvDevRegUpdateSer}
   */
  public enum EmNvDevRegUpdateSer
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvDevInvalid = 0;</code>
     */
    emNvDevInvalid(0, 0),
    /**
     * <code>emNvIMIX = 1;</code>
     */
    emNvIMIX(1, 1),
    /**
     * <code>emNvTPad = 2;</code>
     */
    emNvTPad(2, 2),
    /**
     * <code>emNvQuickShare = 3;</code>
     */
    emNvQuickShare(3, 3),
    /**
     * <code>emNvPower = 4;</code>
     */
    emNvPower(4, 4),
    ;

    /**
     * <code>emNvDevInvalid = 0;</code>
     */
    public static final int emNvDevInvalid_VALUE = 0;
    /**
     * <code>emNvIMIX = 1;</code>
     */
    public static final int emNvIMIX_VALUE = 1;
    /**
     * <code>emNvTPad = 2;</code>
     */
    public static final int emNvTPad_VALUE = 2;
    /**
     * <code>emNvQuickShare = 3;</code>
     */
    public static final int emNvQuickShare_VALUE = 3;
    /**
     * <code>emNvPower = 4;</code>
     */
    public static final int emNvPower_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmNvDevRegUpdateSer valueOf(int value) {
      switch (value) {
        case 0: return emNvDevInvalid;
        case 1: return emNvIMIX;
        case 2: return emNvTPad;
        case 3: return emNvQuickShare;
        case 4: return emNvPower;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvDevRegUpdateSer>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvDevRegUpdateSer>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvDevRegUpdateSer>() {
            public EmNvDevRegUpdateSer findValueByNumber(int number) {
              return EmNvDevRegUpdateSer.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(55);
    }

    private static final EmNvDevRegUpdateSer[] VALUES = values();

    public static EmNvDevRegUpdateSer valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvDevRegUpdateSer(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvDevRegUpdateSer)
  }

  /**
   * Protobuf enum {@code nv.EmNvUpdateType}
   */
  public enum EmNvUpdateType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvUpdateForced = 0;</code>
     *
     * <pre>
     *强制升级
     * </pre>
     */
    emNvUpdateForced(0, 0),
    /**
     * <code>emNvUpdateSelected = 1;</code>
     *
     * <pre>
     *选择升级
     * </pre>
     */
    emNvUpdateSelected(1, 1),
    ;

    /**
     * <code>emNvUpdateForced = 0;</code>
     *
     * <pre>
     *强制升级
     * </pre>
     */
    public static final int emNvUpdateForced_VALUE = 0;
    /**
     * <code>emNvUpdateSelected = 1;</code>
     *
     * <pre>
     *选择升级
     * </pre>
     */
    public static final int emNvUpdateSelected_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmNvUpdateType valueOf(int value) {
      switch (value) {
        case 0: return emNvUpdateForced;
        case 1: return emNvUpdateSelected;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvUpdateType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvUpdateType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvUpdateType>() {
            public EmNvUpdateType findValueByNumber(int number) {
              return EmNvUpdateType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(56);
    }

    private static final EmNvUpdateType[] VALUES = values();

    public static EmNvUpdateType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvUpdateType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvUpdateType)
  }

  /**
   * Protobuf enum {@code nv.EmNvCnLoginUpdateRet}
   *
   * <pre>
   *cn登录升级服务器的结果
   * </pre>
   */
  public enum EmNvCnLoginUpdateRet
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvCnLoginUpdateInvalid = 0;</code>
     */
    emNvCnLoginUpdateInvalid(0, 0),
    /**
     * <code>emNvCnLoginUpdateFail = 1;</code>
     */
    emNvCnLoginUpdateFail(1, 1),
    /**
     * <code>emNvCnLoginUpdateSuccess = 2;</code>
     */
    emNvCnLoginUpdateSuccess(2, 2),
    ;

    /**
     * <code>emNvCnLoginUpdateInvalid = 0;</code>
     */
    public static final int emNvCnLoginUpdateInvalid_VALUE = 0;
    /**
     * <code>emNvCnLoginUpdateFail = 1;</code>
     */
    public static final int emNvCnLoginUpdateFail_VALUE = 1;
    /**
     * <code>emNvCnLoginUpdateSuccess = 2;</code>
     */
    public static final int emNvCnLoginUpdateSuccess_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvCnLoginUpdateRet valueOf(int value) {
      switch (value) {
        case 0: return emNvCnLoginUpdateInvalid;
        case 1: return emNvCnLoginUpdateFail;
        case 2: return emNvCnLoginUpdateSuccess;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvCnLoginUpdateRet>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvCnLoginUpdateRet>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvCnLoginUpdateRet>() {
            public EmNvCnLoginUpdateRet findValueByNumber(int number) {
              return EmNvCnLoginUpdateRet.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(57);
    }

    private static final EmNvCnLoginUpdateRet[] VALUES = values();

    public static EmNvCnLoginUpdateRet valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvCnLoginUpdateRet(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvCnLoginUpdateRet)
  }

  /**
   * Protobuf enum {@code nv.EmNvScreenColorTemperature}
   *
   * <pre>
   *显示器色温
   * </pre>
   */
  public enum EmNvScreenColorTemperature
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvCT_Standard = 0;</code>
     *
     * <pre>
     *标准
     * </pre>
     */
    emNvCT_Standard(0, 0),
    /**
     * <code>emNvCT_Rathercold = 1;</code>
     *
     * <pre>
     *偏冷
     * </pre>
     */
    emNvCT_Rathercold(1, 1),
    /**
     * <code>emNvCT_Warm = 2;</code>
     *
     * <pre>
     *偏暖
     * </pre>
     */
    emNvCT_Warm(2, 2),
    ;

    /**
     * <code>emNvCT_Standard = 0;</code>
     *
     * <pre>
     *标准
     * </pre>
     */
    public static final int emNvCT_Standard_VALUE = 0;
    /**
     * <code>emNvCT_Rathercold = 1;</code>
     *
     * <pre>
     *偏冷
     * </pre>
     */
    public static final int emNvCT_Rathercold_VALUE = 1;
    /**
     * <code>emNvCT_Warm = 2;</code>
     *
     * <pre>
     *偏暖
     * </pre>
     */
    public static final int emNvCT_Warm_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvScreenColorTemperature valueOf(int value) {
      switch (value) {
        case 0: return emNvCT_Standard;
        case 1: return emNvCT_Rathercold;
        case 2: return emNvCT_Warm;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvScreenColorTemperature>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvScreenColorTemperature>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvScreenColorTemperature>() {
            public EmNvScreenColorTemperature findValueByNumber(int number) {
              return EmNvScreenColorTemperature.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(58);
    }

    private static final EmNvScreenColorTemperature[] VALUES = values();

    public static EmNvScreenColorTemperature valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvScreenColorTemperature(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvScreenColorTemperature)
  }

  /**
   * Protobuf enum {@code nv.EmNvScreenType}
   */
  public enum EmNvScreenType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvSc_Right = 0;</code>
     */
    emNvSc_Right(0, 0),
    /**
     * <code>emNvSc_Left = 1;</code>
     */
    emNvSc_Left(1, 1),
    ;

    /**
     * <code>emNvSc_Right = 0;</code>
     */
    public static final int emNvSc_Right_VALUE = 0;
    /**
     * <code>emNvSc_Left = 1;</code>
     */
    public static final int emNvSc_Left_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmNvScreenType valueOf(int value) {
      switch (value) {
        case 0: return emNvSc_Right;
        case 1: return emNvSc_Left;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvScreenType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvScreenType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvScreenType>() {
            public EmNvScreenType findValueByNumber(int number) {
              return EmNvScreenType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(59);
    }

    private static final EmNvScreenType[] VALUES = values();

    public static EmNvScreenType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvScreenType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvScreenType)
  }

  /**
   * Protobuf enum {@code nv.EmNvSubModel}
   *
   * <pre>
   *终端子型号
   * </pre>
   */
  public enum EmNvSubModel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvSubModelBegin = 0;</code>
     *
     * <pre>
     *无效值，
     * </pre>
     */
    emNvSubModelBegin(0, 0),
    /**
     * <code>emNvSub_NEX1110A_55 = 1;</code>
     */
    emNvSub_NEX1110A_55(1, 1),
    /**
     * <code>emNvSub_NEX1110A_65 = 2;</code>
     */
    emNvSub_NEX1110A_65(2, 2),
    /**
     * <code>emNvSub_NEX1110A_75 = 3;</code>
     */
    emNvSub_NEX1110A_75(3, 3),
    /**
     * <code>emNvSub_NEX1210A_55 = 4;</code>
     */
    emNvSub_NEX1210A_55(4, 4),
    /**
     * <code>emNvSub_NEX1210A_65 = 5;</code>
     */
    emNvSub_NEX1210A_65(5, 5),
    /**
     * <code>emNvSub_NEX1210A_75 = 6;</code>
     */
    emNvSub_NEX1210A_75(6, 6),
    /**
     * <code>emNvSub_NEX1110B_55 = 7;</code>
     */
    emNvSub_NEX1110B_55(7, 7),
    /**
     * <code>emNvSub_NEX1210B_55 = 8;</code>
     */
    emNvSub_NEX1210B_55(8, 8),
    /**
     * <code>emNvSub_NEX1110A_55T = 9;</code>
     */
    emNvSub_NEX1110A_55T(9, 9),
    /**
     * <code>emNvSub_NEX1110A_65T = 10;</code>
     */
    emNvSub_NEX1110A_65T(10, 10),
    /**
     * <code>emNvSub_NEX1110A_75T = 11;</code>
     */
    emNvSub_NEX1110A_75T(11, 11),
    /**
     * <code>emNvSub_NEX1210A_55T = 12;</code>
     */
    emNvSub_NEX1210A_55T(12, 12),
    /**
     * <code>emNvSub_NEX1210A_65T = 13;</code>
     */
    emNvSub_NEX1210A_65T(13, 13),
    /**
     * <code>emNvSub_NEX1210A_75T = 14;</code>
     */
    emNvSub_NEX1210A_75T(14, 14),
    /**
     * <code>emNvSub_NEX1210H_75 = 15;</code>
     */
    emNvSub_NEX1210H_75(15, 15),
    /**
     * <code>emNvSub_NEX1210H_75T = 16;</code>
     */
    emNvSub_NEX1210H_75T(16, 16),
    /**
     * <code>emNvSub_NEX1310E_75 = 17;</code>
     */
    emNvSub_NEX1310E_75(17, 17),
    ;

    /**
     * <code>emNvSubModelBegin = 0;</code>
     *
     * <pre>
     *无效值，
     * </pre>
     */
    public static final int emNvSubModelBegin_VALUE = 0;
    /**
     * <code>emNvSub_NEX1110A_55 = 1;</code>
     */
    public static final int emNvSub_NEX1110A_55_VALUE = 1;
    /**
     * <code>emNvSub_NEX1110A_65 = 2;</code>
     */
    public static final int emNvSub_NEX1110A_65_VALUE = 2;
    /**
     * <code>emNvSub_NEX1110A_75 = 3;</code>
     */
    public static final int emNvSub_NEX1110A_75_VALUE = 3;
    /**
     * <code>emNvSub_NEX1210A_55 = 4;</code>
     */
    public static final int emNvSub_NEX1210A_55_VALUE = 4;
    /**
     * <code>emNvSub_NEX1210A_65 = 5;</code>
     */
    public static final int emNvSub_NEX1210A_65_VALUE = 5;
    /**
     * <code>emNvSub_NEX1210A_75 = 6;</code>
     */
    public static final int emNvSub_NEX1210A_75_VALUE = 6;
    /**
     * <code>emNvSub_NEX1110B_55 = 7;</code>
     */
    public static final int emNvSub_NEX1110B_55_VALUE = 7;
    /**
     * <code>emNvSub_NEX1210B_55 = 8;</code>
     */
    public static final int emNvSub_NEX1210B_55_VALUE = 8;
    /**
     * <code>emNvSub_NEX1110A_55T = 9;</code>
     */
    public static final int emNvSub_NEX1110A_55T_VALUE = 9;
    /**
     * <code>emNvSub_NEX1110A_65T = 10;</code>
     */
    public static final int emNvSub_NEX1110A_65T_VALUE = 10;
    /**
     * <code>emNvSub_NEX1110A_75T = 11;</code>
     */
    public static final int emNvSub_NEX1110A_75T_VALUE = 11;
    /**
     * <code>emNvSub_NEX1210A_55T = 12;</code>
     */
    public static final int emNvSub_NEX1210A_55T_VALUE = 12;
    /**
     * <code>emNvSub_NEX1210A_65T = 13;</code>
     */
    public static final int emNvSub_NEX1210A_65T_VALUE = 13;
    /**
     * <code>emNvSub_NEX1210A_75T = 14;</code>
     */
    public static final int emNvSub_NEX1210A_75T_VALUE = 14;
    /**
     * <code>emNvSub_NEX1210H_75 = 15;</code>
     */
    public static final int emNvSub_NEX1210H_75_VALUE = 15;
    /**
     * <code>emNvSub_NEX1210H_75T = 16;</code>
     */
    public static final int emNvSub_NEX1210H_75T_VALUE = 16;
    /**
     * <code>emNvSub_NEX1310E_75 = 17;</code>
     */
    public static final int emNvSub_NEX1310E_75_VALUE = 17;


    public final int getNumber() { return value; }

    public static EmNvSubModel valueOf(int value) {
      switch (value) {
        case 0: return emNvSubModelBegin;
        case 1: return emNvSub_NEX1110A_55;
        case 2: return emNvSub_NEX1110A_65;
        case 3: return emNvSub_NEX1110A_75;
        case 4: return emNvSub_NEX1210A_55;
        case 5: return emNvSub_NEX1210A_65;
        case 6: return emNvSub_NEX1210A_75;
        case 7: return emNvSub_NEX1110B_55;
        case 8: return emNvSub_NEX1210B_55;
        case 9: return emNvSub_NEX1110A_55T;
        case 10: return emNvSub_NEX1110A_65T;
        case 11: return emNvSub_NEX1110A_75T;
        case 12: return emNvSub_NEX1210A_55T;
        case 13: return emNvSub_NEX1210A_65T;
        case 14: return emNvSub_NEX1210A_75T;
        case 15: return emNvSub_NEX1210H_75;
        case 16: return emNvSub_NEX1210H_75T;
        case 17: return emNvSub_NEX1310E_75;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvSubModel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvSubModel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvSubModel>() {
            public EmNvSubModel findValueByNumber(int number) {
              return EmNvSubModel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(60);
    }

    private static final EmNvSubModel[] VALUES = values();

    public static EmNvSubModel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvSubModel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvSubModel)
  }

  /**
   * Protobuf enum {@code nv.EmNvTvDisplayRatio}
   */
  public enum EmNvTvDisplayRatio
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvTvDR16to9 = 0;</code>
     */
    emNvTvDR16to9(0, 0),
    /**
     * <code>emNvTvDRFull = 1;</code>
     */
    emNvTvDRFull(1, 1),
    /**
     * <code>emNvTvDR4to3 = 2;</code>
     */
    emNvTvDR4to3(2, 2),
    ;

    /**
     * <code>emNvTvDR16to9 = 0;</code>
     */
    public static final int emNvTvDR16to9_VALUE = 0;
    /**
     * <code>emNvTvDRFull = 1;</code>
     */
    public static final int emNvTvDRFull_VALUE = 1;
    /**
     * <code>emNvTvDR4to3 = 2;</code>
     */
    public static final int emNvTvDR4to3_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvTvDisplayRatio valueOf(int value) {
      switch (value) {
        case 0: return emNvTvDR16to9;
        case 1: return emNvTvDRFull;
        case 2: return emNvTvDR4to3;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvTvDisplayRatio>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvTvDisplayRatio>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvTvDisplayRatio>() {
            public EmNvTvDisplayRatio findValueByNumber(int number) {
              return EmNvTvDisplayRatio.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(61);
    }

    private static final EmNvTvDisplayRatio[] VALUES = values();

    public static EmNvTvDisplayRatio valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvTvDisplayRatio(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvTvDisplayRatio)
  }

  /**
   * Protobuf enum {@code nv.EmNvViewReason}
   */
  public enum EmNvViewReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvView_Success = 0;</code>
     */
    emNvView_Success(0, 0),
    /**
     * <code>emNvView_NoSignal = 1;</code>
     */
    emNvView_NoSignal(1, 1),
    /**
     * <code>emNvView_Offline = 2;</code>
     */
    emNvView_Offline(2, 2),
    /**
     * <code>emNvView_UnknowReason = 3;</code>
     */
    emNvView_UnknowReason(3, 3),
    /**
     * <code>emNvView_NotViewed = 4;</code>
     */
    emNvView_NotViewed(4, 4),
    /**
     * <code>emNvView_OverFormat = 5;</code>
     *
     * <pre>
     *分辨率过大
     * </pre>
     */
    emNvView_OverFormat(5, 5),
    /**
     * <code>emNvView_OpsNoSignal = 6;</code>
     *
     * <pre>
     *ops无信号
     * </pre>
     */
    emNvView_OpsNoSignal(6, 6),
    ;

    /**
     * <code>emNvView_Success = 0;</code>
     */
    public static final int emNvView_Success_VALUE = 0;
    /**
     * <code>emNvView_NoSignal = 1;</code>
     */
    public static final int emNvView_NoSignal_VALUE = 1;
    /**
     * <code>emNvView_Offline = 2;</code>
     */
    public static final int emNvView_Offline_VALUE = 2;
    /**
     * <code>emNvView_UnknowReason = 3;</code>
     */
    public static final int emNvView_UnknowReason_VALUE = 3;
    /**
     * <code>emNvView_NotViewed = 4;</code>
     */
    public static final int emNvView_NotViewed_VALUE = 4;
    /**
     * <code>emNvView_OverFormat = 5;</code>
     *
     * <pre>
     *分辨率过大
     * </pre>
     */
    public static final int emNvView_OverFormat_VALUE = 5;
    /**
     * <code>emNvView_OpsNoSignal = 6;</code>
     *
     * <pre>
     *ops无信号
     * </pre>
     */
    public static final int emNvView_OpsNoSignal_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmNvViewReason valueOf(int value) {
      switch (value) {
        case 0: return emNvView_Success;
        case 1: return emNvView_NoSignal;
        case 2: return emNvView_Offline;
        case 3: return emNvView_UnknowReason;
        case 4: return emNvView_NotViewed;
        case 5: return emNvView_OverFormat;
        case 6: return emNvView_OpsNoSignal;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvViewReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvViewReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvViewReason>() {
            public EmNvViewReason findValueByNumber(int number) {
              return EmNvViewReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(62);
    }

    private static final EmNvViewReason[] VALUES = values();

    public static EmNvViewReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvViewReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvViewReason)
  }

  /**
   * Protobuf enum {@code nv.EmNvEncodeMode}
   */
  public enum EmNvEncodeMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvQualityFirst = 0;</code>
     */
    emNvQualityFirst(0, 0),
    /**
     * <code>emNvSpeedFirst = 1;</code>
     */
    emNvSpeedFirst(1, 1),
    ;

    /**
     * <code>emNvQualityFirst = 0;</code>
     */
    public static final int emNvQualityFirst_VALUE = 0;
    /**
     * <code>emNvSpeedFirst = 1;</code>
     */
    public static final int emNvSpeedFirst_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmNvEncodeMode valueOf(int value) {
      switch (value) {
        case 0: return emNvQualityFirst;
        case 1: return emNvSpeedFirst;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvEncodeMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvEncodeMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvEncodeMode>() {
            public EmNvEncodeMode findValueByNumber(int number) {
              return EmNvEncodeMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(63);
    }

    private static final EmNvEncodeMode[] VALUES = values();

    public static EmNvEncodeMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvEncodeMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvEncodeMode)
  }

  /**
   * Protobuf enum {@code nv.EmNvPowerTurnOffReason}
   */
  public enum EmNvPowerTurnOffReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvTurnOffReason_Success = 0;</code>
     */
    emNvTurnOffReason_Success(0, 0),
    /**
     * <code>emNvTurnOffReason_Upgrade = 1;</code>
     *
     * <pre>
     *系统正在升级
     * </pre>
     */
    emNvTurnOffReason_Upgrade(1, 1),
    /**
     * <code>emNvTurnOffReason_OpsFailed = 2;</code>
     *
     * <pre>
     *ops关机失败
     * </pre>
     */
    emNvTurnOffReason_OpsFailed(2, 2),
    /**
     * <code>emNvTurnOffReason_Conf = 3;</code>
     *
     * <pre>
     *会议中
     * </pre>
     */
    emNvTurnOffReason_Conf(3, 3),
    /**
     * <code>emNvTurnOffReason_QkUpgrade = 4;</code>
     *
     * <pre>
     *投屏器正在升级
     * </pre>
     */
    emNvTurnOffReason_QkUpgrade(4, 4),
    ;

    /**
     * <code>emNvTurnOffReason_Success = 0;</code>
     */
    public static final int emNvTurnOffReason_Success_VALUE = 0;
    /**
     * <code>emNvTurnOffReason_Upgrade = 1;</code>
     *
     * <pre>
     *系统正在升级
     * </pre>
     */
    public static final int emNvTurnOffReason_Upgrade_VALUE = 1;
    /**
     * <code>emNvTurnOffReason_OpsFailed = 2;</code>
     *
     * <pre>
     *ops关机失败
     * </pre>
     */
    public static final int emNvTurnOffReason_OpsFailed_VALUE = 2;
    /**
     * <code>emNvTurnOffReason_Conf = 3;</code>
     *
     * <pre>
     *会议中
     * </pre>
     */
    public static final int emNvTurnOffReason_Conf_VALUE = 3;
    /**
     * <code>emNvTurnOffReason_QkUpgrade = 4;</code>
     *
     * <pre>
     *投屏器正在升级
     * </pre>
     */
    public static final int emNvTurnOffReason_QkUpgrade_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmNvPowerTurnOffReason valueOf(int value) {
      switch (value) {
        case 0: return emNvTurnOffReason_Success;
        case 1: return emNvTurnOffReason_Upgrade;
        case 2: return emNvTurnOffReason_OpsFailed;
        case 3: return emNvTurnOffReason_Conf;
        case 4: return emNvTurnOffReason_QkUpgrade;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvPowerTurnOffReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvPowerTurnOffReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvPowerTurnOffReason>() {
            public EmNvPowerTurnOffReason findValueByNumber(int number) {
              return EmNvPowerTurnOffReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(64);
    }

    private static final EmNvPowerTurnOffReason[] VALUES = values();

    public static EmNvPowerTurnOffReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvPowerTurnOffReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvPowerTurnOffReason)
  }

  /**
   * Protobuf enum {@code nv.EmNvAudPortIn}
   *
   * <pre>
   *音频输入接口
   * </pre>
   */
  public enum EmNvAudPortIn
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvAudIn_HDMI0 = 0;</code>
     *
     * <pre>
     *IMix
     * </pre>
     */
    emNvAudIn_HDMI0(0, 0),
    /**
     * <code>emNvAudIn_HDMI1 = 1;</code>
     *
     * <pre>
     *OPSTV port a
     * </pre>
     */
    emNvAudIn_HDMI1(1, 1),
    /**
     * <code>emNvAudIn_HDMI2 = 2;</code>
     *
     * <pre>
     *Treminal
     * </pre>
     */
    emNvAudIn_HDMI2(2, 2),
    /**
     * <code>emNvAudIn_HDMI3 = 3;</code>
     *
     * <pre>
     *OPSTV port b
     * </pre>
     */
    emNvAudIn_HDMI3(3, 3),
    /**
     * <code>emNvAudIn_RCA = 4;</code>
     */
    emNvAudIn_RCA(4, 4),
    /**
     * <code>emNvAudIn_HDMI4 = 5;</code>
     *
     * <pre>
     *4k声音
     * </pre>
     */
    emNvAudIn_HDMI4(5, 5),
    ;

    /**
     * <code>emNvAudIn_HDMI0 = 0;</code>
     *
     * <pre>
     *IMix
     * </pre>
     */
    public static final int emNvAudIn_HDMI0_VALUE = 0;
    /**
     * <code>emNvAudIn_HDMI1 = 1;</code>
     *
     * <pre>
     *OPSTV port a
     * </pre>
     */
    public static final int emNvAudIn_HDMI1_VALUE = 1;
    /**
     * <code>emNvAudIn_HDMI2 = 2;</code>
     *
     * <pre>
     *Treminal
     * </pre>
     */
    public static final int emNvAudIn_HDMI2_VALUE = 2;
    /**
     * <code>emNvAudIn_HDMI3 = 3;</code>
     *
     * <pre>
     *OPSTV port b
     * </pre>
     */
    public static final int emNvAudIn_HDMI3_VALUE = 3;
    /**
     * <code>emNvAudIn_RCA = 4;</code>
     */
    public static final int emNvAudIn_RCA_VALUE = 4;
    /**
     * <code>emNvAudIn_HDMI4 = 5;</code>
     *
     * <pre>
     *4k声音
     * </pre>
     */
    public static final int emNvAudIn_HDMI4_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmNvAudPortIn valueOf(int value) {
      switch (value) {
        case 0: return emNvAudIn_HDMI0;
        case 1: return emNvAudIn_HDMI1;
        case 2: return emNvAudIn_HDMI2;
        case 3: return emNvAudIn_HDMI3;
        case 4: return emNvAudIn_RCA;
        case 5: return emNvAudIn_HDMI4;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvAudPortIn>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvAudPortIn>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvAudPortIn>() {
            public EmNvAudPortIn findValueByNumber(int number) {
              return EmNvAudPortIn.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(65);
    }

    private static final EmNvAudPortIn[] VALUES = values();

    public static EmNvAudPortIn valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvAudPortIn(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvAudPortIn)
  }

  /**
   * Protobuf enum {@code nv.EmNvAudPortOut}
   *
   * <pre>
   *音频输出接口
   * </pre>
   */
  public enum EmNvAudPortOut
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvAudOut_HDMI0 = 0;</code>
     *
     * <pre>
     * main flow
     * </pre>
     */
    emNvAudOut_HDMI0(0, 0),
    /**
     * <code>emNvAudOut_HDMI1 = 1;</code>
     *
     * <pre>
     *Auxiliary flow
     * </pre>
     */
    emNvAudOut_HDMI1(1, 1),
    /**
     * <code>emNvAudOut_JACK_3mm5 = 2;</code>
     *
     * <pre>
     *mix out	
     * </pre>
     */
    emNvAudOut_JACK_3mm5(2, 2),
    ;

    /**
     * <code>emNvAudOut_HDMI0 = 0;</code>
     *
     * <pre>
     * main flow
     * </pre>
     */
    public static final int emNvAudOut_HDMI0_VALUE = 0;
    /**
     * <code>emNvAudOut_HDMI1 = 1;</code>
     *
     * <pre>
     *Auxiliary flow
     * </pre>
     */
    public static final int emNvAudOut_HDMI1_VALUE = 1;
    /**
     * <code>emNvAudOut_JACK_3mm5 = 2;</code>
     *
     * <pre>
     *mix out	
     * </pre>
     */
    public static final int emNvAudOut_JACK_3mm5_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvAudPortOut valueOf(int value) {
      switch (value) {
        case 0: return emNvAudOut_HDMI0;
        case 1: return emNvAudOut_HDMI1;
        case 2: return emNvAudOut_JACK_3mm5;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvAudPortOut>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvAudPortOut>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvAudPortOut>() {
            public EmNvAudPortOut findValueByNumber(int number) {
              return EmNvAudPortOut.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(66);
    }

    private static final EmNvAudPortOut[] VALUES = values();

    public static EmNvAudPortOut valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvAudPortOut(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvAudPortOut)
  }

  /**
   * Protobuf enum {@code nv.EmNvPingErrcode}
   *
   * <pre>
   *ping结果反馈
   * </pre>
   */
  public enum EmNvPingErrcode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvPingReply = 0;</code>
     */
    emNvPingReply(0, 0),
    /**
     * <code>emNvPingTimeout = 1;</code>
     */
    emNvPingTimeout(1, 1),
    /**
     * <code>emNvPingError = 2;</code>
     */
    emNvPingError(2, 2),
    /**
     * <code>emNvPingNetUnreach = 3;</code>
     */
    emNvPingNetUnreach(3, 3),
    ;

    /**
     * <code>emNvPingReply = 0;</code>
     */
    public static final int emNvPingReply_VALUE = 0;
    /**
     * <code>emNvPingTimeout = 1;</code>
     */
    public static final int emNvPingTimeout_VALUE = 1;
    /**
     * <code>emNvPingError = 2;</code>
     */
    public static final int emNvPingError_VALUE = 2;
    /**
     * <code>emNvPingNetUnreach = 3;</code>
     */
    public static final int emNvPingNetUnreach_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNvPingErrcode valueOf(int value) {
      switch (value) {
        case 0: return emNvPingReply;
        case 1: return emNvPingTimeout;
        case 2: return emNvPingError;
        case 3: return emNvPingNetUnreach;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvPingErrcode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvPingErrcode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvPingErrcode>() {
            public EmNvPingErrcode findValueByNumber(int number) {
              return EmNvPingErrcode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(67);
    }

    private static final EmNvPingErrcode[] VALUES = values();

    public static EmNvPingErrcode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvPingErrcode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvPingErrcode)
  }

  /**
   * Protobuf enum {@code nv.EmNVSerialMode}
   *
   * <pre>
   *串口模式
   * </pre>
   */
  public enum EmNVSerialMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRS232 = 0;</code>
     */
    emRS232(0, 0),
    /**
     * <code>emRS422 = 1;</code>
     */
    emRS422(1, 1),
    /**
     * <code>emRS485 = 2;</code>
     */
    emRS485(2, 2),
    /**
     * <code>emSerialInfrared = 3;</code>
     */
    emSerialInfrared(3, 3),
    /**
     * <code>emRJ11 = 4;</code>
     */
    emRJ11(4, 4),
    ;

    /**
     * <code>emRS232 = 0;</code>
     */
    public static final int emRS232_VALUE = 0;
    /**
     * <code>emRS422 = 1;</code>
     */
    public static final int emRS422_VALUE = 1;
    /**
     * <code>emRS485 = 2;</code>
     */
    public static final int emRS485_VALUE = 2;
    /**
     * <code>emSerialInfrared = 3;</code>
     */
    public static final int emSerialInfrared_VALUE = 3;
    /**
     * <code>emRJ11 = 4;</code>
     */
    public static final int emRJ11_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmNVSerialMode valueOf(int value) {
      switch (value) {
        case 0: return emRS232;
        case 1: return emRS422;
        case 2: return emRS485;
        case 3: return emSerialInfrared;
        case 4: return emRJ11;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNVSerialMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNVSerialMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNVSerialMode>() {
            public EmNVSerialMode findValueByNumber(int number) {
              return EmNVSerialMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(68);
    }

    private static final EmNVSerialMode[] VALUES = values();

    public static EmNVSerialMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNVSerialMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNVSerialMode)
  }

  /**
   * Protobuf enum {@code nv.EmEthnetWorkMode}
   *
   * <pre>
   ** 以太网工作模式 
   * </pre>
   */
  public enum EmEthnetWorkMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emEthModeAuto = 0;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    emEthModeAuto(0, 0),
    /**
     * <code>emEthMode10MFull = 1;</code>
     *
     * <pre>
     *10M全双工
     * </pre>
     */
    emEthMode10MFull(1, 1),
    /**
     * <code>emEthMode10MHalf = 2;</code>
     *
     * <pre>
     *10M半双工
     * </pre>
     */
    emEthMode10MHalf(2, 2),
    /**
     * <code>emEthMode100MFull = 3;</code>
     *
     * <pre>
     *100M全双工
     * </pre>
     */
    emEthMode100MFull(3, 3),
    /**
     * <code>emEthMode100MHalf = 4;</code>
     *
     * <pre>
     *100M半双工
     * </pre>
     */
    emEthMode100MHalf(4, 4),
    /**
     * <code>emEthMode1000MFull = 5;</code>
     *
     * <pre>
     *1000M全双工
     * </pre>
     */
    emEthMode1000MFull(5, 5),
    /**
     * <code>emEthMode1000MHalf = 6;</code>
     *
     * <pre>
     *1000M半双工	
     * </pre>
     */
    emEthMode1000MHalf(6, 6),
    ;

    /**
     * <code>emEthModeAuto = 0;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    public static final int emEthModeAuto_VALUE = 0;
    /**
     * <code>emEthMode10MFull = 1;</code>
     *
     * <pre>
     *10M全双工
     * </pre>
     */
    public static final int emEthMode10MFull_VALUE = 1;
    /**
     * <code>emEthMode10MHalf = 2;</code>
     *
     * <pre>
     *10M半双工
     * </pre>
     */
    public static final int emEthMode10MHalf_VALUE = 2;
    /**
     * <code>emEthMode100MFull = 3;</code>
     *
     * <pre>
     *100M全双工
     * </pre>
     */
    public static final int emEthMode100MFull_VALUE = 3;
    /**
     * <code>emEthMode100MHalf = 4;</code>
     *
     * <pre>
     *100M半双工
     * </pre>
     */
    public static final int emEthMode100MHalf_VALUE = 4;
    /**
     * <code>emEthMode1000MFull = 5;</code>
     *
     * <pre>
     *1000M全双工
     * </pre>
     */
    public static final int emEthMode1000MFull_VALUE = 5;
    /**
     * <code>emEthMode1000MHalf = 6;</code>
     *
     * <pre>
     *1000M半双工	
     * </pre>
     */
    public static final int emEthMode1000MHalf_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmEthnetWorkMode valueOf(int value) {
      switch (value) {
        case 0: return emEthModeAuto;
        case 1: return emEthMode10MFull;
        case 2: return emEthMode10MHalf;
        case 3: return emEthMode100MFull;
        case 4: return emEthMode100MHalf;
        case 5: return emEthMode1000MFull;
        case 6: return emEthMode1000MHalf;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEthnetWorkMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEthnetWorkMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEthnetWorkMode>() {
            public EmEthnetWorkMode findValueByNumber(int number) {
              return EmEthnetWorkMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(69);
    }

    private static final EmEthnetWorkMode[] VALUES = values();

    public static EmEthnetWorkMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEthnetWorkMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmEthnetWorkMode)
  }

  /**
   * Protobuf enum {@code nv.EmEthInterfaceMode}
   *
   * <pre>
   ** 以太网多网口模式 
   * </pre>
   */
  public enum EmEthInterfaceMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emEthInterfaceModeBackup = 0;</code>
     *
     * <pre>
     *备份
     * </pre>
     */
    emEthInterfaceModeBackup(0, 0),
    /**
     * <code>emEthInterfaceModeMulti = 1;</code>
     *
     * <pre>
     *多网口
     * </pre>
     */
    emEthInterfaceModeMulti(1, 1),
    ;

    /**
     * <code>emEthInterfaceModeBackup = 0;</code>
     *
     * <pre>
     *备份
     * </pre>
     */
    public static final int emEthInterfaceModeBackup_VALUE = 0;
    /**
     * <code>emEthInterfaceModeMulti = 1;</code>
     *
     * <pre>
     *多网口
     * </pre>
     */
    public static final int emEthInterfaceModeMulti_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmEthInterfaceMode valueOf(int value) {
      switch (value) {
        case 0: return emEthInterfaceModeBackup;
        case 1: return emEthInterfaceModeMulti;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEthInterfaceMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEthInterfaceMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEthInterfaceMode>() {
            public EmEthInterfaceMode findValueByNumber(int number) {
              return EmEthInterfaceMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(70);
    }

    private static final EmEthInterfaceMode[] VALUES = values();

    public static EmEthInterfaceMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEthInterfaceMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmEthInterfaceMode)
  }

  /**
   * Protobuf enum {@code nv.EmEthStartupResult}
   *
   * <pre>
   ** 以太网启动状况 
   * </pre>
   */
  public enum EmEthStartupResult
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emEthStartupSuccess = 0;</code>
     *
     * <pre>
     *启动成功
     * </pre>
     */
    emEthStartupSuccess(0, 0),
    /**
     * <code>emEthStartupFail = 1;</code>
     *
     * <pre>
     *启动失败
     * </pre>
     */
    emEthStartupFail(1, 1),
    ;

    /**
     * <code>emEthStartupSuccess = 0;</code>
     *
     * <pre>
     *启动成功
     * </pre>
     */
    public static final int emEthStartupSuccess_VALUE = 0;
    /**
     * <code>emEthStartupFail = 1;</code>
     *
     * <pre>
     *启动失败
     * </pre>
     */
    public static final int emEthStartupFail_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmEthStartupResult valueOf(int value) {
      switch (value) {
        case 0: return emEthStartupSuccess;
        case 1: return emEthStartupFail;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEthStartupResult>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEthStartupResult>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEthStartupResult>() {
            public EmEthStartupResult findValueByNumber(int number) {
              return EmEthStartupResult.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(71);
    }

    private static final EmEthStartupResult[] VALUES = values();

    public static EmEthStartupResult valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEthStartupResult(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmEthStartupResult)
  }

  /**
   * Protobuf enum {@code nv.EmEthnetParamType}
   *
   * <pre>
   ** 设置以太网参数类型
   * </pre>
   */
  public enum EmEthnetParamType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emType_SetIpAndMask = 0;</code>
     *
     * <pre>
     *设置IP和掩码
     * </pre>
     */
    emType_SetIpAndMask(0, 0),
    /**
     * <code>emType_SetMacAddress = 1;</code>
     *
     * <pre>
     *设置MAC地址
     * </pre>
     */
    emType_SetMacAddress(1, 1),
    /**
     * <code>emType_SetAllParam = 2;</code>
     *
     * <pre>
     *设置所有参数
     * </pre>
     */
    emType_SetAllParam(2, 2),
    /**
     * <code>emType_SetSecondIp = 3;</code>
     *
     * <pre>
     *设置第二个IP信息
     * </pre>
     */
    emType_SetSecondIp(3, 3),
    ;

    /**
     * <code>emType_SetIpAndMask = 0;</code>
     *
     * <pre>
     *设置IP和掩码
     * </pre>
     */
    public static final int emType_SetIpAndMask_VALUE = 0;
    /**
     * <code>emType_SetMacAddress = 1;</code>
     *
     * <pre>
     *设置MAC地址
     * </pre>
     */
    public static final int emType_SetMacAddress_VALUE = 1;
    /**
     * <code>emType_SetAllParam = 2;</code>
     *
     * <pre>
     *设置所有参数
     * </pre>
     */
    public static final int emType_SetAllParam_VALUE = 2;
    /**
     * <code>emType_SetSecondIp = 3;</code>
     *
     * <pre>
     *设置第二个IP信息
     * </pre>
     */
    public static final int emType_SetSecondIp_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmEthnetParamType valueOf(int value) {
      switch (value) {
        case 0: return emType_SetIpAndMask;
        case 1: return emType_SetMacAddress;
        case 2: return emType_SetAllParam;
        case 3: return emType_SetSecondIp;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEthnetParamType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEthnetParamType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEthnetParamType>() {
            public EmEthnetParamType findValueByNumber(int number) {
              return EmEthnetParamType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(72);
    }

    private static final EmEthnetParamType[] VALUES = values();

    public static EmEthnetParamType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEthnetParamType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmEthnetParamType)
  }

  /**
   * Protobuf enum {@code nv.EmNvVidResResizeMode}
   *
   * <pre>
   *图像比例调整策略
   * </pre>
   */
  public enum EmNvVidResResizeMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvPanoramicLift = 0;</code>
     *
     * <pre>
     *全景拉伸，不等比缩放至1080p
     * </pre>
     */
    emNvPanoramicLift(0, 0),
    /**
     * <code>emNvFullScreenMid = 1;</code>
     *
     * <pre>
     *全屏居中：等比缩放加黑边至1080P
     * </pre>
     */
    emNvFullScreenMid(1, 1),
    ;

    /**
     * <code>emNvPanoramicLift = 0;</code>
     *
     * <pre>
     *全景拉伸，不等比缩放至1080p
     * </pre>
     */
    public static final int emNvPanoramicLift_VALUE = 0;
    /**
     * <code>emNvFullScreenMid = 1;</code>
     *
     * <pre>
     *全屏居中：等比缩放加黑边至1080P
     * </pre>
     */
    public static final int emNvFullScreenMid_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmNvVidResResizeMode valueOf(int value) {
      switch (value) {
        case 0: return emNvPanoramicLift;
        case 1: return emNvFullScreenMid;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvVidResResizeMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvVidResResizeMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvVidResResizeMode>() {
            public EmNvVidResResizeMode findValueByNumber(int number) {
              return EmNvVidResResizeMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(73);
    }

    private static final EmNvVidResResizeMode[] VALUES = values();

    public static EmNvVidResResizeMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvVidResResizeMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvVidResResizeMode)
  }

  /**
   * Protobuf enum {@code nv.EmNvIfaceInstruction}
   *
   * <pre>
   *iface指令通知
   * </pre>
   */
  public enum EmNvIfaceInstruction
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvIface_Invalid = 0;</code>
     */
    emNvIface_Invalid(0, 0),
    /**
     * <code>emNvIface_Hdmi1_Has = 1;</code>
     *
     * <pre>
     *hdmi1有源
     * </pre>
     */
    emNvIface_Hdmi1_Has(1, 1),
    /**
     * <code>emNvIface_Hdmi1_No = 2;</code>
     *
     * <pre>
     *hdmi1无源
     * </pre>
     */
    emNvIface_Hdmi1_No(2, 2),
    /**
     * <code>emNvIface_Hdmi2_Has = 3;</code>
     *
     * <pre>
     *hdmi2有源
     * </pre>
     */
    emNvIface_Hdmi2_Has(3, 3),
    /**
     * <code>emNvIface_Hdmi2_No = 4;</code>
     *
     * <pre>
     *hdmi2无源
     * </pre>
     */
    emNvIface_Hdmi2_No(4, 4),
    ;

    /**
     * <code>emNvIface_Invalid = 0;</code>
     */
    public static final int emNvIface_Invalid_VALUE = 0;
    /**
     * <code>emNvIface_Hdmi1_Has = 1;</code>
     *
     * <pre>
     *hdmi1有源
     * </pre>
     */
    public static final int emNvIface_Hdmi1_Has_VALUE = 1;
    /**
     * <code>emNvIface_Hdmi1_No = 2;</code>
     *
     * <pre>
     *hdmi1无源
     * </pre>
     */
    public static final int emNvIface_Hdmi1_No_VALUE = 2;
    /**
     * <code>emNvIface_Hdmi2_Has = 3;</code>
     *
     * <pre>
     *hdmi2有源
     * </pre>
     */
    public static final int emNvIface_Hdmi2_Has_VALUE = 3;
    /**
     * <code>emNvIface_Hdmi2_No = 4;</code>
     *
     * <pre>
     *hdmi2无源
     * </pre>
     */
    public static final int emNvIface_Hdmi2_No_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmNvIfaceInstruction valueOf(int value) {
      switch (value) {
        case 0: return emNvIface_Invalid;
        case 1: return emNvIface_Hdmi1_Has;
        case 2: return emNvIface_Hdmi1_No;
        case 3: return emNvIface_Hdmi2_Has;
        case 4: return emNvIface_Hdmi2_No;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvIfaceInstruction>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvIfaceInstruction>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvIfaceInstruction>() {
            public EmNvIfaceInstruction findValueByNumber(int number) {
              return EmNvIfaceInstruction.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(74);
    }

    private static final EmNvIfaceInstruction[] VALUES = values();

    public static EmNvIfaceInstruction valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvIfaceInstruction(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvIfaceInstruction)
  }

  /**
   * Protobuf enum {@code nv.EmMtVer}
   */
  public enum EmMtVer
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>enNVMtX300 = 0;</code>
     */
    enNVMtX300(0, 0),
    /**
     * <code>enNvMtX500 = 1;</code>
     */
    enNvMtX500(1, 1),
    /**
     * <code>enNvMtX700 = 2;</code>
     */
    enNvMtX700(2, 2),
    ;

    /**
     * <code>enNVMtX300 = 0;</code>
     */
    public static final int enNVMtX300_VALUE = 0;
    /**
     * <code>enNvMtX500 = 1;</code>
     */
    public static final int enNvMtX500_VALUE = 1;
    /**
     * <code>enNvMtX700 = 2;</code>
     */
    public static final int enNvMtX700_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtVer valueOf(int value) {
      switch (value) {
        case 0: return enNVMtX300;
        case 1: return enNvMtX500;
        case 2: return enNvMtX700;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtVer>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtVer>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtVer>() {
            public EmMtVer findValueByNumber(int number) {
              return EmMtVer.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(75);
    }

    private static final EmMtVer[] VALUES = values();

    public static EmMtVer valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtVer(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtVer)
  }

  /**
   * Protobuf enum {@code nv.EmNvHintCode}
   */
  public enum EmNvHintCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvHintBegin = 0;</code>
     *
     * <pre>
     *&#47;&lt;无效值
     * </pre>
     */
    emNvHintBegin(0, 0),
    /**
     * <code>emNvFailtoSendDual = 1;</code>
     *
     * <pre>
     *&#47;&lt;对端不支持当前格式和分辨率下的桌面共享
     * </pre>
     */
    emNvFailtoSendDual(1, 1),
    /**
     * <code>emNvFailtoRecvDual = 2;</code>
     *
     * <pre>
     *&#47;&lt;带宽不足，不支持对端发起的桌面共享
     * </pre>
     */
    emNvFailtoRecvDual(2, 2),
    /**
     * <code>emNvFailtoVodLogin = 3;</code>
     *
     * <pre>
     *&#47;&lt;VOD 登录失败
     * </pre>
     */
    emNvFailtoVodLogin(3, 3),
    /**
     * <code>emNvDHCPTimeOut = 4;</code>
     *
     * <pre>
     *&#47;&lt;获取DHCP地址超时
     * </pre>
     */
    emNvDHCPTimeOut(4, 4),
    /**
     * <code>emNvPPPoEAuthorError = 5;</code>
     *
     * <pre>
     *&#47;&lt;PPPOE身份验证错误
     * </pre>
     */
    emNvPPPoEAuthorError(5, 5),
    /**
     * <code>emNvPPPoEAgentError = 6;</code>
     *
     * <pre>
     *&#47;&lt;PPPOE找不到ISP服务商
     * </pre>
     */
    emNvPPPoEAgentError(6, 6),
    /**
     * <code>emNvPPPoETimeOutError = 7;</code>
     *
     * <pre>
     *&#47;&lt;PPPOE拨号超时
     * </pre>
     */
    emNvPPPoETimeOutError(7, 7),
    /**
     * <code>emNvPPPoELinkDownError = 8;</code>
     *
     * <pre>
     *&#47;&lt;PPPOE断链
     * </pre>
     */
    emNvPPPoELinkDownError(8, 8),
    /**
     * <code>emNvPPPoEGeneralError = 9;</code>
     *
     * <pre>
     *&#47;&lt;PPPOE其他错误
     * </pre>
     */
    emNvPPPoEGeneralError(9, 9),
    /**
     * <code>emNvFailtoSendDualAsReject = 10;</code>
     *
     * <pre>
     *&#47;&lt;对端拒绝发起桌面共享;只有发言人可以发起桌面共享
     * </pre>
     */
    emNvFailtoSendDualAsReject(10, 10),
    /**
     * <code>emNvCallRateNotValidForMc = 11;</code>
     *
     * <pre>
     *&#47;&lt;呼叫码率过高;拒绝MC扩展
     * </pre>
     */
    emNvCallRateNotValidForMc(11, 11),
    /**
     * <code>emNvDualResNotMatchConfRes = 12;</code>
     *
     * <pre>
     *&#47;&lt;桌面共享分辨率与会议要求(%s)不匹配
     * </pre>
     */
    emNvDualResNotMatchConfRes(12, 12),
    /**
     * <code>emNvSuccedetoSendDual = 13;</code>
     *
     * <pre>
     *&#47;&lt;发起桌面共享成功
     * </pre>
     */
    emNvSuccedetoSendDual(13, 13),
    /**
     * <code>emNvSuccedetoRecvDual = 14;</code>
     *
     * <pre>
     *&#47;&lt;接收桌面共享成功
     * </pre>
     */
    emNvSuccedetoRecvDual(14, 14),
    /**
     * <code>emNvSateMtNoP2pPermission = 15;</code>
     *
     * <pre>
     *&#47;&lt;卫星终端没有点对点视频会议权限
     * </pre>
     */
    emNvSateMtNoP2pPermission(15, 15),
    /**
     * <code>emNvH323UpLoadBitrateLessThan64Ind = 16;</code>
     *
     * <pre>
     *&#47;&lt;上行码率小于等于64K
     * </pre>
     */
    emNvH323UpLoadBitrateLessThan64Ind(16, 16),
    /**
     * <code>emNvH323DownLoadBitrateLessThan64Ind = 17;</code>
     *
     * <pre>
     *&#47;&lt;下行码率小于等于64k
     * </pre>
     */
    emNvH323DownLoadBitrateLessThan64Ind(17, 17),
    /**
     * <code>emNvAssVidHasNoSignal = 18;</code>
     *
     * <pre>
     *辅视频没有信号
     * </pre>
     */
    emNvAssVidHasNoSignal(18, 18),
    /**
     * <code>emNvBePolledNext = 30;</code>
     *
     * <pre>
     ** mcu通知ter 
     * </pre>
     */
    emNvBePolledNext(19, 30),
    /**
     * <code>emNvHintNoOpenDSChnnlNonSpeaker = 31;</code>
     *
     * <pre>
     *&#47;&lt;对端拒绝发起桌面共享;只有发言人可以发起桌面共享
     * </pre>
     */
    emNvHintNoOpenDSChnnlNonSpeaker(20, 31),
    /**
     * <code>emNvHintNoOpenDSChnnlNonCap = 32;</code>
     *
     * <pre>
     *&#47;&lt;能力集限制，桌面共享失败!
     * </pre>
     */
    emNvHintNoOpenDSChnnlNonCap(21, 32),
    /**
     * <code>emNvHintNoOpenDSChnnlBRLow64 = 33;</code>
     *
     * <pre>
     *&#47;&lt;码率小于64k，桌面共享失败!
     * </pre>
     */
    emNvHintNoOpenDSChnnlBRLow64(22, 33),
    /**
     * <code>emNvHintNoOpenDSChnnlFECType = 34;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开双流通道因FEC类型不匹配
     * </pre>
     */
    emNvHintNoOpenDSChnnlFECType(23, 34),
    /**
     * <code>emNvHintNoOpenDSChnnlNonMp = 35;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开双流通道因对应转发板不存在
     * </pre>
     */
    emNvHintNoOpenDSChnnlNonMp(24, 35),
    /**
     * <code>emNvHintNoOpenDSChnnlEncryptMode = 36;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开双流通道因加密模式不匹配
     * </pre>
     */
    emNvHintNoOpenDSChnnlEncryptMode(25, 36),
    /**
     * <code>emNvHintNoOpenDSChnnlOverSatDCastChnNum = 37;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开双流通道因超过了卫星分散会议的最大通道数
     * </pre>
     */
    emNvHintNoOpenDSChnnlOverSatDCastChnNum(26, 37),
    /**
     * <code>emNvHintNoOpenFSChnnlNonCap = 38;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因能力集限制失败
     * </pre>
     */
    emNvHintNoOpenFSChnnlNonCap(27, 38),
    /**
     * <code>emNvHintNoOpenFSChnnlBRLow64 = 39;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因通道码率小于64k
     * </pre>
     */
    emNvHintNoOpenFSChnnlBRLow64(28, 39),
    /**
     * <code>emNvHintNoOpenFSChnnlEncrpytMode = 40;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因加密模式不匹配
     * </pre>
     */
    emNvHintNoOpenFSChnnlEncrpytMode(29, 40),
    /**
     * <code>emNvHintNoOpenFSChnnlFECType = 41;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因FEC类型不匹配
     * </pre>
     */
    emNvHintNoOpenFSChnnlFECType(30, 41),
    /**
     * <code>emNvHintNoOpenFSChnnlNonMp = 42;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因对应的转发板不存在
     * </pre>
     */
    emNvHintNoOpenFSChnnlNonMp(31, 42),
    /**
     * <code>emNvHintNoOpenFSChnnlBROverflow = 43;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因码率过大
     * </pre>
     */
    emNvHintNoOpenFSChnnlBROverflow(32, 43),
    /**
     * <code>emNvHintNoOpenFSChnnlBothH263plus = 44;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因通道类型和动态载荷均为H263
     * </pre>
     */
    emNvHintNoOpenFSChnnlBothH263plus(33, 44),
    /**
     * <code>emNvHintNoOpenFSChnnlFormat = 45;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因分辨率过大
     * </pre>
     */
    emNvHintNoOpenFSChnnlFormat(34, 45),
    /**
     * <code>emNvHintNoOpenFSChnnlFPS = 46;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因帧率过大
     * </pre>
     */
    emNvHintNoOpenFSChnnlFPS(35, 46),
    /**
     * <code>emNvHintBRLessThanConf = 47;</code>
     *
     * <pre>
     *&#47;&lt;提示呼叫码率小于会议码率，请重新呼叫   { "wBitrate": 0}
     * </pre>
     */
    emNvHintBRLessThanConf(36, 47),
    /**
     * <code>emNvHintBRLargerThanConf = 48;</code>
     *
     * <pre>
     *&#47;&lt;提示呼叫码率大于会议码率，已自动调整
     * </pre>
     */
    emNvHintBRLargerThanConf(37, 48),
    /**
     * <code>emNvHintNoSupportOprForNoAuth = 49;</code>
     *
     * <pre>
     *&#47;&lt;提示不支持该操作，权限不足，请联系管理员
     * </pre>
     */
    emNvHintNoSupportOprForNoAuth(38, 49),
    /**
     * <code>emNvHintQueueConfNoIdleServer = 50;</code>
     *
     * <pre>
     *&#47;&lt;提示无空闲服务，请稍等
     * </pre>
     */
    emNvHintQueueConfNoIdleServer(39, 50),
    /**
     * <code>emNvHintQueueConfAllocatedServer = 51;</code>
     *
     * <pre>
     *&#47;&lt;提示正在接受服务
     * </pre>
     */
    emNvHintQueueConfAllocatedServer(40, 51),
    /**
     * <code>emNvHintOldStackNotSupportSpecVip = 52;</code>
     *
     * <pre>
     *&#47;提示老平台不支持主席指定Vip
     * </pre>
     */
    emNvHintOldStackNotSupportSpecVip(41, 52),
    /**
     * <code>emNvHintOldStackNotSupportModifyDumb = 53;</code>
     *
     * <pre>
     *&#47;提示老平台不支持会场哑音
     * </pre>
     */
    emNvHintOldStackNotSupportModifyDumb(42, 53),
    /**
     * <code>emNvHintOldStackNotSupportModifyConfPwd = 54;</code>
     *
     * <pre>
     *提示老平台不支持修改会议密码
     * </pre>
     */
    emNvHintOldStackNotSupportModifyConfPwd(43, 54),
    /**
     * <code>emNvHintOldStackNotSupportModifyConfNoDisturb = 55;</code>
     *
     * <pre>
     *提示老平台不支持设置会议免打扰
     * </pre>
     */
    emNvHintOldStackNotSupportModifyConfNoDisturb(44, 55),
    /**
     * <code>emNvHintOldStackNotSupportModifyDuration = 56;</code>
     *
     * <pre>
     *提示老平台不支持延长会议时间
     * </pre>
     */
    emNvHintOldStackNotSupportModifyDuration(45, 56),
    /**
     * <code>emNvHintOldStackNotSupportModifyConfName = 57;</code>
     *
     * <pre>
     *提示老平台不支持修改会议名称
     * </pre>
     */
    emNvHintOldStackNotSupportModifyConfName(46, 57),
    /**
     * <code>emNvHintOldStackNotSupportSetAssStreamSendMod = 58;</code>
     *
     * <pre>
     *提示老平台不支持修改内容共享权限
     * </pre>
     */
    emNvHintOldStackNotSupportSetAssStreamSendMod(47, 58),
    /**
     * <code>emNvHintAssVideoSourceIsSwitch = 59;</code>
     *
     * <pre>
     *提示老平台不支持修改内容共享权限
     * </pre>
     */
    emNvHintAssVideoSourceIsSwitch(48, 59),
    ;

    /**
     * <code>emNvHintBegin = 0;</code>
     *
     * <pre>
     *&#47;&lt;无效值
     * </pre>
     */
    public static final int emNvHintBegin_VALUE = 0;
    /**
     * <code>emNvFailtoSendDual = 1;</code>
     *
     * <pre>
     *&#47;&lt;对端不支持当前格式和分辨率下的桌面共享
     * </pre>
     */
    public static final int emNvFailtoSendDual_VALUE = 1;
    /**
     * <code>emNvFailtoRecvDual = 2;</code>
     *
     * <pre>
     *&#47;&lt;带宽不足，不支持对端发起的桌面共享
     * </pre>
     */
    public static final int emNvFailtoRecvDual_VALUE = 2;
    /**
     * <code>emNvFailtoVodLogin = 3;</code>
     *
     * <pre>
     *&#47;&lt;VOD 登录失败
     * </pre>
     */
    public static final int emNvFailtoVodLogin_VALUE = 3;
    /**
     * <code>emNvDHCPTimeOut = 4;</code>
     *
     * <pre>
     *&#47;&lt;获取DHCP地址超时
     * </pre>
     */
    public static final int emNvDHCPTimeOut_VALUE = 4;
    /**
     * <code>emNvPPPoEAuthorError = 5;</code>
     *
     * <pre>
     *&#47;&lt;PPPOE身份验证错误
     * </pre>
     */
    public static final int emNvPPPoEAuthorError_VALUE = 5;
    /**
     * <code>emNvPPPoEAgentError = 6;</code>
     *
     * <pre>
     *&#47;&lt;PPPOE找不到ISP服务商
     * </pre>
     */
    public static final int emNvPPPoEAgentError_VALUE = 6;
    /**
     * <code>emNvPPPoETimeOutError = 7;</code>
     *
     * <pre>
     *&#47;&lt;PPPOE拨号超时
     * </pre>
     */
    public static final int emNvPPPoETimeOutError_VALUE = 7;
    /**
     * <code>emNvPPPoELinkDownError = 8;</code>
     *
     * <pre>
     *&#47;&lt;PPPOE断链
     * </pre>
     */
    public static final int emNvPPPoELinkDownError_VALUE = 8;
    /**
     * <code>emNvPPPoEGeneralError = 9;</code>
     *
     * <pre>
     *&#47;&lt;PPPOE其他错误
     * </pre>
     */
    public static final int emNvPPPoEGeneralError_VALUE = 9;
    /**
     * <code>emNvFailtoSendDualAsReject = 10;</code>
     *
     * <pre>
     *&#47;&lt;对端拒绝发起桌面共享;只有发言人可以发起桌面共享
     * </pre>
     */
    public static final int emNvFailtoSendDualAsReject_VALUE = 10;
    /**
     * <code>emNvCallRateNotValidForMc = 11;</code>
     *
     * <pre>
     *&#47;&lt;呼叫码率过高;拒绝MC扩展
     * </pre>
     */
    public static final int emNvCallRateNotValidForMc_VALUE = 11;
    /**
     * <code>emNvDualResNotMatchConfRes = 12;</code>
     *
     * <pre>
     *&#47;&lt;桌面共享分辨率与会议要求(%s)不匹配
     * </pre>
     */
    public static final int emNvDualResNotMatchConfRes_VALUE = 12;
    /**
     * <code>emNvSuccedetoSendDual = 13;</code>
     *
     * <pre>
     *&#47;&lt;发起桌面共享成功
     * </pre>
     */
    public static final int emNvSuccedetoSendDual_VALUE = 13;
    /**
     * <code>emNvSuccedetoRecvDual = 14;</code>
     *
     * <pre>
     *&#47;&lt;接收桌面共享成功
     * </pre>
     */
    public static final int emNvSuccedetoRecvDual_VALUE = 14;
    /**
     * <code>emNvSateMtNoP2pPermission = 15;</code>
     *
     * <pre>
     *&#47;&lt;卫星终端没有点对点视频会议权限
     * </pre>
     */
    public static final int emNvSateMtNoP2pPermission_VALUE = 15;
    /**
     * <code>emNvH323UpLoadBitrateLessThan64Ind = 16;</code>
     *
     * <pre>
     *&#47;&lt;上行码率小于等于64K
     * </pre>
     */
    public static final int emNvH323UpLoadBitrateLessThan64Ind_VALUE = 16;
    /**
     * <code>emNvH323DownLoadBitrateLessThan64Ind = 17;</code>
     *
     * <pre>
     *&#47;&lt;下行码率小于等于64k
     * </pre>
     */
    public static final int emNvH323DownLoadBitrateLessThan64Ind_VALUE = 17;
    /**
     * <code>emNvAssVidHasNoSignal = 18;</code>
     *
     * <pre>
     *辅视频没有信号
     * </pre>
     */
    public static final int emNvAssVidHasNoSignal_VALUE = 18;
    /**
     * <code>emNvBePolledNext = 30;</code>
     *
     * <pre>
     ** mcu通知ter 
     * </pre>
     */
    public static final int emNvBePolledNext_VALUE = 30;
    /**
     * <code>emNvHintNoOpenDSChnnlNonSpeaker = 31;</code>
     *
     * <pre>
     *&#47;&lt;对端拒绝发起桌面共享;只有发言人可以发起桌面共享
     * </pre>
     */
    public static final int emNvHintNoOpenDSChnnlNonSpeaker_VALUE = 31;
    /**
     * <code>emNvHintNoOpenDSChnnlNonCap = 32;</code>
     *
     * <pre>
     *&#47;&lt;能力集限制，桌面共享失败!
     * </pre>
     */
    public static final int emNvHintNoOpenDSChnnlNonCap_VALUE = 32;
    /**
     * <code>emNvHintNoOpenDSChnnlBRLow64 = 33;</code>
     *
     * <pre>
     *&#47;&lt;码率小于64k，桌面共享失败!
     * </pre>
     */
    public static final int emNvHintNoOpenDSChnnlBRLow64_VALUE = 33;
    /**
     * <code>emNvHintNoOpenDSChnnlFECType = 34;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开双流通道因FEC类型不匹配
     * </pre>
     */
    public static final int emNvHintNoOpenDSChnnlFECType_VALUE = 34;
    /**
     * <code>emNvHintNoOpenDSChnnlNonMp = 35;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开双流通道因对应转发板不存在
     * </pre>
     */
    public static final int emNvHintNoOpenDSChnnlNonMp_VALUE = 35;
    /**
     * <code>emNvHintNoOpenDSChnnlEncryptMode = 36;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开双流通道因加密模式不匹配
     * </pre>
     */
    public static final int emNvHintNoOpenDSChnnlEncryptMode_VALUE = 36;
    /**
     * <code>emNvHintNoOpenDSChnnlOverSatDCastChnNum = 37;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开双流通道因超过了卫星分散会议的最大通道数
     * </pre>
     */
    public static final int emNvHintNoOpenDSChnnlOverSatDCastChnNum_VALUE = 37;
    /**
     * <code>emNvHintNoOpenFSChnnlNonCap = 38;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因能力集限制失败
     * </pre>
     */
    public static final int emNvHintNoOpenFSChnnlNonCap_VALUE = 38;
    /**
     * <code>emNvHintNoOpenFSChnnlBRLow64 = 39;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因通道码率小于64k
     * </pre>
     */
    public static final int emNvHintNoOpenFSChnnlBRLow64_VALUE = 39;
    /**
     * <code>emNvHintNoOpenFSChnnlEncrpytMode = 40;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因加密模式不匹配
     * </pre>
     */
    public static final int emNvHintNoOpenFSChnnlEncrpytMode_VALUE = 40;
    /**
     * <code>emNvHintNoOpenFSChnnlFECType = 41;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因FEC类型不匹配
     * </pre>
     */
    public static final int emNvHintNoOpenFSChnnlFECType_VALUE = 41;
    /**
     * <code>emNvHintNoOpenFSChnnlNonMp = 42;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因对应的转发板不存在
     * </pre>
     */
    public static final int emNvHintNoOpenFSChnnlNonMp_VALUE = 42;
    /**
     * <code>emNvHintNoOpenFSChnnlBROverflow = 43;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因码率过大
     * </pre>
     */
    public static final int emNvHintNoOpenFSChnnlBROverflow_VALUE = 43;
    /**
     * <code>emNvHintNoOpenFSChnnlBothH263plus = 44;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因通道类型和动态载荷均为H263
     * </pre>
     */
    public static final int emNvHintNoOpenFSChnnlBothH263plus_VALUE = 44;
    /**
     * <code>emNvHintNoOpenFSChnnlFormat = 45;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因分辨率过大
     * </pre>
     */
    public static final int emNvHintNoOpenFSChnnlFormat_VALUE = 45;
    /**
     * <code>emNvHintNoOpenFSChnnlFPS = 46;</code>
     *
     * <pre>
     *&#47;&lt;提示终端打开第一路视频通道因帧率过大
     * </pre>
     */
    public static final int emNvHintNoOpenFSChnnlFPS_VALUE = 46;
    /**
     * <code>emNvHintBRLessThanConf = 47;</code>
     *
     * <pre>
     *&#47;&lt;提示呼叫码率小于会议码率，请重新呼叫   { "wBitrate": 0}
     * </pre>
     */
    public static final int emNvHintBRLessThanConf_VALUE = 47;
    /**
     * <code>emNvHintBRLargerThanConf = 48;</code>
     *
     * <pre>
     *&#47;&lt;提示呼叫码率大于会议码率，已自动调整
     * </pre>
     */
    public static final int emNvHintBRLargerThanConf_VALUE = 48;
    /**
     * <code>emNvHintNoSupportOprForNoAuth = 49;</code>
     *
     * <pre>
     *&#47;&lt;提示不支持该操作，权限不足，请联系管理员
     * </pre>
     */
    public static final int emNvHintNoSupportOprForNoAuth_VALUE = 49;
    /**
     * <code>emNvHintQueueConfNoIdleServer = 50;</code>
     *
     * <pre>
     *&#47;&lt;提示无空闲服务，请稍等
     * </pre>
     */
    public static final int emNvHintQueueConfNoIdleServer_VALUE = 50;
    /**
     * <code>emNvHintQueueConfAllocatedServer = 51;</code>
     *
     * <pre>
     *&#47;&lt;提示正在接受服务
     * </pre>
     */
    public static final int emNvHintQueueConfAllocatedServer_VALUE = 51;
    /**
     * <code>emNvHintOldStackNotSupportSpecVip = 52;</code>
     *
     * <pre>
     *&#47;提示老平台不支持主席指定Vip
     * </pre>
     */
    public static final int emNvHintOldStackNotSupportSpecVip_VALUE = 52;
    /**
     * <code>emNvHintOldStackNotSupportModifyDumb = 53;</code>
     *
     * <pre>
     *&#47;提示老平台不支持会场哑音
     * </pre>
     */
    public static final int emNvHintOldStackNotSupportModifyDumb_VALUE = 53;
    /**
     * <code>emNvHintOldStackNotSupportModifyConfPwd = 54;</code>
     *
     * <pre>
     *提示老平台不支持修改会议密码
     * </pre>
     */
    public static final int emNvHintOldStackNotSupportModifyConfPwd_VALUE = 54;
    /**
     * <code>emNvHintOldStackNotSupportModifyConfNoDisturb = 55;</code>
     *
     * <pre>
     *提示老平台不支持设置会议免打扰
     * </pre>
     */
    public static final int emNvHintOldStackNotSupportModifyConfNoDisturb_VALUE = 55;
    /**
     * <code>emNvHintOldStackNotSupportModifyDuration = 56;</code>
     *
     * <pre>
     *提示老平台不支持延长会议时间
     * </pre>
     */
    public static final int emNvHintOldStackNotSupportModifyDuration_VALUE = 56;
    /**
     * <code>emNvHintOldStackNotSupportModifyConfName = 57;</code>
     *
     * <pre>
     *提示老平台不支持修改会议名称
     * </pre>
     */
    public static final int emNvHintOldStackNotSupportModifyConfName_VALUE = 57;
    /**
     * <code>emNvHintOldStackNotSupportSetAssStreamSendMod = 58;</code>
     *
     * <pre>
     *提示老平台不支持修改内容共享权限
     * </pre>
     */
    public static final int emNvHintOldStackNotSupportSetAssStreamSendMod_VALUE = 58;
    /**
     * <code>emNvHintAssVideoSourceIsSwitch = 59;</code>
     *
     * <pre>
     *提示老平台不支持修改内容共享权限
     * </pre>
     */
    public static final int emNvHintAssVideoSourceIsSwitch_VALUE = 59;


    public final int getNumber() { return value; }

    public static EmNvHintCode valueOf(int value) {
      switch (value) {
        case 0: return emNvHintBegin;
        case 1: return emNvFailtoSendDual;
        case 2: return emNvFailtoRecvDual;
        case 3: return emNvFailtoVodLogin;
        case 4: return emNvDHCPTimeOut;
        case 5: return emNvPPPoEAuthorError;
        case 6: return emNvPPPoEAgentError;
        case 7: return emNvPPPoETimeOutError;
        case 8: return emNvPPPoELinkDownError;
        case 9: return emNvPPPoEGeneralError;
        case 10: return emNvFailtoSendDualAsReject;
        case 11: return emNvCallRateNotValidForMc;
        case 12: return emNvDualResNotMatchConfRes;
        case 13: return emNvSuccedetoSendDual;
        case 14: return emNvSuccedetoRecvDual;
        case 15: return emNvSateMtNoP2pPermission;
        case 16: return emNvH323UpLoadBitrateLessThan64Ind;
        case 17: return emNvH323DownLoadBitrateLessThan64Ind;
        case 18: return emNvAssVidHasNoSignal;
        case 30: return emNvBePolledNext;
        case 31: return emNvHintNoOpenDSChnnlNonSpeaker;
        case 32: return emNvHintNoOpenDSChnnlNonCap;
        case 33: return emNvHintNoOpenDSChnnlBRLow64;
        case 34: return emNvHintNoOpenDSChnnlFECType;
        case 35: return emNvHintNoOpenDSChnnlNonMp;
        case 36: return emNvHintNoOpenDSChnnlEncryptMode;
        case 37: return emNvHintNoOpenDSChnnlOverSatDCastChnNum;
        case 38: return emNvHintNoOpenFSChnnlNonCap;
        case 39: return emNvHintNoOpenFSChnnlBRLow64;
        case 40: return emNvHintNoOpenFSChnnlEncrpytMode;
        case 41: return emNvHintNoOpenFSChnnlFECType;
        case 42: return emNvHintNoOpenFSChnnlNonMp;
        case 43: return emNvHintNoOpenFSChnnlBROverflow;
        case 44: return emNvHintNoOpenFSChnnlBothH263plus;
        case 45: return emNvHintNoOpenFSChnnlFormat;
        case 46: return emNvHintNoOpenFSChnnlFPS;
        case 47: return emNvHintBRLessThanConf;
        case 48: return emNvHintBRLargerThanConf;
        case 49: return emNvHintNoSupportOprForNoAuth;
        case 50: return emNvHintQueueConfNoIdleServer;
        case 51: return emNvHintQueueConfAllocatedServer;
        case 52: return emNvHintOldStackNotSupportSpecVip;
        case 53: return emNvHintOldStackNotSupportModifyDumb;
        case 54: return emNvHintOldStackNotSupportModifyConfPwd;
        case 55: return emNvHintOldStackNotSupportModifyConfNoDisturb;
        case 56: return emNvHintOldStackNotSupportModifyDuration;
        case 57: return emNvHintOldStackNotSupportModifyConfName;
        case 58: return emNvHintOldStackNotSupportSetAssStreamSendMod;
        case 59: return emNvHintAssVideoSourceIsSwitch;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvHintCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvHintCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvHintCode>() {
            public EmNvHintCode findValueByNumber(int number) {
              return EmNvHintCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(76);
    }

    private static final EmNvHintCode[] VALUES = values();

    public static EmNvHintCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvHintCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvHintCode)
  }

  /**
   * Protobuf enum {@code nv.EmNvTvInputSelect}
   */
  public enum EmNvTvInputSelect
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>enNvTvInvalid = 0;</code>
     */
    enNvTvInvalid(0, 0),
    /**
     * <code>enNvTvHdmi1 = 1;</code>
     */
    enNvTvHdmi1(1, 1),
    /**
     * <code>enNvTvHdmi2 = 2;</code>
     */
    enNvTvHdmi2(2, 2),
    ;

    /**
     * <code>enNvTvInvalid = 0;</code>
     */
    public static final int enNvTvInvalid_VALUE = 0;
    /**
     * <code>enNvTvHdmi1 = 1;</code>
     */
    public static final int enNvTvHdmi1_VALUE = 1;
    /**
     * <code>enNvTvHdmi2 = 2;</code>
     */
    public static final int enNvTvHdmi2_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvTvInputSelect valueOf(int value) {
      switch (value) {
        case 0: return enNvTvInvalid;
        case 1: return enNvTvHdmi1;
        case 2: return enNvTvHdmi2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvTvInputSelect>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvTvInputSelect>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvTvInputSelect>() {
            public EmNvTvInputSelect findValueByNumber(int number) {
              return EmNvTvInputSelect.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(77);
    }

    private static final EmNvTvInputSelect[] VALUES = values();

    public static EmNvTvInputSelect valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvTvInputSelect(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvTvInputSelect)
  }

  /**
   * Protobuf enum {@code nv.EmNvZoomMode}
   */
  public enum EmNvZoomMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>enNV_ZOOM_FILLBLACK = 0;</code>
     *
     * <pre>
     *加黑边
     * </pre>
     */
    enNV_ZOOM_FILLBLACK(0, 0),
    /**
     * <code>enNV_ZOOM_CUT = 1;</code>
     *
     * <pre>
     *裁边
     * </pre>
     */
    enNV_ZOOM_CUT(1, 1),
    /**
     * <code>enNV_ZOOM_SCALE = 2;</code>
     *
     * <pre>
     *不等比拉伸
     * </pre>
     */
    enNV_ZOOM_SCALE(2, 2),
    ;

    /**
     * <code>enNV_ZOOM_FILLBLACK = 0;</code>
     *
     * <pre>
     *加黑边
     * </pre>
     */
    public static final int enNV_ZOOM_FILLBLACK_VALUE = 0;
    /**
     * <code>enNV_ZOOM_CUT = 1;</code>
     *
     * <pre>
     *裁边
     * </pre>
     */
    public static final int enNV_ZOOM_CUT_VALUE = 1;
    /**
     * <code>enNV_ZOOM_SCALE = 2;</code>
     *
     * <pre>
     *不等比拉伸
     * </pre>
     */
    public static final int enNV_ZOOM_SCALE_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvZoomMode valueOf(int value) {
      switch (value) {
        case 0: return enNV_ZOOM_FILLBLACK;
        case 1: return enNV_ZOOM_CUT;
        case 2: return enNV_ZOOM_SCALE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvZoomMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvZoomMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvZoomMode>() {
            public EmNvZoomMode findValueByNumber(int number) {
              return EmNvZoomMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(78);
    }

    private static final EmNvZoomMode[] VALUES = values();

    public static EmNvZoomMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvZoomMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvZoomMode)
  }

  /**
   * Protobuf enum {@code nv.EmNvScreen}
   */
  public enum EmNvScreen
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>enNV_Screen_Brightness = 0;</code>
     *
     * <pre>
     *亮度 
     * </pre>
     */
    enNV_Screen_Brightness(0, 0),
    /**
     * <code>enNV_Screen_Contrast = 1;</code>
     *
     * <pre>
     *对比度
     * </pre>
     */
    enNV_Screen_Contrast(1, 1),
    /**
     * <code>enNV_Screen_Saturation = 2;</code>
     *
     * <pre>
     *饱和度
     * </pre>
     */
    enNV_Screen_Saturation(2, 2),
    /**
     * <code>enNV_Screen_Clarity = 3;</code>
     *
     * <pre>
     *清晰度
     * </pre>
     */
    enNV_Screen_Clarity(3, 3),
    /**
     * <code>enNV_Screen_Colortemp = 4;</code>
     *
     * <pre>
     *色温
     * </pre>
     */
    enNV_Screen_Colortemp(4, 4),
    /**
     * <code>enNV_Screen_Displayratio = 5;</code>
     *
     * <pre>
     *显示比例
     * </pre>
     */
    enNV_Screen_Displayratio(5, 5),
    ;

    /**
     * <code>enNV_Screen_Brightness = 0;</code>
     *
     * <pre>
     *亮度 
     * </pre>
     */
    public static final int enNV_Screen_Brightness_VALUE = 0;
    /**
     * <code>enNV_Screen_Contrast = 1;</code>
     *
     * <pre>
     *对比度
     * </pre>
     */
    public static final int enNV_Screen_Contrast_VALUE = 1;
    /**
     * <code>enNV_Screen_Saturation = 2;</code>
     *
     * <pre>
     *饱和度
     * </pre>
     */
    public static final int enNV_Screen_Saturation_VALUE = 2;
    /**
     * <code>enNV_Screen_Clarity = 3;</code>
     *
     * <pre>
     *清晰度
     * </pre>
     */
    public static final int enNV_Screen_Clarity_VALUE = 3;
    /**
     * <code>enNV_Screen_Colortemp = 4;</code>
     *
     * <pre>
     *色温
     * </pre>
     */
    public static final int enNV_Screen_Colortemp_VALUE = 4;
    /**
     * <code>enNV_Screen_Displayratio = 5;</code>
     *
     * <pre>
     *显示比例
     * </pre>
     */
    public static final int enNV_Screen_Displayratio_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmNvScreen valueOf(int value) {
      switch (value) {
        case 0: return enNV_Screen_Brightness;
        case 1: return enNV_Screen_Contrast;
        case 2: return enNV_Screen_Saturation;
        case 3: return enNV_Screen_Clarity;
        case 4: return enNV_Screen_Colortemp;
        case 5: return enNV_Screen_Displayratio;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvScreen>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvScreen>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvScreen>() {
            public EmNvScreen findValueByNumber(int number) {
              return EmNvScreen.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(79);
    }

    private static final EmNvScreen[] VALUES = values();

    public static EmNvScreen valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvScreen(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvScreen)
  }

  /**
   * Protobuf enum {@code nv.EmNvVidLabel}
   */
  public enum EmNvVidLabel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvVidLabBegin = 0;</code>
     */
    emNvVidLabBegin(0, 0),
    /**
     * <code>emNvPcStreamVidLab = 1;</code>
     *
     * <pre>
     *pc双流标签
     * </pre>
     */
    emNvPcStreamVidLab(1, 1),
    /**
     * <code>emNvVideoStreamVidLab = 2;</code>
     *
     * <pre>
     *video双流标签
     * </pre>
     */
    emNvVideoStreamVidLab(2, 2),
    ;

    /**
     * <code>emNvVidLabBegin = 0;</code>
     */
    public static final int emNvVidLabBegin_VALUE = 0;
    /**
     * <code>emNvPcStreamVidLab = 1;</code>
     *
     * <pre>
     *pc双流标签
     * </pre>
     */
    public static final int emNvPcStreamVidLab_VALUE = 1;
    /**
     * <code>emNvVideoStreamVidLab = 2;</code>
     *
     * <pre>
     *video双流标签
     * </pre>
     */
    public static final int emNvVideoStreamVidLab_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvVidLabel valueOf(int value) {
      switch (value) {
        case 0: return emNvVidLabBegin;
        case 1: return emNvPcStreamVidLab;
        case 2: return emNvVideoStreamVidLab;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvVidLabel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvVidLabel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvVidLabel>() {
            public EmNvVidLabel findValueByNumber(int number) {
              return EmNvVidLabel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(80);
    }

    private static final EmNvVidLabel[] VALUES = values();

    public static EmNvVidLabel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvVidLabel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvVidLabel)
  }

  /**
   * Protobuf enum {@code nv.EmNvMiniVidPos}
   */
  public enum EmNvMiniVidPos
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvMini_RightBottom = 0;</code>
     *
     * <pre>
     *右下
     * </pre>
     */
    emNvMini_RightBottom(0, 0),
    /**
     * <code>emNvMini_LeftBottom = 1;</code>
     *
     * <pre>
     *左下
     * </pre>
     */
    emNvMini_LeftBottom(1, 1),
    /**
     * <code>emNvMini_LeftTop = 2;</code>
     *
     * <pre>
     *左上
     * </pre>
     */
    emNvMini_LeftTop(2, 2),
    /**
     * <code>emNvMini_RightTop = 3;</code>
     *
     * <pre>
     *右上
     * </pre>
     */
    emNvMini_RightTop(3, 3),
    ;

    /**
     * <code>emNvMini_RightBottom = 0;</code>
     *
     * <pre>
     *右下
     * </pre>
     */
    public static final int emNvMini_RightBottom_VALUE = 0;
    /**
     * <code>emNvMini_LeftBottom = 1;</code>
     *
     * <pre>
     *左下
     * </pre>
     */
    public static final int emNvMini_LeftBottom_VALUE = 1;
    /**
     * <code>emNvMini_LeftTop = 2;</code>
     *
     * <pre>
     *左上
     * </pre>
     */
    public static final int emNvMini_LeftTop_VALUE = 2;
    /**
     * <code>emNvMini_RightTop = 3;</code>
     *
     * <pre>
     *右上
     * </pre>
     */
    public static final int emNvMini_RightTop_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNvMiniVidPos valueOf(int value) {
      switch (value) {
        case 0: return emNvMini_RightBottom;
        case 1: return emNvMini_LeftBottom;
        case 2: return emNvMini_LeftTop;
        case 3: return emNvMini_RightTop;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvMiniVidPos>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvMiniVidPos>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvMiniVidPos>() {
            public EmNvMiniVidPos findValueByNumber(int number) {
              return EmNvMiniVidPos.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(81);
    }

    private static final EmNvMiniVidPos[] VALUES = values();

    public static EmNvMiniVidPos valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvMiniVidPos(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvMiniVidPos)
  }

  /**
   * Protobuf enum {@code nv.EmNvCallStatApi}
   *
   * <pre>
   *会议呼叫状态
   * </pre>
   */
  public enum EmNvCallStatApi
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvCallIdle_Api = 0;</code>
     */
    emNvCallIdle_Api(0, 0),
    /**
     * <code>emNvCallRasConfJoining_Api = 1;</code>
     *
     * <pre>
     *&lt;ras非标加入会议，等待mcu 呼叫
     * </pre>
     */
    emNvCallRasConfJoining_Api(1, 1),
    /**
     * <code>emNvCallRasConfCreating_Api = 2;</code>
     *
     * <pre>
     *&lt;ras非标创建会议，等待mcu 呼叫
     * </pre>
     */
    emNvCallRasConfCreating_Api(2, 2),
    /**
     * <code>emNvCallOuting_Api = 3;</code>
     *
     * <pre>
     *&lt;呼出
     * </pre>
     */
    emNvCallOuting_Api(3, 3),
    /**
     * <code>emNvCallIncoming_Api = 4;</code>
     *
     * <pre>
     *&lt;呼入
     * </pre>
     */
    emNvCallIncoming_Api(4, 4),
    /**
     * <code>emNvCallAccepted_Api = 5;</code>
     *
     * <pre>
     *&lt;接收
     * </pre>
     */
    emNvCallAccepted_Api(5, 5),
    /**
     * <code>emNvCallHanging_Api = 6;</code>
     *
     * <pre>
     *&lt;挂断
     * </pre>
     */
    emNvCallHanging_Api(6, 6),
    /**
     * <code>emNvCallConnected_Api = 7;</code>
     *
     * <pre>
     *&lt;h323 是 225connected, sip是呼叫信令交互完
     * </pre>
     */
    emNvCallConnected_Api(7, 7),
    /**
     * <code>emNvCallP2P_Api = 8;</code>
     *
     * <pre>
     *&lt;点对点
     * </pre>
     */
    emNvCallP2P_Api(8, 8),
    /**
     * <code>emNvCallMCU_Api = 9;</code>
     *
     * <pre>
     *&lt;多点
     * </pre>
     */
    emNvCallMCU_Api(9, 9),
    ;

    /**
     * <code>emNvCallIdle_Api = 0;</code>
     */
    public static final int emNvCallIdle_Api_VALUE = 0;
    /**
     * <code>emNvCallRasConfJoining_Api = 1;</code>
     *
     * <pre>
     *&lt;ras非标加入会议，等待mcu 呼叫
     * </pre>
     */
    public static final int emNvCallRasConfJoining_Api_VALUE = 1;
    /**
     * <code>emNvCallRasConfCreating_Api = 2;</code>
     *
     * <pre>
     *&lt;ras非标创建会议，等待mcu 呼叫
     * </pre>
     */
    public static final int emNvCallRasConfCreating_Api_VALUE = 2;
    /**
     * <code>emNvCallOuting_Api = 3;</code>
     *
     * <pre>
     *&lt;呼出
     * </pre>
     */
    public static final int emNvCallOuting_Api_VALUE = 3;
    /**
     * <code>emNvCallIncoming_Api = 4;</code>
     *
     * <pre>
     *&lt;呼入
     * </pre>
     */
    public static final int emNvCallIncoming_Api_VALUE = 4;
    /**
     * <code>emNvCallAccepted_Api = 5;</code>
     *
     * <pre>
     *&lt;接收
     * </pre>
     */
    public static final int emNvCallAccepted_Api_VALUE = 5;
    /**
     * <code>emNvCallHanging_Api = 6;</code>
     *
     * <pre>
     *&lt;挂断
     * </pre>
     */
    public static final int emNvCallHanging_Api_VALUE = 6;
    /**
     * <code>emNvCallConnected_Api = 7;</code>
     *
     * <pre>
     *&lt;h323 是 225connected, sip是呼叫信令交互完
     * </pre>
     */
    public static final int emNvCallConnected_Api_VALUE = 7;
    /**
     * <code>emNvCallP2P_Api = 8;</code>
     *
     * <pre>
     *&lt;点对点
     * </pre>
     */
    public static final int emNvCallP2P_Api_VALUE = 8;
    /**
     * <code>emNvCallMCU_Api = 9;</code>
     *
     * <pre>
     *&lt;多点
     * </pre>
     */
    public static final int emNvCallMCU_Api_VALUE = 9;


    public final int getNumber() { return value; }

    public static EmNvCallStatApi valueOf(int value) {
      switch (value) {
        case 0: return emNvCallIdle_Api;
        case 1: return emNvCallRasConfJoining_Api;
        case 2: return emNvCallRasConfCreating_Api;
        case 3: return emNvCallOuting_Api;
        case 4: return emNvCallIncoming_Api;
        case 5: return emNvCallAccepted_Api;
        case 6: return emNvCallHanging_Api;
        case 7: return emNvCallConnected_Api;
        case 8: return emNvCallP2P_Api;
        case 9: return emNvCallMCU_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvCallStatApi>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvCallStatApi>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvCallStatApi>() {
            public EmNvCallStatApi findValueByNumber(int number) {
              return EmNvCallStatApi.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(82);
    }

    private static final EmNvCallStatApi[] VALUES = values();

    public static EmNvCallStatApi valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvCallStatApi(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvCallStatApi)
  }

  /**
   * Protobuf enum {@code nv.EmNvCallingType}
   *
   * <pre>
   *conf呼叫类型, 区分加会，创会，主呼，被呼
   * </pre>
   */
  public enum EmNvCallingType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvJoinConf_Api = 0;</code>
     *
     * <pre>
     *&lt;ras非标加入会议，等待mcu 呼叫  
     * </pre>
     */
    emNvJoinConf_Api(0, 0),
    /**
     * <code>emNvCreateConf_Api = 1;</code>
     *
     * <pre>
     *&lt;ras非标创建会议，等待mcu 呼叫
     * </pre>
     */
    emNvCreateConf_Api(1, 1),
    /**
     * <code>emNvOutCall_Api = 2;</code>
     *
     * <pre>
     *&lt;呼出
     * </pre>
     */
    emNvOutCall_Api(2, 2),
    /**
     * <code>emNvIncomingCall_Api = 3;</code>
     *
     * <pre>
     *&lt;呼入
     * </pre>
     */
    emNvIncomingCall_Api(3, 3),
    ;

    /**
     * <code>emNvJoinConf_Api = 0;</code>
     *
     * <pre>
     *&lt;ras非标加入会议，等待mcu 呼叫  
     * </pre>
     */
    public static final int emNvJoinConf_Api_VALUE = 0;
    /**
     * <code>emNvCreateConf_Api = 1;</code>
     *
     * <pre>
     *&lt;ras非标创建会议，等待mcu 呼叫
     * </pre>
     */
    public static final int emNvCreateConf_Api_VALUE = 1;
    /**
     * <code>emNvOutCall_Api = 2;</code>
     *
     * <pre>
     *&lt;呼出
     * </pre>
     */
    public static final int emNvOutCall_Api_VALUE = 2;
    /**
     * <code>emNvIncomingCall_Api = 3;</code>
     *
     * <pre>
     *&lt;呼入
     * </pre>
     */
    public static final int emNvIncomingCall_Api_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNvCallingType valueOf(int value) {
      switch (value) {
        case 0: return emNvJoinConf_Api;
        case 1: return emNvCreateConf_Api;
        case 2: return emNvOutCall_Api;
        case 3: return emNvIncomingCall_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvCallingType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvCallingType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvCallingType>() {
            public EmNvCallingType findValueByNumber(int number) {
              return EmNvCallingType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(83);
    }

    private static final EmNvCallingType[] VALUES = values();

    public static EmNvCallingType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvCallingType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvCallingType)
  }

  /**
   * Protobuf enum {@code nv.EmNvCallProtocol}
   *
   * <pre>
   *呼叫协议类型
   * </pre>
   */
  public enum EmNvCallProtocol
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvProtocolBegin_Api = 0;</code>
     *
     * <pre>
     *&lt;起始值
     * </pre>
     */
    emNvProtocolBegin_Api(0, 0),
    /**
     * <code>emNv323_Api = 1;</code>
     *
     * <pre>
     *&lt;H323
     * </pre>
     */
    emNv323_Api(1, 1),
    /**
     * <code>emNvsip_Api = 2;</code>
     *
     * <pre>
     *&lt;SIP
     * </pre>
     */
    emNvsip_Api(2, 2),
    /**
     * <code>emNvsat_Api = 3;</code>
     *
     * <pre>
     *&lt;SAT
     * </pre>
     */
    emNvsat_Api(3, 3),
    /**
     * <code>emNvtip_Api = 4;</code>
     *
     * <pre>
     *&lt;TIP
     * </pre>
     */
    emNvtip_Api(4, 4),
    ;

    /**
     * <code>emNvProtocolBegin_Api = 0;</code>
     *
     * <pre>
     *&lt;起始值
     * </pre>
     */
    public static final int emNvProtocolBegin_Api_VALUE = 0;
    /**
     * <code>emNv323_Api = 1;</code>
     *
     * <pre>
     *&lt;H323
     * </pre>
     */
    public static final int emNv323_Api_VALUE = 1;
    /**
     * <code>emNvsip_Api = 2;</code>
     *
     * <pre>
     *&lt;SIP
     * </pre>
     */
    public static final int emNvsip_Api_VALUE = 2;
    /**
     * <code>emNvsat_Api = 3;</code>
     *
     * <pre>
     *&lt;SAT
     * </pre>
     */
    public static final int emNvsat_Api_VALUE = 3;
    /**
     * <code>emNvtip_Api = 4;</code>
     *
     * <pre>
     *&lt;TIP
     * </pre>
     */
    public static final int emNvtip_Api_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmNvCallProtocol valueOf(int value) {
      switch (value) {
        case 0: return emNvProtocolBegin_Api;
        case 1: return emNv323_Api;
        case 2: return emNvsip_Api;
        case 3: return emNvsat_Api;
        case 4: return emNvtip_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvCallProtocol>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvCallProtocol>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvCallProtocol>() {
            public EmNvCallProtocol findValueByNumber(int number) {
              return EmNvCallProtocol.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(84);
    }

    private static final EmNvCallProtocol[] VALUES = values();

    public static EmNvCallProtocol valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvCallProtocol(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvCallProtocol)
  }

  /**
   * Protobuf enum {@code nv.EmNvCallDisReason}
   *
   * <pre>
   *呼叫挂断原因
   * </pre>
   */
  public enum EmNvCallDisReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emDisconnectNv_Busy_Api = 0;</code>
     *
     * <pre>
     *&lt; 对端忙
     * </pre>
     */
    emDisconnectNv_Busy_Api(0, 0),
    /**
     * <code>emDisconnectNv_Normal_Api = 1;</code>
     *
     * <pre>
     *&lt; 正常挂断
     * </pre>
     */
    emDisconnectNv_Normal_Api(1, 1),
    /**
     * <code>emDisconnectNv_Rejected_Api = 2;</code>
     *
     * <pre>
     *&lt; 对端拒绝
     * </pre>
     */
    emDisconnectNv_Rejected_Api(2, 2),
    /**
     * <code>emDisconnectNv_Unreachable_Api = 3;</code>
     *
     * <pre>
     *&lt; 对端不可达
     * </pre>
     */
    emDisconnectNv_Unreachable_Api(3, 3),
    /**
     * <code>emDisconnectNv_Local_Api = 4;</code>
     *
     * <pre>
     *&lt; 本地原因
     * </pre>
     */
    emDisconnectNv_Local_Api(4, 4),
    /**
     * <code>emDisconnectNv_Unknown_Api = 5;</code>
     *
     * <pre>
     *&lt; 未知原因
     * </pre>
     */
    emDisconnectNv_Unknown_Api(5, 5),
    /**
     * <code>emDisconnectNv_custom_Api = 6;</code>
     *
     * <pre>
     *&lt; 自定义原因
     * </pre>
     */
    emDisconnectNv_custom_Api(6, 6),
    /**
     * <code>emDisconnectNv_AdaptiveBusy_Api = 7;</code>
     *
     * <pre>
     *&lt; 接入电话终端失败
     * </pre>
     */
    emDisconnectNv_AdaptiveBusy_Api(7, 7),
    /**
     * <code>emDisconnectNv_Occupy_Api = 8;</code>
     *
     * <pre>
     *其他终端或者mcu抢断
     * </pre>
     */
    emDisconnectNv_Occupy_Api(8, 8),
    /**
     * <code>emDisconnectNv_Joinconftimeout_Api = 20;</code>
     *
     * <pre>
     *&lt; 参加会议超时
     * </pre>
     */
    emDisconnectNv_Joinconftimeout_Api(9, 20),
    /**
     * <code>emDisconnectNv_Createconftimeout_Api = 21;</code>
     *
     * <pre>
     *&#47;&lt; 召集会议超时
     * </pre>
     */
    emDisconnectNv_Createconftimeout_Api(10, 21),
    /**
     * <code>emDisconnectNv_Nomediaresource_Api = 22;</code>
     *
     * <pre>
     *&lt; 没有媒体资源
     * </pre>
     */
    emDisconnectNv_Nomediaresource_Api(11, 22),
    /**
     * <code>emDisconnectNv_Exceedmaxinconfmtnum_Api = 23;</code>
     *
     * <pre>
     *&lt; 超过会议最大终端数（参加会议时）
     * </pre>
     */
    emDisconnectNv_Exceedmaxinconfmtnum_Api(12, 23),
    /**
     * <code>emDisconnectNv_Exceedmaxconfnum_Api = 24;</code>
     *
     * <pre>
     *&lt; 超过会议最大数（创建会议时）
     * </pre>
     */
    emDisconnectNv_Exceedmaxconfnum_Api(13, 24),
    /**
     * <code>emDisconnectNv_EncrypeErr_Api = 25;</code>
     *
     * <pre>
     *&lt; 与会议加密模式不符
     * </pre>
     */
    emDisconnectNv_EncrypeErr_Api(14, 25),
    /**
     * <code>emDisconnectNv_P2Ptimeout_Api = 26;</code>
     *
     * <pre>
     *&lt; 点对点呼叫超时
     * </pre>
     */
    emDisconnectNv_P2Ptimeout_Api(15, 26),
    /**
     * <code>emDisconnectNv_MccDrop_Api = 27;</code>
     *
     * <pre>
     *&lt; 会控挂断
     * </pre>
     */
    emDisconnectNv_MccDrop_Api(16, 27),
    /**
     * <code>emDisconnectNv_ChairDrop_Api = 28;</code>
     *
     * <pre>
     *&lt; 主席挂断
     * </pre>
     */
    emDisconnectNv_ChairDrop_Api(17, 28),
    /**
     * <code>emDisconnectNv_MMcuDrop_Api = 29;</code>
     *
     * <pre>
     *&lt; 上级会议挂断
     * </pre>
     */
    emDisconnectNv_MMcuDrop_Api(18, 29),
    /**
     * <code>emDisconnectNv_ConfRelease_Api = 30;</code>
     *
     * <pre>
     *&lt; 会议结束挂断
     * </pre>
     */
    emDisconnectNv_ConfRelease_Api(19, 30),
    /**
     * <code>emDisconnectNv_PeerInConf_Api = 31;</code>
     *
     * <pre>
     *&lt; 正在会议中
     * </pre>
     */
    emDisconnectNv_PeerInConf_Api(20, 31),
    /**
     * <code>emDisconnectNv_PeerNoDisturb_Api = 32;</code>
     *
     * <pre>
     *&lt; 免打扰
     * </pre>
     */
    emDisconnectNv_PeerNoDisturb_Api(21, 32),
    /**
     * <code>emDisconnectNv_NotInPeerContact_Api = 33;</code>
     *
     * <pre>
     *&lt; 非好友
     * </pre>
     */
    emDisconnectNv_NotInPeerContact_Api(22, 33),
    /**
     * <code>emDisconnectNv_PeerNoP2PPermission_Api = 34;</code>
     *
     * <pre>
     *&lt; 对端无点对点权限
     * </pre>
     */
    emDisconnectNv_PeerNoP2PPermission_Api(23, 34),
    /**
     * <code>emDisconnectNv_PeerOnSleeping_Api = 35;</code>
     *
     * <pre>
     *&lt; 对端正在待机
     * </pre>
     */
    emDisconnectNv_PeerOnSleeping_Api(24, 35),
    /**
     * <code>emDisconnectNv_ConfAutoRelease_Api = 36;</code>
     *
     * <pre>
     *&lt; 会议自动结束挂断
     * </pre>
     */
    emDisconnectNv_ConfAutoRelease_Api(25, 36),
    /**
     * <code>emDisconnectNv_REASON_BUSYEXT_Api = 37;</code>
     *
     * <pre>
     *&lt; 终端忙,带终端目前所在会议的级别及会议名称(邀请终端失败时原因)
     * </pre>
     */
    emDisconnectNv_REASON_BUSYEXT_Api(26, 37),
    /**
     * <code>emDisconnectNv_REASON_REMOTERECONNECT_Api = 38;</code>
     *
     * <pre>
     *&lt; 本端行政级别低，由远端自动发起重连(邀请终端失败时原因)
     * </pre>
     */
    emDisconnectNv_REASON_REMOTERECONNECT_Api(27, 38),
    /**
     * <code>emDisconnectNv_CallNumExceed_Api = 39;</code>
     *
     * <pre>
     *&lt; 呼叫数超限
     * </pre>
     */
    emDisconnectNv_CallNumExceed_Api(28, 39),
    /**
     * <code>emDisconnectNv_NotRegedToCallFailed_Api = 40;</code>
     *
     * <pre>
     *本地没有注册成功导致呼叫别名或者e164号码有问题
     * </pre>
     */
    emDisconnectNv_NotRegedToCallFailed_Api(29, 40),
    /**
     * <code>emDisconnectNv_LocalVodPlaying_Api = 41;</code>
     *
     * <pre>
     *本地正在vod点播中
     * </pre>
     */
    emDisconnectNv_LocalVodPlaying_Api(30, 41),
    /**
     * <code>emDisconnectNv_SecCrtNotFind_Api = 42;</code>
     *
     * <pre>
     *&#47;//sec 注册失败reason
     * </pre>
     */
    emDisconnectNv_SecCrtNotFind_Api(31, 42),
    /**
     * <code>emDisconnectNv_SecCrtVerifyFail_Api = 43;</code>
     *
     * <pre>
     *证书验证失败
     * </pre>
     */
    emDisconnectNv_SecCrtVerifyFail_Api(32, 43),
    /**
     * <code>emDisconnectNv_SecCrtExpired_Api = 44;</code>
     *
     * <pre>
     *证书过期 有效期错误
     * </pre>
     */
    emDisconnectNv_SecCrtExpired_Api(33, 44),
    /**
     * <code>emDisconnectNv_SecCrtFormatError_Api = 45;</code>
     *
     * <pre>
     *证书格式错误
     * </pre>
     */
    emDisconnectNv_SecCrtFormatError_Api(34, 45),
    /**
     * <code>emDisconnectNv_SecLoadCertFailed_Api = 46;</code>
     *
     * <pre>
     *证书加载失败
     * </pre>
     */
    emDisconnectNv_SecLoadCertFailed_Api(35, 46),
    /**
     * <code>emDisconnectNv_SecEncTypeError_Api = 47;</code>
     *
     * <pre>
     *&#47;加密类型不一致
     * </pre>
     */
    emDisconnectNv_SecEncTypeError_Api(36, 47),
    /**
     * <code>emDisconnectNv_AuthenticationErr_Api = 48;</code>
     *
     * <pre>
     *强认证报错 一般是终端未强认证主呼强认证会议
     * </pre>
     */
    emDisconnectNv_AuthenticationErr_Api(37, 48),
    /**
     * <code>emDisconnectNv_MtHasInConf_Api = 49;</code>
     *
     * <pre>
     *主席邀请同一个终端入会提示
     * </pre>
     */
    emDisconnectNv_MtHasInConf_Api(38, 49),
    /**
     * <code>emDisconnectNv_End = 100;</code>
     *
     * <pre>
     *&lt; 前面用于扩展
     * </pre>
     */
    emDisconnectNv_End(39, 100),
    ;

    /**
     * <code>emDisconnectNv_Busy_Api = 0;</code>
     *
     * <pre>
     *&lt; 对端忙
     * </pre>
     */
    public static final int emDisconnectNv_Busy_Api_VALUE = 0;
    /**
     * <code>emDisconnectNv_Normal_Api = 1;</code>
     *
     * <pre>
     *&lt; 正常挂断
     * </pre>
     */
    public static final int emDisconnectNv_Normal_Api_VALUE = 1;
    /**
     * <code>emDisconnectNv_Rejected_Api = 2;</code>
     *
     * <pre>
     *&lt; 对端拒绝
     * </pre>
     */
    public static final int emDisconnectNv_Rejected_Api_VALUE = 2;
    /**
     * <code>emDisconnectNv_Unreachable_Api = 3;</code>
     *
     * <pre>
     *&lt; 对端不可达
     * </pre>
     */
    public static final int emDisconnectNv_Unreachable_Api_VALUE = 3;
    /**
     * <code>emDisconnectNv_Local_Api = 4;</code>
     *
     * <pre>
     *&lt; 本地原因
     * </pre>
     */
    public static final int emDisconnectNv_Local_Api_VALUE = 4;
    /**
     * <code>emDisconnectNv_Unknown_Api = 5;</code>
     *
     * <pre>
     *&lt; 未知原因
     * </pre>
     */
    public static final int emDisconnectNv_Unknown_Api_VALUE = 5;
    /**
     * <code>emDisconnectNv_custom_Api = 6;</code>
     *
     * <pre>
     *&lt; 自定义原因
     * </pre>
     */
    public static final int emDisconnectNv_custom_Api_VALUE = 6;
    /**
     * <code>emDisconnectNv_AdaptiveBusy_Api = 7;</code>
     *
     * <pre>
     *&lt; 接入电话终端失败
     * </pre>
     */
    public static final int emDisconnectNv_AdaptiveBusy_Api_VALUE = 7;
    /**
     * <code>emDisconnectNv_Occupy_Api = 8;</code>
     *
     * <pre>
     *其他终端或者mcu抢断
     * </pre>
     */
    public static final int emDisconnectNv_Occupy_Api_VALUE = 8;
    /**
     * <code>emDisconnectNv_Joinconftimeout_Api = 20;</code>
     *
     * <pre>
     *&lt; 参加会议超时
     * </pre>
     */
    public static final int emDisconnectNv_Joinconftimeout_Api_VALUE = 20;
    /**
     * <code>emDisconnectNv_Createconftimeout_Api = 21;</code>
     *
     * <pre>
     *&#47;&lt; 召集会议超时
     * </pre>
     */
    public static final int emDisconnectNv_Createconftimeout_Api_VALUE = 21;
    /**
     * <code>emDisconnectNv_Nomediaresource_Api = 22;</code>
     *
     * <pre>
     *&lt; 没有媒体资源
     * </pre>
     */
    public static final int emDisconnectNv_Nomediaresource_Api_VALUE = 22;
    /**
     * <code>emDisconnectNv_Exceedmaxinconfmtnum_Api = 23;</code>
     *
     * <pre>
     *&lt; 超过会议最大终端数（参加会议时）
     * </pre>
     */
    public static final int emDisconnectNv_Exceedmaxinconfmtnum_Api_VALUE = 23;
    /**
     * <code>emDisconnectNv_Exceedmaxconfnum_Api = 24;</code>
     *
     * <pre>
     *&lt; 超过会议最大数（创建会议时）
     * </pre>
     */
    public static final int emDisconnectNv_Exceedmaxconfnum_Api_VALUE = 24;
    /**
     * <code>emDisconnectNv_EncrypeErr_Api = 25;</code>
     *
     * <pre>
     *&lt; 与会议加密模式不符
     * </pre>
     */
    public static final int emDisconnectNv_EncrypeErr_Api_VALUE = 25;
    /**
     * <code>emDisconnectNv_P2Ptimeout_Api = 26;</code>
     *
     * <pre>
     *&lt; 点对点呼叫超时
     * </pre>
     */
    public static final int emDisconnectNv_P2Ptimeout_Api_VALUE = 26;
    /**
     * <code>emDisconnectNv_MccDrop_Api = 27;</code>
     *
     * <pre>
     *&lt; 会控挂断
     * </pre>
     */
    public static final int emDisconnectNv_MccDrop_Api_VALUE = 27;
    /**
     * <code>emDisconnectNv_ChairDrop_Api = 28;</code>
     *
     * <pre>
     *&lt; 主席挂断
     * </pre>
     */
    public static final int emDisconnectNv_ChairDrop_Api_VALUE = 28;
    /**
     * <code>emDisconnectNv_MMcuDrop_Api = 29;</code>
     *
     * <pre>
     *&lt; 上级会议挂断
     * </pre>
     */
    public static final int emDisconnectNv_MMcuDrop_Api_VALUE = 29;
    /**
     * <code>emDisconnectNv_ConfRelease_Api = 30;</code>
     *
     * <pre>
     *&lt; 会议结束挂断
     * </pre>
     */
    public static final int emDisconnectNv_ConfRelease_Api_VALUE = 30;
    /**
     * <code>emDisconnectNv_PeerInConf_Api = 31;</code>
     *
     * <pre>
     *&lt; 正在会议中
     * </pre>
     */
    public static final int emDisconnectNv_PeerInConf_Api_VALUE = 31;
    /**
     * <code>emDisconnectNv_PeerNoDisturb_Api = 32;</code>
     *
     * <pre>
     *&lt; 免打扰
     * </pre>
     */
    public static final int emDisconnectNv_PeerNoDisturb_Api_VALUE = 32;
    /**
     * <code>emDisconnectNv_NotInPeerContact_Api = 33;</code>
     *
     * <pre>
     *&lt; 非好友
     * </pre>
     */
    public static final int emDisconnectNv_NotInPeerContact_Api_VALUE = 33;
    /**
     * <code>emDisconnectNv_PeerNoP2PPermission_Api = 34;</code>
     *
     * <pre>
     *&lt; 对端无点对点权限
     * </pre>
     */
    public static final int emDisconnectNv_PeerNoP2PPermission_Api_VALUE = 34;
    /**
     * <code>emDisconnectNv_PeerOnSleeping_Api = 35;</code>
     *
     * <pre>
     *&lt; 对端正在待机
     * </pre>
     */
    public static final int emDisconnectNv_PeerOnSleeping_Api_VALUE = 35;
    /**
     * <code>emDisconnectNv_ConfAutoRelease_Api = 36;</code>
     *
     * <pre>
     *&lt; 会议自动结束挂断
     * </pre>
     */
    public static final int emDisconnectNv_ConfAutoRelease_Api_VALUE = 36;
    /**
     * <code>emDisconnectNv_REASON_BUSYEXT_Api = 37;</code>
     *
     * <pre>
     *&lt; 终端忙,带终端目前所在会议的级别及会议名称(邀请终端失败时原因)
     * </pre>
     */
    public static final int emDisconnectNv_REASON_BUSYEXT_Api_VALUE = 37;
    /**
     * <code>emDisconnectNv_REASON_REMOTERECONNECT_Api = 38;</code>
     *
     * <pre>
     *&lt; 本端行政级别低，由远端自动发起重连(邀请终端失败时原因)
     * </pre>
     */
    public static final int emDisconnectNv_REASON_REMOTERECONNECT_Api_VALUE = 38;
    /**
     * <code>emDisconnectNv_CallNumExceed_Api = 39;</code>
     *
     * <pre>
     *&lt; 呼叫数超限
     * </pre>
     */
    public static final int emDisconnectNv_CallNumExceed_Api_VALUE = 39;
    /**
     * <code>emDisconnectNv_NotRegedToCallFailed_Api = 40;</code>
     *
     * <pre>
     *本地没有注册成功导致呼叫别名或者e164号码有问题
     * </pre>
     */
    public static final int emDisconnectNv_NotRegedToCallFailed_Api_VALUE = 40;
    /**
     * <code>emDisconnectNv_LocalVodPlaying_Api = 41;</code>
     *
     * <pre>
     *本地正在vod点播中
     * </pre>
     */
    public static final int emDisconnectNv_LocalVodPlaying_Api_VALUE = 41;
    /**
     * <code>emDisconnectNv_SecCrtNotFind_Api = 42;</code>
     *
     * <pre>
     *&#47;//sec 注册失败reason
     * </pre>
     */
    public static final int emDisconnectNv_SecCrtNotFind_Api_VALUE = 42;
    /**
     * <code>emDisconnectNv_SecCrtVerifyFail_Api = 43;</code>
     *
     * <pre>
     *证书验证失败
     * </pre>
     */
    public static final int emDisconnectNv_SecCrtVerifyFail_Api_VALUE = 43;
    /**
     * <code>emDisconnectNv_SecCrtExpired_Api = 44;</code>
     *
     * <pre>
     *证书过期 有效期错误
     * </pre>
     */
    public static final int emDisconnectNv_SecCrtExpired_Api_VALUE = 44;
    /**
     * <code>emDisconnectNv_SecCrtFormatError_Api = 45;</code>
     *
     * <pre>
     *证书格式错误
     * </pre>
     */
    public static final int emDisconnectNv_SecCrtFormatError_Api_VALUE = 45;
    /**
     * <code>emDisconnectNv_SecLoadCertFailed_Api = 46;</code>
     *
     * <pre>
     *证书加载失败
     * </pre>
     */
    public static final int emDisconnectNv_SecLoadCertFailed_Api_VALUE = 46;
    /**
     * <code>emDisconnectNv_SecEncTypeError_Api = 47;</code>
     *
     * <pre>
     *&#47;加密类型不一致
     * </pre>
     */
    public static final int emDisconnectNv_SecEncTypeError_Api_VALUE = 47;
    /**
     * <code>emDisconnectNv_AuthenticationErr_Api = 48;</code>
     *
     * <pre>
     *强认证报错 一般是终端未强认证主呼强认证会议
     * </pre>
     */
    public static final int emDisconnectNv_AuthenticationErr_Api_VALUE = 48;
    /**
     * <code>emDisconnectNv_MtHasInConf_Api = 49;</code>
     *
     * <pre>
     *主席邀请同一个终端入会提示
     * </pre>
     */
    public static final int emDisconnectNv_MtHasInConf_Api_VALUE = 49;
    /**
     * <code>emDisconnectNv_End = 100;</code>
     *
     * <pre>
     *&lt; 前面用于扩展
     * </pre>
     */
    public static final int emDisconnectNv_End_VALUE = 100;


    public final int getNumber() { return value; }

    public static EmNvCallDisReason valueOf(int value) {
      switch (value) {
        case 0: return emDisconnectNv_Busy_Api;
        case 1: return emDisconnectNv_Normal_Api;
        case 2: return emDisconnectNv_Rejected_Api;
        case 3: return emDisconnectNv_Unreachable_Api;
        case 4: return emDisconnectNv_Local_Api;
        case 5: return emDisconnectNv_Unknown_Api;
        case 6: return emDisconnectNv_custom_Api;
        case 7: return emDisconnectNv_AdaptiveBusy_Api;
        case 8: return emDisconnectNv_Occupy_Api;
        case 20: return emDisconnectNv_Joinconftimeout_Api;
        case 21: return emDisconnectNv_Createconftimeout_Api;
        case 22: return emDisconnectNv_Nomediaresource_Api;
        case 23: return emDisconnectNv_Exceedmaxinconfmtnum_Api;
        case 24: return emDisconnectNv_Exceedmaxconfnum_Api;
        case 25: return emDisconnectNv_EncrypeErr_Api;
        case 26: return emDisconnectNv_P2Ptimeout_Api;
        case 27: return emDisconnectNv_MccDrop_Api;
        case 28: return emDisconnectNv_ChairDrop_Api;
        case 29: return emDisconnectNv_MMcuDrop_Api;
        case 30: return emDisconnectNv_ConfRelease_Api;
        case 31: return emDisconnectNv_PeerInConf_Api;
        case 32: return emDisconnectNv_PeerNoDisturb_Api;
        case 33: return emDisconnectNv_NotInPeerContact_Api;
        case 34: return emDisconnectNv_PeerNoP2PPermission_Api;
        case 35: return emDisconnectNv_PeerOnSleeping_Api;
        case 36: return emDisconnectNv_ConfAutoRelease_Api;
        case 37: return emDisconnectNv_REASON_BUSYEXT_Api;
        case 38: return emDisconnectNv_REASON_REMOTERECONNECT_Api;
        case 39: return emDisconnectNv_CallNumExceed_Api;
        case 40: return emDisconnectNv_NotRegedToCallFailed_Api;
        case 41: return emDisconnectNv_LocalVodPlaying_Api;
        case 42: return emDisconnectNv_SecCrtNotFind_Api;
        case 43: return emDisconnectNv_SecCrtVerifyFail_Api;
        case 44: return emDisconnectNv_SecCrtExpired_Api;
        case 45: return emDisconnectNv_SecCrtFormatError_Api;
        case 46: return emDisconnectNv_SecLoadCertFailed_Api;
        case 47: return emDisconnectNv_SecEncTypeError_Api;
        case 48: return emDisconnectNv_AuthenticationErr_Api;
        case 49: return emDisconnectNv_MtHasInConf_Api;
        case 100: return emDisconnectNv_End;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvCallDisReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvCallDisReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvCallDisReason>() {
            public EmNvCallDisReason findValueByNumber(int number) {
              return EmNvCallDisReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(85);
    }

    private static final EmNvCallDisReason[] VALUES = values();

    public static EmNvCallDisReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvCallDisReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvCallDisReason)
  }

  /**
   * Protobuf enum {@code nv.NvEndpointType}
   *
   * <pre>
   *终端类型
   * </pre>
   */
  public enum NvEndpointType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvEndpointTypeUnknown_Api = 0;</code>
     *
     * <pre>
     *&lt;未知类型
     * </pre>
     */
    emNvEndpointTypeUnknown_Api(0, 0),
    /**
     * <code>emNvEndpointTypeMT_Api = 1;</code>
     *
     * <pre>
     *&lt;终端
     * </pre>
     */
    emNvEndpointTypeMT_Api(1, 1),
    /**
     * <code>emNvEndpointTypeMCU_Api = 2;</code>
     *
     * <pre>
     *&lt;MCU
     * </pre>
     */
    emNvEndpointTypeMCU_Api(2, 2),
    /**
     * <code>emNvEndpointTypeGK_Api = 4;</code>
     *
     * <pre>
     *&lt;GK
     * </pre>
     */
    emNvEndpointTypeGK_Api(3, 4),
    ;

    /**
     * <code>emNvEndpointTypeUnknown_Api = 0;</code>
     *
     * <pre>
     *&lt;未知类型
     * </pre>
     */
    public static final int emNvEndpointTypeUnknown_Api_VALUE = 0;
    /**
     * <code>emNvEndpointTypeMT_Api = 1;</code>
     *
     * <pre>
     *&lt;终端
     * </pre>
     */
    public static final int emNvEndpointTypeMT_Api_VALUE = 1;
    /**
     * <code>emNvEndpointTypeMCU_Api = 2;</code>
     *
     * <pre>
     *&lt;MCU
     * </pre>
     */
    public static final int emNvEndpointTypeMCU_Api_VALUE = 2;
    /**
     * <code>emNvEndpointTypeGK_Api = 4;</code>
     *
     * <pre>
     *&lt;GK
     * </pre>
     */
    public static final int emNvEndpointTypeGK_Api_VALUE = 4;


    public final int getNumber() { return value; }

    public static NvEndpointType valueOf(int value) {
      switch (value) {
        case 0: return emNvEndpointTypeUnknown_Api;
        case 1: return emNvEndpointTypeMT_Api;
        case 2: return emNvEndpointTypeMCU_Api;
        case 4: return emNvEndpointTypeGK_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<NvEndpointType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<NvEndpointType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<NvEndpointType>() {
            public NvEndpointType findValueByNumber(int number) {
              return NvEndpointType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(86);
    }

    private static final NvEndpointType[] VALUES = values();

    public static NvEndpointType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private NvEndpointType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.NvEndpointType)
  }

  /**
   * Protobuf enum {@code nv.EmNvVideoPort_Api}
   *
   * <pre>
   ** 终端视频端口 
   * </pre>
   */
  public enum EmNvVideoPort_Api
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvVidInvalid_Api = 0;</code>
     */
    emNvVidInvalid_Api(0, 0),
    /**
     * <code>emNvVidMultiView_Api = 1;</code>
     */
    emNvVidMultiView_Api(1, 1),
    /**
     * <code>emNvVidInnerCamera_Api = 2;</code>
     */
    emNvVidInnerCamera_Api(2, 2),
    /**
     * <code>emNvVidDVI1_Api = 3;</code>
     */
    emNvVidDVI1_Api(3, 3),
    /**
     * <code>emNvVidDVI2_Api = 4;</code>
     */
    emNvVidDVI2_Api(4, 4),
    /**
     * <code>emNvVidDVI3_Api = 5;</code>
     */
    emNvVidDVI3_Api(5, 5),
    /**
     * <code>emNvVidDVI4_Api = 6;</code>
     */
    emNvVidDVI4_Api(6, 6),
    /**
     * <code>emNvVidHDMI1_Api = 7;</code>
     */
    emNvVidHDMI1_Api(7, 7),
    /**
     * <code>emNvVidHDMI2_Api = 8;</code>
     */
    emNvVidHDMI2_Api(8, 8),
    /**
     * <code>emNvVidHDMI3_Api = 9;</code>
     */
    emNvVidHDMI3_Api(9, 9),
    /**
     * <code>emNvVidHDMI4_Api = 10;</code>
     */
    emNvVidHDMI4_Api(10, 10),
    /**
     * <code>emNvVidYPbPr1_Api = 11;</code>
     */
    emNvVidYPbPr1_Api(11, 11),
    /**
     * <code>emNvVidYPbPr2_Api = 12;</code>
     */
    emNvVidYPbPr2_Api(12, 12),
    /**
     * <code>emNvVidYPbPr3_Api = 13;</code>
     */
    emNvVidYPbPr3_Api(13, 13),
    /**
     * <code>emNvVidYPbPr4_Api = 14;</code>
     */
    emNvVidYPbPr4_Api(14, 14),
    /**
     * <code>emNvVidVGA1_Api = 15;</code>
     */
    emNvVidVGA1_Api(15, 15),
    /**
     * <code>emNvVidVGA2_Api = 16;</code>
     */
    emNvVidVGA2_Api(16, 16),
    /**
     * <code>emNvVidVGA3_Api = 17;</code>
     */
    emNvVidVGA3_Api(17, 17),
    /**
     * <code>emNvVidVGA4_Api = 18;</code>
     */
    emNvVidVGA4_Api(18, 18),
    /**
     * <code>emNvVidC1_Api = 19;</code>
     */
    emNvVidC1_Api(19, 19),
    /**
     * <code>emNvVidC2_Api = 20;</code>
     */
    emNvVidC2_Api(20, 20),
    /**
     * <code>emNvVidC3_Api = 21;</code>
     */
    emNvVidC3_Api(21, 21),
    /**
     * <code>emNvVidS1_Api = 22;</code>
     */
    emNvVidS1_Api(22, 22),
    /**
     * <code>emNvVidS2_Api = 23;</code>
     */
    emNvVidS2_Api(23, 23),
    /**
     * <code>emNvVidS3_Api = 24;</code>
     */
    emNvVidS3_Api(24, 24),
    /**
     * <code>emNvVidHDBaseT1_Api = 25;</code>
     */
    emNvVidHDBaseT1_Api(25, 25),
    /**
     * <code>emNvVidHDBaseT2_Api = 26;</code>
     */
    emNvVidHDBaseT2_Api(26, 26),
    /**
     * <code>emNvVidHDBaseT3_Api = 27;</code>
     */
    emNvVidHDBaseT3_Api(27, 27),
    /**
     * <code>emNvVidHDBaseT4_Api = 28;</code>
     */
    emNvVidHDBaseT4_Api(28, 28),
    /**
     * <code>emNvVidSDI1_Api = 29;</code>
     */
    emNvVidSDI1_Api(29, 29),
    /**
     * <code>emNvVidSDI2_Api = 30;</code>
     */
    emNvVidSDI2_Api(30, 30),
    /**
     * <code>emNvVidSDI3_Api = 31;</code>
     */
    emNvVidSDI3_Api(31, 31),
    /**
     * <code>emNvVidSDI4_Api = 32;</code>
     */
    emNvVidSDI4_Api(32, 32),
    ;

    /**
     * <code>emNvVidInvalid_Api = 0;</code>
     */
    public static final int emNvVidInvalid_Api_VALUE = 0;
    /**
     * <code>emNvVidMultiView_Api = 1;</code>
     */
    public static final int emNvVidMultiView_Api_VALUE = 1;
    /**
     * <code>emNvVidInnerCamera_Api = 2;</code>
     */
    public static final int emNvVidInnerCamera_Api_VALUE = 2;
    /**
     * <code>emNvVidDVI1_Api = 3;</code>
     */
    public static final int emNvVidDVI1_Api_VALUE = 3;
    /**
     * <code>emNvVidDVI2_Api = 4;</code>
     */
    public static final int emNvVidDVI2_Api_VALUE = 4;
    /**
     * <code>emNvVidDVI3_Api = 5;</code>
     */
    public static final int emNvVidDVI3_Api_VALUE = 5;
    /**
     * <code>emNvVidDVI4_Api = 6;</code>
     */
    public static final int emNvVidDVI4_Api_VALUE = 6;
    /**
     * <code>emNvVidHDMI1_Api = 7;</code>
     */
    public static final int emNvVidHDMI1_Api_VALUE = 7;
    /**
     * <code>emNvVidHDMI2_Api = 8;</code>
     */
    public static final int emNvVidHDMI2_Api_VALUE = 8;
    /**
     * <code>emNvVidHDMI3_Api = 9;</code>
     */
    public static final int emNvVidHDMI3_Api_VALUE = 9;
    /**
     * <code>emNvVidHDMI4_Api = 10;</code>
     */
    public static final int emNvVidHDMI4_Api_VALUE = 10;
    /**
     * <code>emNvVidYPbPr1_Api = 11;</code>
     */
    public static final int emNvVidYPbPr1_Api_VALUE = 11;
    /**
     * <code>emNvVidYPbPr2_Api = 12;</code>
     */
    public static final int emNvVidYPbPr2_Api_VALUE = 12;
    /**
     * <code>emNvVidYPbPr3_Api = 13;</code>
     */
    public static final int emNvVidYPbPr3_Api_VALUE = 13;
    /**
     * <code>emNvVidYPbPr4_Api = 14;</code>
     */
    public static final int emNvVidYPbPr4_Api_VALUE = 14;
    /**
     * <code>emNvVidVGA1_Api = 15;</code>
     */
    public static final int emNvVidVGA1_Api_VALUE = 15;
    /**
     * <code>emNvVidVGA2_Api = 16;</code>
     */
    public static final int emNvVidVGA2_Api_VALUE = 16;
    /**
     * <code>emNvVidVGA3_Api = 17;</code>
     */
    public static final int emNvVidVGA3_Api_VALUE = 17;
    /**
     * <code>emNvVidVGA4_Api = 18;</code>
     */
    public static final int emNvVidVGA4_Api_VALUE = 18;
    /**
     * <code>emNvVidC1_Api = 19;</code>
     */
    public static final int emNvVidC1_Api_VALUE = 19;
    /**
     * <code>emNvVidC2_Api = 20;</code>
     */
    public static final int emNvVidC2_Api_VALUE = 20;
    /**
     * <code>emNvVidC3_Api = 21;</code>
     */
    public static final int emNvVidC3_Api_VALUE = 21;
    /**
     * <code>emNvVidS1_Api = 22;</code>
     */
    public static final int emNvVidS1_Api_VALUE = 22;
    /**
     * <code>emNvVidS2_Api = 23;</code>
     */
    public static final int emNvVidS2_Api_VALUE = 23;
    /**
     * <code>emNvVidS3_Api = 24;</code>
     */
    public static final int emNvVidS3_Api_VALUE = 24;
    /**
     * <code>emNvVidHDBaseT1_Api = 25;</code>
     */
    public static final int emNvVidHDBaseT1_Api_VALUE = 25;
    /**
     * <code>emNvVidHDBaseT2_Api = 26;</code>
     */
    public static final int emNvVidHDBaseT2_Api_VALUE = 26;
    /**
     * <code>emNvVidHDBaseT3_Api = 27;</code>
     */
    public static final int emNvVidHDBaseT3_Api_VALUE = 27;
    /**
     * <code>emNvVidHDBaseT4_Api = 28;</code>
     */
    public static final int emNvVidHDBaseT4_Api_VALUE = 28;
    /**
     * <code>emNvVidSDI1_Api = 29;</code>
     */
    public static final int emNvVidSDI1_Api_VALUE = 29;
    /**
     * <code>emNvVidSDI2_Api = 30;</code>
     */
    public static final int emNvVidSDI2_Api_VALUE = 30;
    /**
     * <code>emNvVidSDI3_Api = 31;</code>
     */
    public static final int emNvVidSDI3_Api_VALUE = 31;
    /**
     * <code>emNvVidSDI4_Api = 32;</code>
     */
    public static final int emNvVidSDI4_Api_VALUE = 32;


    public final int getNumber() { return value; }

    public static EmNvVideoPort_Api valueOf(int value) {
      switch (value) {
        case 0: return emNvVidInvalid_Api;
        case 1: return emNvVidMultiView_Api;
        case 2: return emNvVidInnerCamera_Api;
        case 3: return emNvVidDVI1_Api;
        case 4: return emNvVidDVI2_Api;
        case 5: return emNvVidDVI3_Api;
        case 6: return emNvVidDVI4_Api;
        case 7: return emNvVidHDMI1_Api;
        case 8: return emNvVidHDMI2_Api;
        case 9: return emNvVidHDMI3_Api;
        case 10: return emNvVidHDMI4_Api;
        case 11: return emNvVidYPbPr1_Api;
        case 12: return emNvVidYPbPr2_Api;
        case 13: return emNvVidYPbPr3_Api;
        case 14: return emNvVidYPbPr4_Api;
        case 15: return emNvVidVGA1_Api;
        case 16: return emNvVidVGA2_Api;
        case 17: return emNvVidVGA3_Api;
        case 18: return emNvVidVGA4_Api;
        case 19: return emNvVidC1_Api;
        case 20: return emNvVidC2_Api;
        case 21: return emNvVidC3_Api;
        case 22: return emNvVidS1_Api;
        case 23: return emNvVidS2_Api;
        case 24: return emNvVidS3_Api;
        case 25: return emNvVidHDBaseT1_Api;
        case 26: return emNvVidHDBaseT2_Api;
        case 27: return emNvVidHDBaseT3_Api;
        case 28: return emNvVidHDBaseT4_Api;
        case 29: return emNvVidSDI1_Api;
        case 30: return emNvVidSDI2_Api;
        case 31: return emNvVidSDI3_Api;
        case 32: return emNvVidSDI4_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoPort_Api>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoPort_Api>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvVideoPort_Api>() {
            public EmNvVideoPort_Api findValueByNumber(int number) {
              return EmNvVideoPort_Api.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(87);
    }

    private static final EmNvVideoPort_Api[] VALUES = values();

    public static EmNvVideoPort_Api valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvVideoPort_Api(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvVideoPort_Api)
  }

  /**
   * Protobuf enum {@code nv.EmNvVideoOutType_Api}
   *
   * <pre>
   ** 视频输出接口定义 
   * </pre>
   */
  public enum EmNvVideoOutType_Api
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVOTNv_Invalid_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;无效视频接口
     * </pre>
     */
    emVOTNv_Invalid_Api(0, 0),
    /**
     * <code>emVOTNv_DVI1_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;dvi1
     * </pre>
     */
    emVOTNv_DVI1_Api(1, 1),
    /**
     * <code>emVOTNv_DVI2_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;dvi2
     * </pre>
     */
    emVOTNv_DVI2_Api(2, 2),
    /**
     * <code>emVOTNv_DVI3_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt;dvi3
     * </pre>
     */
    emVOTNv_DVI3_Api(3, 3),
    /**
     * <code>emVOTNv_DVI4_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt;dvi4
     * </pre>
     */
    emVOTNv_DVI4_Api(4, 4),
    /**
     * <code>emVOTNv_HDMI1_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt;hdmi1
     * </pre>
     */
    emVOTNv_HDMI1_Api(5, 5),
    /**
     * <code>emVOTNv_HDMI2_Api = 6;</code>
     *
     * <pre>
     *&#47;&lt;hdmi2
     * </pre>
     */
    emVOTNv_HDMI2_Api(6, 6),
    /**
     * <code>emVOTNv_HDMI3_Api = 7;</code>
     *
     * <pre>
     *&#47;&lt;hdmi3
     * </pre>
     */
    emVOTNv_HDMI3_Api(7, 7),
    /**
     * <code>emVOTNv_HDMI4_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt;hdmi4
     * </pre>
     */
    emVOTNv_HDMI4_Api(8, 8),
    /**
     * <code>emVOTNv_YPbPr1_Api = 9;</code>
     *
     * <pre>
     *&#47;&lt;YPbPr1
     * </pre>
     */
    emVOTNv_YPbPr1_Api(9, 9),
    /**
     * <code>emVOTNv_YPbPr2_Api = 10;</code>
     *
     * <pre>
     *&#47;&lt;YPbPr2
     * </pre>
     */
    emVOTNv_YPbPr2_Api(10, 10),
    /**
     * <code>emVOTNv_YPbPr3_Api = 11;</code>
     *
     * <pre>
     *&#47;&lt;YPbPr3
     * </pre>
     */
    emVOTNv_YPbPr3_Api(11, 11),
    /**
     * <code>emVOTNv_YPbPr4_Api = 12;</code>
     *
     * <pre>
     *&#47;&lt;YPbPr4
     * </pre>
     */
    emVOTNv_YPbPr4_Api(12, 12),
    /**
     * <code>emVOTNv_VGA1_Api = 13;</code>
     *
     * <pre>
     *&#47;&lt;vga1
     * </pre>
     */
    emVOTNv_VGA1_Api(13, 13),
    /**
     * <code>emVOTNv_VGA2_Api = 14;</code>
     *
     * <pre>
     *&#47;&lt;vga2
     * </pre>
     */
    emVOTNv_VGA2_Api(14, 14),
    /**
     * <code>emVOTNv_VGA3_Api = 15;</code>
     *
     * <pre>
     *&#47;&lt;vga3
     * </pre>
     */
    emVOTNv_VGA3_Api(15, 15),
    /**
     * <code>emVOTNv_VGA4_Api = 16;</code>
     *
     * <pre>
     *&#47;&lt;vga4
     * </pre>
     */
    emVOTNv_VGA4_Api(16, 16),
    /**
     * <code>emVOTNv_SDI1_Api = 17;</code>
     *
     * <pre>
     *&#47;&lt;sdi1
     * </pre>
     */
    emVOTNv_SDI1_Api(17, 17),
    /**
     * <code>emVOTNv_SDI2_Api = 18;</code>
     *
     * <pre>
     *&#47;&lt;sdi2
     * </pre>
     */
    emVOTNv_SDI2_Api(18, 18),
    /**
     * <code>emVOTNv_SDI3_Api = 19;</code>
     *
     * <pre>
     *&#47;&lt;sdi3
     * </pre>
     */
    emVOTNv_SDI3_Api(19, 19),
    /**
     * <code>emVOTNv_SDI4_Api = 20;</code>
     *
     * <pre>
     *&#47;&lt;sdi4
     * </pre>
     */
    emVOTNv_SDI4_Api(20, 20),
    /**
     * <code>emVOTNv_C1_Api = 21;</code>
     *
     * <pre>
     *&#47;&lt;cvbs1
     * </pre>
     */
    emVOTNv_C1_Api(21, 21),
    /**
     * <code>emVOTNv_C2_Api = 22;</code>
     *
     * <pre>
     *&#47;&lt;cvbs2
     * </pre>
     */
    emVOTNv_C2_Api(22, 22),
    /**
     * <code>emVOTNv_C3_Api = 23;</code>
     *
     * <pre>
     *&#47;&lt;cvbs3
     * </pre>
     */
    emVOTNv_C3_Api(23, 23),
    ;

    /**
     * <code>emVOTNv_Invalid_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;无效视频接口
     * </pre>
     */
    public static final int emVOTNv_Invalid_Api_VALUE = 0;
    /**
     * <code>emVOTNv_DVI1_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;dvi1
     * </pre>
     */
    public static final int emVOTNv_DVI1_Api_VALUE = 1;
    /**
     * <code>emVOTNv_DVI2_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;dvi2
     * </pre>
     */
    public static final int emVOTNv_DVI2_Api_VALUE = 2;
    /**
     * <code>emVOTNv_DVI3_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt;dvi3
     * </pre>
     */
    public static final int emVOTNv_DVI3_Api_VALUE = 3;
    /**
     * <code>emVOTNv_DVI4_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt;dvi4
     * </pre>
     */
    public static final int emVOTNv_DVI4_Api_VALUE = 4;
    /**
     * <code>emVOTNv_HDMI1_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt;hdmi1
     * </pre>
     */
    public static final int emVOTNv_HDMI1_Api_VALUE = 5;
    /**
     * <code>emVOTNv_HDMI2_Api = 6;</code>
     *
     * <pre>
     *&#47;&lt;hdmi2
     * </pre>
     */
    public static final int emVOTNv_HDMI2_Api_VALUE = 6;
    /**
     * <code>emVOTNv_HDMI3_Api = 7;</code>
     *
     * <pre>
     *&#47;&lt;hdmi3
     * </pre>
     */
    public static final int emVOTNv_HDMI3_Api_VALUE = 7;
    /**
     * <code>emVOTNv_HDMI4_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt;hdmi4
     * </pre>
     */
    public static final int emVOTNv_HDMI4_Api_VALUE = 8;
    /**
     * <code>emVOTNv_YPbPr1_Api = 9;</code>
     *
     * <pre>
     *&#47;&lt;YPbPr1
     * </pre>
     */
    public static final int emVOTNv_YPbPr1_Api_VALUE = 9;
    /**
     * <code>emVOTNv_YPbPr2_Api = 10;</code>
     *
     * <pre>
     *&#47;&lt;YPbPr2
     * </pre>
     */
    public static final int emVOTNv_YPbPr2_Api_VALUE = 10;
    /**
     * <code>emVOTNv_YPbPr3_Api = 11;</code>
     *
     * <pre>
     *&#47;&lt;YPbPr3
     * </pre>
     */
    public static final int emVOTNv_YPbPr3_Api_VALUE = 11;
    /**
     * <code>emVOTNv_YPbPr4_Api = 12;</code>
     *
     * <pre>
     *&#47;&lt;YPbPr4
     * </pre>
     */
    public static final int emVOTNv_YPbPr4_Api_VALUE = 12;
    /**
     * <code>emVOTNv_VGA1_Api = 13;</code>
     *
     * <pre>
     *&#47;&lt;vga1
     * </pre>
     */
    public static final int emVOTNv_VGA1_Api_VALUE = 13;
    /**
     * <code>emVOTNv_VGA2_Api = 14;</code>
     *
     * <pre>
     *&#47;&lt;vga2
     * </pre>
     */
    public static final int emVOTNv_VGA2_Api_VALUE = 14;
    /**
     * <code>emVOTNv_VGA3_Api = 15;</code>
     *
     * <pre>
     *&#47;&lt;vga3
     * </pre>
     */
    public static final int emVOTNv_VGA3_Api_VALUE = 15;
    /**
     * <code>emVOTNv_VGA4_Api = 16;</code>
     *
     * <pre>
     *&#47;&lt;vga4
     * </pre>
     */
    public static final int emVOTNv_VGA4_Api_VALUE = 16;
    /**
     * <code>emVOTNv_SDI1_Api = 17;</code>
     *
     * <pre>
     *&#47;&lt;sdi1
     * </pre>
     */
    public static final int emVOTNv_SDI1_Api_VALUE = 17;
    /**
     * <code>emVOTNv_SDI2_Api = 18;</code>
     *
     * <pre>
     *&#47;&lt;sdi2
     * </pre>
     */
    public static final int emVOTNv_SDI2_Api_VALUE = 18;
    /**
     * <code>emVOTNv_SDI3_Api = 19;</code>
     *
     * <pre>
     *&#47;&lt;sdi3
     * </pre>
     */
    public static final int emVOTNv_SDI3_Api_VALUE = 19;
    /**
     * <code>emVOTNv_SDI4_Api = 20;</code>
     *
     * <pre>
     *&#47;&lt;sdi4
     * </pre>
     */
    public static final int emVOTNv_SDI4_Api_VALUE = 20;
    /**
     * <code>emVOTNv_C1_Api = 21;</code>
     *
     * <pre>
     *&#47;&lt;cvbs1
     * </pre>
     */
    public static final int emVOTNv_C1_Api_VALUE = 21;
    /**
     * <code>emVOTNv_C2_Api = 22;</code>
     *
     * <pre>
     *&#47;&lt;cvbs2
     * </pre>
     */
    public static final int emVOTNv_C2_Api_VALUE = 22;
    /**
     * <code>emVOTNv_C3_Api = 23;</code>
     *
     * <pre>
     *&#47;&lt;cvbs3
     * </pre>
     */
    public static final int emVOTNv_C3_Api_VALUE = 23;


    public final int getNumber() { return value; }

    public static EmNvVideoOutType_Api valueOf(int value) {
      switch (value) {
        case 0: return emVOTNv_Invalid_Api;
        case 1: return emVOTNv_DVI1_Api;
        case 2: return emVOTNv_DVI2_Api;
        case 3: return emVOTNv_DVI3_Api;
        case 4: return emVOTNv_DVI4_Api;
        case 5: return emVOTNv_HDMI1_Api;
        case 6: return emVOTNv_HDMI2_Api;
        case 7: return emVOTNv_HDMI3_Api;
        case 8: return emVOTNv_HDMI4_Api;
        case 9: return emVOTNv_YPbPr1_Api;
        case 10: return emVOTNv_YPbPr2_Api;
        case 11: return emVOTNv_YPbPr3_Api;
        case 12: return emVOTNv_YPbPr4_Api;
        case 13: return emVOTNv_VGA1_Api;
        case 14: return emVOTNv_VGA2_Api;
        case 15: return emVOTNv_VGA3_Api;
        case 16: return emVOTNv_VGA4_Api;
        case 17: return emVOTNv_SDI1_Api;
        case 18: return emVOTNv_SDI2_Api;
        case 19: return emVOTNv_SDI3_Api;
        case 20: return emVOTNv_SDI4_Api;
        case 21: return emVOTNv_C1_Api;
        case 22: return emVOTNv_C2_Api;
        case 23: return emVOTNv_C3_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoOutType_Api>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoOutType_Api>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvVideoOutType_Api>() {
            public EmNvVideoOutType_Api findValueByNumber(int number) {
              return EmNvVideoOutType_Api.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(88);
    }

    private static final EmNvVideoOutType_Api[] VALUES = values();

    public static EmNvVideoOutType_Api valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvVideoOutType_Api(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvVideoOutType_Api)
  }

  /**
   * Protobuf enum {@code nv.EmNvVideoSourceType_Api}
   *
   * <pre>
   ** 视频输出口的输入源定义
   * </pre>
   */
  public enum EmNvVideoSourceType_Api
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNv_Invalid_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;无效视频源
     * </pre>
     */
    emNv_Invalid_Api(0, 0),
    /**
     * <code>emNv_1stDec_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;第1路解码
     * </pre>
     */
    emNv_1stDec_Api(1, 1),
    /**
     * <code>emNv_2ndDec_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;第2路解码
     * </pre>
     */
    emNv_2ndDec_Api(2, 2),
    /**
     * <code>emNv_3rdDec_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt;第3路解码
     * </pre>
     */
    emNv_3rdDec_Api(3, 3),
    /**
     * <code>emNv_4thDec_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt;第4路解码
     * </pre>
     */
    emNv_4thDec_Api(4, 4),
    /**
     * <code>emNv_5thDec_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt;第5路解码
     * </pre>
     */
    emNv_5thDec_Api(5, 5),
    /**
     * <code>emNv_6thDec_Api = 6;</code>
     *
     * <pre>
     *&#47;&lt;第6路解码
     * </pre>
     */
    emNv_6thDec_Api(6, 6),
    /**
     * <code>emNv_7thDec_Api = 7;</code>
     *
     * <pre>
     *&#47;&lt;第7路解码
     * </pre>
     */
    emNv_7thDec_Api(7, 7),
    /**
     * <code>emNv_8thDec_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt;第8路解码
     * </pre>
     */
    emNv_8thDec_Api(8, 8),
    /**
     * <code>emNv_9thDec_Api = 9;</code>
     *
     * <pre>
     *&#47;&lt;第9路解码
     * </pre>
     */
    emNv_9thDec_Api(9, 9),
    /**
     * <code>emNv_10thDec_Api = 10;</code>
     *
     * <pre>
     *&#47;&lt;第10路解码
     * </pre>
     */
    emNv_10thDec_Api(10, 10),
    /**
     * <code>emNv_MtVidInnerCamera_Api = 11;</code>
     *
     * <pre>
     *&#47;&lt;内置摄像头
     * </pre>
     */
    emNv_MtVidInnerCamera_Api(11, 11),
    /**
     * <code>emNv_MtVidDVI1_Api = 12;</code>
     */
    emNv_MtVidDVI1_Api(12, 12),
    /**
     * <code>emNv_MtVidDVI2_Api = 13;</code>
     */
    emNv_MtVidDVI2_Api(13, 13),
    /**
     * <code>emNv_MtVidDVI3_Api = 14;</code>
     */
    emNv_MtVidDVI3_Api(14, 14),
    /**
     * <code>emNv_MtVidDVI4_Api = 15;</code>
     */
    emNv_MtVidDVI4_Api(15, 15),
    /**
     * <code>emNv_MtVidHDMI1_Api = 16;</code>
     */
    emNv_MtVidHDMI1_Api(16, 16),
    /**
     * <code>emNv_MtVidHDMI2_Api = 17;</code>
     */
    emNv_MtVidHDMI2_Api(17, 17),
    /**
     * <code>emNv_MtVidHDMI3_Api = 18;</code>
     */
    emNv_MtVidHDMI3_Api(18, 18),
    /**
     * <code>emNv_MtVidHDMI4_Api = 19;</code>
     */
    emNv_MtVidHDMI4_Api(19, 19),
    /**
     * <code>emNv_MtVidYPbPr1_Api = 20;</code>
     */
    emNv_MtVidYPbPr1_Api(20, 20),
    /**
     * <code>emNv_MtVidYPbPr2_Api = 21;</code>
     */
    emNv_MtVidYPbPr2_Api(21, 21),
    /**
     * <code>emNv_MtVidYPbPr3_Api = 22;</code>
     */
    emNv_MtVidYPbPr3_Api(22, 22),
    /**
     * <code>emNv_MtVidYPbPr4_Api = 23;</code>
     */
    emNv_MtVidYPbPr4_Api(23, 23),
    /**
     * <code>emNv_MtVidVGA1_Api = 24;</code>
     */
    emNv_MtVidVGA1_Api(24, 24),
    /**
     * <code>emNv_MtVidVGA2_Api = 25;</code>
     */
    emNv_MtVidVGA2_Api(25, 25),
    /**
     * <code>emNv_MtVidVGA3_Api = 26;</code>
     */
    emNv_MtVidVGA3_Api(26, 26),
    /**
     * <code>emNv_MtVidVGA4_Api = 27;</code>
     */
    emNv_MtVidVGA4_Api(27, 27),
    /**
     * <code>emNv_MtVidC1_Api = 28;</code>
     */
    emNv_MtVidC1_Api(28, 28),
    /**
     * <code>emNv_MtVidC2_Api = 29;</code>
     */
    emNv_MtVidC2_Api(29, 29),
    /**
     * <code>emNv_MtVidC3_Api = 30;</code>
     */
    emNv_MtVidC3_Api(30, 30),
    /**
     * <code>emNv_MtVidS1_Api = 31;</code>
     */
    emNv_MtVidS1_Api(31, 31),
    /**
     * <code>emNv_MtVidS2_Api = 32;</code>
     */
    emNv_MtVidS2_Api(32, 32),
    /**
     * <code>emNv_MtVidS3_Api = 33;</code>
     */
    emNv_MtVidS3_Api(33, 33),
    /**
     * <code>emNv_MtVidHDBaseT1_Api = 34;</code>
     */
    emNv_MtVidHDBaseT1_Api(34, 34),
    /**
     * <code>emNv_MtVidHDBaseT2_Api = 35;</code>
     */
    emNv_MtVidHDBaseT2_Api(35, 35),
    /**
     * <code>emNv_MtVidHDBaseT3_Api = 36;</code>
     */
    emNv_MtVidHDBaseT3_Api(36, 36),
    /**
     * <code>emNv_MtVidHDBaseT4_Api = 37;</code>
     */
    emNv_MtVidHDBaseT4_Api(37, 37),
    /**
     * <code>emNv_MtVidSDI1_Api = 38;</code>
     */
    emNv_MtVidSDI1_Api(38, 38),
    /**
     * <code>emNv_MtVidSDI2_Api = 39;</code>
     */
    emNv_MtVidSDI2_Api(39, 39),
    /**
     * <code>emNv_MtVidSDI3_Api = 40;</code>
     */
    emNv_MtVidSDI3_Api(40, 40),
    /**
     * <code>emNv_MtVidSDI4_Api = 41;</code>
     */
    emNv_MtVidSDI4_Api(41, 41),
    ;

    /**
     * <code>emNv_Invalid_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;无效视频源
     * </pre>
     */
    public static final int emNv_Invalid_Api_VALUE = 0;
    /**
     * <code>emNv_1stDec_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;第1路解码
     * </pre>
     */
    public static final int emNv_1stDec_Api_VALUE = 1;
    /**
     * <code>emNv_2ndDec_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;第2路解码
     * </pre>
     */
    public static final int emNv_2ndDec_Api_VALUE = 2;
    /**
     * <code>emNv_3rdDec_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt;第3路解码
     * </pre>
     */
    public static final int emNv_3rdDec_Api_VALUE = 3;
    /**
     * <code>emNv_4thDec_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt;第4路解码
     * </pre>
     */
    public static final int emNv_4thDec_Api_VALUE = 4;
    /**
     * <code>emNv_5thDec_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt;第5路解码
     * </pre>
     */
    public static final int emNv_5thDec_Api_VALUE = 5;
    /**
     * <code>emNv_6thDec_Api = 6;</code>
     *
     * <pre>
     *&#47;&lt;第6路解码
     * </pre>
     */
    public static final int emNv_6thDec_Api_VALUE = 6;
    /**
     * <code>emNv_7thDec_Api = 7;</code>
     *
     * <pre>
     *&#47;&lt;第7路解码
     * </pre>
     */
    public static final int emNv_7thDec_Api_VALUE = 7;
    /**
     * <code>emNv_8thDec_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt;第8路解码
     * </pre>
     */
    public static final int emNv_8thDec_Api_VALUE = 8;
    /**
     * <code>emNv_9thDec_Api = 9;</code>
     *
     * <pre>
     *&#47;&lt;第9路解码
     * </pre>
     */
    public static final int emNv_9thDec_Api_VALUE = 9;
    /**
     * <code>emNv_10thDec_Api = 10;</code>
     *
     * <pre>
     *&#47;&lt;第10路解码
     * </pre>
     */
    public static final int emNv_10thDec_Api_VALUE = 10;
    /**
     * <code>emNv_MtVidInnerCamera_Api = 11;</code>
     *
     * <pre>
     *&#47;&lt;内置摄像头
     * </pre>
     */
    public static final int emNv_MtVidInnerCamera_Api_VALUE = 11;
    /**
     * <code>emNv_MtVidDVI1_Api = 12;</code>
     */
    public static final int emNv_MtVidDVI1_Api_VALUE = 12;
    /**
     * <code>emNv_MtVidDVI2_Api = 13;</code>
     */
    public static final int emNv_MtVidDVI2_Api_VALUE = 13;
    /**
     * <code>emNv_MtVidDVI3_Api = 14;</code>
     */
    public static final int emNv_MtVidDVI3_Api_VALUE = 14;
    /**
     * <code>emNv_MtVidDVI4_Api = 15;</code>
     */
    public static final int emNv_MtVidDVI4_Api_VALUE = 15;
    /**
     * <code>emNv_MtVidHDMI1_Api = 16;</code>
     */
    public static final int emNv_MtVidHDMI1_Api_VALUE = 16;
    /**
     * <code>emNv_MtVidHDMI2_Api = 17;</code>
     */
    public static final int emNv_MtVidHDMI2_Api_VALUE = 17;
    /**
     * <code>emNv_MtVidHDMI3_Api = 18;</code>
     */
    public static final int emNv_MtVidHDMI3_Api_VALUE = 18;
    /**
     * <code>emNv_MtVidHDMI4_Api = 19;</code>
     */
    public static final int emNv_MtVidHDMI4_Api_VALUE = 19;
    /**
     * <code>emNv_MtVidYPbPr1_Api = 20;</code>
     */
    public static final int emNv_MtVidYPbPr1_Api_VALUE = 20;
    /**
     * <code>emNv_MtVidYPbPr2_Api = 21;</code>
     */
    public static final int emNv_MtVidYPbPr2_Api_VALUE = 21;
    /**
     * <code>emNv_MtVidYPbPr3_Api = 22;</code>
     */
    public static final int emNv_MtVidYPbPr3_Api_VALUE = 22;
    /**
     * <code>emNv_MtVidYPbPr4_Api = 23;</code>
     */
    public static final int emNv_MtVidYPbPr4_Api_VALUE = 23;
    /**
     * <code>emNv_MtVidVGA1_Api = 24;</code>
     */
    public static final int emNv_MtVidVGA1_Api_VALUE = 24;
    /**
     * <code>emNv_MtVidVGA2_Api = 25;</code>
     */
    public static final int emNv_MtVidVGA2_Api_VALUE = 25;
    /**
     * <code>emNv_MtVidVGA3_Api = 26;</code>
     */
    public static final int emNv_MtVidVGA3_Api_VALUE = 26;
    /**
     * <code>emNv_MtVidVGA4_Api = 27;</code>
     */
    public static final int emNv_MtVidVGA4_Api_VALUE = 27;
    /**
     * <code>emNv_MtVidC1_Api = 28;</code>
     */
    public static final int emNv_MtVidC1_Api_VALUE = 28;
    /**
     * <code>emNv_MtVidC2_Api = 29;</code>
     */
    public static final int emNv_MtVidC2_Api_VALUE = 29;
    /**
     * <code>emNv_MtVidC3_Api = 30;</code>
     */
    public static final int emNv_MtVidC3_Api_VALUE = 30;
    /**
     * <code>emNv_MtVidS1_Api = 31;</code>
     */
    public static final int emNv_MtVidS1_Api_VALUE = 31;
    /**
     * <code>emNv_MtVidS2_Api = 32;</code>
     */
    public static final int emNv_MtVidS2_Api_VALUE = 32;
    /**
     * <code>emNv_MtVidS3_Api = 33;</code>
     */
    public static final int emNv_MtVidS3_Api_VALUE = 33;
    /**
     * <code>emNv_MtVidHDBaseT1_Api = 34;</code>
     */
    public static final int emNv_MtVidHDBaseT1_Api_VALUE = 34;
    /**
     * <code>emNv_MtVidHDBaseT2_Api = 35;</code>
     */
    public static final int emNv_MtVidHDBaseT2_Api_VALUE = 35;
    /**
     * <code>emNv_MtVidHDBaseT3_Api = 36;</code>
     */
    public static final int emNv_MtVidHDBaseT3_Api_VALUE = 36;
    /**
     * <code>emNv_MtVidHDBaseT4_Api = 37;</code>
     */
    public static final int emNv_MtVidHDBaseT4_Api_VALUE = 37;
    /**
     * <code>emNv_MtVidSDI1_Api = 38;</code>
     */
    public static final int emNv_MtVidSDI1_Api_VALUE = 38;
    /**
     * <code>emNv_MtVidSDI2_Api = 39;</code>
     */
    public static final int emNv_MtVidSDI2_Api_VALUE = 39;
    /**
     * <code>emNv_MtVidSDI3_Api = 40;</code>
     */
    public static final int emNv_MtVidSDI3_Api_VALUE = 40;
    /**
     * <code>emNv_MtVidSDI4_Api = 41;</code>
     */
    public static final int emNv_MtVidSDI4_Api_VALUE = 41;


    public final int getNumber() { return value; }

    public static EmNvVideoSourceType_Api valueOf(int value) {
      switch (value) {
        case 0: return emNv_Invalid_Api;
        case 1: return emNv_1stDec_Api;
        case 2: return emNv_2ndDec_Api;
        case 3: return emNv_3rdDec_Api;
        case 4: return emNv_4thDec_Api;
        case 5: return emNv_5thDec_Api;
        case 6: return emNv_6thDec_Api;
        case 7: return emNv_7thDec_Api;
        case 8: return emNv_8thDec_Api;
        case 9: return emNv_9thDec_Api;
        case 10: return emNv_10thDec_Api;
        case 11: return emNv_MtVidInnerCamera_Api;
        case 12: return emNv_MtVidDVI1_Api;
        case 13: return emNv_MtVidDVI2_Api;
        case 14: return emNv_MtVidDVI3_Api;
        case 15: return emNv_MtVidDVI4_Api;
        case 16: return emNv_MtVidHDMI1_Api;
        case 17: return emNv_MtVidHDMI2_Api;
        case 18: return emNv_MtVidHDMI3_Api;
        case 19: return emNv_MtVidHDMI4_Api;
        case 20: return emNv_MtVidYPbPr1_Api;
        case 21: return emNv_MtVidYPbPr2_Api;
        case 22: return emNv_MtVidYPbPr3_Api;
        case 23: return emNv_MtVidYPbPr4_Api;
        case 24: return emNv_MtVidVGA1_Api;
        case 25: return emNv_MtVidVGA2_Api;
        case 26: return emNv_MtVidVGA3_Api;
        case 27: return emNv_MtVidVGA4_Api;
        case 28: return emNv_MtVidC1_Api;
        case 29: return emNv_MtVidC2_Api;
        case 30: return emNv_MtVidC3_Api;
        case 31: return emNv_MtVidS1_Api;
        case 32: return emNv_MtVidS2_Api;
        case 33: return emNv_MtVidS3_Api;
        case 34: return emNv_MtVidHDBaseT1_Api;
        case 35: return emNv_MtVidHDBaseT2_Api;
        case 36: return emNv_MtVidHDBaseT3_Api;
        case 37: return emNv_MtVidHDBaseT4_Api;
        case 38: return emNv_MtVidSDI1_Api;
        case 39: return emNv_MtVidSDI2_Api;
        case 40: return emNv_MtVidSDI3_Api;
        case 41: return emNv_MtVidSDI4_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoSourceType_Api>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvVideoSourceType_Api>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvVideoSourceType_Api>() {
            public EmNvVideoSourceType_Api findValueByNumber(int number) {
              return EmNvVideoSourceType_Api.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(89);
    }

    private static final EmNvVideoSourceType_Api[] VALUES = values();

    public static EmNvVideoSourceType_Api valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvVideoSourceType_Api(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvVideoSourceType_Api)
  }

  /**
   * Protobuf enum {@code nv.EmNvDynamicSrcType}
   */
  public enum EmNvDynamicSrcType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvUnkownType = 0;</code>
     */
    emNvUnkownType(0, 0),
    /**
     * <code>emNvStaticSrc = 1;</code>
     */
    emNvStaticSrc(1, 1),
    /**
     * <code>emNvDynamicSrc = 2;</code>
     */
    emNvDynamicSrc(2, 2),
    /**
     * <code>emNvQKorDLNA = 3;</code>
     */
    emNvQKorDLNA(3, 3),
    ;

    /**
     * <code>emNvUnkownType = 0;</code>
     */
    public static final int emNvUnkownType_VALUE = 0;
    /**
     * <code>emNvStaticSrc = 1;</code>
     */
    public static final int emNvStaticSrc_VALUE = 1;
    /**
     * <code>emNvDynamicSrc = 2;</code>
     */
    public static final int emNvDynamicSrc_VALUE = 2;
    /**
     * <code>emNvQKorDLNA = 3;</code>
     */
    public static final int emNvQKorDLNA_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNvDynamicSrcType valueOf(int value) {
      switch (value) {
        case 0: return emNvUnkownType;
        case 1: return emNvStaticSrc;
        case 2: return emNvDynamicSrc;
        case 3: return emNvQKorDLNA;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvDynamicSrcType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvDynamicSrcType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvDynamicSrcType>() {
            public EmNvDynamicSrcType findValueByNumber(int number) {
              return EmNvDynamicSrcType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(90);
    }

    private static final EmNvDynamicSrcType[] VALUES = values();

    public static EmNvDynamicSrcType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvDynamicSrcType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvDynamicSrcType)
  }

  /**
   * Protobuf enum {@code nv.EmNvLeaveDrawReason}
   */
  public enum EmNvLeaveDrawReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNv_LeaveDrawReason_Invalid = 0;</code>
     */
    emNv_LeaveDrawReason_Invalid(0, 0),
    /**
     * <code>emNv_Draw_OPS_NoSignal = 1;</code>
     */
    emNv_Draw_OPS_NoSignal(1, 1),
    /**
     * <code>emNv_Draw_TV_HDMI_NoSignal = 2;</code>
     */
    emNv_Draw_TV_HDMI_NoSignal(2, 2),
    /**
     * <code>emNv_Draw_MT_NoSignal = 3;</code>
     */
    emNv_Draw_MT_NoSignal(3, 3),
    /**
     * <code>emNv_Draw_VGA_NoSignal = 4;</code>
     */
    emNv_Draw_VGA_NoSignal(4, 4),
    /**
     * <code>emNv_Draw_HDMI_NoSignal = 5;</code>
     */
    emNv_Draw_HDMI_NoSignal(5, 5),
    /**
     * <code>emNv_Draw_QuickShare1_NoSignal = 6;</code>
     */
    emNv_Draw_QuickShare1_NoSignal(6, 6),
    /**
     * <code>emNv_Draw_QuickShare2_NoSignal = 7;</code>
     */
    emNv_Draw_QuickShare2_NoSignal(7, 7),
    /**
     * <code>emNv_Draw_QuickShare3_NoSignal = 8;</code>
     */
    emNv_Draw_QuickShare3_NoSignal(8, 8),
    /**
     * <code>emNv_Draw_QuickShare4_NoSignal = 9;</code>
     */
    emNv_Draw_QuickShare4_NoSignal(9, 9),
    /**
     * <code>emNv_Draw_QuickShare5_NoSignal = 10;</code>
     */
    emNv_Draw_QuickShare5_NoSignal(10, 10),
    /**
     * <code>emNv_Draw_QuickShare6_NoSignal = 11;</code>
     */
    emNv_Draw_QuickShare6_NoSignal(11, 11),
    /**
     * <code>emNv_Draw_QuickShare7_NoSignal = 12;</code>
     */
    emNv_Draw_QuickShare7_NoSignal(12, 12),
    /**
     * <code>emNv_Draw_QuickShare8_NoSignal = 13;</code>
     */
    emNv_Draw_QuickShare8_NoSignal(13, 13),
    /**
     * <code>emNv_Draw_DLNA_NoSignal = 14;</code>
     */
    emNv_Draw_DLNA_NoSignal(14, 14),
    /**
     * <code>emNv_Draw_UDisk1_NoSignal = 15;</code>
     */
    emNv_Draw_UDisk1_NoSignal(15, 15),
    /**
     * <code>emNv_Draw_UDisk2_NoSignal = 16;</code>
     */
    emNv_Draw_UDisk2_NoSignal(16, 16),
    /**
     * <code>emNv_Draw_CallIdle = 17;</code>
     */
    emNv_Draw_CallIdle(17, 17),
    /**
     * <code>emNv_Draw_CallConnected = 18;</code>
     */
    emNv_Draw_CallConnected(18, 18),
    /**
     * <code>emNv_Draw_StartRcvDual = 19;</code>
     */
    emNv_Draw_StartRcvDual(19, 19),
    /**
     * <code>emNv_Draw_StopRcvDual = 20;</code>
     */
    emNv_Draw_StopRcvDual(20, 20),
    /**
     * <code>emNv_Draw_StartSendDual = 21;</code>
     */
    emNv_Draw_StartSendDual(21, 21),
    /**
     * <code>emNv_Draw_StopSendDual = 22;</code>
     */
    emNv_Draw_StopSendDual(22, 22),
    /**
     * <code>emNv_Draw_QuickShare1_Start = 23;</code>
     */
    emNv_Draw_QuickShare1_Start(23, 23),
    /**
     * <code>emNv_Draw_QuickShare2_Start = 24;</code>
     */
    emNv_Draw_QuickShare2_Start(24, 24),
    /**
     * <code>emNv_Draw_QuickShare3_Start = 25;</code>
     */
    emNv_Draw_QuickShare3_Start(25, 25),
    /**
     * <code>emNv_Draw_QuickShare4_Start = 26;</code>
     */
    emNv_Draw_QuickShare4_Start(26, 26),
    /**
     * <code>emNv_Draw_QuickShare5_Start = 27;</code>
     */
    emNv_Draw_QuickShare5_Start(27, 27),
    /**
     * <code>emNv_Draw_QuickShare6_Start = 28;</code>
     */
    emNv_Draw_QuickShare6_Start(28, 28),
    /**
     * <code>emNv_Draw_QuickShare7_Start = 29;</code>
     */
    emNv_Draw_QuickShare7_Start(29, 29),
    /**
     * <code>emNv_Draw_QuickShare8_Start = 30;</code>
     */
    emNv_Draw_QuickShare8_Start(30, 30),
    /**
     * <code>emNv_Draw_DLNA_Start = 31;</code>
     */
    emNv_Draw_DLNA_Start(31, 31),
    /**
     * <code>emNv_Draw_VGA_Start = 32;</code>
     */
    emNv_Draw_VGA_Start(32, 32),
    /**
     * <code>emNv_Draw_TV_HDMI_Start = 33;</code>
     */
    emNv_Draw_TV_HDMI_Start(33, 33),
    /**
     * <code>emNv_Draw_QuickShare1_Stop = 34;</code>
     */
    emNv_Draw_QuickShare1_Stop(34, 34),
    /**
     * <code>emNv_Draw_QuickShare2_Stop = 35;</code>
     */
    emNv_Draw_QuickShare2_Stop(35, 35),
    /**
     * <code>emNv_Draw_QuickShare3_Stop = 36;</code>
     */
    emNv_Draw_QuickShare3_Stop(36, 36),
    /**
     * <code>emNv_Draw_QuickShare4_Stop = 37;</code>
     */
    emNv_Draw_QuickShare4_Stop(37, 37),
    /**
     * <code>emNv_Draw_QuickShare5_Stop = 38;</code>
     */
    emNv_Draw_QuickShare5_Stop(38, 38),
    /**
     * <code>emNv_Draw_QuickShare6_Stop = 39;</code>
     */
    emNv_Draw_QuickShare6_Stop(39, 39),
    /**
     * <code>emNv_Draw_QuickShare7_Stop = 40;</code>
     */
    emNv_Draw_QuickShare7_Stop(40, 40),
    /**
     * <code>emNv_Draw_QuickShare8_Stop = 41;</code>
     */
    emNv_Draw_QuickShare8_Stop(41, 41),
    /**
     * <code>emNv_Draw_UDisk1_Start = 42;</code>
     */
    emNv_Draw_UDisk1_Start(42, 42),
    /**
     * <code>emNv_Draw_UDisk2_Start = 43;</code>
     */
    emNv_Draw_UDisk2_Start(43, 43),
    /**
     * <code>emNv_Draw_ops_Start = 44;</code>
     */
    emNv_Draw_ops_Start(44, 44),
    /**
     * <code>emNv_Draw_ops_Stop = 45;</code>
     */
    emNv_Draw_ops_Stop(45, 45),
    ;

    /**
     * <code>emNv_LeaveDrawReason_Invalid = 0;</code>
     */
    public static final int emNv_LeaveDrawReason_Invalid_VALUE = 0;
    /**
     * <code>emNv_Draw_OPS_NoSignal = 1;</code>
     */
    public static final int emNv_Draw_OPS_NoSignal_VALUE = 1;
    /**
     * <code>emNv_Draw_TV_HDMI_NoSignal = 2;</code>
     */
    public static final int emNv_Draw_TV_HDMI_NoSignal_VALUE = 2;
    /**
     * <code>emNv_Draw_MT_NoSignal = 3;</code>
     */
    public static final int emNv_Draw_MT_NoSignal_VALUE = 3;
    /**
     * <code>emNv_Draw_VGA_NoSignal = 4;</code>
     */
    public static final int emNv_Draw_VGA_NoSignal_VALUE = 4;
    /**
     * <code>emNv_Draw_HDMI_NoSignal = 5;</code>
     */
    public static final int emNv_Draw_HDMI_NoSignal_VALUE = 5;
    /**
     * <code>emNv_Draw_QuickShare1_NoSignal = 6;</code>
     */
    public static final int emNv_Draw_QuickShare1_NoSignal_VALUE = 6;
    /**
     * <code>emNv_Draw_QuickShare2_NoSignal = 7;</code>
     */
    public static final int emNv_Draw_QuickShare2_NoSignal_VALUE = 7;
    /**
     * <code>emNv_Draw_QuickShare3_NoSignal = 8;</code>
     */
    public static final int emNv_Draw_QuickShare3_NoSignal_VALUE = 8;
    /**
     * <code>emNv_Draw_QuickShare4_NoSignal = 9;</code>
     */
    public static final int emNv_Draw_QuickShare4_NoSignal_VALUE = 9;
    /**
     * <code>emNv_Draw_QuickShare5_NoSignal = 10;</code>
     */
    public static final int emNv_Draw_QuickShare5_NoSignal_VALUE = 10;
    /**
     * <code>emNv_Draw_QuickShare6_NoSignal = 11;</code>
     */
    public static final int emNv_Draw_QuickShare6_NoSignal_VALUE = 11;
    /**
     * <code>emNv_Draw_QuickShare7_NoSignal = 12;</code>
     */
    public static final int emNv_Draw_QuickShare7_NoSignal_VALUE = 12;
    /**
     * <code>emNv_Draw_QuickShare8_NoSignal = 13;</code>
     */
    public static final int emNv_Draw_QuickShare8_NoSignal_VALUE = 13;
    /**
     * <code>emNv_Draw_DLNA_NoSignal = 14;</code>
     */
    public static final int emNv_Draw_DLNA_NoSignal_VALUE = 14;
    /**
     * <code>emNv_Draw_UDisk1_NoSignal = 15;</code>
     */
    public static final int emNv_Draw_UDisk1_NoSignal_VALUE = 15;
    /**
     * <code>emNv_Draw_UDisk2_NoSignal = 16;</code>
     */
    public static final int emNv_Draw_UDisk2_NoSignal_VALUE = 16;
    /**
     * <code>emNv_Draw_CallIdle = 17;</code>
     */
    public static final int emNv_Draw_CallIdle_VALUE = 17;
    /**
     * <code>emNv_Draw_CallConnected = 18;</code>
     */
    public static final int emNv_Draw_CallConnected_VALUE = 18;
    /**
     * <code>emNv_Draw_StartRcvDual = 19;</code>
     */
    public static final int emNv_Draw_StartRcvDual_VALUE = 19;
    /**
     * <code>emNv_Draw_StopRcvDual = 20;</code>
     */
    public static final int emNv_Draw_StopRcvDual_VALUE = 20;
    /**
     * <code>emNv_Draw_StartSendDual = 21;</code>
     */
    public static final int emNv_Draw_StartSendDual_VALUE = 21;
    /**
     * <code>emNv_Draw_StopSendDual = 22;</code>
     */
    public static final int emNv_Draw_StopSendDual_VALUE = 22;
    /**
     * <code>emNv_Draw_QuickShare1_Start = 23;</code>
     */
    public static final int emNv_Draw_QuickShare1_Start_VALUE = 23;
    /**
     * <code>emNv_Draw_QuickShare2_Start = 24;</code>
     */
    public static final int emNv_Draw_QuickShare2_Start_VALUE = 24;
    /**
     * <code>emNv_Draw_QuickShare3_Start = 25;</code>
     */
    public static final int emNv_Draw_QuickShare3_Start_VALUE = 25;
    /**
     * <code>emNv_Draw_QuickShare4_Start = 26;</code>
     */
    public static final int emNv_Draw_QuickShare4_Start_VALUE = 26;
    /**
     * <code>emNv_Draw_QuickShare5_Start = 27;</code>
     */
    public static final int emNv_Draw_QuickShare5_Start_VALUE = 27;
    /**
     * <code>emNv_Draw_QuickShare6_Start = 28;</code>
     */
    public static final int emNv_Draw_QuickShare6_Start_VALUE = 28;
    /**
     * <code>emNv_Draw_QuickShare7_Start = 29;</code>
     */
    public static final int emNv_Draw_QuickShare7_Start_VALUE = 29;
    /**
     * <code>emNv_Draw_QuickShare8_Start = 30;</code>
     */
    public static final int emNv_Draw_QuickShare8_Start_VALUE = 30;
    /**
     * <code>emNv_Draw_DLNA_Start = 31;</code>
     */
    public static final int emNv_Draw_DLNA_Start_VALUE = 31;
    /**
     * <code>emNv_Draw_VGA_Start = 32;</code>
     */
    public static final int emNv_Draw_VGA_Start_VALUE = 32;
    /**
     * <code>emNv_Draw_TV_HDMI_Start = 33;</code>
     */
    public static final int emNv_Draw_TV_HDMI_Start_VALUE = 33;
    /**
     * <code>emNv_Draw_QuickShare1_Stop = 34;</code>
     */
    public static final int emNv_Draw_QuickShare1_Stop_VALUE = 34;
    /**
     * <code>emNv_Draw_QuickShare2_Stop = 35;</code>
     */
    public static final int emNv_Draw_QuickShare2_Stop_VALUE = 35;
    /**
     * <code>emNv_Draw_QuickShare3_Stop = 36;</code>
     */
    public static final int emNv_Draw_QuickShare3_Stop_VALUE = 36;
    /**
     * <code>emNv_Draw_QuickShare4_Stop = 37;</code>
     */
    public static final int emNv_Draw_QuickShare4_Stop_VALUE = 37;
    /**
     * <code>emNv_Draw_QuickShare5_Stop = 38;</code>
     */
    public static final int emNv_Draw_QuickShare5_Stop_VALUE = 38;
    /**
     * <code>emNv_Draw_QuickShare6_Stop = 39;</code>
     */
    public static final int emNv_Draw_QuickShare6_Stop_VALUE = 39;
    /**
     * <code>emNv_Draw_QuickShare7_Stop = 40;</code>
     */
    public static final int emNv_Draw_QuickShare7_Stop_VALUE = 40;
    /**
     * <code>emNv_Draw_QuickShare8_Stop = 41;</code>
     */
    public static final int emNv_Draw_QuickShare8_Stop_VALUE = 41;
    /**
     * <code>emNv_Draw_UDisk1_Start = 42;</code>
     */
    public static final int emNv_Draw_UDisk1_Start_VALUE = 42;
    /**
     * <code>emNv_Draw_UDisk2_Start = 43;</code>
     */
    public static final int emNv_Draw_UDisk2_Start_VALUE = 43;
    /**
     * <code>emNv_Draw_ops_Start = 44;</code>
     */
    public static final int emNv_Draw_ops_Start_VALUE = 44;
    /**
     * <code>emNv_Draw_ops_Stop = 45;</code>
     */
    public static final int emNv_Draw_ops_Stop_VALUE = 45;


    public final int getNumber() { return value; }

    public static EmNvLeaveDrawReason valueOf(int value) {
      switch (value) {
        case 0: return emNv_LeaveDrawReason_Invalid;
        case 1: return emNv_Draw_OPS_NoSignal;
        case 2: return emNv_Draw_TV_HDMI_NoSignal;
        case 3: return emNv_Draw_MT_NoSignal;
        case 4: return emNv_Draw_VGA_NoSignal;
        case 5: return emNv_Draw_HDMI_NoSignal;
        case 6: return emNv_Draw_QuickShare1_NoSignal;
        case 7: return emNv_Draw_QuickShare2_NoSignal;
        case 8: return emNv_Draw_QuickShare3_NoSignal;
        case 9: return emNv_Draw_QuickShare4_NoSignal;
        case 10: return emNv_Draw_QuickShare5_NoSignal;
        case 11: return emNv_Draw_QuickShare6_NoSignal;
        case 12: return emNv_Draw_QuickShare7_NoSignal;
        case 13: return emNv_Draw_QuickShare8_NoSignal;
        case 14: return emNv_Draw_DLNA_NoSignal;
        case 15: return emNv_Draw_UDisk1_NoSignal;
        case 16: return emNv_Draw_UDisk2_NoSignal;
        case 17: return emNv_Draw_CallIdle;
        case 18: return emNv_Draw_CallConnected;
        case 19: return emNv_Draw_StartRcvDual;
        case 20: return emNv_Draw_StopRcvDual;
        case 21: return emNv_Draw_StartSendDual;
        case 22: return emNv_Draw_StopSendDual;
        case 23: return emNv_Draw_QuickShare1_Start;
        case 24: return emNv_Draw_QuickShare2_Start;
        case 25: return emNv_Draw_QuickShare3_Start;
        case 26: return emNv_Draw_QuickShare4_Start;
        case 27: return emNv_Draw_QuickShare5_Start;
        case 28: return emNv_Draw_QuickShare6_Start;
        case 29: return emNv_Draw_QuickShare7_Start;
        case 30: return emNv_Draw_QuickShare8_Start;
        case 31: return emNv_Draw_DLNA_Start;
        case 32: return emNv_Draw_VGA_Start;
        case 33: return emNv_Draw_TV_HDMI_Start;
        case 34: return emNv_Draw_QuickShare1_Stop;
        case 35: return emNv_Draw_QuickShare2_Stop;
        case 36: return emNv_Draw_QuickShare3_Stop;
        case 37: return emNv_Draw_QuickShare4_Stop;
        case 38: return emNv_Draw_QuickShare5_Stop;
        case 39: return emNv_Draw_QuickShare6_Stop;
        case 40: return emNv_Draw_QuickShare7_Stop;
        case 41: return emNv_Draw_QuickShare8_Stop;
        case 42: return emNv_Draw_UDisk1_Start;
        case 43: return emNv_Draw_UDisk2_Start;
        case 44: return emNv_Draw_ops_Start;
        case 45: return emNv_Draw_ops_Stop;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvLeaveDrawReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvLeaveDrawReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvLeaveDrawReason>() {
            public EmNvLeaveDrawReason findValueByNumber(int number) {
              return EmNvLeaveDrawReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(91);
    }

    private static final EmNvLeaveDrawReason[] VALUES = values();

    public static EmNvLeaveDrawReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvLeaveDrawReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvLeaveDrawReason)
  }

  /**
   * Protobuf enum {@code nv.EmNvPPTPageTurning}
   */
  public enum EmNvPPTPageTurning
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNv_PageTurning_Invalid = 0;</code>
     */
    emNv_PageTurning_Invalid(0, 0),
    /**
     * <code>emNv_PageUp = 1;</code>
     */
    emNv_PageUp(1, 1),
    /**
     * <code>emNv_PageDown = 2;</code>
     */
    emNv_PageDown(2, 2),
    /**
     * <code>emNv_PPTStop = 3;</code>
     */
    emNv_PPTStop(3, 3),
    ;

    /**
     * <code>emNv_PageTurning_Invalid = 0;</code>
     */
    public static final int emNv_PageTurning_Invalid_VALUE = 0;
    /**
     * <code>emNv_PageUp = 1;</code>
     */
    public static final int emNv_PageUp_VALUE = 1;
    /**
     * <code>emNv_PageDown = 2;</code>
     */
    public static final int emNv_PageDown_VALUE = 2;
    /**
     * <code>emNv_PPTStop = 3;</code>
     */
    public static final int emNv_PPTStop_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNvPPTPageTurning valueOf(int value) {
      switch (value) {
        case 0: return emNv_PageTurning_Invalid;
        case 1: return emNv_PageUp;
        case 2: return emNv_PageDown;
        case 3: return emNv_PPTStop;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvPPTPageTurning>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvPPTPageTurning>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvPPTPageTurning>() {
            public EmNvPPTPageTurning findValueByNumber(int number) {
              return EmNvPPTPageTurning.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(92);
    }

    private static final EmNvPPTPageTurning[] VALUES = values();

    public static EmNvPPTPageTurning valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvPPTPageTurning(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvPPTPageTurning)
  }

  /**
   * Protobuf enum {@code nv.EmNvAutoShutdownFailReason}
   */
  public enum EmNvAutoShutdownFailReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNv_AutoShutdownFailReason_Invalid = 0;</code>
     */
    emNv_AutoShutdownFailReason_Invalid(0, 0),
    /**
     * <code>emNv_AutoShutdown_Touch = 1;</code>
     */
    emNv_AutoShutdown_Touch(1, 1),
    /**
     * <code>emNv_AutoShutdown_Conf = 2;</code>
     */
    emNv_AutoShutdown_Conf(2, 2),
    /**
     * <code>emNv_AutoShutdown_Upgrage = 3;</code>
     */
    emNv_AutoShutdown_Upgrage(3, 3),
    /**
     * <code>emNv_AutoShutdown_QkUpgrage = 4;</code>
     */
    emNv_AutoShutdown_QkUpgrage(4, 4),
    /**
     * <code>emNv_AutoShutdown_ViewQK = 5;</code>
     */
    emNv_AutoShutdown_ViewQK(5, 5),
    /**
     * <code>emNv_AutoShutdown_ViewDLNA = 6;</code>
     */
    emNv_AutoShutdown_ViewDLNA(6, 6),
    ;

    /**
     * <code>emNv_AutoShutdownFailReason_Invalid = 0;</code>
     */
    public static final int emNv_AutoShutdownFailReason_Invalid_VALUE = 0;
    /**
     * <code>emNv_AutoShutdown_Touch = 1;</code>
     */
    public static final int emNv_AutoShutdown_Touch_VALUE = 1;
    /**
     * <code>emNv_AutoShutdown_Conf = 2;</code>
     */
    public static final int emNv_AutoShutdown_Conf_VALUE = 2;
    /**
     * <code>emNv_AutoShutdown_Upgrage = 3;</code>
     */
    public static final int emNv_AutoShutdown_Upgrage_VALUE = 3;
    /**
     * <code>emNv_AutoShutdown_QkUpgrage = 4;</code>
     */
    public static final int emNv_AutoShutdown_QkUpgrage_VALUE = 4;
    /**
     * <code>emNv_AutoShutdown_ViewQK = 5;</code>
     */
    public static final int emNv_AutoShutdown_ViewQK_VALUE = 5;
    /**
     * <code>emNv_AutoShutdown_ViewDLNA = 6;</code>
     */
    public static final int emNv_AutoShutdown_ViewDLNA_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmNvAutoShutdownFailReason valueOf(int value) {
      switch (value) {
        case 0: return emNv_AutoShutdownFailReason_Invalid;
        case 1: return emNv_AutoShutdown_Touch;
        case 2: return emNv_AutoShutdown_Conf;
        case 3: return emNv_AutoShutdown_Upgrage;
        case 4: return emNv_AutoShutdown_QkUpgrage;
        case 5: return emNv_AutoShutdown_ViewQK;
        case 6: return emNv_AutoShutdown_ViewDLNA;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvAutoShutdownFailReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvAutoShutdownFailReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvAutoShutdownFailReason>() {
            public EmNvAutoShutdownFailReason findValueByNumber(int number) {
              return EmNvAutoShutdownFailReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(93);
    }

    private static final EmNvAutoShutdownFailReason[] VALUES = values();

    public static EmNvAutoShutdownFailReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvAutoShutdownFailReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvAutoShutdownFailReason)
  }

  /**
   * Protobuf enum {@code nv.EmNvMtModel}
   *
   * <pre>
   *终端型号
   * </pre>
   */
  public enum EmNvMtModel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emModelBegin = 0;</code>
     *
     * <pre>
     *&#47;&lt;起始值
     * </pre>
     */
    emModelBegin(0, 0),
    /**
     * <code>emSkyWindows = 1;</code>
     *
     * <pre>
     *&#47;&lt;桌面终端 自建
     * </pre>
     */
    emSkyWindows(1, 1),
    /**
     * <code>emSkyIPad = 2;</code>
     *
     * <pre>
     *&#47;&lt;移动终端ipad 自建
     * </pre>
     */
    emSkyIPad(2, 2),
    /**
     * <code>emSkyIPhone = 3;</code>
     *
     * <pre>
     *&#47;&lt;移动终端iphone 自建
     * </pre>
     */
    emSkyIPhone(3, 3),
    /**
     * <code>emSkyAndroidPad = 7;</code>
     *
     * <pre>
     *&#47;&lt;移动终端androidpad 自建
     * </pre>
     */
    emSkyAndroidPad(4, 7),
    /**
     * <code>emSkyAndroidPhone = 8;</code>
     *
     * <pre>
     *&#47;&lt;移动终端androidphone 自建
     * </pre>
     */
    emSkyAndroidPhone(5, 8),
    /**
     * <code>emX500_1080P60 = 9;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 自建
     * </pre>
     */
    emX500_1080P60(6, 9),
    /**
     * <code>emX500_1080P30 = 10;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 自建
     * </pre>
     */
    emX500_1080P30(7, 10),
    /**
     * <code>emX500_720P60 = 11;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 自建
     * </pre>
     */
    emX500_720P60(8, 11),
    /**
     * <code>emX500_mo_1080P = 12;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 租赁
     * </pre>
     */
    emX500_mo_1080P(9, 12),
    /**
     * <code>emX500_mo_720P = 13;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 租赁
     * </pre>
     */
    emX500_mo_720P(10, 13),
    /**
     * <code>emX500_oem_1080P = 14;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 自建
     * </pre>
     */
    emX500_oem_1080P(11, 14),
    /**
     * <code>emX500_oem_mo_1080P = 15;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 租赁
     * </pre>
     */
    emX500_oem_mo_1080P(12, 15),
    /**
     * <code>emTrueLink = 16;</code>
     *
     * <pre>
     *&#47;&lt;桌面终端 租赁
     * </pre>
     */
    emTrueLink(13, 16),
    /**
     * <code>emTrueTouchIpad = 17;</code>
     *
     * <pre>
     *&#47;&lt;移动终端ipad 租赁
     * </pre>
     */
    emTrueTouchIpad(14, 17),
    /**
     * <code>emTrueTouchIphone = 18;</code>
     *
     * <pre>
     *&#47;&lt;移动终端iphone 租赁
     * </pre>
     */
    emTrueTouchIphone(15, 18),
    /**
     * <code>emTrueTouchAndroidPhone = 19;</code>
     *
     * <pre>
     *&#47;&lt;移动终端androidphone 租赁
     * </pre>
     */
    emTrueTouchAndroidPhone(16, 19),
    /**
     * <code>emTrueTouchAndroidPad = 20;</code>
     *
     * <pre>
     *&#47;&lt;移动终端androidpad   租赁
     * </pre>
     */
    emTrueTouchAndroidPad(17, 20),
    /**
     * <code>emH950_1080P60 = 21;</code>
     *
     * <pre>
     *&#47;&lt;硬终端 自建
     * </pre>
     */
    emH950_1080P60(18, 21),
    /**
     * <code>emTrueLinkTV = 22;</code>
     *
     * <pre>
     *&#47;&lt;移动终端TV盒子 租赁
     * </pre>
     */
    emTrueLinkTV(19, 22),
    /**
     * <code>emX700_4k30 = 23;</code>
     *
     * <pre>
     *x700-4k30 自建
     * </pre>
     */
    emX700_4k30(20, 23),
    /**
     * <code>emX700_oem_4k30 = 24;</code>
     *
     * <pre>
     *x700-4k30 oem 自建
     * </pre>
     */
    emX700_oem_4k30(21, 24),
    /**
     * <code>emX500_4k30 = 25;</code>
     *
     * <pre>
     *x500-4k30 自建
     * </pre>
     */
    emX500_4k30(22, 25),
    /**
     * <code>emX500_oem_4k30 = 26;</code>
     *
     * <pre>
     *x500-4k30 oem 自建
     * </pre>
     */
    emX500_oem_4k30(23, 26),
    /**
     * <code>emX300_1080P60 = 27;</code>
     *
     * <pre>
     *x300-1080P60  自建
     * </pre>
     */
    emX300_1080P60(24, 27),
    /**
     * <code>emX300_1080P30 = 28;</code>
     *
     * <pre>
     *x300-1080P30  自建
     * </pre>
     */
    emX300_1080P30(25, 28),
    /**
     * <code>emX300_720P60 = 29;</code>
     *
     * <pre>
     *x300-720P60   自建
     * </pre>
     */
    emX300_720P60(26, 29),
    /**
     * <code>emX300_oem_1080P60 = 30;</code>
     *
     * <pre>
     *x300-1080P60 oem 自建
     * </pre>
     */
    emX300_oem_1080P60(27, 30),
    /**
     * <code>emX500_1080P_60 = 31;</code>
     *
     * <pre>
     *x500-1080P-1080P60  自建  SKY X500-1080P 终端 和从9-15的x500终端不一样，芯片不一样
     * </pre>
     */
    emX500_1080P_60(28, 31),
    /**
     * <code>emX500_1080P_30 = 32;</code>
     *
     * <pre>
     *x500-1080P-1080P30  自建
     * </pre>
     */
    emX500_1080P_30(29, 32),
    /**
     * <code>emX500_oem_1080P_60 = 33;</code>
     *
     * <pre>
     *x500-1080P-1080P60 oem 自建
     * </pre>
     */
    emX500_oem_1080P_60(30, 33),
    /**
     * <code>em300_1080P30 = 34;</code>
     *
     * <pre>
     *300-1080P30  自建
     * </pre>
     */
    em300_1080P30(31, 34),
    /**
     * <code>em300_720P60 = 35;</code>
     *
     * <pre>
     *300-720P60  自建
     * </pre>
     */
    em300_720P60(32, 35),
    /**
     * <code>em300_oem_1080P30 = 36;</code>
     *
     * <pre>
     *300-1080P30  oem 自建
     * </pre>
     */
    em300_oem_1080P30(33, 36),
    /**
     * <code>em300L_1080P30 = 37;</code>
     *
     * <pre>
     *300L-1080P30  自建
     * </pre>
     */
    em300L_1080P30(34, 37),
    /**
     * <code>em300L_720P60 = 38;</code>
     *
     * <pre>
     *300L-720P60  自建
     * </pre>
     */
    em300L_720P60(35, 38),
    /**
     * <code>em300L_oem_1080P30 = 39;</code>
     *
     * <pre>
     *300L-1080P30  oem 自建
     * </pre>
     */
    em300L_oem_1080P30(36, 39),
    /**
     * <code>em300_1080P60 = 40;</code>
     *
     * <pre>
     *300-1080P60  自建
     * </pre>
     */
    em300_1080P60(37, 40),
    /**
     * <code>em300_720P30 = 41;</code>
     *
     * <pre>
     *300-720P30   自建
     * </pre>
     */
    em300_720P30(38, 41),
    /**
     * <code>em300L_1080P60 = 42;</code>
     *
     * <pre>
     *300-1080P60  自建(目前还没用到)
     * </pre>
     */
    em300L_1080P60(39, 42),
    /**
     * <code>em300L_720P30 = 43;</code>
     *
     * <pre>
     *300-720P30   自建(目前还没用到)
     * </pre>
     */
    em300L_720P30(40, 43),
    /**
     * <code>emX300_720P30 = 44;</code>
     *
     * <pre>
     *x300-720P30   自建
     * </pre>
     */
    emX300_720P30(41, 44),
    /**
     * <code>emX500_720P_30 = 45;</code>
     *
     * <pre>
     *x500-720P-720P30  自建(目前还没用到)
     * </pre>
     */
    emX500_720P_30(42, 45),
    /**
     * <code>emX500_720P_60 = 46;</code>
     *
     * <pre>
     *x500-720P-720P60  自建(目前还没用到)
     * </pre>
     */
    emX500_720P_60(43, 46),
    /**
     * <code>em100_1080P30_12X = 47;</code>
     *
     * <pre>
     *100_1080P30_12X      自建
     * </pre>
     */
    em100_1080P30_12X(44, 47),
    /**
     * <code>em100_1080P30_3X = 48;</code>
     *
     * <pre>
     *100_1080P30_3X       自建
     * </pre>
     */
    em100_1080P30_3X(45, 48),
    /**
     * <code>em100L_720P = 49;</code>
     *
     * <pre>
     *100L_720P            自建
     * </pre>
     */
    em100L_720P(46, 49),
    /**
     * <code>em100_oem_1080P30_3X = 50;</code>
     *
     * <pre>
     *100_oem_1080P30_3X   自建
     * </pre>
     */
    em100_oem_1080P30_3X(47, 50),
    /**
     * <code>emSkyWindows_s = 51;</code>
     *
     * <pre>
     *&#47;&lt; 商密桌面终端 自建
     * </pre>
     */
    emSkyWindows_s(48, 51),
    /**
     * <code>emSkyIPad_s = 52;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端ipad 自建
     * </pre>
     */
    emSkyIPad_s(49, 52),
    /**
     * <code>emSkyIPhone_s = 53;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端iphone 自建
     * </pre>
     */
    emSkyIPhone_s(50, 53),
    /**
     * <code>emSkyAndroidPad_s = 54;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端androidpad 自建
     * </pre>
     */
    emSkyAndroidPad_s(51, 54),
    /**
     * <code>emSkyAndroidPhone_s = 55;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端androidphone 自建
     * </pre>
     */
    emSkyAndroidPhone_s(52, 55),
    /**
     * <code>emX300_1080P60_s = 56;</code>
     *
     * <pre>
     * 商密硬终端 sky_x300_1080P60_s 
     * </pre>
     */
    emX300_1080P60_s(53, 56),
    /**
     * <code>emX500_1080P60_s = 57;</code>
     *
     * <pre>
     * 商密硬终端 sky_x500_1080P60_s
     * </pre>
     */
    emX500_1080P60_s(54, 57),
    /**
     * <code>em300_1080P60_s = 58;</code>
     *
     * <pre>
     * 商密硬终端 sky_300_1080P60_s
     * </pre>
     */
    em300_1080P60_s(55, 58),
    /**
     * <code>emX700_s = 59;</code>
     *
     * <pre>
     * 商密硬终端 sky_x700_s
     * </pre>
     */
    emX700_s(56, 59),
    /**
     * <code>emX500_4K_s = 60;</code>
     *
     * <pre>
     * 商密硬终端 sky_x500_4k_s
     * </pre>
     */
    emX500_4K_s(57, 60),
    /**
     * <code>em100_1080P30_12X_s = 61;</code>
     *
     * <pre>
     * 商密硬终端 sky_100_1080P30_12x_s
     * </pre>
     */
    em100_1080P30_12X_s(58, 61),
    /**
     * <code>emX300_1080P60_cs = 62;</code>
     *
     * <pre>
     * 渠道版本 sky_x300_1080P60_cs 
     * </pre>
     */
    emX300_1080P60_cs(59, 62),
    /**
     * <code>emX500_1080P60_cs = 63;</code>
     *
     * <pre>
     * 渠道版本 sky_x500_1080P60_cs
     * </pre>
     */
    emX500_1080P60_cs(60, 63),
    /**
     * <code>em300_1080P60_cs = 64;</code>
     *
     * <pre>
     * 渠道版本 sky_300_1080P60_cs
     * </pre>
     */
    em300_1080P60_cs(61, 64),
    /**
     * <code>emX700_cs = 65;</code>
     *
     * <pre>
     * 渠道版本 sky_x700_cs
     * </pre>
     */
    emX700_cs(62, 65),
    /**
     * <code>emX500_4K_cs = 66;</code>
     *
     * <pre>
     * 渠道版本 sky_x500_4k_cs
     * </pre>
     */
    emX500_4K_cs(63, 66),
    /**
     * <code>em100_1080P30_12X_cs = 67;</code>
     *
     * <pre>
     * 渠道版本 sky_100_1080P30_12x_cs
     * </pre>
     */
    em100_1080P30_12X_cs(64, 67),
    ;

    /**
     * <code>emModelBegin = 0;</code>
     *
     * <pre>
     *&#47;&lt;起始值
     * </pre>
     */
    public static final int emModelBegin_VALUE = 0;
    /**
     * <code>emSkyWindows = 1;</code>
     *
     * <pre>
     *&#47;&lt;桌面终端 自建
     * </pre>
     */
    public static final int emSkyWindows_VALUE = 1;
    /**
     * <code>emSkyIPad = 2;</code>
     *
     * <pre>
     *&#47;&lt;移动终端ipad 自建
     * </pre>
     */
    public static final int emSkyIPad_VALUE = 2;
    /**
     * <code>emSkyIPhone = 3;</code>
     *
     * <pre>
     *&#47;&lt;移动终端iphone 自建
     * </pre>
     */
    public static final int emSkyIPhone_VALUE = 3;
    /**
     * <code>emSkyAndroidPad = 7;</code>
     *
     * <pre>
     *&#47;&lt;移动终端androidpad 自建
     * </pre>
     */
    public static final int emSkyAndroidPad_VALUE = 7;
    /**
     * <code>emSkyAndroidPhone = 8;</code>
     *
     * <pre>
     *&#47;&lt;移动终端androidphone 自建
     * </pre>
     */
    public static final int emSkyAndroidPhone_VALUE = 8;
    /**
     * <code>emX500_1080P60 = 9;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 自建
     * </pre>
     */
    public static final int emX500_1080P60_VALUE = 9;
    /**
     * <code>emX500_1080P30 = 10;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 自建
     * </pre>
     */
    public static final int emX500_1080P30_VALUE = 10;
    /**
     * <code>emX500_720P60 = 11;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 自建
     * </pre>
     */
    public static final int emX500_720P60_VALUE = 11;
    /**
     * <code>emX500_mo_1080P = 12;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 租赁
     * </pre>
     */
    public static final int emX500_mo_1080P_VALUE = 12;
    /**
     * <code>emX500_mo_720P = 13;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 租赁
     * </pre>
     */
    public static final int emX500_mo_720P_VALUE = 13;
    /**
     * <code>emX500_oem_1080P = 14;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 自建
     * </pre>
     */
    public static final int emX500_oem_1080P_VALUE = 14;
    /**
     * <code>emX500_oem_mo_1080P = 15;</code>
     *
     * <pre>
     *&#47;&lt;硬终端X500 租赁
     * </pre>
     */
    public static final int emX500_oem_mo_1080P_VALUE = 15;
    /**
     * <code>emTrueLink = 16;</code>
     *
     * <pre>
     *&#47;&lt;桌面终端 租赁
     * </pre>
     */
    public static final int emTrueLink_VALUE = 16;
    /**
     * <code>emTrueTouchIpad = 17;</code>
     *
     * <pre>
     *&#47;&lt;移动终端ipad 租赁
     * </pre>
     */
    public static final int emTrueTouchIpad_VALUE = 17;
    /**
     * <code>emTrueTouchIphone = 18;</code>
     *
     * <pre>
     *&#47;&lt;移动终端iphone 租赁
     * </pre>
     */
    public static final int emTrueTouchIphone_VALUE = 18;
    /**
     * <code>emTrueTouchAndroidPhone = 19;</code>
     *
     * <pre>
     *&#47;&lt;移动终端androidphone 租赁
     * </pre>
     */
    public static final int emTrueTouchAndroidPhone_VALUE = 19;
    /**
     * <code>emTrueTouchAndroidPad = 20;</code>
     *
     * <pre>
     *&#47;&lt;移动终端androidpad   租赁
     * </pre>
     */
    public static final int emTrueTouchAndroidPad_VALUE = 20;
    /**
     * <code>emH950_1080P60 = 21;</code>
     *
     * <pre>
     *&#47;&lt;硬终端 自建
     * </pre>
     */
    public static final int emH950_1080P60_VALUE = 21;
    /**
     * <code>emTrueLinkTV = 22;</code>
     *
     * <pre>
     *&#47;&lt;移动终端TV盒子 租赁
     * </pre>
     */
    public static final int emTrueLinkTV_VALUE = 22;
    /**
     * <code>emX700_4k30 = 23;</code>
     *
     * <pre>
     *x700-4k30 自建
     * </pre>
     */
    public static final int emX700_4k30_VALUE = 23;
    /**
     * <code>emX700_oem_4k30 = 24;</code>
     *
     * <pre>
     *x700-4k30 oem 自建
     * </pre>
     */
    public static final int emX700_oem_4k30_VALUE = 24;
    /**
     * <code>emX500_4k30 = 25;</code>
     *
     * <pre>
     *x500-4k30 自建
     * </pre>
     */
    public static final int emX500_4k30_VALUE = 25;
    /**
     * <code>emX500_oem_4k30 = 26;</code>
     *
     * <pre>
     *x500-4k30 oem 自建
     * </pre>
     */
    public static final int emX500_oem_4k30_VALUE = 26;
    /**
     * <code>emX300_1080P60 = 27;</code>
     *
     * <pre>
     *x300-1080P60  自建
     * </pre>
     */
    public static final int emX300_1080P60_VALUE = 27;
    /**
     * <code>emX300_1080P30 = 28;</code>
     *
     * <pre>
     *x300-1080P30  自建
     * </pre>
     */
    public static final int emX300_1080P30_VALUE = 28;
    /**
     * <code>emX300_720P60 = 29;</code>
     *
     * <pre>
     *x300-720P60   自建
     * </pre>
     */
    public static final int emX300_720P60_VALUE = 29;
    /**
     * <code>emX300_oem_1080P60 = 30;</code>
     *
     * <pre>
     *x300-1080P60 oem 自建
     * </pre>
     */
    public static final int emX300_oem_1080P60_VALUE = 30;
    /**
     * <code>emX500_1080P_60 = 31;</code>
     *
     * <pre>
     *x500-1080P-1080P60  自建  SKY X500-1080P 终端 和从9-15的x500终端不一样，芯片不一样
     * </pre>
     */
    public static final int emX500_1080P_60_VALUE = 31;
    /**
     * <code>emX500_1080P_30 = 32;</code>
     *
     * <pre>
     *x500-1080P-1080P30  自建
     * </pre>
     */
    public static final int emX500_1080P_30_VALUE = 32;
    /**
     * <code>emX500_oem_1080P_60 = 33;</code>
     *
     * <pre>
     *x500-1080P-1080P60 oem 自建
     * </pre>
     */
    public static final int emX500_oem_1080P_60_VALUE = 33;
    /**
     * <code>em300_1080P30 = 34;</code>
     *
     * <pre>
     *300-1080P30  自建
     * </pre>
     */
    public static final int em300_1080P30_VALUE = 34;
    /**
     * <code>em300_720P60 = 35;</code>
     *
     * <pre>
     *300-720P60  自建
     * </pre>
     */
    public static final int em300_720P60_VALUE = 35;
    /**
     * <code>em300_oem_1080P30 = 36;</code>
     *
     * <pre>
     *300-1080P30  oem 自建
     * </pre>
     */
    public static final int em300_oem_1080P30_VALUE = 36;
    /**
     * <code>em300L_1080P30 = 37;</code>
     *
     * <pre>
     *300L-1080P30  自建
     * </pre>
     */
    public static final int em300L_1080P30_VALUE = 37;
    /**
     * <code>em300L_720P60 = 38;</code>
     *
     * <pre>
     *300L-720P60  自建
     * </pre>
     */
    public static final int em300L_720P60_VALUE = 38;
    /**
     * <code>em300L_oem_1080P30 = 39;</code>
     *
     * <pre>
     *300L-1080P30  oem 自建
     * </pre>
     */
    public static final int em300L_oem_1080P30_VALUE = 39;
    /**
     * <code>em300_1080P60 = 40;</code>
     *
     * <pre>
     *300-1080P60  自建
     * </pre>
     */
    public static final int em300_1080P60_VALUE = 40;
    /**
     * <code>em300_720P30 = 41;</code>
     *
     * <pre>
     *300-720P30   自建
     * </pre>
     */
    public static final int em300_720P30_VALUE = 41;
    /**
     * <code>em300L_1080P60 = 42;</code>
     *
     * <pre>
     *300-1080P60  自建(目前还没用到)
     * </pre>
     */
    public static final int em300L_1080P60_VALUE = 42;
    /**
     * <code>em300L_720P30 = 43;</code>
     *
     * <pre>
     *300-720P30   自建(目前还没用到)
     * </pre>
     */
    public static final int em300L_720P30_VALUE = 43;
    /**
     * <code>emX300_720P30 = 44;</code>
     *
     * <pre>
     *x300-720P30   自建
     * </pre>
     */
    public static final int emX300_720P30_VALUE = 44;
    /**
     * <code>emX500_720P_30 = 45;</code>
     *
     * <pre>
     *x500-720P-720P30  自建(目前还没用到)
     * </pre>
     */
    public static final int emX500_720P_30_VALUE = 45;
    /**
     * <code>emX500_720P_60 = 46;</code>
     *
     * <pre>
     *x500-720P-720P60  自建(目前还没用到)
     * </pre>
     */
    public static final int emX500_720P_60_VALUE = 46;
    /**
     * <code>em100_1080P30_12X = 47;</code>
     *
     * <pre>
     *100_1080P30_12X      自建
     * </pre>
     */
    public static final int em100_1080P30_12X_VALUE = 47;
    /**
     * <code>em100_1080P30_3X = 48;</code>
     *
     * <pre>
     *100_1080P30_3X       自建
     * </pre>
     */
    public static final int em100_1080P30_3X_VALUE = 48;
    /**
     * <code>em100L_720P = 49;</code>
     *
     * <pre>
     *100L_720P            自建
     * </pre>
     */
    public static final int em100L_720P_VALUE = 49;
    /**
     * <code>em100_oem_1080P30_3X = 50;</code>
     *
     * <pre>
     *100_oem_1080P30_3X   自建
     * </pre>
     */
    public static final int em100_oem_1080P30_3X_VALUE = 50;
    /**
     * <code>emSkyWindows_s = 51;</code>
     *
     * <pre>
     *&#47;&lt; 商密桌面终端 自建
     * </pre>
     */
    public static final int emSkyWindows_s_VALUE = 51;
    /**
     * <code>emSkyIPad_s = 52;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端ipad 自建
     * </pre>
     */
    public static final int emSkyIPad_s_VALUE = 52;
    /**
     * <code>emSkyIPhone_s = 53;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端iphone 自建
     * </pre>
     */
    public static final int emSkyIPhone_s_VALUE = 53;
    /**
     * <code>emSkyAndroidPad_s = 54;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端androidpad 自建
     * </pre>
     */
    public static final int emSkyAndroidPad_s_VALUE = 54;
    /**
     * <code>emSkyAndroidPhone_s = 55;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端androidphone 自建
     * </pre>
     */
    public static final int emSkyAndroidPhone_s_VALUE = 55;
    /**
     * <code>emX300_1080P60_s = 56;</code>
     *
     * <pre>
     * 商密硬终端 sky_x300_1080P60_s 
     * </pre>
     */
    public static final int emX300_1080P60_s_VALUE = 56;
    /**
     * <code>emX500_1080P60_s = 57;</code>
     *
     * <pre>
     * 商密硬终端 sky_x500_1080P60_s
     * </pre>
     */
    public static final int emX500_1080P60_s_VALUE = 57;
    /**
     * <code>em300_1080P60_s = 58;</code>
     *
     * <pre>
     * 商密硬终端 sky_300_1080P60_s
     * </pre>
     */
    public static final int em300_1080P60_s_VALUE = 58;
    /**
     * <code>emX700_s = 59;</code>
     *
     * <pre>
     * 商密硬终端 sky_x700_s
     * </pre>
     */
    public static final int emX700_s_VALUE = 59;
    /**
     * <code>emX500_4K_s = 60;</code>
     *
     * <pre>
     * 商密硬终端 sky_x500_4k_s
     * </pre>
     */
    public static final int emX500_4K_s_VALUE = 60;
    /**
     * <code>em100_1080P30_12X_s = 61;</code>
     *
     * <pre>
     * 商密硬终端 sky_100_1080P30_12x_s
     * </pre>
     */
    public static final int em100_1080P30_12X_s_VALUE = 61;
    /**
     * <code>emX300_1080P60_cs = 62;</code>
     *
     * <pre>
     * 渠道版本 sky_x300_1080P60_cs 
     * </pre>
     */
    public static final int emX300_1080P60_cs_VALUE = 62;
    /**
     * <code>emX500_1080P60_cs = 63;</code>
     *
     * <pre>
     * 渠道版本 sky_x500_1080P60_cs
     * </pre>
     */
    public static final int emX500_1080P60_cs_VALUE = 63;
    /**
     * <code>em300_1080P60_cs = 64;</code>
     *
     * <pre>
     * 渠道版本 sky_300_1080P60_cs
     * </pre>
     */
    public static final int em300_1080P60_cs_VALUE = 64;
    /**
     * <code>emX700_cs = 65;</code>
     *
     * <pre>
     * 渠道版本 sky_x700_cs
     * </pre>
     */
    public static final int emX700_cs_VALUE = 65;
    /**
     * <code>emX500_4K_cs = 66;</code>
     *
     * <pre>
     * 渠道版本 sky_x500_4k_cs
     * </pre>
     */
    public static final int emX500_4K_cs_VALUE = 66;
    /**
     * <code>em100_1080P30_12X_cs = 67;</code>
     *
     * <pre>
     * 渠道版本 sky_100_1080P30_12x_cs
     * </pre>
     */
    public static final int em100_1080P30_12X_cs_VALUE = 67;


    public final int getNumber() { return value; }

    public static EmNvMtModel valueOf(int value) {
      switch (value) {
        case 0: return emModelBegin;
        case 1: return emSkyWindows;
        case 2: return emSkyIPad;
        case 3: return emSkyIPhone;
        case 7: return emSkyAndroidPad;
        case 8: return emSkyAndroidPhone;
        case 9: return emX500_1080P60;
        case 10: return emX500_1080P30;
        case 11: return emX500_720P60;
        case 12: return emX500_mo_1080P;
        case 13: return emX500_mo_720P;
        case 14: return emX500_oem_1080P;
        case 15: return emX500_oem_mo_1080P;
        case 16: return emTrueLink;
        case 17: return emTrueTouchIpad;
        case 18: return emTrueTouchIphone;
        case 19: return emTrueTouchAndroidPhone;
        case 20: return emTrueTouchAndroidPad;
        case 21: return emH950_1080P60;
        case 22: return emTrueLinkTV;
        case 23: return emX700_4k30;
        case 24: return emX700_oem_4k30;
        case 25: return emX500_4k30;
        case 26: return emX500_oem_4k30;
        case 27: return emX300_1080P60;
        case 28: return emX300_1080P30;
        case 29: return emX300_720P60;
        case 30: return emX300_oem_1080P60;
        case 31: return emX500_1080P_60;
        case 32: return emX500_1080P_30;
        case 33: return emX500_oem_1080P_60;
        case 34: return em300_1080P30;
        case 35: return em300_720P60;
        case 36: return em300_oem_1080P30;
        case 37: return em300L_1080P30;
        case 38: return em300L_720P60;
        case 39: return em300L_oem_1080P30;
        case 40: return em300_1080P60;
        case 41: return em300_720P30;
        case 42: return em300L_1080P60;
        case 43: return em300L_720P30;
        case 44: return emX300_720P30;
        case 45: return emX500_720P_30;
        case 46: return emX500_720P_60;
        case 47: return em100_1080P30_12X;
        case 48: return em100_1080P30_3X;
        case 49: return em100L_720P;
        case 50: return em100_oem_1080P30_3X;
        case 51: return emSkyWindows_s;
        case 52: return emSkyIPad_s;
        case 53: return emSkyIPhone_s;
        case 54: return emSkyAndroidPad_s;
        case 55: return emSkyAndroidPhone_s;
        case 56: return emX300_1080P60_s;
        case 57: return emX500_1080P60_s;
        case 58: return em300_1080P60_s;
        case 59: return emX700_s;
        case 60: return emX500_4K_s;
        case 61: return em100_1080P30_12X_s;
        case 62: return emX300_1080P60_cs;
        case 63: return emX500_1080P60_cs;
        case 64: return em300_1080P60_cs;
        case 65: return emX700_cs;
        case 66: return emX500_4K_cs;
        case 67: return em100_1080P30_12X_cs;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvMtModel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvMtModel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvMtModel>() {
            public EmNvMtModel findValueByNumber(int number) {
              return EmNvMtModel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(94);
    }

    private static final EmNvMtModel[] VALUES = values();

    public static EmNvMtModel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvMtModel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvMtModel)
  }

  /**
   * Protobuf enum {@code nv.EmMtLocalSoundType}
   *
   * <pre>
   ** 终端本地声音类型 
   * </pre>
   */
  public enum EmMtLocalSoundType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emLSRing = 0;</code>
     *
     * <pre>
     *&#47;&lt;铃声
     * </pre>
     */
    emLSRing(0, 0),
    /**
     * <code>emLSKeyTone = 1;</code>
     *
     * <pre>
     *&#47;&lt;按键音
     * </pre>
     */
    emLSKeyTone(1, 1),
    /**
     * <code>emLSSpecialEffects = 2;</code>
     *
     * <pre>
     *&#47;&lt;音效
     * </pre>
     */
    emLSSpecialEffects(2, 2),
    ;

    /**
     * <code>emLSRing = 0;</code>
     *
     * <pre>
     *&#47;&lt;铃声
     * </pre>
     */
    public static final int emLSRing_VALUE = 0;
    /**
     * <code>emLSKeyTone = 1;</code>
     *
     * <pre>
     *&#47;&lt;按键音
     * </pre>
     */
    public static final int emLSKeyTone_VALUE = 1;
    /**
     * <code>emLSSpecialEffects = 2;</code>
     *
     * <pre>
     *&#47;&lt;音效
     * </pre>
     */
    public static final int emLSSpecialEffects_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtLocalSoundType valueOf(int value) {
      switch (value) {
        case 0: return emLSRing;
        case 1: return emLSKeyTone;
        case 2: return emLSSpecialEffects;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtLocalSoundType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtLocalSoundType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtLocalSoundType>() {
            public EmMtLocalSoundType findValueByNumber(int number) {
              return EmMtLocalSoundType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(95);
    }

    private static final EmMtLocalSoundType[] VALUES = values();

    public static EmMtLocalSoundType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtLocalSoundType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtLocalSoundType)
  }

  /**
   * Protobuf enum {@code nv.EmMtLocalSoundIndex}
   *
   * <pre>
   ** 终端本地音效索引 
   * </pre>
   */
  public enum EmMtLocalSoundIndex
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSound1st = 0;</code>
     *
     * <pre>
     *&#47;&lt;索引1
     * </pre>
     */
    emSound1st(0, 0),
    /**
     * <code>emSound2nd = 1;</code>
     *
     * <pre>
     *&#47;&lt;索引2
     * </pre>
     */
    emSound2nd(1, 1),
    /**
     * <code>emSound3rd = 2;</code>
     *
     * <pre>
     *&#47;&lt;索引3
     * </pre>
     */
    emSound3rd(2, 2),
    /**
     * <code>emSound4th = 3;</code>
     *
     * <pre>
     *&#47;&lt;索引4
     * </pre>
     */
    emSound4th(3, 3),
    /**
     * <code>emSound5th = 4;</code>
     *
     * <pre>
     *&#47;&lt;索引5
     * </pre>
     */
    emSound5th(4, 4),
    /**
     * <code>emSound6th = 5;</code>
     *
     * <pre>
     *&#47;&lt;索引6
     * </pre>
     */
    emSound6th(5, 5),
    /**
     * <code>emSound7th = 6;</code>
     *
     * <pre>
     *&#47;&lt;索引7
     * </pre>
     */
    emSound7th(6, 6),
    /**
     * <code>emSound8th = 7;</code>
     *
     * <pre>
     *&#47;&lt;索引8
     * </pre>
     */
    emSound8th(7, 7),
    /**
     * <code>emSound9th = 8;</code>
     *
     * <pre>
     *&#47;&lt;索引9
     * </pre>
     */
    emSound9th(8, 8),
    ;

    /**
     * <code>emSound1st = 0;</code>
     *
     * <pre>
     *&#47;&lt;索引1
     * </pre>
     */
    public static final int emSound1st_VALUE = 0;
    /**
     * <code>emSound2nd = 1;</code>
     *
     * <pre>
     *&#47;&lt;索引2
     * </pre>
     */
    public static final int emSound2nd_VALUE = 1;
    /**
     * <code>emSound3rd = 2;</code>
     *
     * <pre>
     *&#47;&lt;索引3
     * </pre>
     */
    public static final int emSound3rd_VALUE = 2;
    /**
     * <code>emSound4th = 3;</code>
     *
     * <pre>
     *&#47;&lt;索引4
     * </pre>
     */
    public static final int emSound4th_VALUE = 3;
    /**
     * <code>emSound5th = 4;</code>
     *
     * <pre>
     *&#47;&lt;索引5
     * </pre>
     */
    public static final int emSound5th_VALUE = 4;
    /**
     * <code>emSound6th = 5;</code>
     *
     * <pre>
     *&#47;&lt;索引6
     * </pre>
     */
    public static final int emSound6th_VALUE = 5;
    /**
     * <code>emSound7th = 6;</code>
     *
     * <pre>
     *&#47;&lt;索引7
     * </pre>
     */
    public static final int emSound7th_VALUE = 6;
    /**
     * <code>emSound8th = 7;</code>
     *
     * <pre>
     *&#47;&lt;索引8
     * </pre>
     */
    public static final int emSound8th_VALUE = 7;
    /**
     * <code>emSound9th = 8;</code>
     *
     * <pre>
     *&#47;&lt;索引9
     * </pre>
     */
    public static final int emSound9th_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmMtLocalSoundIndex valueOf(int value) {
      switch (value) {
        case 0: return emSound1st;
        case 1: return emSound2nd;
        case 2: return emSound3rd;
        case 3: return emSound4th;
        case 4: return emSound5th;
        case 5: return emSound6th;
        case 6: return emSound7th;
        case 7: return emSound8th;
        case 8: return emSound9th;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtLocalSoundIndex>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtLocalSoundIndex>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtLocalSoundIndex>() {
            public EmMtLocalSoundIndex findValueByNumber(int number) {
              return EmMtLocalSoundIndex.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(96);
    }

    private static final EmMtLocalSoundIndex[] VALUES = values();

    public static EmMtLocalSoundIndex valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtLocalSoundIndex(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtLocalSoundIndex)
  }

  /**
   * Protobuf enum {@code nv.EmMtHDAudPortIn}
   *
   * <pre>
   ** 终端音频输入接口 
   * </pre>
   */
  public enum EmMtHDAudPortIn
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emHDAudInBegin = 0;</code>
     *
     * <pre>
     *&#47;&lt; X500                  X700-4K|X500-4K
     * </pre>
     */
    emHDAudInBegin(0, 0),
    /**
     * <code>emHDAudInDMic1 = 1;</code>
     *
     * <pre>
     *&#47;&lt; 数字MIC1              有线MIC 1
     * </pre>
     */
    emHDAudInDMic1(1, 1),
    /**
     * <code>emHDAudInDMic2 = 2;</code>
     *
     * <pre>
     *&#47;&lt; 有线MIC 2             有线MIC 2
     * </pre>
     */
    emHDAudInDMic2(2, 2),
    /**
     * <code>emHDAudInXLR = 3;</code>
     *
     * <pre>
     *&#47;&lt; 卡侬MIC 1             卡侬MIC 1
     * </pre>
     */
    emHDAudInXLR(3, 3),
    /**
     * <code>emHDAudInWMic1 = 4;</code>
     *
     * <pre>
     *&#47;&lt; 无线MIC 1             无线MIC 1
     * </pre>
     */
    emHDAudInWMic1(4, 4),
    /**
     * <code>emHDAudInWMic2 = 5;</code>
     *
     * <pre>
     *&#47;&lt; 无线MIC 2             无线MIC 2
     * </pre>
     */
    emHDAudInWMic2(5, 5),
    /**
     * <code>emHDAudInWMic3 = 6;</code>
     *
     * <pre>
     *&#47;&lt; 无线MIC 3             无线MIC 3
     * </pre>
     */
    emHDAudInWMic3(6, 6),
    /**
     * <code>emHDAudInRCA = 7;</code>
     *
     * <pre>
     *&#47;&lt; LINE 4                LINE 5
     * </pre>
     */
    emHDAudInRCA(7, 7),
    /**
     * <code>emHDAudInTRS3_5 = 8;</code>
     *
     * <pre>
     *&#47;&lt; AUX 3                 AUX 3
     * </pre>
     */
    emHDAudInTRS3_5(8, 8),
    /**
     * <code>emHDAudInHDMI1 = 9;</code>
     *
     * <pre>
     *&#47;&lt; HDMI_4                HDMI_6
     * </pre>
     */
    emHDAudInHDMI1(9, 9),
    /**
     * <code>emHDAudInHDMI2 = 10;</code>
     *
     * <pre>
     *&#47;&lt; ...                   HDMI_1
     * </pre>
     */
    emHDAudInHDMI2(10, 10),
    /**
     * <code>emHDAudInHDMI3 = 11;</code>
     *
     * <pre>
     *&#47;&lt; ...                   HDMI_2
     * </pre>
     */
    emHDAudInHDMI3(11, 11),
    /**
     * <code>emHDAudInDHDMI = 12;</code>
     *
     * <pre>
     *&#47;&lt; DVI/YPbPr/VGA/HDMI 3  DVI/HDMI/VGA/YPbPr 5
     * </pre>
     */
    emHDAudInDHDMI(12, 12),
    /**
     * <code>emHDAudInSDI1 = 13;</code>
     *
     * <pre>
     *&#47;&lt; SDI1                  SDI 3
     * </pre>
     */
    emHDAudInSDI1(13, 13),
    /**
     * <code>emHDAudInSDI2 = 14;</code>
     *
     * <pre>
     *&#47;&lt; SDI2                  SDI 4
     * </pre>
     */
    emHDAudInSDI2(14, 14),
    /**
     * <code>emHDAudInHDBaseT1 = 15;</code>
     *
     * <pre>
     *&#47;&lt; HDBaseT 1             HDBaseT 1
     * </pre>
     */
    emHDAudInHDBaseT1(15, 15),
    /**
     * <code>emHDAudInHDBaseT2 = 16;</code>
     *
     * <pre>
     *&#47;&lt; HDBaseT 2             HDBaseT 2
     * </pre>
     */
    emHDAudInHDBaseT2(16, 16),
    /**
     * <code>emHDAudInDsiMic1 = 17;</code>
     *
     * <pre>
     *&#47;&lt; //内置Mic1
     * </pre>
     */
    emHDAudInDsiMic1(17, 17),
    /**
     * <code>emHDAudInDsiMic2 = 18;</code>
     *
     * <pre>
     *&#47;&lt; //内置Mic2
     * </pre>
     */
    emHDAudInDsiMic2(18, 18),
    ;

    /**
     * <code>emHDAudInBegin = 0;</code>
     *
     * <pre>
     *&#47;&lt; X500                  X700-4K|X500-4K
     * </pre>
     */
    public static final int emHDAudInBegin_VALUE = 0;
    /**
     * <code>emHDAudInDMic1 = 1;</code>
     *
     * <pre>
     *&#47;&lt; 数字MIC1              有线MIC 1
     * </pre>
     */
    public static final int emHDAudInDMic1_VALUE = 1;
    /**
     * <code>emHDAudInDMic2 = 2;</code>
     *
     * <pre>
     *&#47;&lt; 有线MIC 2             有线MIC 2
     * </pre>
     */
    public static final int emHDAudInDMic2_VALUE = 2;
    /**
     * <code>emHDAudInXLR = 3;</code>
     *
     * <pre>
     *&#47;&lt; 卡侬MIC 1             卡侬MIC 1
     * </pre>
     */
    public static final int emHDAudInXLR_VALUE = 3;
    /**
     * <code>emHDAudInWMic1 = 4;</code>
     *
     * <pre>
     *&#47;&lt; 无线MIC 1             无线MIC 1
     * </pre>
     */
    public static final int emHDAudInWMic1_VALUE = 4;
    /**
     * <code>emHDAudInWMic2 = 5;</code>
     *
     * <pre>
     *&#47;&lt; 无线MIC 2             无线MIC 2
     * </pre>
     */
    public static final int emHDAudInWMic2_VALUE = 5;
    /**
     * <code>emHDAudInWMic3 = 6;</code>
     *
     * <pre>
     *&#47;&lt; 无线MIC 3             无线MIC 3
     * </pre>
     */
    public static final int emHDAudInWMic3_VALUE = 6;
    /**
     * <code>emHDAudInRCA = 7;</code>
     *
     * <pre>
     *&#47;&lt; LINE 4                LINE 5
     * </pre>
     */
    public static final int emHDAudInRCA_VALUE = 7;
    /**
     * <code>emHDAudInTRS3_5 = 8;</code>
     *
     * <pre>
     *&#47;&lt; AUX 3                 AUX 3
     * </pre>
     */
    public static final int emHDAudInTRS3_5_VALUE = 8;
    /**
     * <code>emHDAudInHDMI1 = 9;</code>
     *
     * <pre>
     *&#47;&lt; HDMI_4                HDMI_6
     * </pre>
     */
    public static final int emHDAudInHDMI1_VALUE = 9;
    /**
     * <code>emHDAudInHDMI2 = 10;</code>
     *
     * <pre>
     *&#47;&lt; ...                   HDMI_1
     * </pre>
     */
    public static final int emHDAudInHDMI2_VALUE = 10;
    /**
     * <code>emHDAudInHDMI3 = 11;</code>
     *
     * <pre>
     *&#47;&lt; ...                   HDMI_2
     * </pre>
     */
    public static final int emHDAudInHDMI3_VALUE = 11;
    /**
     * <code>emHDAudInDHDMI = 12;</code>
     *
     * <pre>
     *&#47;&lt; DVI/YPbPr/VGA/HDMI 3  DVI/HDMI/VGA/YPbPr 5
     * </pre>
     */
    public static final int emHDAudInDHDMI_VALUE = 12;
    /**
     * <code>emHDAudInSDI1 = 13;</code>
     *
     * <pre>
     *&#47;&lt; SDI1                  SDI 3
     * </pre>
     */
    public static final int emHDAudInSDI1_VALUE = 13;
    /**
     * <code>emHDAudInSDI2 = 14;</code>
     *
     * <pre>
     *&#47;&lt; SDI2                  SDI 4
     * </pre>
     */
    public static final int emHDAudInSDI2_VALUE = 14;
    /**
     * <code>emHDAudInHDBaseT1 = 15;</code>
     *
     * <pre>
     *&#47;&lt; HDBaseT 1             HDBaseT 1
     * </pre>
     */
    public static final int emHDAudInHDBaseT1_VALUE = 15;
    /**
     * <code>emHDAudInHDBaseT2 = 16;</code>
     *
     * <pre>
     *&#47;&lt; HDBaseT 2             HDBaseT 2
     * </pre>
     */
    public static final int emHDAudInHDBaseT2_VALUE = 16;
    /**
     * <code>emHDAudInDsiMic1 = 17;</code>
     *
     * <pre>
     *&#47;&lt; //内置Mic1
     * </pre>
     */
    public static final int emHDAudInDsiMic1_VALUE = 17;
    /**
     * <code>emHDAudInDsiMic2 = 18;</code>
     *
     * <pre>
     *&#47;&lt; //内置Mic2
     * </pre>
     */
    public static final int emHDAudInDsiMic2_VALUE = 18;


    public final int getNumber() { return value; }

    public static EmMtHDAudPortIn valueOf(int value) {
      switch (value) {
        case 0: return emHDAudInBegin;
        case 1: return emHDAudInDMic1;
        case 2: return emHDAudInDMic2;
        case 3: return emHDAudInXLR;
        case 4: return emHDAudInWMic1;
        case 5: return emHDAudInWMic2;
        case 6: return emHDAudInWMic3;
        case 7: return emHDAudInRCA;
        case 8: return emHDAudInTRS3_5;
        case 9: return emHDAudInHDMI1;
        case 10: return emHDAudInHDMI2;
        case 11: return emHDAudInHDMI3;
        case 12: return emHDAudInDHDMI;
        case 13: return emHDAudInSDI1;
        case 14: return emHDAudInSDI2;
        case 15: return emHDAudInHDBaseT1;
        case 16: return emHDAudInHDBaseT2;
        case 17: return emHDAudInDsiMic1;
        case 18: return emHDAudInDsiMic2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtHDAudPortIn>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtHDAudPortIn>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtHDAudPortIn>() {
            public EmMtHDAudPortIn findValueByNumber(int number) {
              return EmMtHDAudPortIn.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(97);
    }

    private static final EmMtHDAudPortIn[] VALUES = values();

    public static EmMtHDAudPortIn valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtHDAudPortIn(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtHDAudPortIn)
  }

  /**
   * Protobuf enum {@code nv.EmMtCodecComponent}
   *
   * <pre>
   *终端codec组件
   * </pre>
   */
  public enum EmMtCodecComponent
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVidMainEncoder = 0;</code>
     *
     * <pre>
     *&#47;&lt;主流视频编码器
     * </pre>
     */
    emVidMainEncoder(0, 0),
    /**
     * <code>emVidMainDecoder = 1;</code>
     *
     * <pre>
     *&#47;&lt;主流视频解码器
     * </pre>
     */
    emVidMainDecoder(1, 1),
    /**
     * <code>emAudMainEncoder = 2;</code>
     *
     * <pre>
     *&#47;&lt;主流音频编码器
     * </pre>
     */
    emAudMainEncoder(2, 2),
    /**
     * <code>emAudMainDecoder = 3;</code>
     *
     * <pre>
     *&#47;&lt;主流音频解码器
     * </pre>
     */
    emAudMainDecoder(3, 3),
    /**
     * <code>emAudMainMixer = 4;</code>
     *
     * <pre>
     *&#47;&lt;主流混音器
     * </pre>
     */
    emAudMainMixer(4, 4),
    /**
     * <code>emVidMainMixer = 5;</code>
     *
     * <pre>
     *&#47;&lt;主流画面合成器
     * </pre>
     */
    emVidMainMixer(5, 5),
    /**
     * <code>emVidAssEncoder = 6;</code>
     *
     * <pre>
     *&#47;&lt;辅流视频编码器
     * </pre>
     */
    emVidAssEncoder(6, 6),
    /**
     * <code>emVidAssDecoder = 7;</code>
     *
     * <pre>
     *&#47;&lt;辅流视频解码器
     * </pre>
     */
    emVidAssDecoder(7, 7),
    /**
     * <code>emAudAssEncoder = 8;</code>
     *
     * <pre>
     *&#47;&lt;辅流音频编码器
     * </pre>
     */
    emAudAssEncoder(8, 8),
    /**
     * <code>emAudAssDecoder = 9;</code>
     *
     * <pre>
     *&#47;&lt;辅流音频编码器
     * </pre>
     */
    emAudAssDecoder(9, 9),
    /**
     * <code>emAudAssMixer = 10;</code>
     *
     * <pre>
     *&#47;&lt;辅流混音器
     * </pre>
     */
    emAudAssMixer(10, 10),
    /**
     * <code>emVidAssMixer = 11;</code>
     *
     * <pre>
     *&#47;&lt;辅流画面合成器
     * </pre>
     */
    emVidAssMixer(11, 11),
    /**
     * <code>emCodecInvalid = 20;</code>
     *
     * <pre>
     *&#47;&lt;无效值
     * </pre>
     */
    emCodecInvalid(12, 20),
    ;

    /**
     * <code>emVidMainEncoder = 0;</code>
     *
     * <pre>
     *&#47;&lt;主流视频编码器
     * </pre>
     */
    public static final int emVidMainEncoder_VALUE = 0;
    /**
     * <code>emVidMainDecoder = 1;</code>
     *
     * <pre>
     *&#47;&lt;主流视频解码器
     * </pre>
     */
    public static final int emVidMainDecoder_VALUE = 1;
    /**
     * <code>emAudMainEncoder = 2;</code>
     *
     * <pre>
     *&#47;&lt;主流音频编码器
     * </pre>
     */
    public static final int emAudMainEncoder_VALUE = 2;
    /**
     * <code>emAudMainDecoder = 3;</code>
     *
     * <pre>
     *&#47;&lt;主流音频解码器
     * </pre>
     */
    public static final int emAudMainDecoder_VALUE = 3;
    /**
     * <code>emAudMainMixer = 4;</code>
     *
     * <pre>
     *&#47;&lt;主流混音器
     * </pre>
     */
    public static final int emAudMainMixer_VALUE = 4;
    /**
     * <code>emVidMainMixer = 5;</code>
     *
     * <pre>
     *&#47;&lt;主流画面合成器
     * </pre>
     */
    public static final int emVidMainMixer_VALUE = 5;
    /**
     * <code>emVidAssEncoder = 6;</code>
     *
     * <pre>
     *&#47;&lt;辅流视频编码器
     * </pre>
     */
    public static final int emVidAssEncoder_VALUE = 6;
    /**
     * <code>emVidAssDecoder = 7;</code>
     *
     * <pre>
     *&#47;&lt;辅流视频解码器
     * </pre>
     */
    public static final int emVidAssDecoder_VALUE = 7;
    /**
     * <code>emAudAssEncoder = 8;</code>
     *
     * <pre>
     *&#47;&lt;辅流音频编码器
     * </pre>
     */
    public static final int emAudAssEncoder_VALUE = 8;
    /**
     * <code>emAudAssDecoder = 9;</code>
     *
     * <pre>
     *&#47;&lt;辅流音频编码器
     * </pre>
     */
    public static final int emAudAssDecoder_VALUE = 9;
    /**
     * <code>emAudAssMixer = 10;</code>
     *
     * <pre>
     *&#47;&lt;辅流混音器
     * </pre>
     */
    public static final int emAudAssMixer_VALUE = 10;
    /**
     * <code>emVidAssMixer = 11;</code>
     *
     * <pre>
     *&#47;&lt;辅流画面合成器
     * </pre>
     */
    public static final int emVidAssMixer_VALUE = 11;
    /**
     * <code>emCodecInvalid = 20;</code>
     *
     * <pre>
     *&#47;&lt;无效值
     * </pre>
     */
    public static final int emCodecInvalid_VALUE = 20;


    public final int getNumber() { return value; }

    public static EmMtCodecComponent valueOf(int value) {
      switch (value) {
        case 0: return emVidMainEncoder;
        case 1: return emVidMainDecoder;
        case 2: return emAudMainEncoder;
        case 3: return emAudMainDecoder;
        case 4: return emAudMainMixer;
        case 5: return emVidMainMixer;
        case 6: return emVidAssEncoder;
        case 7: return emVidAssDecoder;
        case 8: return emAudAssEncoder;
        case 9: return emAudAssDecoder;
        case 10: return emAudAssMixer;
        case 11: return emVidAssMixer;
        case 20: return emCodecInvalid;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtCodecComponent>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtCodecComponent>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtCodecComponent>() {
            public EmMtCodecComponent findValueByNumber(int number) {
              return EmMtCodecComponent.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(98);
    }

    private static final EmMtCodecComponent[] VALUES = values();

    public static EmMtCodecComponent valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtCodecComponent(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtCodecComponent)
  }

  /**
   * Protobuf enum {@code nv.EmCodecComponentIndex}
   *
   * <pre>
   ** 终端编解码器具体哪一路
   * </pre>
   */
  public enum EmCodecComponentIndex
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>em1st_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;第1路
     * </pre>
     */
    em1st_Api(0, 0),
    /**
     * <code>em2nd_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;第2路
     * </pre>
     */
    em2nd_Api(1, 1),
    /**
     * <code>em3rd_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;第3路
     * </pre>
     */
    em3rd_Api(2, 2),
    /**
     * <code>em4th_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt;第4路
     * </pre>
     */
    em4th_Api(3, 3),
    /**
     * <code>em5th_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt;第5路
     * </pre>
     */
    em5th_Api(4, 4),
    /**
     * <code>em6th_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt;第6路
     * </pre>
     */
    em6th_Api(5, 5),
    /**
     * <code>em7th_Api = 6;</code>
     *
     * <pre>
     *&#47;&lt;第7路
     * </pre>
     */
    em7th_Api(6, 6),
    /**
     * <code>em8th_Api = 7;</code>
     *
     * <pre>
     *&#47;&lt;第8路
     * </pre>
     */
    em8th_Api(7, 7),
    /**
     * <code>em9th_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt;第9路
     * </pre>
     */
    em9th_Api(8, 8),
    ;

    /**
     * <code>em1st_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;第1路
     * </pre>
     */
    public static final int em1st_Api_VALUE = 0;
    /**
     * <code>em2nd_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;第2路
     * </pre>
     */
    public static final int em2nd_Api_VALUE = 1;
    /**
     * <code>em3rd_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;第3路
     * </pre>
     */
    public static final int em3rd_Api_VALUE = 2;
    /**
     * <code>em4th_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt;第4路
     * </pre>
     */
    public static final int em4th_Api_VALUE = 3;
    /**
     * <code>em5th_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt;第5路
     * </pre>
     */
    public static final int em5th_Api_VALUE = 4;
    /**
     * <code>em6th_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt;第6路
     * </pre>
     */
    public static final int em6th_Api_VALUE = 5;
    /**
     * <code>em7th_Api = 6;</code>
     *
     * <pre>
     *&#47;&lt;第7路
     * </pre>
     */
    public static final int em7th_Api_VALUE = 6;
    /**
     * <code>em8th_Api = 7;</code>
     *
     * <pre>
     *&#47;&lt;第8路
     * </pre>
     */
    public static final int em8th_Api_VALUE = 7;
    /**
     * <code>em9th_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt;第9路
     * </pre>
     */
    public static final int em9th_Api_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmCodecComponentIndex valueOf(int value) {
      switch (value) {
        case 0: return em1st_Api;
        case 1: return em2nd_Api;
        case 2: return em3rd_Api;
        case 3: return em4th_Api;
        case 4: return em5th_Api;
        case 5: return em6th_Api;
        case 6: return em7th_Api;
        case 7: return em8th_Api;
        case 8: return em9th_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCodecComponentIndex>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCodecComponentIndex>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCodecComponentIndex>() {
            public EmCodecComponentIndex findValueByNumber(int number) {
              return EmCodecComponentIndex.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(99);
    }

    private static final EmCodecComponentIndex[] VALUES = values();

    public static EmCodecComponentIndex valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCodecComponentIndex(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmCodecComponentIndex)
  }

  /**
   * Protobuf enum {@code nv.EmMtConfProtocol}
   */
  public enum EmMtConfProtocol
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emProtocolBegin = 0;</code>
     *
     * <pre>
     *&#47;&lt;起始值
     * </pre>
     */
    emProtocolBegin(0, 0),
    /**
     * <code>em323_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;H323
     * </pre>
     */
    em323_Api(1, 1),
    /**
     * <code>emsip_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;SIP
     * </pre>
     */
    emsip_Api(2, 2),
    /**
     * <code>emsat_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt;SAT
     * </pre>
     */
    emsat_Api(3, 3),
    /**
     * <code>emtip_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt;TIP
     * </pre>
     */
    emtip_Api(4, 4),
    ;

    /**
     * <code>emProtocolBegin = 0;</code>
     *
     * <pre>
     *&#47;&lt;起始值
     * </pre>
     */
    public static final int emProtocolBegin_VALUE = 0;
    /**
     * <code>em323_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;H323
     * </pre>
     */
    public static final int em323_Api_VALUE = 1;
    /**
     * <code>emsip_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;SIP
     * </pre>
     */
    public static final int emsip_Api_VALUE = 2;
    /**
     * <code>emsat_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt;SAT
     * </pre>
     */
    public static final int emsat_Api_VALUE = 3;
    /**
     * <code>emtip_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt;TIP
     * </pre>
     */
    public static final int emtip_Api_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmMtConfProtocol valueOf(int value) {
      switch (value) {
        case 0: return emProtocolBegin;
        case 1: return em323_Api;
        case 2: return emsip_Api;
        case 3: return emsat_Api;
        case 4: return emtip_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtConfProtocol>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtConfProtocol>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtConfProtocol>() {
            public EmMtConfProtocol findValueByNumber(int number) {
              return EmMtConfProtocol.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(100);
    }

    private static final EmMtConfProtocol[] VALUES = values();

    public static EmMtConfProtocol valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtConfProtocol(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtConfProtocol)
  }

  /**
   * Protobuf enum {@code nv.EmMtServerAddrType}
   */
  public enum EmMtServerAddrType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSrvAddrTypeDefault = 0;</code>
     *
     * <pre>
     *&#47;&lt;默认不可修改
     * </pre>
     */
    emSrvAddrTypeDefault(0, 0),
    /**
     * <code>emSrvAddrTypeCustom = 1;</code>
     *
     * <pre>
     *&#47;&lt;用户自定义可编辑
     * </pre>
     */
    emSrvAddrTypeCustom(1, 1),
    ;

    /**
     * <code>emSrvAddrTypeDefault = 0;</code>
     *
     * <pre>
     *&#47;&lt;默认不可修改
     * </pre>
     */
    public static final int emSrvAddrTypeDefault_VALUE = 0;
    /**
     * <code>emSrvAddrTypeCustom = 1;</code>
     *
     * <pre>
     *&#47;&lt;用户自定义可编辑
     * </pre>
     */
    public static final int emSrvAddrTypeCustom_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmMtServerAddrType valueOf(int value) {
      switch (value) {
        case 0: return emSrvAddrTypeDefault;
        case 1: return emSrvAddrTypeCustom;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtServerAddrType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtServerAddrType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtServerAddrType>() {
            public EmMtServerAddrType findValueByNumber(int number) {
              return EmMtServerAddrType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(101);
    }

    private static final EmMtServerAddrType[] VALUES = values();

    public static EmMtServerAddrType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtServerAddrType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtServerAddrType)
  }

  /**
   * Protobuf enum {@code nv.EmMtAudioDelayCheckState}
   */
  public enum EmMtAudioDelayCheckState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAudioDelayBegin = 0;</code>
     *
     * <pre>
     *初始状态
     * </pre>
     */
    emAudioDelayBegin(0, 0),
    /**
     * <code>emAudioDelayChecking = 1;</code>
     *
     * <pre>
     *正在检测
     * </pre>
     */
    emAudioDelayChecking(1, 1),
    /**
     * <code>emAudioDelayChecked = 2;</code>
     *
     * <pre>
     *检测完成
     * </pre>
     */
    emAudioDelayChecked(2, 2),
    /**
     * <code>emAudioDelayTimeout = 3;</code>
     *
     * <pre>
     *检测超时
     * </pre>
     */
    emAudioDelayTimeout(3, 3),
    /**
     * <code>emAudioDelayFailed = 4;</code>
     *
     * <pre>
     *检测失败
     * </pre>
     */
    emAudioDelayFailed(4, 4),
    /**
     * <code>emAudioDelayReserve1 = 5;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    emAudioDelayReserve1(5, 5),
    /**
     * <code>emAudioDelayReserve2 = 6;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    emAudioDelayReserve2(6, 6),
    ;

    /**
     * <code>emAudioDelayBegin = 0;</code>
     *
     * <pre>
     *初始状态
     * </pre>
     */
    public static final int emAudioDelayBegin_VALUE = 0;
    /**
     * <code>emAudioDelayChecking = 1;</code>
     *
     * <pre>
     *正在检测
     * </pre>
     */
    public static final int emAudioDelayChecking_VALUE = 1;
    /**
     * <code>emAudioDelayChecked = 2;</code>
     *
     * <pre>
     *检测完成
     * </pre>
     */
    public static final int emAudioDelayChecked_VALUE = 2;
    /**
     * <code>emAudioDelayTimeout = 3;</code>
     *
     * <pre>
     *检测超时
     * </pre>
     */
    public static final int emAudioDelayTimeout_VALUE = 3;
    /**
     * <code>emAudioDelayFailed = 4;</code>
     *
     * <pre>
     *检测失败
     * </pre>
     */
    public static final int emAudioDelayFailed_VALUE = 4;
    /**
     * <code>emAudioDelayReserve1 = 5;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    public static final int emAudioDelayReserve1_VALUE = 5;
    /**
     * <code>emAudioDelayReserve2 = 6;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    public static final int emAudioDelayReserve2_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmMtAudioDelayCheckState valueOf(int value) {
      switch (value) {
        case 0: return emAudioDelayBegin;
        case 1: return emAudioDelayChecking;
        case 2: return emAudioDelayChecked;
        case 3: return emAudioDelayTimeout;
        case 4: return emAudioDelayFailed;
        case 5: return emAudioDelayReserve1;
        case 6: return emAudioDelayReserve2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtAudioDelayCheckState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtAudioDelayCheckState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtAudioDelayCheckState>() {
            public EmMtAudioDelayCheckState findValueByNumber(int number) {
              return EmMtAudioDelayCheckState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(102);
    }

    private static final EmMtAudioDelayCheckState[] VALUES = values();

    public static EmMtAudioDelayCheckState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtAudioDelayCheckState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtAudioDelayCheckState)
  }

  /**
   * Protobuf enum {@code nv.EmMtServerType}
   */
  public enum EmMtServerType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAPS_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt; 接入
     * </pre>
     */
    emAPS_Api(0, 0),
    /**
     * <code>emXNU_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt; XMPP
     * </pre>
     */
    emXNU_Api(1, 1),
    /**
     * <code>emSUS_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt; 升级
     * </pre>
     */
    emSUS_Api(2, 2),
    /**
     * <code>emNMS_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt; 网管
     * </pre>
     */
    emNMS_Api(3, 3),
    /**
     * <code>emNTS_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt; 测速
     * </pre>
     */
    emNTS_Api(4, 4),
    /**
     * <code>emSIP_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt; SIP呼叫
     * </pre>
     */
    emSIP_Api(5, 5),
    /**
     * <code>emNonH323_Api = 6;</code>
     *
     * <pre>
     *&#47;&lt;非标H323
     * </pre>
     */
    emNonH323_Api(6, 6),
    /**
     * <code>emStdH323_Api = 7;</code>
     *
     * <pre>
     *&lt;标准H323
     * </pre>
     */
    emStdH323_Api(7, 7),
    /**
     * <code>emNTP_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt; 时间同步
     * </pre>
     */
    emNTP_Api(8, 8),
    /**
     * <code>emVOD_Api = 9;</code>
     *
     * <pre>
     *&#47;&lt; VOD
     * </pre>
     */
    emVOD_Api(9, 9),
    /**
     * <code>emMoMeeting_Api = 10;</code>
     *
     * <pre>
     *&#47;&lt; 会管
     * </pre>
     */
    emMoMeeting_Api(10, 10),
    /**
     * <code>emMoPlatform_Api = 11;</code>
     *
     * <pre>
     *&#47;&lt; 平台
     * </pre>
     */
    emMoPlatform_Api(11, 11),
    /**
     * <code>emVRS_Api = 12;</code>
     *
     * <pre>
     *&#47;&lt; VRS
     * </pre>
     */
    emVRS_Api(12, 12),
    /**
     * <code>emDCS_Api = 13;</code>
     *
     * <pre>
     *&#47;&lt; DCS
     * </pre>
     */
    emDCS_Api(13, 13),
    /**
     * <code>emServerTypeEnd_Api = 14;</code>
     *
     * <pre>
     *&#47;&lt; 枚举结束值
     * </pre>
     */
    emServerTypeEnd_Api(14, 14),
    ;

    /**
     * <code>emAPS_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt; 接入
     * </pre>
     */
    public static final int emAPS_Api_VALUE = 0;
    /**
     * <code>emXNU_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt; XMPP
     * </pre>
     */
    public static final int emXNU_Api_VALUE = 1;
    /**
     * <code>emSUS_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt; 升级
     * </pre>
     */
    public static final int emSUS_Api_VALUE = 2;
    /**
     * <code>emNMS_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt; 网管
     * </pre>
     */
    public static final int emNMS_Api_VALUE = 3;
    /**
     * <code>emNTS_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt; 测速
     * </pre>
     */
    public static final int emNTS_Api_VALUE = 4;
    /**
     * <code>emSIP_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt; SIP呼叫
     * </pre>
     */
    public static final int emSIP_Api_VALUE = 5;
    /**
     * <code>emNonH323_Api = 6;</code>
     *
     * <pre>
     *&#47;&lt;非标H323
     * </pre>
     */
    public static final int emNonH323_Api_VALUE = 6;
    /**
     * <code>emStdH323_Api = 7;</code>
     *
     * <pre>
     *&lt;标准H323
     * </pre>
     */
    public static final int emStdH323_Api_VALUE = 7;
    /**
     * <code>emNTP_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt; 时间同步
     * </pre>
     */
    public static final int emNTP_Api_VALUE = 8;
    /**
     * <code>emVOD_Api = 9;</code>
     *
     * <pre>
     *&#47;&lt; VOD
     * </pre>
     */
    public static final int emVOD_Api_VALUE = 9;
    /**
     * <code>emMoMeeting_Api = 10;</code>
     *
     * <pre>
     *&#47;&lt; 会管
     * </pre>
     */
    public static final int emMoMeeting_Api_VALUE = 10;
    /**
     * <code>emMoPlatform_Api = 11;</code>
     *
     * <pre>
     *&#47;&lt; 平台
     * </pre>
     */
    public static final int emMoPlatform_Api_VALUE = 11;
    /**
     * <code>emVRS_Api = 12;</code>
     *
     * <pre>
     *&#47;&lt; VRS
     * </pre>
     */
    public static final int emVRS_Api_VALUE = 12;
    /**
     * <code>emDCS_Api = 13;</code>
     *
     * <pre>
     *&#47;&lt; DCS
     * </pre>
     */
    public static final int emDCS_Api_VALUE = 13;
    /**
     * <code>emServerTypeEnd_Api = 14;</code>
     *
     * <pre>
     *&#47;&lt; 枚举结束值
     * </pre>
     */
    public static final int emServerTypeEnd_Api_VALUE = 14;


    public final int getNumber() { return value; }

    public static EmMtServerType valueOf(int value) {
      switch (value) {
        case 0: return emAPS_Api;
        case 1: return emXNU_Api;
        case 2: return emSUS_Api;
        case 3: return emNMS_Api;
        case 4: return emNTS_Api;
        case 5: return emSIP_Api;
        case 6: return emNonH323_Api;
        case 7: return emStdH323_Api;
        case 8: return emNTP_Api;
        case 9: return emVOD_Api;
        case 10: return emMoMeeting_Api;
        case 11: return emMoPlatform_Api;
        case 12: return emVRS_Api;
        case 13: return emDCS_Api;
        case 14: return emServerTypeEnd_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtServerType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtServerType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtServerType>() {
            public EmMtServerType findValueByNumber(int number) {
              return EmMtServerType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(103);
    }

    private static final EmMtServerType[] VALUES = values();

    public static EmMtServerType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtServerType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtServerType)
  }

  /**
   * Protobuf enum {@code nv.EmMtServerState}
   */
  public enum EmMtServerState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSrvIdle_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt; 空闲     
     * </pre>
     */
    emSrvIdle_Api(0, 0),
    /**
     * <code>emSrvDnsQuerying_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt; 正在解析IP
     * </pre>
     */
    emSrvDnsQuerying_Api(1, 1),
    /**
     * <code>emSrvLogging_In_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt; 正在登录
     * </pre>
     */
    emSrvLogging_In_Api(2, 2),
    /**
     * <code>emSrvLogin_Succ_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt; 登录成功
     * </pre>
     */
    emSrvLogin_Succ_Api(3, 3),
    /**
     * <code>emSrvLogging_Out_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt; 正在登出
     * </pre>
     */
    emSrvLogging_Out_Api(4, 4),
    /**
     * <code>emSrvDisconnected_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt; 断链（适用于保持心跳的服务器）
     * </pre>
     */
    emSrvDisconnected_Api(5, 5),
    /**
     * <code>emSrvLogin_Err_Api = 6;</code>
     */
    emSrvLogin_Err_Api(6, 6),
    ;

    /**
     * <code>emSrvIdle_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt; 空闲     
     * </pre>
     */
    public static final int emSrvIdle_Api_VALUE = 0;
    /**
     * <code>emSrvDnsQuerying_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt; 正在解析IP
     * </pre>
     */
    public static final int emSrvDnsQuerying_Api_VALUE = 1;
    /**
     * <code>emSrvLogging_In_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt; 正在登录
     * </pre>
     */
    public static final int emSrvLogging_In_Api_VALUE = 2;
    /**
     * <code>emSrvLogin_Succ_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt; 登录成功
     * </pre>
     */
    public static final int emSrvLogin_Succ_Api_VALUE = 3;
    /**
     * <code>emSrvLogging_Out_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt; 正在登出
     * </pre>
     */
    public static final int emSrvLogging_Out_Api_VALUE = 4;
    /**
     * <code>emSrvDisconnected_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt; 断链（适用于保持心跳的服务器）
     * </pre>
     */
    public static final int emSrvDisconnected_Api_VALUE = 5;
    /**
     * <code>emSrvLogin_Err_Api = 6;</code>
     */
    public static final int emSrvLogin_Err_Api_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmMtServerState valueOf(int value) {
      switch (value) {
        case 0: return emSrvIdle_Api;
        case 1: return emSrvDnsQuerying_Api;
        case 2: return emSrvLogging_In_Api;
        case 3: return emSrvLogin_Succ_Api;
        case 4: return emSrvLogging_Out_Api;
        case 5: return emSrvDisconnected_Api;
        case 6: return emSrvLogin_Err_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtServerState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtServerState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtServerState>() {
            public EmMtServerState findValueByNumber(int number) {
              return EmMtServerState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(104);
    }

    private static final EmMtServerState[] VALUES = values();

    public static EmMtServerState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtServerState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtServerState)
  }

  /**
   * Protobuf enum {@code nv.EmMtRegFailedReason}
   *
   * <pre>
   ** 注册失败原因 
   * </pre>
   */
  public enum EmMtRegFailedReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emGKFailedBegin_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;起始值
     * </pre>
     */
    emGKFailedBegin_Api(0, 0),
    /**
     * <code>emGKUnReachable_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;对端不可达
     * </pre>
     */
    emGKUnReachable_Api(1, 1),
    /**
     * <code>emInvalidAliase_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;无效的别名
     * </pre>
     */
    emInvalidAliase_Api(2, 2),
    /**
     * <code>emDupAlias_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt;别名重复
     * </pre>
     */
    emDupAlias_Api(3, 3),
    /**
     * <code>emInvalidCallAddress_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt;无效的呼叫地址
     * </pre>
     */
    emInvalidCallAddress_Api(4, 4),
    /**
     * <code>emResourceUnavailable_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt;资源不可用
     * </pre>
     */
    emResourceUnavailable_Api(5, 5),
    /**
     * <code>emRegNumberFull_Api = 7;</code>
     *
     * <pre>
     *emUnknown_Api = 6;               ///&lt;未知原因,不用
     * </pre>
     */
    emRegNumberFull_Api(6, 7),
    /**
     * <code>emGKSecurityDenial_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt;GK注册权限失败
     * </pre>
     */
    emGKSecurityDenial_Api(7, 8),
    /**
     * <code>emGKDismatch_Api = 9;</code>
     *
     * <pre>
     *&#47;&lt;GK不是运营版本,服务器不匹配
     * </pre>
     */
    emGKDismatch_Api(8, 9),
    /**
     * <code>emUnRegGKReq_Api = 10;</code>
     *
     * <pre>
     *&#47;&lt;GK被抢登后，要求注销GK
     * </pre>
     */
    emUnRegGKReq_Api(9, 10),
    /**
     * <code>emRRQCreateHRASFailed_Api = 11;</code>
     *
     * <pre>
     *&#47;&lt;rrq创建句柄失败
     * </pre>
     */
    emRRQCreateHRASFailed_Api(10, 11),
    /**
     * <code>emRRQSendFailed_Api = 12;</code>
     *
     * <pre>
     *&#47;&lt;rrq发送失败
     * </pre>
     */
    emRRQSendFailed_Api(11, 12),
    /**
     * <code>emSipFailedBegin_Api = 50;</code>
     *
     * <pre>
     *&#47;&lt;sip注册失败原因开始
     * </pre>
     */
    emSipFailedBegin_Api(12, 50),
    /**
     * <code>emSipLocalNormalUnreg_Api = 51;</code>
     *
     * <pre>
     *&#47;&lt;未注册
     * </pre>
     */
    emSipLocalNormalUnreg_Api(13, 51),
    /**
     * <code>emSipInvalidUserNameAndPassword_Api = 52;</code>
     *
     * <pre>
     *&#47;&lt;无效的用户名和密码
     * </pre>
     */
    emSipInvalidUserNameAndPassword_Api(14, 52),
    /**
     * <code>emSipRegistrarUnReachable_Api = 53;</code>
     *
     * <pre>
     *&#47;&lt;注册不可达
     * </pre>
     */
    emSipRegistrarUnReachable_Api(15, 53),
    /**
     * <code>emSipInvalidAlias_Api = 54;</code>
     *
     * <pre>
     *&#47;&lt;无效的别名
     * </pre>
     */
    emSipInvalidAlias_Api(16, 54),
    /**
     * <code>emSipUnknownReason_Api = 55;</code>
     *
     * <pre>
     *&#47;&lt;未知原因
     * </pre>
     */
    emSipUnknownReason_Api(17, 55),
    /**
     * <code>emSipRegisterFailed_Api = 56;</code>
     *
     * <pre>
     *&#47;&lt;注册失败
     * </pre>
     */
    emSipRegisterFailed_Api(18, 56),
    /**
     * <code>emSipRegisterNameDup_Api = 57;</code>
     *
     * <pre>
     *&#47;&lt;注册名称重复
     * </pre>
     */
    emSipRegisterNameDup_Api(19, 57),
    /**
     * <code>emSecCrtNotFind_Api = 58;</code>
     *
     * <pre>
     *&#47;//sec 注册失败reason
     * </pre>
     */
    emSecCrtNotFind_Api(20, 58),
    /**
     * <code>emSecCrtVerifyFail_Api = 59;</code>
     *
     * <pre>
     *&#47;证书验证失败
     * </pre>
     */
    emSecCrtVerifyFail_Api(21, 59),
    /**
     * <code>emSecCrtExpired_Api = 60;</code>
     *
     * <pre>
     *&#47;证书过期 有效期错误
     * </pre>
     */
    emSecCrtExpired_Api(22, 60),
    /**
     * <code>emSecCrtFormatError_Api = 61;</code>
     *
     * <pre>
     *&#47;证书格式错误
     * </pre>
     */
    emSecCrtFormatError_Api(23, 61),
    /**
     * <code>emSecLoadCertFailed_Api = 62;</code>
     */
    emSecLoadCertFailed_Api(24, 62),
    /**
     * <code>emUnRegSuc_Api = 90;</code>
     *
     * <pre>
     *&#47;&lt; 取消注册成功
     * </pre>
     */
    emUnRegSuc_Api(25, 90),
    /**
     * <code>emRegSuccess_Api = 100;</code>
     *
     * <pre>
     *&#47;&lt;注册成功， sip和323都是这个
     * </pre>
     */
    emRegSuccess_Api(26, 100),
    ;

    /**
     * <code>emGKFailedBegin_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;起始值
     * </pre>
     */
    public static final int emGKFailedBegin_Api_VALUE = 0;
    /**
     * <code>emGKUnReachable_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;对端不可达
     * </pre>
     */
    public static final int emGKUnReachable_Api_VALUE = 1;
    /**
     * <code>emInvalidAliase_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;无效的别名
     * </pre>
     */
    public static final int emInvalidAliase_Api_VALUE = 2;
    /**
     * <code>emDupAlias_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt;别名重复
     * </pre>
     */
    public static final int emDupAlias_Api_VALUE = 3;
    /**
     * <code>emInvalidCallAddress_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt;无效的呼叫地址
     * </pre>
     */
    public static final int emInvalidCallAddress_Api_VALUE = 4;
    /**
     * <code>emResourceUnavailable_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt;资源不可用
     * </pre>
     */
    public static final int emResourceUnavailable_Api_VALUE = 5;
    /**
     * <code>emRegNumberFull_Api = 7;</code>
     *
     * <pre>
     *emUnknown_Api = 6;               ///&lt;未知原因,不用
     * </pre>
     */
    public static final int emRegNumberFull_Api_VALUE = 7;
    /**
     * <code>emGKSecurityDenial_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt;GK注册权限失败
     * </pre>
     */
    public static final int emGKSecurityDenial_Api_VALUE = 8;
    /**
     * <code>emGKDismatch_Api = 9;</code>
     *
     * <pre>
     *&#47;&lt;GK不是运营版本,服务器不匹配
     * </pre>
     */
    public static final int emGKDismatch_Api_VALUE = 9;
    /**
     * <code>emUnRegGKReq_Api = 10;</code>
     *
     * <pre>
     *&#47;&lt;GK被抢登后，要求注销GK
     * </pre>
     */
    public static final int emUnRegGKReq_Api_VALUE = 10;
    /**
     * <code>emRRQCreateHRASFailed_Api = 11;</code>
     *
     * <pre>
     *&#47;&lt;rrq创建句柄失败
     * </pre>
     */
    public static final int emRRQCreateHRASFailed_Api_VALUE = 11;
    /**
     * <code>emRRQSendFailed_Api = 12;</code>
     *
     * <pre>
     *&#47;&lt;rrq发送失败
     * </pre>
     */
    public static final int emRRQSendFailed_Api_VALUE = 12;
    /**
     * <code>emSipFailedBegin_Api = 50;</code>
     *
     * <pre>
     *&#47;&lt;sip注册失败原因开始
     * </pre>
     */
    public static final int emSipFailedBegin_Api_VALUE = 50;
    /**
     * <code>emSipLocalNormalUnreg_Api = 51;</code>
     *
     * <pre>
     *&#47;&lt;未注册
     * </pre>
     */
    public static final int emSipLocalNormalUnreg_Api_VALUE = 51;
    /**
     * <code>emSipInvalidUserNameAndPassword_Api = 52;</code>
     *
     * <pre>
     *&#47;&lt;无效的用户名和密码
     * </pre>
     */
    public static final int emSipInvalidUserNameAndPassword_Api_VALUE = 52;
    /**
     * <code>emSipRegistrarUnReachable_Api = 53;</code>
     *
     * <pre>
     *&#47;&lt;注册不可达
     * </pre>
     */
    public static final int emSipRegistrarUnReachable_Api_VALUE = 53;
    /**
     * <code>emSipInvalidAlias_Api = 54;</code>
     *
     * <pre>
     *&#47;&lt;无效的别名
     * </pre>
     */
    public static final int emSipInvalidAlias_Api_VALUE = 54;
    /**
     * <code>emSipUnknownReason_Api = 55;</code>
     *
     * <pre>
     *&#47;&lt;未知原因
     * </pre>
     */
    public static final int emSipUnknownReason_Api_VALUE = 55;
    /**
     * <code>emSipRegisterFailed_Api = 56;</code>
     *
     * <pre>
     *&#47;&lt;注册失败
     * </pre>
     */
    public static final int emSipRegisterFailed_Api_VALUE = 56;
    /**
     * <code>emSipRegisterNameDup_Api = 57;</code>
     *
     * <pre>
     *&#47;&lt;注册名称重复
     * </pre>
     */
    public static final int emSipRegisterNameDup_Api_VALUE = 57;
    /**
     * <code>emSecCrtNotFind_Api = 58;</code>
     *
     * <pre>
     *&#47;//sec 注册失败reason
     * </pre>
     */
    public static final int emSecCrtNotFind_Api_VALUE = 58;
    /**
     * <code>emSecCrtVerifyFail_Api = 59;</code>
     *
     * <pre>
     *&#47;证书验证失败
     * </pre>
     */
    public static final int emSecCrtVerifyFail_Api_VALUE = 59;
    /**
     * <code>emSecCrtExpired_Api = 60;</code>
     *
     * <pre>
     *&#47;证书过期 有效期错误
     * </pre>
     */
    public static final int emSecCrtExpired_Api_VALUE = 60;
    /**
     * <code>emSecCrtFormatError_Api = 61;</code>
     *
     * <pre>
     *&#47;证书格式错误
     * </pre>
     */
    public static final int emSecCrtFormatError_Api_VALUE = 61;
    /**
     * <code>emSecLoadCertFailed_Api = 62;</code>
     */
    public static final int emSecLoadCertFailed_Api_VALUE = 62;
    /**
     * <code>emUnRegSuc_Api = 90;</code>
     *
     * <pre>
     *&#47;&lt; 取消注册成功
     * </pre>
     */
    public static final int emUnRegSuc_Api_VALUE = 90;
    /**
     * <code>emRegSuccess_Api = 100;</code>
     *
     * <pre>
     *&#47;&lt;注册成功， sip和323都是这个
     * </pre>
     */
    public static final int emRegSuccess_Api_VALUE = 100;


    public final int getNumber() { return value; }

    public static EmMtRegFailedReason valueOf(int value) {
      switch (value) {
        case 0: return emGKFailedBegin_Api;
        case 1: return emGKUnReachable_Api;
        case 2: return emInvalidAliase_Api;
        case 3: return emDupAlias_Api;
        case 4: return emInvalidCallAddress_Api;
        case 5: return emResourceUnavailable_Api;
        case 7: return emRegNumberFull_Api;
        case 8: return emGKSecurityDenial_Api;
        case 9: return emGKDismatch_Api;
        case 10: return emUnRegGKReq_Api;
        case 11: return emRRQCreateHRASFailed_Api;
        case 12: return emRRQSendFailed_Api;
        case 50: return emSipFailedBegin_Api;
        case 51: return emSipLocalNormalUnreg_Api;
        case 52: return emSipInvalidUserNameAndPassword_Api;
        case 53: return emSipRegistrarUnReachable_Api;
        case 54: return emSipInvalidAlias_Api;
        case 55: return emSipUnknownReason_Api;
        case 56: return emSipRegisterFailed_Api;
        case 57: return emSipRegisterNameDup_Api;
        case 58: return emSecCrtNotFind_Api;
        case 59: return emSecCrtVerifyFail_Api;
        case 60: return emSecCrtExpired_Api;
        case 61: return emSecCrtFormatError_Api;
        case 62: return emSecLoadCertFailed_Api;
        case 90: return emUnRegSuc_Api;
        case 100: return emRegSuccess_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtRegFailedReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtRegFailedReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtRegFailedReason>() {
            public EmMtRegFailedReason findValueByNumber(int number) {
              return EmMtRegFailedReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(105);
    }

    private static final EmMtRegFailedReason[] VALUES = values();

    public static EmMtRegFailedReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtRegFailedReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtRegFailedReason)
  }

  /**
   * Protobuf enum {@code nv.EmMtSdiInOut}
   *
   * <pre>
   ** SDI接口数量 
   * </pre>
   */
  public enum EmMtSdiInOut
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSdiNone_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;无sdi
     * </pre>
     */
    emSdiNone_Api(0, 0),
    /**
     * <code>emSdiTwoIn_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;两进口
     * </pre>
     */
    emSdiTwoIn_Api(1, 1),
    /**
     * <code>emSdiOneInOneOut_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;一进口一出口
     * </pre>
     */
    emSdiOneInOneOut_Api(2, 2),
    ;

    /**
     * <code>emSdiNone_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;无sdi
     * </pre>
     */
    public static final int emSdiNone_Api_VALUE = 0;
    /**
     * <code>emSdiTwoIn_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;两进口
     * </pre>
     */
    public static final int emSdiTwoIn_Api_VALUE = 1;
    /**
     * <code>emSdiOneInOneOut_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;一进口一出口
     * </pre>
     */
    public static final int emSdiOneInOneOut_Api_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtSdiInOut valueOf(int value) {
      switch (value) {
        case 0: return emSdiNone_Api;
        case 1: return emSdiTwoIn_Api;
        case 2: return emSdiOneInOneOut_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtSdiInOut>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtSdiInOut>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtSdiInOut>() {
            public EmMtSdiInOut findValueByNumber(int number) {
              return EmMtSdiInOut.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(106);
    }

    private static final EmMtSdiInOut[] VALUES = values();

    public static EmMtSdiInOut valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtSdiInOut(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtSdiInOut)
  }

  /**
   * Protobuf enum {@code nv.EmMtMicDevId}
   *
   * <pre>
   **  数字麦ID
   * </pre>
   */
  public enum EmMtMicDevId
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWiredMic0_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦0
     * </pre>
     */
    emWiredMic0_Api(0, 0),
    /**
     * <code>emWiredMic1_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦1
     * </pre>
     */
    emWiredMic1_Api(1, 1),
    /**
     * <code>emWirelessMic0_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt; 无线麦0
     * </pre>
     */
    emWirelessMic0_Api(2, 2),
    /**
     * <code>emWirelessMic1_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt; 无线麦1
     * </pre>
     */
    emWirelessMic1_Api(3, 3),
    /**
     * <code>emWirelessMic2_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt; 无线麦2
     * </pre>
     */
    emWirelessMic2_Api(4, 4),
    /**
     * <code>emWiredMic0Cascade1_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦0级联1
     * </pre>
     */
    emWiredMic0Cascade1_Api(5, 5),
    /**
     * <code>emWiredMic0Cascade2_Api = 6;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦0级联2
     * </pre>
     */
    emWiredMic0Cascade2_Api(6, 6),
    /**
     * <code>emWiredMic1Cascade1_Api = 7;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦1级联1
     * </pre>
     */
    emWiredMic1Cascade1_Api(7, 7),
    /**
     * <code>emWiredMic1Cascade2_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦1级联2
     * </pre>
     */
    emWiredMic1Cascade2_Api(8, 8),
    /**
     * <code>emMicDevIdEnd_Api = 9;</code>
     */
    emMicDevIdEnd_Api(9, 9),
    ;

    /**
     * <code>emWiredMic0_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦0
     * </pre>
     */
    public static final int emWiredMic0_Api_VALUE = 0;
    /**
     * <code>emWiredMic1_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦1
     * </pre>
     */
    public static final int emWiredMic1_Api_VALUE = 1;
    /**
     * <code>emWirelessMic0_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt; 无线麦0
     * </pre>
     */
    public static final int emWirelessMic0_Api_VALUE = 2;
    /**
     * <code>emWirelessMic1_Api = 3;</code>
     *
     * <pre>
     *&#47;&lt; 无线麦1
     * </pre>
     */
    public static final int emWirelessMic1_Api_VALUE = 3;
    /**
     * <code>emWirelessMic2_Api = 4;</code>
     *
     * <pre>
     *&#47;&lt; 无线麦2
     * </pre>
     */
    public static final int emWirelessMic2_Api_VALUE = 4;
    /**
     * <code>emWiredMic0Cascade1_Api = 5;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦0级联1
     * </pre>
     */
    public static final int emWiredMic0Cascade1_Api_VALUE = 5;
    /**
     * <code>emWiredMic0Cascade2_Api = 6;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦0级联2
     * </pre>
     */
    public static final int emWiredMic0Cascade2_Api_VALUE = 6;
    /**
     * <code>emWiredMic1Cascade1_Api = 7;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦1级联1
     * </pre>
     */
    public static final int emWiredMic1Cascade1_Api_VALUE = 7;
    /**
     * <code>emWiredMic1Cascade2_Api = 8;</code>
     *
     * <pre>
     *&#47;&lt; 有线麦1级联2
     * </pre>
     */
    public static final int emWiredMic1Cascade2_Api_VALUE = 8;
    /**
     * <code>emMicDevIdEnd_Api = 9;</code>
     */
    public static final int emMicDevIdEnd_Api_VALUE = 9;


    public final int getNumber() { return value; }

    public static EmMtMicDevId valueOf(int value) {
      switch (value) {
        case 0: return emWiredMic0_Api;
        case 1: return emWiredMic1_Api;
        case 2: return emWirelessMic0_Api;
        case 3: return emWirelessMic1_Api;
        case 4: return emWirelessMic2_Api;
        case 5: return emWiredMic0Cascade1_Api;
        case 6: return emWiredMic0Cascade2_Api;
        case 7: return emWiredMic1Cascade1_Api;
        case 8: return emWiredMic1Cascade2_Api;
        case 9: return emMicDevIdEnd_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtMicDevId>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtMicDevId>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtMicDevId>() {
            public EmMtMicDevId findValueByNumber(int number) {
              return EmMtMicDevId.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(107);
    }

    private static final EmMtMicDevId[] VALUES = values();

    public static EmMtMicDevId valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtMicDevId(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtMicDevId)
  }

  /**
   * Protobuf enum {@code nv.EmMtHDVideoType}
   *
   * <pre>
   ** 视频类型 
   * </pre>
   */
  public enum EmMtHDVideoType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emHD1stPriVideo_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;第一路主视频
     * </pre>
     */
    emHD1stPriVideo_Api(0, 0),
    /**
     * <code>emHD2ndPriVideo_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;第二路主视频
     * </pre>
     */
    emHD2ndPriVideo_Api(1, 1),
    /**
     * <code>emHD3rdPriVideo_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;第三路主视频
     * </pre>
     */
    emHD3rdPriVideo_Api(2, 2),
    /**
     * <code>emHDAssVideo_Api = 10;</code>
     *
     * <pre>
     *&#47;&lt;辅视频
     * </pre>
     */
    emHDAssVideo_Api(3, 10),
    ;

    /**
     * <code>emHD1stPriVideo_Api = 0;</code>
     *
     * <pre>
     *&#47;&lt;第一路主视频
     * </pre>
     */
    public static final int emHD1stPriVideo_Api_VALUE = 0;
    /**
     * <code>emHD2ndPriVideo_Api = 1;</code>
     *
     * <pre>
     *&#47;&lt;第二路主视频
     * </pre>
     */
    public static final int emHD2ndPriVideo_Api_VALUE = 1;
    /**
     * <code>emHD3rdPriVideo_Api = 2;</code>
     *
     * <pre>
     *&#47;&lt;第三路主视频
     * </pre>
     */
    public static final int emHD3rdPriVideo_Api_VALUE = 2;
    /**
     * <code>emHDAssVideo_Api = 10;</code>
     *
     * <pre>
     *&#47;&lt;辅视频
     * </pre>
     */
    public static final int emHDAssVideo_Api_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmMtHDVideoType valueOf(int value) {
      switch (value) {
        case 0: return emHD1stPriVideo_Api;
        case 1: return emHD2ndPriVideo_Api;
        case 2: return emHD3rdPriVideo_Api;
        case 10: return emHDAssVideo_Api;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtHDVideoType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtHDVideoType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtHDVideoType>() {
            public EmMtHDVideoType findValueByNumber(int number) {
              return EmMtHDVideoType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(108);
    }

    private static final EmMtHDVideoType[] VALUES = values();

    public static EmMtHDVideoType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtHDVideoType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmMtHDVideoType)
  }

  /**
   * Protobuf enum {@code nv.EmNvSwbState}
   */
  public enum EmNvSwbState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNvSwbChance = 0;</code>
     *
     * <pre>
     *&#47;取消
     * </pre>
     */
    emNvSwbChance(0, 0),
    /**
     * <code>emNvSwbSleep = 1;</code>
     *
     * <pre>
     *&#47;待机
     * </pre>
     */
    emNvSwbSleep(1, 1),
    /**
     * <code>emNvSwbTurnOff = 2;</code>
     *
     * <pre>
     *&#47;关机
     * </pre>
     */
    emNvSwbTurnOff(2, 2),
    ;

    /**
     * <code>emNvSwbChance = 0;</code>
     *
     * <pre>
     *&#47;取消
     * </pre>
     */
    public static final int emNvSwbChance_VALUE = 0;
    /**
     * <code>emNvSwbSleep = 1;</code>
     *
     * <pre>
     *&#47;待机
     * </pre>
     */
    public static final int emNvSwbSleep_VALUE = 1;
    /**
     * <code>emNvSwbTurnOff = 2;</code>
     *
     * <pre>
     *&#47;关机
     * </pre>
     */
    public static final int emNvSwbTurnOff_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNvSwbState valueOf(int value) {
      switch (value) {
        case 0: return emNvSwbChance;
        case 1: return emNvSwbSleep;
        case 2: return emNvSwbTurnOff;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNvSwbState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNvSwbState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNvSwbState>() {
            public EmNvSwbState findValueByNumber(int number) {
              return EmNvSwbState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(109);
    }

    private static final EmNvSwbState[] VALUES = values();

    public static EmNvSwbState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNvSwbState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmNvSwbState)
  }

  /**
   * Protobuf enum {@code nv.EmQkVidFormat}
   *
   * <pre>
   ** 投屏器视频格式 
   * </pre>
   */
  public enum EmQkVidFormat
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emQkVid_Start = 0;</code>
     */
    emQkVid_Start(0, 0),
    /**
     * <code>emQkVid_H265 = 1;</code>
     */
    emQkVid_H265(1, 1),
    /**
     * <code>emQkVid_H264 = 2;</code>
     */
    emQkVid_H264(2, 2),
    /**
     * <code>emQkVid_PROFILE = 3;</code>
     */
    emQkVid_PROFILE(3, 3),
    /**
     * <code>emQkVid_MPEG = 4;</code>
     */
    emQkVid_MPEG(4, 4),
    /**
     * <code>emQkVid_H263 = 5;</code>
     */
    emQkVid_H263(5, 5),
    /**
     * <code>emQkVid_H263PLUS = 6;</code>
     */
    emQkVid_H263PLUS(6, 6),
    /**
     * <code>emQkVid_H261 = 7;</code>
     */
    emQkVid_H261(7, 7),
    ;

    /**
     * <code>emQkVid_Start = 0;</code>
     */
    public static final int emQkVid_Start_VALUE = 0;
    /**
     * <code>emQkVid_H265 = 1;</code>
     */
    public static final int emQkVid_H265_VALUE = 1;
    /**
     * <code>emQkVid_H264 = 2;</code>
     */
    public static final int emQkVid_H264_VALUE = 2;
    /**
     * <code>emQkVid_PROFILE = 3;</code>
     */
    public static final int emQkVid_PROFILE_VALUE = 3;
    /**
     * <code>emQkVid_MPEG = 4;</code>
     */
    public static final int emQkVid_MPEG_VALUE = 4;
    /**
     * <code>emQkVid_H263 = 5;</code>
     */
    public static final int emQkVid_H263_VALUE = 5;
    /**
     * <code>emQkVid_H263PLUS = 6;</code>
     */
    public static final int emQkVid_H263PLUS_VALUE = 6;
    /**
     * <code>emQkVid_H261 = 7;</code>
     */
    public static final int emQkVid_H261_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmQkVidFormat valueOf(int value) {
      switch (value) {
        case 0: return emQkVid_Start;
        case 1: return emQkVid_H265;
        case 2: return emQkVid_H264;
        case 3: return emQkVid_PROFILE;
        case 4: return emQkVid_MPEG;
        case 5: return emQkVid_H263;
        case 6: return emQkVid_H263PLUS;
        case 7: return emQkVid_H261;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmQkVidFormat>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmQkVidFormat>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmQkVidFormat>() {
            public EmQkVidFormat findValueByNumber(int number) {
              return EmQkVidFormat.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(110);
    }

    private static final EmQkVidFormat[] VALUES = values();

    public static EmQkVidFormat valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmQkVidFormat(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmQkVidFormat)
  }

  /**
   * Protobuf enum {@code nv.EmQkAudFormat}
   *
   * <pre>
   ** 投屏器音频格式 
   * </pre>
   */
  public enum EmQkAudFormat
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emQkAud_Start = 0;</code>
     */
    emQkAud_Start(0, 0),
    /**
     * <code>emQkAud_OPUS = 1;</code>
     */
    emQkAud_OPUS(1, 1),
    /**
     * <code>emQkAud_G711A = 2;</code>
     */
    emQkAud_G711A(2, 2),
    /**
     * <code>emQkAud_G711U = 3;</code>
     */
    emQkAud_G711U(3, 3),
    /**
     * <code>emQkAud_G719 = 4;</code>
     */
    emQkAud_G719(4, 4),
    /**
     * <code>emQkAud_G722 = 5;</code>
     */
    emQkAud_G722(5, 5),
    /**
     * <code>emQkAud_G7221 = 6;</code>
     */
    emQkAud_G7221(6, 6),
    /**
     * <code>emQkAud_G728 = 7;</code>
     */
    emQkAud_G728(7, 7),
    /**
     * <code>emQkAud_G729 = 8;</code>
     */
    emQkAud_G729(8, 8),
    /**
     * <code>emQkAud_MPEGAACLC = 9;</code>
     */
    emQkAud_MPEGAACLC(9, 9),
    /**
     * <code>emQkAud_MPEGAACLD = 10;</code>
     */
    emQkAud_MPEGAACLD(10, 10),
    /**
     * <code>emQkAud_MP3 = 11;</code>
     */
    emQkAud_MP3(11, 11),
    ;

    /**
     * <code>emQkAud_Start = 0;</code>
     */
    public static final int emQkAud_Start_VALUE = 0;
    /**
     * <code>emQkAud_OPUS = 1;</code>
     */
    public static final int emQkAud_OPUS_VALUE = 1;
    /**
     * <code>emQkAud_G711A = 2;</code>
     */
    public static final int emQkAud_G711A_VALUE = 2;
    /**
     * <code>emQkAud_G711U = 3;</code>
     */
    public static final int emQkAud_G711U_VALUE = 3;
    /**
     * <code>emQkAud_G719 = 4;</code>
     */
    public static final int emQkAud_G719_VALUE = 4;
    /**
     * <code>emQkAud_G722 = 5;</code>
     */
    public static final int emQkAud_G722_VALUE = 5;
    /**
     * <code>emQkAud_G7221 = 6;</code>
     */
    public static final int emQkAud_G7221_VALUE = 6;
    /**
     * <code>emQkAud_G728 = 7;</code>
     */
    public static final int emQkAud_G728_VALUE = 7;
    /**
     * <code>emQkAud_G729 = 8;</code>
     */
    public static final int emQkAud_G729_VALUE = 8;
    /**
     * <code>emQkAud_MPEGAACLC = 9;</code>
     */
    public static final int emQkAud_MPEGAACLC_VALUE = 9;
    /**
     * <code>emQkAud_MPEGAACLD = 10;</code>
     */
    public static final int emQkAud_MPEGAACLD_VALUE = 10;
    /**
     * <code>emQkAud_MP3 = 11;</code>
     */
    public static final int emQkAud_MP3_VALUE = 11;


    public final int getNumber() { return value; }

    public static EmQkAudFormat valueOf(int value) {
      switch (value) {
        case 0: return emQkAud_Start;
        case 1: return emQkAud_OPUS;
        case 2: return emQkAud_G711A;
        case 3: return emQkAud_G711U;
        case 4: return emQkAud_G719;
        case 5: return emQkAud_G722;
        case 6: return emQkAud_G7221;
        case 7: return emQkAud_G728;
        case 8: return emQkAud_G729;
        case 9: return emQkAud_MPEGAACLC;
        case 10: return emQkAud_MPEGAACLD;
        case 11: return emQkAud_MP3;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmQkAudFormat>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmQkAudFormat>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmQkAudFormat>() {
            public EmQkAudFormat findValueByNumber(int number) {
              return EmQkAudFormat.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(111);
    }

    private static final EmQkAudFormat[] VALUES = values();

    public static EmQkAudFormat valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmQkAudFormat(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmQkAudFormat)
  }

  /**
   * Protobuf enum {@code nv.EmQkCodeRes}
   *
   * <pre>
   ** 投屏器分辨率 
   * </pre>
   */
  public enum EmQkCodeRes
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emQkRes_Start = 0;</code>
     */
    emQkRes_Start(0, 0),
    /**
     * <code>emQkRes_1080P_1920x1080 = 1;</code>
     */
    emQkRes_1080P_1920x1080(1, 1),
    /**
     * <code>emQkRes_WSXGA_1440x900 = 2;</code>
     */
    emQkRes_WSXGA_1440x900(2, 2),
    /**
     * <code>emQkRes_SXGA_1280x1024 = 3;</code>
     */
    emQkRes_SXGA_1280x1024(3, 3),
    /**
     * <code>emQkRes_1280x960 = 4;</code>
     */
    emQkRes_1280x960(4, 4),
    /**
     * <code>emQkRes_WXGA_1366x768 = 5;</code>
     */
    emQkRes_WXGA_1366x768(5, 5),
    /**
     * <code>emQkRes_WXGA_1360x768 = 6;</code>
     */
    emQkRes_WXGA_1360x768(6, 6),
    /**
     * <code>emQkRes_WXGA_1280x800 = 7;</code>
     */
    emQkRes_WXGA_1280x800(7, 7),
    /**
     * <code>emQkRes_WXGA_1280x768 = 8;</code>
     */
    emQkRes_WXGA_1280x768(8, 8),
    /**
     * <code>emQkRes_720P_1280x720 = 9;</code>
     */
    emQkRes_720P_1280x720(9, 9),
    /**
     * <code>emQkRes_1280x600 = 10;</code>
     */
    emQkRes_1280x600(10, 10),
    /**
     * <code>emQkRes_XGA_1024x768 = 11;</code>
     */
    emQkRes_XGA_1024x768(11, 11),
    /**
     * <code>emQkRes_SVGA_800x600 = 12;</code>
     */
    emQkRes_SVGA_800x600(12, 12),
    ;

    /**
     * <code>emQkRes_Start = 0;</code>
     */
    public static final int emQkRes_Start_VALUE = 0;
    /**
     * <code>emQkRes_1080P_1920x1080 = 1;</code>
     */
    public static final int emQkRes_1080P_1920x1080_VALUE = 1;
    /**
     * <code>emQkRes_WSXGA_1440x900 = 2;</code>
     */
    public static final int emQkRes_WSXGA_1440x900_VALUE = 2;
    /**
     * <code>emQkRes_SXGA_1280x1024 = 3;</code>
     */
    public static final int emQkRes_SXGA_1280x1024_VALUE = 3;
    /**
     * <code>emQkRes_1280x960 = 4;</code>
     */
    public static final int emQkRes_1280x960_VALUE = 4;
    /**
     * <code>emQkRes_WXGA_1366x768 = 5;</code>
     */
    public static final int emQkRes_WXGA_1366x768_VALUE = 5;
    /**
     * <code>emQkRes_WXGA_1360x768 = 6;</code>
     */
    public static final int emQkRes_WXGA_1360x768_VALUE = 6;
    /**
     * <code>emQkRes_WXGA_1280x800 = 7;</code>
     */
    public static final int emQkRes_WXGA_1280x800_VALUE = 7;
    /**
     * <code>emQkRes_WXGA_1280x768 = 8;</code>
     */
    public static final int emQkRes_WXGA_1280x768_VALUE = 8;
    /**
     * <code>emQkRes_720P_1280x720 = 9;</code>
     */
    public static final int emQkRes_720P_1280x720_VALUE = 9;
    /**
     * <code>emQkRes_1280x600 = 10;</code>
     */
    public static final int emQkRes_1280x600_VALUE = 10;
    /**
     * <code>emQkRes_XGA_1024x768 = 11;</code>
     */
    public static final int emQkRes_XGA_1024x768_VALUE = 11;
    /**
     * <code>emQkRes_SVGA_800x600 = 12;</code>
     */
    public static final int emQkRes_SVGA_800x600_VALUE = 12;


    public final int getNumber() { return value; }

    public static EmQkCodeRes valueOf(int value) {
      switch (value) {
        case 0: return emQkRes_Start;
        case 1: return emQkRes_1080P_1920x1080;
        case 2: return emQkRes_WSXGA_1440x900;
        case 3: return emQkRes_SXGA_1280x1024;
        case 4: return emQkRes_1280x960;
        case 5: return emQkRes_WXGA_1366x768;
        case 6: return emQkRes_WXGA_1360x768;
        case 7: return emQkRes_WXGA_1280x800;
        case 8: return emQkRes_WXGA_1280x768;
        case 9: return emQkRes_720P_1280x720;
        case 10: return emQkRes_1280x600;
        case 11: return emQkRes_XGA_1024x768;
        case 12: return emQkRes_SVGA_800x600;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmQkCodeRes>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmQkCodeRes>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmQkCodeRes>() {
            public EmQkCodeRes findValueByNumber(int number) {
              return EmQkCodeRes.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.kedacom.nv.netmanage.protobuf.EnumPB.getDescriptor().getEnumTypes().get(112);
    }

    private static final EmQkCodeRes[] VALUES = values();

    public static EmQkCodeRes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmQkCodeRes(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:nv.EmQkCodeRes)
  }


  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\014nvenum.proto\022\002nv*\202\001\n\017EmNvSysStartMod\022\032" +
      "\n\026emNvSysStartMod_By_lib\020\000\022\032\n\026emNvSysSta" +
      "rtMod_By_Dll\020\001\022\036\n\032emNvSysStartMod_By_Pro" +
      "cess\020\002\022\027\n\023emNvSysStartMod_End\020\003*c\n\025EmNvS" +
      "ysStartModFromUI\022\027\n\023emNvSysStart_By_Dll\020" +
      "\000\022\033\n\027emNvSysStart_By_Process\020\001\022\024\n\020emNvSy" +
      "sStart_End\020\002*\227\001\n\017EmNvSysSrvState\022\030\n\024emNv" +
      "SysSrvState_Idle\020\000\022\032\n\026emNvSysSrvState_Bi" +
      "nded\020\001\022\033\n\027emNvSysSrvState_Running\020\002\022\030\n\024e" +
      "mNvSysSrvState_Stop\020\003\022\027\n\023emNvSysSrvState",
      "_Err\020\004*b\n\024EmNvSysKeepLiveState\022\030\n\024emNvSy" +
      "sKLState_Ready\020\000\022\030\n\024emNvSysKLState_Alive" +
      "\020\001\022\026\n\022emNvSysKLState_Err\020\002*,\n\016EmNvIpAddr" +
      "Type\022\014\n\010emNvIpV4\020\000\022\014\n\010emNvIpV6\020\001*f\n\rEmNv" +
      "AliasType\022\r\n\temNvBegin\020\000\022\014\n\010emNvE164\020\001\022\r" +
      "\n\temNvAlias\020\002\022\r\n\temNvEmail\020\003\022\014\n\010emNvEpID" +
      "\020\004\022\014\n\010emNvGKID\020\005*w\n\014EmNvAddrType\022\016\n\nemNv" +
      "AddrIP\020\000\022\020\n\014emNvAddrE164\020\001\022\021\n\remNvAddrAl" +
      "ias\020\002\022\017\n\013emNvDialNum\020\003\022\017\n\013emNvSipAddr\020\004\022" +
      "\020\n\014emNvAddrMoid\020\005*Q\n\014EmNvChanType\022\025\n\021emN",
      "vChanRecvAudio\020\000\022\025\n\021emNvChanRecvVideo\020\001\022" +
      "\023\n\017emNvChanTypeEnd\020\014*\252\001\n\tEmNvModel\022\023\n\017em" +
      "Nv_ModelBegin\020\000\022\022\n\016emNv_Mode_Imix\020\001\022\030\n\024e" +
      "mNv_Mode_QuickShare\020\002\022\025\n\021emNv_Mode_Imix_" +
      "S1\020\003\022\025\n\021emNv_Mode_Imix_D1\020\004\022\025\n\021emNv_Mode" +
      "_Imix_S0\020\005\022\025\n\021emNv_Mode_Imix_D0\020\006*\212\001\n\022Em" +
      "NvCodecComponent\022\026\n\022emNvVidMainEncoder\020\000" +
      "\022\026\n\022emNvVidMainDecoder\020\001\022\026\n\022emNvAudMainE" +
      "ncoder\020\002\022\026\n\022emNvAudMainDecoder\020\003\022\024\n\020emNv" +
      "CodecInvalid\020\024*\216\001\n\027EmNvCodecComponentInd",
      "ex\022\013\n\007emNv1st\020\000\022\013\n\007emNv2nd\020\001\022\013\n\007emNv3rd\020" +
      "\002\022\013\n\007emNv4th\020\003\022\013\n\007emNv5th\020\004\022\013\n\007emNv6th\020\005" +
      "\022\013\n\007emNv7th\020\006\022\013\n\007emNv8th\020\007\022\013\n\007emNv9th\020\010*" +
      "\213\001\n\rEmNvVidFormat\022\r\n\temNvVH261\020\000\022\r\n\temNv" +
      "VH262\020\001\022\r\n\temNvVH263\020\002\022\021\n\remNvVH263plus\020" +
      "\003\022\r\n\temNvVH264\020\004\022\016\n\nemNvVMPEG4\020\005\022\r\n\temNv" +
      "VH265\020\006\022\014\n\010emNvVEnd\020\007*\357\001\n\rEmNvAudFormat\022" +
      "\016\n\nemNvAG711a\020\000\022\016\n\nemNvAG711u\020\001\022\r\n\temNvA" +
      "G722\020\002\022\016\n\nemNvAG7231\020\003\022\r\n\temNvAG728\020\004\022\r\n" +
      "\temNvAG729\020\005\022\014\n\010emNvAMP3\020\006\022\r\n\temNvAG721\020",
      "\007\022\016\n\nemNvAG7221\020\010\022\r\n\temNvAG719\020\t\022\022\n\016emNv" +
      "AMpegAACLC\020\n\022\022\n\016emNvAMpegAACLD\020\013\022\r\n\temNv" +
      "AOpus\020\014\022\016\n\nemNvAudEnd\020\r*\212\010\n\016EmNvResoluti" +
      "on\022\017\n\013emNvResAuto\020\000\022\r\n\temNvSQCIF\020\001\022\014\n\010em" +
      "NvQCIF\020\002\022\013\n\007emNvCIF\020\003\022\014\n\010emNv2CIF\020\004\022\014\n\010e" +
      "mNv4CIF\020\005\022\r\n\temNv16CIF\020\006\022\022\n\016emNvVGA352x2" +
      "40\020\007\022\014\n\010emNv2SIF\020\010\022\022\n\016emNvVGA704x480\020\t\022\022" +
      "\n\016emNvVGA640x480\020\n\022\022\n\016emNvVGA800x600\020\013\022\023" +
      "\n\017emNvVGA1024x768\020\014\022\r\n\temNvVWCIF\020\r\022\024\n\020em" +
      "NvVSQCIF112x96\020\016\022\023\n\017emNvVSQCIF96x80\020\017\022\016\n",
      "\nemNvVW4CIF\020\020\022\026\n\022emNvHD720p1280x720\020\021\022\024\n" +
      "\020emNvVGA1280x1024\020\022\022\024\n\020emNvVGA1600x1200\020" +
      "\023\022\030\n\024emNvHD1080i1920x1080\020\024\022\030\n\024emNvHD108" +
      "0p1920x1080\020\025\022\023\n\017emNvVGA1280x800\020\026\022\023\n\017em" +
      "NvVGA1440x900\020\027\022\023\n\017emNvVGA1280x960\020\030\022\021\n\r" +
      "emNvV1440x816\020\031\022\020\n\014emNv1280x720\020\032\022\020\n\014emN" +
      "vV960x544\020\033\022\020\n\014emNvV640x368\020\034\022\020\n\014emNvV48" +
      "0x272\020\035\022\017\n\013emNv384x272\020\036\022\017\n\013emNv640x544\020" +
      "\037\022\017\n\013emNv320x272\020 \022\024\n\020emNv_720_960x544\020!" +
      "\022\024\n\020emNv_720_864x480\020\"\022\024\n\020emNv_720_640x3",
      "68\020#\022\024\n\020emNv_720_432x240\020$\022\024\n\020emNv_720_3" +
      "20x192\020%\022\022\n\016emNvVGA480x352\020&\022\025\n\021emNvHD48" +
      "0i720x480\020\'\022\025\n\021emNvHD480p720x480\020(\022\025\n\021em" +
      "NvHD576i720x576\020)\022\025\n\021emNvHD576p720x576\020*" +
      "\022\023\n\017emNvVGA1280x768\020+\022\023\n\017emNvVGA1366x768" +
      "\020,\022\023\n\017emNvVGA1280x854\020-\022\024\n\020emNvVGA1680x1" +
      "050\020.\022\024\n\020emNvVGA1920x1200\020/\022\022\n\016emNvV3840" +
      "x2160\0200\022\020\n\014emNv1280x600\0201\022\020\n\014emNv1360x76" +
      "8\0202\022\017\n\013emNvVResEnd\020d*o\n\014EmNvPathType\022\023\n\017" +
      "emNvPathTypeBgn\020\001\022\022\n\016emNvPathConfig\020\002\022\017\n",
      "\013emNvPathLog\020\003\022\017\n\013emNvDataLog\020\004\022\024\n\017emNvP" +
      "athTypeEnd\020\377\001*\376\001\n\010EmNvFile\022\021\n\remNvFileBe" +
      "gin\020\000\022\022\n\016emNvConfigFile\020\001\022\027\n\023emNvDebugCo" +
      "nfigFile\020\002\022\025\n\021emNvStaticPicFile\020\003\022\030\n\024emN" +
      "vUpgradeStateFile\020\004\022\025\n\021emNvMcLicenseFile" +
      "\020\005\022\025\n\021emNvKdvlogCfgFile\020\006\022\031\n\025emNvCorrupt" +
      "ConfigFile\020\007\022\025\n\021emNvExceptionFile\020\010\022\017\n\013e" +
      "mNvLogFile\020\t\022\020\n\013emNvFileEnd\020\377\001*O\n\017EmNvUp" +
      "gradeType\022\022\n\016emNvSusUpgrade\020\000\022\024\n\020emNvLoc" +
      "alUpgrade\020\001\022\022\n\016emNvNvcUpgrade\020\002*\305\002\n\021EmNv",
      "UpgradeNotify\022\024\n\020emNvFileCheckBgn\020\000\022\027\n\023e" +
      "mNvWholeUpgradeBgn\020\001\022\030\n\024emNvFileCheckSuc" +
      "cess\020\002\022\033\n\027emNvWholeUpgradeSuccess\020\003\022\022\n\016e" +
      "mNvUnknownErr\020\004\022\026\n\022emNvInvalidFileErr\020\005\022" +
      "\026\n\022emNvLoadXmlFileErr\020\006\022\024\n\020emNvFileCheck" +
      "Err\020\007\022\026\n\022emNvSysMountBakErr\020\010\022\036\n\032emNvUpg" +
      "radeDriverModuleErr\020\t\022\033\n\027emNvUpgradeAppM" +
      "oduleErr\020\n\022\033\n\027emNvUpgradeExeModuleErr\020\013*" +
      "\362\001\n\016EmNvServerType\022\013\n\007emNvAPS\020\000\022\013\n\007emNvX" +
      "NU\020\001\022\013\n\007emNvSUS\020\002\022\013\n\007emNvNMS\020\003\022\013\n\007emNvNT",
      "S\020\004\022\013\n\007emNvSIP\020\005\022\017\n\013emNvNonH323\020\006\022\017\n\013emN" +
      "vStdH323\020\007\022\013\n\007emNvNTP\020\010\022\013\n\007emNvVOD\020\t\022\021\n\r" +
      "emNvMoMeeting\020\n\022\022\n\016emNvMoPlatform\020\013\022\013\n\007e" +
      "mNvVRS\020\014\022\013\n\007emNvDCS\020\r\022\025\n\021emNvServerTypeE" +
      "nd\020\016*\232\001\n\017EmNvServerState\022\014\n\010emNvIdle\020\000\022\023" +
      "\n\017emNvDnsQuerying\020\001\022\022\n\016emNvLogging_In\020\002\022" +
      "\022\n\016emNvLogin_Succ\020\003\022\023\n\017emNvLogging_Out\020\004" +
      "\022\024\n\020emNvDisconnected\020\005\022\021\n\remNvLogin_Err\020" +
      "\006*l\n\023EmNvUpgradeVerLevel\022\032\n\026emNvUpgradeL" +
      "evelForced\020\000\022\035\n\031emNvUpgradeLevelSuggeste",
      "d\020\001\022\032\n\026emNvUpgradeLevelNormal\020\002*\177\n\026EmNvU" +
      "pgradeReleaseAttr\022\023\n\017emNvUpgradeAttr\020\000\022\031" +
      "\n\025emNvUpgradeAttrCommon\020\001\022\034\n\030emNvUpgrade" +
      "AttrRecommend\020\002\022\027\n\023emNvUpgradeAttrGray\020\004" +
      "*\341\001\n\013EmNvNvcType\022\017\n\013emNvUnkownT\020\000\022\014\n\010emN" +
      "vNvcT\020\001\022\r\n\temNvPcdvT\020\002\022\014\n\010emNvNctT\020\003\022\023\n\017" +
      "emNvQuickShareT\020\004\022\025\n\021emNvSystemUpgrade\020\005" +
      "\022\025\n\021emNvSystemSetting\020\006\022\025\n\021emNvSystemToo" +
      "lbar\020\007\022\025\n\021emNvScreenDrawing\020\010\022\021\n\remNvCon" +
      "tainer\020\t\022\022\n\016emNvPADUpgrade\020\n*\222\002\n\026EmNvNet",
      "AdapterWorkType\022\037\n\033emNvNetAdapterWorkTyp" +
      "e_None\020\000\022\037\n\033emNvNetAdapterWorkType_Wifi\020" +
      "\001\022 \n\034emNvNetAdapterWorkType_PPPoE\020\002\022%\n!e" +
      "mNvNetAdapterWorkType_MobileData\020\003\022&\n\"em" +
      "NvNetAdapterWorkType_EthnetCard1\020\004\022&\n\"em" +
      "NvNetAdapterWorkType_EthnetCard2\020\005\022\035\n\031em" +
      "NvNetAdapterWorkType_E1\020\006*\272\001\n\016EmNvRemote" +
      "Type\022\031\n\025emNvRemoteTypeUnknown\020\000\022\034\n\030emNvR" +
      "emoteTypeShortBlack\020\001\022\033\n\027emNvRemoteTypeL" +
      "ongBlack\020\002\022\030\n\024emNvRemoteTypeSilver\020\003\022\033\n\027",
      "emNvRemoteTypeV3CamCtrl\020\004\022\033\n\027emNvRemoteT" +
      "ypeSkyWalker\020\005*\313\n\n\022EmNvRemoteScanCode\022\021\n" +
      "\remNvScanCode0\020\000\022\021\n\remNvScanCode1\020\001\022\021\n\re" +
      "mNvScanCode2\020\002\022\021\n\remNvScanCode3\020\003\022\021\n\remN" +
      "vScanCode4\020\004\022\021\n\remNvScanCode5\020\005\022\021\n\remNvS" +
      "canCode6\020\006\022\021\n\remNvScanCode7\020\007\022\021\n\remNvSca" +
      "nCode8\020\010\022\021\n\remNvScanCode9\020\t\022\025\n\021emNvScanC" +
      "odePoint\020\n\022\025\n\021emNvScanCodeSharp\020\013\022\024\n\020emN" +
      "vScanCodeMenu\020\014\022\031\n\025emNvScanCodeBackspace" +
      "\020\r\022\025\n\021emNvScanCodeEnter\020\016\022\022\n\016emNvScanCod",
      "eUp\020\017\022\024\n\020emNvScanCodeDown\020\020\022\024\n\020emNvScanC" +
      "odeLeft\020\021\022\025\n\021emNvScanCodeRight\020\022\022\025\n\021emNv" +
      "ScanCodePower\020\023\022\030\n\024emNvScanCodeMainVSrc\020" +
      "\024\022\022\n\016emNvScanCodeAV\020\025\022\027\n\023emNvScanCodeFar" +
      "Ctrl\020\026\022\024\n\020emNvScanCodeMute\020\027\022\025\n\021emNvScan" +
      "CodeQuiet\020\030\022\023\n\017emNvScanCodeVGA\020\031\022\021\n\remNv" +
      "ScanCodeS\020\032\022\030\n\024emNvScanCodeShotSnap\020\033\022\030\n" +
      "\024emNvScanCodeVolumeUp\020\034\022\032\n\026emNvScanCodeV" +
      "olumeDown\020\035\022\027\n\023emNvScanCodeConnect\020\036\022\032\n\026" +
      "emNvScanCodeDisconnect\020\037\022\031\n\025emNvScanCode",
      "Directory\020 \022\031\n\025emNvScanCodePipEnable\020!\022\031" +
      "\n\025emNvScanCodePipAdjust\020\"\022\030\n\024emNvScanCod" +
      "eSelfTest\020#\022\031\n\025emNvScanCodeAutoFocus\020$\022\030" +
      "\n\024emNvScanCodeNearZoom\020%\022\027\n\023emNvScanCode" +
      "FarZoom\020&\022\027\n\023emNvScanCodePreSave\020\'\022\027\n\023em" +
      "NvScanCodePreMove\020(\022\030\n\024emNvScanCodeChair" +
      "Req\020)\022\030\n\024emNvScanCodeSpeakReq\020*\022\027\n\023emNvS" +
      "canCodeQuitReq\020+\022\025\n\021emNvScanCodeState\020,\022" +
      "\027\n\023emNvScanCodeHotLeft\020-\022\031\n\025emNvScanCode" +
      "HotCenter\020.\022\030\n\024emNvScanCodeHotRight\020/\022\024\n",
      "\020emNvScanCodeHelp\0200\022\030\n\024emNvScanCodeBrigh" +
      "tUp\0201\022\032\n\026emNvScanCodeBrightDown\0202\022\024\n\020emN" +
      "vScanCodeDual\0203\022\026\n\022emNvScanCodeReturn\0204\022" +
      "\024\n\020emNvScanCodeFunc\0205\022\026\n\022emNvScanCodeSea" +
      "rch\0206\022\024\n\020emNvScanCodeNull\020b\022\027\n\023emNvScanC" +
      "odeInvalid\020c*H\n\014EmNvStopBits\022\020\n\014emNv1Sto" +
      "pBit\020\000\022\024\n\020emNv1HalfStopBit\020\001\022\020\n\014emNv2Sto" +
      "pBit\020\002*G\n\017EmNvParityCheck\022\017\n\013emNvNoCheck" +
      "\020\000\022\020\n\014emNvOddCheck\020\001\022\021\n\remNvEvenCheck\020\002*" +
      "\230\001\n\016EmNvSerialType\022\017\n\013emNvRS232_0\020\000\022\017\n\013e",
      "mNvRS232_1\020\001\022\017\n\013emNvRS232_2\020\002\022\017\n\013emNvRS2" +
      "32_3\020\003\022\017\n\013emNvRS232_4\020\004\022\017\n\013emNvRS232_5\020\005" +
      "\022\017\n\013emNvRS232_6\020\006\022\017\n\013emNvRS232_7\020\007*\211\001\n\rE" +
      "mNvAlarmCode\022\030\n\023emNvAlarmFileSysErr\020\362\007\022\025" +
      "\n\020emNvAlarmSysBusy\020\363\007\022\024\n\017emNvAlarmFanErr" +
      "\020\370\007\022\026\n\021emNvAlarmTempHigh\020\371\007\022\031\n\024emNvAlarm" +
      "VoltageHigh\020\372\007*U\n\024EmNvEthInterfaceMode\022\036" +
      "\n\032emNvEthInterfaceModeBackup\020\000\022\035\n\031emNvEt" +
      "hInterfaceModeMulti\020\001*c\n\022EmNvSystemFileT" +
      "ype\022\022\n\016emNvFileNormal\020\000\022\025\n\021emNvFileDirec",
      "tory\020\001\022\020\n\014emNvFileLink\020\002\022\020\n\014emNvFilePipe" +
      "\020\003*\237\001\n\017EmNvFileCopyErr\022\023\n\017emNvCopySucces" +
      "s\020\000\022\026\n\022emNvCopyUnknownErr\020\001\022\023\n\017emNvCopyN" +
      "oSpace\020\002\022\033\n\027emNvCopySrcFileNotFound\020\003\022\033\n" +
      "\027emNvCopyDstPathNotFound\020\004\022\020\n\014emNvCopySt" +
      "op\020\005*C\n\020EmNvDisplayRatio\022\016\n\nemNvDR4to3\020\000" +
      "\022\017\n\013emNvDR16to9\020\001\022\016\n\nemNvDRAuto\020\002*I\n\rEmN" +
      "vCallState\022\020\n\014emNvCallIdle\020\000\022\017\n\013emNvCall" +
      "Ing\020\001\022\025\n\021emNvCallConnected\020\002*\243\003\n\023EmNvVid" +
      "eoOutPutMode\022\025\n\021emNvVOM_HD_ORIGIN\020\000\022\025\n\021e",
      "mNvVOM_HD_720P50\020\001\022\025\n\021emNvVOM_HD_720P60\020" +
      "\002\022\026\n\022emNvVOM_HD_1080P24\020\003\022\026\n\022emNvVOM_HD_" +
      "1080P25\020\004\022\026\n\022emNvVOM_HD_1080P30\020\005\022\026\n\022emN" +
      "vVOM_HD_1080P50\020\006\022\026\n\022emNvVOM_HD_1080P60\020" +
      "\007\022\024\n\020emNvVOM_HD_XGA60\020\010\022\025\n\021emNvVOM_HD_SX" +
      "GA60\020\t\022\036\n\032emNvVOM_HD_WXGA1280x800_60\020\n\022\036" +
      "\n\032emNvVOM_HD_WXGA1366x768_60\020\013\022\026\n\022emNvVO" +
      "M_HD_WSXGA60\020\014\022\032\n\026emNvVOM_HD_WSXGAPLUS60" +
      "\020\r\022\026\n\022emNvVOM_HD_2160P30\020\016\022\026\n\022emNvVOM_HD" +
      "_2160P60\020\017*\233\001\n\016EmNvAacChnlNum\022\021\n\remNvCnN",
      "umCust\020\000\022\016\n\nemNvCnNum1\020\001\022\016\n\nemNvCnNum2\020\002" +
      "\022\016\n\nemNvCnNum3\020\004\022\016\n\nemNvCnNum4\020\010\022\016\n\nemNv" +
      "CnNum5\020\020\022\022\n\016emNvCnNum5dot1\020 \022\022\n\016emNvCnNu" +
      "m7dot1\020@*\350\001\n\017EmNvAacSampFreq\022\020\n\014emNvASF9" +
      "6000\020\000\022\020\n\014emNvASF88200\020\001\022\020\n\014emNvASF64000" +
      "\020\002\022\020\n\014emNvASF48000\020\003\022\020\n\014emNvASF44100\020\004\022\020" +
      "\n\014emNvASF32000\020\005\022\020\n\014emNvASF24000\020\006\022\020\n\014em" +
      "NvASF22050\020\007\022\020\n\014emNvASF16000\020\010\022\020\n\014emNvAS" +
      "F12000\020\t\022\020\n\014emNvASF11025\020\n\022\017\n\013emNvASF800" +
      "0\020\013*_\n\027EmNvH264AdditionalModes\022\020\n\014emNvMo",
      "deNone\020\000\022\020\n\014emNvModeRCD0\020@\022\017\n\013emNvModeSB" +
      "P\020 \022\017\n\013emNvModeSHP\020\020*\224\001\n\017EmNvH264Profile" +
      "\022\017\n\013emNvInvalid\020\000\022\020\n\014emNvBaseline\020\001\022\014\n\010e" +
      "mNvMain\020\002\022\020\n\014emNvExtended\020\004\022\014\n\010emNvHigh\020" +
      "\010\022\016\n\nemNvHigh10\020\020\022\017\n\013emNvHigh422\020 \022\017\n\013em" +
      "NvHigh444\020@*W\n\017EmNvH265Profile\022\023\n\017emNvPr" +
      "ofileMain\020\000\022\025\n\021emNvProfileMain10\020\001\022\030\n\024em" +
      "NvProfileMainStill\020\002*s\n\024EmNvLostPackStra" +
      "tegy\022\027\n\023emNvLPSQualityFirst\020\000\022\024\n\020emNvLPS" +
      "SpeedSlow\020\001\022\026\n\022emNvLPSSpeedNormal\020\002\022\024\n\020e",
      "mNvLPSSpeedFast\020\003*\200\002\n\013EmNvPiPMode\022\020\n\014emN" +
      "vPiPClose\020\001\022\024\n\020emNvPIPLeftRight\020\002\022\026\n\022emN" +
      "vPiPRightBottom\020\003\022\025\n\021emNvPiPLeftBottom\020\004" +
      "\022\022\n\016emNvPiPLeftTop\020\005\022\023\n\017emNvPiPRightTop\020" +
      "\006\022\037\n\033emNvPiPTwoSmallLeftInOneBig\020\007\022 \n\034em" +
      "NvPiPTwoSmallRightInOneBig\020\010\022\034\n\030emNvPiPO" +
      "neBigAndTwoSmall\020\t\022\020\n\014emNvPiPThree\020\n*l\n\021" +
      "EmNvHDLastDisplay\022\024\n\020emNvLD_LastFrame\020\000\022" +
      "\025\n\021emNvLD_BlueScreen\020\001\022\024\n\020emNvLD_StaticB" +
      "MP\020\002\022\024\n\020emNvLD_CustomBMP\020\003*N\n\016EmNvResize",
      "Mode\022\021\n\remNvBlackEdge\020\000\022\017\n\013emNvCutEdge\020\001" +
      "\022\030\n\024emNvNoProportionally\020\002*\225\001\n\020EmNvHDIma" +
      "geNoise\022\032\n\026emNvImageNoise_Disable\020\000\022\026\n\022e" +
      "mNvImageNoise_Low\020\001\022\026\n\022emNvImageNoise_Me" +
      "d\020\002\022\027\n\023emNvImageNoise_High\020\003\022\034\n\030emNvImag" +
      "eNoise_UltraHigh\020\004*\267\001\n\023EmNvLocalSoundInd" +
      "ex\022\020\n\014emNvSound1st\020\000\022\020\n\014emNvSound2nd\020\001\022\020" +
      "\n\014emNvSound3rd\020\002\022\020\n\014emNvSound4th\020\003\022\020\n\014em" +
      "NvSound5th\020\004\022\020\n\014emNvSound6th\020\005\022\020\n\014emNvSo" +
      "und7th\020\006\022\020\n\014emNvSound8th\020\007\022\020\n\014emNvSound9",
      "th\020\010*\250\001\n\027EmNvUISynchronizeReason\022\033\n\027emNv" +
      "Synchronize_Upgrade\020\000\022!\n\035emNvSynchronize" +
      "_BeginDspSleep\020\001\022#\n\037emNvSynchronize_Canc" +
      "elDspSleeep\020\002\022(\n$emNvSynchronize_Recount" +
      "AutoSleepTime\020\003*:\n\020EmNvVideoOutPort\022\022\n\016e" +
      "mNv_OUT_HDMI0\020\000\022\022\n\016emNv_OUT_HDMI1\020\001*r\n\017E" +
      "mNvVideoInPort\022\021\n\remNv_IN_HDMI0\020\000\022\021\n\remN" +
      "v_IN_HDMI1\020\001\022\021\n\remNv_IN_HDMI2\020\002\022\022\n\016emNv_" +
      "IN_DSP_VP\020\003\022\022\n\016emNv_IN_OSD_VP\020\004*\331\003\n\022EmNv" +
      "ImixVidSrcType\022\024\n\020emNv_Vid_Invalid\020\000\022\021\n\r",
      "emNv_Vid_IMIX\020\001\022\020\n\014emNv_Vid_OPS\020\002\022\024\n\020emN" +
      "v_Vid_TV_HDMI\020\003\022\017\n\013emNv_Vid_MT\020\004\022\020\n\014emNv" +
      "_Vid_VGA\020\005\022\021\n\remNv_Vid_HDMI\020\006\022\030\n\024emNv_Vi" +
      "d_QuickShare1\020\007\022\030\n\024emNv_Vid_QuickShare2\020" +
      "\010\022\030\n\024emNv_Vid_QuickShare3\020\t\022\030\n\024emNv_Vid_" +
      "QuickShare4\020\n\022\030\n\024emNv_Vid_QuickShare5\020\013\022" +
      "\030\n\024emNv_Vid_QuickShare6\020\014\022\030\n\024emNv_Vid_Qu" +
      "ickShare7\020\r\022\030\n\024emNv_Vid_QuickShare8\020\016\022\021\n" +
      "\remNv_Vid_DLNA\020\017\022\027\n\023emNv_Vid_ScreenDraw\020" +
      "\020\022\023\n\017emNv_Vid_UDisk1\020\021\022\023\n\017emNv_Vid_UDisk",
      "2\020\022\022\026\n\022emNv_Vid_LocalEcho\020\023*5\n\014EmNvMtSvT" +
      "ype\022\022\n\016emNv_MtSv_Hdmi\020\000\022\021\n\remNv_MtSv_Vga" +
      "\020\001*/\n\013EmNvApiMode\022\017\n\013emNvLocMode\020\000\022\017\n\013em" +
      "NvRnvMode\020\001*\355\002\n\023EmNvSleepFailReason\022\022\n\016e" +
      "mNvSFRNoError\020\000\022\031\n\025emNvSFRProtectionTime" +
      "\020\001\022\022\n\016emNvSFRMonitor\020\002\022\021\n\remNvSFRInConf\020" +
      "\003\022\017\n\013emNvSFRLoop\020\004\022\025\n\021emNvSFRRibbonTest\020" +
      "\005\022\023\n\017emNvSFRSnapView\020\006\022\016\n\nemNvSFRVrs\020\007\022\022" +
      "\n\016emNvSFRUpgrade\020\010\022\025\n\021emNvSFRSusUpgrade\020" +
      "\t\022\021\n\remNvSFRNetCap\020\n\022\023\n\017emNvSFRAddrbook\020",
      "\013\022\025\n\021emNvSFRSnapExport\020\014\022\030\n\024emNvSFRInCon" +
      "fByPower\020\036\022\027\n\023emNvSFRInSysUpGrade\020\037\022\026\n\022e" +
      "mNvSFRInQkupgrade\020 *\316\005\n\014EmNvTimeZone\022\024\n\020" +
      "emNvTimeZone_GMT\020\000\022\024\n\020emNvTimeZone_UTC\020\001" +
      "\022\024\n\020emNvTimeZone_ECT\020\002\022\024\n\020emNvTimeZone_E" +
      "ET\020\003\022\024\n\020emNvTimeZone_ART\020\004\022\024\n\020emNvTimeZo" +
      "ne_EAT\020\005\022\024\n\020emNvTimeZone_MET\020\006\022\024\n\020emNvTi" +
      "meZone_NET\020\007\022\024\n\020emNvTimeZone_PLT\020\010\022\024\n\020em" +
      "NvTimeZone_IST\020\t\022\024\n\020emNvTimeZone_BST\020\n\022\024" +
      "\n\020emNvTimeZone_VST\020\013\022\024\n\020emNvTimeZone_CTT",
      "\020\014\022\024\n\020emNvTimeZone_JST\020\r\022\024\n\020emNvTimeZone" +
      "_ACT\020\016\022\024\n\020emNvTimeZone_AET\020\017\022\024\n\020emNvTime" +
      "Zone_SST\020\020\022\024\n\020emNvTimeZone_NST\020\021\022\024\n\020emNv" +
      "TimeZone_MIT\020\022\022\024\n\020emNvTimeZone_HST\020\023\022\024\n\020" +
      "emNvTimeZone_AST\020\024\022\024\n\020emNvTimeZone_PST\020\025" +
      "\022\024\n\020emNvTimeZone_PNT\020\026\022\024\n\020emNvTimeZone_M" +
      "ST\020\027\022\024\n\020emNvTimeZone_CST\020\030\022\024\n\020emNvTimeZo" +
      "ne_EST\020\031\022\024\n\020emNvTimeZone_IET\020\032\022\024\n\020emNvTi" +
      "meZone_PRT\020\033\022\024\n\020emNvTimeZone_CNT\020\034\022\024\n\020em" +
      "NvTimeZone_AGT\020\035\022\024\n\020emNvTimeZone_BET\020\036\022\024",
      "\n\020emNvTimeZone_CAT\020\037*h\n\023EmNvDevRegUpdate" +
      "Ser\022\022\n\016emNvDevInvalid\020\000\022\014\n\010emNvIMIX\020\001\022\014\n" +
      "\010emNvTPad\020\002\022\022\n\016emNvQuickShare\020\003\022\r\n\temNvP" +
      "ower\020\004*>\n\016EmNvUpdateType\022\024\n\020emNvUpdateFo" +
      "rced\020\000\022\026\n\022emNvUpdateSelected\020\001*m\n\024EmNvCn" +
      "LoginUpdateRet\022\034\n\030emNvCnLoginUpdateInval" +
      "id\020\000\022\031\n\025emNvCnLoginUpdateFail\020\001\022\034\n\030emNvC" +
      "nLoginUpdateSuccess\020\002*Y\n\032EmNvScreenColor" +
      "Temperature\022\023\n\017emNvCT_Standard\020\000\022\025\n\021emNv" +
      "CT_Rathercold\020\001\022\017\n\013emNvCT_Warm\020\002*3\n\016EmNv",
      "ScreenType\022\020\n\014emNvSc_Right\020\000\022\017\n\013emNvSc_L" +
      "eft\020\001*\325\003\n\014EmNvSubModel\022\025\n\021emNvSubModelBe" +
      "gin\020\000\022\027\n\023emNvSub_NEX1110A_55\020\001\022\027\n\023emNvSu" +
      "b_NEX1110A_65\020\002\022\027\n\023emNvSub_NEX1110A_75\020\003" +
      "\022\027\n\023emNvSub_NEX1210A_55\020\004\022\027\n\023emNvSub_NEX" +
      "1210A_65\020\005\022\027\n\023emNvSub_NEX1210A_75\020\006\022\027\n\023e" +
      "mNvSub_NEX1110B_55\020\007\022\027\n\023emNvSub_NEX1210B" +
      "_55\020\010\022\030\n\024emNvSub_NEX1110A_55T\020\t\022\030\n\024emNvS" +
      "ub_NEX1110A_65T\020\n\022\030\n\024emNvSub_NEX1110A_75" +
      "T\020\013\022\030\n\024emNvSub_NEX1210A_55T\020\014\022\030\n\024emNvSub",
      "_NEX1210A_65T\020\r\022\030\n\024emNvSub_NEX1210A_75T\020" +
      "\016\022\027\n\023emNvSub_NEX1210H_75\020\017\022\030\n\024emNvSub_NE" +
      "X1210H_75T\020\020\022\027\n\023emNvSub_NEX1310E_75\020\021*K\n" +
      "\022EmNvTvDisplayRatio\022\021\n\remNvTvDR16to9\020\000\022\020" +
      "\n\014emNvTvDRFull\020\001\022\020\n\014emNvTvDR4to3\020\002*\271\001\n\016E" +
      "mNvViewReason\022\024\n\020emNvView_Success\020\000\022\025\n\021e" +
      "mNvView_NoSignal\020\001\022\024\n\020emNvView_Offline\020\002" +
      "\022\031\n\025emNvView_UnknowReason\020\003\022\026\n\022emNvView_" +
      "NotViewed\020\004\022\027\n\023emNvView_OverFormat\020\005\022\030\n\024" +
      "emNvView_OpsNoSignal\020\006*:\n\016EmNvEncodeMode",
      "\022\024\n\020emNvQualityFirst\020\000\022\022\n\016emNvSpeedFirst" +
      "\020\001*\264\001\n\026EmNvPowerTurnOffReason\022\035\n\031emNvTur" +
      "nOffReason_Success\020\000\022\035\n\031emNvTurnOffReaso" +
      "n_Upgrade\020\001\022\037\n\033emNvTurnOffReason_OpsFail" +
      "ed\020\002\022\032\n\026emNvTurnOffReason_Conf\020\003\022\037\n\033emNv" +
      "TurnOffReason_QkUpgrade\020\004*\213\001\n\rEmNvAudPor" +
      "tIn\022\023\n\017emNvAudIn_HDMI0\020\000\022\023\n\017emNvAudIn_HD" +
      "MI1\020\001\022\023\n\017emNvAudIn_HDMI2\020\002\022\023\n\017emNvAudIn_" +
      "HDMI3\020\003\022\021\n\remNvAudIn_RCA\020\004\022\023\n\017emNvAudIn_" +
      "HDMI4\020\005*V\n\016EmNvAudPortOut\022\024\n\020emNvAudOut_",
      "HDMI0\020\000\022\024\n\020emNvAudOut_HDMI1\020\001\022\030\n\024emNvAud" +
      "Out_JACK_3mm5\020\002*d\n\017EmNvPingErrcode\022\021\n\rem" +
      "NvPingReply\020\000\022\023\n\017emNvPingTimeout\020\001\022\021\n\rem" +
      "NvPingError\020\002\022\026\n\022emNvPingNetUnreach\020\003*Y\n" +
      "\016EmNVSerialMode\022\013\n\007emRS232\020\000\022\013\n\007emRS422\020" +
      "\001\022\013\n\007emRS485\020\002\022\024\n\020emSerialInfrared\020\003\022\n\n\006" +
      "emRJ11\020\004*\257\001\n\020EmEthnetWorkMode\022\021\n\remEthMo" +
      "deAuto\020\000\022\024\n\020emEthMode10MFull\020\001\022\024\n\020emEthM" +
      "ode10MHalf\020\002\022\025\n\021emEthMode100MFull\020\003\022\025\n\021e" +
      "mEthMode100MHalf\020\004\022\026\n\022emEthMode1000MFull",
      "\020\005\022\026\n\022emEthMode1000MHalf\020\006*O\n\022EmEthInter" +
      "faceMode\022\034\n\030emEthInterfaceModeBackup\020\000\022\033" +
      "\n\027emEthInterfaceModeMulti\020\001*C\n\022EmEthStar" +
      "tupResult\022\027\n\023emEthStartupSuccess\020\000\022\024\n\020em" +
      "EthStartupFail\020\001*v\n\021EmEthnetParamType\022\027\n" +
      "\023emType_SetIpAndMask\020\000\022\030\n\024emType_SetMacA" +
      "ddress\020\001\022\026\n\022emType_SetAllParam\020\002\022\026\n\022emTy" +
      "pe_SetSecondIp\020\003*D\n\024EmNvVidResResizeMode" +
      "\022\025\n\021emNvPanoramicLift\020\000\022\025\n\021emNvFullScree" +
      "nMid\020\001*\217\001\n\024EmNvIfaceInstruction\022\025\n\021emNvI",
      "face_Invalid\020\000\022\027\n\023emNvIface_Hdmi1_Has\020\001\022" +
      "\026\n\022emNvIface_Hdmi1_No\020\002\022\027\n\023emNvIface_Hdm" +
      "i2_Has\020\003\022\026\n\022emNvIface_Hdmi2_No\020\004*9\n\007EmMt" +
      "Ver\022\016\n\nenNVMtX300\020\000\022\016\n\nenNvMtX500\020\001\022\016\n\ne" +
      "nNvMtX700\020\002*\367\014\n\014EmNvHintCode\022\021\n\remNvHint" +
      "Begin\020\000\022\026\n\022emNvFailtoSendDual\020\001\022\026\n\022emNvF" +
      "ailtoRecvDual\020\002\022\026\n\022emNvFailtoVodLogin\020\003\022" +
      "\023\n\017emNvDHCPTimeOut\020\004\022\030\n\024emNvPPPoEAuthorE" +
      "rror\020\005\022\027\n\023emNvPPPoEAgentError\020\006\022\031\n\025emNvP" +
      "PPoETimeOutError\020\007\022\032\n\026emNvPPPoELinkDownE",
      "rror\020\010\022\031\n\025emNvPPPoEGeneralError\020\t\022\036\n\032emN" +
      "vFailtoSendDualAsReject\020\n\022\035\n\031emNvCallRat" +
      "eNotValidForMc\020\013\022\036\n\032emNvDualResNotMatchC" +
      "onfRes\020\014\022\031\n\025emNvSuccedetoSendDual\020\r\022\031\n\025e" +
      "mNvSuccedetoRecvDual\020\016\022\035\n\031emNvSateMtNoP2" +
      "pPermission\020\017\022&\n\"emNvH323UpLoadBitrateLe" +
      "ssThan64Ind\020\020\022(\n$emNvH323DownLoadBitrate" +
      "LessThan64Ind\020\021\022\031\n\025emNvAssVidHasNoSignal" +
      "\020\022\022\024\n\020emNvBePolledNext\020\036\022#\n\037emNvHintNoOp" +
      "enDSChnnlNonSpeaker\020\037\022\037\n\033emNvHintNoOpenD",
      "SChnnlNonCap\020 \022 \n\034emNvHintNoOpenDSChnnlB" +
      "RLow64\020!\022 \n\034emNvHintNoOpenDSChnnlFECType" +
      "\020\"\022\036\n\032emNvHintNoOpenDSChnnlNonMp\020#\022$\n em" +
      "NvHintNoOpenDSChnnlEncryptMode\020$\022+\n\'emNv" +
      "HintNoOpenDSChnnlOverSatDCastChnNum\020%\022\037\n" +
      "\033emNvHintNoOpenFSChnnlNonCap\020&\022 \n\034emNvHi" +
      "ntNoOpenFSChnnlBRLow64\020\'\022$\n emNvHintNoOp" +
      "enFSChnnlEncrpytMode\020(\022 \n\034emNvHintNoOpen" +
      "FSChnnlFECType\020)\022\036\n\032emNvHintNoOpenFSChnn" +
      "lNonMp\020*\022#\n\037emNvHintNoOpenFSChnnlBROverf",
      "low\020+\022%\n!emNvHintNoOpenFSChnnlBothH263pl" +
      "us\020,\022\037\n\033emNvHintNoOpenFSChnnlFormat\020-\022\034\n" +
      "\030emNvHintNoOpenFSChnnlFPS\020.\022\032\n\026emNvHintB" +
      "RLessThanConf\020/\022\034\n\030emNvHintBRLargerThanC" +
      "onf\0200\022!\n\035emNvHintNoSupportOprForNoAuth\0201" +
      "\022!\n\035emNvHintQueueConfNoIdleServer\0202\022$\n e" +
      "mNvHintQueueConfAllocatedServer\0203\022%\n!emN" +
      "vHintOldStackNotSupportSpecVip\0204\022(\n$emNv" +
      "HintOldStackNotSupportModifyDumb\0205\022+\n\'em" +
      "NvHintOldStackNotSupportModifyConfPwd\0206\022",
      "1\n-emNvHintOldStackNotSupportModifyConfN" +
      "oDisturb\0207\022,\n(emNvHintOldStackNotSupport" +
      "ModifyDuration\0208\022,\n(emNvHintOldStackNotS" +
      "upportModifyConfName\0209\0221\n-emNvHintOldSta" +
      "ckNotSupportSetAssStreamSendMod\020:\022\"\n\036emN" +
      "vHintAssVideoSourceIsSwitch\020;*H\n\021EmNvTvI" +
      "nputSelect\022\021\n\renNvTvInvalid\020\000\022\017\n\013enNvTvH" +
      "dmi1\020\001\022\017\n\013enNvTvHdmi2\020\002*O\n\014EmNvZoomMode\022" +
      "\027\n\023enNV_ZOOM_FILLBLACK\020\000\022\021\n\renNV_ZOOM_CU" +
      "T\020\001\022\023\n\017enNV_ZOOM_SCALE\020\002*\260\001\n\nEmNvScreen\022",
      "\032\n\026enNV_Screen_Brightness\020\000\022\030\n\024enNV_Scre" +
      "en_Contrast\020\001\022\032\n\026enNV_Screen_Saturation\020" +
      "\002\022\027\n\023enNV_Screen_Clarity\020\003\022\031\n\025enNV_Scree" +
      "n_Colortemp\020\004\022\034\n\030enNV_Screen_Displayrati" +
      "o\020\005*V\n\014EmNvVidLabel\022\023\n\017emNvVidLabBegin\020\000" +
      "\022\026\n\022emNvPcStreamVidLab\020\001\022\031\n\025emNvVideoStr" +
      "eamVidLab\020\002*p\n\016EmNvMiniVidPos\022\030\n\024emNvMin" +
      "i_RightBottom\020\000\022\027\n\023emNvMini_LeftBottom\020\001" +
      "\022\024\n\020emNvMini_LeftTop\020\002\022\025\n\021emNvMini_Right" +
      "Top\020\003*\222\002\n\017EmNvCallStatApi\022\024\n\020emNvCallIdl",
      "e_Api\020\000\022\036\n\032emNvCallRasConfJoining_Api\020\001\022" +
      "\037\n\033emNvCallRasConfCreating_Api\020\002\022\026\n\022emNv" +
      "CallOuting_Api\020\003\022\030\n\024emNvCallIncoming_Api" +
      "\020\004\022\030\n\024emNvCallAccepted_Api\020\005\022\027\n\023emNvCall" +
      "Hanging_Api\020\006\022\031\n\025emNvCallConnected_Api\020\007" +
      "\022\023\n\017emNvCallP2P_Api\020\010\022\023\n\017emNvCallMCU_Api" +
      "\020\t*n\n\017EmNvCallingType\022\024\n\020emNvJoinConf_Ap" +
      "i\020\000\022\026\n\022emNvCreateConf_Api\020\001\022\023\n\017emNvOutCa" +
      "ll_Api\020\002\022\030\n\024emNvIncomingCall_Api\020\003*q\n\020Em" +
      "NvCallProtocol\022\031\n\025emNvProtocolBegin_Api\020",
      "\000\022\017\n\013emNv323_Api\020\001\022\017\n\013emNvsip_Api\020\002\022\017\n\013e" +
      "mNvsat_Api\020\003\022\017\n\013emNvtip_Api\020\004*\347\013\n\021EmNvCa" +
      "llDisReason\022\033\n\027emDisconnectNv_Busy_Api\020\000" +
      "\022\035\n\031emDisconnectNv_Normal_Api\020\001\022\037\n\033emDis" +
      "connectNv_Rejected_Api\020\002\022\"\n\036emDisconnect" +
      "Nv_Unreachable_Api\020\003\022\034\n\030emDisconnectNv_L" +
      "ocal_Api\020\004\022\036\n\032emDisconnectNv_Unknown_Api" +
      "\020\005\022\035\n\031emDisconnectNv_custom_Api\020\006\022#\n\037emD" +
      "isconnectNv_AdaptiveBusy_Api\020\007\022\035\n\031emDisc" +
      "onnectNv_Occupy_Api\020\010\022&\n\"emDisconnectNv_",
      "Joinconftimeout_Api\020\024\022(\n$emDisconnectNv_" +
      "Createconftimeout_Api\020\025\022&\n\"emDisconnectN" +
      "v_Nomediaresource_Api\020\026\022+\n\'emDisconnectN" +
      "v_Exceedmaxinconfmtnum_Api\020\027\022\'\n#emDiscon" +
      "nectNv_Exceedmaxconfnum_Api\020\030\022!\n\035emDisco" +
      "nnectNv_EncrypeErr_Api\020\031\022!\n\035emDisconnect" +
      "Nv_P2Ptimeout_Api\020\032\022\036\n\032emDisconnectNv_Mc" +
      "cDrop_Api\020\033\022 \n\034emDisconnectNv_ChairDrop_" +
      "Api\020\034\022\037\n\033emDisconnectNv_MMcuDrop_Api\020\035\022\"" +
      "\n\036emDisconnectNv_ConfRelease_Api\020\036\022!\n\035em",
      "DisconnectNv_PeerInConf_Api\020\037\022$\n emDisco" +
      "nnectNv_PeerNoDisturb_Api\020 \022\'\n#emDisconn" +
      "ectNv_NotInPeerContact_Api\020!\022*\n&emDiscon" +
      "nectNv_PeerNoP2PPermission_Api\020\"\022%\n!emDi" +
      "sconnectNv_PeerOnSleeping_Api\020#\022&\n\"emDis" +
      "connectNv_ConfAutoRelease_Api\020$\022%\n!emDis" +
      "connectNv_REASON_BUSYEXT_Api\020%\022-\n)emDisc" +
      "onnectNv_REASON_REMOTERECONNECT_Api\020&\022$\n" +
      " emDisconnectNv_CallNumExceed_Api\020\'\022+\n\'e" +
      "mDisconnectNv_NotRegedToCallFailed_Api\020(",
      "\022&\n\"emDisconnectNv_LocalVodPlaying_Api\020)" +
      "\022$\n emDisconnectNv_SecCrtNotFind_Api\020*\022\'" +
      "\n#emDisconnectNv_SecCrtVerifyFail_Api\020+\022" +
      "$\n emDisconnectNv_SecCrtExpired_Api\020,\022(\n" +
      "$emDisconnectNv_SecCrtFormatError_Api\020-\022" +
      "(\n$emDisconnectNv_SecLoadCertFailed_Api\020" +
      ".\022&\n\"emDisconnectNv_SecEncTypeError_Api\020" +
      "/\022(\n$emDisconnectNv_AuthenticationErr_Ap" +
      "i\0200\022\"\n\036emDisconnectNv_MtHasInConf_Api\0201\022" +
      "\026\n\022emDisconnectNv_End\020d*\206\001\n\016NvEndpointTy",
      "pe\022\037\n\033emNvEndpointTypeUnknown_Api\020\000\022\032\n\026e" +
      "mNvEndpointTypeMT_Api\020\001\022\033\n\027emNvEndpointT" +
      "ypeMCU_Api\020\002\022\032\n\026emNvEndpointTypeGK_Api\020\004" +
      "*\347\005\n\021EmNvVideoPort_Api\022\026\n\022emNvVidInvalid" +
      "_Api\020\000\022\030\n\024emNvVidMultiView_Api\020\001\022\032\n\026emNv" +
      "VidInnerCamera_Api\020\002\022\023\n\017emNvVidDVI1_Api\020" +
      "\003\022\023\n\017emNvVidDVI2_Api\020\004\022\023\n\017emNvVidDVI3_Ap" +
      "i\020\005\022\023\n\017emNvVidDVI4_Api\020\006\022\024\n\020emNvVidHDMI1" +
      "_Api\020\007\022\024\n\020emNvVidHDMI2_Api\020\010\022\024\n\020emNvVidH" +
      "DMI3_Api\020\t\022\024\n\020emNvVidHDMI4_Api\020\n\022\025\n\021emNv",
      "VidYPbPr1_Api\020\013\022\025\n\021emNvVidYPbPr2_Api\020\014\022\025" +
      "\n\021emNvVidYPbPr3_Api\020\r\022\025\n\021emNvVidYPbPr4_A" +
      "pi\020\016\022\023\n\017emNvVidVGA1_Api\020\017\022\023\n\017emNvVidVGA2" +
      "_Api\020\020\022\023\n\017emNvVidVGA3_Api\020\021\022\023\n\017emNvVidVG" +
      "A4_Api\020\022\022\021\n\remNvVidC1_Api\020\023\022\021\n\remNvVidC2" +
      "_Api\020\024\022\021\n\remNvVidC3_Api\020\025\022\021\n\remNvVidS1_A" +
      "pi\020\026\022\021\n\remNvVidS2_Api\020\027\022\021\n\remNvVidS3_Api" +
      "\020\030\022\027\n\023emNvVidHDBaseT1_Api\020\031\022\027\n\023emNvVidHD" +
      "BaseT2_Api\020\032\022\027\n\023emNvVidHDBaseT3_Api\020\033\022\027\n" +
      "\023emNvVidHDBaseT4_Api\020\034\022\023\n\017emNvVidSDI1_Ap",
      "i\020\035\022\023\n\017emNvVidSDI2_Api\020\036\022\023\n\017emNvVidSDI3_" +
      "Api\020\037\022\023\n\017emNvVidSDI4_Api\020 *\257\004\n\024EmNvVideo" +
      "OutType_Api\022\027\n\023emVOTNv_Invalid_Api\020\000\022\024\n\020" +
      "emVOTNv_DVI1_Api\020\001\022\024\n\020emVOTNv_DVI2_Api\020\002" +
      "\022\024\n\020emVOTNv_DVI3_Api\020\003\022\024\n\020emVOTNv_DVI4_A" +
      "pi\020\004\022\025\n\021emVOTNv_HDMI1_Api\020\005\022\025\n\021emVOTNv_H" +
      "DMI2_Api\020\006\022\025\n\021emVOTNv_HDMI3_Api\020\007\022\025\n\021emV" +
      "OTNv_HDMI4_Api\020\010\022\026\n\022emVOTNv_YPbPr1_Api\020\t" +
      "\022\026\n\022emVOTNv_YPbPr2_Api\020\n\022\026\n\022emVOTNv_YPbP" +
      "r3_Api\020\013\022\026\n\022emVOTNv_YPbPr4_Api\020\014\022\024\n\020emVO",
      "TNv_VGA1_Api\020\r\022\024\n\020emVOTNv_VGA2_Api\020\016\022\024\n\020" +
      "emVOTNv_VGA3_Api\020\017\022\024\n\020emVOTNv_VGA4_Api\020\020" +
      "\022\024\n\020emVOTNv_SDI1_Api\020\021\022\024\n\020emVOTNv_SDI2_A" +
      "pi\020\022\022\024\n\020emVOTNv_SDI3_Api\020\023\022\024\n\020emVOTNv_SD" +
      "I4_Api\020\024\022\022\n\016emVOTNv_C1_Api\020\025\022\022\n\016emVOTNv_" +
      "C2_Api\020\026\022\022\n\016emVOTNv_C3_Api\020\027*\201\010\n\027EmNvVid" +
      "eoSourceType_Api\022\024\n\020emNv_Invalid_Api\020\000\022\023" +
      "\n\017emNv_1stDec_Api\020\001\022\023\n\017emNv_2ndDec_Api\020\002" +
      "\022\023\n\017emNv_3rdDec_Api\020\003\022\023\n\017emNv_4thDec_Api" +
      "\020\004\022\023\n\017emNv_5thDec_Api\020\005\022\023\n\017emNv_6thDec_A",
      "pi\020\006\022\023\n\017emNv_7thDec_Api\020\007\022\023\n\017emNv_8thDec" +
      "_Api\020\010\022\023\n\017emNv_9thDec_Api\020\t\022\024\n\020emNv_10th" +
      "Dec_Api\020\n\022\035\n\031emNv_MtVidInnerCamera_Api\020\013" +
      "\022\026\n\022emNv_MtVidDVI1_Api\020\014\022\026\n\022emNv_MtVidDV" +
      "I2_Api\020\r\022\026\n\022emNv_MtVidDVI3_Api\020\016\022\026\n\022emNv" +
      "_MtVidDVI4_Api\020\017\022\027\n\023emNv_MtVidHDMI1_Api\020" +
      "\020\022\027\n\023emNv_MtVidHDMI2_Api\020\021\022\027\n\023emNv_MtVid" +
      "HDMI3_Api\020\022\022\027\n\023emNv_MtVidHDMI4_Api\020\023\022\030\n\024" +
      "emNv_MtVidYPbPr1_Api\020\024\022\030\n\024emNv_MtVidYPbP" +
      "r2_Api\020\025\022\030\n\024emNv_MtVidYPbPr3_Api\020\026\022\030\n\024em",
      "Nv_MtVidYPbPr4_Api\020\027\022\026\n\022emNv_MtVidVGA1_A" +
      "pi\020\030\022\026\n\022emNv_MtVidVGA2_Api\020\031\022\026\n\022emNv_MtV" +
      "idVGA3_Api\020\032\022\026\n\022emNv_MtVidVGA4_Api\020\033\022\024\n\020" +
      "emNv_MtVidC1_Api\020\034\022\024\n\020emNv_MtVidC2_Api\020\035" +
      "\022\024\n\020emNv_MtVidC3_Api\020\036\022\024\n\020emNv_MtVidS1_A" +
      "pi\020\037\022\024\n\020emNv_MtVidS2_Api\020 \022\024\n\020emNv_MtVid" +
      "S3_Api\020!\022\032\n\026emNv_MtVidHDBaseT1_Api\020\"\022\032\n\026" +
      "emNv_MtVidHDBaseT2_Api\020#\022\032\n\026emNv_MtVidHD" +
      "BaseT3_Api\020$\022\032\n\026emNv_MtVidHDBaseT4_Api\020%" +
      "\022\026\n\022emNv_MtVidSDI1_Api\020&\022\026\n\022emNv_MtVidSD",
      "I2_Api\020\'\022\026\n\022emNv_MtVidSDI3_Api\020(\022\026\n\022emNv" +
      "_MtVidSDI4_Api\020)*a\n\022EmNvDynamicSrcType\022\022" +
      "\n\016emNvUnkownType\020\000\022\021\n\remNvStaticSrc\020\001\022\022\n" +
      "\016emNvDynamicSrc\020\002\022\020\n\014emNvQKorDLNA\020\003*\250\013\n\023" +
      "EmNvLeaveDrawReason\022 \n\034emNv_LeaveDrawRea" +
      "son_Invalid\020\000\022\032\n\026emNv_Draw_OPS_NoSignal\020" +
      "\001\022\036\n\032emNv_Draw_TV_HDMI_NoSignal\020\002\022\031\n\025emN" +
      "v_Draw_MT_NoSignal\020\003\022\032\n\026emNv_Draw_VGA_No" +
      "Signal\020\004\022\033\n\027emNv_Draw_HDMI_NoSignal\020\005\022\"\n" +
      "\036emNv_Draw_QuickShare1_NoSignal\020\006\022\"\n\036emN",
      "v_Draw_QuickShare2_NoSignal\020\007\022\"\n\036emNv_Dr" +
      "aw_QuickShare3_NoSignal\020\010\022\"\n\036emNv_Draw_Q" +
      "uickShare4_NoSignal\020\t\022\"\n\036emNv_Draw_Quick" +
      "Share5_NoSignal\020\n\022\"\n\036emNv_Draw_QuickShar" +
      "e6_NoSignal\020\013\022\"\n\036emNv_Draw_QuickShare7_N" +
      "oSignal\020\014\022\"\n\036emNv_Draw_QuickShare8_NoSig" +
      "nal\020\r\022\033\n\027emNv_Draw_DLNA_NoSignal\020\016\022\035\n\031em" +
      "Nv_Draw_UDisk1_NoSignal\020\017\022\035\n\031emNv_Draw_U" +
      "Disk2_NoSignal\020\020\022\026\n\022emNv_Draw_CallIdle\020\021" +
      "\022\033\n\027emNv_Draw_CallConnected\020\022\022\032\n\026emNv_Dr",
      "aw_StartRcvDual\020\023\022\031\n\025emNv_Draw_StopRcvDu" +
      "al\020\024\022\033\n\027emNv_Draw_StartSendDual\020\025\022\032\n\026emN" +
      "v_Draw_StopSendDual\020\026\022\037\n\033emNv_Draw_Quick" +
      "Share1_Start\020\027\022\037\n\033emNv_Draw_QuickShare2_" +
      "Start\020\030\022\037\n\033emNv_Draw_QuickShare3_Start\020\031" +
      "\022\037\n\033emNv_Draw_QuickShare4_Start\020\032\022\037\n\033emN" +
      "v_Draw_QuickShare5_Start\020\033\022\037\n\033emNv_Draw_" +
      "QuickShare6_Start\020\034\022\037\n\033emNv_Draw_QuickSh" +
      "are7_Start\020\035\022\037\n\033emNv_Draw_QuickShare8_St" +
      "art\020\036\022\030\n\024emNv_Draw_DLNA_Start\020\037\022\027\n\023emNv_",
      "Draw_VGA_Start\020 \022\033\n\027emNv_Draw_TV_HDMI_St" +
      "art\020!\022\036\n\032emNv_Draw_QuickShare1_Stop\020\"\022\036\n" +
      "\032emNv_Draw_QuickShare2_Stop\020#\022\036\n\032emNv_Dr" +
      "aw_QuickShare3_Stop\020$\022\036\n\032emNv_Draw_Quick" +
      "Share4_Stop\020%\022\036\n\032emNv_Draw_QuickShare5_S" +
      "top\020&\022\036\n\032emNv_Draw_QuickShare6_Stop\020\'\022\036\n" +
      "\032emNv_Draw_QuickShare7_Stop\020(\022\036\n\032emNv_Dr" +
      "aw_QuickShare8_Stop\020)\022\032\n\026emNv_Draw_UDisk" +
      "1_Start\020*\022\032\n\026emNv_Draw_UDisk2_Start\020+\022\027\n" +
      "\023emNv_Draw_ops_Start\020,\022\026\n\022emNv_Draw_ops_",
      "Stop\020-*h\n\022EmNvPPTPageTurning\022\034\n\030emNv_Pag" +
      "eTurning_Invalid\020\000\022\017\n\013emNv_PageUp\020\001\022\021\n\re" +
      "mNv_PageDown\020\002\022\020\n\014emNv_PPTStop\020\003*\374\001\n\032EmN" +
      "vAutoShutdownFailReason\022\'\n#emNv_AutoShut" +
      "downFailReason_Invalid\020\000\022\033\n\027emNv_AutoShu" +
      "tdown_Touch\020\001\022\032\n\026emNv_AutoShutdown_Conf\020" +
      "\002\022\035\n\031emNv_AutoShutdown_Upgrage\020\003\022\037\n\033emNv" +
      "_AutoShutdown_QkUpgrage\020\004\022\034\n\030emNv_AutoSh" +
      "utdown_ViewQK\020\005\022\036\n\032emNv_AutoShutdown_Vie" +
      "wDLNA\020\006*\306\n\n\013EmNvMtModel\022\020\n\014emModelBegin\020",
      "\000\022\020\n\014emSkyWindows\020\001\022\r\n\temSkyIPad\020\002\022\017\n\013em" +
      "SkyIPhone\020\003\022\023\n\017emSkyAndroidPad\020\007\022\025\n\021emSk" +
      "yAndroidPhone\020\010\022\022\n\016emX500_1080P60\020\t\022\022\n\016e" +
      "mX500_1080P30\020\n\022\021\n\remX500_720P60\020\013\022\023\n\017em" +
      "X500_mo_1080P\020\014\022\022\n\016emX500_mo_720P\020\r\022\024\n\020e" +
      "mX500_oem_1080P\020\016\022\027\n\023emX500_oem_mo_1080P" +
      "\020\017\022\016\n\nemTrueLink\020\020\022\023\n\017emTrueTouchIpad\020\021\022" +
      "\025\n\021emTrueTouchIphone\020\022\022\033\n\027emTrueTouchAnd" +
      "roidPhone\020\023\022\031\n\025emTrueTouchAndroidPad\020\024\022\022" +
      "\n\016emH950_1080P60\020\025\022\020\n\014emTrueLinkTV\020\026\022\017\n\013",
      "emX700_4k30\020\027\022\023\n\017emX700_oem_4k30\020\030\022\017\n\013em" +
      "X500_4k30\020\031\022\023\n\017emX500_oem_4k30\020\032\022\022\n\016emX3" +
      "00_1080P60\020\033\022\022\n\016emX300_1080P30\020\034\022\021\n\remX3" +
      "00_720P60\020\035\022\026\n\022emX300_oem_1080P60\020\036\022\023\n\017e" +
      "mX500_1080P_60\020\037\022\023\n\017emX500_1080P_30\020 \022\027\n" +
      "\023emX500_oem_1080P_60\020!\022\021\n\rem300_1080P30\020" +
      "\"\022\020\n\014em300_720P60\020#\022\025\n\021em300_oem_1080P30" +
      "\020$\022\022\n\016em300L_1080P30\020%\022\021\n\rem300L_720P60\020" +
      "&\022\026\n\022em300L_oem_1080P30\020\'\022\021\n\rem300_1080P" +
      "60\020(\022\020\n\014em300_720P30\020)\022\022\n\016em300L_1080P60",
      "\020*\022\021\n\rem300L_720P30\020+\022\021\n\remX300_720P30\020," +
      "\022\022\n\016emX500_720P_30\020-\022\022\n\016emX500_720P_60\020." +
      "\022\025\n\021em100_1080P30_12X\020/\022\024\n\020em100_1080P30" +
      "_3X\0200\022\017\n\013em100L_720P\0201\022\030\n\024em100_oem_1080" +
      "P30_3X\0202\022\022\n\016emSkyWindows_s\0203\022\017\n\013emSkyIPa" +
      "d_s\0204\022\021\n\remSkyIPhone_s\0205\022\025\n\021emSkyAndroid" +
      "Pad_s\0206\022\027\n\023emSkyAndroidPhone_s\0207\022\024\n\020emX3" +
      "00_1080P60_s\0208\022\024\n\020emX500_1080P60_s\0209\022\023\n\017" +
      "em300_1080P60_s\020:\022\014\n\010emX700_s\020;\022\017\n\013emX50" +
      "0_4K_s\020<\022\027\n\023em100_1080P30_12X_s\020=\022\025\n\021emX",
      "300_1080P60_cs\020>\022\025\n\021emX500_1080P60_cs\020?\022" +
      "\024\n\020em300_1080P60_cs\020@\022\r\n\temX700_cs\020A\022\020\n\014" +
      "emX500_4K_cs\020B\022\030\n\024em100_1080P30_12X_cs\020C" +
      "*K\n\022EmMtLocalSoundType\022\014\n\010emLSRing\020\000\022\017\n\013" +
      "emLSKeyTone\020\001\022\026\n\022emLSSpecialEffects\020\002*\245\001" +
      "\n\023EmMtLocalSoundIndex\022\016\n\nemSound1st\020\000\022\016\n" +
      "\nemSound2nd\020\001\022\016\n\nemSound3rd\020\002\022\016\n\nemSound" +
      "4th\020\003\022\016\n\nemSound5th\020\004\022\016\n\nemSound6th\020\005\022\016\n" +
      "\nemSound7th\020\006\022\016\n\nemSound8th\020\007\022\016\n\nemSound" +
      "9th\020\010*\222\003\n\017EmMtHDAudPortIn\022\022\n\016emHDAudInBe",
      "gin\020\000\022\022\n\016emHDAudInDMic1\020\001\022\022\n\016emHDAudInDM" +
      "ic2\020\002\022\020\n\014emHDAudInXLR\020\003\022\022\n\016emHDAudInWMic" +
      "1\020\004\022\022\n\016emHDAudInWMic2\020\005\022\022\n\016emHDAudInWMic" +
      "3\020\006\022\020\n\014emHDAudInRCA\020\007\022\023\n\017emHDAudInTRS3_5" +
      "\020\010\022\022\n\016emHDAudInHDMI1\020\t\022\022\n\016emHDAudInHDMI2" +
      "\020\n\022\022\n\016emHDAudInHDMI3\020\013\022\022\n\016emHDAudInDHDMI" +
      "\020\014\022\021\n\remHDAudInSDI1\020\r\022\021\n\remHDAudInSDI2\020\016" +
      "\022\025\n\021emHDAudInHDBaseT1\020\017\022\025\n\021emHDAudInHDBa" +
      "seT2\020\020\022\024\n\020emHDAudInDsiMic1\020\021\022\024\n\020emHDAudI" +
      "nDsiMic2\020\022*\242\002\n\022EmMtCodecComponent\022\024\n\020emV",
      "idMainEncoder\020\000\022\024\n\020emVidMainDecoder\020\001\022\024\n" +
      "\020emAudMainEncoder\020\002\022\024\n\020emAudMainDecoder\020" +
      "\003\022\022\n\016emAudMainMixer\020\004\022\022\n\016emVidMainMixer\020" +
      "\005\022\023\n\017emVidAssEncoder\020\006\022\023\n\017emVidAssDecode" +
      "r\020\007\022\023\n\017emAudAssEncoder\020\010\022\023\n\017emAudAssDeco" +
      "der\020\t\022\021\n\remAudAssMixer\020\n\022\021\n\remVidAssMixe" +
      "r\020\013\022\022\n\016emCodecInvalid\020\024*\236\001\n\025EmCodecCompo" +
      "nentIndex\022\r\n\tem1st_Api\020\000\022\r\n\tem2nd_Api\020\001\022" +
      "\r\n\tem3rd_Api\020\002\022\r\n\tem4th_Api\020\003\022\r\n\tem5th_A" +
      "pi\020\004\022\r\n\tem6th_Api\020\005\022\r\n\tem7th_Api\020\006\022\r\n\tem",
      "8th_Api\020\007\022\r\n\tem9th_Api\020\010*c\n\020EmMtConfProt" +
      "ocol\022\023\n\017emProtocolBegin\020\000\022\r\n\tem323_Api\020\001" +
      "\022\r\n\temsip_Api\020\002\022\r\n\temsat_Api\020\003\022\r\n\temtip_" +
      "Api\020\004*G\n\022EmMtServerAddrType\022\030\n\024emSrvAddr" +
      "TypeDefault\020\000\022\027\n\023emSrvAddrTypeCustom\020\001*\311" +
      "\001\n\030EmMtAudioDelayCheckState\022\025\n\021emAudioDe" +
      "layBegin\020\000\022\030\n\024emAudioDelayChecking\020\001\022\027\n\023" +
      "emAudioDelayChecked\020\002\022\027\n\023emAudioDelayTim" +
      "eout\020\003\022\026\n\022emAudioDelayFailed\020\004\022\030\n\024emAudi" +
      "oDelayReserve1\020\005\022\030\n\024emAudioDelayReserve2",
      "\020\006*\220\002\n\016EmMtServerType\022\r\n\temAPS_Api\020\000\022\r\n\t" +
      "emXNU_Api\020\001\022\r\n\temSUS_Api\020\002\022\r\n\temNMS_Api\020" +
      "\003\022\r\n\temNTS_Api\020\004\022\r\n\temSIP_Api\020\005\022\021\n\remNon" +
      "H323_Api\020\006\022\021\n\remStdH323_Api\020\007\022\r\n\temNTP_A" +
      "pi\020\010\022\r\n\temVOD_Api\020\t\022\023\n\017emMoMeeting_Api\020\n" +
      "\022\024\n\020emMoPlatform_Api\020\013\022\r\n\temVRS_Api\020\014\022\r\n" +
      "\temDCS_Api\020\r\022\027\n\023emServerTypeEnd_Api\020\016*\275\001" +
      "\n\017EmMtServerState\022\021\n\remSrvIdle_Api\020\000\022\030\n\024" +
      "emSrvDnsQuerying_Api\020\001\022\027\n\023emSrvLogging_I" +
      "n_Api\020\002\022\027\n\023emSrvLogin_Succ_Api\020\003\022\030\n\024emSr",
      "vLogging_Out_Api\020\004\022\031\n\025emSrvDisconnected_" +
      "Api\020\005\022\026\n\022emSrvLogin_Err_Api\020\006*\363\005\n\023EmMtRe" +
      "gFailedReason\022\027\n\023emGKFailedBegin_Api\020\000\022\027" +
      "\n\023emGKUnReachable_Api\020\001\022\027\n\023emInvalidAlia" +
      "se_Api\020\002\022\022\n\016emDupAlias_Api\020\003\022\034\n\030emInvali" +
      "dCallAddress_Api\020\004\022\035\n\031emResourceUnavaila" +
      "ble_Api\020\005\022\027\n\023emRegNumberFull_Api\020\007\022\032\n\026em" +
      "GKSecurityDenial_Api\020\010\022\024\n\020emGKDismatch_A" +
      "pi\020\t\022\024\n\020emUnRegGKReq_Api\020\n\022\035\n\031emRRQCreat" +
      "eHRASFailed_Api\020\013\022\027\n\023emRRQSendFailed_Api",
      "\020\014\022\030\n\024emSipFailedBegin_Api\0202\022\035\n\031emSipLoc" +
      "alNormalUnreg_Api\0203\022\'\n#emSipInvalidUserN" +
      "ameAndPassword_Api\0204\022!\n\035emSipRegistrarUn" +
      "Reachable_Api\0205\022\031\n\025emSipInvalidAlias_Api" +
      "\0206\022\032\n\026emSipUnknownReason_Api\0207\022\033\n\027emSipR" +
      "egisterFailed_Api\0208\022\034\n\030emSipRegisterName" +
      "Dup_Api\0209\022\027\n\023emSecCrtNotFind_Api\020:\022\032\n\026em" +
      "SecCrtVerifyFail_Api\020;\022\027\n\023emSecCrtExpire" +
      "d_Api\020<\022\033\n\027emSecCrtFormatError_Api\020=\022\033\n\027" +
      "emSecLoadCertFailed_Api\020>\022\022\n\016emUnRegSuc_",
      "Api\020Z\022\024\n\020emRegSuccess_Api\020d*O\n\014EmMtSdiIn" +
      "Out\022\021\n\remSdiNone_Api\020\000\022\022\n\016emSdiTwoIn_Api" +
      "\020\001\022\030\n\024emSdiOneInOneOut_Api\020\002*\213\002\n\014EmMtMic" +
      "DevId\022\023\n\017emWiredMic0_Api\020\000\022\023\n\017emWiredMic" +
      "1_Api\020\001\022\026\n\022emWirelessMic0_Api\020\002\022\026\n\022emWir" +
      "elessMic1_Api\020\003\022\026\n\022emWirelessMic2_Api\020\004\022" +
      "\033\n\027emWiredMic0Cascade1_Api\020\005\022\033\n\027emWiredM" +
      "ic0Cascade2_Api\020\006\022\033\n\027emWiredMic1Cascade1" +
      "_Api\020\007\022\033\n\027emWiredMic1Cascade2_Api\020\010\022\025\n\021e" +
      "mMicDevIdEnd_Api\020\t*r\n\017EmMtHDVideoType\022\027\n",
      "\023emHD1stPriVideo_Api\020\000\022\027\n\023emHD2ndPriVide" +
      "o_Api\020\001\022\027\n\023emHD3rdPriVideo_Api\020\002\022\024\n\020emHD" +
      "AssVideo_Api\020\n*G\n\014EmNvSwbState\022\021\n\remNvSw" +
      "bChance\020\000\022\020\n\014emNvSwbSleep\020\001\022\022\n\016emNvSwbTu" +
      "rnOff\020\002*\247\001\n\rEmQkVidFormat\022\021\n\remQkVid_Sta" +
      "rt\020\000\022\020\n\014emQkVid_H265\020\001\022\020\n\014emQkVid_H264\020\002" +
      "\022\023\n\017emQkVid_PROFILE\020\003\022\020\n\014emQkVid_MPEG\020\004\022" +
      "\020\n\014emQkVid_H263\020\005\022\024\n\020emQkVid_H263PLUS\020\006\022" +
      "\020\n\014emQkVid_H261\020\007*\364\001\n\rEmQkAudFormat\022\021\n\re" +
      "mQkAud_Start\020\000\022\020\n\014emQkAud_OPUS\020\001\022\021\n\remQk",
      "Aud_G711A\020\002\022\021\n\remQkAud_G711U\020\003\022\020\n\014emQkAu" +
      "d_G719\020\004\022\020\n\014emQkAud_G722\020\005\022\021\n\remQkAud_G7" +
      "221\020\006\022\020\n\014emQkAud_G728\020\007\022\020\n\014emQkAud_G729\020" +
      "\010\022\025\n\021emQkAud_MPEGAACLC\020\t\022\025\n\021emQkAud_MPEG" +
      "AACLD\020\n\022\017\n\013emQkAud_MP3\020\013*\334\002\n\013EmQkCodeRes" +
      "\022\021\n\remQkRes_Start\020\000\022\033\n\027emQkRes_1080P_192" +
      "0x1080\020\001\022\032\n\026emQkRes_WSXGA_1440x900\020\002\022\032\n\026" +
      "emQkRes_SXGA_1280x1024\020\003\022\024\n\020emQkRes_1280" +
      "x960\020\004\022\031\n\025emQkRes_WXGA_1366x768\020\005\022\031\n\025emQ" +
      "kRes_WXGA_1360x768\020\006\022\031\n\025emQkRes_WXGA_128",
      "0x800\020\007\022\031\n\025emQkRes_WXGA_1280x768\020\010\022\031\n\025em" +
      "QkRes_720P_1280x720\020\t\022\024\n\020emQkRes_1280x60" +
      "0\020\n\022\030\n\024emQkRes_XGA_1024x768\020\013\022\030\n\024emQkRes" +
      "_SVGA_800x600\020\014B+\n!com.kedacom.nv.netman" +
      "age.protobufB\006EnumPB"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
        public com.google.protobuf.ExtensionRegistry assignDescriptors(
            com.google.protobuf.Descriptors.FileDescriptor root) {
          descriptor = root;
          return null;
        }
      };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
  }

  // @@protoc_insertion_point(outer_class_scope)
}
