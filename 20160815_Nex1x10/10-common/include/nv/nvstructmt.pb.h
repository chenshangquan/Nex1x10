// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nvstructmt.proto

#ifndef PROTOBUF_nvstructmt_2eproto__INCLUDED
#define PROTOBUF_nvstructmt_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "nvenum.pb.h"
#include "nvstructcommon.pb.h"
#include "nvstructbase.pb.h"
// @@protoc_insertion_point(includes)

namespace nv {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
void protobuf_AssignDesc_nvstructmt_2eproto();
void protobuf_ShutdownFile_nvstructmt_2eproto();

class TNVApsLoginParam;
class TNVH323PxyCfg;
class TNVH460PxyCfg;
class TNVSipSrvCfg;
class TNVMtAudInState;
class TNVMtMutiAudInState;
class TNVMtLocalSoundPaly;
class TNVMtAudioTestCfg;
class TNVMtAudioPower;
class TNVMtXAPSvrCfg;
class TNVMtXAPSvrList;
class TNVMtCSUAddr;
class TNVMtAccountManager;
class TNVMtApsLoginErrcode;
class TNVForceSetH323Stack;
class TNVMtAudInPort;
class TNVMtAudInPortList;
class TNVMtCallBitRate;
class TNVMtSvrState;
class TNVMtSvrStateList;
class TNVMtMicStatus;
class TNVMtAllMicStatus;
class TNVMtHDVidInPort;
class TNVImixAllVerInfo;
class TNVSusUpgradeModule;

// ===================================================================

class MTMSG_API TNVApsLoginParam : public ::google::protobuf::Message {
 public:
  TNVApsLoginParam();
  virtual ~TNVApsLoginParam();

  TNVApsLoginParam(const TNVApsLoginParam& from);

  inline TNVApsLoginParam& operator=(const TNVApsLoginParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVApsLoginParam& default_instance();

  void Swap(TNVApsLoginParam* other);

  // implements Message ----------------------------------------------

  TNVApsLoginParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVApsLoginParam& from);
  void MergeFrom(const TNVApsLoginParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string software_ver = 3;
  inline bool has_software_ver() const;
  inline void clear_software_ver();
  static const int kSoftwareVerFieldNumber = 3;
  inline const ::std::string& software_ver() const;
  inline void set_software_ver(const ::std::string& value);
  inline void set_software_ver(const char* value);
  inline void set_software_ver(const char* value, size_t size);
  inline ::std::string* mutable_software_ver();
  inline ::std::string* release_software_ver();
  inline void set_allocated_software_ver(::std::string* software_ver);

  // optional string model_name = 4;
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 4;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // optional string oem_info = 5;
  inline bool has_oem_info() const;
  inline void clear_oem_info();
  static const int kOemInfoFieldNumber = 5;
  inline const ::std::string& oem_info() const;
  inline void set_oem_info(const ::std::string& value);
  inline void set_oem_info(const char* value);
  inline void set_oem_info(const char* value, size_t size);
  inline ::std::string* mutable_oem_info();
  inline ::std::string* release_oem_info();
  inline void set_allocated_oem_info(::std::string* oem_info);

  // optional string md5_password = 6;
  inline bool has_md5_password() const;
  inline void clear_md5_password();
  static const int kMd5PasswordFieldNumber = 6;
  inline const ::std::string& md5_password() const;
  inline void set_md5_password(const ::std::string& value);
  inline void set_md5_password(const char* value);
  inline void set_md5_password(const char* value, size_t size);
  inline ::std::string* mutable_md5_password();
  inline ::std::string* release_md5_password();
  inline void set_allocated_md5_password(::std::string* md5_password);

  // @@protoc_insertion_point(class_scope:nv.TNVApsLoginParam)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_software_ver();
  inline void clear_has_software_ver();
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_oem_info();
  inline void clear_has_oem_info();
  inline void set_has_md5_password();
  inline void clear_has_md5_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::std::string* password_;
  ::std::string* software_ver_;
  ::std::string* model_name_;
  ::std::string* oem_info_;
  ::std::string* md5_password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVApsLoginParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVH323PxyCfg : public ::google::protobuf::Message {
 public:
  TNVH323PxyCfg();
  virtual ~TNVH323PxyCfg();

  TNVH323PxyCfg(const TNVH323PxyCfg& from);

  inline TNVH323PxyCfg& operator=(const TNVH323PxyCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVH323PxyCfg& default_instance();

  void Swap(TNVH323PxyCfg* other);

  // implements Message ----------------------------------------------

  TNVH323PxyCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVH323PxyCfg& from);
  void MergeFrom(const TNVH323PxyCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional uint32 srv_ip = 2;
  inline bool has_srv_ip() const;
  inline void clear_srv_ip();
  static const int kSrvIpFieldNumber = 2;
  inline ::google::protobuf::uint32 srv_ip() const;
  inline void set_srv_ip(::google::protobuf::uint32 value);

  // optional uint32 srv_port = 3;
  inline bool has_srv_port() const;
  inline void clear_srv_port();
  static const int kSrvPortFieldNumber = 3;
  inline ::google::protobuf::uint32 srv_port() const;
  inline void set_srv_port(::google::protobuf::uint32 value);

  // optional string number = 4;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 4;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:nv.TNVH323PxyCfg)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_srv_ip();
  inline void clear_has_srv_ip();
  inline void set_has_srv_port();
  inline void clear_has_srv_port();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  ::google::protobuf::uint32 srv_ip_;
  ::std::string* number_;
  ::std::string* password_;
  ::google::protobuf::uint32 srv_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVH323PxyCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVH460PxyCfg : public ::google::protobuf::Message {
 public:
  TNVH460PxyCfg();
  virtual ~TNVH460PxyCfg();

  TNVH460PxyCfg(const TNVH460PxyCfg& from);

  inline TNVH460PxyCfg& operator=(const TNVH460PxyCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVH460PxyCfg& default_instance();

  void Swap(TNVH460PxyCfg* other);

  // implements Message ----------------------------------------------

  TNVH460PxyCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVH460PxyCfg& from);
  void MergeFrom(const TNVH460PxyCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional uint32 srv_ip = 2;
  inline bool has_srv_ip() const;
  inline void clear_srv_ip();
  static const int kSrvIpFieldNumber = 2;
  inline ::google::protobuf::uint32 srv_ip() const;
  inline void set_srv_ip(::google::protobuf::uint32 value);

  // optional string number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:nv.TNVH460PxyCfg)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_srv_ip();
  inline void clear_has_srv_ip();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  ::google::protobuf::uint32 srv_ip_;
  ::std::string* number_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVH460PxyCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVSipSrvCfg : public ::google::protobuf::Message {
 public:
  TNVSipSrvCfg();
  virtual ~TNVSipSrvCfg();

  TNVSipSrvCfg(const TNVSipSrvCfg& from);

  inline TNVSipSrvCfg& operator=(const TNVSipSrvCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVSipSrvCfg& default_instance();

  void Swap(TNVSipSrvCfg* other);

  // implements Message ----------------------------------------------

  TNVSipSrvCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVSipSrvCfg& from);
  void MergeFrom(const TNVSipSrvCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional string domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 srv_ip = 3;
  inline bool has_srv_ip() const;
  inline void clear_srv_ip();
  static const int kSrvIpFieldNumber = 3;
  inline ::google::protobuf::uint32 srv_ip() const;
  inline void set_srv_ip(::google::protobuf::uint32 value);

  // optional uint32 srv_port = 4;
  inline bool has_srv_port() const;
  inline void clear_srv_port();
  static const int kSrvPortFieldNumber = 4;
  inline ::google::protobuf::uint32 srv_port() const;
  inline void set_srv_port(::google::protobuf::uint32 value);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional uint32 expire = 6;
  inline bool has_expire() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 6;
  inline ::google::protobuf::uint32 expire() const;
  inline void set_expire(::google::protobuf::uint32 value);

  // optional string ValidateName = 7;
  inline bool has_validatename() const;
  inline void clear_validatename();
  static const int kValidateNameFieldNumber = 7;
  inline const ::std::string& validatename() const;
  inline void set_validatename(const ::std::string& value);
  inline void set_validatename(const char* value);
  inline void set_validatename(const char* value, size_t size);
  inline ::std::string* mutable_validatename();
  inline ::std::string* release_validatename();
  inline void set_allocated_validatename(::std::string* validatename);

  // optional uint32 host_port = 8;
  inline bool has_host_port() const;
  inline void clear_host_port();
  static const int kHostPortFieldNumber = 8;
  inline ::google::protobuf::uint32 host_port() const;
  inline void set_host_port(::google::protobuf::uint32 value);

  // optional string auth_name = 9;
  inline bool has_auth_name() const;
  inline void clear_auth_name();
  static const int kAuthNameFieldNumber = 9;
  inline const ::std::string& auth_name() const;
  inline void set_auth_name(const ::std::string& value);
  inline void set_auth_name(const char* value);
  inline void set_auth_name(const char* value, size_t size);
  inline ::std::string* mutable_auth_name();
  inline ::std::string* release_auth_name();
  inline void set_allocated_auth_name(::std::string* auth_name);

  // @@protoc_insertion_point(class_scope:nv.TNVSipSrvCfg)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_srv_ip();
  inline void clear_has_srv_ip();
  inline void set_has_srv_port();
  inline void clear_has_srv_port();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_expire();
  inline void clear_has_expire();
  inline void set_has_validatename();
  inline void clear_has_validatename();
  inline void set_has_host_port();
  inline void clear_has_host_port();
  inline void set_has_auth_name();
  inline void clear_has_auth_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  bool enable_;
  ::google::protobuf::uint32 srv_ip_;
  ::std::string* password_;
  ::google::protobuf::uint32 srv_port_;
  ::google::protobuf::uint32 expire_;
  ::std::string* validatename_;
  ::std::string* auth_name_;
  ::google::protobuf::uint32 host_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVSipSrvCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtAudInState : public ::google::protobuf::Message {
 public:
  TNVMtAudInState();
  virtual ~TNVMtAudInState();

  TNVMtAudInState(const TNVMtAudInState& from);

  inline TNVMtAudInState& operator=(const TNVMtAudInState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtAudInState& default_instance();

  void Swap(TNVMtAudInState* other);

  // implements Message ----------------------------------------------

  TNVMtAudInState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtAudInState& from);
  void MergeFrom(const TNVMtAudInState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_used = 1;
  inline bool has_is_used() const;
  inline void clear_is_used();
  static const int kIsUsedFieldNumber = 1;
  inline bool is_used() const;
  inline void set_is_used(bool value);

  // optional .nv.EmMtHDAudPortIn audin_type = 2;
  inline bool has_audin_type() const;
  inline void clear_audin_type();
  static const int kAudinTypeFieldNumber = 2;
  inline ::nv::EmMtHDAudPortIn audin_type() const;
  inline void set_audin_type(::nv::EmMtHDAudPortIn value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtAudInState)
 private:
  inline void set_has_is_used();
  inline void clear_has_is_used();
  inline void set_has_audin_type();
  inline void clear_has_audin_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_used_;
  int audin_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtAudInState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtMutiAudInState : public ::google::protobuf::Message {
 public:
  TNVMtMutiAudInState();
  virtual ~TNVMtMutiAudInState();

  TNVMtMutiAudInState(const TNVMtMutiAudInState& from);

  inline TNVMtMutiAudInState& operator=(const TNVMtMutiAudInState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtMutiAudInState& default_instance();

  void Swap(TNVMtMutiAudInState* other);

  // implements Message ----------------------------------------------

  TNVMtMutiAudInState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtMutiAudInState& from);
  void MergeFrom(const TNVMtMutiAudInState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .nv.TNVMtAudInState audin_state = 2;
  inline int audin_state_size() const;
  inline void clear_audin_state();
  static const int kAudinStateFieldNumber = 2;
  inline const ::nv::TNVMtAudInState& audin_state(int index) const;
  inline ::nv::TNVMtAudInState* mutable_audin_state(int index);
  inline ::nv::TNVMtAudInState* add_audin_state();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVMtAudInState >&
      audin_state() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVMtAudInState >*
      mutable_audin_state();

  // @@protoc_insertion_point(class_scope:nv.TNVMtMutiAudInState)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVMtAudInState > audin_state_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtMutiAudInState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtLocalSoundPaly : public ::google::protobuf::Message {
 public:
  TNVMtLocalSoundPaly();
  virtual ~TNVMtLocalSoundPaly();

  TNVMtLocalSoundPaly(const TNVMtLocalSoundPaly& from);

  inline TNVMtLocalSoundPaly& operator=(const TNVMtLocalSoundPaly& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtLocalSoundPaly& default_instance();

  void Swap(TNVMtLocalSoundPaly* other);

  // implements Message ----------------------------------------------

  TNVMtLocalSoundPaly* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtLocalSoundPaly& from);
  void MergeFrom(const TNVMtLocalSoundPaly& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmMtLocalSoundType emtype = 1;
  inline bool has_emtype() const;
  inline void clear_emtype();
  static const int kEmtypeFieldNumber = 1;
  inline ::nv::EmMtLocalSoundType emtype() const;
  inline void set_emtype(::nv::EmMtLocalSoundType value);

  // optional .nv.EmMtLocalSoundIndex emindex = 2;
  inline bool has_emindex() const;
  inline void clear_emindex();
  static const int kEmindexFieldNumber = 2;
  inline ::nv::EmMtLocalSoundIndex emindex() const;
  inline void set_emindex(::nv::EmMtLocalSoundIndex value);

  // optional bool is_play = 3;
  inline bool has_is_play() const;
  inline void clear_is_play();
  static const int kIsPlayFieldNumber = 3;
  inline bool is_play() const;
  inline void set_is_play(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtLocalSoundPaly)
 private:
  inline void set_has_emtype();
  inline void clear_has_emtype();
  inline void set_has_emindex();
  inline void clear_has_emindex();
  inline void set_has_is_play();
  inline void clear_has_is_play();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emtype_;
  int emindex_;
  bool is_play_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtLocalSoundPaly* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtAudioTestCfg : public ::google::protobuf::Message {
 public:
  TNVMtAudioTestCfg();
  virtual ~TNVMtAudioTestCfg();

  TNVMtAudioTestCfg(const TNVMtAudioTestCfg& from);

  inline TNVMtAudioTestCfg& operator=(const TNVMtAudioTestCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtAudioTestCfg& default_instance();

  void Swap(TNVMtAudioTestCfg* other);

  // implements Message ----------------------------------------------

  TNVMtAudioTestCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtAudioTestCfg& from);
  void MergeFrom(const TNVMtAudioTestCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmMtCodecComponent emcomponent = 1;
  inline bool has_emcomponent() const;
  inline void clear_emcomponent();
  static const int kEmcomponentFieldNumber = 1;
  inline ::nv::EmMtCodecComponent emcomponent() const;
  inline void set_emcomponent(::nv::EmMtCodecComponent value);

  // optional .nv.EmCodecComponentIndex emIndex = 2;
  inline bool has_emindex() const;
  inline void clear_emindex();
  static const int kEmIndexFieldNumber = 2;
  inline ::nv::EmCodecComponentIndex emindex() const;
  inline void set_emindex(::nv::EmCodecComponentIndex value);

  // optional bool is_start = 3;
  inline bool has_is_start() const;
  inline void clear_is_start();
  static const int kIsStartFieldNumber = 3;
  inline bool is_start() const;
  inline void set_is_start(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtAudioTestCfg)
 private:
  inline void set_has_emcomponent();
  inline void clear_has_emcomponent();
  inline void set_has_emindex();
  inline void clear_has_emindex();
  inline void set_has_is_start();
  inline void clear_has_is_start();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emcomponent_;
  int emindex_;
  bool is_start_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtAudioTestCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtAudioPower : public ::google::protobuf::Message {
 public:
  TNVMtAudioPower();
  virtual ~TNVMtAudioPower();

  TNVMtAudioPower(const TNVMtAudioPower& from);

  inline TNVMtAudioPower& operator=(const TNVMtAudioPower& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtAudioPower& default_instance();

  void Swap(TNVMtAudioPower* other);

  // implements Message ----------------------------------------------

  TNVMtAudioPower* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtAudioPower& from);
  void MergeFrom(const TNVMtAudioPower& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmMtCodecComponent emcomponent = 1;
  inline bool has_emcomponent() const;
  inline void clear_emcomponent();
  static const int kEmcomponentFieldNumber = 1;
  inline ::nv::EmMtCodecComponent emcomponent() const;
  inline void set_emcomponent(::nv::EmMtCodecComponent value);

  // optional .nv.EmCodecComponentIndex emIndex = 2;
  inline bool has_emindex() const;
  inline void clear_emindex();
  static const int kEmIndexFieldNumber = 2;
  inline ::nv::EmCodecComponentIndex emindex() const;
  inline void set_emindex(::nv::EmCodecComponentIndex value);

  // optional uint32 power = 3;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 3;
  inline ::google::protobuf::uint32 power() const;
  inline void set_power(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtAudioPower)
 private:
  inline void set_has_emcomponent();
  inline void clear_has_emcomponent();
  inline void set_has_emindex();
  inline void clear_has_emindex();
  inline void set_has_power();
  inline void clear_has_power();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emcomponent_;
  int emindex_;
  ::google::protobuf::uint32 power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtAudioPower* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtXAPSvrCfg : public ::google::protobuf::Message {
 public:
  TNVMtXAPSvrCfg();
  virtual ~TNVMtXAPSvrCfg();

  TNVMtXAPSvrCfg(const TNVMtXAPSvrCfg& from);

  inline TNVMtXAPSvrCfg& operator=(const TNVMtXAPSvrCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtXAPSvrCfg& default_instance();

  void Swap(TNVMtXAPSvrCfg* other);

  // implements Message ----------------------------------------------

  TNVMtXAPSvrCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtXAPSvrCfg& from);
  void MergeFrom(const TNVMtXAPSvrCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmMtServerAddrType addr_type = 1;
  inline bool has_addr_type() const;
  inline void clear_addr_type();
  static const int kAddrTypeFieldNumber = 1;
  inline ::nv::EmMtServerAddrType addr_type() const;
  inline void set_addr_type(::nv::EmMtServerAddrType value);

  // optional string alias = 2;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 2;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // optional string domain = 3;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 3;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 dwip = 4;
  inline bool has_dwip() const;
  inline void clear_dwip();
  static const int kDwipFieldNumber = 4;
  inline ::google::protobuf::uint32 dwip() const;
  inline void set_dwip(::google::protobuf::uint32 value);

  // optional bool is_ipsrv = 5;
  inline bool has_is_ipsrv() const;
  inline void clear_is_ipsrv();
  static const int kIsIpsrvFieldNumber = 5;
  inline bool is_ipsrv() const;
  inline void set_is_ipsrv(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtXAPSvrCfg)
 private:
  inline void set_has_addr_type();
  inline void clear_has_addr_type();
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_dwip();
  inline void clear_has_dwip();
  inline void set_has_is_ipsrv();
  inline void clear_has_is_ipsrv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alias_;
  int addr_type_;
  ::google::protobuf::uint32 dwip_;
  ::std::string* domain_;
  bool is_ipsrv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtXAPSvrCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtXAPSvrList : public ::google::protobuf::Message {
 public:
  TNVMtXAPSvrList();
  virtual ~TNVMtXAPSvrList();

  TNVMtXAPSvrList(const TNVMtXAPSvrList& from);

  inline TNVMtXAPSvrList& operator=(const TNVMtXAPSvrList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtXAPSvrList& default_instance();

  void Swap(TNVMtXAPSvrList* other);

  // implements Message ----------------------------------------------

  TNVMtXAPSvrList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtXAPSvrList& from);
  void MergeFrom(const TNVMtXAPSvrList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_auotoselect = 1;
  inline bool has_is_auotoselect() const;
  inline void clear_is_auotoselect();
  static const int kIsAuotoselectFieldNumber = 1;
  inline bool is_auotoselect() const;
  inline void set_is_auotoselect(bool value);

  // optional uint32 cur_index = 2;
  inline bool has_cur_index() const;
  inline void clear_cur_index();
  static const int kCurIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 cur_index() const;
  inline void set_cur_index(::google::protobuf::uint32 value);

  // repeated .nv.TNVMtXAPSvrCfg xapsrv_list = 3;
  inline int xapsrv_list_size() const;
  inline void clear_xapsrv_list();
  static const int kXapsrvListFieldNumber = 3;
  inline const ::nv::TNVMtXAPSvrCfg& xapsrv_list(int index) const;
  inline ::nv::TNVMtXAPSvrCfg* mutable_xapsrv_list(int index);
  inline ::nv::TNVMtXAPSvrCfg* add_xapsrv_list();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVMtXAPSvrCfg >&
      xapsrv_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVMtXAPSvrCfg >*
      mutable_xapsrv_list();

  // optional uint32 list_count = 4;
  inline bool has_list_count() const;
  inline void clear_list_count();
  static const int kListCountFieldNumber = 4;
  inline ::google::protobuf::uint32 list_count() const;
  inline void set_list_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtXAPSvrList)
 private:
  inline void set_has_is_auotoselect();
  inline void clear_has_is_auotoselect();
  inline void set_has_cur_index();
  inline void clear_has_cur_index();
  inline void set_has_list_count();
  inline void clear_has_list_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_auotoselect_;
  ::google::protobuf::uint32 cur_index_;
  ::google::protobuf::RepeatedPtrField< ::nv::TNVMtXAPSvrCfg > xapsrv_list_;
  ::google::protobuf::uint32 list_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtXAPSvrList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtCSUAddr : public ::google::protobuf::Message {
 public:
  TNVMtCSUAddr();
  virtual ~TNVMtCSUAddr();

  TNVMtCSUAddr(const TNVMtCSUAddr& from);

  inline TNVMtCSUAddr& operator=(const TNVMtCSUAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtCSUAddr& default_instance();

  void Swap(TNVMtCSUAddr* other);

  // implements Message ----------------------------------------------

  TNVMtCSUAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtCSUAddr& from);
  void MergeFrom(const TNVMtCSUAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_usedCSU = 1;
  inline bool has_is_usedcsu() const;
  inline void clear_is_usedcsu();
  static const int kIsUsedCSUFieldNumber = 1;
  inline bool is_usedcsu() const;
  inline void set_is_usedcsu(bool value);

  // optional string domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 gk_ip = 3;
  inline bool has_gk_ip() const;
  inline void clear_gk_ip();
  static const int kGkIpFieldNumber = 3;
  inline ::google::protobuf::uint32 gk_ip() const;
  inline void set_gk_ip(::google::protobuf::uint32 value);

  // optional uint32 gk_port = 4;
  inline bool has_gk_port() const;
  inline void clear_gk_port();
  static const int kGkPortFieldNumber = 4;
  inline ::google::protobuf::uint32 gk_port() const;
  inline void set_gk_port(::google::protobuf::uint32 value);

  // optional string number = 5;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 5;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional uint32 time_tolive = 7;
  inline bool has_time_tolive() const;
  inline void clear_time_tolive();
  static const int kTimeToliveFieldNumber = 7;
  inline ::google::protobuf::uint32 time_tolive() const;
  inline void set_time_tolive(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtCSUAddr)
 private:
  inline void set_has_is_usedcsu();
  inline void clear_has_is_usedcsu();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_gk_ip();
  inline void clear_has_gk_ip();
  inline void set_has_gk_port();
  inline void clear_has_gk_port();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_time_tolive();
  inline void clear_has_time_tolive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  bool is_usedcsu_;
  ::google::protobuf::uint32 gk_ip_;
  ::std::string* number_;
  ::google::protobuf::uint32 gk_port_;
  ::google::protobuf::uint32 time_tolive_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtCSUAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtAccountManager : public ::google::protobuf::Message {
 public:
  TNVMtAccountManager();
  virtual ~TNVMtAccountManager();

  TNVMtAccountManager(const TNVMtAccountManager& from);

  inline TNVMtAccountManager& operator=(const TNVMtAccountManager& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtAccountManager& default_instance();

  void Swap(TNVMtAccountManager* other);

  // implements Message ----------------------------------------------

  TNVMtAccountManager* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtAccountManager& from);
  void MergeFrom(const TNVMtAccountManager& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string mobile_num = 3;
  inline bool has_mobile_num() const;
  inline void clear_mobile_num();
  static const int kMobileNumFieldNumber = 3;
  inline const ::std::string& mobile_num() const;
  inline void set_mobile_num(const ::std::string& value);
  inline void set_mobile_num(const char* value);
  inline void set_mobile_num(const char* value, size_t size);
  inline ::std::string* mutable_mobile_num();
  inline ::std::string* release_mobile_num();
  inline void set_allocated_mobile_num(::std::string* mobile_num);

  // optional string ext_num = 4;
  inline bool has_ext_num() const;
  inline void clear_ext_num();
  static const int kExtNumFieldNumber = 4;
  inline const ::std::string& ext_num() const;
  inline void set_ext_num(const ::std::string& value);
  inline void set_ext_num(const char* value);
  inline void set_ext_num(const char* value, size_t size);
  inline ::std::string* mutable_ext_num();
  inline ::std::string* release_ext_num();
  inline void set_allocated_ext_num(::std::string* ext_num);

  // optional string seat = 5;
  inline bool has_seat() const;
  inline void clear_seat();
  static const int kSeatFieldNumber = 5;
  inline const ::std::string& seat() const;
  inline void set_seat(const ::std::string& value);
  inline void set_seat(const char* value);
  inline void set_seat(const char* value, size_t size);
  inline ::std::string* mutable_seat();
  inline ::std::string* release_seat();
  inline void set_allocated_seat(::std::string* seat);

  // optional string brief = 6;
  inline bool has_brief() const;
  inline void clear_brief();
  static const int kBriefFieldNumber = 6;
  inline const ::std::string& brief() const;
  inline void set_brief(const ::std::string& value);
  inline void set_brief(const char* value);
  inline void set_brief(const char* value, size_t size);
  inline ::std::string* mutable_brief();
  inline ::std::string* release_brief();
  inline void set_allocated_brief(::std::string* brief);

  // optional string positon = 7;
  inline bool has_positon() const;
  inline void clear_positon();
  static const int kPositonFieldNumber = 7;
  inline const ::std::string& positon() const;
  inline void set_positon(const ::std::string& value);
  inline void set_positon(const char* value);
  inline void set_positon(const char* value, size_t size);
  inline ::std::string* mutable_positon();
  inline ::std::string* release_positon();
  inline void set_allocated_positon(::std::string* positon);

  // optional string name = 8;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 8;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string api_addr = 9;
  inline bool has_api_addr() const;
  inline void clear_api_addr();
  static const int kApiAddrFieldNumber = 9;
  inline const ::std::string& api_addr() const;
  inline void set_api_addr(const ::std::string& value);
  inline void set_api_addr(const char* value);
  inline void set_api_addr(const char* value, size_t size);
  inline ::std::string* mutable_api_addr();
  inline ::std::string* release_api_addr();
  inline void set_allocated_api_addr(::std::string* api_addr);

  // optional string email = 10;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 10;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional bool is_male = 11;
  inline bool has_is_male() const;
  inline void clear_is_male();
  static const int kIsMaleFieldNumber = 11;
  inline bool is_male() const;
  inline void set_is_male(bool value);

  // optional bool is_adding = 12;
  inline bool has_is_adding() const;
  inline void clear_is_adding();
  static const int kIsAddingFieldNumber = 12;
  inline bool is_adding() const;
  inline void set_is_adding(bool value);

  // optional uint32 bit_mask = 13;
  inline bool has_bit_mask() const;
  inline void clear_bit_mask();
  static const int kBitMaskFieldNumber = 13;
  inline ::google::protobuf::uint32 bit_mask() const;
  inline void set_bit_mask(::google::protobuf::uint32 value);

  // optional uint32 context_id = 14;
  inline bool has_context_id() const;
  inline void clear_context_id();
  static const int kContextIdFieldNumber = 14;
  inline ::google::protobuf::uint32 context_id() const;
  inline void set_context_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtAccountManager)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_mobile_num();
  inline void clear_has_mobile_num();
  inline void set_has_ext_num();
  inline void clear_has_ext_num();
  inline void set_has_seat();
  inline void clear_has_seat();
  inline void set_has_brief();
  inline void clear_has_brief();
  inline void set_has_positon();
  inline void clear_has_positon();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_api_addr();
  inline void clear_has_api_addr();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_is_male();
  inline void clear_has_is_male();
  inline void set_has_is_adding();
  inline void clear_has_is_adding();
  inline void set_has_bit_mask();
  inline void clear_has_bit_mask();
  inline void set_has_context_id();
  inline void clear_has_context_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::std::string* password_;
  ::std::string* mobile_num_;
  ::std::string* ext_num_;
  ::std::string* seat_;
  ::std::string* brief_;
  ::std::string* positon_;
  ::std::string* name_;
  ::std::string* api_addr_;
  ::std::string* email_;
  bool is_male_;
  bool is_adding_;
  ::google::protobuf::uint32 bit_mask_;
  ::google::protobuf::uint32 context_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtAccountManager* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtApsLoginErrcode : public ::google::protobuf::Message {
 public:
  TNVMtApsLoginErrcode();
  virtual ~TNVMtApsLoginErrcode();

  TNVMtApsLoginErrcode(const TNVMtApsLoginErrcode& from);

  inline TNVMtApsLoginErrcode& operator=(const TNVMtApsLoginErrcode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtApsLoginErrcode& default_instance();

  void Swap(TNVMtApsLoginErrcode* other);

  // implements Message ----------------------------------------------

  TNVMtApsLoginErrcode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtApsLoginErrcode& from);
  void MergeFrom(const TNVMtApsLoginErrcode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_suc = 1;
  inline bool has_is_suc() const;
  inline void clear_is_suc();
  static const int kIsSucFieldNumber = 1;
  inline bool is_suc() const;
  inline void set_is_suc(bool value);

  // optional uint32 http_errcode = 2;
  inline bool has_http_errcode() const;
  inline void clear_http_errcode();
  static const int kHttpErrcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 http_errcode() const;
  inline void set_http_errcode(::google::protobuf::uint32 value);

  // optional uint32 aps_errcode = 3;
  inline bool has_aps_errcode() const;
  inline void clear_aps_errcode();
  static const int kApsErrcodeFieldNumber = 3;
  inline ::google::protobuf::uint32 aps_errcode() const;
  inline void set_aps_errcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtApsLoginErrcode)
 private:
  inline void set_has_is_suc();
  inline void clear_has_is_suc();
  inline void set_has_http_errcode();
  inline void clear_has_http_errcode();
  inline void set_has_aps_errcode();
  inline void clear_has_aps_errcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_suc_;
  ::google::protobuf::uint32 http_errcode_;
  ::google::protobuf::uint32 aps_errcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtApsLoginErrcode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVForceSetH323Stack : public ::google::protobuf::Message {
 public:
  TNVForceSetH323Stack();
  virtual ~TNVForceSetH323Stack();

  TNVForceSetH323Stack(const TNVForceSetH323Stack& from);

  inline TNVForceSetH323Stack& operator=(const TNVForceSetH323Stack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVForceSetH323Stack& default_instance();

  void Swap(TNVForceSetH323Stack* other);

  // implements Message ----------------------------------------------

  TNVForceSetH323Stack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVForceSetH323Stack& from);
  void MergeFrom(const TNVForceSetH323Stack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional bool stand = 2;
  inline bool has_stand() const;
  inline void clear_stand();
  static const int kStandFieldNumber = 2;
  inline bool stand() const;
  inline void set_stand(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVForceSetH323Stack)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_stand();
  inline void clear_has_stand();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  bool stand_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVForceSetH323Stack* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtAudInPort : public ::google::protobuf::Message {
 public:
  TNVMtAudInPort();
  virtual ~TNVMtAudInPort();

  TNVMtAudInPort(const TNVMtAudInPort& from);

  inline TNVMtAudInPort& operator=(const TNVMtAudInPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtAudInPort& default_instance();

  void Swap(TNVMtAudInPort* other);

  // implements Message ----------------------------------------------

  TNVMtAudInPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtAudInPort& from);
  void MergeFrom(const TNVMtAudInPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.EmMtHDAudPortIn audinport_list = 1;
  inline int audinport_list_size() const;
  inline void clear_audinport_list();
  static const int kAudinportListFieldNumber = 1;
  inline ::nv::EmMtHDAudPortIn audinport_list(int index) const;
  inline void set_audinport_list(int index, ::nv::EmMtHDAudPortIn value);
  inline void add_audinport_list(::nv::EmMtHDAudPortIn value);
  inline const ::google::protobuf::RepeatedField<int>& audinport_list() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_audinport_list();

  // optional uint32 port_count = 2;
  inline bool has_port_count() const;
  inline void clear_port_count();
  static const int kPortCountFieldNumber = 2;
  inline ::google::protobuf::uint32 port_count() const;
  inline void set_port_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtAudInPort)
 private:
  inline void set_has_port_count();
  inline void clear_has_port_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> audinport_list_;
  ::google::protobuf::uint32 port_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtAudInPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtAudInPortList : public ::google::protobuf::Message {
 public:
  TNVMtAudInPortList();
  virtual ~TNVMtAudInPortList();

  TNVMtAudInPortList(const TNVMtAudInPortList& from);

  inline TNVMtAudInPortList& operator=(const TNVMtAudInPortList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtAudInPortList& default_instance();

  void Swap(TNVMtAudInPortList* other);

  // implements Message ----------------------------------------------

  TNVMtAudInPortList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtAudInPortList& from);
  void MergeFrom(const TNVMtAudInPortList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.TNVMtAudInPort primic_list = 1;
  inline bool has_primic_list() const;
  inline void clear_primic_list();
  static const int kPrimicListFieldNumber = 1;
  inline const ::nv::TNVMtAudInPort& primic_list() const;
  inline ::nv::TNVMtAudInPort* mutable_primic_list();
  inline ::nv::TNVMtAudInPort* release_primic_list();
  inline void set_allocated_primic_list(::nv::TNVMtAudInPort* primic_list);

  // optional .nv.TNVMtAudInPort linein_list = 2;
  inline bool has_linein_list() const;
  inline void clear_linein_list();
  static const int kLineinListFieldNumber = 2;
  inline const ::nv::TNVMtAudInPort& linein_list() const;
  inline ::nv::TNVMtAudInPort* mutable_linein_list();
  inline ::nv::TNVMtAudInPort* release_linein_list();
  inline void set_allocated_linein_list(::nv::TNVMtAudInPort* linein_list);

  // optional bool is_auxmic = 3;
  inline bool has_is_auxmic() const;
  inline void clear_is_auxmic();
  static const int kIsAuxmicFieldNumber = 3;
  inline bool is_auxmic() const;
  inline void set_is_auxmic(bool value);

  // optional bool is_linemic = 4;
  inline bool has_is_linemic() const;
  inline void clear_is_linemic();
  static const int kIsLinemicFieldNumber = 4;
  inline bool is_linemic() const;
  inline void set_is_linemic(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtAudInPortList)
 private:
  inline void set_has_primic_list();
  inline void clear_has_primic_list();
  inline void set_has_linein_list();
  inline void clear_has_linein_list();
  inline void set_has_is_auxmic();
  inline void clear_has_is_auxmic();
  inline void set_has_is_linemic();
  inline void clear_has_is_linemic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::nv::TNVMtAudInPort* primic_list_;
  ::nv::TNVMtAudInPort* linein_list_;
  bool is_auxmic_;
  bool is_linemic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtAudInPortList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtCallBitRate : public ::google::protobuf::Message {
 public:
  TNVMtCallBitRate();
  virtual ~TNVMtCallBitRate();

  TNVMtCallBitRate(const TNVMtCallBitRate& from);

  inline TNVMtCallBitRate& operator=(const TNVMtCallBitRate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtCallBitRate& default_instance();

  void Swap(TNVMtCallBitRate* other);

  // implements Message ----------------------------------------------

  TNVMtCallBitRate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtCallBitRate& from);
  void MergeFrom(const TNVMtCallBitRate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rate_count = 1;
  inline bool has_rate_count() const;
  inline void clear_rate_count();
  static const int kRateCountFieldNumber = 1;
  inline ::google::protobuf::uint32 rate_count() const;
  inline void set_rate_count(::google::protobuf::uint32 value);

  // repeated uint32 rate_list = 2;
  inline int rate_list_size() const;
  inline void clear_rate_list();
  static const int kRateListFieldNumber = 2;
  inline ::google::protobuf::uint32 rate_list(int index) const;
  inline void set_rate_list(int index, ::google::protobuf::uint32 value);
  inline void add_rate_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      rate_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_rate_list();

  // @@protoc_insertion_point(class_scope:nv.TNVMtCallBitRate)
 private:
  inline void set_has_rate_count();
  inline void clear_has_rate_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > rate_list_;
  ::google::protobuf::uint32 rate_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtCallBitRate* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtSvrState : public ::google::protobuf::Message {
 public:
  TNVMtSvrState();
  virtual ~TNVMtSvrState();

  TNVMtSvrState(const TNVMtSvrState& from);

  inline TNVMtSvrState& operator=(const TNVMtSvrState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtSvrState& default_instance();

  void Swap(TNVMtSvrState* other);

  // implements Message ----------------------------------------------

  TNVMtSvrState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtSvrState& from);
  void MergeFrom(const TNVMtSvrState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmMtServerType srv_type = 1;
  inline bool has_srv_type() const;
  inline void clear_srv_type();
  static const int kSrvTypeFieldNumber = 1;
  inline ::nv::EmMtServerType srv_type() const;
  inline void set_srv_type(::nv::EmMtServerType value);

  // optional .nv.EmMtServerState srv_state = 2;
  inline bool has_srv_state() const;
  inline void clear_srv_state();
  static const int kSrvStateFieldNumber = 2;
  inline ::nv::EmMtServerState srv_state() const;
  inline void set_srv_state(::nv::EmMtServerState value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtSvrState)
 private:
  inline void set_has_srv_type();
  inline void clear_has_srv_type();
  inline void set_has_srv_state();
  inline void clear_has_srv_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int srv_type_;
  int srv_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtSvrState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtSvrStateList : public ::google::protobuf::Message {
 public:
  TNVMtSvrStateList();
  virtual ~TNVMtSvrStateList();

  TNVMtSvrStateList(const TNVMtSvrStateList& from);

  inline TNVMtSvrStateList& operator=(const TNVMtSvrStateList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtSvrStateList& default_instance();

  void Swap(TNVMtSvrStateList* other);

  // implements Message ----------------------------------------------

  TNVMtSvrStateList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtSvrStateList& from);
  void MergeFrom(const TNVMtSvrStateList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVMtSvrState srv_state = 1;
  inline int srv_state_size() const;
  inline void clear_srv_state();
  static const int kSrvStateFieldNumber = 1;
  inline const ::nv::TNVMtSvrState& srv_state(int index) const;
  inline ::nv::TNVMtSvrState* mutable_srv_state(int index);
  inline ::nv::TNVMtSvrState* add_srv_state();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVMtSvrState >&
      srv_state() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVMtSvrState >*
      mutable_srv_state();

  // optional uint32 srv_count = 2;
  inline bool has_srv_count() const;
  inline void clear_srv_count();
  static const int kSrvCountFieldNumber = 2;
  inline ::google::protobuf::uint32 srv_count() const;
  inline void set_srv_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtSvrStateList)
 private:
  inline void set_has_srv_count();
  inline void clear_has_srv_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVMtSvrState > srv_state_;
  ::google::protobuf::uint32 srv_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtSvrStateList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtMicStatus : public ::google::protobuf::Message {
 public:
  TNVMtMicStatus();
  virtual ~TNVMtMicStatus();

  TNVMtMicStatus(const TNVMtMicStatus& from);

  inline TNVMtMicStatus& operator=(const TNVMtMicStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtMicStatus& default_instance();

  void Swap(TNVMtMicStatus* other);

  // implements Message ----------------------------------------------

  TNVMtMicStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtMicStatus& from);
  void MergeFrom(const TNVMtMicStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 mic_id = 1;
  inline bool has_mic_id() const;
  inline void clear_mic_id();
  static const int kMicIdFieldNumber = 1;
  inline ::google::protobuf::uint32 mic_id() const;
  inline void set_mic_id(::google::protobuf::uint32 value);

  // optional uint32 mic_stat = 2;
  inline bool has_mic_stat() const;
  inline void clear_mic_stat();
  static const int kMicStatFieldNumber = 2;
  inline ::google::protobuf::uint32 mic_stat() const;
  inline void set_mic_stat(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtMicStatus)
 private:
  inline void set_has_mic_id();
  inline void clear_has_mic_id();
  inline void set_has_mic_stat();
  inline void clear_has_mic_stat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 mic_id_;
  ::google::protobuf::uint32 mic_stat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtMicStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtAllMicStatus : public ::google::protobuf::Message {
 public:
  TNVMtAllMicStatus();
  virtual ~TNVMtAllMicStatus();

  TNVMtAllMicStatus(const TNVMtAllMicStatus& from);

  inline TNVMtAllMicStatus& operator=(const TNVMtAllMicStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtAllMicStatus& default_instance();

  void Swap(TNVMtAllMicStatus* other);

  // implements Message ----------------------------------------------

  TNVMtAllMicStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtAllMicStatus& from);
  void MergeFrom(const TNVMtAllMicStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVMtMicStatus mic_status = 1;
  inline int mic_status_size() const;
  inline void clear_mic_status();
  static const int kMicStatusFieldNumber = 1;
  inline const ::nv::TNVMtMicStatus& mic_status(int index) const;
  inline ::nv::TNVMtMicStatus* mutable_mic_status(int index);
  inline ::nv::TNVMtMicStatus* add_mic_status();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVMtMicStatus >&
      mic_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVMtMicStatus >*
      mutable_mic_status();

  // optional uint32 mic_cnt = 2;
  inline bool has_mic_cnt() const;
  inline void clear_mic_cnt();
  static const int kMicCntFieldNumber = 2;
  inline ::google::protobuf::uint32 mic_cnt() const;
  inline void set_mic_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtAllMicStatus)
 private:
  inline void set_has_mic_cnt();
  inline void clear_has_mic_cnt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVMtMicStatus > mic_status_;
  ::google::protobuf::uint32 mic_cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtAllMicStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtHDVidInPort : public ::google::protobuf::Message {
 public:
  TNVMtHDVidInPort();
  virtual ~TNVMtHDVidInPort();

  TNVMtHDVidInPort(const TNVMtHDVidInPort& from);

  inline TNVMtHDVidInPort& operator=(const TNVMtHDVidInPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtHDVidInPort& default_instance();

  void Swap(TNVMtHDVidInPort* other);

  // implements Message ----------------------------------------------

  TNVMtHDVidInPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtHDVidInPort& from);
  void MergeFrom(const TNVMtHDVidInPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmMtHDVideoType vid_type = 1;
  inline bool has_vid_type() const;
  inline void clear_vid_type();
  static const int kVidTypeFieldNumber = 1;
  inline ::nv::EmMtHDVideoType vid_type() const;
  inline void set_vid_type(::nv::EmMtHDVideoType value);

  // optional .nv.EmNvVideoPort_Api vid_port = 2;
  inline bool has_vid_port() const;
  inline void clear_vid_port();
  static const int kVidPortFieldNumber = 2;
  inline ::nv::EmNvVideoPort_Api vid_port() const;
  inline void set_vid_port(::nv::EmNvVideoPort_Api value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtHDVidInPort)
 private:
  inline void set_has_vid_type();
  inline void clear_has_vid_type();
  inline void set_has_vid_port();
  inline void clear_has_vid_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int vid_type_;
  int vid_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVMtHDVidInPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVImixAllVerInfo : public ::google::protobuf::Message {
 public:
  TNVImixAllVerInfo();
  virtual ~TNVImixAllVerInfo();

  TNVImixAllVerInfo(const TNVImixAllVerInfo& from);

  inline TNVImixAllVerInfo& operator=(const TNVImixAllVerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVImixAllVerInfo& default_instance();

  void Swap(TNVImixAllVerInfo* other);

  // implements Message ----------------------------------------------

  TNVImixAllVerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVImixAllVerInfo& from);
  void MergeFrom(const TNVImixAllVerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string imix_ver = 1;
  inline bool has_imix_ver() const;
  inline void clear_imix_ver();
  static const int kImixVerFieldNumber = 1;
  inline const ::std::string& imix_ver() const;
  inline void set_imix_ver(const ::std::string& value);
  inline void set_imix_ver(const char* value);
  inline void set_imix_ver(const char* value, size_t size);
  inline ::std::string* mutable_imix_ver();
  inline ::std::string* release_imix_ver();
  inline void set_allocated_imix_ver(::std::string* imix_ver);

  // optional string power_ver = 2;
  inline bool has_power_ver() const;
  inline void clear_power_ver();
  static const int kPowerVerFieldNumber = 2;
  inline const ::std::string& power_ver() const;
  inline void set_power_ver(const ::std::string& value);
  inline void set_power_ver(const char* value);
  inline void set_power_ver(const char* value, size_t size);
  inline ::std::string* mutable_power_ver();
  inline ::std::string* release_power_ver();
  inline void set_allocated_power_ver(::std::string* power_ver);

  // optional string router_ver = 3;
  inline bool has_router_ver() const;
  inline void clear_router_ver();
  static const int kRouterVerFieldNumber = 3;
  inline const ::std::string& router_ver() const;
  inline void set_router_ver(const ::std::string& value);
  inline void set_router_ver(const char* value);
  inline void set_router_ver(const char* value, size_t size);
  inline ::std::string* mutable_router_ver();
  inline ::std::string* release_router_ver();
  inline void set_allocated_router_ver(::std::string* router_ver);

  // optional string qk_ver = 4;
  inline bool has_qk_ver() const;
  inline void clear_qk_ver();
  static const int kQkVerFieldNumber = 4;
  inline const ::std::string& qk_ver() const;
  inline void set_qk_ver(const ::std::string& value);
  inline void set_qk_ver(const char* value);
  inline void set_qk_ver(const char* value, size_t size);
  inline ::std::string* mutable_qk_ver();
  inline ::std::string* release_qk_ver();
  inline void set_allocated_qk_ver(::std::string* qk_ver);

  // @@protoc_insertion_point(class_scope:nv.TNVImixAllVerInfo)
 private:
  inline void set_has_imix_ver();
  inline void clear_has_imix_ver();
  inline void set_has_power_ver();
  inline void clear_has_power_ver();
  inline void set_has_router_ver();
  inline void clear_has_router_ver();
  inline void set_has_qk_ver();
  inline void clear_has_qk_ver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* imix_ver_;
  ::std::string* power_ver_;
  ::std::string* router_ver_;
  ::std::string* qk_ver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVImixAllVerInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVSusUpgradeModule : public ::google::protobuf::Message {
 public:
  TNVSusUpgradeModule();
  virtual ~TNVSusUpgradeModule();

  TNVSusUpgradeModule(const TNVSusUpgradeModule& from);

  inline TNVSusUpgradeModule& operator=(const TNVSusUpgradeModule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVSusUpgradeModule& default_instance();

  void Swap(TNVSusUpgradeModule* other);

  // implements Message ----------------------------------------------

  TNVSusUpgradeModule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVSusUpgradeModule& from);
  void MergeFrom(const TNVSusUpgradeModule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.EmSusUpgradeModule upgrade_module = 1;
  inline int upgrade_module_size() const;
  inline void clear_upgrade_module();
  static const int kUpgradeModuleFieldNumber = 1;
  inline ::nv::EmSusUpgradeModule upgrade_module(int index) const;
  inline void set_upgrade_module(int index, ::nv::EmSusUpgradeModule value);
  inline void add_upgrade_module(::nv::EmSusUpgradeModule value);
  inline const ::google::protobuf::RepeatedField<int>& upgrade_module() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_upgrade_module();

  // optional uint32 module_size = 2;
  inline bool has_module_size() const;
  inline void clear_module_size();
  static const int kModuleSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 module_size() const;
  inline void set_module_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVSusUpgradeModule)
 private:
  inline void set_has_module_size();
  inline void clear_has_module_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> upgrade_module_;
  ::google::protobuf::uint32 module_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructmt_2eproto();
  friend void protobuf_AssignDesc_nvstructmt_2eproto();
  friend void protobuf_ShutdownFile_nvstructmt_2eproto();

  void InitAsDefaultInstance();
  static TNVSusUpgradeModule* default_instance_;
};
// ===================================================================


// ===================================================================

// TNVApsLoginParam

// optional string user_name = 1;
inline bool TNVApsLoginParam::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVApsLoginParam::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVApsLoginParam::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVApsLoginParam::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TNVApsLoginParam::user_name() const {
  return *user_name_;
}
inline void TNVApsLoginParam::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVApsLoginParam::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVApsLoginParam::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVApsLoginParam::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TNVApsLoginParam::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVApsLoginParam::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool TNVApsLoginParam::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVApsLoginParam::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVApsLoginParam::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVApsLoginParam::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TNVApsLoginParam::password() const {
  return *password_;
}
inline void TNVApsLoginParam::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVApsLoginParam::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVApsLoginParam::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVApsLoginParam::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TNVApsLoginParam::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVApsLoginParam::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string software_ver = 3;
inline bool TNVApsLoginParam::has_software_ver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVApsLoginParam::set_has_software_ver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVApsLoginParam::clear_has_software_ver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVApsLoginParam::clear_software_ver() {
  if (software_ver_ != &::google::protobuf::internal::kEmptyString) {
    software_ver_->clear();
  }
  clear_has_software_ver();
}
inline const ::std::string& TNVApsLoginParam::software_ver() const {
  return *software_ver_;
}
inline void TNVApsLoginParam::set_software_ver(const ::std::string& value) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(value);
}
inline void TNVApsLoginParam::set_software_ver(const char* value) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(value);
}
inline void TNVApsLoginParam::set_software_ver(const char* value, size_t size) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVApsLoginParam::mutable_software_ver() {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  return software_ver_;
}
inline ::std::string* TNVApsLoginParam::release_software_ver() {
  clear_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_ver_;
    software_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVApsLoginParam::set_allocated_software_ver(::std::string* software_ver) {
  if (software_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete software_ver_;
  }
  if (software_ver) {
    set_has_software_ver();
    software_ver_ = software_ver;
  } else {
    clear_has_software_ver();
    software_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string model_name = 4;
inline bool TNVApsLoginParam::has_model_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVApsLoginParam::set_has_model_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVApsLoginParam::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVApsLoginParam::clear_model_name() {
  if (model_name_ != &::google::protobuf::internal::kEmptyString) {
    model_name_->clear();
  }
  clear_has_model_name();
}
inline const ::std::string& TNVApsLoginParam::model_name() const {
  return *model_name_;
}
inline void TNVApsLoginParam::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void TNVApsLoginParam::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void TNVApsLoginParam::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVApsLoginParam::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  return model_name_;
}
inline ::std::string* TNVApsLoginParam::release_model_name() {
  clear_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVApsLoginParam::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != &::google::protobuf::internal::kEmptyString) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string oem_info = 5;
inline bool TNVApsLoginParam::has_oem_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVApsLoginParam::set_has_oem_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVApsLoginParam::clear_has_oem_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVApsLoginParam::clear_oem_info() {
  if (oem_info_ != &::google::protobuf::internal::kEmptyString) {
    oem_info_->clear();
  }
  clear_has_oem_info();
}
inline const ::std::string& TNVApsLoginParam::oem_info() const {
  return *oem_info_;
}
inline void TNVApsLoginParam::set_oem_info(const ::std::string& value) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(value);
}
inline void TNVApsLoginParam::set_oem_info(const char* value) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(value);
}
inline void TNVApsLoginParam::set_oem_info(const char* value, size_t size) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVApsLoginParam::mutable_oem_info() {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  return oem_info_;
}
inline ::std::string* TNVApsLoginParam::release_oem_info() {
  clear_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oem_info_;
    oem_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVApsLoginParam::set_allocated_oem_info(::std::string* oem_info) {
  if (oem_info_ != &::google::protobuf::internal::kEmptyString) {
    delete oem_info_;
  }
  if (oem_info) {
    set_has_oem_info();
    oem_info_ = oem_info;
  } else {
    clear_has_oem_info();
    oem_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string md5_password = 6;
inline bool TNVApsLoginParam::has_md5_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVApsLoginParam::set_has_md5_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVApsLoginParam::clear_has_md5_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVApsLoginParam::clear_md5_password() {
  if (md5_password_ != &::google::protobuf::internal::kEmptyString) {
    md5_password_->clear();
  }
  clear_has_md5_password();
}
inline const ::std::string& TNVApsLoginParam::md5_password() const {
  return *md5_password_;
}
inline void TNVApsLoginParam::set_md5_password(const ::std::string& value) {
  set_has_md5_password();
  if (md5_password_ == &::google::protobuf::internal::kEmptyString) {
    md5_password_ = new ::std::string;
  }
  md5_password_->assign(value);
}
inline void TNVApsLoginParam::set_md5_password(const char* value) {
  set_has_md5_password();
  if (md5_password_ == &::google::protobuf::internal::kEmptyString) {
    md5_password_ = new ::std::string;
  }
  md5_password_->assign(value);
}
inline void TNVApsLoginParam::set_md5_password(const char* value, size_t size) {
  set_has_md5_password();
  if (md5_password_ == &::google::protobuf::internal::kEmptyString) {
    md5_password_ = new ::std::string;
  }
  md5_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVApsLoginParam::mutable_md5_password() {
  set_has_md5_password();
  if (md5_password_ == &::google::protobuf::internal::kEmptyString) {
    md5_password_ = new ::std::string;
  }
  return md5_password_;
}
inline ::std::string* TNVApsLoginParam::release_md5_password() {
  clear_has_md5_password();
  if (md5_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md5_password_;
    md5_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVApsLoginParam::set_allocated_md5_password(::std::string* md5_password) {
  if (md5_password_ != &::google::protobuf::internal::kEmptyString) {
    delete md5_password_;
  }
  if (md5_password) {
    set_has_md5_password();
    md5_password_ = md5_password;
  } else {
    clear_has_md5_password();
    md5_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVH323PxyCfg

// optional bool enable = 1;
inline bool TNVH323PxyCfg::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVH323PxyCfg::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVH323PxyCfg::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVH323PxyCfg::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TNVH323PxyCfg::enable() const {
  return enable_;
}
inline void TNVH323PxyCfg::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional uint32 srv_ip = 2;
inline bool TNVH323PxyCfg::has_srv_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVH323PxyCfg::set_has_srv_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVH323PxyCfg::clear_has_srv_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVH323PxyCfg::clear_srv_ip() {
  srv_ip_ = 0u;
  clear_has_srv_ip();
}
inline ::google::protobuf::uint32 TNVH323PxyCfg::srv_ip() const {
  return srv_ip_;
}
inline void TNVH323PxyCfg::set_srv_ip(::google::protobuf::uint32 value) {
  set_has_srv_ip();
  srv_ip_ = value;
}

// optional uint32 srv_port = 3;
inline bool TNVH323PxyCfg::has_srv_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVH323PxyCfg::set_has_srv_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVH323PxyCfg::clear_has_srv_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVH323PxyCfg::clear_srv_port() {
  srv_port_ = 0u;
  clear_has_srv_port();
}
inline ::google::protobuf::uint32 TNVH323PxyCfg::srv_port() const {
  return srv_port_;
}
inline void TNVH323PxyCfg::set_srv_port(::google::protobuf::uint32 value) {
  set_has_srv_port();
  srv_port_ = value;
}

// optional string number = 4;
inline bool TNVH323PxyCfg::has_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVH323PxyCfg::set_has_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVH323PxyCfg::clear_has_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVH323PxyCfg::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& TNVH323PxyCfg::number() const {
  return *number_;
}
inline void TNVH323PxyCfg::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TNVH323PxyCfg::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TNVH323PxyCfg::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVH323PxyCfg::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* TNVH323PxyCfg::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVH323PxyCfg::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 5;
inline bool TNVH323PxyCfg::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVH323PxyCfg::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVH323PxyCfg::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVH323PxyCfg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TNVH323PxyCfg::password() const {
  return *password_;
}
inline void TNVH323PxyCfg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVH323PxyCfg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVH323PxyCfg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVH323PxyCfg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TNVH323PxyCfg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVH323PxyCfg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVH460PxyCfg

// optional bool enable = 1;
inline bool TNVH460PxyCfg::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVH460PxyCfg::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVH460PxyCfg::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVH460PxyCfg::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TNVH460PxyCfg::enable() const {
  return enable_;
}
inline void TNVH460PxyCfg::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional uint32 srv_ip = 2;
inline bool TNVH460PxyCfg::has_srv_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVH460PxyCfg::set_has_srv_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVH460PxyCfg::clear_has_srv_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVH460PxyCfg::clear_srv_ip() {
  srv_ip_ = 0u;
  clear_has_srv_ip();
}
inline ::google::protobuf::uint32 TNVH460PxyCfg::srv_ip() const {
  return srv_ip_;
}
inline void TNVH460PxyCfg::set_srv_ip(::google::protobuf::uint32 value) {
  set_has_srv_ip();
  srv_ip_ = value;
}

// optional string number = 3;
inline bool TNVH460PxyCfg::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVH460PxyCfg::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVH460PxyCfg::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVH460PxyCfg::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& TNVH460PxyCfg::number() const {
  return *number_;
}
inline void TNVH460PxyCfg::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TNVH460PxyCfg::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TNVH460PxyCfg::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVH460PxyCfg::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* TNVH460PxyCfg::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVH460PxyCfg::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 4;
inline bool TNVH460PxyCfg::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVH460PxyCfg::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVH460PxyCfg::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVH460PxyCfg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TNVH460PxyCfg::password() const {
  return *password_;
}
inline void TNVH460PxyCfg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVH460PxyCfg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVH460PxyCfg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVH460PxyCfg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TNVH460PxyCfg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVH460PxyCfg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVSipSrvCfg

// optional bool enable = 1;
inline bool TNVSipSrvCfg::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVSipSrvCfg::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVSipSrvCfg::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVSipSrvCfg::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TNVSipSrvCfg::enable() const {
  return enable_;
}
inline void TNVSipSrvCfg::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional string domain = 2;
inline bool TNVSipSrvCfg::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVSipSrvCfg::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVSipSrvCfg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVSipSrvCfg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TNVSipSrvCfg::domain() const {
  return *domain_;
}
inline void TNVSipSrvCfg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVSipSrvCfg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVSipSrvCfg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSipSrvCfg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TNVSipSrvCfg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVSipSrvCfg::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 srv_ip = 3;
inline bool TNVSipSrvCfg::has_srv_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVSipSrvCfg::set_has_srv_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVSipSrvCfg::clear_has_srv_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVSipSrvCfg::clear_srv_ip() {
  srv_ip_ = 0u;
  clear_has_srv_ip();
}
inline ::google::protobuf::uint32 TNVSipSrvCfg::srv_ip() const {
  return srv_ip_;
}
inline void TNVSipSrvCfg::set_srv_ip(::google::protobuf::uint32 value) {
  set_has_srv_ip();
  srv_ip_ = value;
}

// optional uint32 srv_port = 4;
inline bool TNVSipSrvCfg::has_srv_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVSipSrvCfg::set_has_srv_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVSipSrvCfg::clear_has_srv_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVSipSrvCfg::clear_srv_port() {
  srv_port_ = 0u;
  clear_has_srv_port();
}
inline ::google::protobuf::uint32 TNVSipSrvCfg::srv_port() const {
  return srv_port_;
}
inline void TNVSipSrvCfg::set_srv_port(::google::protobuf::uint32 value) {
  set_has_srv_port();
  srv_port_ = value;
}

// optional string password = 5;
inline bool TNVSipSrvCfg::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVSipSrvCfg::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVSipSrvCfg::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVSipSrvCfg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TNVSipSrvCfg::password() const {
  return *password_;
}
inline void TNVSipSrvCfg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVSipSrvCfg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVSipSrvCfg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSipSrvCfg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TNVSipSrvCfg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVSipSrvCfg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 expire = 6;
inline bool TNVSipSrvCfg::has_expire() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVSipSrvCfg::set_has_expire() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVSipSrvCfg::clear_has_expire() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVSipSrvCfg::clear_expire() {
  expire_ = 0u;
  clear_has_expire();
}
inline ::google::protobuf::uint32 TNVSipSrvCfg::expire() const {
  return expire_;
}
inline void TNVSipSrvCfg::set_expire(::google::protobuf::uint32 value) {
  set_has_expire();
  expire_ = value;
}

// optional string ValidateName = 7;
inline bool TNVSipSrvCfg::has_validatename() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVSipSrvCfg::set_has_validatename() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVSipSrvCfg::clear_has_validatename() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVSipSrvCfg::clear_validatename() {
  if (validatename_ != &::google::protobuf::internal::kEmptyString) {
    validatename_->clear();
  }
  clear_has_validatename();
}
inline const ::std::string& TNVSipSrvCfg::validatename() const {
  return *validatename_;
}
inline void TNVSipSrvCfg::set_validatename(const ::std::string& value) {
  set_has_validatename();
  if (validatename_ == &::google::protobuf::internal::kEmptyString) {
    validatename_ = new ::std::string;
  }
  validatename_->assign(value);
}
inline void TNVSipSrvCfg::set_validatename(const char* value) {
  set_has_validatename();
  if (validatename_ == &::google::protobuf::internal::kEmptyString) {
    validatename_ = new ::std::string;
  }
  validatename_->assign(value);
}
inline void TNVSipSrvCfg::set_validatename(const char* value, size_t size) {
  set_has_validatename();
  if (validatename_ == &::google::protobuf::internal::kEmptyString) {
    validatename_ = new ::std::string;
  }
  validatename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSipSrvCfg::mutable_validatename() {
  set_has_validatename();
  if (validatename_ == &::google::protobuf::internal::kEmptyString) {
    validatename_ = new ::std::string;
  }
  return validatename_;
}
inline ::std::string* TNVSipSrvCfg::release_validatename() {
  clear_has_validatename();
  if (validatename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = validatename_;
    validatename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVSipSrvCfg::set_allocated_validatename(::std::string* validatename) {
  if (validatename_ != &::google::protobuf::internal::kEmptyString) {
    delete validatename_;
  }
  if (validatename) {
    set_has_validatename();
    validatename_ = validatename;
  } else {
    clear_has_validatename();
    validatename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 host_port = 8;
inline bool TNVSipSrvCfg::has_host_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVSipSrvCfg::set_has_host_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVSipSrvCfg::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVSipSrvCfg::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
inline ::google::protobuf::uint32 TNVSipSrvCfg::host_port() const {
  return host_port_;
}
inline void TNVSipSrvCfg::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
}

// optional string auth_name = 9;
inline bool TNVSipSrvCfg::has_auth_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVSipSrvCfg::set_has_auth_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVSipSrvCfg::clear_has_auth_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVSipSrvCfg::clear_auth_name() {
  if (auth_name_ != &::google::protobuf::internal::kEmptyString) {
    auth_name_->clear();
  }
  clear_has_auth_name();
}
inline const ::std::string& TNVSipSrvCfg::auth_name() const {
  return *auth_name_;
}
inline void TNVSipSrvCfg::set_auth_name(const ::std::string& value) {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  auth_name_->assign(value);
}
inline void TNVSipSrvCfg::set_auth_name(const char* value) {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  auth_name_->assign(value);
}
inline void TNVSipSrvCfg::set_auth_name(const char* value, size_t size) {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  auth_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSipSrvCfg::mutable_auth_name() {
  set_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    auth_name_ = new ::std::string;
  }
  return auth_name_;
}
inline ::std::string* TNVSipSrvCfg::release_auth_name() {
  clear_has_auth_name();
  if (auth_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_name_;
    auth_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVSipSrvCfg::set_allocated_auth_name(::std::string* auth_name) {
  if (auth_name_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_name_;
  }
  if (auth_name) {
    set_has_auth_name();
    auth_name_ = auth_name;
  } else {
    clear_has_auth_name();
    auth_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVMtAudInState

// optional bool is_used = 1;
inline bool TNVMtAudInState::has_is_used() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtAudInState::set_has_is_used() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtAudInState::clear_has_is_used() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtAudInState::clear_is_used() {
  is_used_ = false;
  clear_has_is_used();
}
inline bool TNVMtAudInState::is_used() const {
  return is_used_;
}
inline void TNVMtAudInState::set_is_used(bool value) {
  set_has_is_used();
  is_used_ = value;
}

// optional .nv.EmMtHDAudPortIn audin_type = 2;
inline bool TNVMtAudInState::has_audin_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtAudInState::set_has_audin_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtAudInState::clear_has_audin_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtAudInState::clear_audin_type() {
  audin_type_ = 0;
  clear_has_audin_type();
}
inline ::nv::EmMtHDAudPortIn TNVMtAudInState::audin_type() const {
  return static_cast< ::nv::EmMtHDAudPortIn >(audin_type_);
}
inline void TNVMtAudInState::set_audin_type(::nv::EmMtHDAudPortIn value) {
  assert(::nv::EmMtHDAudPortIn_IsValid(value));
  set_has_audin_type();
  audin_type_ = value;
}

// -------------------------------------------------------------------

// TNVMtMutiAudInState

// optional uint32 count = 1;
inline bool TNVMtMutiAudInState::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtMutiAudInState::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtMutiAudInState::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtMutiAudInState::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TNVMtMutiAudInState::count() const {
  return count_;
}
inline void TNVMtMutiAudInState::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .nv.TNVMtAudInState audin_state = 2;
inline int TNVMtMutiAudInState::audin_state_size() const {
  return audin_state_.size();
}
inline void TNVMtMutiAudInState::clear_audin_state() {
  audin_state_.Clear();
}
inline const ::nv::TNVMtAudInState& TNVMtMutiAudInState::audin_state(int index) const {
  return audin_state_.Get(index);
}
inline ::nv::TNVMtAudInState* TNVMtMutiAudInState::mutable_audin_state(int index) {
  return audin_state_.Mutable(index);
}
inline ::nv::TNVMtAudInState* TNVMtMutiAudInState::add_audin_state() {
  return audin_state_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVMtAudInState >&
TNVMtMutiAudInState::audin_state() const {
  return audin_state_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVMtAudInState >*
TNVMtMutiAudInState::mutable_audin_state() {
  return &audin_state_;
}

// -------------------------------------------------------------------

// TNVMtLocalSoundPaly

// optional .nv.EmMtLocalSoundType emtype = 1;
inline bool TNVMtLocalSoundPaly::has_emtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtLocalSoundPaly::set_has_emtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtLocalSoundPaly::clear_has_emtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtLocalSoundPaly::clear_emtype() {
  emtype_ = 0;
  clear_has_emtype();
}
inline ::nv::EmMtLocalSoundType TNVMtLocalSoundPaly::emtype() const {
  return static_cast< ::nv::EmMtLocalSoundType >(emtype_);
}
inline void TNVMtLocalSoundPaly::set_emtype(::nv::EmMtLocalSoundType value) {
  assert(::nv::EmMtLocalSoundType_IsValid(value));
  set_has_emtype();
  emtype_ = value;
}

// optional .nv.EmMtLocalSoundIndex emindex = 2;
inline bool TNVMtLocalSoundPaly::has_emindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtLocalSoundPaly::set_has_emindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtLocalSoundPaly::clear_has_emindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtLocalSoundPaly::clear_emindex() {
  emindex_ = 0;
  clear_has_emindex();
}
inline ::nv::EmMtLocalSoundIndex TNVMtLocalSoundPaly::emindex() const {
  return static_cast< ::nv::EmMtLocalSoundIndex >(emindex_);
}
inline void TNVMtLocalSoundPaly::set_emindex(::nv::EmMtLocalSoundIndex value) {
  assert(::nv::EmMtLocalSoundIndex_IsValid(value));
  set_has_emindex();
  emindex_ = value;
}

// optional bool is_play = 3;
inline bool TNVMtLocalSoundPaly::has_is_play() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVMtLocalSoundPaly::set_has_is_play() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVMtLocalSoundPaly::clear_has_is_play() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVMtLocalSoundPaly::clear_is_play() {
  is_play_ = false;
  clear_has_is_play();
}
inline bool TNVMtLocalSoundPaly::is_play() const {
  return is_play_;
}
inline void TNVMtLocalSoundPaly::set_is_play(bool value) {
  set_has_is_play();
  is_play_ = value;
}

// -------------------------------------------------------------------

// TNVMtAudioTestCfg

// optional .nv.EmMtCodecComponent emcomponent = 1;
inline bool TNVMtAudioTestCfg::has_emcomponent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtAudioTestCfg::set_has_emcomponent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtAudioTestCfg::clear_has_emcomponent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtAudioTestCfg::clear_emcomponent() {
  emcomponent_ = 0;
  clear_has_emcomponent();
}
inline ::nv::EmMtCodecComponent TNVMtAudioTestCfg::emcomponent() const {
  return static_cast< ::nv::EmMtCodecComponent >(emcomponent_);
}
inline void TNVMtAudioTestCfg::set_emcomponent(::nv::EmMtCodecComponent value) {
  assert(::nv::EmMtCodecComponent_IsValid(value));
  set_has_emcomponent();
  emcomponent_ = value;
}

// optional .nv.EmCodecComponentIndex emIndex = 2;
inline bool TNVMtAudioTestCfg::has_emindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtAudioTestCfg::set_has_emindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtAudioTestCfg::clear_has_emindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtAudioTestCfg::clear_emindex() {
  emindex_ = 0;
  clear_has_emindex();
}
inline ::nv::EmCodecComponentIndex TNVMtAudioTestCfg::emindex() const {
  return static_cast< ::nv::EmCodecComponentIndex >(emindex_);
}
inline void TNVMtAudioTestCfg::set_emindex(::nv::EmCodecComponentIndex value) {
  assert(::nv::EmCodecComponentIndex_IsValid(value));
  set_has_emindex();
  emindex_ = value;
}

// optional bool is_start = 3;
inline bool TNVMtAudioTestCfg::has_is_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVMtAudioTestCfg::set_has_is_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVMtAudioTestCfg::clear_has_is_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVMtAudioTestCfg::clear_is_start() {
  is_start_ = false;
  clear_has_is_start();
}
inline bool TNVMtAudioTestCfg::is_start() const {
  return is_start_;
}
inline void TNVMtAudioTestCfg::set_is_start(bool value) {
  set_has_is_start();
  is_start_ = value;
}

// -------------------------------------------------------------------

// TNVMtAudioPower

// optional .nv.EmMtCodecComponent emcomponent = 1;
inline bool TNVMtAudioPower::has_emcomponent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtAudioPower::set_has_emcomponent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtAudioPower::clear_has_emcomponent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtAudioPower::clear_emcomponent() {
  emcomponent_ = 0;
  clear_has_emcomponent();
}
inline ::nv::EmMtCodecComponent TNVMtAudioPower::emcomponent() const {
  return static_cast< ::nv::EmMtCodecComponent >(emcomponent_);
}
inline void TNVMtAudioPower::set_emcomponent(::nv::EmMtCodecComponent value) {
  assert(::nv::EmMtCodecComponent_IsValid(value));
  set_has_emcomponent();
  emcomponent_ = value;
}

// optional .nv.EmCodecComponentIndex emIndex = 2;
inline bool TNVMtAudioPower::has_emindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtAudioPower::set_has_emindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtAudioPower::clear_has_emindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtAudioPower::clear_emindex() {
  emindex_ = 0;
  clear_has_emindex();
}
inline ::nv::EmCodecComponentIndex TNVMtAudioPower::emindex() const {
  return static_cast< ::nv::EmCodecComponentIndex >(emindex_);
}
inline void TNVMtAudioPower::set_emindex(::nv::EmCodecComponentIndex value) {
  assert(::nv::EmCodecComponentIndex_IsValid(value));
  set_has_emindex();
  emindex_ = value;
}

// optional uint32 power = 3;
inline bool TNVMtAudioPower::has_power() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVMtAudioPower::set_has_power() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVMtAudioPower::clear_has_power() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVMtAudioPower::clear_power() {
  power_ = 0u;
  clear_has_power();
}
inline ::google::protobuf::uint32 TNVMtAudioPower::power() const {
  return power_;
}
inline void TNVMtAudioPower::set_power(::google::protobuf::uint32 value) {
  set_has_power();
  power_ = value;
}

// -------------------------------------------------------------------

// TNVMtXAPSvrCfg

// optional .nv.EmMtServerAddrType addr_type = 1;
inline bool TNVMtXAPSvrCfg::has_addr_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtXAPSvrCfg::set_has_addr_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtXAPSvrCfg::clear_has_addr_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtXAPSvrCfg::clear_addr_type() {
  addr_type_ = 0;
  clear_has_addr_type();
}
inline ::nv::EmMtServerAddrType TNVMtXAPSvrCfg::addr_type() const {
  return static_cast< ::nv::EmMtServerAddrType >(addr_type_);
}
inline void TNVMtXAPSvrCfg::set_addr_type(::nv::EmMtServerAddrType value) {
  assert(::nv::EmMtServerAddrType_IsValid(value));
  set_has_addr_type();
  addr_type_ = value;
}

// optional string alias = 2;
inline bool TNVMtXAPSvrCfg::has_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtXAPSvrCfg::set_has_alias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtXAPSvrCfg::clear_has_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtXAPSvrCfg::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& TNVMtXAPSvrCfg::alias() const {
  return *alias_;
}
inline void TNVMtXAPSvrCfg::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TNVMtXAPSvrCfg::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TNVMtXAPSvrCfg::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtXAPSvrCfg::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* TNVMtXAPSvrCfg::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtXAPSvrCfg::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string domain = 3;
inline bool TNVMtXAPSvrCfg::has_domain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVMtXAPSvrCfg::set_has_domain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVMtXAPSvrCfg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVMtXAPSvrCfg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TNVMtXAPSvrCfg::domain() const {
  return *domain_;
}
inline void TNVMtXAPSvrCfg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVMtXAPSvrCfg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVMtXAPSvrCfg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtXAPSvrCfg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TNVMtXAPSvrCfg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtXAPSvrCfg::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 dwip = 4;
inline bool TNVMtXAPSvrCfg::has_dwip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVMtXAPSvrCfg::set_has_dwip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVMtXAPSvrCfg::clear_has_dwip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVMtXAPSvrCfg::clear_dwip() {
  dwip_ = 0u;
  clear_has_dwip();
}
inline ::google::protobuf::uint32 TNVMtXAPSvrCfg::dwip() const {
  return dwip_;
}
inline void TNVMtXAPSvrCfg::set_dwip(::google::protobuf::uint32 value) {
  set_has_dwip();
  dwip_ = value;
}

// optional bool is_ipsrv = 5;
inline bool TNVMtXAPSvrCfg::has_is_ipsrv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVMtXAPSvrCfg::set_has_is_ipsrv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVMtXAPSvrCfg::clear_has_is_ipsrv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVMtXAPSvrCfg::clear_is_ipsrv() {
  is_ipsrv_ = false;
  clear_has_is_ipsrv();
}
inline bool TNVMtXAPSvrCfg::is_ipsrv() const {
  return is_ipsrv_;
}
inline void TNVMtXAPSvrCfg::set_is_ipsrv(bool value) {
  set_has_is_ipsrv();
  is_ipsrv_ = value;
}

// -------------------------------------------------------------------

// TNVMtXAPSvrList

// optional bool is_auotoselect = 1;
inline bool TNVMtXAPSvrList::has_is_auotoselect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtXAPSvrList::set_has_is_auotoselect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtXAPSvrList::clear_has_is_auotoselect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtXAPSvrList::clear_is_auotoselect() {
  is_auotoselect_ = false;
  clear_has_is_auotoselect();
}
inline bool TNVMtXAPSvrList::is_auotoselect() const {
  return is_auotoselect_;
}
inline void TNVMtXAPSvrList::set_is_auotoselect(bool value) {
  set_has_is_auotoselect();
  is_auotoselect_ = value;
}

// optional uint32 cur_index = 2;
inline bool TNVMtXAPSvrList::has_cur_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtXAPSvrList::set_has_cur_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtXAPSvrList::clear_has_cur_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtXAPSvrList::clear_cur_index() {
  cur_index_ = 0u;
  clear_has_cur_index();
}
inline ::google::protobuf::uint32 TNVMtXAPSvrList::cur_index() const {
  return cur_index_;
}
inline void TNVMtXAPSvrList::set_cur_index(::google::protobuf::uint32 value) {
  set_has_cur_index();
  cur_index_ = value;
}

// repeated .nv.TNVMtXAPSvrCfg xapsrv_list = 3;
inline int TNVMtXAPSvrList::xapsrv_list_size() const {
  return xapsrv_list_.size();
}
inline void TNVMtXAPSvrList::clear_xapsrv_list() {
  xapsrv_list_.Clear();
}
inline const ::nv::TNVMtXAPSvrCfg& TNVMtXAPSvrList::xapsrv_list(int index) const {
  return xapsrv_list_.Get(index);
}
inline ::nv::TNVMtXAPSvrCfg* TNVMtXAPSvrList::mutable_xapsrv_list(int index) {
  return xapsrv_list_.Mutable(index);
}
inline ::nv::TNVMtXAPSvrCfg* TNVMtXAPSvrList::add_xapsrv_list() {
  return xapsrv_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVMtXAPSvrCfg >&
TNVMtXAPSvrList::xapsrv_list() const {
  return xapsrv_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVMtXAPSvrCfg >*
TNVMtXAPSvrList::mutable_xapsrv_list() {
  return &xapsrv_list_;
}

// optional uint32 list_count = 4;
inline bool TNVMtXAPSvrList::has_list_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVMtXAPSvrList::set_has_list_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVMtXAPSvrList::clear_has_list_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVMtXAPSvrList::clear_list_count() {
  list_count_ = 0u;
  clear_has_list_count();
}
inline ::google::protobuf::uint32 TNVMtXAPSvrList::list_count() const {
  return list_count_;
}
inline void TNVMtXAPSvrList::set_list_count(::google::protobuf::uint32 value) {
  set_has_list_count();
  list_count_ = value;
}

// -------------------------------------------------------------------

// TNVMtCSUAddr

// optional bool is_usedCSU = 1;
inline bool TNVMtCSUAddr::has_is_usedcsu() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtCSUAddr::set_has_is_usedcsu() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtCSUAddr::clear_has_is_usedcsu() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtCSUAddr::clear_is_usedcsu() {
  is_usedcsu_ = false;
  clear_has_is_usedcsu();
}
inline bool TNVMtCSUAddr::is_usedcsu() const {
  return is_usedcsu_;
}
inline void TNVMtCSUAddr::set_is_usedcsu(bool value) {
  set_has_is_usedcsu();
  is_usedcsu_ = value;
}

// optional string domain = 2;
inline bool TNVMtCSUAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtCSUAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtCSUAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtCSUAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TNVMtCSUAddr::domain() const {
  return *domain_;
}
inline void TNVMtCSUAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVMtCSUAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVMtCSUAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtCSUAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TNVMtCSUAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtCSUAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gk_ip = 3;
inline bool TNVMtCSUAddr::has_gk_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVMtCSUAddr::set_has_gk_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVMtCSUAddr::clear_has_gk_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVMtCSUAddr::clear_gk_ip() {
  gk_ip_ = 0u;
  clear_has_gk_ip();
}
inline ::google::protobuf::uint32 TNVMtCSUAddr::gk_ip() const {
  return gk_ip_;
}
inline void TNVMtCSUAddr::set_gk_ip(::google::protobuf::uint32 value) {
  set_has_gk_ip();
  gk_ip_ = value;
}

// optional uint32 gk_port = 4;
inline bool TNVMtCSUAddr::has_gk_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVMtCSUAddr::set_has_gk_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVMtCSUAddr::clear_has_gk_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVMtCSUAddr::clear_gk_port() {
  gk_port_ = 0u;
  clear_has_gk_port();
}
inline ::google::protobuf::uint32 TNVMtCSUAddr::gk_port() const {
  return gk_port_;
}
inline void TNVMtCSUAddr::set_gk_port(::google::protobuf::uint32 value) {
  set_has_gk_port();
  gk_port_ = value;
}

// optional string number = 5;
inline bool TNVMtCSUAddr::has_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVMtCSUAddr::set_has_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVMtCSUAddr::clear_has_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVMtCSUAddr::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& TNVMtCSUAddr::number() const {
  return *number_;
}
inline void TNVMtCSUAddr::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TNVMtCSUAddr::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void TNVMtCSUAddr::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtCSUAddr::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* TNVMtCSUAddr::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtCSUAddr::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 6;
inline bool TNVMtCSUAddr::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVMtCSUAddr::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVMtCSUAddr::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVMtCSUAddr::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TNVMtCSUAddr::password() const {
  return *password_;
}
inline void TNVMtCSUAddr::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVMtCSUAddr::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVMtCSUAddr::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtCSUAddr::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TNVMtCSUAddr::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtCSUAddr::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 time_tolive = 7;
inline bool TNVMtCSUAddr::has_time_tolive() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVMtCSUAddr::set_has_time_tolive() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVMtCSUAddr::clear_has_time_tolive() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVMtCSUAddr::clear_time_tolive() {
  time_tolive_ = 0u;
  clear_has_time_tolive();
}
inline ::google::protobuf::uint32 TNVMtCSUAddr::time_tolive() const {
  return time_tolive_;
}
inline void TNVMtCSUAddr::set_time_tolive(::google::protobuf::uint32 value) {
  set_has_time_tolive();
  time_tolive_ = value;
}

// -------------------------------------------------------------------

// TNVMtAccountManager

// optional string user_name = 1;
inline bool TNVMtAccountManager::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtAccountManager::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtAccountManager::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtAccountManager::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TNVMtAccountManager::user_name() const {
  return *user_name_;
}
inline void TNVMtAccountManager::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVMtAccountManager::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVMtAccountManager::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtAccountManager::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TNVMtAccountManager::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtAccountManager::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool TNVMtAccountManager::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtAccountManager::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtAccountManager::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtAccountManager::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TNVMtAccountManager::password() const {
  return *password_;
}
inline void TNVMtAccountManager::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVMtAccountManager::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVMtAccountManager::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtAccountManager::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TNVMtAccountManager::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtAccountManager::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobile_num = 3;
inline bool TNVMtAccountManager::has_mobile_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVMtAccountManager::set_has_mobile_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVMtAccountManager::clear_has_mobile_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVMtAccountManager::clear_mobile_num() {
  if (mobile_num_ != &::google::protobuf::internal::kEmptyString) {
    mobile_num_->clear();
  }
  clear_has_mobile_num();
}
inline const ::std::string& TNVMtAccountManager::mobile_num() const {
  return *mobile_num_;
}
inline void TNVMtAccountManager::set_mobile_num(const ::std::string& value) {
  set_has_mobile_num();
  if (mobile_num_ == &::google::protobuf::internal::kEmptyString) {
    mobile_num_ = new ::std::string;
  }
  mobile_num_->assign(value);
}
inline void TNVMtAccountManager::set_mobile_num(const char* value) {
  set_has_mobile_num();
  if (mobile_num_ == &::google::protobuf::internal::kEmptyString) {
    mobile_num_ = new ::std::string;
  }
  mobile_num_->assign(value);
}
inline void TNVMtAccountManager::set_mobile_num(const char* value, size_t size) {
  set_has_mobile_num();
  if (mobile_num_ == &::google::protobuf::internal::kEmptyString) {
    mobile_num_ = new ::std::string;
  }
  mobile_num_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtAccountManager::mutable_mobile_num() {
  set_has_mobile_num();
  if (mobile_num_ == &::google::protobuf::internal::kEmptyString) {
    mobile_num_ = new ::std::string;
  }
  return mobile_num_;
}
inline ::std::string* TNVMtAccountManager::release_mobile_num() {
  clear_has_mobile_num();
  if (mobile_num_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_num_;
    mobile_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtAccountManager::set_allocated_mobile_num(::std::string* mobile_num) {
  if (mobile_num_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_num_;
  }
  if (mobile_num) {
    set_has_mobile_num();
    mobile_num_ = mobile_num;
  } else {
    clear_has_mobile_num();
    mobile_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ext_num = 4;
inline bool TNVMtAccountManager::has_ext_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVMtAccountManager::set_has_ext_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVMtAccountManager::clear_has_ext_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVMtAccountManager::clear_ext_num() {
  if (ext_num_ != &::google::protobuf::internal::kEmptyString) {
    ext_num_->clear();
  }
  clear_has_ext_num();
}
inline const ::std::string& TNVMtAccountManager::ext_num() const {
  return *ext_num_;
}
inline void TNVMtAccountManager::set_ext_num(const ::std::string& value) {
  set_has_ext_num();
  if (ext_num_ == &::google::protobuf::internal::kEmptyString) {
    ext_num_ = new ::std::string;
  }
  ext_num_->assign(value);
}
inline void TNVMtAccountManager::set_ext_num(const char* value) {
  set_has_ext_num();
  if (ext_num_ == &::google::protobuf::internal::kEmptyString) {
    ext_num_ = new ::std::string;
  }
  ext_num_->assign(value);
}
inline void TNVMtAccountManager::set_ext_num(const char* value, size_t size) {
  set_has_ext_num();
  if (ext_num_ == &::google::protobuf::internal::kEmptyString) {
    ext_num_ = new ::std::string;
  }
  ext_num_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtAccountManager::mutable_ext_num() {
  set_has_ext_num();
  if (ext_num_ == &::google::protobuf::internal::kEmptyString) {
    ext_num_ = new ::std::string;
  }
  return ext_num_;
}
inline ::std::string* TNVMtAccountManager::release_ext_num() {
  clear_has_ext_num();
  if (ext_num_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ext_num_;
    ext_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtAccountManager::set_allocated_ext_num(::std::string* ext_num) {
  if (ext_num_ != &::google::protobuf::internal::kEmptyString) {
    delete ext_num_;
  }
  if (ext_num) {
    set_has_ext_num();
    ext_num_ = ext_num;
  } else {
    clear_has_ext_num();
    ext_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string seat = 5;
inline bool TNVMtAccountManager::has_seat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVMtAccountManager::set_has_seat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVMtAccountManager::clear_has_seat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVMtAccountManager::clear_seat() {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    seat_->clear();
  }
  clear_has_seat();
}
inline const ::std::string& TNVMtAccountManager::seat() const {
  return *seat_;
}
inline void TNVMtAccountManager::set_seat(const ::std::string& value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void TNVMtAccountManager::set_seat(const char* value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void TNVMtAccountManager::set_seat(const char* value, size_t size) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtAccountManager::mutable_seat() {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  return seat_;
}
inline ::std::string* TNVMtAccountManager::release_seat() {
  clear_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seat_;
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtAccountManager::set_allocated_seat(::std::string* seat) {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    delete seat_;
  }
  if (seat) {
    set_has_seat();
    seat_ = seat;
  } else {
    clear_has_seat();
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brief = 6;
inline bool TNVMtAccountManager::has_brief() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVMtAccountManager::set_has_brief() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVMtAccountManager::clear_has_brief() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVMtAccountManager::clear_brief() {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    brief_->clear();
  }
  clear_has_brief();
}
inline const ::std::string& TNVMtAccountManager::brief() const {
  return *brief_;
}
inline void TNVMtAccountManager::set_brief(const ::std::string& value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TNVMtAccountManager::set_brief(const char* value) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(value);
}
inline void TNVMtAccountManager::set_brief(const char* value, size_t size) {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  brief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtAccountManager::mutable_brief() {
  set_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    brief_ = new ::std::string;
  }
  return brief_;
}
inline ::std::string* TNVMtAccountManager::release_brief() {
  clear_has_brief();
  if (brief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brief_;
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtAccountManager::set_allocated_brief(::std::string* brief) {
  if (brief_ != &::google::protobuf::internal::kEmptyString) {
    delete brief_;
  }
  if (brief) {
    set_has_brief();
    brief_ = brief;
  } else {
    clear_has_brief();
    brief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string positon = 7;
inline bool TNVMtAccountManager::has_positon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVMtAccountManager::set_has_positon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVMtAccountManager::clear_has_positon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVMtAccountManager::clear_positon() {
  if (positon_ != &::google::protobuf::internal::kEmptyString) {
    positon_->clear();
  }
  clear_has_positon();
}
inline const ::std::string& TNVMtAccountManager::positon() const {
  return *positon_;
}
inline void TNVMtAccountManager::set_positon(const ::std::string& value) {
  set_has_positon();
  if (positon_ == &::google::protobuf::internal::kEmptyString) {
    positon_ = new ::std::string;
  }
  positon_->assign(value);
}
inline void TNVMtAccountManager::set_positon(const char* value) {
  set_has_positon();
  if (positon_ == &::google::protobuf::internal::kEmptyString) {
    positon_ = new ::std::string;
  }
  positon_->assign(value);
}
inline void TNVMtAccountManager::set_positon(const char* value, size_t size) {
  set_has_positon();
  if (positon_ == &::google::protobuf::internal::kEmptyString) {
    positon_ = new ::std::string;
  }
  positon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtAccountManager::mutable_positon() {
  set_has_positon();
  if (positon_ == &::google::protobuf::internal::kEmptyString) {
    positon_ = new ::std::string;
  }
  return positon_;
}
inline ::std::string* TNVMtAccountManager::release_positon() {
  clear_has_positon();
  if (positon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = positon_;
    positon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtAccountManager::set_allocated_positon(::std::string* positon) {
  if (positon_ != &::google::protobuf::internal::kEmptyString) {
    delete positon_;
  }
  if (positon) {
    set_has_positon();
    positon_ = positon;
  } else {
    clear_has_positon();
    positon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 8;
inline bool TNVMtAccountManager::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVMtAccountManager::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVMtAccountManager::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVMtAccountManager::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TNVMtAccountManager::name() const {
  return *name_;
}
inline void TNVMtAccountManager::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TNVMtAccountManager::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TNVMtAccountManager::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtAccountManager::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TNVMtAccountManager::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtAccountManager::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string api_addr = 9;
inline bool TNVMtAccountManager::has_api_addr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVMtAccountManager::set_has_api_addr() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVMtAccountManager::clear_has_api_addr() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVMtAccountManager::clear_api_addr() {
  if (api_addr_ != &::google::protobuf::internal::kEmptyString) {
    api_addr_->clear();
  }
  clear_has_api_addr();
}
inline const ::std::string& TNVMtAccountManager::api_addr() const {
  return *api_addr_;
}
inline void TNVMtAccountManager::set_api_addr(const ::std::string& value) {
  set_has_api_addr();
  if (api_addr_ == &::google::protobuf::internal::kEmptyString) {
    api_addr_ = new ::std::string;
  }
  api_addr_->assign(value);
}
inline void TNVMtAccountManager::set_api_addr(const char* value) {
  set_has_api_addr();
  if (api_addr_ == &::google::protobuf::internal::kEmptyString) {
    api_addr_ = new ::std::string;
  }
  api_addr_->assign(value);
}
inline void TNVMtAccountManager::set_api_addr(const char* value, size_t size) {
  set_has_api_addr();
  if (api_addr_ == &::google::protobuf::internal::kEmptyString) {
    api_addr_ = new ::std::string;
  }
  api_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtAccountManager::mutable_api_addr() {
  set_has_api_addr();
  if (api_addr_ == &::google::protobuf::internal::kEmptyString) {
    api_addr_ = new ::std::string;
  }
  return api_addr_;
}
inline ::std::string* TNVMtAccountManager::release_api_addr() {
  clear_has_api_addr();
  if (api_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = api_addr_;
    api_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtAccountManager::set_allocated_api_addr(::std::string* api_addr) {
  if (api_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete api_addr_;
  }
  if (api_addr) {
    set_has_api_addr();
    api_addr_ = api_addr;
  } else {
    clear_has_api_addr();
    api_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 10;
inline bool TNVMtAccountManager::has_email() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TNVMtAccountManager::set_has_email() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TNVMtAccountManager::clear_has_email() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TNVMtAccountManager::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& TNVMtAccountManager::email() const {
  return *email_;
}
inline void TNVMtAccountManager::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TNVMtAccountManager::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void TNVMtAccountManager::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtAccountManager::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* TNVMtAccountManager::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtAccountManager::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_male = 11;
inline bool TNVMtAccountManager::has_is_male() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TNVMtAccountManager::set_has_is_male() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TNVMtAccountManager::clear_has_is_male() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TNVMtAccountManager::clear_is_male() {
  is_male_ = false;
  clear_has_is_male();
}
inline bool TNVMtAccountManager::is_male() const {
  return is_male_;
}
inline void TNVMtAccountManager::set_is_male(bool value) {
  set_has_is_male();
  is_male_ = value;
}

// optional bool is_adding = 12;
inline bool TNVMtAccountManager::has_is_adding() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TNVMtAccountManager::set_has_is_adding() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TNVMtAccountManager::clear_has_is_adding() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TNVMtAccountManager::clear_is_adding() {
  is_adding_ = false;
  clear_has_is_adding();
}
inline bool TNVMtAccountManager::is_adding() const {
  return is_adding_;
}
inline void TNVMtAccountManager::set_is_adding(bool value) {
  set_has_is_adding();
  is_adding_ = value;
}

// optional uint32 bit_mask = 13;
inline bool TNVMtAccountManager::has_bit_mask() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TNVMtAccountManager::set_has_bit_mask() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TNVMtAccountManager::clear_has_bit_mask() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TNVMtAccountManager::clear_bit_mask() {
  bit_mask_ = 0u;
  clear_has_bit_mask();
}
inline ::google::protobuf::uint32 TNVMtAccountManager::bit_mask() const {
  return bit_mask_;
}
inline void TNVMtAccountManager::set_bit_mask(::google::protobuf::uint32 value) {
  set_has_bit_mask();
  bit_mask_ = value;
}

// optional uint32 context_id = 14;
inline bool TNVMtAccountManager::has_context_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TNVMtAccountManager::set_has_context_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TNVMtAccountManager::clear_has_context_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TNVMtAccountManager::clear_context_id() {
  context_id_ = 0u;
  clear_has_context_id();
}
inline ::google::protobuf::uint32 TNVMtAccountManager::context_id() const {
  return context_id_;
}
inline void TNVMtAccountManager::set_context_id(::google::protobuf::uint32 value) {
  set_has_context_id();
  context_id_ = value;
}

// -------------------------------------------------------------------

// TNVMtApsLoginErrcode

// optional bool is_suc = 1;
inline bool TNVMtApsLoginErrcode::has_is_suc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtApsLoginErrcode::set_has_is_suc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtApsLoginErrcode::clear_has_is_suc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtApsLoginErrcode::clear_is_suc() {
  is_suc_ = false;
  clear_has_is_suc();
}
inline bool TNVMtApsLoginErrcode::is_suc() const {
  return is_suc_;
}
inline void TNVMtApsLoginErrcode::set_is_suc(bool value) {
  set_has_is_suc();
  is_suc_ = value;
}

// optional uint32 http_errcode = 2;
inline bool TNVMtApsLoginErrcode::has_http_errcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtApsLoginErrcode::set_has_http_errcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtApsLoginErrcode::clear_has_http_errcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtApsLoginErrcode::clear_http_errcode() {
  http_errcode_ = 0u;
  clear_has_http_errcode();
}
inline ::google::protobuf::uint32 TNVMtApsLoginErrcode::http_errcode() const {
  return http_errcode_;
}
inline void TNVMtApsLoginErrcode::set_http_errcode(::google::protobuf::uint32 value) {
  set_has_http_errcode();
  http_errcode_ = value;
}

// optional uint32 aps_errcode = 3;
inline bool TNVMtApsLoginErrcode::has_aps_errcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVMtApsLoginErrcode::set_has_aps_errcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVMtApsLoginErrcode::clear_has_aps_errcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVMtApsLoginErrcode::clear_aps_errcode() {
  aps_errcode_ = 0u;
  clear_has_aps_errcode();
}
inline ::google::protobuf::uint32 TNVMtApsLoginErrcode::aps_errcode() const {
  return aps_errcode_;
}
inline void TNVMtApsLoginErrcode::set_aps_errcode(::google::protobuf::uint32 value) {
  set_has_aps_errcode();
  aps_errcode_ = value;
}

// -------------------------------------------------------------------

// TNVForceSetH323Stack

// optional bool enable = 1;
inline bool TNVForceSetH323Stack::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVForceSetH323Stack::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVForceSetH323Stack::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVForceSetH323Stack::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TNVForceSetH323Stack::enable() const {
  return enable_;
}
inline void TNVForceSetH323Stack::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional bool stand = 2;
inline bool TNVForceSetH323Stack::has_stand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVForceSetH323Stack::set_has_stand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVForceSetH323Stack::clear_has_stand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVForceSetH323Stack::clear_stand() {
  stand_ = false;
  clear_has_stand();
}
inline bool TNVForceSetH323Stack::stand() const {
  return stand_;
}
inline void TNVForceSetH323Stack::set_stand(bool value) {
  set_has_stand();
  stand_ = value;
}

// -------------------------------------------------------------------

// TNVMtAudInPort

// repeated .nv.EmMtHDAudPortIn audinport_list = 1;
inline int TNVMtAudInPort::audinport_list_size() const {
  return audinport_list_.size();
}
inline void TNVMtAudInPort::clear_audinport_list() {
  audinport_list_.Clear();
}
inline ::nv::EmMtHDAudPortIn TNVMtAudInPort::audinport_list(int index) const {
  return static_cast< ::nv::EmMtHDAudPortIn >(audinport_list_.Get(index));
}
inline void TNVMtAudInPort::set_audinport_list(int index, ::nv::EmMtHDAudPortIn value) {
  assert(::nv::EmMtHDAudPortIn_IsValid(value));
  audinport_list_.Set(index, value);
}
inline void TNVMtAudInPort::add_audinport_list(::nv::EmMtHDAudPortIn value) {
  assert(::nv::EmMtHDAudPortIn_IsValid(value));
  audinport_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TNVMtAudInPort::audinport_list() const {
  return audinport_list_;
}
inline ::google::protobuf::RepeatedField<int>*
TNVMtAudInPort::mutable_audinport_list() {
  return &audinport_list_;
}

// optional uint32 port_count = 2;
inline bool TNVMtAudInPort::has_port_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtAudInPort::set_has_port_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtAudInPort::clear_has_port_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtAudInPort::clear_port_count() {
  port_count_ = 0u;
  clear_has_port_count();
}
inline ::google::protobuf::uint32 TNVMtAudInPort::port_count() const {
  return port_count_;
}
inline void TNVMtAudInPort::set_port_count(::google::protobuf::uint32 value) {
  set_has_port_count();
  port_count_ = value;
}

// -------------------------------------------------------------------

// TNVMtAudInPortList

// optional .nv.TNVMtAudInPort primic_list = 1;
inline bool TNVMtAudInPortList::has_primic_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtAudInPortList::set_has_primic_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtAudInPortList::clear_has_primic_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtAudInPortList::clear_primic_list() {
  if (primic_list_ != NULL) primic_list_->::nv::TNVMtAudInPort::Clear();
  clear_has_primic_list();
}
inline const ::nv::TNVMtAudInPort& TNVMtAudInPortList::primic_list() const {
  return primic_list_ != NULL ? *primic_list_ : *default_instance_->primic_list_;
}
inline ::nv::TNVMtAudInPort* TNVMtAudInPortList::mutable_primic_list() {
  set_has_primic_list();
  if (primic_list_ == NULL) primic_list_ = new ::nv::TNVMtAudInPort;
  return primic_list_;
}
inline ::nv::TNVMtAudInPort* TNVMtAudInPortList::release_primic_list() {
  clear_has_primic_list();
  ::nv::TNVMtAudInPort* temp = primic_list_;
  primic_list_ = NULL;
  return temp;
}
inline void TNVMtAudInPortList::set_allocated_primic_list(::nv::TNVMtAudInPort* primic_list) {
  delete primic_list_;
  primic_list_ = primic_list;
  if (primic_list) {
    set_has_primic_list();
  } else {
    clear_has_primic_list();
  }
}

// optional .nv.TNVMtAudInPort linein_list = 2;
inline bool TNVMtAudInPortList::has_linein_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtAudInPortList::set_has_linein_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtAudInPortList::clear_has_linein_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtAudInPortList::clear_linein_list() {
  if (linein_list_ != NULL) linein_list_->::nv::TNVMtAudInPort::Clear();
  clear_has_linein_list();
}
inline const ::nv::TNVMtAudInPort& TNVMtAudInPortList::linein_list() const {
  return linein_list_ != NULL ? *linein_list_ : *default_instance_->linein_list_;
}
inline ::nv::TNVMtAudInPort* TNVMtAudInPortList::mutable_linein_list() {
  set_has_linein_list();
  if (linein_list_ == NULL) linein_list_ = new ::nv::TNVMtAudInPort;
  return linein_list_;
}
inline ::nv::TNVMtAudInPort* TNVMtAudInPortList::release_linein_list() {
  clear_has_linein_list();
  ::nv::TNVMtAudInPort* temp = linein_list_;
  linein_list_ = NULL;
  return temp;
}
inline void TNVMtAudInPortList::set_allocated_linein_list(::nv::TNVMtAudInPort* linein_list) {
  delete linein_list_;
  linein_list_ = linein_list;
  if (linein_list) {
    set_has_linein_list();
  } else {
    clear_has_linein_list();
  }
}

// optional bool is_auxmic = 3;
inline bool TNVMtAudInPortList::has_is_auxmic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVMtAudInPortList::set_has_is_auxmic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVMtAudInPortList::clear_has_is_auxmic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVMtAudInPortList::clear_is_auxmic() {
  is_auxmic_ = false;
  clear_has_is_auxmic();
}
inline bool TNVMtAudInPortList::is_auxmic() const {
  return is_auxmic_;
}
inline void TNVMtAudInPortList::set_is_auxmic(bool value) {
  set_has_is_auxmic();
  is_auxmic_ = value;
}

// optional bool is_linemic = 4;
inline bool TNVMtAudInPortList::has_is_linemic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVMtAudInPortList::set_has_is_linemic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVMtAudInPortList::clear_has_is_linemic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVMtAudInPortList::clear_is_linemic() {
  is_linemic_ = false;
  clear_has_is_linemic();
}
inline bool TNVMtAudInPortList::is_linemic() const {
  return is_linemic_;
}
inline void TNVMtAudInPortList::set_is_linemic(bool value) {
  set_has_is_linemic();
  is_linemic_ = value;
}

// -------------------------------------------------------------------

// TNVMtCallBitRate

// optional uint32 rate_count = 1;
inline bool TNVMtCallBitRate::has_rate_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtCallBitRate::set_has_rate_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtCallBitRate::clear_has_rate_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtCallBitRate::clear_rate_count() {
  rate_count_ = 0u;
  clear_has_rate_count();
}
inline ::google::protobuf::uint32 TNVMtCallBitRate::rate_count() const {
  return rate_count_;
}
inline void TNVMtCallBitRate::set_rate_count(::google::protobuf::uint32 value) {
  set_has_rate_count();
  rate_count_ = value;
}

// repeated uint32 rate_list = 2;
inline int TNVMtCallBitRate::rate_list_size() const {
  return rate_list_.size();
}
inline void TNVMtCallBitRate::clear_rate_list() {
  rate_list_.Clear();
}
inline ::google::protobuf::uint32 TNVMtCallBitRate::rate_list(int index) const {
  return rate_list_.Get(index);
}
inline void TNVMtCallBitRate::set_rate_list(int index, ::google::protobuf::uint32 value) {
  rate_list_.Set(index, value);
}
inline void TNVMtCallBitRate::add_rate_list(::google::protobuf::uint32 value) {
  rate_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TNVMtCallBitRate::rate_list() const {
  return rate_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TNVMtCallBitRate::mutable_rate_list() {
  return &rate_list_;
}

// -------------------------------------------------------------------

// TNVMtSvrState

// optional .nv.EmMtServerType srv_type = 1;
inline bool TNVMtSvrState::has_srv_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtSvrState::set_has_srv_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtSvrState::clear_has_srv_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtSvrState::clear_srv_type() {
  srv_type_ = 0;
  clear_has_srv_type();
}
inline ::nv::EmMtServerType TNVMtSvrState::srv_type() const {
  return static_cast< ::nv::EmMtServerType >(srv_type_);
}
inline void TNVMtSvrState::set_srv_type(::nv::EmMtServerType value) {
  assert(::nv::EmMtServerType_IsValid(value));
  set_has_srv_type();
  srv_type_ = value;
}

// optional .nv.EmMtServerState srv_state = 2;
inline bool TNVMtSvrState::has_srv_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtSvrState::set_has_srv_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtSvrState::clear_has_srv_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtSvrState::clear_srv_state() {
  srv_state_ = 0;
  clear_has_srv_state();
}
inline ::nv::EmMtServerState TNVMtSvrState::srv_state() const {
  return static_cast< ::nv::EmMtServerState >(srv_state_);
}
inline void TNVMtSvrState::set_srv_state(::nv::EmMtServerState value) {
  assert(::nv::EmMtServerState_IsValid(value));
  set_has_srv_state();
  srv_state_ = value;
}

// -------------------------------------------------------------------

// TNVMtSvrStateList

// repeated .nv.TNVMtSvrState srv_state = 1;
inline int TNVMtSvrStateList::srv_state_size() const {
  return srv_state_.size();
}
inline void TNVMtSvrStateList::clear_srv_state() {
  srv_state_.Clear();
}
inline const ::nv::TNVMtSvrState& TNVMtSvrStateList::srv_state(int index) const {
  return srv_state_.Get(index);
}
inline ::nv::TNVMtSvrState* TNVMtSvrStateList::mutable_srv_state(int index) {
  return srv_state_.Mutable(index);
}
inline ::nv::TNVMtSvrState* TNVMtSvrStateList::add_srv_state() {
  return srv_state_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVMtSvrState >&
TNVMtSvrStateList::srv_state() const {
  return srv_state_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVMtSvrState >*
TNVMtSvrStateList::mutable_srv_state() {
  return &srv_state_;
}

// optional uint32 srv_count = 2;
inline bool TNVMtSvrStateList::has_srv_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtSvrStateList::set_has_srv_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtSvrStateList::clear_has_srv_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtSvrStateList::clear_srv_count() {
  srv_count_ = 0u;
  clear_has_srv_count();
}
inline ::google::protobuf::uint32 TNVMtSvrStateList::srv_count() const {
  return srv_count_;
}
inline void TNVMtSvrStateList::set_srv_count(::google::protobuf::uint32 value) {
  set_has_srv_count();
  srv_count_ = value;
}

// -------------------------------------------------------------------

// TNVMtMicStatus

// optional uint32 mic_id = 1;
inline bool TNVMtMicStatus::has_mic_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtMicStatus::set_has_mic_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtMicStatus::clear_has_mic_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtMicStatus::clear_mic_id() {
  mic_id_ = 0u;
  clear_has_mic_id();
}
inline ::google::protobuf::uint32 TNVMtMicStatus::mic_id() const {
  return mic_id_;
}
inline void TNVMtMicStatus::set_mic_id(::google::protobuf::uint32 value) {
  set_has_mic_id();
  mic_id_ = value;
}

// optional uint32 mic_stat = 2;
inline bool TNVMtMicStatus::has_mic_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtMicStatus::set_has_mic_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtMicStatus::clear_has_mic_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtMicStatus::clear_mic_stat() {
  mic_stat_ = 0u;
  clear_has_mic_stat();
}
inline ::google::protobuf::uint32 TNVMtMicStatus::mic_stat() const {
  return mic_stat_;
}
inline void TNVMtMicStatus::set_mic_stat(::google::protobuf::uint32 value) {
  set_has_mic_stat();
  mic_stat_ = value;
}

// -------------------------------------------------------------------

// TNVMtAllMicStatus

// repeated .nv.TNVMtMicStatus mic_status = 1;
inline int TNVMtAllMicStatus::mic_status_size() const {
  return mic_status_.size();
}
inline void TNVMtAllMicStatus::clear_mic_status() {
  mic_status_.Clear();
}
inline const ::nv::TNVMtMicStatus& TNVMtAllMicStatus::mic_status(int index) const {
  return mic_status_.Get(index);
}
inline ::nv::TNVMtMicStatus* TNVMtAllMicStatus::mutable_mic_status(int index) {
  return mic_status_.Mutable(index);
}
inline ::nv::TNVMtMicStatus* TNVMtAllMicStatus::add_mic_status() {
  return mic_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVMtMicStatus >&
TNVMtAllMicStatus::mic_status() const {
  return mic_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVMtMicStatus >*
TNVMtAllMicStatus::mutable_mic_status() {
  return &mic_status_;
}

// optional uint32 mic_cnt = 2;
inline bool TNVMtAllMicStatus::has_mic_cnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtAllMicStatus::set_has_mic_cnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtAllMicStatus::clear_has_mic_cnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtAllMicStatus::clear_mic_cnt() {
  mic_cnt_ = 0u;
  clear_has_mic_cnt();
}
inline ::google::protobuf::uint32 TNVMtAllMicStatus::mic_cnt() const {
  return mic_cnt_;
}
inline void TNVMtAllMicStatus::set_mic_cnt(::google::protobuf::uint32 value) {
  set_has_mic_cnt();
  mic_cnt_ = value;
}

// -------------------------------------------------------------------

// TNVMtHDVidInPort

// optional .nv.EmMtHDVideoType vid_type = 1;
inline bool TNVMtHDVidInPort::has_vid_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtHDVidInPort::set_has_vid_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtHDVidInPort::clear_has_vid_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtHDVidInPort::clear_vid_type() {
  vid_type_ = 0;
  clear_has_vid_type();
}
inline ::nv::EmMtHDVideoType TNVMtHDVidInPort::vid_type() const {
  return static_cast< ::nv::EmMtHDVideoType >(vid_type_);
}
inline void TNVMtHDVidInPort::set_vid_type(::nv::EmMtHDVideoType value) {
  assert(::nv::EmMtHDVideoType_IsValid(value));
  set_has_vid_type();
  vid_type_ = value;
}

// optional .nv.EmNvVideoPort_Api vid_port = 2;
inline bool TNVMtHDVidInPort::has_vid_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtHDVidInPort::set_has_vid_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtHDVidInPort::clear_has_vid_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtHDVidInPort::clear_vid_port() {
  vid_port_ = 0;
  clear_has_vid_port();
}
inline ::nv::EmNvVideoPort_Api TNVMtHDVidInPort::vid_port() const {
  return static_cast< ::nv::EmNvVideoPort_Api >(vid_port_);
}
inline void TNVMtHDVidInPort::set_vid_port(::nv::EmNvVideoPort_Api value) {
  assert(::nv::EmNvVideoPort_Api_IsValid(value));
  set_has_vid_port();
  vid_port_ = value;
}

// -------------------------------------------------------------------

// TNVImixAllVerInfo

// optional string imix_ver = 1;
inline bool TNVImixAllVerInfo::has_imix_ver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVImixAllVerInfo::set_has_imix_ver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVImixAllVerInfo::clear_has_imix_ver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVImixAllVerInfo::clear_imix_ver() {
  if (imix_ver_ != &::google::protobuf::internal::kEmptyString) {
    imix_ver_->clear();
  }
  clear_has_imix_ver();
}
inline const ::std::string& TNVImixAllVerInfo::imix_ver() const {
  return *imix_ver_;
}
inline void TNVImixAllVerInfo::set_imix_ver(const ::std::string& value) {
  set_has_imix_ver();
  if (imix_ver_ == &::google::protobuf::internal::kEmptyString) {
    imix_ver_ = new ::std::string;
  }
  imix_ver_->assign(value);
}
inline void TNVImixAllVerInfo::set_imix_ver(const char* value) {
  set_has_imix_ver();
  if (imix_ver_ == &::google::protobuf::internal::kEmptyString) {
    imix_ver_ = new ::std::string;
  }
  imix_ver_->assign(value);
}
inline void TNVImixAllVerInfo::set_imix_ver(const char* value, size_t size) {
  set_has_imix_ver();
  if (imix_ver_ == &::google::protobuf::internal::kEmptyString) {
    imix_ver_ = new ::std::string;
  }
  imix_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVImixAllVerInfo::mutable_imix_ver() {
  set_has_imix_ver();
  if (imix_ver_ == &::google::protobuf::internal::kEmptyString) {
    imix_ver_ = new ::std::string;
  }
  return imix_ver_;
}
inline ::std::string* TNVImixAllVerInfo::release_imix_ver() {
  clear_has_imix_ver();
  if (imix_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imix_ver_;
    imix_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVImixAllVerInfo::set_allocated_imix_ver(::std::string* imix_ver) {
  if (imix_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete imix_ver_;
  }
  if (imix_ver) {
    set_has_imix_ver();
    imix_ver_ = imix_ver;
  } else {
    clear_has_imix_ver();
    imix_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string power_ver = 2;
inline bool TNVImixAllVerInfo::has_power_ver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVImixAllVerInfo::set_has_power_ver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVImixAllVerInfo::clear_has_power_ver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVImixAllVerInfo::clear_power_ver() {
  if (power_ver_ != &::google::protobuf::internal::kEmptyString) {
    power_ver_->clear();
  }
  clear_has_power_ver();
}
inline const ::std::string& TNVImixAllVerInfo::power_ver() const {
  return *power_ver_;
}
inline void TNVImixAllVerInfo::set_power_ver(const ::std::string& value) {
  set_has_power_ver();
  if (power_ver_ == &::google::protobuf::internal::kEmptyString) {
    power_ver_ = new ::std::string;
  }
  power_ver_->assign(value);
}
inline void TNVImixAllVerInfo::set_power_ver(const char* value) {
  set_has_power_ver();
  if (power_ver_ == &::google::protobuf::internal::kEmptyString) {
    power_ver_ = new ::std::string;
  }
  power_ver_->assign(value);
}
inline void TNVImixAllVerInfo::set_power_ver(const char* value, size_t size) {
  set_has_power_ver();
  if (power_ver_ == &::google::protobuf::internal::kEmptyString) {
    power_ver_ = new ::std::string;
  }
  power_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVImixAllVerInfo::mutable_power_ver() {
  set_has_power_ver();
  if (power_ver_ == &::google::protobuf::internal::kEmptyString) {
    power_ver_ = new ::std::string;
  }
  return power_ver_;
}
inline ::std::string* TNVImixAllVerInfo::release_power_ver() {
  clear_has_power_ver();
  if (power_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = power_ver_;
    power_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVImixAllVerInfo::set_allocated_power_ver(::std::string* power_ver) {
  if (power_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete power_ver_;
  }
  if (power_ver) {
    set_has_power_ver();
    power_ver_ = power_ver;
  } else {
    clear_has_power_ver();
    power_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string router_ver = 3;
inline bool TNVImixAllVerInfo::has_router_ver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVImixAllVerInfo::set_has_router_ver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVImixAllVerInfo::clear_has_router_ver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVImixAllVerInfo::clear_router_ver() {
  if (router_ver_ != &::google::protobuf::internal::kEmptyString) {
    router_ver_->clear();
  }
  clear_has_router_ver();
}
inline const ::std::string& TNVImixAllVerInfo::router_ver() const {
  return *router_ver_;
}
inline void TNVImixAllVerInfo::set_router_ver(const ::std::string& value) {
  set_has_router_ver();
  if (router_ver_ == &::google::protobuf::internal::kEmptyString) {
    router_ver_ = new ::std::string;
  }
  router_ver_->assign(value);
}
inline void TNVImixAllVerInfo::set_router_ver(const char* value) {
  set_has_router_ver();
  if (router_ver_ == &::google::protobuf::internal::kEmptyString) {
    router_ver_ = new ::std::string;
  }
  router_ver_->assign(value);
}
inline void TNVImixAllVerInfo::set_router_ver(const char* value, size_t size) {
  set_has_router_ver();
  if (router_ver_ == &::google::protobuf::internal::kEmptyString) {
    router_ver_ = new ::std::string;
  }
  router_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVImixAllVerInfo::mutable_router_ver() {
  set_has_router_ver();
  if (router_ver_ == &::google::protobuf::internal::kEmptyString) {
    router_ver_ = new ::std::string;
  }
  return router_ver_;
}
inline ::std::string* TNVImixAllVerInfo::release_router_ver() {
  clear_has_router_ver();
  if (router_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = router_ver_;
    router_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVImixAllVerInfo::set_allocated_router_ver(::std::string* router_ver) {
  if (router_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete router_ver_;
  }
  if (router_ver) {
    set_has_router_ver();
    router_ver_ = router_ver;
  } else {
    clear_has_router_ver();
    router_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string qk_ver = 4;
inline bool TNVImixAllVerInfo::has_qk_ver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVImixAllVerInfo::set_has_qk_ver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVImixAllVerInfo::clear_has_qk_ver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVImixAllVerInfo::clear_qk_ver() {
  if (qk_ver_ != &::google::protobuf::internal::kEmptyString) {
    qk_ver_->clear();
  }
  clear_has_qk_ver();
}
inline const ::std::string& TNVImixAllVerInfo::qk_ver() const {
  return *qk_ver_;
}
inline void TNVImixAllVerInfo::set_qk_ver(const ::std::string& value) {
  set_has_qk_ver();
  if (qk_ver_ == &::google::protobuf::internal::kEmptyString) {
    qk_ver_ = new ::std::string;
  }
  qk_ver_->assign(value);
}
inline void TNVImixAllVerInfo::set_qk_ver(const char* value) {
  set_has_qk_ver();
  if (qk_ver_ == &::google::protobuf::internal::kEmptyString) {
    qk_ver_ = new ::std::string;
  }
  qk_ver_->assign(value);
}
inline void TNVImixAllVerInfo::set_qk_ver(const char* value, size_t size) {
  set_has_qk_ver();
  if (qk_ver_ == &::google::protobuf::internal::kEmptyString) {
    qk_ver_ = new ::std::string;
  }
  qk_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVImixAllVerInfo::mutable_qk_ver() {
  set_has_qk_ver();
  if (qk_ver_ == &::google::protobuf::internal::kEmptyString) {
    qk_ver_ = new ::std::string;
  }
  return qk_ver_;
}
inline ::std::string* TNVImixAllVerInfo::release_qk_ver() {
  clear_has_qk_ver();
  if (qk_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qk_ver_;
    qk_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVImixAllVerInfo::set_allocated_qk_ver(::std::string* qk_ver) {
  if (qk_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete qk_ver_;
  }
  if (qk_ver) {
    set_has_qk_ver();
    qk_ver_ = qk_ver;
  } else {
    clear_has_qk_ver();
    qk_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVSusUpgradeModule

// repeated .nv.EmSusUpgradeModule upgrade_module = 1;
inline int TNVSusUpgradeModule::upgrade_module_size() const {
  return upgrade_module_.size();
}
inline void TNVSusUpgradeModule::clear_upgrade_module() {
  upgrade_module_.Clear();
}
inline ::nv::EmSusUpgradeModule TNVSusUpgradeModule::upgrade_module(int index) const {
  return static_cast< ::nv::EmSusUpgradeModule >(upgrade_module_.Get(index));
}
inline void TNVSusUpgradeModule::set_upgrade_module(int index, ::nv::EmSusUpgradeModule value) {
  assert(::nv::EmSusUpgradeModule_IsValid(value));
  upgrade_module_.Set(index, value);
}
inline void TNVSusUpgradeModule::add_upgrade_module(::nv::EmSusUpgradeModule value) {
  assert(::nv::EmSusUpgradeModule_IsValid(value));
  upgrade_module_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TNVSusUpgradeModule::upgrade_module() const {
  return upgrade_module_;
}
inline ::google::protobuf::RepeatedField<int>*
TNVSusUpgradeModule::mutable_upgrade_module() {
  return &upgrade_module_;
}

// optional uint32 module_size = 2;
inline bool TNVSusUpgradeModule::has_module_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVSusUpgradeModule::set_has_module_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVSusUpgradeModule::clear_has_module_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVSusUpgradeModule::clear_module_size() {
  module_size_ = 0u;
  clear_has_module_size();
}
inline ::google::protobuf::uint32 TNVSusUpgradeModule::module_size() const {
  return module_size_;
}
inline void TNVSusUpgradeModule::set_module_size(::google::protobuf::uint32 value) {
  set_has_module_size();
  module_size_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nv

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nvstructmt_2eproto__INCLUDED
