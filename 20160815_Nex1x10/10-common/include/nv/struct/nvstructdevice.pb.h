// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nvstructdevice.proto

#ifndef PROTOBUF_nvstructdevice_2eproto__INCLUDED
#define PROTOBUF_nvstructdevice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "nvenum.pb.h"
// @@protoc_insertion_point(includes)

namespace nv {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
void protobuf_AssignDesc_nvstructdevice_2eproto();
void protobuf_ShutdownFile_nvstructdevice_2eproto();

class TNVKeyPressInfo;
class TNVHDSerialCtrl;
class TNVUsbPartition;
class TNVUsbInfo;
class TNVUsbStatus;
class TNVBrdInfo;
class TNVCpuAndMemState;
class TNVNetCapFileInfo;
class TNVNetCapFileList;
class TNVPathStructureUnit;
class TNVPathStructureDetail;
class TNVScreenParam;
class TNVScreenParamList;

// ===================================================================

class MTMSG_API TNVKeyPressInfo : public ::google::protobuf::Message {
 public:
  TNVKeyPressInfo();
  virtual ~TNVKeyPressInfo();

  TNVKeyPressInfo(const TNVKeyPressInfo& from);

  inline TNVKeyPressInfo& operator=(const TNVKeyPressInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVKeyPressInfo& default_instance();

  void Swap(TNVKeyPressInfo* other);

  // implements Message ----------------------------------------------

  TNVKeyPressInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVKeyPressInfo& from);
  void MergeFrom(const TNVKeyPressInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool key_type = 1;
  inline bool has_key_type() const;
  inline void clear_key_type();
  static const int kKeyTypeFieldNumber = 1;
  inline bool key_type() const;
  inline void set_key_type(bool value);

  // optional .nv.EmNvRemoteType key_source = 2;
  inline bool has_key_source() const;
  inline void clear_key_source();
  static const int kKeySourceFieldNumber = 2;
  inline ::nv::EmNvRemoteType key_source() const;
  inline void set_key_source(::nv::EmNvRemoteType value);

  // optional .nv.EmNvRemoteScanCode key_code = 3;
  inline bool has_key_code() const;
  inline void clear_key_code();
  static const int kKeyCodeFieldNumber = 3;
  inline ::nv::EmNvRemoteScanCode key_code() const;
  inline void set_key_code(::nv::EmNvRemoteScanCode value);

  // optional uint32 key_count = 4;
  inline bool has_key_count() const;
  inline void clear_key_count();
  static const int kKeyCountFieldNumber = 4;
  inline ::google::protobuf::uint32 key_count() const;
  inline void set_key_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVKeyPressInfo)
 private:
  inline void set_has_key_type();
  inline void clear_has_key_type();
  inline void set_has_key_source();
  inline void clear_has_key_source();
  inline void set_has_key_code();
  inline void clear_has_key_code();
  inline void set_has_key_count();
  inline void clear_has_key_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool key_type_;
  int key_source_;
  int key_code_;
  ::google::protobuf::uint32 key_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVKeyPressInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVHDSerialCtrl : public ::google::protobuf::Message {
 public:
  TNVHDSerialCtrl();
  virtual ~TNVHDSerialCtrl();

  TNVHDSerialCtrl(const TNVHDSerialCtrl& from);

  inline TNVHDSerialCtrl& operator=(const TNVHDSerialCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVHDSerialCtrl& default_instance();

  void Swap(TNVHDSerialCtrl* other);

  // implements Message ----------------------------------------------

  TNVHDSerialCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVHDSerialCtrl& from);
  void MergeFrom(const TNVHDSerialCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvSerialType serial_type = 1;
  inline bool has_serial_type() const;
  inline void clear_serial_type();
  static const int kSerialTypeFieldNumber = 1;
  inline ::nv::EmNvSerialType serial_type() const;
  inline void set_serial_type(::nv::EmNvSerialType value);

  // optional uint32 band_rate = 2;
  inline bool has_band_rate() const;
  inline void clear_band_rate();
  static const int kBandRateFieldNumber = 2;
  inline ::google::protobuf::uint32 band_rate() const;
  inline void set_band_rate(::google::protobuf::uint32 value);

  // optional uint32 byte_size = 3;
  inline bool has_byte_size() const;
  inline void clear_byte_size();
  static const int kByteSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 byte_size() const;
  inline void set_byte_size(::google::protobuf::uint32 value);

  // optional .nv.EmNvStopBits stop_bits = 4;
  inline bool has_stop_bits() const;
  inline void clear_stop_bits();
  static const int kStopBitsFieldNumber = 4;
  inline ::nv::EmNvStopBits stop_bits() const;
  inline void set_stop_bits(::nv::EmNvStopBits value);

  // optional .nv.EmNvParityCheck parity_check = 5;
  inline bool has_parity_check() const;
  inline void clear_parity_check();
  static const int kParityCheckFieldNumber = 5;
  inline ::nv::EmNvParityCheck parity_check() const;
  inline void set_parity_check(::nv::EmNvParityCheck value);

  // @@protoc_insertion_point(class_scope:nv.TNVHDSerialCtrl)
 private:
  inline void set_has_serial_type();
  inline void clear_has_serial_type();
  inline void set_has_band_rate();
  inline void clear_has_band_rate();
  inline void set_has_byte_size();
  inline void clear_has_byte_size();
  inline void set_has_stop_bits();
  inline void clear_has_stop_bits();
  inline void set_has_parity_check();
  inline void clear_has_parity_check();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int serial_type_;
  ::google::protobuf::uint32 band_rate_;
  ::google::protobuf::uint32 byte_size_;
  int stop_bits_;
  int parity_check_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVHDSerialCtrl* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUsbPartition : public ::google::protobuf::Message {
 public:
  TNVUsbPartition();
  virtual ~TNVUsbPartition();

  TNVUsbPartition(const TNVUsbPartition& from);

  inline TNVUsbPartition& operator=(const TNVUsbPartition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUsbPartition& default_instance();

  void Swap(TNVUsbPartition* other);

  // implements Message ----------------------------------------------

  TNVUsbPartition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUsbPartition& from);
  void MergeFrom(const TNVUsbPartition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 total_space = 3;
  inline bool has_total_space() const;
  inline void clear_total_space();
  static const int kTotalSpaceFieldNumber = 3;
  inline ::google::protobuf::uint32 total_space() const;
  inline void set_total_space(::google::protobuf::uint32 value);

  // optional uint32 free_space = 4;
  inline bool has_free_space() const;
  inline void clear_free_space();
  static const int kFreeSpaceFieldNumber = 4;
  inline ::google::protobuf::uint32 free_space() const;
  inline void set_free_space(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVUsbPartition)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_total_space();
  inline void clear_has_total_space();
  inline void set_has_free_space();
  inline void clear_has_free_space();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  ::std::string* name_;
  ::google::protobuf::uint32 total_space_;
  ::google::protobuf::uint32 free_space_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVUsbPartition* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUsbInfo : public ::google::protobuf::Message {
 public:
  TNVUsbInfo();
  virtual ~TNVUsbInfo();

  TNVUsbInfo(const TNVUsbInfo& from);

  inline TNVUsbInfo& operator=(const TNVUsbInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUsbInfo& default_instance();

  void Swap(TNVUsbInfo* other);

  // implements Message ----------------------------------------------

  TNVUsbInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUsbInfo& from);
  void MergeFrom(const TNVUsbInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 usb_id = 1;
  inline bool has_usb_id() const;
  inline void clear_usb_id();
  static const int kUsbIdFieldNumber = 1;
  inline ::google::protobuf::uint32 usb_id() const;
  inline void set_usb_id(::google::protobuf::uint32 value);

  // optional bool is_used = 2;
  inline bool has_is_used() const;
  inline void clear_is_used();
  static const int kIsUsedFieldNumber = 2;
  inline bool is_used() const;
  inline void set_is_used(bool value);

  // repeated .nv.TNVUsbPartition usb_partition = 3;
  inline int usb_partition_size() const;
  inline void clear_usb_partition();
  static const int kUsbPartitionFieldNumber = 3;
  inline const ::nv::TNVUsbPartition& usb_partition(int index) const;
  inline ::nv::TNVUsbPartition* mutable_usb_partition(int index);
  inline ::nv::TNVUsbPartition* add_usb_partition();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVUsbPartition >&
      usb_partition() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVUsbPartition >*
      mutable_usb_partition();

  // @@protoc_insertion_point(class_scope:nv.TNVUsbInfo)
 private:
  inline void set_has_usb_id();
  inline void clear_has_usb_id();
  inline void set_has_is_used();
  inline void clear_has_is_used();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 usb_id_;
  bool is_used_;
  ::google::protobuf::RepeatedPtrField< ::nv::TNVUsbPartition > usb_partition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVUsbInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUsbStatus : public ::google::protobuf::Message {
 public:
  TNVUsbStatus();
  virtual ~TNVUsbStatus();

  TNVUsbStatus(const TNVUsbStatus& from);

  inline TNVUsbStatus& operator=(const TNVUsbStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUsbStatus& default_instance();

  void Swap(TNVUsbStatus* other);

  // implements Message ----------------------------------------------

  TNVUsbStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUsbStatus& from);
  void MergeFrom(const TNVUsbStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVUsbInfo usb_info = 1;
  inline int usb_info_size() const;
  inline void clear_usb_info();
  static const int kUsbInfoFieldNumber = 1;
  inline const ::nv::TNVUsbInfo& usb_info(int index) const;
  inline ::nv::TNVUsbInfo* mutable_usb_info(int index);
  inline ::nv::TNVUsbInfo* add_usb_info();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVUsbInfo >&
      usb_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVUsbInfo >*
      mutable_usb_info();

  // @@protoc_insertion_point(class_scope:nv.TNVUsbStatus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVUsbInfo > usb_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVUsbStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVBrdInfo : public ::google::protobuf::Message {
 public:
  TNVBrdInfo();
  virtual ~TNVBrdInfo();

  TNVBrdInfo(const TNVBrdInfo& from);

  inline TNVBrdInfo& operator=(const TNVBrdInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVBrdInfo& default_instance();

  void Swap(TNVBrdInfo* other);

  // implements Message ----------------------------------------------

  TNVBrdInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVBrdInfo& from);
  void MergeFrom(const TNVBrdInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 brd_id = 2;
  inline bool has_brd_id() const;
  inline void clear_brd_id();
  static const int kBrdIdFieldNumber = 2;
  inline ::google::protobuf::uint32 brd_id() const;
  inline void set_brd_id(::google::protobuf::uint32 value);

  // optional uint32 brd_version = 3;
  inline bool has_brd_version() const;
  inline void clear_brd_version();
  static const int kBrdVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 brd_version() const;
  inline void set_brd_version(::google::protobuf::uint32 value);

  // optional uint32 pld_version = 4;
  inline bool has_pld_version() const;
  inline void clear_pld_version();
  static const int kPldVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 pld_version() const;
  inline void set_pld_version(::google::protobuf::uint32 value);

  // optional uint32 fpga_version = 5;
  inline bool has_fpga_version() const;
  inline void clear_fpga_version();
  static const int kFpgaVersionFieldNumber = 5;
  inline ::google::protobuf::uint32 fpga_version() const;
  inline void set_fpga_version(::google::protobuf::uint32 value);

  // optional int32 layer = 6;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 6;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // optional int32 slot = 7;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 7;
  inline ::google::protobuf::int32 slot() const;
  inline void set_slot(::google::protobuf::int32 value);

  // optional uint32 CpuNum = 8;
  inline bool has_cpunum() const;
  inline void clear_cpunum();
  static const int kCpuNumFieldNumber = 8;
  inline ::google::protobuf::uint32 cpunum() const;
  inline void set_cpunum(::google::protobuf::uint32 value);

  // optional uint32 CpuSelfNo = 9;
  inline bool has_cpuselfno() const;
  inline void clear_cpuselfno();
  static const int kCpuSelfNoFieldNumber = 9;
  inline ::google::protobuf::uint32 cpuselfno() const;
  inline void set_cpuselfno(::google::protobuf::uint32 value);

  // optional uint32 PldNum = 10;
  inline bool has_pldnum() const;
  inline void clear_pldnum();
  static const int kPldNumFieldNumber = 10;
  inline ::google::protobuf::uint32 pldnum() const;
  inline void set_pldnum(::google::protobuf::uint32 value);

  // optional uint32 FpgaNum = 11;
  inline bool has_fpganum() const;
  inline void clear_fpganum();
  static const int kFpgaNumFieldNumber = 11;
  inline ::google::protobuf::uint32 fpganum() const;
  inline void set_fpganum(::google::protobuf::uint32 value);

  // optional uint32 RtcNum = 12;
  inline bool has_rtcnum() const;
  inline void clear_rtcnum();
  static const int kRtcNumFieldNumber = 12;
  inline ::google::protobuf::uint32 rtcnum() const;
  inline void set_rtcnum(::google::protobuf::uint32 value);

  // optional uint32 EthNum = 13;
  inline bool has_ethnum() const;
  inline void clear_ethnum();
  static const int kEthNumFieldNumber = 13;
  inline ::google::protobuf::uint32 ethnum() const;
  inline void set_ethnum(::google::protobuf::uint32 value);

  // optional uint32 E1Num = 14;
  inline bool has_e1num() const;
  inline void clear_e1num();
  static const int kE1NumFieldNumber = 14;
  inline ::google::protobuf::uint32 e1num() const;
  inline void set_e1num(::google::protobuf::uint32 value);

  // optional uint32 V35Num = 15;
  inline bool has_v35num() const;
  inline void clear_v35num();
  static const int kV35NumFieldNumber = 15;
  inline ::google::protobuf::uint32 v35num() const;
  inline void set_v35num(::google::protobuf::uint32 value);

  // optional uint32 SerialNum = 16;
  inline bool has_serialnum() const;
  inline void clear_serialnum();
  static const int kSerialNumFieldNumber = 16;
  inline ::google::protobuf::uint32 serialnum() const;
  inline void set_serialnum(::google::protobuf::uint32 value);

  // optional uint32 FanNum = 17;
  inline bool has_fannum() const;
  inline void clear_fannum();
  static const int kFanNumFieldNumber = 17;
  inline ::google::protobuf::uint32 fannum() const;
  inline void set_fannum(::google::protobuf::uint32 value);

  // optional uint32 LedNum = 18;
  inline bool has_lednum() const;
  inline void clear_lednum();
  static const int kLedNumFieldNumber = 18;
  inline ::google::protobuf::uint32 lednum() const;
  inline void set_lednum(::google::protobuf::uint32 value);

  // optional uint32 ButtonNum = 19;
  inline bool has_buttonnum() const;
  inline void clear_buttonnum();
  static const int kButtonNumFieldNumber = 19;
  inline ::google::protobuf::uint32 buttonnum() const;
  inline void set_buttonnum(::google::protobuf::uint32 value);

  // optional uint32 HwmonNum = 20;
  inline bool has_hwmonnum() const;
  inline void clear_hwmonnum();
  static const int kHwmonNumFieldNumber = 20;
  inline ::google::protobuf::uint32 hwmonnum() const;
  inline void set_hwmonnum(::google::protobuf::uint32 value);

  // optional uint32 OledNum = 21;
  inline bool has_olednum() const;
  inline void clear_olednum();
  static const int kOledNumFieldNumber = 21;
  inline ::google::protobuf::uint32 olednum() const;
  inline void set_olednum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVBrdInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_brd_id();
  inline void clear_has_brd_id();
  inline void set_has_brd_version();
  inline void clear_has_brd_version();
  inline void set_has_pld_version();
  inline void clear_has_pld_version();
  inline void set_has_fpga_version();
  inline void clear_has_fpga_version();
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_slot();
  inline void clear_has_slot();
  inline void set_has_cpunum();
  inline void clear_has_cpunum();
  inline void set_has_cpuselfno();
  inline void clear_has_cpuselfno();
  inline void set_has_pldnum();
  inline void clear_has_pldnum();
  inline void set_has_fpganum();
  inline void clear_has_fpganum();
  inline void set_has_rtcnum();
  inline void clear_has_rtcnum();
  inline void set_has_ethnum();
  inline void clear_has_ethnum();
  inline void set_has_e1num();
  inline void clear_has_e1num();
  inline void set_has_v35num();
  inline void clear_has_v35num();
  inline void set_has_serialnum();
  inline void clear_has_serialnum();
  inline void set_has_fannum();
  inline void clear_has_fannum();
  inline void set_has_lednum();
  inline void clear_has_lednum();
  inline void set_has_buttonnum();
  inline void clear_has_buttonnum();
  inline void set_has_hwmonnum();
  inline void clear_has_hwmonnum();
  inline void set_has_olednum();
  inline void clear_has_olednum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 brd_id_;
  ::google::protobuf::uint32 brd_version_;
  ::google::protobuf::uint32 pld_version_;
  ::google::protobuf::uint32 fpga_version_;
  ::google::protobuf::int32 layer_;
  ::google::protobuf::int32 slot_;
  ::google::protobuf::uint32 cpunum_;
  ::google::protobuf::uint32 cpuselfno_;
  ::google::protobuf::uint32 pldnum_;
  ::google::protobuf::uint32 fpganum_;
  ::google::protobuf::uint32 rtcnum_;
  ::google::protobuf::uint32 ethnum_;
  ::google::protobuf::uint32 e1num_;
  ::google::protobuf::uint32 v35num_;
  ::google::protobuf::uint32 serialnum_;
  ::google::protobuf::uint32 fannum_;
  ::google::protobuf::uint32 lednum_;
  ::google::protobuf::uint32 buttonnum_;
  ::google::protobuf::uint32 hwmonnum_;
  ::google::protobuf::uint32 olednum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVBrdInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVCpuAndMemState : public ::google::protobuf::Message {
 public:
  TNVCpuAndMemState();
  virtual ~TNVCpuAndMemState();

  TNVCpuAndMemState(const TNVCpuAndMemState& from);

  inline TNVCpuAndMemState& operator=(const TNVCpuAndMemState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVCpuAndMemState& default_instance();

  void Swap(TNVCpuAndMemState* other);

  // implements Message ----------------------------------------------

  TNVCpuAndMemState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVCpuAndMemState& from);
  void MergeFrom(const TNVCpuAndMemState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cpu_idle_percent = 1;
  inline bool has_cpu_idle_percent() const;
  inline void clear_cpu_idle_percent();
  static const int kCpuIdlePercentFieldNumber = 1;
  inline ::google::protobuf::uint32 cpu_idle_percent() const;
  inline void set_cpu_idle_percent(::google::protobuf::uint32 value);

  // optional uint32 mem_total_size = 2;
  inline bool has_mem_total_size() const;
  inline void clear_mem_total_size();
  static const int kMemTotalSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 mem_total_size() const;
  inline void set_mem_total_size(::google::protobuf::uint32 value);

  // optional uint32 mem_alloc_size = 3;
  inline bool has_mem_alloc_size() const;
  inline void clear_mem_alloc_size();
  static const int kMemAllocSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 mem_alloc_size() const;
  inline void set_mem_alloc_size(::google::protobuf::uint32 value);

  // optional uint32 mem_free_size = 4;
  inline bool has_mem_free_size() const;
  inline void clear_mem_free_size();
  static const int kMemFreeSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 mem_free_size() const;
  inline void set_mem_free_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVCpuAndMemState)
 private:
  inline void set_has_cpu_idle_percent();
  inline void clear_has_cpu_idle_percent();
  inline void set_has_mem_total_size();
  inline void clear_has_mem_total_size();
  inline void set_has_mem_alloc_size();
  inline void clear_has_mem_alloc_size();
  inline void set_has_mem_free_size();
  inline void clear_has_mem_free_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cpu_idle_percent_;
  ::google::protobuf::uint32 mem_total_size_;
  ::google::protobuf::uint32 mem_alloc_size_;
  ::google::protobuf::uint32 mem_free_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVCpuAndMemState* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVNetCapFileInfo : public ::google::protobuf::Message {
 public:
  TNVNetCapFileInfo();
  virtual ~TNVNetCapFileInfo();

  TNVNetCapFileInfo(const TNVNetCapFileInfo& from);

  inline TNVNetCapFileInfo& operator=(const TNVNetCapFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVNetCapFileInfo& default_instance();

  void Swap(TNVNetCapFileInfo* other);

  // implements Message ----------------------------------------------

  TNVNetCapFileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVNetCapFileInfo& from);
  void MergeFrom(const TNVNetCapFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional uint32 file_size = 2;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVNetCapFileInfo)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_name_;
  ::google::protobuf::uint32 file_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVNetCapFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVNetCapFileList : public ::google::protobuf::Message {
 public:
  TNVNetCapFileList();
  virtual ~TNVNetCapFileList();

  TNVNetCapFileList(const TNVNetCapFileList& from);

  inline TNVNetCapFileList& operator=(const TNVNetCapFileList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVNetCapFileList& default_instance();

  void Swap(TNVNetCapFileList* other);

  // implements Message ----------------------------------------------

  TNVNetCapFileList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVNetCapFileList& from);
  void MergeFrom(const TNVNetCapFileList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  inline void set_allocated_file_path(::std::string* file_path);

  // repeated .nv.TNVNetCapFileInfo file_list = 2;
  inline int file_list_size() const;
  inline void clear_file_list();
  static const int kFileListFieldNumber = 2;
  inline const ::nv::TNVNetCapFileInfo& file_list(int index) const;
  inline ::nv::TNVNetCapFileInfo* mutable_file_list(int index);
  inline ::nv::TNVNetCapFileInfo* add_file_list();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVNetCapFileInfo >&
      file_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVNetCapFileInfo >*
      mutable_file_list();

  // @@protoc_insertion_point(class_scope:nv.TNVNetCapFileList)
 private:
  inline void set_has_file_path();
  inline void clear_has_file_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_path_;
  ::google::protobuf::RepeatedPtrField< ::nv::TNVNetCapFileInfo > file_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVNetCapFileList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVPathStructureUnit : public ::google::protobuf::Message {
 public:
  TNVPathStructureUnit();
  virtual ~TNVPathStructureUnit();

  TNVPathStructureUnit(const TNVPathStructureUnit& from);

  inline TNVPathStructureUnit& operator=(const TNVPathStructureUnit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVPathStructureUnit& default_instance();

  void Swap(TNVPathStructureUnit* other);

  // implements Message ----------------------------------------------

  TNVPathStructureUnit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVPathStructureUnit& from);
  void MergeFrom(const TNVPathStructureUnit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvSystemFileType file_type = 1;
  inline bool has_file_type() const;
  inline void clear_file_type();
  static const int kFileTypeFieldNumber = 1;
  inline ::nv::EmNvSystemFileType file_type() const;
  inline void set_file_type(::nv::EmNvSystemFileType value);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:nv.TNVPathStructureUnit)
 private:
  inline void set_has_file_type();
  inline void clear_has_file_type();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  int file_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVPathStructureUnit* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVPathStructureDetail : public ::google::protobuf::Message {
 public:
  TNVPathStructureDetail();
  virtual ~TNVPathStructureDetail();

  TNVPathStructureDetail(const TNVPathStructureDetail& from);

  inline TNVPathStructureDetail& operator=(const TNVPathStructureDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVPathStructureDetail& default_instance();

  void Swap(TNVPathStructureDetail* other);

  // implements Message ----------------------------------------------

  TNVPathStructureDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVPathStructureDetail& from);
  void MergeFrom(const TNVPathStructureDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVPathStructureUnit path_unit_list = 1;
  inline int path_unit_list_size() const;
  inline void clear_path_unit_list();
  static const int kPathUnitListFieldNumber = 1;
  inline const ::nv::TNVPathStructureUnit& path_unit_list(int index) const;
  inline ::nv::TNVPathStructureUnit* mutable_path_unit_list(int index);
  inline ::nv::TNVPathStructureUnit* add_path_unit_list();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVPathStructureUnit >&
      path_unit_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVPathStructureUnit >*
      mutable_path_unit_list();

  // @@protoc_insertion_point(class_scope:nv.TNVPathStructureDetail)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVPathStructureUnit > path_unit_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVPathStructureDetail* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVScreenParam : public ::google::protobuf::Message {
 public:
  TNVScreenParam();
  virtual ~TNVScreenParam();

  TNVScreenParam(const TNVScreenParam& from);

  inline TNVScreenParam& operator=(const TNVScreenParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVScreenParam& default_instance();

  void Swap(TNVScreenParam* other);

  // implements Message ----------------------------------------------

  TNVScreenParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVScreenParam& from);
  void MergeFrom(const TNVScreenParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 brightness = 1;
  inline bool has_brightness() const;
  inline void clear_brightness();
  static const int kBrightnessFieldNumber = 1;
  inline ::google::protobuf::uint32 brightness() const;
  inline void set_brightness(::google::protobuf::uint32 value);

  // optional uint32 contrast = 2;
  inline bool has_contrast() const;
  inline void clear_contrast();
  static const int kContrastFieldNumber = 2;
  inline ::google::protobuf::uint32 contrast() const;
  inline void set_contrast(::google::protobuf::uint32 value);

  // optional uint32 saturation = 3;
  inline bool has_saturation() const;
  inline void clear_saturation();
  static const int kSaturationFieldNumber = 3;
  inline ::google::protobuf::uint32 saturation() const;
  inline void set_saturation(::google::protobuf::uint32 value);

  // optional uint32 clarity = 4;
  inline bool has_clarity() const;
  inline void clear_clarity();
  static const int kClarityFieldNumber = 4;
  inline ::google::protobuf::uint32 clarity() const;
  inline void set_clarity(::google::protobuf::uint32 value);

  // optional .nv.EmNvScreenColorTemperature color_temp = 5;
  inline bool has_color_temp() const;
  inline void clear_color_temp();
  static const int kColorTempFieldNumber = 5;
  inline ::nv::EmNvScreenColorTemperature color_temp() const;
  inline void set_color_temp(::nv::EmNvScreenColorTemperature value);

  // optional .nv.EmNvTvDisplayRatio displayratio = 6;
  inline bool has_displayratio() const;
  inline void clear_displayratio();
  static const int kDisplayratioFieldNumber = 6;
  inline ::nv::EmNvTvDisplayRatio displayratio() const;
  inline void set_displayratio(::nv::EmNvTvDisplayRatio value);

  // optional .nv.EmNvScreenType screen_type = 7;
  inline bool has_screen_type() const;
  inline void clear_screen_type();
  static const int kScreenTypeFieldNumber = 7;
  inline ::nv::EmNvScreenType screen_type() const;
  inline void set_screen_type(::nv::EmNvScreenType value);

  // @@protoc_insertion_point(class_scope:nv.TNVScreenParam)
 private:
  inline void set_has_brightness();
  inline void clear_has_brightness();
  inline void set_has_contrast();
  inline void clear_has_contrast();
  inline void set_has_saturation();
  inline void clear_has_saturation();
  inline void set_has_clarity();
  inline void clear_has_clarity();
  inline void set_has_color_temp();
  inline void clear_has_color_temp();
  inline void set_has_displayratio();
  inline void clear_has_displayratio();
  inline void set_has_screen_type();
  inline void clear_has_screen_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 brightness_;
  ::google::protobuf::uint32 contrast_;
  ::google::protobuf::uint32 saturation_;
  ::google::protobuf::uint32 clarity_;
  int color_temp_;
  int displayratio_;
  int screen_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVScreenParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVScreenParamList : public ::google::protobuf::Message {
 public:
  TNVScreenParamList();
  virtual ~TNVScreenParamList();

  TNVScreenParamList(const TNVScreenParamList& from);

  inline TNVScreenParamList& operator=(const TNVScreenParamList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVScreenParamList& default_instance();

  void Swap(TNVScreenParamList* other);

  // implements Message ----------------------------------------------

  TNVScreenParamList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVScreenParamList& from);
  void MergeFrom(const TNVScreenParamList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVScreenParam screen = 1;
  inline int screen_size() const;
  inline void clear_screen();
  static const int kScreenFieldNumber = 1;
  inline const ::nv::TNVScreenParam& screen(int index) const;
  inline ::nv::TNVScreenParam* mutable_screen(int index);
  inline ::nv::TNVScreenParam* add_screen();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVScreenParam >&
      screen() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVScreenParam >*
      mutable_screen();

  // @@protoc_insertion_point(class_scope:nv.TNVScreenParamList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVScreenParam > screen_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructdevice_2eproto();
  friend void protobuf_AssignDesc_nvstructdevice_2eproto();
  friend void protobuf_ShutdownFile_nvstructdevice_2eproto();

  void InitAsDefaultInstance();
  static TNVScreenParamList* default_instance_;
};
// ===================================================================


// ===================================================================

// TNVKeyPressInfo

// optional bool key_type = 1;
inline bool TNVKeyPressInfo::has_key_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVKeyPressInfo::set_has_key_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVKeyPressInfo::clear_has_key_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVKeyPressInfo::clear_key_type() {
  key_type_ = false;
  clear_has_key_type();
}
inline bool TNVKeyPressInfo::key_type() const {
  return key_type_;
}
inline void TNVKeyPressInfo::set_key_type(bool value) {
  set_has_key_type();
  key_type_ = value;
}

// optional .nv.EmNvRemoteType key_source = 2;
inline bool TNVKeyPressInfo::has_key_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVKeyPressInfo::set_has_key_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVKeyPressInfo::clear_has_key_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVKeyPressInfo::clear_key_source() {
  key_source_ = 0;
  clear_has_key_source();
}
inline ::nv::EmNvRemoteType TNVKeyPressInfo::key_source() const {
  return static_cast< ::nv::EmNvRemoteType >(key_source_);
}
inline void TNVKeyPressInfo::set_key_source(::nv::EmNvRemoteType value) {
  assert(::nv::EmNvRemoteType_IsValid(value));
  set_has_key_source();
  key_source_ = value;
}

// optional .nv.EmNvRemoteScanCode key_code = 3;
inline bool TNVKeyPressInfo::has_key_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVKeyPressInfo::set_has_key_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVKeyPressInfo::clear_has_key_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVKeyPressInfo::clear_key_code() {
  key_code_ = 0;
  clear_has_key_code();
}
inline ::nv::EmNvRemoteScanCode TNVKeyPressInfo::key_code() const {
  return static_cast< ::nv::EmNvRemoteScanCode >(key_code_);
}
inline void TNVKeyPressInfo::set_key_code(::nv::EmNvRemoteScanCode value) {
  assert(::nv::EmNvRemoteScanCode_IsValid(value));
  set_has_key_code();
  key_code_ = value;
}

// optional uint32 key_count = 4;
inline bool TNVKeyPressInfo::has_key_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVKeyPressInfo::set_has_key_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVKeyPressInfo::clear_has_key_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVKeyPressInfo::clear_key_count() {
  key_count_ = 0u;
  clear_has_key_count();
}
inline ::google::protobuf::uint32 TNVKeyPressInfo::key_count() const {
  return key_count_;
}
inline void TNVKeyPressInfo::set_key_count(::google::protobuf::uint32 value) {
  set_has_key_count();
  key_count_ = value;
}

// -------------------------------------------------------------------

// TNVHDSerialCtrl

// optional .nv.EmNvSerialType serial_type = 1;
inline bool TNVHDSerialCtrl::has_serial_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVHDSerialCtrl::set_has_serial_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVHDSerialCtrl::clear_has_serial_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVHDSerialCtrl::clear_serial_type() {
  serial_type_ = 0;
  clear_has_serial_type();
}
inline ::nv::EmNvSerialType TNVHDSerialCtrl::serial_type() const {
  return static_cast< ::nv::EmNvSerialType >(serial_type_);
}
inline void TNVHDSerialCtrl::set_serial_type(::nv::EmNvSerialType value) {
  assert(::nv::EmNvSerialType_IsValid(value));
  set_has_serial_type();
  serial_type_ = value;
}

// optional uint32 band_rate = 2;
inline bool TNVHDSerialCtrl::has_band_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVHDSerialCtrl::set_has_band_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVHDSerialCtrl::clear_has_band_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVHDSerialCtrl::clear_band_rate() {
  band_rate_ = 0u;
  clear_has_band_rate();
}
inline ::google::protobuf::uint32 TNVHDSerialCtrl::band_rate() const {
  return band_rate_;
}
inline void TNVHDSerialCtrl::set_band_rate(::google::protobuf::uint32 value) {
  set_has_band_rate();
  band_rate_ = value;
}

// optional uint32 byte_size = 3;
inline bool TNVHDSerialCtrl::has_byte_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVHDSerialCtrl::set_has_byte_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVHDSerialCtrl::clear_has_byte_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVHDSerialCtrl::clear_byte_size() {
  byte_size_ = 0u;
  clear_has_byte_size();
}
inline ::google::protobuf::uint32 TNVHDSerialCtrl::byte_size() const {
  return byte_size_;
}
inline void TNVHDSerialCtrl::set_byte_size(::google::protobuf::uint32 value) {
  set_has_byte_size();
  byte_size_ = value;
}

// optional .nv.EmNvStopBits stop_bits = 4;
inline bool TNVHDSerialCtrl::has_stop_bits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVHDSerialCtrl::set_has_stop_bits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVHDSerialCtrl::clear_has_stop_bits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVHDSerialCtrl::clear_stop_bits() {
  stop_bits_ = 0;
  clear_has_stop_bits();
}
inline ::nv::EmNvStopBits TNVHDSerialCtrl::stop_bits() const {
  return static_cast< ::nv::EmNvStopBits >(stop_bits_);
}
inline void TNVHDSerialCtrl::set_stop_bits(::nv::EmNvStopBits value) {
  assert(::nv::EmNvStopBits_IsValid(value));
  set_has_stop_bits();
  stop_bits_ = value;
}

// optional .nv.EmNvParityCheck parity_check = 5;
inline bool TNVHDSerialCtrl::has_parity_check() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVHDSerialCtrl::set_has_parity_check() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVHDSerialCtrl::clear_has_parity_check() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVHDSerialCtrl::clear_parity_check() {
  parity_check_ = 0;
  clear_has_parity_check();
}
inline ::nv::EmNvParityCheck TNVHDSerialCtrl::parity_check() const {
  return static_cast< ::nv::EmNvParityCheck >(parity_check_);
}
inline void TNVHDSerialCtrl::set_parity_check(::nv::EmNvParityCheck value) {
  assert(::nv::EmNvParityCheck_IsValid(value));
  set_has_parity_check();
  parity_check_ = value;
}

// -------------------------------------------------------------------

// TNVUsbPartition

// optional string path = 1;
inline bool TNVUsbPartition::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUsbPartition::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUsbPartition::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUsbPartition::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TNVUsbPartition::path() const {
  return *path_;
}
inline void TNVUsbPartition::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TNVUsbPartition::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TNVUsbPartition::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUsbPartition::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TNVUsbPartition::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUsbPartition::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TNVUsbPartition::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUsbPartition::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUsbPartition::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUsbPartition::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TNVUsbPartition::name() const {
  return *name_;
}
inline void TNVUsbPartition::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TNVUsbPartition::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TNVUsbPartition::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUsbPartition::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TNVUsbPartition::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUsbPartition::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 total_space = 3;
inline bool TNVUsbPartition::has_total_space() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVUsbPartition::set_has_total_space() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVUsbPartition::clear_has_total_space() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVUsbPartition::clear_total_space() {
  total_space_ = 0u;
  clear_has_total_space();
}
inline ::google::protobuf::uint32 TNVUsbPartition::total_space() const {
  return total_space_;
}
inline void TNVUsbPartition::set_total_space(::google::protobuf::uint32 value) {
  set_has_total_space();
  total_space_ = value;
}

// optional uint32 free_space = 4;
inline bool TNVUsbPartition::has_free_space() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVUsbPartition::set_has_free_space() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVUsbPartition::clear_has_free_space() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVUsbPartition::clear_free_space() {
  free_space_ = 0u;
  clear_has_free_space();
}
inline ::google::protobuf::uint32 TNVUsbPartition::free_space() const {
  return free_space_;
}
inline void TNVUsbPartition::set_free_space(::google::protobuf::uint32 value) {
  set_has_free_space();
  free_space_ = value;
}

// -------------------------------------------------------------------

// TNVUsbInfo

// optional uint32 usb_id = 1;
inline bool TNVUsbInfo::has_usb_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUsbInfo::set_has_usb_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUsbInfo::clear_has_usb_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUsbInfo::clear_usb_id() {
  usb_id_ = 0u;
  clear_has_usb_id();
}
inline ::google::protobuf::uint32 TNVUsbInfo::usb_id() const {
  return usb_id_;
}
inline void TNVUsbInfo::set_usb_id(::google::protobuf::uint32 value) {
  set_has_usb_id();
  usb_id_ = value;
}

// optional bool is_used = 2;
inline bool TNVUsbInfo::has_is_used() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUsbInfo::set_has_is_used() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUsbInfo::clear_has_is_used() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUsbInfo::clear_is_used() {
  is_used_ = false;
  clear_has_is_used();
}
inline bool TNVUsbInfo::is_used() const {
  return is_used_;
}
inline void TNVUsbInfo::set_is_used(bool value) {
  set_has_is_used();
  is_used_ = value;
}

// repeated .nv.TNVUsbPartition usb_partition = 3;
inline int TNVUsbInfo::usb_partition_size() const {
  return usb_partition_.size();
}
inline void TNVUsbInfo::clear_usb_partition() {
  usb_partition_.Clear();
}
inline const ::nv::TNVUsbPartition& TNVUsbInfo::usb_partition(int index) const {
  return usb_partition_.Get(index);
}
inline ::nv::TNVUsbPartition* TNVUsbInfo::mutable_usb_partition(int index) {
  return usb_partition_.Mutable(index);
}
inline ::nv::TNVUsbPartition* TNVUsbInfo::add_usb_partition() {
  return usb_partition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVUsbPartition >&
TNVUsbInfo::usb_partition() const {
  return usb_partition_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVUsbPartition >*
TNVUsbInfo::mutable_usb_partition() {
  return &usb_partition_;
}

// -------------------------------------------------------------------

// TNVUsbStatus

// repeated .nv.TNVUsbInfo usb_info = 1;
inline int TNVUsbStatus::usb_info_size() const {
  return usb_info_.size();
}
inline void TNVUsbStatus::clear_usb_info() {
  usb_info_.Clear();
}
inline const ::nv::TNVUsbInfo& TNVUsbStatus::usb_info(int index) const {
  return usb_info_.Get(index);
}
inline ::nv::TNVUsbInfo* TNVUsbStatus::mutable_usb_info(int index) {
  return usb_info_.Mutable(index);
}
inline ::nv::TNVUsbInfo* TNVUsbStatus::add_usb_info() {
  return usb_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVUsbInfo >&
TNVUsbStatus::usb_info() const {
  return usb_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVUsbInfo >*
TNVUsbStatus::mutable_usb_info() {
  return &usb_info_;
}

// -------------------------------------------------------------------

// TNVBrdInfo

// optional string name = 1;
inline bool TNVBrdInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVBrdInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVBrdInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVBrdInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TNVBrdInfo::name() const {
  return *name_;
}
inline void TNVBrdInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TNVBrdInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TNVBrdInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVBrdInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TNVBrdInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVBrdInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 brd_id = 2;
inline bool TNVBrdInfo::has_brd_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVBrdInfo::set_has_brd_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVBrdInfo::clear_has_brd_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVBrdInfo::clear_brd_id() {
  brd_id_ = 0u;
  clear_has_brd_id();
}
inline ::google::protobuf::uint32 TNVBrdInfo::brd_id() const {
  return brd_id_;
}
inline void TNVBrdInfo::set_brd_id(::google::protobuf::uint32 value) {
  set_has_brd_id();
  brd_id_ = value;
}

// optional uint32 brd_version = 3;
inline bool TNVBrdInfo::has_brd_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVBrdInfo::set_has_brd_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVBrdInfo::clear_has_brd_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVBrdInfo::clear_brd_version() {
  brd_version_ = 0u;
  clear_has_brd_version();
}
inline ::google::protobuf::uint32 TNVBrdInfo::brd_version() const {
  return brd_version_;
}
inline void TNVBrdInfo::set_brd_version(::google::protobuf::uint32 value) {
  set_has_brd_version();
  brd_version_ = value;
}

// optional uint32 pld_version = 4;
inline bool TNVBrdInfo::has_pld_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVBrdInfo::set_has_pld_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVBrdInfo::clear_has_pld_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVBrdInfo::clear_pld_version() {
  pld_version_ = 0u;
  clear_has_pld_version();
}
inline ::google::protobuf::uint32 TNVBrdInfo::pld_version() const {
  return pld_version_;
}
inline void TNVBrdInfo::set_pld_version(::google::protobuf::uint32 value) {
  set_has_pld_version();
  pld_version_ = value;
}

// optional uint32 fpga_version = 5;
inline bool TNVBrdInfo::has_fpga_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVBrdInfo::set_has_fpga_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVBrdInfo::clear_has_fpga_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVBrdInfo::clear_fpga_version() {
  fpga_version_ = 0u;
  clear_has_fpga_version();
}
inline ::google::protobuf::uint32 TNVBrdInfo::fpga_version() const {
  return fpga_version_;
}
inline void TNVBrdInfo::set_fpga_version(::google::protobuf::uint32 value) {
  set_has_fpga_version();
  fpga_version_ = value;
}

// optional int32 layer = 6;
inline bool TNVBrdInfo::has_layer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVBrdInfo::set_has_layer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVBrdInfo::clear_has_layer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVBrdInfo::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 TNVBrdInfo::layer() const {
  return layer_;
}
inline void TNVBrdInfo::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// optional int32 slot = 7;
inline bool TNVBrdInfo::has_slot() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVBrdInfo::set_has_slot() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVBrdInfo::clear_has_slot() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVBrdInfo::clear_slot() {
  slot_ = 0;
  clear_has_slot();
}
inline ::google::protobuf::int32 TNVBrdInfo::slot() const {
  return slot_;
}
inline void TNVBrdInfo::set_slot(::google::protobuf::int32 value) {
  set_has_slot();
  slot_ = value;
}

// optional uint32 CpuNum = 8;
inline bool TNVBrdInfo::has_cpunum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVBrdInfo::set_has_cpunum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVBrdInfo::clear_has_cpunum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVBrdInfo::clear_cpunum() {
  cpunum_ = 0u;
  clear_has_cpunum();
}
inline ::google::protobuf::uint32 TNVBrdInfo::cpunum() const {
  return cpunum_;
}
inline void TNVBrdInfo::set_cpunum(::google::protobuf::uint32 value) {
  set_has_cpunum();
  cpunum_ = value;
}

// optional uint32 CpuSelfNo = 9;
inline bool TNVBrdInfo::has_cpuselfno() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVBrdInfo::set_has_cpuselfno() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVBrdInfo::clear_has_cpuselfno() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVBrdInfo::clear_cpuselfno() {
  cpuselfno_ = 0u;
  clear_has_cpuselfno();
}
inline ::google::protobuf::uint32 TNVBrdInfo::cpuselfno() const {
  return cpuselfno_;
}
inline void TNVBrdInfo::set_cpuselfno(::google::protobuf::uint32 value) {
  set_has_cpuselfno();
  cpuselfno_ = value;
}

// optional uint32 PldNum = 10;
inline bool TNVBrdInfo::has_pldnum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TNVBrdInfo::set_has_pldnum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TNVBrdInfo::clear_has_pldnum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TNVBrdInfo::clear_pldnum() {
  pldnum_ = 0u;
  clear_has_pldnum();
}
inline ::google::protobuf::uint32 TNVBrdInfo::pldnum() const {
  return pldnum_;
}
inline void TNVBrdInfo::set_pldnum(::google::protobuf::uint32 value) {
  set_has_pldnum();
  pldnum_ = value;
}

// optional uint32 FpgaNum = 11;
inline bool TNVBrdInfo::has_fpganum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TNVBrdInfo::set_has_fpganum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TNVBrdInfo::clear_has_fpganum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TNVBrdInfo::clear_fpganum() {
  fpganum_ = 0u;
  clear_has_fpganum();
}
inline ::google::protobuf::uint32 TNVBrdInfo::fpganum() const {
  return fpganum_;
}
inline void TNVBrdInfo::set_fpganum(::google::protobuf::uint32 value) {
  set_has_fpganum();
  fpganum_ = value;
}

// optional uint32 RtcNum = 12;
inline bool TNVBrdInfo::has_rtcnum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TNVBrdInfo::set_has_rtcnum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TNVBrdInfo::clear_has_rtcnum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TNVBrdInfo::clear_rtcnum() {
  rtcnum_ = 0u;
  clear_has_rtcnum();
}
inline ::google::protobuf::uint32 TNVBrdInfo::rtcnum() const {
  return rtcnum_;
}
inline void TNVBrdInfo::set_rtcnum(::google::protobuf::uint32 value) {
  set_has_rtcnum();
  rtcnum_ = value;
}

// optional uint32 EthNum = 13;
inline bool TNVBrdInfo::has_ethnum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TNVBrdInfo::set_has_ethnum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TNVBrdInfo::clear_has_ethnum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TNVBrdInfo::clear_ethnum() {
  ethnum_ = 0u;
  clear_has_ethnum();
}
inline ::google::protobuf::uint32 TNVBrdInfo::ethnum() const {
  return ethnum_;
}
inline void TNVBrdInfo::set_ethnum(::google::protobuf::uint32 value) {
  set_has_ethnum();
  ethnum_ = value;
}

// optional uint32 E1Num = 14;
inline bool TNVBrdInfo::has_e1num() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TNVBrdInfo::set_has_e1num() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TNVBrdInfo::clear_has_e1num() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TNVBrdInfo::clear_e1num() {
  e1num_ = 0u;
  clear_has_e1num();
}
inline ::google::protobuf::uint32 TNVBrdInfo::e1num() const {
  return e1num_;
}
inline void TNVBrdInfo::set_e1num(::google::protobuf::uint32 value) {
  set_has_e1num();
  e1num_ = value;
}

// optional uint32 V35Num = 15;
inline bool TNVBrdInfo::has_v35num() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TNVBrdInfo::set_has_v35num() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TNVBrdInfo::clear_has_v35num() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TNVBrdInfo::clear_v35num() {
  v35num_ = 0u;
  clear_has_v35num();
}
inline ::google::protobuf::uint32 TNVBrdInfo::v35num() const {
  return v35num_;
}
inline void TNVBrdInfo::set_v35num(::google::protobuf::uint32 value) {
  set_has_v35num();
  v35num_ = value;
}

// optional uint32 SerialNum = 16;
inline bool TNVBrdInfo::has_serialnum() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TNVBrdInfo::set_has_serialnum() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TNVBrdInfo::clear_has_serialnum() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TNVBrdInfo::clear_serialnum() {
  serialnum_ = 0u;
  clear_has_serialnum();
}
inline ::google::protobuf::uint32 TNVBrdInfo::serialnum() const {
  return serialnum_;
}
inline void TNVBrdInfo::set_serialnum(::google::protobuf::uint32 value) {
  set_has_serialnum();
  serialnum_ = value;
}

// optional uint32 FanNum = 17;
inline bool TNVBrdInfo::has_fannum() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TNVBrdInfo::set_has_fannum() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TNVBrdInfo::clear_has_fannum() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TNVBrdInfo::clear_fannum() {
  fannum_ = 0u;
  clear_has_fannum();
}
inline ::google::protobuf::uint32 TNVBrdInfo::fannum() const {
  return fannum_;
}
inline void TNVBrdInfo::set_fannum(::google::protobuf::uint32 value) {
  set_has_fannum();
  fannum_ = value;
}

// optional uint32 LedNum = 18;
inline bool TNVBrdInfo::has_lednum() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TNVBrdInfo::set_has_lednum() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TNVBrdInfo::clear_has_lednum() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TNVBrdInfo::clear_lednum() {
  lednum_ = 0u;
  clear_has_lednum();
}
inline ::google::protobuf::uint32 TNVBrdInfo::lednum() const {
  return lednum_;
}
inline void TNVBrdInfo::set_lednum(::google::protobuf::uint32 value) {
  set_has_lednum();
  lednum_ = value;
}

// optional uint32 ButtonNum = 19;
inline bool TNVBrdInfo::has_buttonnum() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TNVBrdInfo::set_has_buttonnum() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TNVBrdInfo::clear_has_buttonnum() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TNVBrdInfo::clear_buttonnum() {
  buttonnum_ = 0u;
  clear_has_buttonnum();
}
inline ::google::protobuf::uint32 TNVBrdInfo::buttonnum() const {
  return buttonnum_;
}
inline void TNVBrdInfo::set_buttonnum(::google::protobuf::uint32 value) {
  set_has_buttonnum();
  buttonnum_ = value;
}

// optional uint32 HwmonNum = 20;
inline bool TNVBrdInfo::has_hwmonnum() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TNVBrdInfo::set_has_hwmonnum() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TNVBrdInfo::clear_has_hwmonnum() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TNVBrdInfo::clear_hwmonnum() {
  hwmonnum_ = 0u;
  clear_has_hwmonnum();
}
inline ::google::protobuf::uint32 TNVBrdInfo::hwmonnum() const {
  return hwmonnum_;
}
inline void TNVBrdInfo::set_hwmonnum(::google::protobuf::uint32 value) {
  set_has_hwmonnum();
  hwmonnum_ = value;
}

// optional uint32 OledNum = 21;
inline bool TNVBrdInfo::has_olednum() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TNVBrdInfo::set_has_olednum() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TNVBrdInfo::clear_has_olednum() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TNVBrdInfo::clear_olednum() {
  olednum_ = 0u;
  clear_has_olednum();
}
inline ::google::protobuf::uint32 TNVBrdInfo::olednum() const {
  return olednum_;
}
inline void TNVBrdInfo::set_olednum(::google::protobuf::uint32 value) {
  set_has_olednum();
  olednum_ = value;
}

// -------------------------------------------------------------------

// TNVCpuAndMemState

// optional uint32 cpu_idle_percent = 1;
inline bool TNVCpuAndMemState::has_cpu_idle_percent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVCpuAndMemState::set_has_cpu_idle_percent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVCpuAndMemState::clear_has_cpu_idle_percent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVCpuAndMemState::clear_cpu_idle_percent() {
  cpu_idle_percent_ = 0u;
  clear_has_cpu_idle_percent();
}
inline ::google::protobuf::uint32 TNVCpuAndMemState::cpu_idle_percent() const {
  return cpu_idle_percent_;
}
inline void TNVCpuAndMemState::set_cpu_idle_percent(::google::protobuf::uint32 value) {
  set_has_cpu_idle_percent();
  cpu_idle_percent_ = value;
}

// optional uint32 mem_total_size = 2;
inline bool TNVCpuAndMemState::has_mem_total_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVCpuAndMemState::set_has_mem_total_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVCpuAndMemState::clear_has_mem_total_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVCpuAndMemState::clear_mem_total_size() {
  mem_total_size_ = 0u;
  clear_has_mem_total_size();
}
inline ::google::protobuf::uint32 TNVCpuAndMemState::mem_total_size() const {
  return mem_total_size_;
}
inline void TNVCpuAndMemState::set_mem_total_size(::google::protobuf::uint32 value) {
  set_has_mem_total_size();
  mem_total_size_ = value;
}

// optional uint32 mem_alloc_size = 3;
inline bool TNVCpuAndMemState::has_mem_alloc_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVCpuAndMemState::set_has_mem_alloc_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVCpuAndMemState::clear_has_mem_alloc_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVCpuAndMemState::clear_mem_alloc_size() {
  mem_alloc_size_ = 0u;
  clear_has_mem_alloc_size();
}
inline ::google::protobuf::uint32 TNVCpuAndMemState::mem_alloc_size() const {
  return mem_alloc_size_;
}
inline void TNVCpuAndMemState::set_mem_alloc_size(::google::protobuf::uint32 value) {
  set_has_mem_alloc_size();
  mem_alloc_size_ = value;
}

// optional uint32 mem_free_size = 4;
inline bool TNVCpuAndMemState::has_mem_free_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVCpuAndMemState::set_has_mem_free_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVCpuAndMemState::clear_has_mem_free_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVCpuAndMemState::clear_mem_free_size() {
  mem_free_size_ = 0u;
  clear_has_mem_free_size();
}
inline ::google::protobuf::uint32 TNVCpuAndMemState::mem_free_size() const {
  return mem_free_size_;
}
inline void TNVCpuAndMemState::set_mem_free_size(::google::protobuf::uint32 value) {
  set_has_mem_free_size();
  mem_free_size_ = value;
}

// -------------------------------------------------------------------

// TNVNetCapFileInfo

// optional string file_name = 1;
inline bool TNVNetCapFileInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVNetCapFileInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVNetCapFileInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVNetCapFileInfo::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& TNVNetCapFileInfo::file_name() const {
  return *file_name_;
}
inline void TNVNetCapFileInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TNVNetCapFileInfo::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TNVNetCapFileInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVNetCapFileInfo::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* TNVNetCapFileInfo::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVNetCapFileInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 file_size = 2;
inline bool TNVNetCapFileInfo::has_file_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVNetCapFileInfo::set_has_file_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVNetCapFileInfo::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVNetCapFileInfo::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 TNVNetCapFileInfo::file_size() const {
  return file_size_;
}
inline void TNVNetCapFileInfo::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
}

// -------------------------------------------------------------------

// TNVNetCapFileList

// optional string file_path = 1;
inline bool TNVNetCapFileList::has_file_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVNetCapFileList::set_has_file_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVNetCapFileList::clear_has_file_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVNetCapFileList::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& TNVNetCapFileList::file_path() const {
  return *file_path_;
}
inline void TNVNetCapFileList::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void TNVNetCapFileList::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void TNVNetCapFileList::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVNetCapFileList::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  return file_path_;
}
inline ::std::string* TNVNetCapFileList::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVNetCapFileList::set_allocated_file_path(::std::string* file_path) {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    delete file_path_;
  }
  if (file_path) {
    set_has_file_path();
    file_path_ = file_path;
  } else {
    clear_has_file_path();
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .nv.TNVNetCapFileInfo file_list = 2;
inline int TNVNetCapFileList::file_list_size() const {
  return file_list_.size();
}
inline void TNVNetCapFileList::clear_file_list() {
  file_list_.Clear();
}
inline const ::nv::TNVNetCapFileInfo& TNVNetCapFileList::file_list(int index) const {
  return file_list_.Get(index);
}
inline ::nv::TNVNetCapFileInfo* TNVNetCapFileList::mutable_file_list(int index) {
  return file_list_.Mutable(index);
}
inline ::nv::TNVNetCapFileInfo* TNVNetCapFileList::add_file_list() {
  return file_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVNetCapFileInfo >&
TNVNetCapFileList::file_list() const {
  return file_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVNetCapFileInfo >*
TNVNetCapFileList::mutable_file_list() {
  return &file_list_;
}

// -------------------------------------------------------------------

// TNVPathStructureUnit

// optional .nv.EmNvSystemFileType file_type = 1;
inline bool TNVPathStructureUnit::has_file_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVPathStructureUnit::set_has_file_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVPathStructureUnit::clear_has_file_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVPathStructureUnit::clear_file_type() {
  file_type_ = 0;
  clear_has_file_type();
}
inline ::nv::EmNvSystemFileType TNVPathStructureUnit::file_type() const {
  return static_cast< ::nv::EmNvSystemFileType >(file_type_);
}
inline void TNVPathStructureUnit::set_file_type(::nv::EmNvSystemFileType value) {
  assert(::nv::EmNvSystemFileType_IsValid(value));
  set_has_file_type();
  file_type_ = value;
}

// optional string path = 2;
inline bool TNVPathStructureUnit::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVPathStructureUnit::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVPathStructureUnit::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVPathStructureUnit::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TNVPathStructureUnit::path() const {
  return *path_;
}
inline void TNVPathStructureUnit::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TNVPathStructureUnit::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TNVPathStructureUnit::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVPathStructureUnit::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TNVPathStructureUnit::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVPathStructureUnit::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVPathStructureDetail

// repeated .nv.TNVPathStructureUnit path_unit_list = 1;
inline int TNVPathStructureDetail::path_unit_list_size() const {
  return path_unit_list_.size();
}
inline void TNVPathStructureDetail::clear_path_unit_list() {
  path_unit_list_.Clear();
}
inline const ::nv::TNVPathStructureUnit& TNVPathStructureDetail::path_unit_list(int index) const {
  return path_unit_list_.Get(index);
}
inline ::nv::TNVPathStructureUnit* TNVPathStructureDetail::mutable_path_unit_list(int index) {
  return path_unit_list_.Mutable(index);
}
inline ::nv::TNVPathStructureUnit* TNVPathStructureDetail::add_path_unit_list() {
  return path_unit_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVPathStructureUnit >&
TNVPathStructureDetail::path_unit_list() const {
  return path_unit_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVPathStructureUnit >*
TNVPathStructureDetail::mutable_path_unit_list() {
  return &path_unit_list_;
}

// -------------------------------------------------------------------

// TNVScreenParam

// optional uint32 brightness = 1;
inline bool TNVScreenParam::has_brightness() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVScreenParam::set_has_brightness() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVScreenParam::clear_has_brightness() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVScreenParam::clear_brightness() {
  brightness_ = 0u;
  clear_has_brightness();
}
inline ::google::protobuf::uint32 TNVScreenParam::brightness() const {
  return brightness_;
}
inline void TNVScreenParam::set_brightness(::google::protobuf::uint32 value) {
  set_has_brightness();
  brightness_ = value;
}

// optional uint32 contrast = 2;
inline bool TNVScreenParam::has_contrast() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVScreenParam::set_has_contrast() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVScreenParam::clear_has_contrast() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVScreenParam::clear_contrast() {
  contrast_ = 0u;
  clear_has_contrast();
}
inline ::google::protobuf::uint32 TNVScreenParam::contrast() const {
  return contrast_;
}
inline void TNVScreenParam::set_contrast(::google::protobuf::uint32 value) {
  set_has_contrast();
  contrast_ = value;
}

// optional uint32 saturation = 3;
inline bool TNVScreenParam::has_saturation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVScreenParam::set_has_saturation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVScreenParam::clear_has_saturation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVScreenParam::clear_saturation() {
  saturation_ = 0u;
  clear_has_saturation();
}
inline ::google::protobuf::uint32 TNVScreenParam::saturation() const {
  return saturation_;
}
inline void TNVScreenParam::set_saturation(::google::protobuf::uint32 value) {
  set_has_saturation();
  saturation_ = value;
}

// optional uint32 clarity = 4;
inline bool TNVScreenParam::has_clarity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVScreenParam::set_has_clarity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVScreenParam::clear_has_clarity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVScreenParam::clear_clarity() {
  clarity_ = 0u;
  clear_has_clarity();
}
inline ::google::protobuf::uint32 TNVScreenParam::clarity() const {
  return clarity_;
}
inline void TNVScreenParam::set_clarity(::google::protobuf::uint32 value) {
  set_has_clarity();
  clarity_ = value;
}

// optional .nv.EmNvScreenColorTemperature color_temp = 5;
inline bool TNVScreenParam::has_color_temp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVScreenParam::set_has_color_temp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVScreenParam::clear_has_color_temp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVScreenParam::clear_color_temp() {
  color_temp_ = 0;
  clear_has_color_temp();
}
inline ::nv::EmNvScreenColorTemperature TNVScreenParam::color_temp() const {
  return static_cast< ::nv::EmNvScreenColorTemperature >(color_temp_);
}
inline void TNVScreenParam::set_color_temp(::nv::EmNvScreenColorTemperature value) {
  assert(::nv::EmNvScreenColorTemperature_IsValid(value));
  set_has_color_temp();
  color_temp_ = value;
}

// optional .nv.EmNvTvDisplayRatio displayratio = 6;
inline bool TNVScreenParam::has_displayratio() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVScreenParam::set_has_displayratio() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVScreenParam::clear_has_displayratio() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVScreenParam::clear_displayratio() {
  displayratio_ = 0;
  clear_has_displayratio();
}
inline ::nv::EmNvTvDisplayRatio TNVScreenParam::displayratio() const {
  return static_cast< ::nv::EmNvTvDisplayRatio >(displayratio_);
}
inline void TNVScreenParam::set_displayratio(::nv::EmNvTvDisplayRatio value) {
  assert(::nv::EmNvTvDisplayRatio_IsValid(value));
  set_has_displayratio();
  displayratio_ = value;
}

// optional .nv.EmNvScreenType screen_type = 7;
inline bool TNVScreenParam::has_screen_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVScreenParam::set_has_screen_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVScreenParam::clear_has_screen_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVScreenParam::clear_screen_type() {
  screen_type_ = 0;
  clear_has_screen_type();
}
inline ::nv::EmNvScreenType TNVScreenParam::screen_type() const {
  return static_cast< ::nv::EmNvScreenType >(screen_type_);
}
inline void TNVScreenParam::set_screen_type(::nv::EmNvScreenType value) {
  assert(::nv::EmNvScreenType_IsValid(value));
  set_has_screen_type();
  screen_type_ = value;
}

// -------------------------------------------------------------------

// TNVScreenParamList

// repeated .nv.TNVScreenParam screen = 1;
inline int TNVScreenParamList::screen_size() const {
  return screen_.size();
}
inline void TNVScreenParamList::clear_screen() {
  screen_.Clear();
}
inline const ::nv::TNVScreenParam& TNVScreenParamList::screen(int index) const {
  return screen_.Get(index);
}
inline ::nv::TNVScreenParam* TNVScreenParamList::mutable_screen(int index) {
  return screen_.Mutable(index);
}
inline ::nv::TNVScreenParam* TNVScreenParamList::add_screen() {
  return screen_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVScreenParam >&
TNVScreenParamList::screen() const {
  return screen_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVScreenParam >*
TNVScreenParamList::mutable_screen() {
  return &screen_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nv

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nvstructdevice_2eproto__INCLUDED
