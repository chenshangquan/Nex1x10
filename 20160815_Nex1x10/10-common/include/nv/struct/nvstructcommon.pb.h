// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nvstructcommon.proto

#ifndef PROTOBUF_nvstructcommon_2eproto__INCLUDED
#define PROTOBUF_nvstructcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "nvenum.pb.h"
// @@protoc_insertion_point(includes)

namespace nv {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_nvstructcommon_2eproto();
void protobuf_AssignDesc_nvstructcommon_2eproto();
void protobuf_ShutdownFile_nvstructcommon_2eproto();

class TNVNetAddr;
class TNVRpNetAddr;
class TNVPrsParam;
class TNVEncryptKey;
class TNVTime;
class TNVSocks5Cfg;
class TNVAddr;
class TRpNvAddr;
class TNVAlias;
class TNVSubsMsgID;

// ===================================================================

class MTMSG_API TNVNetAddr : public ::google::protobuf::Message {
 public:
  TNVNetAddr();
  virtual ~TNVNetAddr();

  TNVNetAddr(const TNVNetAddr& from);

  inline TNVNetAddr& operator=(const TNVNetAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVNetAddr& default_instance();

  void Swap(TNVNetAddr* other);

  // implements Message ----------------------------------------------

  TNVNetAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVNetAddr& from);
  void MergeFrom(const TNVNetAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvIpAddrType ip_type = 1 [default = emNvIpV4];
  inline bool has_ip_type() const;
  inline void clear_ip_type();
  static const int kIpTypeFieldNumber = 1;
  inline ::nv::EmNvIpAddrType ip_type() const;
  inline void set_ip_type(::nv::EmNvIpAddrType value);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional bytes ip_v6 = 3;
  inline bool has_ip_v6() const;
  inline void clear_ip_v6();
  static const int kIpV6FieldNumber = 3;
  inline const ::std::string& ip_v6() const;
  inline void set_ip_v6(const ::std::string& value);
  inline void set_ip_v6(const char* value);
  inline void set_ip_v6(const void* value, size_t size);
  inline ::std::string* mutable_ip_v6();
  inline ::std::string* release_ip_v6();
  inline void set_allocated_ip_v6(::std::string* ip_v6);

  // optional uint32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVNetAddr)
 private:
  inline void set_has_ip_type();
  inline void clear_has_ip_type();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_ip_v6();
  inline void clear_has_ip_v6();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ip_type_;
  ::google::protobuf::uint32 ip_;
  ::std::string* ip_v6_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcommon_2eproto();
  friend void protobuf_AssignDesc_nvstructcommon_2eproto();
  friend void protobuf_ShutdownFile_nvstructcommon_2eproto();

  void InitAsDefaultInstance();
  static TNVNetAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVRpNetAddr : public ::google::protobuf::Message {
 public:
  TNVRpNetAddr();
  virtual ~TNVRpNetAddr();

  TNVRpNetAddr(const TNVRpNetAddr& from);

  inline TNVRpNetAddr& operator=(const TNVRpNetAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVRpNetAddr& default_instance();

  void Swap(TNVRpNetAddr* other);

  // implements Message ----------------------------------------------

  TNVRpNetAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVRpNetAddr& from);
  void MergeFrom(const TNVRpNetAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVNetAddr net_addr = 1;
  inline int net_addr_size() const;
  inline void clear_net_addr();
  static const int kNetAddrFieldNumber = 1;
  inline const ::nv::TNVNetAddr& net_addr(int index) const;
  inline ::nv::TNVNetAddr* mutable_net_addr(int index);
  inline ::nv::TNVNetAddr* add_net_addr();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVNetAddr >&
      net_addr() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVNetAddr >*
      mutable_net_addr();

  // @@protoc_insertion_point(class_scope:nv.TNVRpNetAddr)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVNetAddr > net_addr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcommon_2eproto();
  friend void protobuf_AssignDesc_nvstructcommon_2eproto();
  friend void protobuf_ShutdownFile_nvstructcommon_2eproto();

  void InitAsDefaultInstance();
  static TNVRpNetAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVPrsParam : public ::google::protobuf::Message {
 public:
  TNVPrsParam();
  virtual ~TNVPrsParam();

  TNVPrsParam(const TNVPrsParam& from);

  inline TNVPrsParam& operator=(const TNVPrsParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVPrsParam& default_instance();

  void Swap(TNVPrsParam* other);

  // implements Message ----------------------------------------------

  TNVPrsParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVPrsParam& from);
  void MergeFrom(const TNVPrsParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional uint32 first_time_span = 2 [default = 40];
  inline bool has_first_time_span() const;
  inline void clear_first_time_span();
  static const int kFirstTimeSpanFieldNumber = 2;
  inline ::google::protobuf::uint32 first_time_span() const;
  inline void set_first_time_span(::google::protobuf::uint32 value);

  // optional uint32 second_time_span = 3 [default = 80];
  inline bool has_second_time_span() const;
  inline void clear_second_time_span();
  static const int kSecondTimeSpanFieldNumber = 3;
  inline ::google::protobuf::uint32 second_time_span() const;
  inline void set_second_time_span(::google::protobuf::uint32 value);

  // optional uint32 third_time_span = 4 [default = 160];
  inline bool has_third_time_span() const;
  inline void clear_third_time_span();
  static const int kThirdTimeSpanFieldNumber = 4;
  inline ::google::protobuf::uint32 third_time_span() const;
  inline void set_third_time_span(::google::protobuf::uint32 value);

  // optional uint32 reject_time_span = 5 [default = 200];
  inline bool has_reject_time_span() const;
  inline void clear_reject_time_span();
  static const int kRejectTimeSpanFieldNumber = 5;
  inline ::google::protobuf::uint32 reject_time_span() const;
  inline void set_reject_time_span(::google::protobuf::uint32 value);

  // optional uint32 send_buf_time_span = 6 [default = 1000];
  inline bool has_send_buf_time_span() const;
  inline void clear_send_buf_time_span();
  static const int kSendBufTimeSpanFieldNumber = 6;
  inline ::google::protobuf::uint32 send_buf_time_span() const;
  inline void set_send_buf_time_span(::google::protobuf::uint32 value);

  // optional bool bUseSmoothSend = 7;
  inline bool has_busesmoothsend() const;
  inline void clear_busesmoothsend();
  static const int kBUseSmoothSendFieldNumber = 7;
  inline bool busesmoothsend() const;
  inline void set_busesmoothsend(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVPrsParam)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_first_time_span();
  inline void clear_has_first_time_span();
  inline void set_has_second_time_span();
  inline void clear_has_second_time_span();
  inline void set_has_third_time_span();
  inline void clear_has_third_time_span();
  inline void set_has_reject_time_span();
  inline void clear_has_reject_time_span();
  inline void set_has_send_buf_time_span();
  inline void clear_has_send_buf_time_span();
  inline void set_has_busesmoothsend();
  inline void clear_has_busesmoothsend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 first_time_span_;
  ::google::protobuf::uint32 second_time_span_;
  ::google::protobuf::uint32 third_time_span_;
  bool enable_;
  bool busesmoothsend_;
  ::google::protobuf::uint32 reject_time_span_;
  ::google::protobuf::uint32 send_buf_time_span_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcommon_2eproto();
  friend void protobuf_AssignDesc_nvstructcommon_2eproto();
  friend void protobuf_ShutdownFile_nvstructcommon_2eproto();

  void InitAsDefaultInstance();
  static TNVPrsParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVEncryptKey : public ::google::protobuf::Message {
 public:
  TNVEncryptKey();
  virtual ~TNVEncryptKey();

  TNVEncryptKey(const TNVEncryptKey& from);

  inline TNVEncryptKey& operator=(const TNVEncryptKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVEncryptKey& default_instance();

  void Swap(TNVEncryptKey* other);

  // implements Message ----------------------------------------------

  TNVEncryptKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVEncryptKey& from);
  void MergeFrom(const TNVEncryptKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:nv.TNVEncryptKey)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcommon_2eproto();
  friend void protobuf_AssignDesc_nvstructcommon_2eproto();
  friend void protobuf_ShutdownFile_nvstructcommon_2eproto();

  void InitAsDefaultInstance();
  static TNVEncryptKey* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVTime : public ::google::protobuf::Message {
 public:
  TNVTime();
  virtual ~TNVTime();

  TNVTime(const TNVTime& from);

  inline TNVTime& operator=(const TNVTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVTime& default_instance();

  void Swap(TNVTime* other);

  // implements Message ----------------------------------------------

  TNVTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVTime& from);
  void MergeFrom(const TNVTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 year = 1;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 1;
  inline ::google::protobuf::uint32 year() const;
  inline void set_year(::google::protobuf::uint32 value);

  // optional uint32 month = 2;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 2;
  inline ::google::protobuf::uint32 month() const;
  inline void set_month(::google::protobuf::uint32 value);

  // optional uint32 day = 3;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // optional uint32 hour = 4;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 4;
  inline ::google::protobuf::uint32 hour() const;
  inline void set_hour(::google::protobuf::uint32 value);

  // optional uint32 minute = 5;
  inline bool has_minute() const;
  inline void clear_minute();
  static const int kMinuteFieldNumber = 5;
  inline ::google::protobuf::uint32 minute() const;
  inline void set_minute(::google::protobuf::uint32 value);

  // optional uint32 second = 6;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 6;
  inline ::google::protobuf::uint32 second() const;
  inline void set_second(::google::protobuf::uint32 value);

  // optional uint32 microsecond = 7;
  inline bool has_microsecond() const;
  inline void clear_microsecond();
  static const int kMicrosecondFieldNumber = 7;
  inline ::google::protobuf::uint32 microsecond() const;
  inline void set_microsecond(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVTime)
 private:
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_minute();
  inline void clear_has_minute();
  inline void set_has_second();
  inline void clear_has_second();
  inline void set_has_microsecond();
  inline void clear_has_microsecond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 year_;
  ::google::protobuf::uint32 month_;
  ::google::protobuf::uint32 day_;
  ::google::protobuf::uint32 hour_;
  ::google::protobuf::uint32 minute_;
  ::google::protobuf::uint32 second_;
  ::google::protobuf::uint32 microsecond_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcommon_2eproto();
  friend void protobuf_AssignDesc_nvstructcommon_2eproto();
  friend void protobuf_ShutdownFile_nvstructcommon_2eproto();

  void InitAsDefaultInstance();
  static TNVTime* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVSocks5Cfg : public ::google::protobuf::Message {
 public:
  TNVSocks5Cfg();
  virtual ~TNVSocks5Cfg();

  TNVSocks5Cfg(const TNVSocks5Cfg& from);

  inline TNVSocks5Cfg& operator=(const TNVSocks5Cfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVSocks5Cfg& default_instance();

  void Swap(TNVSocks5Cfg* other);

  // implements Message ----------------------------------------------

  TNVSocks5Cfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVSocks5Cfg& from);
  void MergeFrom(const TNVSocks5Cfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.TNVNetAddr server_ip = 1;
  inline bool has_server_ip() const;
  inline void clear_server_ip();
  static const int kServerIpFieldNumber = 1;
  inline const ::nv::TNVNetAddr& server_ip() const;
  inline ::nv::TNVNetAddr* mutable_server_ip();
  inline ::nv::TNVNetAddr* release_server_ip();
  inline void set_allocated_server_ip(::nv::TNVNetAddr* server_ip);

  // optional string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string pwd = 3;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 3;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // @@protoc_insertion_point(class_scope:nv.TNVSocks5Cfg)
 private:
  inline void set_has_server_ip();
  inline void clear_has_server_ip();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_pwd();
  inline void clear_has_pwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::nv::TNVNetAddr* server_ip_;
  ::std::string* user_name_;
  ::std::string* pwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcommon_2eproto();
  friend void protobuf_AssignDesc_nvstructcommon_2eproto();
  friend void protobuf_ShutdownFile_nvstructcommon_2eproto();

  void InitAsDefaultInstance();
  static TNVSocks5Cfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVAddr : public ::google::protobuf::Message {
 public:
  TNVAddr();
  virtual ~TNVAddr();

  TNVAddr(const TNVAddr& from);

  inline TNVAddr& operator=(const TNVAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVAddr& default_instance();

  void Swap(TNVAddr* other);

  // implements Message ----------------------------------------------

  TNVAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVAddr& from);
  void MergeFrom(const TNVAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvAddrType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::nv::EmNvAddrType type() const;
  inline void set_type(::nv::EmNvAddrType value);

  // optional .nv.TNVNetAddr ip_addr = 2;
  inline bool has_ip_addr() const;
  inline void clear_ip_addr();
  static const int kIpAddrFieldNumber = 2;
  inline const ::nv::TNVNetAddr& ip_addr() const;
  inline ::nv::TNVNetAddr* mutable_ip_addr();
  inline ::nv::TNVNetAddr* release_ip_addr();
  inline void set_allocated_ip_addr(::nv::TNVNetAddr* ip_addr);

  // optional string alias = 3;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 3;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // @@protoc_insertion_point(class_scope:nv.TNVAddr)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ip_addr();
  inline void clear_has_ip_addr();
  inline void set_has_alias();
  inline void clear_has_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::nv::TNVNetAddr* ip_addr_;
  ::std::string* alias_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcommon_2eproto();
  friend void protobuf_AssignDesc_nvstructcommon_2eproto();
  friend void protobuf_ShutdownFile_nvstructcommon_2eproto();

  void InitAsDefaultInstance();
  static TNVAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TRpNvAddr : public ::google::protobuf::Message {
 public:
  TRpNvAddr();
  virtual ~TRpNvAddr();

  TRpNvAddr(const TRpNvAddr& from);

  inline TRpNvAddr& operator=(const TRpNvAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpNvAddr& default_instance();

  void Swap(TRpNvAddr* other);

  // implements Message ----------------------------------------------

  TRpNvAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpNvAddr& from);
  void MergeFrom(const TRpNvAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVAddr nv_addr = 1;
  inline int nv_addr_size() const;
  inline void clear_nv_addr();
  static const int kNvAddrFieldNumber = 1;
  inline const ::nv::TNVAddr& nv_addr(int index) const;
  inline ::nv::TNVAddr* mutable_nv_addr(int index);
  inline ::nv::TNVAddr* add_nv_addr();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVAddr >&
      nv_addr() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVAddr >*
      mutable_nv_addr();

  // @@protoc_insertion_point(class_scope:nv.TRpNvAddr)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVAddr > nv_addr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcommon_2eproto();
  friend void protobuf_AssignDesc_nvstructcommon_2eproto();
  friend void protobuf_ShutdownFile_nvstructcommon_2eproto();

  void InitAsDefaultInstance();
  static TRpNvAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVAlias : public ::google::protobuf::Message {
 public:
  TNVAlias();
  virtual ~TNVAlias();

  TNVAlias(const TNVAlias& from);

  inline TNVAlias& operator=(const TNVAlias& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVAlias& default_instance();

  void Swap(TNVAlias* other);

  // implements Message ----------------------------------------------

  TNVAlias* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVAlias& from);
  void MergeFrom(const TNVAlias& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvAliasType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::nv::EmNvAliasType type() const;
  inline void set_type(::nv::EmNvAliasType value);

  // optional string alias = 2;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 2;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // @@protoc_insertion_point(class_scope:nv.TNVAlias)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_alias();
  inline void clear_has_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alias_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcommon_2eproto();
  friend void protobuf_AssignDesc_nvstructcommon_2eproto();
  friend void protobuf_ShutdownFile_nvstructcommon_2eproto();

  void InitAsDefaultInstance();
  static TNVAlias* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVSubsMsgID : public ::google::protobuf::Message {
 public:
  TNVSubsMsgID();
  virtual ~TNVSubsMsgID();

  TNVSubsMsgID(const TNVSubsMsgID& from);

  inline TNVSubsMsgID& operator=(const TNVSubsMsgID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVSubsMsgID& default_instance();

  void Swap(TNVSubsMsgID* other);

  // implements Message ----------------------------------------------

  TNVSubsMsgID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVSubsMsgID& from);
  void MergeFrom(const TNVSubsMsgID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string msgid = 1;
  inline int msgid_size() const;
  inline void clear_msgid();
  static const int kMsgidFieldNumber = 1;
  inline const ::std::string& msgid(int index) const;
  inline ::std::string* mutable_msgid(int index);
  inline void set_msgid(int index, const ::std::string& value);
  inline void set_msgid(int index, const char* value);
  inline void set_msgid(int index, const char* value, size_t size);
  inline ::std::string* add_msgid();
  inline void add_msgid(const ::std::string& value);
  inline void add_msgid(const char* value);
  inline void add_msgid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& msgid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_msgid();

  // @@protoc_insertion_point(class_scope:nv.TNVSubsMsgID)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> msgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcommon_2eproto();
  friend void protobuf_AssignDesc_nvstructcommon_2eproto();
  friend void protobuf_ShutdownFile_nvstructcommon_2eproto();

  void InitAsDefaultInstance();
  static TNVSubsMsgID* default_instance_;
};
// ===================================================================


// ===================================================================

// TNVNetAddr

// optional .nv.EmNvIpAddrType ip_type = 1 [default = emNvIpV4];
inline bool TNVNetAddr::has_ip_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVNetAddr::set_has_ip_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVNetAddr::clear_has_ip_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVNetAddr::clear_ip_type() {
  ip_type_ = 0;
  clear_has_ip_type();
}
inline ::nv::EmNvIpAddrType TNVNetAddr::ip_type() const {
  return static_cast< ::nv::EmNvIpAddrType >(ip_type_);
}
inline void TNVNetAddr::set_ip_type(::nv::EmNvIpAddrType value) {
  assert(::nv::EmNvIpAddrType_IsValid(value));
  set_has_ip_type();
  ip_type_ = value;
}

// optional uint32 ip = 2;
inline bool TNVNetAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVNetAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVNetAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVNetAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TNVNetAddr::ip() const {
  return ip_;
}
inline void TNVNetAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional bytes ip_v6 = 3;
inline bool TNVNetAddr::has_ip_v6() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVNetAddr::set_has_ip_v6() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVNetAddr::clear_has_ip_v6() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVNetAddr::clear_ip_v6() {
  if (ip_v6_ != &::google::protobuf::internal::kEmptyString) {
    ip_v6_->clear();
  }
  clear_has_ip_v6();
}
inline const ::std::string& TNVNetAddr::ip_v6() const {
  return *ip_v6_;
}
inline void TNVNetAddr::set_ip_v6(const ::std::string& value) {
  set_has_ip_v6();
  if (ip_v6_ == &::google::protobuf::internal::kEmptyString) {
    ip_v6_ = new ::std::string;
  }
  ip_v6_->assign(value);
}
inline void TNVNetAddr::set_ip_v6(const char* value) {
  set_has_ip_v6();
  if (ip_v6_ == &::google::protobuf::internal::kEmptyString) {
    ip_v6_ = new ::std::string;
  }
  ip_v6_->assign(value);
}
inline void TNVNetAddr::set_ip_v6(const void* value, size_t size) {
  set_has_ip_v6();
  if (ip_v6_ == &::google::protobuf::internal::kEmptyString) {
    ip_v6_ = new ::std::string;
  }
  ip_v6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVNetAddr::mutable_ip_v6() {
  set_has_ip_v6();
  if (ip_v6_ == &::google::protobuf::internal::kEmptyString) {
    ip_v6_ = new ::std::string;
  }
  return ip_v6_;
}
inline ::std::string* TNVNetAddr::release_ip_v6() {
  clear_has_ip_v6();
  if (ip_v6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_v6_;
    ip_v6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVNetAddr::set_allocated_ip_v6(::std::string* ip_v6) {
  if (ip_v6_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_v6_;
  }
  if (ip_v6) {
    set_has_ip_v6();
    ip_v6_ = ip_v6;
  } else {
    clear_has_ip_v6();
    ip_v6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 4;
inline bool TNVNetAddr::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVNetAddr::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVNetAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVNetAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TNVNetAddr::port() const {
  return port_;
}
inline void TNVNetAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TNVRpNetAddr

// repeated .nv.TNVNetAddr net_addr = 1;
inline int TNVRpNetAddr::net_addr_size() const {
  return net_addr_.size();
}
inline void TNVRpNetAddr::clear_net_addr() {
  net_addr_.Clear();
}
inline const ::nv::TNVNetAddr& TNVRpNetAddr::net_addr(int index) const {
  return net_addr_.Get(index);
}
inline ::nv::TNVNetAddr* TNVRpNetAddr::mutable_net_addr(int index) {
  return net_addr_.Mutable(index);
}
inline ::nv::TNVNetAddr* TNVRpNetAddr::add_net_addr() {
  return net_addr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVNetAddr >&
TNVRpNetAddr::net_addr() const {
  return net_addr_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVNetAddr >*
TNVRpNetAddr::mutable_net_addr() {
  return &net_addr_;
}

// -------------------------------------------------------------------

// TNVPrsParam

// optional bool enable = 1;
inline bool TNVPrsParam::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVPrsParam::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVPrsParam::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVPrsParam::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TNVPrsParam::enable() const {
  return enable_;
}
inline void TNVPrsParam::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional uint32 first_time_span = 2 [default = 40];
inline bool TNVPrsParam::has_first_time_span() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVPrsParam::set_has_first_time_span() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVPrsParam::clear_has_first_time_span() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVPrsParam::clear_first_time_span() {
  first_time_span_ = 40u;
  clear_has_first_time_span();
}
inline ::google::protobuf::uint32 TNVPrsParam::first_time_span() const {
  return first_time_span_;
}
inline void TNVPrsParam::set_first_time_span(::google::protobuf::uint32 value) {
  set_has_first_time_span();
  first_time_span_ = value;
}

// optional uint32 second_time_span = 3 [default = 80];
inline bool TNVPrsParam::has_second_time_span() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVPrsParam::set_has_second_time_span() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVPrsParam::clear_has_second_time_span() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVPrsParam::clear_second_time_span() {
  second_time_span_ = 80u;
  clear_has_second_time_span();
}
inline ::google::protobuf::uint32 TNVPrsParam::second_time_span() const {
  return second_time_span_;
}
inline void TNVPrsParam::set_second_time_span(::google::protobuf::uint32 value) {
  set_has_second_time_span();
  second_time_span_ = value;
}

// optional uint32 third_time_span = 4 [default = 160];
inline bool TNVPrsParam::has_third_time_span() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVPrsParam::set_has_third_time_span() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVPrsParam::clear_has_third_time_span() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVPrsParam::clear_third_time_span() {
  third_time_span_ = 160u;
  clear_has_third_time_span();
}
inline ::google::protobuf::uint32 TNVPrsParam::third_time_span() const {
  return third_time_span_;
}
inline void TNVPrsParam::set_third_time_span(::google::protobuf::uint32 value) {
  set_has_third_time_span();
  third_time_span_ = value;
}

// optional uint32 reject_time_span = 5 [default = 200];
inline bool TNVPrsParam::has_reject_time_span() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVPrsParam::set_has_reject_time_span() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVPrsParam::clear_has_reject_time_span() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVPrsParam::clear_reject_time_span() {
  reject_time_span_ = 200u;
  clear_has_reject_time_span();
}
inline ::google::protobuf::uint32 TNVPrsParam::reject_time_span() const {
  return reject_time_span_;
}
inline void TNVPrsParam::set_reject_time_span(::google::protobuf::uint32 value) {
  set_has_reject_time_span();
  reject_time_span_ = value;
}

// optional uint32 send_buf_time_span = 6 [default = 1000];
inline bool TNVPrsParam::has_send_buf_time_span() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVPrsParam::set_has_send_buf_time_span() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVPrsParam::clear_has_send_buf_time_span() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVPrsParam::clear_send_buf_time_span() {
  send_buf_time_span_ = 1000u;
  clear_has_send_buf_time_span();
}
inline ::google::protobuf::uint32 TNVPrsParam::send_buf_time_span() const {
  return send_buf_time_span_;
}
inline void TNVPrsParam::set_send_buf_time_span(::google::protobuf::uint32 value) {
  set_has_send_buf_time_span();
  send_buf_time_span_ = value;
}

// optional bool bUseSmoothSend = 7;
inline bool TNVPrsParam::has_busesmoothsend() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVPrsParam::set_has_busesmoothsend() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVPrsParam::clear_has_busesmoothsend() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVPrsParam::clear_busesmoothsend() {
  busesmoothsend_ = false;
  clear_has_busesmoothsend();
}
inline bool TNVPrsParam::busesmoothsend() const {
  return busesmoothsend_;
}
inline void TNVPrsParam::set_busesmoothsend(bool value) {
  set_has_busesmoothsend();
  busesmoothsend_ = value;
}

// -------------------------------------------------------------------

// TNVEncryptKey

// optional bytes key = 1;
inline bool TNVEncryptKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVEncryptKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVEncryptKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVEncryptKey::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& TNVEncryptKey::key() const {
  return *key_;
}
inline void TNVEncryptKey::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TNVEncryptKey::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TNVEncryptKey::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVEncryptKey::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* TNVEncryptKey::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVEncryptKey::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVTime

// optional uint32 year = 1;
inline bool TNVTime::has_year() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVTime::set_has_year() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVTime::clear_has_year() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVTime::clear_year() {
  year_ = 0u;
  clear_has_year();
}
inline ::google::protobuf::uint32 TNVTime::year() const {
  return year_;
}
inline void TNVTime::set_year(::google::protobuf::uint32 value) {
  set_has_year();
  year_ = value;
}

// optional uint32 month = 2;
inline bool TNVTime::has_month() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVTime::set_has_month() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVTime::clear_has_month() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVTime::clear_month() {
  month_ = 0u;
  clear_has_month();
}
inline ::google::protobuf::uint32 TNVTime::month() const {
  return month_;
}
inline void TNVTime::set_month(::google::protobuf::uint32 value) {
  set_has_month();
  month_ = value;
}

// optional uint32 day = 3;
inline bool TNVTime::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVTime::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVTime::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVTime::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 TNVTime::day() const {
  return day_;
}
inline void TNVTime::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// optional uint32 hour = 4;
inline bool TNVTime::has_hour() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVTime::set_has_hour() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVTime::clear_has_hour() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVTime::clear_hour() {
  hour_ = 0u;
  clear_has_hour();
}
inline ::google::protobuf::uint32 TNVTime::hour() const {
  return hour_;
}
inline void TNVTime::set_hour(::google::protobuf::uint32 value) {
  set_has_hour();
  hour_ = value;
}

// optional uint32 minute = 5;
inline bool TNVTime::has_minute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVTime::set_has_minute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVTime::clear_has_minute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVTime::clear_minute() {
  minute_ = 0u;
  clear_has_minute();
}
inline ::google::protobuf::uint32 TNVTime::minute() const {
  return minute_;
}
inline void TNVTime::set_minute(::google::protobuf::uint32 value) {
  set_has_minute();
  minute_ = value;
}

// optional uint32 second = 6;
inline bool TNVTime::has_second() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVTime::set_has_second() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVTime::clear_has_second() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVTime::clear_second() {
  second_ = 0u;
  clear_has_second();
}
inline ::google::protobuf::uint32 TNVTime::second() const {
  return second_;
}
inline void TNVTime::set_second(::google::protobuf::uint32 value) {
  set_has_second();
  second_ = value;
}

// optional uint32 microsecond = 7;
inline bool TNVTime::has_microsecond() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVTime::set_has_microsecond() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVTime::clear_has_microsecond() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVTime::clear_microsecond() {
  microsecond_ = 0u;
  clear_has_microsecond();
}
inline ::google::protobuf::uint32 TNVTime::microsecond() const {
  return microsecond_;
}
inline void TNVTime::set_microsecond(::google::protobuf::uint32 value) {
  set_has_microsecond();
  microsecond_ = value;
}

// -------------------------------------------------------------------

// TNVSocks5Cfg

// optional .nv.TNVNetAddr server_ip = 1;
inline bool TNVSocks5Cfg::has_server_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVSocks5Cfg::set_has_server_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVSocks5Cfg::clear_has_server_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVSocks5Cfg::clear_server_ip() {
  if (server_ip_ != NULL) server_ip_->::nv::TNVNetAddr::Clear();
  clear_has_server_ip();
}
inline const ::nv::TNVNetAddr& TNVSocks5Cfg::server_ip() const {
  return server_ip_ != NULL ? *server_ip_ : *default_instance_->server_ip_;
}
inline ::nv::TNVNetAddr* TNVSocks5Cfg::mutable_server_ip() {
  set_has_server_ip();
  if (server_ip_ == NULL) server_ip_ = new ::nv::TNVNetAddr;
  return server_ip_;
}
inline ::nv::TNVNetAddr* TNVSocks5Cfg::release_server_ip() {
  clear_has_server_ip();
  ::nv::TNVNetAddr* temp = server_ip_;
  server_ip_ = NULL;
  return temp;
}
inline void TNVSocks5Cfg::set_allocated_server_ip(::nv::TNVNetAddr* server_ip) {
  delete server_ip_;
  server_ip_ = server_ip;
  if (server_ip) {
    set_has_server_ip();
  } else {
    clear_has_server_ip();
  }
}

// optional string user_name = 2;
inline bool TNVSocks5Cfg::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVSocks5Cfg::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVSocks5Cfg::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVSocks5Cfg::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TNVSocks5Cfg::user_name() const {
  return *user_name_;
}
inline void TNVSocks5Cfg::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVSocks5Cfg::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVSocks5Cfg::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSocks5Cfg::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TNVSocks5Cfg::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVSocks5Cfg::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pwd = 3;
inline bool TNVSocks5Cfg::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVSocks5Cfg::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVSocks5Cfg::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVSocks5Cfg::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& TNVSocks5Cfg::pwd() const {
  return *pwd_;
}
inline void TNVSocks5Cfg::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void TNVSocks5Cfg::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void TNVSocks5Cfg::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSocks5Cfg::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* TNVSocks5Cfg::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVSocks5Cfg::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVAddr

// optional .nv.EmNvAddrType type = 1;
inline bool TNVAddr::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVAddr::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVAddr::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVAddr::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::nv::EmNvAddrType TNVAddr::type() const {
  return static_cast< ::nv::EmNvAddrType >(type_);
}
inline void TNVAddr::set_type(::nv::EmNvAddrType value) {
  assert(::nv::EmNvAddrType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .nv.TNVNetAddr ip_addr = 2;
inline bool TNVAddr::has_ip_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVAddr::set_has_ip_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVAddr::clear_has_ip_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVAddr::clear_ip_addr() {
  if (ip_addr_ != NULL) ip_addr_->::nv::TNVNetAddr::Clear();
  clear_has_ip_addr();
}
inline const ::nv::TNVNetAddr& TNVAddr::ip_addr() const {
  return ip_addr_ != NULL ? *ip_addr_ : *default_instance_->ip_addr_;
}
inline ::nv::TNVNetAddr* TNVAddr::mutable_ip_addr() {
  set_has_ip_addr();
  if (ip_addr_ == NULL) ip_addr_ = new ::nv::TNVNetAddr;
  return ip_addr_;
}
inline ::nv::TNVNetAddr* TNVAddr::release_ip_addr() {
  clear_has_ip_addr();
  ::nv::TNVNetAddr* temp = ip_addr_;
  ip_addr_ = NULL;
  return temp;
}
inline void TNVAddr::set_allocated_ip_addr(::nv::TNVNetAddr* ip_addr) {
  delete ip_addr_;
  ip_addr_ = ip_addr;
  if (ip_addr) {
    set_has_ip_addr();
  } else {
    clear_has_ip_addr();
  }
}

// optional string alias = 3;
inline bool TNVAddr::has_alias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVAddr::set_has_alias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVAddr::clear_has_alias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVAddr::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& TNVAddr::alias() const {
  return *alias_;
}
inline void TNVAddr::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TNVAddr::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TNVAddr::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVAddr::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* TNVAddr::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVAddr::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TRpNvAddr

// repeated .nv.TNVAddr nv_addr = 1;
inline int TRpNvAddr::nv_addr_size() const {
  return nv_addr_.size();
}
inline void TRpNvAddr::clear_nv_addr() {
  nv_addr_.Clear();
}
inline const ::nv::TNVAddr& TRpNvAddr::nv_addr(int index) const {
  return nv_addr_.Get(index);
}
inline ::nv::TNVAddr* TRpNvAddr::mutable_nv_addr(int index) {
  return nv_addr_.Mutable(index);
}
inline ::nv::TNVAddr* TRpNvAddr::add_nv_addr() {
  return nv_addr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVAddr >&
TRpNvAddr::nv_addr() const {
  return nv_addr_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVAddr >*
TRpNvAddr::mutable_nv_addr() {
  return &nv_addr_;
}

// -------------------------------------------------------------------

// TNVAlias

// optional .nv.EmNvAliasType type = 1;
inline bool TNVAlias::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVAlias::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVAlias::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVAlias::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::nv::EmNvAliasType TNVAlias::type() const {
  return static_cast< ::nv::EmNvAliasType >(type_);
}
inline void TNVAlias::set_type(::nv::EmNvAliasType value) {
  assert(::nv::EmNvAliasType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string alias = 2;
inline bool TNVAlias::has_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVAlias::set_has_alias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVAlias::clear_has_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVAlias::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& TNVAlias::alias() const {
  return *alias_;
}
inline void TNVAlias::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TNVAlias::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void TNVAlias::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVAlias::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* TNVAlias::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVAlias::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVSubsMsgID

// repeated string msgid = 1;
inline int TNVSubsMsgID::msgid_size() const {
  return msgid_.size();
}
inline void TNVSubsMsgID::clear_msgid() {
  msgid_.Clear();
}
inline const ::std::string& TNVSubsMsgID::msgid(int index) const {
  return msgid_.Get(index);
}
inline ::std::string* TNVSubsMsgID::mutable_msgid(int index) {
  return msgid_.Mutable(index);
}
inline void TNVSubsMsgID::set_msgid(int index, const ::std::string& value) {
  msgid_.Mutable(index)->assign(value);
}
inline void TNVSubsMsgID::set_msgid(int index, const char* value) {
  msgid_.Mutable(index)->assign(value);
}
inline void TNVSubsMsgID::set_msgid(int index, const char* value, size_t size) {
  msgid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSubsMsgID::add_msgid() {
  return msgid_.Add();
}
inline void TNVSubsMsgID::add_msgid(const ::std::string& value) {
  msgid_.Add()->assign(value);
}
inline void TNVSubsMsgID::add_msgid(const char* value) {
  msgid_.Add()->assign(value);
}
inline void TNVSubsMsgID::add_msgid(const char* value, size_t size) {
  msgid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TNVSubsMsgID::msgid() const {
  return msgid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TNVSubsMsgID::mutable_msgid() {
  return &msgid_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nv

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nvstructcommon_2eproto__INCLUDED
