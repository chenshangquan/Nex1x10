// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nvstructcfg.proto

#ifndef PROTOBUF_nvstructcfg_2eproto__INCLUDED
#define PROTOBUF_nvstructcfg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "nvenum.pb.h"
#include "nvstructcommon.pb.h"
#include "nvstructbase.pb.h"
// @@protoc_insertion_point(includes)

namespace nv {

// Internal implementation detail -- do not call these.
void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
void protobuf_AssignDesc_nvstructcfg_2eproto();
void protobuf_ShutdownFile_nvstructcfg_2eproto();

class TNVRestoreDefaultCfgInfo;
class TNVServiceInfo;
class TNVServiceInfoFromUI;
class TNVServiceDefInfo;
class TNVSrvKeepLiveInfo;
class TNVMutiTServiceInfo;
class TNVMutiTServiceInfoRtData;
class TNVMutiTServiceDefInfo;
class TNVPortPairInfo;
class TNVPortPairAllocReqInfo;
class TNVPortRangeAllocReqInfo;
class TNVPortPairAllocRspInfo;
class TNVPortRangeAllocRspInfo;
class TNVPortCfg;
class TNVAPSSvrAddr;
class TNVAPSAddrFromSrv;
class TNVServerAddress;
class TNVTerminalInfo;
class TNVOspSock5Proxy;
class TNVUpgradeNetParam;
class TNVUpgradeDeviceInfo;
class TNVUpgradeClientInfo;
class TNVUpgradeGrayRange;
class TNVUpgradeVersionInfo;
class TNVUpgradeVersionInfoList;
class TNVUpgradeDownloadInfo;
class TNVSUSAddr;
class TNVUserFullInfo;
class TNVUserReqResult;
class TNVMultiUserFullInfo;
class TNVMultiUserReqResult;
class TNVUserConnectInfo;
class TNVEthnetCardInfo;
class TNVEthnetCfg;
class TNVLastDisplay;
class TNVResizeMode;
class TNVHDImageNoise;
class TNVHDImageDeformationTensile;
class TNVImixVidSourceInfo;
class TNVMultiImixVidSourceInfo;
class TNVApiStartInfo;
class TNVLoginInfo;
class TNVLoginInfos;
class TNVImixVidSrcSignal;
class TNVImixVidSrcSignalList;
class TNVVidInPortMode;
class TNVVidOutPortMode;
class TNVVideoOutPort2InPort;
class TNVVideoMatrixScheme;
class TE1Unit;
class TE1Group;
class TE1Cfg;
class TNVLocalDevInfo;
class TNVDevUpdateCfg;
class TNVDevCfgInfoList;
class TNVFTPFileInfo;
class TNVDevUpgrade;
class TNVUpGradeConnectInfo;
class TNVUpgradePackageContent;
class TNVCfgMtSystemTime;
class TNVFtpLoginInfo;
class TNVFtpLoginInfos;
class TNVTerminalName;
class TNVMiniVidInfo;
class TNVImixVerInfo;
class TNVHWInfo;
class TNVMtInfo;
class TNVQkVer;
class TNVMtAutoSleepCfg;
class TNVClearSrcType;
class TNVAllUpgradePackageContent;
class TNVPadLoginInfo;
class TNVPadLoginInfos;

// ===================================================================

class MTMSG_API TNVRestoreDefaultCfgInfo : public ::google::protobuf::Message {
 public:
  TNVRestoreDefaultCfgInfo();
  virtual ~TNVRestoreDefaultCfgInfo();

  TNVRestoreDefaultCfgInfo(const TNVRestoreDefaultCfgInfo& from);

  inline TNVRestoreDefaultCfgInfo& operator=(const TNVRestoreDefaultCfgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVRestoreDefaultCfgInfo& default_instance();

  void Swap(TNVRestoreDefaultCfgInfo* other);

  // implements Message ----------------------------------------------

  TNVRestoreDefaultCfgInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVRestoreDefaultCfgInfo& from);
  void MergeFrom(const TNVRestoreDefaultCfgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string key_list = 1;
  inline int key_list_size() const;
  inline void clear_key_list();
  static const int kKeyListFieldNumber = 1;
  inline const ::std::string& key_list(int index) const;
  inline ::std::string* mutable_key_list(int index);
  inline void set_key_list(int index, const ::std::string& value);
  inline void set_key_list(int index, const char* value);
  inline void set_key_list(int index, const char* value, size_t size);
  inline ::std::string* add_key_list();
  inline void add_key_list(const ::std::string& value);
  inline void add_key_list(const char* value);
  inline void add_key_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& key_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key_list();

  // @@protoc_insertion_point(class_scope:nv.TNVRestoreDefaultCfgInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> key_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVRestoreDefaultCfgInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVServiceInfo : public ::google::protobuf::Message {
 public:
  TNVServiceInfo();
  virtual ~TNVServiceInfo();

  TNVServiceInfo(const TNVServiceInfo& from);

  inline TNVServiceInfo& operator=(const TNVServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVServiceInfo& default_instance();

  void Swap(TNVServiceInfo* other);

  // implements Message ----------------------------------------------

  TNVServiceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVServiceInfo& from);
  void MergeFrom(const TNVServiceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 nvaid = 2;
  inline bool has_nvaid() const;
  inline void clear_nvaid();
  static const int kNvaidFieldNumber = 2;
  inline ::google::protobuf::uint32 nvaid() const;
  inline void set_nvaid(::google::protobuf::uint32 value);

  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string sysalias = 4;
  inline bool has_sysalias() const;
  inline void clear_sysalias();
  static const int kSysaliasFieldNumber = 4;
  inline const ::std::string& sysalias() const;
  inline void set_sysalias(const ::std::string& value);
  inline void set_sysalias(const char* value);
  inline void set_sysalias(const char* value, size_t size);
  inline ::std::string* mutable_sysalias();
  inline ::std::string* release_sysalias();
  inline void set_allocated_sysalias(::std::string* sysalias);

  // optional .nv.EmNvSysStartMod startmod = 5;
  inline bool has_startmod() const;
  inline void clear_startmod();
  static const int kStartmodFieldNumber = 5;
  inline ::nv::EmNvSysStartMod startmod() const;
  inline void set_startmod(::nv::EmNvSysStartMod value);

  // optional string srtfuncname = 6;
  inline bool has_srtfuncname() const;
  inline void clear_srtfuncname();
  static const int kSrtfuncnameFieldNumber = 6;
  inline const ::std::string& srtfuncname() const;
  inline void set_srtfuncname(const ::std::string& value);
  inline void set_srtfuncname(const char* value);
  inline void set_srtfuncname(const char* value, size_t size);
  inline ::std::string* mutable_srtfuncname();
  inline ::std::string* release_srtfuncname();
  inline void set_allocated_srtfuncname(::std::string* srtfuncname);

  // optional string endfuncname = 7;
  inline bool has_endfuncname() const;
  inline void clear_endfuncname();
  static const int kEndfuncnameFieldNumber = 7;
  inline const ::std::string& endfuncname() const;
  inline void set_endfuncname(const ::std::string& value);
  inline void set_endfuncname(const char* value);
  inline void set_endfuncname(const char* value, size_t size);
  inline ::std::string* mutable_endfuncname();
  inline ::std::string* release_endfuncname();
  inline void set_allocated_endfuncname(::std::string* endfuncname);

  // optional .nv.EmNvSysSrvState srvstate = 8;
  inline bool has_srvstate() const;
  inline void clear_srvstate();
  static const int kSrvstateFieldNumber = 8;
  inline ::nv::EmNvSysSrvState srvstate() const;
  inline void set_srvstate(::nv::EmNvSysSrvState value);

  // optional .nv.EmNvSysKeepLiveState srvklstate = 9;
  inline bool has_srvklstate() const;
  inline void clear_srvklstate();
  static const int kSrvklstateFieldNumber = 9;
  inline ::nv::EmNvSysKeepLiveState srvklstate() const;
  inline void set_srvklstate(::nv::EmNvSysKeepLiveState value);

  // optional uint32 time = 10;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 11;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 11;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 dllhandler = 12;
  inline bool has_dllhandler() const;
  inline void clear_dllhandler();
  static const int kDllhandlerFieldNumber = 12;
  inline ::google::protobuf::uint32 dllhandler() const;
  inline void set_dllhandler(::google::protobuf::uint32 value);

  // optional uint32 processpid = 13;
  inline bool has_processpid() const;
  inline void clear_processpid();
  static const int kProcesspidFieldNumber = 13;
  inline ::google::protobuf::uint32 processpid() const;
  inline void set_processpid(::google::protobuf::uint32 value);

  // optional string version = 14;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 14;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:nv.TNVServiceInfo)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_nvaid();
  inline void clear_has_nvaid();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_sysalias();
  inline void clear_has_sysalias();
  inline void set_has_startmod();
  inline void clear_has_startmod();
  inline void set_has_srtfuncname();
  inline void clear_has_srtfuncname();
  inline void set_has_endfuncname();
  inline void clear_has_endfuncname();
  inline void set_has_srvstate();
  inline void clear_has_srvstate();
  inline void set_has_srvklstate();
  inline void clear_has_srvklstate();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_dllhandler();
  inline void clear_has_dllhandler();
  inline void set_has_processpid();
  inline void clear_has_processpid();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 nvaid_;
  ::std::string* path_;
  ::std::string* sysalias_;
  ::std::string* srtfuncname_;
  int startmod_;
  int srvstate_;
  ::std::string* endfuncname_;
  int srvklstate_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 dllhandler_;
  ::std::string* version_;
  ::google::protobuf::uint32 processpid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVServiceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVServiceInfoFromUI : public ::google::protobuf::Message {
 public:
  TNVServiceInfoFromUI();
  virtual ~TNVServiceInfoFromUI();

  TNVServiceInfoFromUI(const TNVServiceInfoFromUI& from);

  inline TNVServiceInfoFromUI& operator=(const TNVServiceInfoFromUI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVServiceInfoFromUI& default_instance();

  void Swap(TNVServiceInfoFromUI* other);

  // implements Message ----------------------------------------------

  TNVServiceInfoFromUI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVServiceInfoFromUI& from);
  void MergeFrom(const TNVServiceInfoFromUI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 nvaid = 1;
  inline bool has_nvaid() const;
  inline void clear_nvaid();
  static const int kNvaidFieldNumber = 1;
  inline ::google::protobuf::uint32 nvaid() const;
  inline void set_nvaid(::google::protobuf::uint32 value);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string sysalias = 3;
  inline bool has_sysalias() const;
  inline void clear_sysalias();
  static const int kSysaliasFieldNumber = 3;
  inline const ::std::string& sysalias() const;
  inline void set_sysalias(const ::std::string& value);
  inline void set_sysalias(const char* value);
  inline void set_sysalias(const char* value, size_t size);
  inline ::std::string* mutable_sysalias();
  inline ::std::string* release_sysalias();
  inline void set_allocated_sysalias(::std::string* sysalias);

  // optional .nv.EmNvSysStartModFromUI startmod = 4;
  inline bool has_startmod() const;
  inline void clear_startmod();
  static const int kStartmodFieldNumber = 4;
  inline ::nv::EmNvSysStartModFromUI startmod() const;
  inline void set_startmod(::nv::EmNvSysStartModFromUI value);

  // optional string srtfuncname = 5;
  inline bool has_srtfuncname() const;
  inline void clear_srtfuncname();
  static const int kSrtfuncnameFieldNumber = 5;
  inline const ::std::string& srtfuncname() const;
  inline void set_srtfuncname(const ::std::string& value);
  inline void set_srtfuncname(const char* value);
  inline void set_srtfuncname(const char* value, size_t size);
  inline ::std::string* mutable_srtfuncname();
  inline ::std::string* release_srtfuncname();
  inline void set_allocated_srtfuncname(::std::string* srtfuncname);

  // optional string endfuncname = 6;
  inline bool has_endfuncname() const;
  inline void clear_endfuncname();
  static const int kEndfuncnameFieldNumber = 6;
  inline const ::std::string& endfuncname() const;
  inline void set_endfuncname(const ::std::string& value);
  inline void set_endfuncname(const char* value);
  inline void set_endfuncname(const char* value, size_t size);
  inline ::std::string* mutable_endfuncname();
  inline ::std::string* release_endfuncname();
  inline void set_allocated_endfuncname(::std::string* endfuncname);

  // @@protoc_insertion_point(class_scope:nv.TNVServiceInfoFromUI)
 private:
  inline void set_has_nvaid();
  inline void clear_has_nvaid();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_sysalias();
  inline void clear_has_sysalias();
  inline void set_has_startmod();
  inline void clear_has_startmod();
  inline void set_has_srtfuncname();
  inline void clear_has_srtfuncname();
  inline void set_has_endfuncname();
  inline void clear_has_endfuncname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  ::google::protobuf::uint32 nvaid_;
  int startmod_;
  ::std::string* sysalias_;
  ::std::string* srtfuncname_;
  ::std::string* endfuncname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVServiceInfoFromUI* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVServiceDefInfo : public ::google::protobuf::Message {
 public:
  TNVServiceDefInfo();
  virtual ~TNVServiceDefInfo();

  TNVServiceDefInfo(const TNVServiceDefInfo& from);

  inline TNVServiceDefInfo& operator=(const TNVServiceDefInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVServiceDefInfo& default_instance();

  void Swap(TNVServiceDefInfo* other);

  // implements Message ----------------------------------------------

  TNVServiceDefInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVServiceDefInfo& from);
  void MergeFrom(const TNVServiceDefInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string sysalias = 3;
  inline bool has_sysalias() const;
  inline void clear_sysalias();
  static const int kSysaliasFieldNumber = 3;
  inline const ::std::string& sysalias() const;
  inline void set_sysalias(const ::std::string& value);
  inline void set_sysalias(const char* value);
  inline void set_sysalias(const char* value, size_t size);
  inline ::std::string* mutable_sysalias();
  inline ::std::string* release_sysalias();
  inline void set_allocated_sysalias(::std::string* sysalias);

  // optional .nv.EmNvSysStartMod startmod = 4;
  inline bool has_startmod() const;
  inline void clear_startmod();
  static const int kStartmodFieldNumber = 4;
  inline ::nv::EmNvSysStartMod startmod() const;
  inline void set_startmod(::nv::EmNvSysStartMod value);

  // optional string srtfuncname = 5;
  inline bool has_srtfuncname() const;
  inline void clear_srtfuncname();
  static const int kSrtfuncnameFieldNumber = 5;
  inline const ::std::string& srtfuncname() const;
  inline void set_srtfuncname(const ::std::string& value);
  inline void set_srtfuncname(const char* value);
  inline void set_srtfuncname(const char* value, size_t size);
  inline ::std::string* mutable_srtfuncname();
  inline ::std::string* release_srtfuncname();
  inline void set_allocated_srtfuncname(::std::string* srtfuncname);

  // optional string endfuncname = 6;
  inline bool has_endfuncname() const;
  inline void clear_endfuncname();
  static const int kEndfuncnameFieldNumber = 6;
  inline const ::std::string& endfuncname() const;
  inline void set_endfuncname(const ::std::string& value);
  inline void set_endfuncname(const char* value);
  inline void set_endfuncname(const char* value, size_t size);
  inline ::std::string* mutable_endfuncname();
  inline ::std::string* release_endfuncname();
  inline void set_allocated_endfuncname(::std::string* endfuncname);

  // @@protoc_insertion_point(class_scope:nv.TNVServiceDefInfo)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_sysalias();
  inline void clear_has_sysalias();
  inline void set_has_startmod();
  inline void clear_has_startmod();
  inline void set_has_srtfuncname();
  inline void clear_has_srtfuncname();
  inline void set_has_endfuncname();
  inline void clear_has_endfuncname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  ::google::protobuf::uint32 index_;
  int startmod_;
  ::std::string* sysalias_;
  ::std::string* srtfuncname_;
  ::std::string* endfuncname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVServiceDefInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVSrvKeepLiveInfo : public ::google::protobuf::Message {
 public:
  TNVSrvKeepLiveInfo();
  virtual ~TNVSrvKeepLiveInfo();

  TNVSrvKeepLiveInfo(const TNVSrvKeepLiveInfo& from);

  inline TNVSrvKeepLiveInfo& operator=(const TNVSrvKeepLiveInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVSrvKeepLiveInfo& default_instance();

  void Swap(TNVSrvKeepLiveInfo* other);

  // implements Message ----------------------------------------------

  TNVSrvKeepLiveInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVSrvKeepLiveInfo& from);
  void MergeFrom(const TNVSrvKeepLiveInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sysalias = 1;
  inline bool has_sysalias() const;
  inline void clear_sysalias();
  static const int kSysaliasFieldNumber = 1;
  inline const ::std::string& sysalias() const;
  inline void set_sysalias(const ::std::string& value);
  inline void set_sysalias(const char* value);
  inline void set_sysalias(const char* value, size_t size);
  inline ::std::string* mutable_sysalias();
  inline ::std::string* release_sysalias();
  inline void set_allocated_sysalias(::std::string* sysalias);

  // optional uint32 nvaid = 2;
  inline bool has_nvaid() const;
  inline void clear_nvaid();
  static const int kNvaidFieldNumber = 2;
  inline ::google::protobuf::uint32 nvaid() const;
  inline void set_nvaid(::google::protobuf::uint32 value);

  // optional uint32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVSrvKeepLiveInfo)
 private:
  inline void set_has_sysalias();
  inline void clear_has_sysalias();
  inline void set_has_nvaid();
  inline void clear_has_nvaid();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sysalias_;
  ::google::protobuf::uint32 nvaid_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVSrvKeepLiveInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMutiTServiceInfo : public ::google::protobuf::Message {
 public:
  TNVMutiTServiceInfo();
  virtual ~TNVMutiTServiceInfo();

  TNVMutiTServiceInfo(const TNVMutiTServiceInfo& from);

  inline TNVMutiTServiceInfo& operator=(const TNVMutiTServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMutiTServiceInfo& default_instance();

  void Swap(TNVMutiTServiceInfo* other);

  // implements Message ----------------------------------------------

  TNVMutiTServiceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMutiTServiceInfo& from);
  void MergeFrom(const TNVMutiTServiceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVServiceInfoFromUI tServiceInfo = 1;
  inline int tserviceinfo_size() const;
  inline void clear_tserviceinfo();
  static const int kTServiceInfoFieldNumber = 1;
  inline const ::nv::TNVServiceInfoFromUI& tserviceinfo(int index) const;
  inline ::nv::TNVServiceInfoFromUI* mutable_tserviceinfo(int index);
  inline ::nv::TNVServiceInfoFromUI* add_tserviceinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceInfoFromUI >&
      tserviceinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceInfoFromUI >*
      mutable_tserviceinfo();

  // @@protoc_insertion_point(class_scope:nv.TNVMutiTServiceInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceInfoFromUI > tserviceinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVMutiTServiceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMutiTServiceInfoRtData : public ::google::protobuf::Message {
 public:
  TNVMutiTServiceInfoRtData();
  virtual ~TNVMutiTServiceInfoRtData();

  TNVMutiTServiceInfoRtData(const TNVMutiTServiceInfoRtData& from);

  inline TNVMutiTServiceInfoRtData& operator=(const TNVMutiTServiceInfoRtData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMutiTServiceInfoRtData& default_instance();

  void Swap(TNVMutiTServiceInfoRtData* other);

  // implements Message ----------------------------------------------

  TNVMutiTServiceInfoRtData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMutiTServiceInfoRtData& from);
  void MergeFrom(const TNVMutiTServiceInfoRtData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVServiceInfo tServiceInfo = 1;
  inline int tserviceinfo_size() const;
  inline void clear_tserviceinfo();
  static const int kTServiceInfoFieldNumber = 1;
  inline const ::nv::TNVServiceInfo& tserviceinfo(int index) const;
  inline ::nv::TNVServiceInfo* mutable_tserviceinfo(int index);
  inline ::nv::TNVServiceInfo* add_tserviceinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceInfo >&
      tserviceinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceInfo >*
      mutable_tserviceinfo();

  // @@protoc_insertion_point(class_scope:nv.TNVMutiTServiceInfoRtData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceInfo > tserviceinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVMutiTServiceInfoRtData* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMutiTServiceDefInfo : public ::google::protobuf::Message {
 public:
  TNVMutiTServiceDefInfo();
  virtual ~TNVMutiTServiceDefInfo();

  TNVMutiTServiceDefInfo(const TNVMutiTServiceDefInfo& from);

  inline TNVMutiTServiceDefInfo& operator=(const TNVMutiTServiceDefInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMutiTServiceDefInfo& default_instance();

  void Swap(TNVMutiTServiceDefInfo* other);

  // implements Message ----------------------------------------------

  TNVMutiTServiceDefInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMutiTServiceDefInfo& from);
  void MergeFrom(const TNVMutiTServiceDefInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVServiceDefInfo tServiceDefInfo = 1;
  inline int tservicedefinfo_size() const;
  inline void clear_tservicedefinfo();
  static const int kTServiceDefInfoFieldNumber = 1;
  inline const ::nv::TNVServiceDefInfo& tservicedefinfo(int index) const;
  inline ::nv::TNVServiceDefInfo* mutable_tservicedefinfo(int index);
  inline ::nv::TNVServiceDefInfo* add_tservicedefinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceDefInfo >&
      tservicedefinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceDefInfo >*
      mutable_tservicedefinfo();

  // @@protoc_insertion_point(class_scope:nv.TNVMutiTServiceDefInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceDefInfo > tservicedefinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVMutiTServiceDefInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVPortPairInfo : public ::google::protobuf::Message {
 public:
  TNVPortPairInfo();
  virtual ~TNVPortPairInfo();

  TNVPortPairInfo(const TNVPortPairInfo& from);

  inline TNVPortPairInfo& operator=(const TNVPortPairInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVPortPairInfo& default_instance();

  void Swap(TNVPortPairInfo* other);

  // implements Message ----------------------------------------------

  TNVPortPairInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVPortPairInfo& from);
  void MergeFrom(const TNVPortPairInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 port_one = 1;
  inline bool has_port_one() const;
  inline void clear_port_one();
  static const int kPortOneFieldNumber = 1;
  inline ::google::protobuf::uint32 port_one() const;
  inline void set_port_one(::google::protobuf::uint32 value);

  // optional uint32 port_two = 2;
  inline bool has_port_two() const;
  inline void clear_port_two();
  static const int kPortTwoFieldNumber = 2;
  inline ::google::protobuf::uint32 port_two() const;
  inline void set_port_two(::google::protobuf::uint32 value);

  // optional string describe = 3;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 3;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // @@protoc_insertion_point(class_scope:nv.TNVPortPairInfo)
 private:
  inline void set_has_port_one();
  inline void clear_has_port_one();
  inline void set_has_port_two();
  inline void clear_has_port_two();
  inline void set_has_describe();
  inline void clear_has_describe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 port_one_;
  ::google::protobuf::uint32 port_two_;
  ::std::string* describe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVPortPairInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVPortPairAllocReqInfo : public ::google::protobuf::Message {
 public:
  TNVPortPairAllocReqInfo();
  virtual ~TNVPortPairAllocReqInfo();

  TNVPortPairAllocReqInfo(const TNVPortPairAllocReqInfo& from);

  inline TNVPortPairAllocReqInfo& operator=(const TNVPortPairAllocReqInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVPortPairAllocReqInfo& default_instance();

  void Swap(TNVPortPairAllocReqInfo* other);

  // implements Message ----------------------------------------------

  TNVPortPairAllocReqInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVPortPairAllocReqInfo& from);
  void MergeFrom(const TNVPortPairAllocReqInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_tcp_port = 1;
  inline bool has_is_tcp_port() const;
  inline void clear_is_tcp_port();
  static const int kIsTcpPortFieldNumber = 1;
  inline bool is_tcp_port() const;
  inline void set_is_tcp_port(bool value);

  // optional uint32 port_pair_num = 2;
  inline bool has_port_pair_num() const;
  inline void clear_port_pair_num();
  static const int kPortPairNumFieldNumber = 2;
  inline ::google::protobuf::uint32 port_pair_num() const;
  inline void set_port_pair_num(::google::protobuf::uint32 value);

  // optional string describe = 3;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 3;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // @@protoc_insertion_point(class_scope:nv.TNVPortPairAllocReqInfo)
 private:
  inline void set_has_is_tcp_port();
  inline void clear_has_is_tcp_port();
  inline void set_has_port_pair_num();
  inline void clear_has_port_pair_num();
  inline void set_has_describe();
  inline void clear_has_describe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_tcp_port_;
  ::google::protobuf::uint32 port_pair_num_;
  ::std::string* describe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVPortPairAllocReqInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVPortRangeAllocReqInfo : public ::google::protobuf::Message {
 public:
  TNVPortRangeAllocReqInfo();
  virtual ~TNVPortRangeAllocReqInfo();

  TNVPortRangeAllocReqInfo(const TNVPortRangeAllocReqInfo& from);

  inline TNVPortRangeAllocReqInfo& operator=(const TNVPortRangeAllocReqInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVPortRangeAllocReqInfo& default_instance();

  void Swap(TNVPortRangeAllocReqInfo* other);

  // implements Message ----------------------------------------------

  TNVPortRangeAllocReqInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVPortRangeAllocReqInfo& from);
  void MergeFrom(const TNVPortRangeAllocReqInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_tcp_port = 1;
  inline bool has_is_tcp_port() const;
  inline void clear_is_tcp_port();
  static const int kIsTcpPortFieldNumber = 1;
  inline bool is_tcp_port() const;
  inline void set_is_tcp_port(bool value);

  // optional uint32 port_num = 2;
  inline bool has_port_num() const;
  inline void clear_port_num();
  static const int kPortNumFieldNumber = 2;
  inline ::google::protobuf::uint32 port_num() const;
  inline void set_port_num(::google::protobuf::uint32 value);

  // optional bool is_from_even_bgning = 3;
  inline bool has_is_from_even_bgning() const;
  inline void clear_is_from_even_bgning();
  static const int kIsFromEvenBgningFieldNumber = 3;
  inline bool is_from_even_bgning() const;
  inline void set_is_from_even_bgning(bool value);

  // optional string describe = 4;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 4;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // @@protoc_insertion_point(class_scope:nv.TNVPortRangeAllocReqInfo)
 private:
  inline void set_has_is_tcp_port();
  inline void clear_has_is_tcp_port();
  inline void set_has_port_num();
  inline void clear_has_port_num();
  inline void set_has_is_from_even_bgning();
  inline void clear_has_is_from_even_bgning();
  inline void set_has_describe();
  inline void clear_has_describe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 port_num_;
  bool is_tcp_port_;
  bool is_from_even_bgning_;
  ::std::string* describe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVPortRangeAllocReqInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVPortPairAllocRspInfo : public ::google::protobuf::Message {
 public:
  TNVPortPairAllocRspInfo();
  virtual ~TNVPortPairAllocRspInfo();

  TNVPortPairAllocRspInfo(const TNVPortPairAllocRspInfo& from);

  inline TNVPortPairAllocRspInfo& operator=(const TNVPortPairAllocRspInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVPortPairAllocRspInfo& default_instance();

  void Swap(TNVPortPairAllocRspInfo* other);

  // implements Message ----------------------------------------------

  TNVPortPairAllocRspInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVPortPairAllocRspInfo& from);
  void MergeFrom(const TNVPortPairAllocRspInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_ok = 1;
  inline bool has_is_ok() const;
  inline void clear_is_ok();
  static const int kIsOkFieldNumber = 1;
  inline bool is_ok() const;
  inline void set_is_ok(bool value);

  // repeated .nv.TNVPortPairInfo port_pair = 2;
  inline int port_pair_size() const;
  inline void clear_port_pair();
  static const int kPortPairFieldNumber = 2;
  inline const ::nv::TNVPortPairInfo& port_pair(int index) const;
  inline ::nv::TNVPortPairInfo* mutable_port_pair(int index);
  inline ::nv::TNVPortPairInfo* add_port_pair();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVPortPairInfo >&
      port_pair() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVPortPairInfo >*
      mutable_port_pair();

  // @@protoc_insertion_point(class_scope:nv.TNVPortPairAllocRspInfo)
 private:
  inline void set_has_is_ok();
  inline void clear_has_is_ok();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVPortPairInfo > port_pair_;
  bool is_ok_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVPortPairAllocRspInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVPortRangeAllocRspInfo : public ::google::protobuf::Message {
 public:
  TNVPortRangeAllocRspInfo();
  virtual ~TNVPortRangeAllocRspInfo();

  TNVPortRangeAllocRspInfo(const TNVPortRangeAllocRspInfo& from);

  inline TNVPortRangeAllocRspInfo& operator=(const TNVPortRangeAllocRspInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVPortRangeAllocRspInfo& default_instance();

  void Swap(TNVPortRangeAllocRspInfo* other);

  // implements Message ----------------------------------------------

  TNVPortRangeAllocRspInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVPortRangeAllocRspInfo& from);
  void MergeFrom(const TNVPortRangeAllocRspInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_ok = 1;
  inline bool has_is_ok() const;
  inline void clear_is_ok();
  static const int kIsOkFieldNumber = 1;
  inline bool is_ok() const;
  inline void set_is_ok(bool value);

  // optional uint32 start_port = 2;
  inline bool has_start_port() const;
  inline void clear_start_port();
  static const int kStartPortFieldNumber = 2;
  inline ::google::protobuf::uint32 start_port() const;
  inline void set_start_port(::google::protobuf::uint32 value);

  // optional uint32 end_port = 3;
  inline bool has_end_port() const;
  inline void clear_end_port();
  static const int kEndPortFieldNumber = 3;
  inline ::google::protobuf::uint32 end_port() const;
  inline void set_end_port(::google::protobuf::uint32 value);

  // optional string describe = 4;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 4;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // @@protoc_insertion_point(class_scope:nv.TNVPortRangeAllocRspInfo)
 private:
  inline void set_has_is_ok();
  inline void clear_has_is_ok();
  inline void set_has_start_port();
  inline void clear_has_start_port();
  inline void set_has_end_port();
  inline void clear_has_end_port();
  inline void set_has_describe();
  inline void clear_has_describe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_ok_;
  ::google::protobuf::uint32 start_port_;
  ::std::string* describe_;
  ::google::protobuf::uint32 end_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVPortRangeAllocRspInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVPortCfg : public ::google::protobuf::Message {
 public:
  TNVPortCfg();
  virtual ~TNVPortCfg();

  TNVPortCfg(const TNVPortCfg& from);

  inline TNVPortCfg& operator=(const TNVPortCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVPortCfg& default_instance();

  void Swap(TNVPortCfg* other);

  // implements Message ----------------------------------------------

  TNVPortCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVPortCfg& from);
  void MergeFrom(const TNVPortCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_used = 1;
  inline bool has_is_used() const;
  inline void clear_is_used();
  static const int kIsUsedFieldNumber = 1;
  inline bool is_used() const;
  inline void set_is_used(bool value);

  // optional uint32 tcp_base_port = 2;
  inline bool has_tcp_base_port() const;
  inline void clear_tcp_base_port();
  static const int kTcpBasePortFieldNumber = 2;
  inline ::google::protobuf::uint32 tcp_base_port() const;
  inline void set_tcp_base_port(::google::protobuf::uint32 value);

  // optional uint32 udp_base_port = 3;
  inline bool has_udp_base_port() const;
  inline void clear_udp_base_port();
  static const int kUdpBasePortFieldNumber = 3;
  inline ::google::protobuf::uint32 udp_base_port() const;
  inline void set_udp_base_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVPortCfg)
 private:
  inline void set_has_is_used();
  inline void clear_has_is_used();
  inline void set_has_tcp_base_port();
  inline void clear_has_tcp_base_port();
  inline void set_has_udp_base_port();
  inline void clear_has_udp_base_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_used_;
  ::google::protobuf::uint32 tcp_base_port_;
  ::google::protobuf::uint32 udp_base_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVPortCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVAPSSvrAddr : public ::google::protobuf::Message {
 public:
  TNVAPSSvrAddr();
  virtual ~TNVAPSSvrAddr();

  TNVAPSSvrAddr(const TNVAPSSvrAddr& from);

  inline TNVAPSSvrAddr& operator=(const TNVAPSSvrAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVAPSSvrAddr& default_instance();

  void Swap(TNVAPSSvrAddr* other);

  // implements Message ----------------------------------------------

  TNVAPSSvrAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVAPSSvrAddr& from);
  void MergeFrom(const TNVAPSSvrAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 aps_login_ip = 2;
  inline bool has_aps_login_ip() const;
  inline void clear_aps_login_ip();
  static const int kApsLoginIpFieldNumber = 2;
  inline ::google::protobuf::uint32 aps_login_ip() const;
  inline void set_aps_login_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVAPSSvrAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_aps_login_ip();
  inline void clear_has_aps_login_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 aps_login_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVAPSSvrAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVAPSAddrFromSrv : public ::google::protobuf::Message {
 public:
  TNVAPSAddrFromSrv();
  virtual ~TNVAPSAddrFromSrv();

  TNVAPSAddrFromSrv(const TNVAPSAddrFromSrv& from);

  inline TNVAPSAddrFromSrv& operator=(const TNVAPSAddrFromSrv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVAPSAddrFromSrv& default_instance();

  void Swap(TNVAPSAddrFromSrv* other);

  // implements Message ----------------------------------------------

  TNVAPSAddrFromSrv* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVAPSAddrFromSrv& from);
  void MergeFrom(const TNVAPSAddrFromSrv& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVAPSSvrAddr srv_list = 1;
  inline int srv_list_size() const;
  inline void clear_srv_list();
  static const int kSrvListFieldNumber = 1;
  inline const ::nv::TNVAPSSvrAddr& srv_list(int index) const;
  inline ::nv::TNVAPSSvrAddr* mutable_srv_list(int index);
  inline ::nv::TNVAPSSvrAddr* add_srv_list();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVAPSSvrAddr >&
      srv_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVAPSSvrAddr >*
      mutable_srv_list();

  // @@protoc_insertion_point(class_scope:nv.TNVAPSAddrFromSrv)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVAPSSvrAddr > srv_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVAPSAddrFromSrv* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVServerAddress : public ::google::protobuf::Message {
 public:
  TNVServerAddress();
  virtual ~TNVServerAddress();

  TNVServerAddress(const TNVServerAddress& from);

  inline TNVServerAddress& operator=(const TNVServerAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVServerAddress& default_instance();

  void Swap(TNVServerAddress* other);

  // implements Message ----------------------------------------------

  TNVServerAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVServerAddress& from);
  void MergeFrom(const TNVServerAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVServerAddress)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVServerAddress* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVTerminalInfo : public ::google::protobuf::Message {
 public:
  TNVTerminalInfo();
  virtual ~TNVTerminalInfo();

  TNVTerminalInfo(const TNVTerminalInfo& from);

  inline TNVTerminalInfo& operator=(const TNVTerminalInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVTerminalInfo& default_instance();

  void Swap(TNVTerminalInfo* other);

  // implements Message ----------------------------------------------

  TNVTerminalInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVTerminalInfo& from);
  void MergeFrom(const TNVTerminalInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvModel model = 1;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 1;
  inline ::nv::EmNvModel model() const;
  inline void set_model(::nv::EmNvModel value);

  // optional string model_name = 2;
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 2;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // optional string hardware_ver = 3;
  inline bool has_hardware_ver() const;
  inline void clear_hardware_ver();
  static const int kHardwareVerFieldNumber = 3;
  inline const ::std::string& hardware_ver() const;
  inline void set_hardware_ver(const ::std::string& value);
  inline void set_hardware_ver(const char* value);
  inline void set_hardware_ver(const char* value, size_t size);
  inline ::std::string* mutable_hardware_ver();
  inline ::std::string* release_hardware_ver();
  inline void set_allocated_hardware_ver(::std::string* hardware_ver);

  // optional string software_ver = 4;
  inline bool has_software_ver() const;
  inline void clear_software_ver();
  static const int kSoftwareVerFieldNumber = 4;
  inline const ::std::string& software_ver() const;
  inline void set_software_ver(const ::std::string& value);
  inline void set_software_ver(const char* value);
  inline void set_software_ver(const char* value, size_t size);
  inline ::std::string* mutable_software_ver();
  inline ::std::string* release_software_ver();
  inline void set_allocated_software_ver(::std::string* software_ver);

  // optional string oem_info = 5;
  inline bool has_oem_info() const;
  inline void clear_oem_info();
  static const int kOemInfoFieldNumber = 5;
  inline const ::std::string& oem_info() const;
  inline void set_oem_info(const ::std::string& value);
  inline void set_oem_info(const char* value);
  inline void set_oem_info(const char* value, size_t size);
  inline ::std::string* mutable_oem_info();
  inline ::std::string* release_oem_info();
  inline void set_allocated_oem_info(::std::string* oem_info);

  // optional string fpga1_ver = 6;
  inline bool has_fpga1_ver() const;
  inline void clear_fpga1_ver();
  static const int kFpga1VerFieldNumber = 6;
  inline const ::std::string& fpga1_ver() const;
  inline void set_fpga1_ver(const ::std::string& value);
  inline void set_fpga1_ver(const char* value);
  inline void set_fpga1_ver(const char* value, size_t size);
  inline ::std::string* mutable_fpga1_ver();
  inline ::std::string* release_fpga1_ver();
  inline void set_allocated_fpga1_ver(::std::string* fpga1_ver);

  // optional string fpga2_ver = 7;
  inline bool has_fpga2_ver() const;
  inline void clear_fpga2_ver();
  static const int kFpga2VerFieldNumber = 7;
  inline const ::std::string& fpga2_ver() const;
  inline void set_fpga2_ver(const ::std::string& value);
  inline void set_fpga2_ver(const char* value);
  inline void set_fpga2_ver(const char* value, size_t size);
  inline ::std::string* mutable_fpga2_ver();
  inline ::std::string* release_fpga2_ver();
  inline void set_allocated_fpga2_ver(::std::string* fpga2_ver);

  // optional string cpld_ver = 8;
  inline bool has_cpld_ver() const;
  inline void clear_cpld_ver();
  static const int kCpldVerFieldNumber = 8;
  inline const ::std::string& cpld_ver() const;
  inline void set_cpld_ver(const ::std::string& value);
  inline void set_cpld_ver(const char* value);
  inline void set_cpld_ver(const char* value, size_t size);
  inline ::std::string* mutable_cpld_ver();
  inline ::std::string* release_cpld_ver();
  inline void set_allocated_cpld_ver(::std::string* cpld_ver);

  // optional string serial_num = 9;
  inline bool has_serial_num() const;
  inline void clear_serial_num();
  static const int kSerialNumFieldNumber = 9;
  inline const ::std::string& serial_num() const;
  inline void set_serial_num(const ::std::string& value);
  inline void set_serial_num(const char* value);
  inline void set_serial_num(const char* value, size_t size);
  inline ::std::string* mutable_serial_num();
  inline ::std::string* release_serial_num();
  inline void set_allocated_serial_num(::std::string* serial_num);

  // optional string infrared_ver = 10;
  inline bool has_infrared_ver() const;
  inline void clear_infrared_ver();
  static const int kInfraredVerFieldNumber = 10;
  inline const ::std::string& infrared_ver() const;
  inline void set_infrared_ver(const ::std::string& value);
  inline void set_infrared_ver(const char* value);
  inline void set_infrared_ver(const char* value, size_t size);
  inline ::std::string* mutable_infrared_ver();
  inline ::std::string* release_infrared_ver();
  inline void set_allocated_infrared_ver(::std::string* infrared_ver);

  // optional .nv.EmNvSubModel submodel = 11;
  inline bool has_submodel() const;
  inline void clear_submodel();
  static const int kSubmodelFieldNumber = 11;
  inline ::nv::EmNvSubModel submodel() const;
  inline void set_submodel(::nv::EmNvSubModel value);

  // @@protoc_insertion_point(class_scope:nv.TNVTerminalInfo)
 private:
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_hardware_ver();
  inline void clear_has_hardware_ver();
  inline void set_has_software_ver();
  inline void clear_has_software_ver();
  inline void set_has_oem_info();
  inline void clear_has_oem_info();
  inline void set_has_fpga1_ver();
  inline void clear_has_fpga1_ver();
  inline void set_has_fpga2_ver();
  inline void clear_has_fpga2_ver();
  inline void set_has_cpld_ver();
  inline void clear_has_cpld_ver();
  inline void set_has_serial_num();
  inline void clear_has_serial_num();
  inline void set_has_infrared_ver();
  inline void clear_has_infrared_ver();
  inline void set_has_submodel();
  inline void clear_has_submodel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* model_name_;
  ::std::string* hardware_ver_;
  ::std::string* software_ver_;
  ::std::string* oem_info_;
  ::std::string* fpga1_ver_;
  int model_;
  int submodel_;
  ::std::string* fpga2_ver_;
  ::std::string* cpld_ver_;
  ::std::string* serial_num_;
  ::std::string* infrared_ver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVTerminalInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVOspSock5Proxy : public ::google::protobuf::Message {
 public:
  TNVOspSock5Proxy();
  virtual ~TNVOspSock5Proxy();

  TNVOspSock5Proxy(const TNVOspSock5Proxy& from);

  inline TNVOspSock5Proxy& operator=(const TNVOspSock5Proxy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVOspSock5Proxy& default_instance();

  void Swap(TNVOspSock5Proxy* other);

  // implements Message ----------------------------------------------

  TNVOspSock5Proxy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVOspSock5Proxy& from);
  void MergeFrom(const TNVOspSock5Proxy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 proxy_ip = 1;
  inline bool has_proxy_ip() const;
  inline void clear_proxy_ip();
  static const int kProxyIpFieldNumber = 1;
  inline ::google::protobuf::uint32 proxy_ip() const;
  inline void set_proxy_ip(::google::protobuf::uint32 value);

  // optional uint32 proxy_port = 2;
  inline bool has_proxy_port() const;
  inline void clear_proxy_port();
  static const int kProxyPortFieldNumber = 2;
  inline ::google::protobuf::uint32 proxy_port() const;
  inline void set_proxy_port(::google::protobuf::uint32 value);

  // optional uint32 authen_num = 3;
  inline bool has_authen_num() const;
  inline void clear_authen_num();
  static const int kAuthenNumFieldNumber = 3;
  inline ::google::protobuf::uint32 authen_num() const;
  inline void set_authen_num(::google::protobuf::uint32 value);

  // optional string authen_method = 4;
  inline bool has_authen_method() const;
  inline void clear_authen_method();
  static const int kAuthenMethodFieldNumber = 4;
  inline const ::std::string& authen_method() const;
  inline void set_authen_method(const ::std::string& value);
  inline void set_authen_method(const char* value);
  inline void set_authen_method(const char* value, size_t size);
  inline ::std::string* mutable_authen_method();
  inline ::std::string* release_authen_method();
  inline void set_allocated_authen_method(::std::string* authen_method);

  // optional string user_name = 5;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 5;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:nv.TNVOspSock5Proxy)
 private:
  inline void set_has_proxy_ip();
  inline void clear_has_proxy_ip();
  inline void set_has_proxy_port();
  inline void clear_has_proxy_port();
  inline void set_has_authen_num();
  inline void clear_has_authen_num();
  inline void set_has_authen_method();
  inline void clear_has_authen_method();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 proxy_ip_;
  ::google::protobuf::uint32 proxy_port_;
  ::std::string* authen_method_;
  ::std::string* user_name_;
  ::std::string* password_;
  ::google::protobuf::uint32 authen_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVOspSock5Proxy* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUpgradeNetParam : public ::google::protobuf::Message {
 public:
  TNVUpgradeNetParam();
  virtual ~TNVUpgradeNetParam();

  TNVUpgradeNetParam(const TNVUpgradeNetParam& from);

  inline TNVUpgradeNetParam& operator=(const TNVUpgradeNetParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUpgradeNetParam& default_instance();

  void Swap(TNVUpgradeNetParam* other);

  // implements Message ----------------------------------------------

  TNVUpgradeNetParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUpgradeNetParam& from);
  void MergeFrom(const TNVUpgradeNetParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string server_ip = 1;
  inline bool has_server_ip() const;
  inline void clear_server_ip();
  static const int kServerIpFieldNumber = 1;
  inline const ::std::string& server_ip() const;
  inline void set_server_ip(const ::std::string& value);
  inline void set_server_ip(const char* value);
  inline void set_server_ip(const char* value, size_t size);
  inline ::std::string* mutable_server_ip();
  inline ::std::string* release_server_ip();
  inline void set_allocated_server_ip(::std::string* server_ip);

  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional bool is_proxy_used = 3;
  inline bool has_is_proxy_used() const;
  inline void clear_is_proxy_used();
  static const int kIsProxyUsedFieldNumber = 3;
  inline bool is_proxy_used() const;
  inline void set_is_proxy_used(bool value);

  // optional .nv.TNVOspSock5Proxy proxy_info = 4;
  inline bool has_proxy_info() const;
  inline void clear_proxy_info();
  static const int kProxyInfoFieldNumber = 4;
  inline const ::nv::TNVOspSock5Proxy& proxy_info() const;
  inline ::nv::TNVOspSock5Proxy* mutable_proxy_info();
  inline ::nv::TNVOspSock5Proxy* release_proxy_info();
  inline void set_allocated_proxy_info(::nv::TNVOspSock5Proxy* proxy_info);

  // optional string domain = 5;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 5;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // @@protoc_insertion_point(class_scope:nv.TNVUpgradeNetParam)
 private:
  inline void set_has_server_ip();
  inline void clear_has_server_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_is_proxy_used();
  inline void clear_has_is_proxy_used();
  inline void set_has_proxy_info();
  inline void clear_has_proxy_info();
  inline void set_has_domain();
  inline void clear_has_domain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* server_ip_;
  ::google::protobuf::uint32 port_;
  bool is_proxy_used_;
  ::nv::TNVOspSock5Proxy* proxy_info_;
  ::std::string* domain_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUpgradeNetParam* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUpgradeDeviceInfo : public ::google::protobuf::Message {
 public:
  TNVUpgradeDeviceInfo();
  virtual ~TNVUpgradeDeviceInfo();

  TNVUpgradeDeviceInfo(const TNVUpgradeDeviceInfo& from);

  inline TNVUpgradeDeviceInfo& operator=(const TNVUpgradeDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUpgradeDeviceInfo& default_instance();

  void Swap(TNVUpgradeDeviceInfo* other);

  // implements Message ----------------------------------------------

  TNVUpgradeDeviceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUpgradeDeviceInfo& from);
  void MergeFrom(const TNVUpgradeDeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvDevRegUpdateSer dev_type = 1;
  inline bool has_dev_type() const;
  inline void clear_dev_type();
  static const int kDevTypeFieldNumber = 1;
  inline ::nv::EmNvDevRegUpdateSer dev_type() const;
  inline void set_dev_type(::nv::EmNvDevRegUpdateSer value);

  // optional string oem_mark = 2;
  inline bool has_oem_mark() const;
  inline void clear_oem_mark();
  static const int kOemMarkFieldNumber = 2;
  inline const ::std::string& oem_mark() const;
  inline void set_oem_mark(const ::std::string& value);
  inline void set_oem_mark(const char* value);
  inline void set_oem_mark(const char* value, size_t size);
  inline ::std::string* mutable_oem_mark();
  inline ::std::string* release_oem_mark();
  inline void set_allocated_oem_mark(::std::string* oem_mark);

  // optional string e164 = 3;
  inline bool has_e164() const;
  inline void clear_e164();
  static const int kE164FieldNumber = 3;
  inline const ::std::string& e164() const;
  inline void set_e164(const ::std::string& value);
  inline void set_e164(const char* value);
  inline void set_e164(const char* value, size_t size);
  inline ::std::string* mutable_e164();
  inline ::std::string* release_e164();
  inline void set_allocated_e164(::std::string* e164);

  // optional string cur_soft_ver = 4;
  inline bool has_cur_soft_ver() const;
  inline void clear_cur_soft_ver();
  static const int kCurSoftVerFieldNumber = 4;
  inline const ::std::string& cur_soft_ver() const;
  inline void set_cur_soft_ver(const ::std::string& value);
  inline void set_cur_soft_ver(const char* value);
  inline void set_cur_soft_ver(const char* value, size_t size);
  inline ::std::string* mutable_cur_soft_ver();
  inline ::std::string* release_cur_soft_ver();
  inline void set_allocated_cur_soft_ver(::std::string* cur_soft_ver);

  // optional uint32 dev_ip = 5;
  inline bool has_dev_ip() const;
  inline void clear_dev_ip();
  static const int kDevIpFieldNumber = 5;
  inline ::google::protobuf::uint32 dev_ip() const;
  inline void set_dev_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVUpgradeDeviceInfo)
 private:
  inline void set_has_dev_type();
  inline void clear_has_dev_type();
  inline void set_has_oem_mark();
  inline void clear_has_oem_mark();
  inline void set_has_e164();
  inline void clear_has_e164();
  inline void set_has_cur_soft_ver();
  inline void clear_has_cur_soft_ver();
  inline void set_has_dev_ip();
  inline void clear_has_dev_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* oem_mark_;
  ::std::string* e164_;
  int dev_type_;
  ::google::protobuf::uint32 dev_ip_;
  ::std::string* cur_soft_ver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUpgradeDeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUpgradeClientInfo : public ::google::protobuf::Message {
 public:
  TNVUpgradeClientInfo();
  virtual ~TNVUpgradeClientInfo();

  TNVUpgradeClientInfo(const TNVUpgradeClientInfo& from);

  inline TNVUpgradeClientInfo& operator=(const TNVUpgradeClientInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUpgradeClientInfo& default_instance();

  void Swap(TNVUpgradeClientInfo* other);

  // implements Message ----------------------------------------------

  TNVUpgradeClientInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUpgradeClientInfo& from);
  void MergeFrom(const TNVUpgradeClientInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.TNVUpgradeNetParam server_info = 1;
  inline bool has_server_info() const;
  inline void clear_server_info();
  static const int kServerInfoFieldNumber = 1;
  inline const ::nv::TNVUpgradeNetParam& server_info() const;
  inline ::nv::TNVUpgradeNetParam* mutable_server_info();
  inline ::nv::TNVUpgradeNetParam* release_server_info();
  inline void set_allocated_server_info(::nv::TNVUpgradeNetParam* server_info);

  // optional .nv.TNVUpgradeDeviceInfo dev_info = 2;
  inline bool has_dev_info() const;
  inline void clear_dev_info();
  static const int kDevInfoFieldNumber = 2;
  inline const ::nv::TNVUpgradeDeviceInfo& dev_info() const;
  inline ::nv::TNVUpgradeDeviceInfo* mutable_dev_info();
  inline ::nv::TNVUpgradeDeviceInfo* release_dev_info();
  inline void set_allocated_dev_info(::nv::TNVUpgradeDeviceInfo* dev_info);

  // @@protoc_insertion_point(class_scope:nv.TNVUpgradeClientInfo)
 private:
  inline void set_has_server_info();
  inline void clear_has_server_info();
  inline void set_has_dev_info();
  inline void clear_has_dev_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::nv::TNVUpgradeNetParam* server_info_;
  ::nv::TNVUpgradeDeviceInfo* dev_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUpgradeClientInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUpgradeGrayRange : public ::google::protobuf::Message {
 public:
  TNVUpgradeGrayRange();
  virtual ~TNVUpgradeGrayRange();

  TNVUpgradeGrayRange(const TNVUpgradeGrayRange& from);

  inline TNVUpgradeGrayRange& operator=(const TNVUpgradeGrayRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUpgradeGrayRange& default_instance();

  void Swap(TNVUpgradeGrayRange* other);

  // implements Message ----------------------------------------------

  TNVUpgradeGrayRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUpgradeGrayRange& from);
  void MergeFrom(const TNVUpgradeGrayRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string moid_list = 1;
  inline bool has_moid_list() const;
  inline void clear_moid_list();
  static const int kMoidListFieldNumber = 1;
  inline const ::std::string& moid_list() const;
  inline void set_moid_list(const ::std::string& value);
  inline void set_moid_list(const char* value);
  inline void set_moid_list(const char* value, size_t size);
  inline ::std::string* mutable_moid_list();
  inline ::std::string* release_moid_list();
  inline void set_allocated_moid_list(::std::string* moid_list);

  // optional string e164_list = 2;
  inline bool has_e164_list() const;
  inline void clear_e164_list();
  static const int kE164ListFieldNumber = 2;
  inline const ::std::string& e164_list() const;
  inline void set_e164_list(const ::std::string& value);
  inline void set_e164_list(const char* value);
  inline void set_e164_list(const char* value, size_t size);
  inline ::std::string* mutable_e164_list();
  inline ::std::string* release_e164_list();
  inline void set_allocated_e164_list(::std::string* e164_list);

  // @@protoc_insertion_point(class_scope:nv.TNVUpgradeGrayRange)
 private:
  inline void set_has_moid_list();
  inline void clear_has_moid_list();
  inline void set_has_e164_list();
  inline void clear_has_e164_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* moid_list_;
  ::std::string* e164_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUpgradeGrayRange* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUpgradeVersionInfo : public ::google::protobuf::Message {
 public:
  TNVUpgradeVersionInfo();
  virtual ~TNVUpgradeVersionInfo();

  TNVUpgradeVersionInfo(const TNVUpgradeVersionInfo& from);

  inline TNVUpgradeVersionInfo& operator=(const TNVUpgradeVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUpgradeVersionInfo& default_instance();

  void Swap(TNVUpgradeVersionInfo* other);

  // implements Message ----------------------------------------------

  TNVUpgradeVersionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUpgradeVersionInfo& from);
  void MergeFrom(const TNVUpgradeVersionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ver_id = 1;
  inline bool has_ver_id() const;
  inline void clear_ver_id();
  static const int kVerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 ver_id() const;
  inline void set_ver_id(::google::protobuf::uint32 value);

  // optional string oem_mark = 2;
  inline bool has_oem_mark() const;
  inline void clear_oem_mark();
  static const int kOemMarkFieldNumber = 2;
  inline const ::std::string& oem_mark() const;
  inline void set_oem_mark(const ::std::string& value);
  inline void set_oem_mark(const char* value);
  inline void set_oem_mark(const char* value, size_t size);
  inline ::std::string* mutable_oem_mark();
  inline ::std::string* release_oem_mark();
  inline void set_allocated_oem_mark(::std::string* oem_mark);

  // optional string dev_Type = 3;
  inline bool has_dev_type() const;
  inline void clear_dev_type();
  static const int kDevTypeFieldNumber = 3;
  inline const ::std::string& dev_type() const;
  inline void set_dev_type(const ::std::string& value);
  inline void set_dev_type(const char* value);
  inline void set_dev_type(const char* value, size_t size);
  inline ::std::string* mutable_dev_type();
  inline ::std::string* release_dev_type();
  inline void set_allocated_dev_type(::std::string* dev_type);

  // optional .nv.EmNvUpgradeVerLevel ver_level = 4;
  inline bool has_ver_level() const;
  inline void clear_ver_level();
  static const int kVerLevelFieldNumber = 4;
  inline ::nv::EmNvUpgradeVerLevel ver_level() const;
  inline void set_ver_level(::nv::EmNvUpgradeVerLevel value);

  // optional string soft_ver = 5;
  inline bool has_soft_ver() const;
  inline void clear_soft_ver();
  static const int kSoftVerFieldNumber = 5;
  inline const ::std::string& soft_ver() const;
  inline void set_soft_ver(const ::std::string& value);
  inline void set_soft_ver(const char* value);
  inline void set_soft_ver(const char* value, size_t size);
  inline ::std::string* mutable_soft_ver();
  inline ::std::string* release_soft_ver();
  inline void set_allocated_soft_ver(::std::string* soft_ver);

  // optional string ver_notes = 6;
  inline bool has_ver_notes() const;
  inline void clear_ver_notes();
  static const int kVerNotesFieldNumber = 6;
  inline const ::std::string& ver_notes() const;
  inline void set_ver_notes(const ::std::string& value);
  inline void set_ver_notes(const char* value);
  inline void set_ver_notes(const char* value, size_t size);
  inline ::std::string* mutable_ver_notes();
  inline ::std::string* release_ver_notes();
  inline void set_allocated_ver_notes(::std::string* ver_notes);

  // optional uint32 size = 7;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 7;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // optional .nv.EmNvUpgradeReleaseAttr ver_attr = 8;
  inline bool has_ver_attr() const;
  inline void clear_ver_attr();
  static const int kVerAttrFieldNumber = 8;
  inline ::nv::EmNvUpgradeReleaseAttr ver_attr() const;
  inline void set_ver_attr(::nv::EmNvUpgradeReleaseAttr value);

  // optional string file_name = 9;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 9;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional .nv.TNVUpgradeGrayRange gray_range = 10;
  inline bool has_gray_range() const;
  inline void clear_gray_range();
  static const int kGrayRangeFieldNumber = 10;
  inline const ::nv::TNVUpgradeGrayRange& gray_range() const;
  inline ::nv::TNVUpgradeGrayRange* mutable_gray_range();
  inline ::nv::TNVUpgradeGrayRange* release_gray_range();
  inline void set_allocated_gray_range(::nv::TNVUpgradeGrayRange* gray_range);

  // @@protoc_insertion_point(class_scope:nv.TNVUpgradeVersionInfo)
 private:
  inline void set_has_ver_id();
  inline void clear_has_ver_id();
  inline void set_has_oem_mark();
  inline void clear_has_oem_mark();
  inline void set_has_dev_type();
  inline void clear_has_dev_type();
  inline void set_has_ver_level();
  inline void clear_has_ver_level();
  inline void set_has_soft_ver();
  inline void clear_has_soft_ver();
  inline void set_has_ver_notes();
  inline void clear_has_ver_notes();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_ver_attr();
  inline void clear_has_ver_attr();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_gray_range();
  inline void clear_has_gray_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* oem_mark_;
  ::google::protobuf::uint32 ver_id_;
  int ver_level_;
  ::std::string* dev_type_;
  ::std::string* soft_ver_;
  ::std::string* ver_notes_;
  ::google::protobuf::uint32 size_;
  int ver_attr_;
  ::std::string* file_name_;
  ::nv::TNVUpgradeGrayRange* gray_range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUpgradeVersionInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUpgradeVersionInfoList : public ::google::protobuf::Message {
 public:
  TNVUpgradeVersionInfoList();
  virtual ~TNVUpgradeVersionInfoList();

  TNVUpgradeVersionInfoList(const TNVUpgradeVersionInfoList& from);

  inline TNVUpgradeVersionInfoList& operator=(const TNVUpgradeVersionInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUpgradeVersionInfoList& default_instance();

  void Swap(TNVUpgradeVersionInfoList* other);

  // implements Message ----------------------------------------------

  TNVUpgradeVersionInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUpgradeVersionInfoList& from);
  void MergeFrom(const TNVUpgradeVersionInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_get_recommend = 1;
  inline bool has_is_get_recommend() const;
  inline void clear_is_get_recommend();
  static const int kIsGetRecommendFieldNumber = 1;
  inline bool is_get_recommend() const;
  inline void set_is_get_recommend(bool value);

  // repeated .nv.TNVUpgradeVersionInfo ver_list = 2;
  inline int ver_list_size() const;
  inline void clear_ver_list();
  static const int kVerListFieldNumber = 2;
  inline const ::nv::TNVUpgradeVersionInfo& ver_list(int index) const;
  inline ::nv::TNVUpgradeVersionInfo* mutable_ver_list(int index);
  inline ::nv::TNVUpgradeVersionInfo* add_ver_list();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVUpgradeVersionInfo >&
      ver_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVUpgradeVersionInfo >*
      mutable_ver_list();

  // @@protoc_insertion_point(class_scope:nv.TNVUpgradeVersionInfoList)
 private:
  inline void set_has_is_get_recommend();
  inline void clear_has_is_get_recommend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVUpgradeVersionInfo > ver_list_;
  bool is_get_recommend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUpgradeVersionInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUpgradeDownloadInfo : public ::google::protobuf::Message {
 public:
  TNVUpgradeDownloadInfo();
  virtual ~TNVUpgradeDownloadInfo();

  TNVUpgradeDownloadInfo(const TNVUpgradeDownloadInfo& from);

  inline TNVUpgradeDownloadInfo& operator=(const TNVUpgradeDownloadInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUpgradeDownloadInfo& default_instance();

  void Swap(TNVUpgradeDownloadInfo* other);

  // implements Message ----------------------------------------------

  TNVUpgradeDownloadInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUpgradeDownloadInfo& from);
  void MergeFrom(const TNVUpgradeDownloadInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // optional uint32 total_percent = 2;
  inline bool has_total_percent() const;
  inline void clear_total_percent();
  static const int kTotalPercentFieldNumber = 2;
  inline ::google::protobuf::uint32 total_percent() const;
  inline void set_total_percent(::google::protobuf::uint32 value);

  // optional uint32 cur_percent = 3;
  inline bool has_cur_percent() const;
  inline void clear_cur_percent();
  static const int kCurPercentFieldNumber = 3;
  inline ::google::protobuf::uint32 cur_percent() const;
  inline void set_cur_percent(::google::protobuf::uint32 value);

  // optional string cur_file_name = 4;
  inline bool has_cur_file_name() const;
  inline void clear_cur_file_name();
  static const int kCurFileNameFieldNumber = 4;
  inline const ::std::string& cur_file_name() const;
  inline void set_cur_file_name(const ::std::string& value);
  inline void set_cur_file_name(const char* value);
  inline void set_cur_file_name(const char* value, size_t size);
  inline ::std::string* mutable_cur_file_name();
  inline ::std::string* release_cur_file_name();
  inline void set_allocated_cur_file_name(::std::string* cur_file_name);

  // @@protoc_insertion_point(class_scope:nv.TNVUpgradeDownloadInfo)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_total_percent();
  inline void clear_has_total_percent();
  inline void set_has_cur_percent();
  inline void clear_has_cur_percent();
  inline void set_has_cur_file_name();
  inline void clear_has_cur_file_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 total_percent_;
  ::std::string* cur_file_name_;
  ::google::protobuf::uint32 cur_percent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUpgradeDownloadInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVSUSAddr : public ::google::protobuf::Message {
 public:
  TNVSUSAddr();
  virtual ~TNVSUSAddr();

  TNVSUSAddr(const TNVSUSAddr& from);

  inline TNVSUSAddr& operator=(const TNVSUSAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVSUSAddr& default_instance();

  void Swap(TNVSUSAddr* other);

  // implements Message ----------------------------------------------

  TNVSUSAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVSUSAddr& from);
  void MergeFrom(const TNVSUSAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional bool use_default_addr = 4;
  inline bool has_use_default_addr() const;
  inline void clear_use_default_addr();
  static const int kUseDefaultAddrFieldNumber = 4;
  inline bool use_default_addr() const;
  inline void set_use_default_addr(bool value);

  // optional string custom_domain = 5;
  inline bool has_custom_domain() const;
  inline void clear_custom_domain();
  static const int kCustomDomainFieldNumber = 5;
  inline const ::std::string& custom_domain() const;
  inline void set_custom_domain(const ::std::string& value);
  inline void set_custom_domain(const char* value);
  inline void set_custom_domain(const char* value, size_t size);
  inline ::std::string* mutable_custom_domain();
  inline ::std::string* release_custom_domain();
  inline void set_allocated_custom_domain(::std::string* custom_domain);

  // optional uint32 custom_ip = 6;
  inline bool has_custom_ip() const;
  inline void clear_custom_ip();
  static const int kCustomIpFieldNumber = 6;
  inline ::google::protobuf::uint32 custom_ip() const;
  inline void set_custom_ip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVSUSAddr)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_use_default_addr();
  inline void clear_has_use_default_addr();
  inline void set_has_custom_domain();
  inline void clear_has_custom_domain();
  inline void set_has_custom_ip();
  inline void clear_has_custom_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::std::string* custom_domain_;
  bool use_default_addr_;
  ::google::protobuf::uint32 custom_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVSUSAddr* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUserFullInfo : public ::google::protobuf::Message {
 public:
  TNVUserFullInfo();
  virtual ~TNVUserFullInfo();

  TNVUserFullInfo(const TNVUserFullInfo& from);

  inline TNVUserFullInfo& operator=(const TNVUserFullInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUserFullInfo& default_instance();

  void Swap(TNVUserFullInfo* other);

  // implements Message ----------------------------------------------

  TNVUserFullInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUserFullInfo& from);
  void MergeFrom(const TNVUserFullInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 guid() const;
  inline void set_guid(::google::protobuf::uint32 value);

  // optional .nv.EmNvNvcType nvc_type = 2;
  inline bool has_nvc_type() const;
  inline void clear_nvc_type();
  static const int kNvcTypeFieldNumber = 2;
  inline ::nv::EmNvNvcType nvc_type() const;
  inline void set_nvc_type(::nv::EmNvNvcType value);

  // optional string user_name = 3;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional uint32 actor = 5;
  inline bool has_actor() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 5;
  inline ::google::protobuf::uint32 actor() const;
  inline void set_actor(::google::protobuf::uint32 value);

  // optional string full_user_name = 6;
  inline bool has_full_user_name() const;
  inline void clear_full_user_name();
  static const int kFullUserNameFieldNumber = 6;
  inline const ::std::string& full_user_name() const;
  inline void set_full_user_name(const ::std::string& value);
  inline void set_full_user_name(const char* value);
  inline void set_full_user_name(const char* value, size_t size);
  inline ::std::string* mutable_full_user_name();
  inline ::std::string* release_full_user_name();
  inline void set_allocated_full_user_name(::std::string* full_user_name);

  // optional string user_discription = 7;
  inline bool has_user_discription() const;
  inline void clear_user_discription();
  static const int kUserDiscriptionFieldNumber = 7;
  inline const ::std::string& user_discription() const;
  inline void set_user_discription(const ::std::string& value);
  inline void set_user_discription(const char* value);
  inline void set_user_discription(const char* value, size_t size);
  inline ::std::string* mutable_user_discription();
  inline ::std::string* release_user_discription();
  inline void set_allocated_user_discription(::std::string* user_discription);

  // @@protoc_insertion_point(class_scope:nv.TNVUserFullInfo)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_nvc_type();
  inline void clear_has_nvc_type();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_actor();
  inline void clear_has_actor();
  inline void set_has_full_user_name();
  inline void clear_has_full_user_name();
  inline void set_has_user_discription();
  inline void clear_has_user_discription();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 guid_;
  int nvc_type_;
  ::std::string* user_name_;
  ::std::string* password_;
  ::std::string* full_user_name_;
  ::std::string* user_discription_;
  ::google::protobuf::uint32 actor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUserFullInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUserReqResult : public ::google::protobuf::Message {
 public:
  TNVUserReqResult();
  virtual ~TNVUserReqResult();

  TNVUserReqResult(const TNVUserReqResult& from);

  inline TNVUserReqResult& operator=(const TNVUserReqResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUserReqResult& default_instance();

  void Swap(TNVUserReqResult* other);

  // implements Message ----------------------------------------------

  TNVUserReqResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUserReqResult& from);
  void MergeFrom(const TNVUserReqResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.TNVUserFullInfo user_info = 1;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  inline const ::nv::TNVUserFullInfo& user_info() const;
  inline ::nv::TNVUserFullInfo* mutable_user_info();
  inline ::nv::TNVUserFullInfo* release_user_info();
  inline void set_allocated_user_info(::nv::TNVUserFullInfo* user_info);

  // optional uint32 user_req_result = 2;
  inline bool has_user_req_result() const;
  inline void clear_user_req_result();
  static const int kUserReqResultFieldNumber = 2;
  inline ::google::protobuf::uint32 user_req_result() const;
  inline void set_user_req_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVUserReqResult)
 private:
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_user_req_result();
  inline void clear_has_user_req_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::nv::TNVUserFullInfo* user_info_;
  ::google::protobuf::uint32 user_req_result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUserReqResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMultiUserFullInfo : public ::google::protobuf::Message {
 public:
  TNVMultiUserFullInfo();
  virtual ~TNVMultiUserFullInfo();

  TNVMultiUserFullInfo(const TNVMultiUserFullInfo& from);

  inline TNVMultiUserFullInfo& operator=(const TNVMultiUserFullInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMultiUserFullInfo& default_instance();

  void Swap(TNVMultiUserFullInfo* other);

  // implements Message ----------------------------------------------

  TNVMultiUserFullInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMultiUserFullInfo& from);
  void MergeFrom(const TNVMultiUserFullInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVUserFullInfo multi_user_info = 1;
  inline int multi_user_info_size() const;
  inline void clear_multi_user_info();
  static const int kMultiUserInfoFieldNumber = 1;
  inline const ::nv::TNVUserFullInfo& multi_user_info(int index) const;
  inline ::nv::TNVUserFullInfo* mutable_multi_user_info(int index);
  inline ::nv::TNVUserFullInfo* add_multi_user_info();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVUserFullInfo >&
      multi_user_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVUserFullInfo >*
      mutable_multi_user_info();

  // @@protoc_insertion_point(class_scope:nv.TNVMultiUserFullInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVUserFullInfo > multi_user_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVMultiUserFullInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMultiUserReqResult : public ::google::protobuf::Message {
 public:
  TNVMultiUserReqResult();
  virtual ~TNVMultiUserReqResult();

  TNVMultiUserReqResult(const TNVMultiUserReqResult& from);

  inline TNVMultiUserReqResult& operator=(const TNVMultiUserReqResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMultiUserReqResult& default_instance();

  void Swap(TNVMultiUserReqResult* other);

  // implements Message ----------------------------------------------

  TNVMultiUserReqResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMultiUserReqResult& from);
  void MergeFrom(const TNVMultiUserReqResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVUserReqResult multi_user_req_result = 1;
  inline int multi_user_req_result_size() const;
  inline void clear_multi_user_req_result();
  static const int kMultiUserReqResultFieldNumber = 1;
  inline const ::nv::TNVUserReqResult& multi_user_req_result(int index) const;
  inline ::nv::TNVUserReqResult* mutable_multi_user_req_result(int index);
  inline ::nv::TNVUserReqResult* add_multi_user_req_result();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVUserReqResult >&
      multi_user_req_result() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVUserReqResult >*
      mutable_multi_user_req_result();

  // @@protoc_insertion_point(class_scope:nv.TNVMultiUserReqResult)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVUserReqResult > multi_user_req_result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVMultiUserReqResult* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUserConnectInfo : public ::google::protobuf::Message {
 public:
  TNVUserConnectInfo();
  virtual ~TNVUserConnectInfo();

  TNVUserConnectInfo(const TNVUserConnectInfo& from);

  inline TNVUserConnectInfo& operator=(const TNVUserConnectInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUserConnectInfo& default_instance();

  void Swap(TNVUserConnectInfo* other);

  // implements Message ----------------------------------------------

  TNVUserConnectInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUserConnectInfo& from);
  void MergeFrom(const TNVUserConnectInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mt_ip = 1;
  inline bool has_mt_ip() const;
  inline void clear_mt_ip();
  static const int kMtIpFieldNumber = 1;
  inline const ::std::string& mt_ip() const;
  inline void set_mt_ip(const ::std::string& value);
  inline void set_mt_ip(const char* value);
  inline void set_mt_ip(const char* value, size_t size);
  inline ::std::string* mutable_mt_ip();
  inline ::std::string* release_mt_ip();
  inline void set_allocated_mt_ip(::std::string* mt_ip);

  // optional uint32 listen_port = 2;
  inline bool has_listen_port() const;
  inline void clear_listen_port();
  static const int kListenPortFieldNumber = 2;
  inline ::google::protobuf::uint32 listen_port() const;
  inline void set_listen_port(::google::protobuf::uint32 value);

  // optional .nv.EmNvNvcType nvc_type = 3;
  inline bool has_nvc_type() const;
  inline void clear_nvc_type();
  static const int kNvcTypeFieldNumber = 3;
  inline ::nv::EmNvNvcType nvc_type() const;
  inline void set_nvc_type(::nv::EmNvNvcType value);

  // optional string user_name = 4;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 4;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:nv.TNVUserConnectInfo)
 private:
  inline void set_has_mt_ip();
  inline void clear_has_mt_ip();
  inline void set_has_listen_port();
  inline void clear_has_listen_port();
  inline void set_has_nvc_type();
  inline void clear_has_nvc_type();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mt_ip_;
  ::google::protobuf::uint32 listen_port_;
  int nvc_type_;
  ::std::string* user_name_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUserConnectInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVEthnetCardInfo : public ::google::protobuf::Message {
 public:
  TNVEthnetCardInfo();
  virtual ~TNVEthnetCardInfo();

  TNVEthnetCardInfo(const TNVEthnetCardInfo& from);

  inline TNVEthnetCardInfo& operator=(const TNVEthnetCardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVEthnetCardInfo& default_instance();

  void Swap(TNVEthnetCardInfo* other);

  // implements Message ----------------------------------------------

  TNVEthnetCardInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVEthnetCardInfo& from);
  void MergeFrom(const TNVEthnetCardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_ip_dhcp = 1;
  inline bool has_enable_ip_dhcp() const;
  inline void clear_enable_ip_dhcp();
  static const int kEnableIpDhcpFieldNumber = 1;
  inline bool enable_ip_dhcp() const;
  inline void set_enable_ip_dhcp(bool value);

  // optional uint32 static_ip = 2;
  inline bool has_static_ip() const;
  inline void clear_static_ip();
  static const int kStaticIpFieldNumber = 2;
  inline ::google::protobuf::uint32 static_ip() const;
  inline void set_static_ip(::google::protobuf::uint32 value);

  // optional uint32 static_mask = 3;
  inline bool has_static_mask() const;
  inline void clear_static_mask();
  static const int kStaticMaskFieldNumber = 3;
  inline ::google::protobuf::uint32 static_mask() const;
  inline void set_static_mask(::google::protobuf::uint32 value);

  // optional uint32 static_gateway_ip = 4;
  inline bool has_static_gateway_ip() const;
  inline void clear_static_gateway_ip();
  static const int kStaticGatewayIpFieldNumber = 4;
  inline ::google::protobuf::uint32 static_gateway_ip() const;
  inline void set_static_gateway_ip(::google::protobuf::uint32 value);

  // optional uint32 dhcp_ip = 5;
  inline bool has_dhcp_ip() const;
  inline void clear_dhcp_ip();
  static const int kDhcpIpFieldNumber = 5;
  inline ::google::protobuf::uint32 dhcp_ip() const;
  inline void set_dhcp_ip(::google::protobuf::uint32 value);

  // optional uint32 dhcp_mask = 6;
  inline bool has_dhcp_mask() const;
  inline void clear_dhcp_mask();
  static const int kDhcpMaskFieldNumber = 6;
  inline ::google::protobuf::uint32 dhcp_mask() const;
  inline void set_dhcp_mask(::google::protobuf::uint32 value);

  // optional uint32 dhcp_gateway = 7;
  inline bool has_dhcp_gateway() const;
  inline void clear_dhcp_gateway();
  static const int kDhcpGatewayFieldNumber = 7;
  inline ::google::protobuf::uint32 dhcp_gateway() const;
  inline void set_dhcp_gateway(::google::protobuf::uint32 value);

  // optional bool enable_dns_dhcp = 8;
  inline bool has_enable_dns_dhcp() const;
  inline void clear_enable_dns_dhcp();
  static const int kEnableDnsDhcpFieldNumber = 8;
  inline bool enable_dns_dhcp() const;
  inline void set_enable_dns_dhcp(bool value);

  // optional uint32 static_dns = 9;
  inline bool has_static_dns() const;
  inline void clear_static_dns();
  static const int kStaticDnsFieldNumber = 9;
  inline ::google::protobuf::uint32 static_dns() const;
  inline void set_static_dns(::google::protobuf::uint32 value);

  // optional uint32 static_dns_backup = 10;
  inline bool has_static_dns_backup() const;
  inline void clear_static_dns_backup();
  static const int kStaticDnsBackupFieldNumber = 10;
  inline ::google::protobuf::uint32 static_dns_backup() const;
  inline void set_static_dns_backup(::google::protobuf::uint32 value);

  // optional uint32 dhcp_dns = 11;
  inline bool has_dhcp_dns() const;
  inline void clear_dhcp_dns();
  static const int kDhcpDnsFieldNumber = 11;
  inline ::google::protobuf::uint32 dhcp_dns() const;
  inline void set_dhcp_dns(::google::protobuf::uint32 value);

  // optional uint32 dhcp_dns_backup = 12;
  inline bool has_dhcp_dns_backup() const;
  inline void clear_dhcp_dns_backup();
  static const int kDhcpDnsBackupFieldNumber = 12;
  inline ::google::protobuf::uint32 dhcp_dns_backup() const;
  inline void set_dhcp_dns_backup(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVEthnetCardInfo)
 private:
  inline void set_has_enable_ip_dhcp();
  inline void clear_has_enable_ip_dhcp();
  inline void set_has_static_ip();
  inline void clear_has_static_ip();
  inline void set_has_static_mask();
  inline void clear_has_static_mask();
  inline void set_has_static_gateway_ip();
  inline void clear_has_static_gateway_ip();
  inline void set_has_dhcp_ip();
  inline void clear_has_dhcp_ip();
  inline void set_has_dhcp_mask();
  inline void clear_has_dhcp_mask();
  inline void set_has_dhcp_gateway();
  inline void clear_has_dhcp_gateway();
  inline void set_has_enable_dns_dhcp();
  inline void clear_has_enable_dns_dhcp();
  inline void set_has_static_dns();
  inline void clear_has_static_dns();
  inline void set_has_static_dns_backup();
  inline void clear_has_static_dns_backup();
  inline void set_has_dhcp_dns();
  inline void clear_has_dhcp_dns();
  inline void set_has_dhcp_dns_backup();
  inline void clear_has_dhcp_dns_backup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 static_ip_;
  ::google::protobuf::uint32 static_mask_;
  ::google::protobuf::uint32 static_gateway_ip_;
  bool enable_ip_dhcp_;
  bool enable_dns_dhcp_;
  ::google::protobuf::uint32 dhcp_ip_;
  ::google::protobuf::uint32 dhcp_mask_;
  ::google::protobuf::uint32 dhcp_gateway_;
  ::google::protobuf::uint32 static_dns_;
  ::google::protobuf::uint32 static_dns_backup_;
  ::google::protobuf::uint32 dhcp_dns_;
  ::google::protobuf::uint32 dhcp_dns_backup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVEthnetCardInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVEthnetCfg : public ::google::protobuf::Message {
 public:
  TNVEthnetCfg();
  virtual ~TNVEthnetCfg();

  TNVEthnetCfg(const TNVEthnetCfg& from);

  inline TNVEthnetCfg& operator=(const TNVEthnetCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVEthnetCfg& default_instance();

  void Swap(TNVEthnetCfg* other);

  // implements Message ----------------------------------------------

  TNVEthnetCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVEthnetCfg& from);
  void MergeFrom(const TNVEthnetCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvEthInterfaceMode ethnet_backupmode = 1;
  inline bool has_ethnet_backupmode() const;
  inline void clear_ethnet_backupmode();
  static const int kEthnetBackupmodeFieldNumber = 1;
  inline ::nv::EmNvEthInterfaceMode ethnet_backupmode() const;
  inline void set_ethnet_backupmode(::nv::EmNvEthInterfaceMode value);

  // optional uint32 cur_cardid = 2;
  inline bool has_cur_cardid() const;
  inline void clear_cur_cardid();
  static const int kCurCardidFieldNumber = 2;
  inline ::google::protobuf::uint32 cur_cardid() const;
  inline void set_cur_cardid(::google::protobuf::uint32 value);

  // optional .nv.TNVEthnetCardInfo eth1 = 3;
  inline bool has_eth1() const;
  inline void clear_eth1();
  static const int kEth1FieldNumber = 3;
  inline const ::nv::TNVEthnetCardInfo& eth1() const;
  inline ::nv::TNVEthnetCardInfo* mutable_eth1();
  inline ::nv::TNVEthnetCardInfo* release_eth1();
  inline void set_allocated_eth1(::nv::TNVEthnetCardInfo* eth1);

  // optional .nv.TNVEthnetCardInfo eth2 = 4;
  inline bool has_eth2() const;
  inline void clear_eth2();
  static const int kEth2FieldNumber = 4;
  inline const ::nv::TNVEthnetCardInfo& eth2() const;
  inline ::nv::TNVEthnetCardInfo* mutable_eth2();
  inline ::nv::TNVEthnetCardInfo* release_eth2();
  inline void set_allocated_eth2(::nv::TNVEthnetCardInfo* eth2);

  // @@protoc_insertion_point(class_scope:nv.TNVEthnetCfg)
 private:
  inline void set_has_ethnet_backupmode();
  inline void clear_has_ethnet_backupmode();
  inline void set_has_cur_cardid();
  inline void clear_has_cur_cardid();
  inline void set_has_eth1();
  inline void clear_has_eth1();
  inline void set_has_eth2();
  inline void clear_has_eth2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ethnet_backupmode_;
  ::google::protobuf::uint32 cur_cardid_;
  ::nv::TNVEthnetCardInfo* eth1_;
  ::nv::TNVEthnetCardInfo* eth2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVEthnetCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVLastDisplay : public ::google::protobuf::Message {
 public:
  TNVLastDisplay();
  virtual ~TNVLastDisplay();

  TNVLastDisplay(const TNVLastDisplay& from);

  inline TNVLastDisplay& operator=(const TNVLastDisplay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVLastDisplay& default_instance();

  void Swap(TNVLastDisplay* other);

  // implements Message ----------------------------------------------

  TNVLastDisplay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVLastDisplay& from);
  void MergeFrom(const TNVLastDisplay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvHDLastDisplay emLastDisplayType = 1;
  inline bool has_emlastdisplaytype() const;
  inline void clear_emlastdisplaytype();
  static const int kEmLastDisplayTypeFieldNumber = 1;
  inline ::nv::EmNvHDLastDisplay emlastdisplaytype() const;
  inline void set_emlastdisplaytype(::nv::EmNvHDLastDisplay value);

  // optional uint32 wait_timer = 2;
  inline bool has_wait_timer() const;
  inline void clear_wait_timer();
  static const int kWaitTimerFieldNumber = 2;
  inline ::google::protobuf::uint32 wait_timer() const;
  inline void set_wait_timer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVLastDisplay)
 private:
  inline void set_has_emlastdisplaytype();
  inline void clear_has_emlastdisplaytype();
  inline void set_has_wait_timer();
  inline void clear_has_wait_timer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emlastdisplaytype_;
  ::google::protobuf::uint32 wait_timer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVLastDisplay* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVResizeMode : public ::google::protobuf::Message {
 public:
  TNVResizeMode();
  virtual ~TNVResizeMode();

  TNVResizeMode(const TNVResizeMode& from);

  inline TNVResizeMode& operator=(const TNVResizeMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVResizeMode& default_instance();

  void Swap(TNVResizeMode* other);

  // implements Message ----------------------------------------------

  TNVResizeMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVResizeMode& from);
  void MergeFrom(const TNVResizeMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvResizeMode emResizeMode = 1;
  inline bool has_emresizemode() const;
  inline void clear_emresizemode();
  static const int kEmResizeModeFieldNumber = 1;
  inline ::nv::EmNvResizeMode emresizemode() const;
  inline void set_emresizemode(::nv::EmNvResizeMode value);

  // @@protoc_insertion_point(class_scope:nv.TNVResizeMode)
 private:
  inline void set_has_emresizemode();
  inline void clear_has_emresizemode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emresizemode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVResizeMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVHDImageNoise : public ::google::protobuf::Message {
 public:
  TNVHDImageNoise();
  virtual ~TNVHDImageNoise();

  TNVHDImageNoise(const TNVHDImageNoise& from);

  inline TNVHDImageNoise& operator=(const TNVHDImageNoise& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVHDImageNoise& default_instance();

  void Swap(TNVHDImageNoise* other);

  // implements Message ----------------------------------------------

  TNVHDImageNoise* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVHDImageNoise& from);
  void MergeFrom(const TNVHDImageNoise& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvHDImageNoise emNoiseLevel = 1;
  inline bool has_emnoiselevel() const;
  inline void clear_emnoiselevel();
  static const int kEmNoiseLevelFieldNumber = 1;
  inline ::nv::EmNvHDImageNoise emnoiselevel() const;
  inline void set_emnoiselevel(::nv::EmNvHDImageNoise value);

  // @@protoc_insertion_point(class_scope:nv.TNVHDImageNoise)
 private:
  inline void set_has_emnoiselevel();
  inline void clear_has_emnoiselevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emnoiselevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVHDImageNoise* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVHDImageDeformationTensile : public ::google::protobuf::Message {
 public:
  TNVHDImageDeformationTensile();
  virtual ~TNVHDImageDeformationTensile();

  TNVHDImageDeformationTensile(const TNVHDImageDeformationTensile& from);

  inline TNVHDImageDeformationTensile& operator=(const TNVHDImageDeformationTensile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVHDImageDeformationTensile& default_instance();

  void Swap(TNVHDImageDeformationTensile* other);

  // implements Message ----------------------------------------------

  TNVHDImageDeformationTensile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVHDImageDeformationTensile& from);
  void MergeFrom(const TNVHDImageDeformationTensile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvCodecComponent CodecType = 1;
  inline bool has_codectype() const;
  inline void clear_codectype();
  static const int kCodecTypeFieldNumber = 1;
  inline ::nv::EmNvCodecComponent codectype() const;
  inline void set_codectype(::nv::EmNvCodecComponent value);

  // optional .nv.EmNvCodecComponentIndex CodecIndex = 2;
  inline bool has_codecindex() const;
  inline void clear_codecindex();
  static const int kCodecIndexFieldNumber = 2;
  inline ::nv::EmNvCodecComponentIndex codecindex() const;
  inline void set_codecindex(::nv::EmNvCodecComponentIndex value);

  // optional uint32 left_right_number = 3;
  inline bool has_left_right_number() const;
  inline void clear_left_right_number();
  static const int kLeftRightNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 left_right_number() const;
  inline void set_left_right_number(::google::protobuf::uint32 value);

  // optional uint32 up_down_number = 4;
  inline bool has_up_down_number() const;
  inline void clear_up_down_number();
  static const int kUpDownNumberFieldNumber = 4;
  inline ::google::protobuf::uint32 up_down_number() const;
  inline void set_up_down_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVHDImageDeformationTensile)
 private:
  inline void set_has_codectype();
  inline void clear_has_codectype();
  inline void set_has_codecindex();
  inline void clear_has_codecindex();
  inline void set_has_left_right_number();
  inline void clear_has_left_right_number();
  inline void set_has_up_down_number();
  inline void clear_has_up_down_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int codectype_;
  int codecindex_;
  ::google::protobuf::uint32 left_right_number_;
  ::google::protobuf::uint32 up_down_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVHDImageDeformationTensile* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVImixVidSourceInfo : public ::google::protobuf::Message {
 public:
  TNVImixVidSourceInfo();
  virtual ~TNVImixVidSourceInfo();

  TNVImixVidSourceInfo(const TNVImixVidSourceInfo& from);

  inline TNVImixVidSourceInfo& operator=(const TNVImixVidSourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVImixVidSourceInfo& default_instance();

  void Swap(TNVImixVidSourceInfo* other);

  // implements Message ----------------------------------------------

  TNVImixVidSourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVImixVidSourceInfo& from);
  void MergeFrom(const TNVImixVidSourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvImixVidSrcType emVidType = 1;
  inline bool has_emvidtype() const;
  inline void clear_emvidtype();
  static const int kEmVidTypeFieldNumber = 1;
  inline ::nv::EmNvImixVidSrcType emvidtype() const;
  inline void set_emvidtype(::nv::EmNvImixVidSrcType value);

  // optional bool enable_have_src = 2;
  inline bool has_enable_have_src() const;
  inline void clear_enable_have_src();
  static const int kEnableHaveSrcFieldNumber = 2;
  inline bool enable_have_src() const;
  inline void set_enable_have_src(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVImixVidSourceInfo)
 private:
  inline void set_has_emvidtype();
  inline void clear_has_emvidtype();
  inline void set_has_enable_have_src();
  inline void clear_has_enable_have_src();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emvidtype_;
  bool enable_have_src_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVImixVidSourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMultiImixVidSourceInfo : public ::google::protobuf::Message {
 public:
  TNVMultiImixVidSourceInfo();
  virtual ~TNVMultiImixVidSourceInfo();

  TNVMultiImixVidSourceInfo(const TNVMultiImixVidSourceInfo& from);

  inline TNVMultiImixVidSourceInfo& operator=(const TNVMultiImixVidSourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMultiImixVidSourceInfo& default_instance();

  void Swap(TNVMultiImixVidSourceInfo* other);

  // implements Message ----------------------------------------------

  TNVMultiImixVidSourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMultiImixVidSourceInfo& from);
  void MergeFrom(const TNVMultiImixVidSourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVImixVidSourceInfo multi_src_info = 1;
  inline int multi_src_info_size() const;
  inline void clear_multi_src_info();
  static const int kMultiSrcInfoFieldNumber = 1;
  inline const ::nv::TNVImixVidSourceInfo& multi_src_info(int index) const;
  inline ::nv::TNVImixVidSourceInfo* mutable_multi_src_info(int index);
  inline ::nv::TNVImixVidSourceInfo* add_multi_src_info();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVImixVidSourceInfo >&
      multi_src_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVImixVidSourceInfo >*
      mutable_multi_src_info();

  // @@protoc_insertion_point(class_scope:nv.TNVMultiImixVidSourceInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVImixVidSourceInfo > multi_src_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVMultiImixVidSourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVApiStartInfo : public ::google::protobuf::Message {
 public:
  TNVApiStartInfo();
  virtual ~TNVApiStartInfo();

  TNVApiStartInfo(const TNVApiStartInfo& from);

  inline TNVApiStartInfo& operator=(const TNVApiStartInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVApiStartInfo& default_instance();

  void Swap(TNVApiStartInfo* other);

  // implements Message ----------------------------------------------

  TNVApiStartInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVApiStartInfo& from);
  void MergeFrom(const TNVApiStartInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvApiMode emApiMode = 1;
  inline bool has_emapimode() const;
  inline void clear_emapimode();
  static const int kEmApiModeFieldNumber = 1;
  inline ::nv::EmNvApiMode emapimode() const;
  inline void set_emapimode(::nv::EmNvApiMode value);

  // optional bool enable_UniqueLogFile = 2;
  inline bool has_enable_uniquelogfile() const;
  inline void clear_enable_uniquelogfile();
  static const int kEnableUniqueLogFileFieldNumber = 2;
  inline bool enable_uniquelogfile() const;
  inline void set_enable_uniquelogfile(bool value);

  // optional string log_ip = 3;
  inline bool has_log_ip() const;
  inline void clear_log_ip();
  static const int kLogIpFieldNumber = 3;
  inline const ::std::string& log_ip() const;
  inline void set_log_ip(const ::std::string& value);
  inline void set_log_ip(const char* value);
  inline void set_log_ip(const char* value, size_t size);
  inline ::std::string* mutable_log_ip();
  inline ::std::string* release_log_ip();
  inline void set_allocated_log_ip(::std::string* log_ip);

  // optional string filepath = 4;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 4;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // optional bool enable_ToFileLogServer = 5;
  inline bool has_enable_tofilelogserver() const;
  inline void clear_enable_tofilelogserver();
  static const int kEnableToFileLogServerFieldNumber = 5;
  inline bool enable_tofilelogserver() const;
  inline void set_enable_tofilelogserver(bool value);

  // optional string strCltTag = 6;
  inline bool has_strclttag() const;
  inline void clear_strclttag();
  static const int kStrCltTagFieldNumber = 6;
  inline const ::std::string& strclttag() const;
  inline void set_strclttag(const ::std::string& value);
  inline void set_strclttag(const char* value);
  inline void set_strclttag(const char* value, size_t size);
  inline ::std::string* mutable_strclttag();
  inline ::std::string* release_strclttag();
  inline void set_allocated_strclttag(::std::string* strclttag);

  // @@protoc_insertion_point(class_scope:nv.TNVApiStartInfo)
 private:
  inline void set_has_emapimode();
  inline void clear_has_emapimode();
  inline void set_has_enable_uniquelogfile();
  inline void clear_has_enable_uniquelogfile();
  inline void set_has_log_ip();
  inline void clear_has_log_ip();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_enable_tofilelogserver();
  inline void clear_has_enable_tofilelogserver();
  inline void set_has_strclttag();
  inline void clear_has_strclttag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int emapimode_;
  bool enable_uniquelogfile_;
  bool enable_tofilelogserver_;
  ::std::string* log_ip_;
  ::std::string* filepath_;
  ::std::string* strclttag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVApiStartInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVLoginInfo : public ::google::protobuf::Message {
 public:
  TNVLoginInfo();
  virtual ~TNVLoginInfo();

  TNVLoginInfo(const TNVLoginInfo& from);

  inline TNVLoginInfo& operator=(const TNVLoginInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVLoginInfo& default_instance();

  void Swap(TNVLoginInfo* other);

  // implements Message ----------------------------------------------

  TNVLoginInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVLoginInfo& from);
  void MergeFrom(const TNVLoginInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 node_id() const;
  inline void set_node_id(::google::protobuf::uint32 value);

  // optional uint32 appinst_id = 2;
  inline bool has_appinst_id() const;
  inline void clear_appinst_id();
  static const int kAppinstIdFieldNumber = 2;
  inline ::google::protobuf::uint32 appinst_id() const;
  inline void set_appinst_id(::google::protobuf::uint32 value);

  // optional string pcname = 3;
  inline bool has_pcname() const;
  inline void clear_pcname();
  static const int kPcnameFieldNumber = 3;
  inline const ::std::string& pcname() const;
  inline void set_pcname(const ::std::string& value);
  inline void set_pcname(const char* value);
  inline void set_pcname(const char* value, size_t size);
  inline ::std::string* mutable_pcname();
  inline ::std::string* release_pcname();
  inline void set_allocated_pcname(::std::string* pcname);

  // optional .nv.EmNvImixVidSrcType empos = 4;
  inline bool has_empos() const;
  inline void clear_empos();
  static const int kEmposFieldNumber = 4;
  inline ::nv::EmNvImixVidSrcType empos() const;
  inline void set_empos(::nv::EmNvImixVidSrcType value);

  // optional bool is_active = 5;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 5;
  inline bool is_active() const;
  inline void set_is_active(bool value);

  // optional bool is_viewppt = 6;
  inline bool has_is_viewppt() const;
  inline void clear_is_viewppt();
  static const int kIsViewpptFieldNumber = 6;
  inline bool is_viewppt() const;
  inline void set_is_viewppt(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVLoginInfo)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_appinst_id();
  inline void clear_has_appinst_id();
  inline void set_has_pcname();
  inline void clear_has_pcname();
  inline void set_has_empos();
  inline void clear_has_empos();
  inline void set_has_is_active();
  inline void clear_has_is_active();
  inline void set_has_is_viewppt();
  inline void clear_has_is_viewppt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 node_id_;
  ::google::protobuf::uint32 appinst_id_;
  ::std::string* pcname_;
  int empos_;
  bool is_active_;
  bool is_viewppt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVLoginInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVLoginInfos : public ::google::protobuf::Message {
 public:
  TNVLoginInfos();
  virtual ~TNVLoginInfos();

  TNVLoginInfos(const TNVLoginInfos& from);

  inline TNVLoginInfos& operator=(const TNVLoginInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVLoginInfos& default_instance();

  void Swap(TNVLoginInfos* other);

  // implements Message ----------------------------------------------

  TNVLoginInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVLoginInfos& from);
  void MergeFrom(const TNVLoginInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVLoginInfo login_info_list = 1;
  inline int login_info_list_size() const;
  inline void clear_login_info_list();
  static const int kLoginInfoListFieldNumber = 1;
  inline const ::nv::TNVLoginInfo& login_info_list(int index) const;
  inline ::nv::TNVLoginInfo* mutable_login_info_list(int index);
  inline ::nv::TNVLoginInfo* add_login_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVLoginInfo >&
      login_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVLoginInfo >*
      mutable_login_info_list();

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVLoginInfos)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVLoginInfo > login_info_list_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVLoginInfos* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVImixVidSrcSignal : public ::google::protobuf::Message {
 public:
  TNVImixVidSrcSignal();
  virtual ~TNVImixVidSrcSignal();

  TNVImixVidSrcSignal(const TNVImixVidSrcSignal& from);

  inline TNVImixVidSrcSignal& operator=(const TNVImixVidSrcSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVImixVidSrcSignal& default_instance();

  void Swap(TNVImixVidSrcSignal* other);

  // implements Message ----------------------------------------------

  TNVImixVidSrcSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVImixVidSrcSignal& from);
  void MergeFrom(const TNVImixVidSrcSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvImixVidSrcType src_type = 1;
  inline bool has_src_type() const;
  inline void clear_src_type();
  static const int kSrcTypeFieldNumber = 1;
  inline ::nv::EmNvImixVidSrcType src_type() const;
  inline void set_src_type(::nv::EmNvImixVidSrcType value);

  // optional bool is_hassrc = 2;
  inline bool has_is_hassrc() const;
  inline void clear_is_hassrc();
  static const int kIsHassrcFieldNumber = 2;
  inline bool is_hassrc() const;
  inline void set_is_hassrc(bool value);

  // optional string vid_name = 3;
  inline bool has_vid_name() const;
  inline void clear_vid_name();
  static const int kVidNameFieldNumber = 3;
  inline const ::std::string& vid_name() const;
  inline void set_vid_name(const ::std::string& value);
  inline void set_vid_name(const char* value);
  inline void set_vid_name(const char* value, size_t size);
  inline ::std::string* mutable_vid_name();
  inline ::std::string* release_vid_name();
  inline void set_allocated_vid_name(::std::string* vid_name);

  // @@protoc_insertion_point(class_scope:nv.TNVImixVidSrcSignal)
 private:
  inline void set_has_src_type();
  inline void clear_has_src_type();
  inline void set_has_is_hassrc();
  inline void clear_has_is_hassrc();
  inline void set_has_vid_name();
  inline void clear_has_vid_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int src_type_;
  bool is_hassrc_;
  ::std::string* vid_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVImixVidSrcSignal* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVImixVidSrcSignalList : public ::google::protobuf::Message {
 public:
  TNVImixVidSrcSignalList();
  virtual ~TNVImixVidSrcSignalList();

  TNVImixVidSrcSignalList(const TNVImixVidSrcSignalList& from);

  inline TNVImixVidSrcSignalList& operator=(const TNVImixVidSrcSignalList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVImixVidSrcSignalList& default_instance();

  void Swap(TNVImixVidSrcSignalList* other);

  // implements Message ----------------------------------------------

  TNVImixVidSrcSignalList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVImixVidSrcSignalList& from);
  void MergeFrom(const TNVImixVidSrcSignalList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVImixVidSrcSignal vid_list = 1;
  inline int vid_list_size() const;
  inline void clear_vid_list();
  static const int kVidListFieldNumber = 1;
  inline const ::nv::TNVImixVidSrcSignal& vid_list(int index) const;
  inline ::nv::TNVImixVidSrcSignal* mutable_vid_list(int index);
  inline ::nv::TNVImixVidSrcSignal* add_vid_list();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVImixVidSrcSignal >&
      vid_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVImixVidSrcSignal >*
      mutable_vid_list();

  // @@protoc_insertion_point(class_scope:nv.TNVImixVidSrcSignalList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVImixVidSrcSignal > vid_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVImixVidSrcSignalList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVidInPortMode : public ::google::protobuf::Message {
 public:
  TNVVidInPortMode();
  virtual ~TNVVidInPortMode();

  TNVVidInPortMode(const TNVVidInPortMode& from);

  inline TNVVidInPortMode& operator=(const TNVVidInPortMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVidInPortMode& default_instance();

  void Swap(TNVVidInPortMode* other);

  // implements Message ----------------------------------------------

  TNVVidInPortMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVidInPortMode& from);
  void MergeFrom(const TNVVidInPortMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvVideoInPort video_inport = 1;
  inline bool has_video_inport() const;
  inline void clear_video_inport();
  static const int kVideoInportFieldNumber = 1;
  inline ::nv::EmNvVideoInPort video_inport() const;
  inline void set_video_inport(::nv::EmNvVideoInPort value);

  // optional .nv.EmNvVideoOutPutMode inport_mode = 2;
  inline bool has_inport_mode() const;
  inline void clear_inport_mode();
  static const int kInportModeFieldNumber = 2;
  inline ::nv::EmNvVideoOutPutMode inport_mode() const;
  inline void set_inport_mode(::nv::EmNvVideoOutPutMode value);

  // optional bool is_change = 3;
  inline bool has_is_change() const;
  inline void clear_is_change();
  static const int kIsChangeFieldNumber = 3;
  inline bool is_change() const;
  inline void set_is_change(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVVidInPortMode)
 private:
  inline void set_has_video_inport();
  inline void clear_has_video_inport();
  inline void set_has_inport_mode();
  inline void clear_has_inport_mode();
  inline void set_has_is_change();
  inline void clear_has_is_change();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_inport_;
  int inport_mode_;
  bool is_change_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVVidInPortMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVidOutPortMode : public ::google::protobuf::Message {
 public:
  TNVVidOutPortMode();
  virtual ~TNVVidOutPortMode();

  TNVVidOutPortMode(const TNVVidOutPortMode& from);

  inline TNVVidOutPortMode& operator=(const TNVVidOutPortMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVidOutPortMode& default_instance();

  void Swap(TNVVidOutPortMode* other);

  // implements Message ----------------------------------------------

  TNVVidOutPortMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVidOutPortMode& from);
  void MergeFrom(const TNVVidOutPortMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvVideoOutPort video_outport = 1;
  inline bool has_video_outport() const;
  inline void clear_video_outport();
  static const int kVideoOutportFieldNumber = 1;
  inline ::nv::EmNvVideoOutPort video_outport() const;
  inline void set_video_outport(::nv::EmNvVideoOutPort value);

  // optional .nv.EmNvVideoOutPutMode outport_mode = 2;
  inline bool has_outport_mode() const;
  inline void clear_outport_mode();
  static const int kOutportModeFieldNumber = 2;
  inline ::nv::EmNvVideoOutPutMode outport_mode() const;
  inline void set_outport_mode(::nv::EmNvVideoOutPutMode value);

  // optional bool is_change = 3;
  inline bool has_is_change() const;
  inline void clear_is_change();
  static const int kIsChangeFieldNumber = 3;
  inline bool is_change() const;
  inline void set_is_change(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVVidOutPortMode)
 private:
  inline void set_has_video_outport();
  inline void clear_has_video_outport();
  inline void set_has_outport_mode();
  inline void clear_has_outport_mode();
  inline void set_has_is_change();
  inline void clear_has_is_change();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_outport_;
  int outport_mode_;
  bool is_change_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVVidOutPortMode* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVideoOutPort2InPort : public ::google::protobuf::Message {
 public:
  TNVVideoOutPort2InPort();
  virtual ~TNVVideoOutPort2InPort();

  TNVVideoOutPort2InPort(const TNVVideoOutPort2InPort& from);

  inline TNVVideoOutPort2InPort& operator=(const TNVVideoOutPort2InPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVideoOutPort2InPort& default_instance();

  void Swap(TNVVideoOutPort2InPort* other);

  // implements Message ----------------------------------------------

  TNVVideoOutPort2InPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVideoOutPort2InPort& from);
  void MergeFrom(const TNVVideoOutPort2InPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvVideoOutPort video_outport = 1;
  inline bool has_video_outport() const;
  inline void clear_video_outport();
  static const int kVideoOutportFieldNumber = 1;
  inline ::nv::EmNvVideoOutPort video_outport() const;
  inline void set_video_outport(::nv::EmNvVideoOutPort value);

  // optional .nv.EmNvVideoInPort video_inport = 2;
  inline bool has_video_inport() const;
  inline void clear_video_inport();
  static const int kVideoInportFieldNumber = 2;
  inline ::nv::EmNvVideoInPort video_inport() const;
  inline void set_video_inport(::nv::EmNvVideoInPort value);

  // optional bool is_change = 3;
  inline bool has_is_change() const;
  inline void clear_is_change();
  static const int kIsChangeFieldNumber = 3;
  inline bool is_change() const;
  inline void set_is_change(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVVideoOutPort2InPort)
 private:
  inline void set_has_video_outport();
  inline void clear_has_video_outport();
  inline void set_has_video_inport();
  inline void clear_has_video_inport();
  inline void set_has_is_change();
  inline void clear_has_is_change();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int video_outport_;
  int video_inport_;
  bool is_change_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVVideoOutPort2InPort* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVVideoMatrixScheme : public ::google::protobuf::Message {
 public:
  TNVVideoMatrixScheme();
  virtual ~TNVVideoMatrixScheme();

  TNVVideoMatrixScheme(const TNVVideoMatrixScheme& from);

  inline TNVVideoMatrixScheme& operator=(const TNVVideoMatrixScheme& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVVideoMatrixScheme& default_instance();

  void Swap(TNVVideoMatrixScheme* other);

  // implements Message ----------------------------------------------

  TNVVideoMatrixScheme* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVVideoMatrixScheme& from);
  void MergeFrom(const TNVVideoMatrixScheme& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVVidInPortMode inport_mode = 1;
  inline int inport_mode_size() const;
  inline void clear_inport_mode();
  static const int kInportModeFieldNumber = 1;
  inline const ::nv::TNVVidInPortMode& inport_mode(int index) const;
  inline ::nv::TNVVidInPortMode* mutable_inport_mode(int index);
  inline ::nv::TNVVidInPortMode* add_inport_mode();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidInPortMode >&
      inport_mode() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidInPortMode >*
      mutable_inport_mode();

  // repeated .nv.TNVVidOutPortMode outport_mode = 2;
  inline int outport_mode_size() const;
  inline void clear_outport_mode();
  static const int kOutportModeFieldNumber = 2;
  inline const ::nv::TNVVidOutPortMode& outport_mode(int index) const;
  inline ::nv::TNVVidOutPortMode* mutable_outport_mode(int index);
  inline ::nv::TNVVidOutPortMode* add_outport_mode();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidOutPortMode >&
      outport_mode() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidOutPortMode >*
      mutable_outport_mode();

  // repeated .nv.TNVVideoOutPort2InPort outport_inport = 3;
  inline int outport_inport_size() const;
  inline void clear_outport_inport();
  static const int kOutportInportFieldNumber = 3;
  inline const ::nv::TNVVideoOutPort2InPort& outport_inport(int index) const;
  inline ::nv::TNVVideoOutPort2InPort* mutable_outport_inport(int index);
  inline ::nv::TNVVideoOutPort2InPort* add_outport_inport();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVideoOutPort2InPort >&
      outport_inport() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVideoOutPort2InPort >*
      mutable_outport_inport();

  // @@protoc_insertion_point(class_scope:nv.TNVVideoMatrixScheme)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVVidInPortMode > inport_mode_;
  ::google::protobuf::RepeatedPtrField< ::nv::TNVVidOutPortMode > outport_mode_;
  ::google::protobuf::RepeatedPtrField< ::nv::TNVVideoOutPort2InPort > outport_inport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVVideoMatrixScheme* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TE1Unit : public ::google::protobuf::Message {
 public:
  TE1Unit();
  virtual ~TE1Unit();

  TE1Unit(const TE1Unit& from);

  inline TE1Unit& operator=(const TE1Unit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TE1Unit& default_instance();

  void Swap(TE1Unit* other);

  // implements Message ----------------------------------------------

  TE1Unit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TE1Unit& from);
  void MergeFrom(const TE1Unit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 e1_id = 1;
  inline bool has_e1_id() const;
  inline void clear_e1_id();
  static const int kE1IdFieldNumber = 1;
  inline ::google::protobuf::uint32 e1_id() const;
  inline void set_e1_id(::google::protobuf::uint32 value);

  // optional uint32 used_flag = 2;
  inline bool has_used_flag() const;
  inline void clear_used_flag();
  static const int kUsedFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 used_flag() const;
  inline void set_used_flag(::google::protobuf::uint32 value);

  // optional uint32 e1_ts_mask = 3;
  inline bool has_e1_ts_mask() const;
  inline void clear_e1_ts_mask();
  static const int kE1TsMaskFieldNumber = 3;
  inline ::google::protobuf::uint32 e1_ts_mask() const;
  inline void set_e1_ts_mask(::google::protobuf::uint32 value);

  // optional uint32 protocol_type = 4;
  inline bool has_protocol_type() const;
  inline void clear_protocol_type();
  static const int kProtocolTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 protocol_type() const;
  inline void set_protocol_type(::google::protobuf::uint32 value);

  // optional uint32 echo_interval = 5;
  inline bool has_echo_interval() const;
  inline void clear_echo_interval();
  static const int kEchoIntervalFieldNumber = 5;
  inline ::google::protobuf::uint32 echo_interval() const;
  inline void set_echo_interval(::google::protobuf::uint32 value);

  // optional uint32 echo_maxretry = 6;
  inline bool has_echo_maxretry() const;
  inline void clear_echo_maxretry();
  static const int kEchoMaxretryFieldNumber = 6;
  inline ::google::protobuf::uint32 echo_maxretry() const;
  inline void set_echo_maxretry(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TE1Unit)
 private:
  inline void set_has_e1_id();
  inline void clear_has_e1_id();
  inline void set_has_used_flag();
  inline void clear_has_used_flag();
  inline void set_has_e1_ts_mask();
  inline void clear_has_e1_ts_mask();
  inline void set_has_protocol_type();
  inline void clear_has_protocol_type();
  inline void set_has_echo_interval();
  inline void clear_has_echo_interval();
  inline void set_has_echo_maxretry();
  inline void clear_has_echo_maxretry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 e1_id_;
  ::google::protobuf::uint32 used_flag_;
  ::google::protobuf::uint32 e1_ts_mask_;
  ::google::protobuf::uint32 protocol_type_;
  ::google::protobuf::uint32 echo_interval_;
  ::google::protobuf::uint32 echo_maxretry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TE1Unit* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TE1Group : public ::google::protobuf::Message {
 public:
  TE1Group();
  virtual ~TE1Group();

  TE1Group(const TE1Group& from);

  inline TE1Group& operator=(const TE1Group& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TE1Group& default_instance();

  void Swap(TE1Group* other);

  // implements Message ----------------------------------------------

  TE1Group* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TE1Group& from);
  void MergeFrom(const TE1Group& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional uint32 unit_num = 2;
  inline bool has_unit_num() const;
  inline void clear_unit_num();
  static const int kUnitNumFieldNumber = 2;
  inline ::google::protobuf::uint32 unit_num() const;
  inline void set_unit_num(::google::protobuf::uint32 value);

  // optional uint32 is_bind = 3;
  inline bool has_is_bind() const;
  inline void clear_is_bind();
  static const int kIsBindFieldNumber = 3;
  inline ::google::protobuf::uint32 is_bind() const;
  inline void set_is_bind(::google::protobuf::uint32 value);

  // optional uint32 group_id = 4;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 4;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // optional uint32 ip = 5;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 5;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 mask = 6;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 6;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);

  // optional uint32 auth_type = 7;
  inline bool has_auth_type() const;
  inline void clear_auth_type();
  static const int kAuthTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 auth_type() const;
  inline void set_auth_type(::google::protobuf::uint32 value);

  // optional uint32 frag_minpackage_len = 8;
  inline bool has_frag_minpackage_len() const;
  inline void clear_frag_minpackage_len();
  static const int kFragMinpackageLenFieldNumber = 8;
  inline ::google::protobuf::uint32 frag_minpackage_len() const;
  inline void set_frag_minpackage_len(::google::protobuf::uint32 value);

  // optional string svr_usrname = 9;
  inline bool has_svr_usrname() const;
  inline void clear_svr_usrname();
  static const int kSvrUsrnameFieldNumber = 9;
  inline const ::std::string& svr_usrname() const;
  inline void set_svr_usrname(const ::std::string& value);
  inline void set_svr_usrname(const char* value);
  inline void set_svr_usrname(const char* value, size_t size);
  inline ::std::string* mutable_svr_usrname();
  inline ::std::string* release_svr_usrname();
  inline void set_allocated_svr_usrname(::std::string* svr_usrname);

  // optional string svr_usrpwd = 10;
  inline bool has_svr_usrpwd() const;
  inline void clear_svr_usrpwd();
  static const int kSvrUsrpwdFieldNumber = 10;
  inline const ::std::string& svr_usrpwd() const;
  inline void set_svr_usrpwd(const ::std::string& value);
  inline void set_svr_usrpwd(const char* value);
  inline void set_svr_usrpwd(const char* value, size_t size);
  inline ::std::string* mutable_svr_usrpwd();
  inline ::std::string* release_svr_usrpwd();
  inline void set_allocated_svr_usrpwd(::std::string* svr_usrpwd);

  // optional string sent_usrname = 11;
  inline bool has_sent_usrname() const;
  inline void clear_sent_usrname();
  static const int kSentUsrnameFieldNumber = 11;
  inline const ::std::string& sent_usrname() const;
  inline void set_sent_usrname(const ::std::string& value);
  inline void set_sent_usrname(const char* value);
  inline void set_sent_usrname(const char* value, size_t size);
  inline ::std::string* mutable_sent_usrname();
  inline ::std::string* release_sent_usrname();
  inline void set_allocated_sent_usrname(::std::string* sent_usrname);

  // optional string sent_usrpwd = 12;
  inline bool has_sent_usrpwd() const;
  inline void clear_sent_usrpwd();
  static const int kSentUsrpwdFieldNumber = 12;
  inline const ::std::string& sent_usrpwd() const;
  inline void set_sent_usrpwd(const ::std::string& value);
  inline void set_sent_usrpwd(const char* value);
  inline void set_sent_usrpwd(const char* value, size_t size);
  inline ::std::string* mutable_sent_usrpwd();
  inline ::std::string* release_sent_usrpwd();
  inline void set_allocated_sent_usrpwd(::std::string* sent_usrpwd);

  // repeated .nv.TE1Unit unit_list = 13;
  inline int unit_list_size() const;
  inline void clear_unit_list();
  static const int kUnitListFieldNumber = 13;
  inline const ::nv::TE1Unit& unit_list(int index) const;
  inline ::nv::TE1Unit* mutable_unit_list(int index);
  inline ::nv::TE1Unit* add_unit_list();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TE1Unit >&
      unit_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TE1Unit >*
      mutable_unit_list();

  // @@protoc_insertion_point(class_scope:nv.TE1Group)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_unit_num();
  inline void clear_has_unit_num();
  inline void set_has_is_bind();
  inline void clear_has_is_bind();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_auth_type();
  inline void clear_has_auth_type();
  inline void set_has_frag_minpackage_len();
  inline void clear_has_frag_minpackage_len();
  inline void set_has_svr_usrname();
  inline void clear_has_svr_usrname();
  inline void set_has_svr_usrpwd();
  inline void clear_has_svr_usrpwd();
  inline void set_has_sent_usrname();
  inline void clear_has_sent_usrname();
  inline void set_has_sent_usrpwd();
  inline void clear_has_sent_usrpwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  ::google::protobuf::uint32 unit_num_;
  ::google::protobuf::uint32 is_bind_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 mask_;
  ::google::protobuf::uint32 auth_type_;
  ::google::protobuf::uint32 frag_minpackage_len_;
  ::std::string* svr_usrname_;
  ::std::string* svr_usrpwd_;
  ::std::string* sent_usrname_;
  ::std::string* sent_usrpwd_;
  ::google::protobuf::RepeatedPtrField< ::nv::TE1Unit > unit_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TE1Group* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TE1Cfg : public ::google::protobuf::Message {
 public:
  TE1Cfg();
  virtual ~TE1Cfg();

  TE1Cfg(const TE1Cfg& from);

  inline TE1Cfg& operator=(const TE1Cfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TE1Cfg& default_instance();

  void Swap(TE1Cfg* other);

  // implements Message ----------------------------------------------

  TE1Cfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TE1Cfg& from);
  void MergeFrom(const TE1Cfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool encrypt = 1;
  inline bool has_encrypt() const;
  inline void clear_encrypt();
  static const int kEncryptFieldNumber = 1;
  inline bool encrypt() const;
  inline void set_encrypt(bool value);

  // optional uint32 clock_type = 2;
  inline bool has_clock_type() const;
  inline void clear_clock_type();
  static const int kClockTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 clock_type() const;
  inline void set_clock_type(::google::protobuf::uint32 value);

  // repeated .nv.TE1Group group_detail = 3;
  inline int group_detail_size() const;
  inline void clear_group_detail();
  static const int kGroupDetailFieldNumber = 3;
  inline const ::nv::TE1Group& group_detail(int index) const;
  inline ::nv::TE1Group* mutable_group_detail(int index);
  inline ::nv::TE1Group* add_group_detail();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TE1Group >&
      group_detail() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TE1Group >*
      mutable_group_detail();

  // @@protoc_insertion_point(class_scope:nv.TE1Cfg)
 private:
  inline void set_has_encrypt();
  inline void clear_has_encrypt();
  inline void set_has_clock_type();
  inline void clear_has_clock_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool encrypt_;
  ::google::protobuf::uint32 clock_type_;
  ::google::protobuf::RepeatedPtrField< ::nv::TE1Group > group_detail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TE1Cfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVLocalDevInfo : public ::google::protobuf::Message {
 public:
  TNVLocalDevInfo();
  virtual ~TNVLocalDevInfo();

  TNVLocalDevInfo(const TNVLocalDevInfo& from);

  inline TNVLocalDevInfo& operator=(const TNVLocalDevInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVLocalDevInfo& default_instance();

  void Swap(TNVLocalDevInfo* other);

  // implements Message ----------------------------------------------

  TNVLocalDevInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVLocalDevInfo& from);
  void MergeFrom(const TNVLocalDevInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvDevRegUpdateSer dev_type = 1;
  inline bool has_dev_type() const;
  inline void clear_dev_type();
  static const int kDevTypeFieldNumber = 1;
  inline ::nv::EmNvDevRegUpdateSer dev_type() const;
  inline void set_dev_type(::nv::EmNvDevRegUpdateSer value);

  // optional string dev_version = 2;
  inline bool has_dev_version() const;
  inline void clear_dev_version();
  static const int kDevVersionFieldNumber = 2;
  inline const ::std::string& dev_version() const;
  inline void set_dev_version(const ::std::string& value);
  inline void set_dev_version(const char* value);
  inline void set_dev_version(const char* value, size_t size);
  inline ::std::string* mutable_dev_version();
  inline ::std::string* release_dev_version();
  inline void set_allocated_dev_version(::std::string* dev_version);

  // optional uint32 instid = 3;
  inline bool has_instid() const;
  inline void clear_instid();
  static const int kInstidFieldNumber = 3;
  inline ::google::protobuf::uint32 instid() const;
  inline void set_instid(::google::protobuf::uint32 value);

  // optional uint32 node = 4;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 4;
  inline ::google::protobuf::uint32 node() const;
  inline void set_node(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVLocalDevInfo)
 private:
  inline void set_has_dev_type();
  inline void clear_has_dev_type();
  inline void set_has_dev_version();
  inline void clear_has_dev_version();
  inline void set_has_instid();
  inline void clear_has_instid();
  inline void set_has_node();
  inline void clear_has_node();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dev_version_;
  int dev_type_;
  ::google::protobuf::uint32 instid_;
  ::google::protobuf::uint32 node_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVLocalDevInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVDevUpdateCfg : public ::google::protobuf::Message {
 public:
  TNVDevUpdateCfg();
  virtual ~TNVDevUpdateCfg();

  TNVDevUpdateCfg(const TNVDevUpdateCfg& from);

  inline TNVDevUpdateCfg& operator=(const TNVDevUpdateCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVDevUpdateCfg& default_instance();

  void Swap(TNVDevUpdateCfg* other);

  // implements Message ----------------------------------------------

  TNVDevUpdateCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVDevUpdateCfg& from);
  void MergeFrom(const TNVDevUpdateCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_used = 1;
  inline bool has_is_used() const;
  inline void clear_is_used();
  static const int kIsUsedFieldNumber = 1;
  inline bool is_used() const;
  inline void set_is_used(bool value);

  // optional .nv.EmNvDevRegUpdateSer dev_type = 2;
  inline bool has_dev_type() const;
  inline void clear_dev_type();
  static const int kDevTypeFieldNumber = 2;
  inline ::nv::EmNvDevRegUpdateSer dev_type() const;
  inline void set_dev_type(::nv::EmNvDevRegUpdateSer value);

  // optional .nv.EmNvUpdateType update_type = 3;
  inline bool has_update_type() const;
  inline void clear_update_type();
  static const int kUpdateTypeFieldNumber = 3;
  inline ::nv::EmNvUpdateType update_type() const;
  inline void set_update_type(::nv::EmNvUpdateType value);

  // optional string dev_version = 4;
  inline bool has_dev_version() const;
  inline void clear_dev_version();
  static const int kDevVersionFieldNumber = 4;
  inline const ::std::string& dev_version() const;
  inline void set_dev_version(const ::std::string& value);
  inline void set_dev_version(const char* value);
  inline void set_dev_version(const char* value, size_t size);
  inline ::std::string* mutable_dev_version();
  inline ::std::string* release_dev_version();
  inline void set_allocated_dev_version(::std::string* dev_version);

  // optional string filename = 5;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 5;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:nv.TNVDevUpdateCfg)
 private:
  inline void set_has_is_used();
  inline void clear_has_is_used();
  inline void set_has_dev_type();
  inline void clear_has_dev_type();
  inline void set_has_update_type();
  inline void clear_has_update_type();
  inline void set_has_dev_version();
  inline void clear_has_dev_version();
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_used_;
  int dev_type_;
  ::std::string* dev_version_;
  ::std::string* filename_;
  int update_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVDevUpdateCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVDevCfgInfoList : public ::google::protobuf::Message {
 public:
  TNVDevCfgInfoList();
  virtual ~TNVDevCfgInfoList();

  TNVDevCfgInfoList(const TNVDevCfgInfoList& from);

  inline TNVDevCfgInfoList& operator=(const TNVDevCfgInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVDevCfgInfoList& default_instance();

  void Swap(TNVDevCfgInfoList* other);

  // implements Message ----------------------------------------------

  TNVDevCfgInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVDevCfgInfoList& from);
  void MergeFrom(const TNVDevCfgInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVDevUpdateCfg tupdatecfg = 1;
  inline int tupdatecfg_size() const;
  inline void clear_tupdatecfg();
  static const int kTupdatecfgFieldNumber = 1;
  inline const ::nv::TNVDevUpdateCfg& tupdatecfg(int index) const;
  inline ::nv::TNVDevUpdateCfg* mutable_tupdatecfg(int index);
  inline ::nv::TNVDevUpdateCfg* add_tupdatecfg();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVDevUpdateCfg >&
      tupdatecfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVDevUpdateCfg >*
      mutable_tupdatecfg();

  // optional uint32 local_ip = 2;
  inline bool has_local_ip() const;
  inline void clear_local_ip();
  static const int kLocalIpFieldNumber = 2;
  inline ::google::protobuf::uint32 local_ip() const;
  inline void set_local_ip(::google::protobuf::uint32 value);

  // repeated .nv.TString imix_version = 3;
  inline int imix_version_size() const;
  inline void clear_imix_version();
  static const int kImixVersionFieldNumber = 3;
  inline const ::nv::TString& imix_version(int index) const;
  inline ::nv::TString* mutable_imix_version(int index);
  inline ::nv::TString* add_imix_version();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TString >&
      imix_version() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TString >*
      mutable_imix_version();

  // repeated .nv.TString tpad_version = 4;
  inline int tpad_version_size() const;
  inline void clear_tpad_version();
  static const int kTpadVersionFieldNumber = 4;
  inline const ::nv::TString& tpad_version(int index) const;
  inline ::nv::TString* mutable_tpad_version(int index);
  inline ::nv::TString* add_tpad_version();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TString >&
      tpad_version() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TString >*
      mutable_tpad_version();

  // @@protoc_insertion_point(class_scope:nv.TNVDevCfgInfoList)
 private:
  inline void set_has_local_ip();
  inline void clear_has_local_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVDevUpdateCfg > tupdatecfg_;
  ::google::protobuf::RepeatedPtrField< ::nv::TString > imix_version_;
  ::google::protobuf::RepeatedPtrField< ::nv::TString > tpad_version_;
  ::google::protobuf::uint32 local_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVDevCfgInfoList* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVFTPFileInfo : public ::google::protobuf::Message {
 public:
  TNVFTPFileInfo();
  virtual ~TNVFTPFileInfo();

  TNVFTPFileInfo(const TNVFTPFileInfo& from);

  inline TNVFTPFileInfo& operator=(const TNVFTPFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVFTPFileInfo& default_instance();

  void Swap(TNVFTPFileInfo* other);

  // implements Message ----------------------------------------------

  TNVFTPFileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVFTPFileInfo& from);
  void MergeFrom(const TNVFTPFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ser_ip = 1;
  inline bool has_ser_ip() const;
  inline void clear_ser_ip();
  static const int kSerIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ser_ip() const;
  inline void set_ser_ip(::google::protobuf::uint32 value);

  // optional uint32 ser_port = 2;
  inline bool has_ser_port() const;
  inline void clear_ser_port();
  static const int kSerPortFieldNumber = 2;
  inline ::google::protobuf::uint32 ser_port() const;
  inline void set_ser_port(::google::protobuf::uint32 value);

  // optional string username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string filepath = 5;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 5;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // optional uint32 filesize = 6;
  inline bool has_filesize() const;
  inline void clear_filesize();
  static const int kFilesizeFieldNumber = 6;
  inline ::google::protobuf::uint32 filesize() const;
  inline void set_filesize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVFTPFileInfo)
 private:
  inline void set_has_ser_ip();
  inline void clear_has_ser_ip();
  inline void set_has_ser_port();
  inline void clear_has_ser_port();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_filesize();
  inline void clear_has_filesize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ser_ip_;
  ::google::protobuf::uint32 ser_port_;
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* filepath_;
  ::google::protobuf::uint32 filesize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVFTPFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVDevUpgrade : public ::google::protobuf::Message {
 public:
  TNVDevUpgrade();
  virtual ~TNVDevUpgrade();

  TNVDevUpgrade(const TNVDevUpgrade& from);

  inline TNVDevUpgrade& operator=(const TNVDevUpgrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVDevUpgrade& default_instance();

  void Swap(TNVDevUpgrade* other);

  // implements Message ----------------------------------------------

  TNVDevUpgrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVDevUpgrade& from);
  void MergeFrom(const TNVDevUpgrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvDevRegUpdateSer dev_type = 1;
  inline bool has_dev_type() const;
  inline void clear_dev_type();
  static const int kDevTypeFieldNumber = 1;
  inline ::nv::EmNvDevRegUpdateSer dev_type() const;
  inline void set_dev_type(::nv::EmNvDevRegUpdateSer value);

  // optional string dev_version = 2;
  inline bool has_dev_version() const;
  inline void clear_dev_version();
  static const int kDevVersionFieldNumber = 2;
  inline const ::std::string& dev_version() const;
  inline void set_dev_version(const ::std::string& value);
  inline void set_dev_version(const char* value);
  inline void set_dev_version(const char* value, size_t size);
  inline ::std::string* mutable_dev_version();
  inline ::std::string* release_dev_version();
  inline void set_allocated_dev_version(::std::string* dev_version);

  // optional .nv.TNVFTPFileInfo tftpinfo = 3;
  inline bool has_tftpinfo() const;
  inline void clear_tftpinfo();
  static const int kTftpinfoFieldNumber = 3;
  inline const ::nv::TNVFTPFileInfo& tftpinfo() const;
  inline ::nv::TNVFTPFileInfo* mutable_tftpinfo();
  inline ::nv::TNVFTPFileInfo* release_tftpinfo();
  inline void set_allocated_tftpinfo(::nv::TNVFTPFileInfo* tftpinfo);

  // optional .nv.EmNvUpdateType update_type = 4;
  inline bool has_update_type() const;
  inline void clear_update_type();
  static const int kUpdateTypeFieldNumber = 4;
  inline ::nv::EmNvUpdateType update_type() const;
  inline void set_update_type(::nv::EmNvUpdateType value);

  // repeated .nv.TString version_info = 5;
  inline int version_info_size() const;
  inline void clear_version_info();
  static const int kVersionInfoFieldNumber = 5;
  inline const ::nv::TString& version_info(int index) const;
  inline ::nv::TString* mutable_version_info(int index);
  inline ::nv::TString* add_version_info();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TString >&
      version_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TString >*
      mutable_version_info();

  // @@protoc_insertion_point(class_scope:nv.TNVDevUpgrade)
 private:
  inline void set_has_dev_type();
  inline void clear_has_dev_type();
  inline void set_has_dev_version();
  inline void clear_has_dev_version();
  inline void set_has_tftpinfo();
  inline void clear_has_tftpinfo();
  inline void set_has_update_type();
  inline void clear_has_update_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dev_version_;
  int dev_type_;
  int update_type_;
  ::nv::TNVFTPFileInfo* tftpinfo_;
  ::google::protobuf::RepeatedPtrField< ::nv::TString > version_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVDevUpgrade* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUpGradeConnectInfo : public ::google::protobuf::Message {
 public:
  TNVUpGradeConnectInfo();
  virtual ~TNVUpGradeConnectInfo();

  TNVUpGradeConnectInfo(const TNVUpGradeConnectInfo& from);

  inline TNVUpGradeConnectInfo& operator=(const TNVUpGradeConnectInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUpGradeConnectInfo& default_instance();

  void Swap(TNVUpGradeConnectInfo* other);

  // implements Message ----------------------------------------------

  TNVUpGradeConnectInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUpGradeConnectInfo& from);
  void MergeFrom(const TNVUpGradeConnectInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mt_ip = 1;
  inline bool has_mt_ip() const;
  inline void clear_mt_ip();
  static const int kMtIpFieldNumber = 1;
  inline const ::std::string& mt_ip() const;
  inline void set_mt_ip(const ::std::string& value);
  inline void set_mt_ip(const char* value);
  inline void set_mt_ip(const char* value, size_t size);
  inline ::std::string* mutable_mt_ip();
  inline ::std::string* release_mt_ip();
  inline void set_allocated_mt_ip(::std::string* mt_ip);

  // optional uint32 listen_port = 2;
  inline bool has_listen_port() const;
  inline void clear_listen_port();
  static const int kListenPortFieldNumber = 2;
  inline ::google::protobuf::uint32 listen_port() const;
  inline void set_listen_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVUpGradeConnectInfo)
 private:
  inline void set_has_mt_ip();
  inline void clear_has_mt_ip();
  inline void set_has_listen_port();
  inline void clear_has_listen_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mt_ip_;
  ::google::protobuf::uint32 listen_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUpGradeConnectInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVUpgradePackageContent : public ::google::protobuf::Message {
 public:
  TNVUpgradePackageContent();
  virtual ~TNVUpgradePackageContent();

  TNVUpgradePackageContent(const TNVUpgradePackageContent& from);

  inline TNVUpgradePackageContent& operator=(const TNVUpgradePackageContent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVUpgradePackageContent& default_instance();

  void Swap(TNVUpgradePackageContent* other);

  // implements Message ----------------------------------------------

  TNVUpgradePackageContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVUpgradePackageContent& from);
  void MergeFrom(const TNVUpgradePackageContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_has_app_package = 1;
  inline bool has_is_has_app_package() const;
  inline void clear_is_has_app_package();
  static const int kIsHasAppPackageFieldNumber = 1;
  inline bool is_has_app_package() const;
  inline void set_is_has_app_package(bool value);

  // optional bool is_has_imix_package = 2;
  inline bool has_is_has_imix_package() const;
  inline void clear_is_has_imix_package();
  static const int kIsHasImixPackageFieldNumber = 2;
  inline bool is_has_imix_package() const;
  inline void set_is_has_imix_package(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVUpgradePackageContent)
 private:
  inline void set_has_is_has_app_package();
  inline void clear_has_is_has_app_package();
  inline void set_has_is_has_imix_package();
  inline void clear_has_is_has_imix_package();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_has_app_package_;
  bool is_has_imix_package_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVUpgradePackageContent* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVCfgMtSystemTime : public ::google::protobuf::Message {
 public:
  TNVCfgMtSystemTime();
  virtual ~TNVCfgMtSystemTime();

  TNVCfgMtSystemTime(const TNVCfgMtSystemTime& from);

  inline TNVCfgMtSystemTime& operator=(const TNVCfgMtSystemTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVCfgMtSystemTime& default_instance();

  void Swap(TNVCfgMtSystemTime* other);

  // implements Message ----------------------------------------------

  TNVCfgMtSystemTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVCfgMtSystemTime& from);
  void MergeFrom(const TNVCfgMtSystemTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bSyncServer = 1;
  inline bool has_bsyncserver() const;
  inline void clear_bsyncserver();
  static const int kBSyncServerFieldNumber = 1;
  inline bool bsyncserver() const;
  inline void set_bsyncserver(bool value);

  // optional .nv.EmNvTimeZone emTimeZone = 2;
  inline bool has_emtimezone() const;
  inline void clear_emtimezone();
  static const int kEmTimeZoneFieldNumber = 2;
  inline ::nv::EmNvTimeZone emtimezone() const;
  inline void set_emtimezone(::nv::EmNvTimeZone value);

  // @@protoc_insertion_point(class_scope:nv.TNVCfgMtSystemTime)
 private:
  inline void set_has_bsyncserver();
  inline void clear_has_bsyncserver();
  inline void set_has_emtimezone();
  inline void clear_has_emtimezone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool bsyncserver_;
  int emtimezone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVCfgMtSystemTime* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVFtpLoginInfo : public ::google::protobuf::Message {
 public:
  TNVFtpLoginInfo();
  virtual ~TNVFtpLoginInfo();

  TNVFtpLoginInfo(const TNVFtpLoginInfo& from);

  inline TNVFtpLoginInfo& operator=(const TNVFtpLoginInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVFtpLoginInfo& default_instance();

  void Swap(TNVFtpLoginInfo* other);

  // implements Message ----------------------------------------------

  TNVFtpLoginInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVFtpLoginInfo& from);
  void MergeFrom(const TNVFtpLoginInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.TNVUserFullInfo login_info = 1;
  inline bool has_login_info() const;
  inline void clear_login_info();
  static const int kLoginInfoFieldNumber = 1;
  inline const ::nv::TNVUserFullInfo& login_info() const;
  inline ::nv::TNVUserFullInfo* mutable_login_info();
  inline ::nv::TNVUserFullInfo* release_login_info();
  inline void set_allocated_login_info(::nv::TNVUserFullInfo* login_info);

  // optional bool bopen_ftp = 2;
  inline bool has_bopen_ftp() const;
  inline void clear_bopen_ftp();
  static const int kBopenFtpFieldNumber = 2;
  inline bool bopen_ftp() const;
  inline void set_bopen_ftp(bool value);

  // optional uint32 node = 3;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 3;
  inline ::google::protobuf::uint32 node() const;
  inline void set_node(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVFtpLoginInfo)
 private:
  inline void set_has_login_info();
  inline void clear_has_login_info();
  inline void set_has_bopen_ftp();
  inline void clear_has_bopen_ftp();
  inline void set_has_node();
  inline void clear_has_node();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::nv::TNVUserFullInfo* login_info_;
  bool bopen_ftp_;
  ::google::protobuf::uint32 node_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVFtpLoginInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVFtpLoginInfos : public ::google::protobuf::Message {
 public:
  TNVFtpLoginInfos();
  virtual ~TNVFtpLoginInfos();

  TNVFtpLoginInfos(const TNVFtpLoginInfos& from);

  inline TNVFtpLoginInfos& operator=(const TNVFtpLoginInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVFtpLoginInfos& default_instance();

  void Swap(TNVFtpLoginInfos* other);

  // implements Message ----------------------------------------------

  TNVFtpLoginInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVFtpLoginInfos& from);
  void MergeFrom(const TNVFtpLoginInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVFtpLoginInfo login_info_list = 1;
  inline int login_info_list_size() const;
  inline void clear_login_info_list();
  static const int kLoginInfoListFieldNumber = 1;
  inline const ::nv::TNVFtpLoginInfo& login_info_list(int index) const;
  inline ::nv::TNVFtpLoginInfo* mutable_login_info_list(int index);
  inline ::nv::TNVFtpLoginInfo* add_login_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVFtpLoginInfo >&
      login_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVFtpLoginInfo >*
      mutable_login_info_list();

  // optional uint32 open_count = 2;
  inline bool has_open_count() const;
  inline void clear_open_count();
  static const int kOpenCountFieldNumber = 2;
  inline ::google::protobuf::uint32 open_count() const;
  inline void set_open_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVFtpLoginInfos)
 private:
  inline void set_has_open_count();
  inline void clear_has_open_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVFtpLoginInfo > login_info_list_;
  ::google::protobuf::uint32 open_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVFtpLoginInfos* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVTerminalName : public ::google::protobuf::Message {
 public:
  TNVTerminalName();
  virtual ~TNVTerminalName();

  TNVTerminalName(const TNVTerminalName& from);

  inline TNVTerminalName& operator=(const TNVTerminalName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVTerminalName& default_instance();

  void Swap(TNVTerminalName* other);

  // implements Message ----------------------------------------------

  TNVTerminalName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVTerminalName& from);
  void MergeFrom(const TNVTerminalName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ter_e164 = 1;
  inline bool has_ter_e164() const;
  inline void clear_ter_e164();
  static const int kTerE164FieldNumber = 1;
  inline const ::std::string& ter_e164() const;
  inline void set_ter_e164(const ::std::string& value);
  inline void set_ter_e164(const char* value);
  inline void set_ter_e164(const char* value, size_t size);
  inline ::std::string* mutable_ter_e164();
  inline ::std::string* release_ter_e164();
  inline void set_allocated_ter_e164(::std::string* ter_e164);

  // optional string ter_alias = 2;
  inline bool has_ter_alias() const;
  inline void clear_ter_alias();
  static const int kTerAliasFieldNumber = 2;
  inline const ::std::string& ter_alias() const;
  inline void set_ter_alias(const ::std::string& value);
  inline void set_ter_alias(const char* value);
  inline void set_ter_alias(const char* value, size_t size);
  inline ::std::string* mutable_ter_alias();
  inline ::std::string* release_ter_alias();
  inline void set_allocated_ter_alias(::std::string* ter_alias);

  // @@protoc_insertion_point(class_scope:nv.TNVTerminalName)
 private:
  inline void set_has_ter_e164();
  inline void clear_has_ter_e164();
  inline void set_has_ter_alias();
  inline void clear_has_ter_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ter_e164_;
  ::std::string* ter_alias_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVTerminalName* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMiniVidInfo : public ::google::protobuf::Message {
 public:
  TNVMiniVidInfo();
  virtual ~TNVMiniVidInfo();

  TNVMiniVidInfo(const TNVMiniVidInfo& from);

  inline TNVMiniVidInfo& operator=(const TNVMiniVidInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMiniVidInfo& default_instance();

  void Swap(TNVMiniVidInfo* other);

  // implements Message ----------------------------------------------

  TNVMiniVidInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMiniVidInfo& from);
  void MergeFrom(const TNVMiniVidInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool open = 1;
  inline bool has_open() const;
  inline void clear_open();
  static const int kOpenFieldNumber = 1;
  inline bool open() const;
  inline void set_open(bool value);

  // optional bool full = 2;
  inline bool has_full() const;
  inline void clear_full();
  static const int kFullFieldNumber = 2;
  inline bool full() const;
  inline void set_full(bool value);

  // optional .nv.EmNvMiniVidPos pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline ::nv::EmNvMiniVidPos pos() const;
  inline void set_pos(::nv::EmNvMiniVidPos value);

  // optional uint32 flag = 4;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 4;
  inline ::google::protobuf::uint32 flag() const;
  inline void set_flag(::google::protobuf::uint32 value);

  // optional uint32 start_x = 5;
  inline bool has_start_x() const;
  inline void clear_start_x();
  static const int kStartXFieldNumber = 5;
  inline ::google::protobuf::uint32 start_x() const;
  inline void set_start_x(::google::protobuf::uint32 value);

  // optional uint32 start_y = 6;
  inline bool has_start_y() const;
  inline void clear_start_y();
  static const int kStartYFieldNumber = 6;
  inline ::google::protobuf::uint32 start_y() const;
  inline void set_start_y(::google::protobuf::uint32 value);

  // optional uint32 height = 7;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 7;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // optional uint32 width = 8;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 8;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 prohibit_start_x = 9;
  inline bool has_prohibit_start_x() const;
  inline void clear_prohibit_start_x();
  static const int kProhibitStartXFieldNumber = 9;
  inline ::google::protobuf::uint32 prohibit_start_x() const;
  inline void set_prohibit_start_x(::google::protobuf::uint32 value);

  // optional uint32 prohibit_start_y = 10;
  inline bool has_prohibit_start_y() const;
  inline void clear_prohibit_start_y();
  static const int kProhibitStartYFieldNumber = 10;
  inline ::google::protobuf::uint32 prohibit_start_y() const;
  inline void set_prohibit_start_y(::google::protobuf::uint32 value);

  // optional uint32 prohibit_end_x = 11;
  inline bool has_prohibit_end_x() const;
  inline void clear_prohibit_end_x();
  static const int kProhibitEndXFieldNumber = 11;
  inline ::google::protobuf::uint32 prohibit_end_x() const;
  inline void set_prohibit_end_x(::google::protobuf::uint32 value);

  // optional uint32 prohibit_end_y = 12;
  inline bool has_prohibit_end_y() const;
  inline void clear_prohibit_end_y();
  static const int kProhibitEndYFieldNumber = 12;
  inline ::google::protobuf::uint32 prohibit_end_y() const;
  inline void set_prohibit_end_y(::google::protobuf::uint32 value);

  // optional uint32 prohibit_start_x_2 = 13;
  inline bool has_prohibit_start_x_2() const;
  inline void clear_prohibit_start_x_2();
  static const int kProhibitStartX2FieldNumber = 13;
  inline ::google::protobuf::uint32 prohibit_start_x_2() const;
  inline void set_prohibit_start_x_2(::google::protobuf::uint32 value);

  // optional uint32 prohibit_start_y_2 = 14;
  inline bool has_prohibit_start_y_2() const;
  inline void clear_prohibit_start_y_2();
  static const int kProhibitStartY2FieldNumber = 14;
  inline ::google::protobuf::uint32 prohibit_start_y_2() const;
  inline void set_prohibit_start_y_2(::google::protobuf::uint32 value);

  // optional uint32 prohibit_end_x_2 = 15;
  inline bool has_prohibit_end_x_2() const;
  inline void clear_prohibit_end_x_2();
  static const int kProhibitEndX2FieldNumber = 15;
  inline ::google::protobuf::uint32 prohibit_end_x_2() const;
  inline void set_prohibit_end_x_2(::google::protobuf::uint32 value);

  // optional uint32 prohibit_end_y_2 = 16;
  inline bool has_prohibit_end_y_2() const;
  inline void clear_prohibit_end_y_2();
  static const int kProhibitEndY2FieldNumber = 16;
  inline ::google::protobuf::uint32 prohibit_end_y_2() const;
  inline void set_prohibit_end_y_2(::google::protobuf::uint32 value);

  // optional uint32 prohibit_start_x_3 = 17;
  inline bool has_prohibit_start_x_3() const;
  inline void clear_prohibit_start_x_3();
  static const int kProhibitStartX3FieldNumber = 17;
  inline ::google::protobuf::uint32 prohibit_start_x_3() const;
  inline void set_prohibit_start_x_3(::google::protobuf::uint32 value);

  // optional uint32 prohibit_start_y_3 = 18;
  inline bool has_prohibit_start_y_3() const;
  inline void clear_prohibit_start_y_3();
  static const int kProhibitStartY3FieldNumber = 18;
  inline ::google::protobuf::uint32 prohibit_start_y_3() const;
  inline void set_prohibit_start_y_3(::google::protobuf::uint32 value);

  // optional uint32 prohibit_end_x_3 = 19;
  inline bool has_prohibit_end_x_3() const;
  inline void clear_prohibit_end_x_3();
  static const int kProhibitEndX3FieldNumber = 19;
  inline ::google::protobuf::uint32 prohibit_end_x_3() const;
  inline void set_prohibit_end_x_3(::google::protobuf::uint32 value);

  // optional uint32 prohibit_end_y_3 = 20;
  inline bool has_prohibit_end_y_3() const;
  inline void clear_prohibit_end_y_3();
  static const int kProhibitEndY3FieldNumber = 20;
  inline ::google::protobuf::uint32 prohibit_end_y_3() const;
  inline void set_prohibit_end_y_3(::google::protobuf::uint32 value);

  // optional uint32 prohibit_start_x_4 = 21;
  inline bool has_prohibit_start_x_4() const;
  inline void clear_prohibit_start_x_4();
  static const int kProhibitStartX4FieldNumber = 21;
  inline ::google::protobuf::uint32 prohibit_start_x_4() const;
  inline void set_prohibit_start_x_4(::google::protobuf::uint32 value);

  // optional uint32 prohibit_start_y_4 = 22;
  inline bool has_prohibit_start_y_4() const;
  inline void clear_prohibit_start_y_4();
  static const int kProhibitStartY4FieldNumber = 22;
  inline ::google::protobuf::uint32 prohibit_start_y_4() const;
  inline void set_prohibit_start_y_4(::google::protobuf::uint32 value);

  // optional uint32 prohibit_end_x_4 = 23;
  inline bool has_prohibit_end_x_4() const;
  inline void clear_prohibit_end_x_4();
  static const int kProhibitEndX4FieldNumber = 23;
  inline ::google::protobuf::uint32 prohibit_end_x_4() const;
  inline void set_prohibit_end_x_4(::google::protobuf::uint32 value);

  // optional uint32 prohibit_end_y_4 = 24;
  inline bool has_prohibit_end_y_4() const;
  inline void clear_prohibit_end_y_4();
  static const int kProhibitEndY4FieldNumber = 24;
  inline ::google::protobuf::uint32 prohibit_end_y_4() const;
  inline void set_prohibit_end_y_4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nv.TNVMiniVidInfo)
 private:
  inline void set_has_open();
  inline void clear_has_open();
  inline void set_has_full();
  inline void clear_has_full();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_start_x();
  inline void clear_has_start_x();
  inline void set_has_start_y();
  inline void clear_has_start_y();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_prohibit_start_x();
  inline void clear_has_prohibit_start_x();
  inline void set_has_prohibit_start_y();
  inline void clear_has_prohibit_start_y();
  inline void set_has_prohibit_end_x();
  inline void clear_has_prohibit_end_x();
  inline void set_has_prohibit_end_y();
  inline void clear_has_prohibit_end_y();
  inline void set_has_prohibit_start_x_2();
  inline void clear_has_prohibit_start_x_2();
  inline void set_has_prohibit_start_y_2();
  inline void clear_has_prohibit_start_y_2();
  inline void set_has_prohibit_end_x_2();
  inline void clear_has_prohibit_end_x_2();
  inline void set_has_prohibit_end_y_2();
  inline void clear_has_prohibit_end_y_2();
  inline void set_has_prohibit_start_x_3();
  inline void clear_has_prohibit_start_x_3();
  inline void set_has_prohibit_start_y_3();
  inline void clear_has_prohibit_start_y_3();
  inline void set_has_prohibit_end_x_3();
  inline void clear_has_prohibit_end_x_3();
  inline void set_has_prohibit_end_y_3();
  inline void clear_has_prohibit_end_y_3();
  inline void set_has_prohibit_start_x_4();
  inline void clear_has_prohibit_start_x_4();
  inline void set_has_prohibit_start_y_4();
  inline void clear_has_prohibit_start_y_4();
  inline void set_has_prohibit_end_x_4();
  inline void clear_has_prohibit_end_x_4();
  inline void set_has_prohibit_end_y_4();
  inline void clear_has_prohibit_end_y_4();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool open_;
  bool full_;
  int pos_;
  ::google::protobuf::uint32 flag_;
  ::google::protobuf::uint32 start_x_;
  ::google::protobuf::uint32 start_y_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 prohibit_start_x_;
  ::google::protobuf::uint32 prohibit_start_y_;
  ::google::protobuf::uint32 prohibit_end_x_;
  ::google::protobuf::uint32 prohibit_end_y_;
  ::google::protobuf::uint32 prohibit_start_x_2_;
  ::google::protobuf::uint32 prohibit_start_y_2_;
  ::google::protobuf::uint32 prohibit_end_x_2_;
  ::google::protobuf::uint32 prohibit_end_y_2_;
  ::google::protobuf::uint32 prohibit_start_x_3_;
  ::google::protobuf::uint32 prohibit_start_y_3_;
  ::google::protobuf::uint32 prohibit_end_x_3_;
  ::google::protobuf::uint32 prohibit_end_y_3_;
  ::google::protobuf::uint32 prohibit_start_x_4_;
  ::google::protobuf::uint32 prohibit_start_y_4_;
  ::google::protobuf::uint32 prohibit_end_x_4_;
  ::google::protobuf::uint32 prohibit_end_y_4_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVMiniVidInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVImixVerInfo : public ::google::protobuf::Message {
 public:
  TNVImixVerInfo();
  virtual ~TNVImixVerInfo();

  TNVImixVerInfo(const TNVImixVerInfo& from);

  inline TNVImixVerInfo& operator=(const TNVImixVerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVImixVerInfo& default_instance();

  void Swap(TNVImixVerInfo* other);

  // implements Message ----------------------------------------------

  TNVImixVerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVImixVerInfo& from);
  void MergeFrom(const TNVImixVerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mt_ver = 1;
  inline bool has_mt_ver() const;
  inline void clear_mt_ver();
  static const int kMtVerFieldNumber = 1;
  inline const ::std::string& mt_ver() const;
  inline void set_mt_ver(const ::std::string& value);
  inline void set_mt_ver(const char* value);
  inline void set_mt_ver(const char* value, size_t size);
  inline ::std::string* mutable_mt_ver();
  inline ::std::string* release_mt_ver();
  inline void set_allocated_mt_ver(::std::string* mt_ver);

  // optional string power_ver = 2;
  inline bool has_power_ver() const;
  inline void clear_power_ver();
  static const int kPowerVerFieldNumber = 2;
  inline const ::std::string& power_ver() const;
  inline void set_power_ver(const ::std::string& value);
  inline void set_power_ver(const char* value);
  inline void set_power_ver(const char* value, size_t size);
  inline ::std::string* mutable_power_ver();
  inline ::std::string* release_power_ver();
  inline void set_allocated_power_ver(::std::string* power_ver);

  // optional string imix_mode = 3;
  inline bool has_imix_mode() const;
  inline void clear_imix_mode();
  static const int kImixModeFieldNumber = 3;
  inline const ::std::string& imix_mode() const;
  inline void set_imix_mode(const ::std::string& value);
  inline void set_imix_mode(const char* value);
  inline void set_imix_mode(const char* value, size_t size);
  inline ::std::string* mutable_imix_mode();
  inline ::std::string* release_imix_mode();
  inline void set_allocated_imix_mode(::std::string* imix_mode);

  // repeated .nv.TNVQkVer qk_ver = 4;
  inline int qk_ver_size() const;
  inline void clear_qk_ver();
  static const int kQkVerFieldNumber = 4;
  inline const ::nv::TNVQkVer& qk_ver(int index) const;
  inline ::nv::TNVQkVer* mutable_qk_ver(int index);
  inline ::nv::TNVQkVer* add_qk_ver();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVQkVer >&
      qk_ver() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVQkVer >*
      mutable_qk_ver();

  // @@protoc_insertion_point(class_scope:nv.TNVImixVerInfo)
 private:
  inline void set_has_mt_ver();
  inline void clear_has_mt_ver();
  inline void set_has_power_ver();
  inline void clear_has_power_ver();
  inline void set_has_imix_mode();
  inline void clear_has_imix_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mt_ver_;
  ::std::string* power_ver_;
  ::std::string* imix_mode_;
  ::google::protobuf::RepeatedPtrField< ::nv::TNVQkVer > qk_ver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVImixVerInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVHWInfo : public ::google::protobuf::Message {
 public:
  TNVHWInfo();
  virtual ~TNVHWInfo();

  TNVHWInfo(const TNVHWInfo& from);

  inline TNVHWInfo& operator=(const TNVHWInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVHWInfo& default_instance();

  void Swap(TNVHWInfo* other);

  // implements Message ----------------------------------------------

  TNVHWInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVHWInfo& from);
  void MergeFrom(const TNVHWInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mode_name = 1;
  inline bool has_mode_name() const;
  inline void clear_mode_name();
  static const int kModeNameFieldNumber = 1;
  inline const ::std::string& mode_name() const;
  inline void set_mode_name(const ::std::string& value);
  inline void set_mode_name(const char* value);
  inline void set_mode_name(const char* value, size_t size);
  inline ::std::string* mutable_mode_name();
  inline ::std::string* release_mode_name();
  inline void set_allocated_mode_name(::std::string* mode_name);

  // optional string fpga1_ver = 2;
  inline bool has_fpga1_ver() const;
  inline void clear_fpga1_ver();
  static const int kFpga1VerFieldNumber = 2;
  inline const ::std::string& fpga1_ver() const;
  inline void set_fpga1_ver(const ::std::string& value);
  inline void set_fpga1_ver(const char* value);
  inline void set_fpga1_ver(const char* value, size_t size);
  inline ::std::string* mutable_fpga1_ver();
  inline ::std::string* release_fpga1_ver();
  inline void set_allocated_fpga1_ver(::std::string* fpga1_ver);

  // optional string cpld_ver = 3;
  inline bool has_cpld_ver() const;
  inline void clear_cpld_ver();
  static const int kCpldVerFieldNumber = 3;
  inline const ::std::string& cpld_ver() const;
  inline void set_cpld_ver(const ::std::string& value);
  inline void set_cpld_ver(const char* value);
  inline void set_cpld_ver(const char* value, size_t size);
  inline ::std::string* mutable_cpld_ver();
  inline ::std::string* release_cpld_ver();
  inline void set_allocated_cpld_ver(::std::string* cpld_ver);

  // optional string serial_num = 4;
  inline bool has_serial_num() const;
  inline void clear_serial_num();
  static const int kSerialNumFieldNumber = 4;
  inline const ::std::string& serial_num() const;
  inline void set_serial_num(const ::std::string& value);
  inline void set_serial_num(const char* value);
  inline void set_serial_num(const char* value, size_t size);
  inline ::std::string* mutable_serial_num();
  inline ::std::string* release_serial_num();
  inline void set_allocated_serial_num(::std::string* serial_num);

  // optional string inf_ver = 5;
  inline bool has_inf_ver() const;
  inline void clear_inf_ver();
  static const int kInfVerFieldNumber = 5;
  inline const ::std::string& inf_ver() const;
  inline void set_inf_ver(const ::std::string& value);
  inline void set_inf_ver(const char* value);
  inline void set_inf_ver(const char* value, size_t size);
  inline ::std::string* mutable_inf_ver();
  inline ::std::string* release_inf_ver();
  inline void set_allocated_inf_ver(::std::string* inf_ver);

  // optional string hw_ver = 6;
  inline bool has_hw_ver() const;
  inline void clear_hw_ver();
  static const int kHwVerFieldNumber = 6;
  inline const ::std::string& hw_ver() const;
  inline void set_hw_ver(const ::std::string& value);
  inline void set_hw_ver(const char* value);
  inline void set_hw_ver(const char* value, size_t size);
  inline ::std::string* mutable_hw_ver();
  inline ::std::string* release_hw_ver();
  inline void set_allocated_hw_ver(::std::string* hw_ver);

  // optional string sf_ver = 7;
  inline bool has_sf_ver() const;
  inline void clear_sf_ver();
  static const int kSfVerFieldNumber = 7;
  inline const ::std::string& sf_ver() const;
  inline void set_sf_ver(const ::std::string& value);
  inline void set_sf_ver(const char* value);
  inline void set_sf_ver(const char* value, size_t size);
  inline ::std::string* mutable_sf_ver();
  inline ::std::string* release_sf_ver();
  inline void set_allocated_sf_ver(::std::string* sf_ver);

  // optional .nv.EmNvMtModel emMtMdodel = 8;
  inline bool has_emmtmdodel() const;
  inline void clear_emmtmdodel();
  static const int kEmMtMdodelFieldNumber = 8;
  inline ::nv::EmNvMtModel emmtmdodel() const;
  inline void set_emmtmdodel(::nv::EmNvMtModel value);

  // @@protoc_insertion_point(class_scope:nv.TNVHWInfo)
 private:
  inline void set_has_mode_name();
  inline void clear_has_mode_name();
  inline void set_has_fpga1_ver();
  inline void clear_has_fpga1_ver();
  inline void set_has_cpld_ver();
  inline void clear_has_cpld_ver();
  inline void set_has_serial_num();
  inline void clear_has_serial_num();
  inline void set_has_inf_ver();
  inline void clear_has_inf_ver();
  inline void set_has_hw_ver();
  inline void clear_has_hw_ver();
  inline void set_has_sf_ver();
  inline void clear_has_sf_ver();
  inline void set_has_emmtmdodel();
  inline void clear_has_emmtmdodel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mode_name_;
  ::std::string* fpga1_ver_;
  ::std::string* cpld_ver_;
  ::std::string* serial_num_;
  ::std::string* inf_ver_;
  ::std::string* hw_ver_;
  ::std::string* sf_ver_;
  int emmtmdodel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVHWInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtInfo : public ::google::protobuf::Message {
 public:
  TNVMtInfo();
  virtual ~TNVMtInfo();

  TNVMtInfo(const TNVMtInfo& from);

  inline TNVMtInfo& operator=(const TNVMtInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtInfo& default_instance();

  void Swap(TNVMtInfo* other);

  // implements Message ----------------------------------------------

  TNVMtInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtInfo& from);
  void MergeFrom(const TNVMtInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvCallState mt_conf = 1;
  inline bool has_mt_conf() const;
  inline void clear_mt_conf();
  static const int kMtConfFieldNumber = 1;
  inline ::nv::EmNvCallState mt_conf() const;
  inline void set_mt_conf(::nv::EmNvCallState value);

  // optional bool send_dual = 2;
  inline bool has_send_dual() const;
  inline void clear_send_dual();
  static const int kSendDualFieldNumber = 2;
  inline bool send_dual() const;
  inline void set_send_dual(bool value);

  // optional bool recv_dual = 3;
  inline bool has_recv_dual() const;
  inline void clear_recv_dual();
  static const int kRecvDualFieldNumber = 3;
  inline bool recv_dual() const;
  inline void set_recv_dual(bool value);

  // optional uint32 answermode = 4;
  inline bool has_answermode() const;
  inline void clear_answermode();
  static const int kAnswermodeFieldNumber = 4;
  inline ::google::protobuf::uint32 answermode() const;
  inline void set_answermode(::google::protobuf::uint32 value);

  // optional string mt_ip = 5;
  inline bool has_mt_ip() const;
  inline void clear_mt_ip();
  static const int kMtIpFieldNumber = 5;
  inline const ::std::string& mt_ip() const;
  inline void set_mt_ip(const ::std::string& value);
  inline void set_mt_ip(const char* value);
  inline void set_mt_ip(const char* value, size_t size);
  inline ::std::string* mutable_mt_ip();
  inline ::std::string* release_mt_ip();
  inline void set_allocated_mt_ip(::std::string* mt_ip);

  // optional .nv.EmMtVer mt_mode = 6;
  inline bool has_mt_mode() const;
  inline void clear_mt_mode();
  static const int kMtModeFieldNumber = 6;
  inline ::nv::EmMtVer mt_mode() const;
  inline void set_mt_mode(::nv::EmMtVer value);

  // optional bool sleep = 7;
  inline bool has_sleep() const;
  inline void clear_sleep();
  static const int kSleepFieldNumber = 7;
  inline bool sleep() const;
  inline void set_sleep(bool value);

  // optional .nv.TNVHWInfo thwinfo = 8;
  inline bool has_thwinfo() const;
  inline void clear_thwinfo();
  static const int kThwinfoFieldNumber = 8;
  inline const ::nv::TNVHWInfo& thwinfo() const;
  inline ::nv::TNVHWInfo* mutable_thwinfo();
  inline ::nv::TNVHWInfo* release_thwinfo();
  inline void set_allocated_thwinfo(::nv::TNVHWInfo* thwinfo);

  // @@protoc_insertion_point(class_scope:nv.TNVMtInfo)
 private:
  inline void set_has_mt_conf();
  inline void clear_has_mt_conf();
  inline void set_has_send_dual();
  inline void clear_has_send_dual();
  inline void set_has_recv_dual();
  inline void clear_has_recv_dual();
  inline void set_has_answermode();
  inline void clear_has_answermode();
  inline void set_has_mt_ip();
  inline void clear_has_mt_ip();
  inline void set_has_mt_mode();
  inline void clear_has_mt_mode();
  inline void set_has_sleep();
  inline void clear_has_sleep();
  inline void set_has_thwinfo();
  inline void clear_has_thwinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int mt_conf_;
  ::google::protobuf::uint32 answermode_;
  bool send_dual_;
  bool recv_dual_;
  bool sleep_;
  int mt_mode_;
  ::std::string* mt_ip_;
  ::nv::TNVHWInfo* thwinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVMtInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVQkVer : public ::google::protobuf::Message {
 public:
  TNVQkVer();
  virtual ~TNVQkVer();

  TNVQkVer(const TNVQkVer& from);

  inline TNVQkVer& operator=(const TNVQkVer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVQkVer& default_instance();

  void Swap(TNVQkVer* other);

  // implements Message ----------------------------------------------

  TNVQkVer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVQkVer& from);
  void MergeFrom(const TNVQkVer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nv.EmNvImixVidSrcType src_type = 1;
  inline bool has_src_type() const;
  inline void clear_src_type();
  static const int kSrcTypeFieldNumber = 1;
  inline ::nv::EmNvImixVidSrcType src_type() const;
  inline void set_src_type(::nv::EmNvImixVidSrcType value);

  // optional string ver = 2;
  inline bool has_ver() const;
  inline void clear_ver();
  static const int kVerFieldNumber = 2;
  inline const ::std::string& ver() const;
  inline void set_ver(const ::std::string& value);
  inline void set_ver(const char* value);
  inline void set_ver(const char* value, size_t size);
  inline ::std::string* mutable_ver();
  inline ::std::string* release_ver();
  inline void set_allocated_ver(::std::string* ver);

  // optional string vid_name = 3;
  inline bool has_vid_name() const;
  inline void clear_vid_name();
  static const int kVidNameFieldNumber = 3;
  inline const ::std::string& vid_name() const;
  inline void set_vid_name(const ::std::string& value);
  inline void set_vid_name(const char* value);
  inline void set_vid_name(const char* value, size_t size);
  inline ::std::string* mutable_vid_name();
  inline ::std::string* release_vid_name();
  inline void set_allocated_vid_name(::std::string* vid_name);

  // optional bool use = 4;
  inline bool has_use() const;
  inline void clear_use();
  static const int kUseFieldNumber = 4;
  inline bool use() const;
  inline void set_use(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVQkVer)
 private:
  inline void set_has_src_type();
  inline void clear_has_src_type();
  inline void set_has_ver();
  inline void clear_has_ver();
  inline void set_has_vid_name();
  inline void clear_has_vid_name();
  inline void set_has_use();
  inline void clear_has_use();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ver_;
  int src_type_;
  bool use_;
  ::std::string* vid_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVQkVer* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVMtAutoSleepCfg : public ::google::protobuf::Message {
 public:
  TNVMtAutoSleepCfg();
  virtual ~TNVMtAutoSleepCfg();

  TNVMtAutoSleepCfg(const TNVMtAutoSleepCfg& from);

  inline TNVMtAutoSleepCfg& operator=(const TNVMtAutoSleepCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVMtAutoSleepCfg& default_instance();

  void Swap(TNVMtAutoSleepCfg* other);

  // implements Message ----------------------------------------------

  TNVMtAutoSleepCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVMtAutoSleepCfg& from);
  void MergeFrom(const TNVMtAutoSleepCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional bool allowcall = 3;
  inline bool has_allowcall() const;
  inline void clear_allowcall();
  static const int kAllowcallFieldNumber = 3;
  inline bool allowcall() const;
  inline void set_allowcall(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVMtAutoSleepCfg)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_allowcall();
  inline void clear_has_allowcall();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 time_;
  bool enable_;
  bool allowcall_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVMtAutoSleepCfg* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVClearSrcType : public ::google::protobuf::Message {
 public:
  TNVClearSrcType();
  virtual ~TNVClearSrcType();

  TNVClearSrcType(const TNVClearSrcType& from);

  inline TNVClearSrcType& operator=(const TNVClearSrcType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVClearSrcType& default_instance();

  void Swap(TNVClearSrcType* other);

  // implements Message ----------------------------------------------

  TNVClearSrcType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVClearSrcType& from);
  void MergeFrom(const TNVClearSrcType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.EmNvImixVidSrcType src_type = 1;
  inline int src_type_size() const;
  inline void clear_src_type();
  static const int kSrcTypeFieldNumber = 1;
  inline ::nv::EmNvImixVidSrcType src_type(int index) const;
  inline void set_src_type(int index, ::nv::EmNvImixVidSrcType value);
  inline void add_src_type(::nv::EmNvImixVidSrcType value);
  inline const ::google::protobuf::RepeatedField<int>& src_type() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_src_type();

  // @@protoc_insertion_point(class_scope:nv.TNVClearSrcType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> src_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVClearSrcType* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVAllUpgradePackageContent : public ::google::protobuf::Message {
 public:
  TNVAllUpgradePackageContent();
  virtual ~TNVAllUpgradePackageContent();

  TNVAllUpgradePackageContent(const TNVAllUpgradePackageContent& from);

  inline TNVAllUpgradePackageContent& operator=(const TNVAllUpgradePackageContent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVAllUpgradePackageContent& default_instance();

  void Swap(TNVAllUpgradePackageContent* other);

  // implements Message ----------------------------------------------

  TNVAllUpgradePackageContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVAllUpgradePackageContent& from);
  void MergeFrom(const TNVAllUpgradePackageContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_has_app_package = 1;
  inline bool has_is_has_app_package() const;
  inline void clear_is_has_app_package();
  static const int kIsHasAppPackageFieldNumber = 1;
  inline bool is_has_app_package() const;
  inline void set_is_has_app_package(bool value);

  // optional bool is_has_imix_package = 2;
  inline bool has_is_has_imix_package() const;
  inline void clear_is_has_imix_package();
  static const int kIsHasImixPackageFieldNumber = 2;
  inline bool is_has_imix_package() const;
  inline void set_is_has_imix_package(bool value);

  // optional bool is_has_power_package = 3;
  inline bool has_is_has_power_package() const;
  inline void clear_is_has_power_package();
  static const int kIsHasPowerPackageFieldNumber = 3;
  inline bool is_has_power_package() const;
  inline void set_is_has_power_package(bool value);

  // optional bool is_has_openwrt_package = 4;
  inline bool has_is_has_openwrt_package() const;
  inline void clear_is_has_openwrt_package();
  static const int kIsHasOpenwrtPackageFieldNumber = 4;
  inline bool is_has_openwrt_package() const;
  inline void set_is_has_openwrt_package(bool value);

  // optional bool is_has_pad_package = 5;
  inline bool has_is_has_pad_package() const;
  inline void clear_is_has_pad_package();
  static const int kIsHasPadPackageFieldNumber = 5;
  inline bool is_has_pad_package() const;
  inline void set_is_has_pad_package(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVAllUpgradePackageContent)
 private:
  inline void set_has_is_has_app_package();
  inline void clear_has_is_has_app_package();
  inline void set_has_is_has_imix_package();
  inline void clear_has_is_has_imix_package();
  inline void set_has_is_has_power_package();
  inline void clear_has_is_has_power_package();
  inline void set_has_is_has_openwrt_package();
  inline void clear_has_is_has_openwrt_package();
  inline void set_has_is_has_pad_package();
  inline void clear_has_is_has_pad_package();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_has_app_package_;
  bool is_has_imix_package_;
  bool is_has_power_package_;
  bool is_has_openwrt_package_;
  bool is_has_pad_package_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVAllUpgradePackageContent* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVPadLoginInfo : public ::google::protobuf::Message {
 public:
  TNVPadLoginInfo();
  virtual ~TNVPadLoginInfo();

  TNVPadLoginInfo(const TNVPadLoginInfo& from);

  inline TNVPadLoginInfo& operator=(const TNVPadLoginInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVPadLoginInfo& default_instance();

  void Swap(TNVPadLoginInfo* other);

  // implements Message ----------------------------------------------

  TNVPadLoginInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVPadLoginInfo& from);
  void MergeFrom(const TNVPadLoginInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 node_id() const;
  inline void set_node_id(::google::protobuf::uint32 value);

  // optional uint32 appinst_id = 2;
  inline bool has_appinst_id() const;
  inline void clear_appinst_id();
  static const int kAppinstIdFieldNumber = 2;
  inline ::google::protobuf::uint32 appinst_id() const;
  inline void set_appinst_id(::google::protobuf::uint32 value);

  // optional bool download = 3;
  inline bool has_download() const;
  inline void clear_download();
  static const int kDownloadFieldNumber = 3;
  inline bool download() const;
  inline void set_download(bool value);

  // @@protoc_insertion_point(class_scope:nv.TNVPadLoginInfo)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_appinst_id();
  inline void clear_has_appinst_id();
  inline void set_has_download();
  inline void clear_has_download();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 node_id_;
  ::google::protobuf::uint32 appinst_id_;
  bool download_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVPadLoginInfo* default_instance_;
};
// -------------------------------------------------------------------

class MTMSG_API TNVPadLoginInfos : public ::google::protobuf::Message {
 public:
  TNVPadLoginInfos();
  virtual ~TNVPadLoginInfos();

  TNVPadLoginInfos(const TNVPadLoginInfos& from);

  inline TNVPadLoginInfos& operator=(const TNVPadLoginInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TNVPadLoginInfos& default_instance();

  void Swap(TNVPadLoginInfos* other);

  // implements Message ----------------------------------------------

  TNVPadLoginInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TNVPadLoginInfos& from);
  void MergeFrom(const TNVPadLoginInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nv.TNVPadLoginInfo login_info_list = 1;
  inline int login_info_list_size() const;
  inline void clear_login_info_list();
  static const int kLoginInfoListFieldNumber = 1;
  inline const ::nv::TNVPadLoginInfo& login_info_list(int index) const;
  inline ::nv::TNVPadLoginInfo* mutable_login_info_list(int index);
  inline ::nv::TNVPadLoginInfo* add_login_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVPadLoginInfo >&
      login_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::nv::TNVPadLoginInfo >*
      mutable_login_info_list();

  // @@protoc_insertion_point(class_scope:nv.TNVPadLoginInfos)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::nv::TNVPadLoginInfo > login_info_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void MTMSG_API protobuf_AddDesc_nvstructcfg_2eproto();
  friend void protobuf_AssignDesc_nvstructcfg_2eproto();
  friend void protobuf_ShutdownFile_nvstructcfg_2eproto();

  void InitAsDefaultInstance();
  static TNVPadLoginInfos* default_instance_;
};
// ===================================================================


// ===================================================================

// TNVRestoreDefaultCfgInfo

// repeated string key_list = 1;
inline int TNVRestoreDefaultCfgInfo::key_list_size() const {
  return key_list_.size();
}
inline void TNVRestoreDefaultCfgInfo::clear_key_list() {
  key_list_.Clear();
}
inline const ::std::string& TNVRestoreDefaultCfgInfo::key_list(int index) const {
  return key_list_.Get(index);
}
inline ::std::string* TNVRestoreDefaultCfgInfo::mutable_key_list(int index) {
  return key_list_.Mutable(index);
}
inline void TNVRestoreDefaultCfgInfo::set_key_list(int index, const ::std::string& value) {
  key_list_.Mutable(index)->assign(value);
}
inline void TNVRestoreDefaultCfgInfo::set_key_list(int index, const char* value) {
  key_list_.Mutable(index)->assign(value);
}
inline void TNVRestoreDefaultCfgInfo::set_key_list(int index, const char* value, size_t size) {
  key_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVRestoreDefaultCfgInfo::add_key_list() {
  return key_list_.Add();
}
inline void TNVRestoreDefaultCfgInfo::add_key_list(const ::std::string& value) {
  key_list_.Add()->assign(value);
}
inline void TNVRestoreDefaultCfgInfo::add_key_list(const char* value) {
  key_list_.Add()->assign(value);
}
inline void TNVRestoreDefaultCfgInfo::add_key_list(const char* value, size_t size) {
  key_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TNVRestoreDefaultCfgInfo::key_list() const {
  return key_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TNVRestoreDefaultCfgInfo::mutable_key_list() {
  return &key_list_;
}

// -------------------------------------------------------------------

// TNVServiceInfo

// optional uint32 index = 1;
inline bool TNVServiceInfo::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVServiceInfo::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVServiceInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVServiceInfo::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TNVServiceInfo::index() const {
  return index_;
}
inline void TNVServiceInfo::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 nvaid = 2;
inline bool TNVServiceInfo::has_nvaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVServiceInfo::set_has_nvaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVServiceInfo::clear_has_nvaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVServiceInfo::clear_nvaid() {
  nvaid_ = 0u;
  clear_has_nvaid();
}
inline ::google::protobuf::uint32 TNVServiceInfo::nvaid() const {
  return nvaid_;
}
inline void TNVServiceInfo::set_nvaid(::google::protobuf::uint32 value) {
  set_has_nvaid();
  nvaid_ = value;
}

// optional string path = 3;
inline bool TNVServiceInfo::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVServiceInfo::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVServiceInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVServiceInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TNVServiceInfo::path() const {
  return *path_;
}
inline void TNVServiceInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TNVServiceInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TNVServiceInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TNVServiceInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceInfo::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sysalias = 4;
inline bool TNVServiceInfo::has_sysalias() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVServiceInfo::set_has_sysalias() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVServiceInfo::clear_has_sysalias() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVServiceInfo::clear_sysalias() {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    sysalias_->clear();
  }
  clear_has_sysalias();
}
inline const ::std::string& TNVServiceInfo::sysalias() const {
  return *sysalias_;
}
inline void TNVServiceInfo::set_sysalias(const ::std::string& value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TNVServiceInfo::set_sysalias(const char* value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TNVServiceInfo::set_sysalias(const char* value, size_t size) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceInfo::mutable_sysalias() {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  return sysalias_;
}
inline ::std::string* TNVServiceInfo::release_sysalias() {
  clear_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sysalias_;
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceInfo::set_allocated_sysalias(::std::string* sysalias) {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    delete sysalias_;
  }
  if (sysalias) {
    set_has_sysalias();
    sysalias_ = sysalias;
  } else {
    clear_has_sysalias();
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.EmNvSysStartMod startmod = 5;
inline bool TNVServiceInfo::has_startmod() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVServiceInfo::set_has_startmod() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVServiceInfo::clear_has_startmod() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVServiceInfo::clear_startmod() {
  startmod_ = 0;
  clear_has_startmod();
}
inline ::nv::EmNvSysStartMod TNVServiceInfo::startmod() const {
  return static_cast< ::nv::EmNvSysStartMod >(startmod_);
}
inline void TNVServiceInfo::set_startmod(::nv::EmNvSysStartMod value) {
  assert(::nv::EmNvSysStartMod_IsValid(value));
  set_has_startmod();
  startmod_ = value;
}

// optional string srtfuncname = 6;
inline bool TNVServiceInfo::has_srtfuncname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVServiceInfo::set_has_srtfuncname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVServiceInfo::clear_has_srtfuncname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVServiceInfo::clear_srtfuncname() {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    srtfuncname_->clear();
  }
  clear_has_srtfuncname();
}
inline const ::std::string& TNVServiceInfo::srtfuncname() const {
  return *srtfuncname_;
}
inline void TNVServiceInfo::set_srtfuncname(const ::std::string& value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TNVServiceInfo::set_srtfuncname(const char* value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TNVServiceInfo::set_srtfuncname(const char* value, size_t size) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceInfo::mutable_srtfuncname() {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  return srtfuncname_;
}
inline ::std::string* TNVServiceInfo::release_srtfuncname() {
  clear_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srtfuncname_;
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceInfo::set_allocated_srtfuncname(::std::string* srtfuncname) {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete srtfuncname_;
  }
  if (srtfuncname) {
    set_has_srtfuncname();
    srtfuncname_ = srtfuncname;
  } else {
    clear_has_srtfuncname();
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endfuncname = 7;
inline bool TNVServiceInfo::has_endfuncname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVServiceInfo::set_has_endfuncname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVServiceInfo::clear_has_endfuncname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVServiceInfo::clear_endfuncname() {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    endfuncname_->clear();
  }
  clear_has_endfuncname();
}
inline const ::std::string& TNVServiceInfo::endfuncname() const {
  return *endfuncname_;
}
inline void TNVServiceInfo::set_endfuncname(const ::std::string& value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TNVServiceInfo::set_endfuncname(const char* value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TNVServiceInfo::set_endfuncname(const char* value, size_t size) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceInfo::mutable_endfuncname() {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  return endfuncname_;
}
inline ::std::string* TNVServiceInfo::release_endfuncname() {
  clear_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endfuncname_;
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceInfo::set_allocated_endfuncname(::std::string* endfuncname) {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete endfuncname_;
  }
  if (endfuncname) {
    set_has_endfuncname();
    endfuncname_ = endfuncname;
  } else {
    clear_has_endfuncname();
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.EmNvSysSrvState srvstate = 8;
inline bool TNVServiceInfo::has_srvstate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVServiceInfo::set_has_srvstate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVServiceInfo::clear_has_srvstate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVServiceInfo::clear_srvstate() {
  srvstate_ = 0;
  clear_has_srvstate();
}
inline ::nv::EmNvSysSrvState TNVServiceInfo::srvstate() const {
  return static_cast< ::nv::EmNvSysSrvState >(srvstate_);
}
inline void TNVServiceInfo::set_srvstate(::nv::EmNvSysSrvState value) {
  assert(::nv::EmNvSysSrvState_IsValid(value));
  set_has_srvstate();
  srvstate_ = value;
}

// optional .nv.EmNvSysKeepLiveState srvklstate = 9;
inline bool TNVServiceInfo::has_srvklstate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVServiceInfo::set_has_srvklstate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVServiceInfo::clear_has_srvklstate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVServiceInfo::clear_srvklstate() {
  srvklstate_ = 0;
  clear_has_srvklstate();
}
inline ::nv::EmNvSysKeepLiveState TNVServiceInfo::srvklstate() const {
  return static_cast< ::nv::EmNvSysKeepLiveState >(srvklstate_);
}
inline void TNVServiceInfo::set_srvklstate(::nv::EmNvSysKeepLiveState value) {
  assert(::nv::EmNvSysKeepLiveState_IsValid(value));
  set_has_srvklstate();
  srvklstate_ = value;
}

// optional uint32 time = 10;
inline bool TNVServiceInfo::has_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TNVServiceInfo::set_has_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TNVServiceInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TNVServiceInfo::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 TNVServiceInfo::time() const {
  return time_;
}
inline void TNVServiceInfo::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional uint32 timestamp = 11;
inline bool TNVServiceInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TNVServiceInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TNVServiceInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TNVServiceInfo::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 TNVServiceInfo::timestamp() const {
  return timestamp_;
}
inline void TNVServiceInfo::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional uint32 dllhandler = 12;
inline bool TNVServiceInfo::has_dllhandler() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TNVServiceInfo::set_has_dllhandler() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TNVServiceInfo::clear_has_dllhandler() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TNVServiceInfo::clear_dllhandler() {
  dllhandler_ = 0u;
  clear_has_dllhandler();
}
inline ::google::protobuf::uint32 TNVServiceInfo::dllhandler() const {
  return dllhandler_;
}
inline void TNVServiceInfo::set_dllhandler(::google::protobuf::uint32 value) {
  set_has_dllhandler();
  dllhandler_ = value;
}

// optional uint32 processpid = 13;
inline bool TNVServiceInfo::has_processpid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TNVServiceInfo::set_has_processpid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TNVServiceInfo::clear_has_processpid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TNVServiceInfo::clear_processpid() {
  processpid_ = 0u;
  clear_has_processpid();
}
inline ::google::protobuf::uint32 TNVServiceInfo::processpid() const {
  return processpid_;
}
inline void TNVServiceInfo::set_processpid(::google::protobuf::uint32 value) {
  set_has_processpid();
  processpid_ = value;
}

// optional string version = 14;
inline bool TNVServiceInfo::has_version() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TNVServiceInfo::set_has_version() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TNVServiceInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TNVServiceInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TNVServiceInfo::version() const {
  return *version_;
}
inline void TNVServiceInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TNVServiceInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TNVServiceInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* TNVServiceInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVServiceInfoFromUI

// optional uint32 nvaid = 1;
inline bool TNVServiceInfoFromUI::has_nvaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVServiceInfoFromUI::set_has_nvaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVServiceInfoFromUI::clear_has_nvaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVServiceInfoFromUI::clear_nvaid() {
  nvaid_ = 0u;
  clear_has_nvaid();
}
inline ::google::protobuf::uint32 TNVServiceInfoFromUI::nvaid() const {
  return nvaid_;
}
inline void TNVServiceInfoFromUI::set_nvaid(::google::protobuf::uint32 value) {
  set_has_nvaid();
  nvaid_ = value;
}

// optional string path = 2;
inline bool TNVServiceInfoFromUI::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVServiceInfoFromUI::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVServiceInfoFromUI::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVServiceInfoFromUI::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TNVServiceInfoFromUI::path() const {
  return *path_;
}
inline void TNVServiceInfoFromUI::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TNVServiceInfoFromUI::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TNVServiceInfoFromUI::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceInfoFromUI::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TNVServiceInfoFromUI::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceInfoFromUI::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sysalias = 3;
inline bool TNVServiceInfoFromUI::has_sysalias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVServiceInfoFromUI::set_has_sysalias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVServiceInfoFromUI::clear_has_sysalias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVServiceInfoFromUI::clear_sysalias() {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    sysalias_->clear();
  }
  clear_has_sysalias();
}
inline const ::std::string& TNVServiceInfoFromUI::sysalias() const {
  return *sysalias_;
}
inline void TNVServiceInfoFromUI::set_sysalias(const ::std::string& value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TNVServiceInfoFromUI::set_sysalias(const char* value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TNVServiceInfoFromUI::set_sysalias(const char* value, size_t size) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceInfoFromUI::mutable_sysalias() {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  return sysalias_;
}
inline ::std::string* TNVServiceInfoFromUI::release_sysalias() {
  clear_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sysalias_;
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceInfoFromUI::set_allocated_sysalias(::std::string* sysalias) {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    delete sysalias_;
  }
  if (sysalias) {
    set_has_sysalias();
    sysalias_ = sysalias;
  } else {
    clear_has_sysalias();
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.EmNvSysStartModFromUI startmod = 4;
inline bool TNVServiceInfoFromUI::has_startmod() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVServiceInfoFromUI::set_has_startmod() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVServiceInfoFromUI::clear_has_startmod() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVServiceInfoFromUI::clear_startmod() {
  startmod_ = 0;
  clear_has_startmod();
}
inline ::nv::EmNvSysStartModFromUI TNVServiceInfoFromUI::startmod() const {
  return static_cast< ::nv::EmNvSysStartModFromUI >(startmod_);
}
inline void TNVServiceInfoFromUI::set_startmod(::nv::EmNvSysStartModFromUI value) {
  assert(::nv::EmNvSysStartModFromUI_IsValid(value));
  set_has_startmod();
  startmod_ = value;
}

// optional string srtfuncname = 5;
inline bool TNVServiceInfoFromUI::has_srtfuncname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVServiceInfoFromUI::set_has_srtfuncname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVServiceInfoFromUI::clear_has_srtfuncname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVServiceInfoFromUI::clear_srtfuncname() {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    srtfuncname_->clear();
  }
  clear_has_srtfuncname();
}
inline const ::std::string& TNVServiceInfoFromUI::srtfuncname() const {
  return *srtfuncname_;
}
inline void TNVServiceInfoFromUI::set_srtfuncname(const ::std::string& value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TNVServiceInfoFromUI::set_srtfuncname(const char* value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TNVServiceInfoFromUI::set_srtfuncname(const char* value, size_t size) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceInfoFromUI::mutable_srtfuncname() {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  return srtfuncname_;
}
inline ::std::string* TNVServiceInfoFromUI::release_srtfuncname() {
  clear_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srtfuncname_;
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceInfoFromUI::set_allocated_srtfuncname(::std::string* srtfuncname) {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete srtfuncname_;
  }
  if (srtfuncname) {
    set_has_srtfuncname();
    srtfuncname_ = srtfuncname;
  } else {
    clear_has_srtfuncname();
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endfuncname = 6;
inline bool TNVServiceInfoFromUI::has_endfuncname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVServiceInfoFromUI::set_has_endfuncname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVServiceInfoFromUI::clear_has_endfuncname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVServiceInfoFromUI::clear_endfuncname() {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    endfuncname_->clear();
  }
  clear_has_endfuncname();
}
inline const ::std::string& TNVServiceInfoFromUI::endfuncname() const {
  return *endfuncname_;
}
inline void TNVServiceInfoFromUI::set_endfuncname(const ::std::string& value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TNVServiceInfoFromUI::set_endfuncname(const char* value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TNVServiceInfoFromUI::set_endfuncname(const char* value, size_t size) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceInfoFromUI::mutable_endfuncname() {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  return endfuncname_;
}
inline ::std::string* TNVServiceInfoFromUI::release_endfuncname() {
  clear_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endfuncname_;
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceInfoFromUI::set_allocated_endfuncname(::std::string* endfuncname) {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete endfuncname_;
  }
  if (endfuncname) {
    set_has_endfuncname();
    endfuncname_ = endfuncname;
  } else {
    clear_has_endfuncname();
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVServiceDefInfo

// optional uint32 index = 1;
inline bool TNVServiceDefInfo::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVServiceDefInfo::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVServiceDefInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVServiceDefInfo::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TNVServiceDefInfo::index() const {
  return index_;
}
inline void TNVServiceDefInfo::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional string path = 2;
inline bool TNVServiceDefInfo::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVServiceDefInfo::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVServiceDefInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVServiceDefInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TNVServiceDefInfo::path() const {
  return *path_;
}
inline void TNVServiceDefInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TNVServiceDefInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TNVServiceDefInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceDefInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TNVServiceDefInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceDefInfo::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sysalias = 3;
inline bool TNVServiceDefInfo::has_sysalias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVServiceDefInfo::set_has_sysalias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVServiceDefInfo::clear_has_sysalias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVServiceDefInfo::clear_sysalias() {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    sysalias_->clear();
  }
  clear_has_sysalias();
}
inline const ::std::string& TNVServiceDefInfo::sysalias() const {
  return *sysalias_;
}
inline void TNVServiceDefInfo::set_sysalias(const ::std::string& value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TNVServiceDefInfo::set_sysalias(const char* value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TNVServiceDefInfo::set_sysalias(const char* value, size_t size) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceDefInfo::mutable_sysalias() {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  return sysalias_;
}
inline ::std::string* TNVServiceDefInfo::release_sysalias() {
  clear_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sysalias_;
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceDefInfo::set_allocated_sysalias(::std::string* sysalias) {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    delete sysalias_;
  }
  if (sysalias) {
    set_has_sysalias();
    sysalias_ = sysalias;
  } else {
    clear_has_sysalias();
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.EmNvSysStartMod startmod = 4;
inline bool TNVServiceDefInfo::has_startmod() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVServiceDefInfo::set_has_startmod() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVServiceDefInfo::clear_has_startmod() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVServiceDefInfo::clear_startmod() {
  startmod_ = 0;
  clear_has_startmod();
}
inline ::nv::EmNvSysStartMod TNVServiceDefInfo::startmod() const {
  return static_cast< ::nv::EmNvSysStartMod >(startmod_);
}
inline void TNVServiceDefInfo::set_startmod(::nv::EmNvSysStartMod value) {
  assert(::nv::EmNvSysStartMod_IsValid(value));
  set_has_startmod();
  startmod_ = value;
}

// optional string srtfuncname = 5;
inline bool TNVServiceDefInfo::has_srtfuncname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVServiceDefInfo::set_has_srtfuncname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVServiceDefInfo::clear_has_srtfuncname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVServiceDefInfo::clear_srtfuncname() {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    srtfuncname_->clear();
  }
  clear_has_srtfuncname();
}
inline const ::std::string& TNVServiceDefInfo::srtfuncname() const {
  return *srtfuncname_;
}
inline void TNVServiceDefInfo::set_srtfuncname(const ::std::string& value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TNVServiceDefInfo::set_srtfuncname(const char* value) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(value);
}
inline void TNVServiceDefInfo::set_srtfuncname(const char* value, size_t size) {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  srtfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceDefInfo::mutable_srtfuncname() {
  set_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    srtfuncname_ = new ::std::string;
  }
  return srtfuncname_;
}
inline ::std::string* TNVServiceDefInfo::release_srtfuncname() {
  clear_has_srtfuncname();
  if (srtfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srtfuncname_;
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceDefInfo::set_allocated_srtfuncname(::std::string* srtfuncname) {
  if (srtfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete srtfuncname_;
  }
  if (srtfuncname) {
    set_has_srtfuncname();
    srtfuncname_ = srtfuncname;
  } else {
    clear_has_srtfuncname();
    srtfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endfuncname = 6;
inline bool TNVServiceDefInfo::has_endfuncname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVServiceDefInfo::set_has_endfuncname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVServiceDefInfo::clear_has_endfuncname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVServiceDefInfo::clear_endfuncname() {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    endfuncname_->clear();
  }
  clear_has_endfuncname();
}
inline const ::std::string& TNVServiceDefInfo::endfuncname() const {
  return *endfuncname_;
}
inline void TNVServiceDefInfo::set_endfuncname(const ::std::string& value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TNVServiceDefInfo::set_endfuncname(const char* value) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(value);
}
inline void TNVServiceDefInfo::set_endfuncname(const char* value, size_t size) {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  endfuncname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServiceDefInfo::mutable_endfuncname() {
  set_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    endfuncname_ = new ::std::string;
  }
  return endfuncname_;
}
inline ::std::string* TNVServiceDefInfo::release_endfuncname() {
  clear_has_endfuncname();
  if (endfuncname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endfuncname_;
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServiceDefInfo::set_allocated_endfuncname(::std::string* endfuncname) {
  if (endfuncname_ != &::google::protobuf::internal::kEmptyString) {
    delete endfuncname_;
  }
  if (endfuncname) {
    set_has_endfuncname();
    endfuncname_ = endfuncname;
  } else {
    clear_has_endfuncname();
    endfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVSrvKeepLiveInfo

// optional string sysalias = 1;
inline bool TNVSrvKeepLiveInfo::has_sysalias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVSrvKeepLiveInfo::set_has_sysalias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVSrvKeepLiveInfo::clear_has_sysalias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVSrvKeepLiveInfo::clear_sysalias() {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    sysalias_->clear();
  }
  clear_has_sysalias();
}
inline const ::std::string& TNVSrvKeepLiveInfo::sysalias() const {
  return *sysalias_;
}
inline void TNVSrvKeepLiveInfo::set_sysalias(const ::std::string& value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TNVSrvKeepLiveInfo::set_sysalias(const char* value) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(value);
}
inline void TNVSrvKeepLiveInfo::set_sysalias(const char* value, size_t size) {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  sysalias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSrvKeepLiveInfo::mutable_sysalias() {
  set_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    sysalias_ = new ::std::string;
  }
  return sysalias_;
}
inline ::std::string* TNVSrvKeepLiveInfo::release_sysalias() {
  clear_has_sysalias();
  if (sysalias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sysalias_;
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVSrvKeepLiveInfo::set_allocated_sysalias(::std::string* sysalias) {
  if (sysalias_ != &::google::protobuf::internal::kEmptyString) {
    delete sysalias_;
  }
  if (sysalias) {
    set_has_sysalias();
    sysalias_ = sysalias;
  } else {
    clear_has_sysalias();
    sysalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 nvaid = 2;
inline bool TNVSrvKeepLiveInfo::has_nvaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVSrvKeepLiveInfo::set_has_nvaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVSrvKeepLiveInfo::clear_has_nvaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVSrvKeepLiveInfo::clear_nvaid() {
  nvaid_ = 0u;
  clear_has_nvaid();
}
inline ::google::protobuf::uint32 TNVSrvKeepLiveInfo::nvaid() const {
  return nvaid_;
}
inline void TNVSrvKeepLiveInfo::set_nvaid(::google::protobuf::uint32 value) {
  set_has_nvaid();
  nvaid_ = value;
}

// optional uint32 time = 3;
inline bool TNVSrvKeepLiveInfo::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVSrvKeepLiveInfo::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVSrvKeepLiveInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVSrvKeepLiveInfo::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 TNVSrvKeepLiveInfo::time() const {
  return time_;
}
inline void TNVSrvKeepLiveInfo::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// TNVMutiTServiceInfo

// repeated .nv.TNVServiceInfoFromUI tServiceInfo = 1;
inline int TNVMutiTServiceInfo::tserviceinfo_size() const {
  return tserviceinfo_.size();
}
inline void TNVMutiTServiceInfo::clear_tserviceinfo() {
  tserviceinfo_.Clear();
}
inline const ::nv::TNVServiceInfoFromUI& TNVMutiTServiceInfo::tserviceinfo(int index) const {
  return tserviceinfo_.Get(index);
}
inline ::nv::TNVServiceInfoFromUI* TNVMutiTServiceInfo::mutable_tserviceinfo(int index) {
  return tserviceinfo_.Mutable(index);
}
inline ::nv::TNVServiceInfoFromUI* TNVMutiTServiceInfo::add_tserviceinfo() {
  return tserviceinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceInfoFromUI >&
TNVMutiTServiceInfo::tserviceinfo() const {
  return tserviceinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceInfoFromUI >*
TNVMutiTServiceInfo::mutable_tserviceinfo() {
  return &tserviceinfo_;
}

// -------------------------------------------------------------------

// TNVMutiTServiceInfoRtData

// repeated .nv.TNVServiceInfo tServiceInfo = 1;
inline int TNVMutiTServiceInfoRtData::tserviceinfo_size() const {
  return tserviceinfo_.size();
}
inline void TNVMutiTServiceInfoRtData::clear_tserviceinfo() {
  tserviceinfo_.Clear();
}
inline const ::nv::TNVServiceInfo& TNVMutiTServiceInfoRtData::tserviceinfo(int index) const {
  return tserviceinfo_.Get(index);
}
inline ::nv::TNVServiceInfo* TNVMutiTServiceInfoRtData::mutable_tserviceinfo(int index) {
  return tserviceinfo_.Mutable(index);
}
inline ::nv::TNVServiceInfo* TNVMutiTServiceInfoRtData::add_tserviceinfo() {
  return tserviceinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceInfo >&
TNVMutiTServiceInfoRtData::tserviceinfo() const {
  return tserviceinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceInfo >*
TNVMutiTServiceInfoRtData::mutable_tserviceinfo() {
  return &tserviceinfo_;
}

// -------------------------------------------------------------------

// TNVMutiTServiceDefInfo

// repeated .nv.TNVServiceDefInfo tServiceDefInfo = 1;
inline int TNVMutiTServiceDefInfo::tservicedefinfo_size() const {
  return tservicedefinfo_.size();
}
inline void TNVMutiTServiceDefInfo::clear_tservicedefinfo() {
  tservicedefinfo_.Clear();
}
inline const ::nv::TNVServiceDefInfo& TNVMutiTServiceDefInfo::tservicedefinfo(int index) const {
  return tservicedefinfo_.Get(index);
}
inline ::nv::TNVServiceDefInfo* TNVMutiTServiceDefInfo::mutable_tservicedefinfo(int index) {
  return tservicedefinfo_.Mutable(index);
}
inline ::nv::TNVServiceDefInfo* TNVMutiTServiceDefInfo::add_tservicedefinfo() {
  return tservicedefinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceDefInfo >&
TNVMutiTServiceDefInfo::tservicedefinfo() const {
  return tservicedefinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVServiceDefInfo >*
TNVMutiTServiceDefInfo::mutable_tservicedefinfo() {
  return &tservicedefinfo_;
}

// -------------------------------------------------------------------

// TNVPortPairInfo

// optional uint32 port_one = 1;
inline bool TNVPortPairInfo::has_port_one() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVPortPairInfo::set_has_port_one() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVPortPairInfo::clear_has_port_one() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVPortPairInfo::clear_port_one() {
  port_one_ = 0u;
  clear_has_port_one();
}
inline ::google::protobuf::uint32 TNVPortPairInfo::port_one() const {
  return port_one_;
}
inline void TNVPortPairInfo::set_port_one(::google::protobuf::uint32 value) {
  set_has_port_one();
  port_one_ = value;
}

// optional uint32 port_two = 2;
inline bool TNVPortPairInfo::has_port_two() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVPortPairInfo::set_has_port_two() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVPortPairInfo::clear_has_port_two() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVPortPairInfo::clear_port_two() {
  port_two_ = 0u;
  clear_has_port_two();
}
inline ::google::protobuf::uint32 TNVPortPairInfo::port_two() const {
  return port_two_;
}
inline void TNVPortPairInfo::set_port_two(::google::protobuf::uint32 value) {
  set_has_port_two();
  port_two_ = value;
}

// optional string describe = 3;
inline bool TNVPortPairInfo::has_describe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVPortPairInfo::set_has_describe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVPortPairInfo::clear_has_describe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVPortPairInfo::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& TNVPortPairInfo::describe() const {
  return *describe_;
}
inline void TNVPortPairInfo::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TNVPortPairInfo::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TNVPortPairInfo::set_describe(const char* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVPortPairInfo::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* TNVPortPairInfo::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVPortPairInfo::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVPortPairAllocReqInfo

// optional bool is_tcp_port = 1;
inline bool TNVPortPairAllocReqInfo::has_is_tcp_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVPortPairAllocReqInfo::set_has_is_tcp_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVPortPairAllocReqInfo::clear_has_is_tcp_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVPortPairAllocReqInfo::clear_is_tcp_port() {
  is_tcp_port_ = false;
  clear_has_is_tcp_port();
}
inline bool TNVPortPairAllocReqInfo::is_tcp_port() const {
  return is_tcp_port_;
}
inline void TNVPortPairAllocReqInfo::set_is_tcp_port(bool value) {
  set_has_is_tcp_port();
  is_tcp_port_ = value;
}

// optional uint32 port_pair_num = 2;
inline bool TNVPortPairAllocReqInfo::has_port_pair_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVPortPairAllocReqInfo::set_has_port_pair_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVPortPairAllocReqInfo::clear_has_port_pair_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVPortPairAllocReqInfo::clear_port_pair_num() {
  port_pair_num_ = 0u;
  clear_has_port_pair_num();
}
inline ::google::protobuf::uint32 TNVPortPairAllocReqInfo::port_pair_num() const {
  return port_pair_num_;
}
inline void TNVPortPairAllocReqInfo::set_port_pair_num(::google::protobuf::uint32 value) {
  set_has_port_pair_num();
  port_pair_num_ = value;
}

// optional string describe = 3;
inline bool TNVPortPairAllocReqInfo::has_describe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVPortPairAllocReqInfo::set_has_describe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVPortPairAllocReqInfo::clear_has_describe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVPortPairAllocReqInfo::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& TNVPortPairAllocReqInfo::describe() const {
  return *describe_;
}
inline void TNVPortPairAllocReqInfo::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TNVPortPairAllocReqInfo::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TNVPortPairAllocReqInfo::set_describe(const char* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVPortPairAllocReqInfo::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* TNVPortPairAllocReqInfo::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVPortPairAllocReqInfo::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVPortRangeAllocReqInfo

// optional bool is_tcp_port = 1;
inline bool TNVPortRangeAllocReqInfo::has_is_tcp_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVPortRangeAllocReqInfo::set_has_is_tcp_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVPortRangeAllocReqInfo::clear_has_is_tcp_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVPortRangeAllocReqInfo::clear_is_tcp_port() {
  is_tcp_port_ = false;
  clear_has_is_tcp_port();
}
inline bool TNVPortRangeAllocReqInfo::is_tcp_port() const {
  return is_tcp_port_;
}
inline void TNVPortRangeAllocReqInfo::set_is_tcp_port(bool value) {
  set_has_is_tcp_port();
  is_tcp_port_ = value;
}

// optional uint32 port_num = 2;
inline bool TNVPortRangeAllocReqInfo::has_port_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVPortRangeAllocReqInfo::set_has_port_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVPortRangeAllocReqInfo::clear_has_port_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVPortRangeAllocReqInfo::clear_port_num() {
  port_num_ = 0u;
  clear_has_port_num();
}
inline ::google::protobuf::uint32 TNVPortRangeAllocReqInfo::port_num() const {
  return port_num_;
}
inline void TNVPortRangeAllocReqInfo::set_port_num(::google::protobuf::uint32 value) {
  set_has_port_num();
  port_num_ = value;
}

// optional bool is_from_even_bgning = 3;
inline bool TNVPortRangeAllocReqInfo::has_is_from_even_bgning() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVPortRangeAllocReqInfo::set_has_is_from_even_bgning() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVPortRangeAllocReqInfo::clear_has_is_from_even_bgning() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVPortRangeAllocReqInfo::clear_is_from_even_bgning() {
  is_from_even_bgning_ = false;
  clear_has_is_from_even_bgning();
}
inline bool TNVPortRangeAllocReqInfo::is_from_even_bgning() const {
  return is_from_even_bgning_;
}
inline void TNVPortRangeAllocReqInfo::set_is_from_even_bgning(bool value) {
  set_has_is_from_even_bgning();
  is_from_even_bgning_ = value;
}

// optional string describe = 4;
inline bool TNVPortRangeAllocReqInfo::has_describe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVPortRangeAllocReqInfo::set_has_describe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVPortRangeAllocReqInfo::clear_has_describe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVPortRangeAllocReqInfo::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& TNVPortRangeAllocReqInfo::describe() const {
  return *describe_;
}
inline void TNVPortRangeAllocReqInfo::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TNVPortRangeAllocReqInfo::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TNVPortRangeAllocReqInfo::set_describe(const char* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVPortRangeAllocReqInfo::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* TNVPortRangeAllocReqInfo::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVPortRangeAllocReqInfo::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVPortPairAllocRspInfo

// optional bool is_ok = 1;
inline bool TNVPortPairAllocRspInfo::has_is_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVPortPairAllocRspInfo::set_has_is_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVPortPairAllocRspInfo::clear_has_is_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVPortPairAllocRspInfo::clear_is_ok() {
  is_ok_ = false;
  clear_has_is_ok();
}
inline bool TNVPortPairAllocRspInfo::is_ok() const {
  return is_ok_;
}
inline void TNVPortPairAllocRspInfo::set_is_ok(bool value) {
  set_has_is_ok();
  is_ok_ = value;
}

// repeated .nv.TNVPortPairInfo port_pair = 2;
inline int TNVPortPairAllocRspInfo::port_pair_size() const {
  return port_pair_.size();
}
inline void TNVPortPairAllocRspInfo::clear_port_pair() {
  port_pair_.Clear();
}
inline const ::nv::TNVPortPairInfo& TNVPortPairAllocRspInfo::port_pair(int index) const {
  return port_pair_.Get(index);
}
inline ::nv::TNVPortPairInfo* TNVPortPairAllocRspInfo::mutable_port_pair(int index) {
  return port_pair_.Mutable(index);
}
inline ::nv::TNVPortPairInfo* TNVPortPairAllocRspInfo::add_port_pair() {
  return port_pair_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVPortPairInfo >&
TNVPortPairAllocRspInfo::port_pair() const {
  return port_pair_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVPortPairInfo >*
TNVPortPairAllocRspInfo::mutable_port_pair() {
  return &port_pair_;
}

// -------------------------------------------------------------------

// TNVPortRangeAllocRspInfo

// optional bool is_ok = 1;
inline bool TNVPortRangeAllocRspInfo::has_is_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVPortRangeAllocRspInfo::set_has_is_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVPortRangeAllocRspInfo::clear_has_is_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVPortRangeAllocRspInfo::clear_is_ok() {
  is_ok_ = false;
  clear_has_is_ok();
}
inline bool TNVPortRangeAllocRspInfo::is_ok() const {
  return is_ok_;
}
inline void TNVPortRangeAllocRspInfo::set_is_ok(bool value) {
  set_has_is_ok();
  is_ok_ = value;
}

// optional uint32 start_port = 2;
inline bool TNVPortRangeAllocRspInfo::has_start_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVPortRangeAllocRspInfo::set_has_start_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVPortRangeAllocRspInfo::clear_has_start_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVPortRangeAllocRspInfo::clear_start_port() {
  start_port_ = 0u;
  clear_has_start_port();
}
inline ::google::protobuf::uint32 TNVPortRangeAllocRspInfo::start_port() const {
  return start_port_;
}
inline void TNVPortRangeAllocRspInfo::set_start_port(::google::protobuf::uint32 value) {
  set_has_start_port();
  start_port_ = value;
}

// optional uint32 end_port = 3;
inline bool TNVPortRangeAllocRspInfo::has_end_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVPortRangeAllocRspInfo::set_has_end_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVPortRangeAllocRspInfo::clear_has_end_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVPortRangeAllocRspInfo::clear_end_port() {
  end_port_ = 0u;
  clear_has_end_port();
}
inline ::google::protobuf::uint32 TNVPortRangeAllocRspInfo::end_port() const {
  return end_port_;
}
inline void TNVPortRangeAllocRspInfo::set_end_port(::google::protobuf::uint32 value) {
  set_has_end_port();
  end_port_ = value;
}

// optional string describe = 4;
inline bool TNVPortRangeAllocRspInfo::has_describe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVPortRangeAllocRspInfo::set_has_describe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVPortRangeAllocRspInfo::clear_has_describe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVPortRangeAllocRspInfo::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& TNVPortRangeAllocRspInfo::describe() const {
  return *describe_;
}
inline void TNVPortRangeAllocRspInfo::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TNVPortRangeAllocRspInfo::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void TNVPortRangeAllocRspInfo::set_describe(const char* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVPortRangeAllocRspInfo::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* TNVPortRangeAllocRspInfo::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVPortRangeAllocRspInfo::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVPortCfg

// optional bool is_used = 1;
inline bool TNVPortCfg::has_is_used() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVPortCfg::set_has_is_used() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVPortCfg::clear_has_is_used() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVPortCfg::clear_is_used() {
  is_used_ = false;
  clear_has_is_used();
}
inline bool TNVPortCfg::is_used() const {
  return is_used_;
}
inline void TNVPortCfg::set_is_used(bool value) {
  set_has_is_used();
  is_used_ = value;
}

// optional uint32 tcp_base_port = 2;
inline bool TNVPortCfg::has_tcp_base_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVPortCfg::set_has_tcp_base_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVPortCfg::clear_has_tcp_base_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVPortCfg::clear_tcp_base_port() {
  tcp_base_port_ = 0u;
  clear_has_tcp_base_port();
}
inline ::google::protobuf::uint32 TNVPortCfg::tcp_base_port() const {
  return tcp_base_port_;
}
inline void TNVPortCfg::set_tcp_base_port(::google::protobuf::uint32 value) {
  set_has_tcp_base_port();
  tcp_base_port_ = value;
}

// optional uint32 udp_base_port = 3;
inline bool TNVPortCfg::has_udp_base_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVPortCfg::set_has_udp_base_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVPortCfg::clear_has_udp_base_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVPortCfg::clear_udp_base_port() {
  udp_base_port_ = 0u;
  clear_has_udp_base_port();
}
inline ::google::protobuf::uint32 TNVPortCfg::udp_base_port() const {
  return udp_base_port_;
}
inline void TNVPortCfg::set_udp_base_port(::google::protobuf::uint32 value) {
  set_has_udp_base_port();
  udp_base_port_ = value;
}

// -------------------------------------------------------------------

// TNVAPSSvrAddr

// optional string Domain = 1;
inline bool TNVAPSSvrAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVAPSSvrAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVAPSSvrAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVAPSSvrAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TNVAPSSvrAddr::domain() const {
  return *domain_;
}
inline void TNVAPSSvrAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVAPSSvrAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVAPSSvrAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVAPSSvrAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TNVAPSSvrAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVAPSSvrAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 aps_login_ip = 2;
inline bool TNVAPSSvrAddr::has_aps_login_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVAPSSvrAddr::set_has_aps_login_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVAPSSvrAddr::clear_has_aps_login_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVAPSSvrAddr::clear_aps_login_ip() {
  aps_login_ip_ = 0u;
  clear_has_aps_login_ip();
}
inline ::google::protobuf::uint32 TNVAPSSvrAddr::aps_login_ip() const {
  return aps_login_ip_;
}
inline void TNVAPSSvrAddr::set_aps_login_ip(::google::protobuf::uint32 value) {
  set_has_aps_login_ip();
  aps_login_ip_ = value;
}

// -------------------------------------------------------------------

// TNVAPSAddrFromSrv

// repeated .nv.TNVAPSSvrAddr srv_list = 1;
inline int TNVAPSAddrFromSrv::srv_list_size() const {
  return srv_list_.size();
}
inline void TNVAPSAddrFromSrv::clear_srv_list() {
  srv_list_.Clear();
}
inline const ::nv::TNVAPSSvrAddr& TNVAPSAddrFromSrv::srv_list(int index) const {
  return srv_list_.Get(index);
}
inline ::nv::TNVAPSSvrAddr* TNVAPSAddrFromSrv::mutable_srv_list(int index) {
  return srv_list_.Mutable(index);
}
inline ::nv::TNVAPSSvrAddr* TNVAPSAddrFromSrv::add_srv_list() {
  return srv_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVAPSSvrAddr >&
TNVAPSAddrFromSrv::srv_list() const {
  return srv_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVAPSSvrAddr >*
TNVAPSAddrFromSrv::mutable_srv_list() {
  return &srv_list_;
}

// -------------------------------------------------------------------

// TNVServerAddress

// optional string Domain = 1;
inline bool TNVServerAddress::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVServerAddress::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVServerAddress::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVServerAddress::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TNVServerAddress::domain() const {
  return *domain_;
}
inline void TNVServerAddress::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVServerAddress::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVServerAddress::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVServerAddress::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TNVServerAddress::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVServerAddress::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TNVServerAddress::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVServerAddress::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVServerAddress::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVServerAddress::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TNVServerAddress::ip() const {
  return ip_;
}
inline void TNVServerAddress::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TNVServerAddress::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVServerAddress::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVServerAddress::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVServerAddress::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TNVServerAddress::port() const {
  return port_;
}
inline void TNVServerAddress::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TNVTerminalInfo

// optional .nv.EmNvModel model = 1;
inline bool TNVTerminalInfo::has_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVTerminalInfo::set_has_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVTerminalInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVTerminalInfo::clear_model() {
  model_ = 0;
  clear_has_model();
}
inline ::nv::EmNvModel TNVTerminalInfo::model() const {
  return static_cast< ::nv::EmNvModel >(model_);
}
inline void TNVTerminalInfo::set_model(::nv::EmNvModel value) {
  assert(::nv::EmNvModel_IsValid(value));
  set_has_model();
  model_ = value;
}

// optional string model_name = 2;
inline bool TNVTerminalInfo::has_model_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVTerminalInfo::set_has_model_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVTerminalInfo::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVTerminalInfo::clear_model_name() {
  if (model_name_ != &::google::protobuf::internal::kEmptyString) {
    model_name_->clear();
  }
  clear_has_model_name();
}
inline const ::std::string& TNVTerminalInfo::model_name() const {
  return *model_name_;
}
inline void TNVTerminalInfo::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void TNVTerminalInfo::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void TNVTerminalInfo::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVTerminalInfo::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    model_name_ = new ::std::string;
  }
  return model_name_;
}
inline ::std::string* TNVTerminalInfo::release_model_name() {
  clear_has_model_name();
  if (model_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVTerminalInfo::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != &::google::protobuf::internal::kEmptyString) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hardware_ver = 3;
inline bool TNVTerminalInfo::has_hardware_ver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVTerminalInfo::set_has_hardware_ver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVTerminalInfo::clear_has_hardware_ver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVTerminalInfo::clear_hardware_ver() {
  if (hardware_ver_ != &::google::protobuf::internal::kEmptyString) {
    hardware_ver_->clear();
  }
  clear_has_hardware_ver();
}
inline const ::std::string& TNVTerminalInfo::hardware_ver() const {
  return *hardware_ver_;
}
inline void TNVTerminalInfo::set_hardware_ver(const ::std::string& value) {
  set_has_hardware_ver();
  if (hardware_ver_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ver_ = new ::std::string;
  }
  hardware_ver_->assign(value);
}
inline void TNVTerminalInfo::set_hardware_ver(const char* value) {
  set_has_hardware_ver();
  if (hardware_ver_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ver_ = new ::std::string;
  }
  hardware_ver_->assign(value);
}
inline void TNVTerminalInfo::set_hardware_ver(const char* value, size_t size) {
  set_has_hardware_ver();
  if (hardware_ver_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ver_ = new ::std::string;
  }
  hardware_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVTerminalInfo::mutable_hardware_ver() {
  set_has_hardware_ver();
  if (hardware_ver_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ver_ = new ::std::string;
  }
  return hardware_ver_;
}
inline ::std::string* TNVTerminalInfo::release_hardware_ver() {
  clear_has_hardware_ver();
  if (hardware_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hardware_ver_;
    hardware_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVTerminalInfo::set_allocated_hardware_ver(::std::string* hardware_ver) {
  if (hardware_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete hardware_ver_;
  }
  if (hardware_ver) {
    set_has_hardware_ver();
    hardware_ver_ = hardware_ver;
  } else {
    clear_has_hardware_ver();
    hardware_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string software_ver = 4;
inline bool TNVTerminalInfo::has_software_ver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVTerminalInfo::set_has_software_ver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVTerminalInfo::clear_has_software_ver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVTerminalInfo::clear_software_ver() {
  if (software_ver_ != &::google::protobuf::internal::kEmptyString) {
    software_ver_->clear();
  }
  clear_has_software_ver();
}
inline const ::std::string& TNVTerminalInfo::software_ver() const {
  return *software_ver_;
}
inline void TNVTerminalInfo::set_software_ver(const ::std::string& value) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(value);
}
inline void TNVTerminalInfo::set_software_ver(const char* value) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(value);
}
inline void TNVTerminalInfo::set_software_ver(const char* value, size_t size) {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  software_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVTerminalInfo::mutable_software_ver() {
  set_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    software_ver_ = new ::std::string;
  }
  return software_ver_;
}
inline ::std::string* TNVTerminalInfo::release_software_ver() {
  clear_has_software_ver();
  if (software_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_ver_;
    software_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVTerminalInfo::set_allocated_software_ver(::std::string* software_ver) {
  if (software_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete software_ver_;
  }
  if (software_ver) {
    set_has_software_ver();
    software_ver_ = software_ver;
  } else {
    clear_has_software_ver();
    software_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string oem_info = 5;
inline bool TNVTerminalInfo::has_oem_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVTerminalInfo::set_has_oem_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVTerminalInfo::clear_has_oem_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVTerminalInfo::clear_oem_info() {
  if (oem_info_ != &::google::protobuf::internal::kEmptyString) {
    oem_info_->clear();
  }
  clear_has_oem_info();
}
inline const ::std::string& TNVTerminalInfo::oem_info() const {
  return *oem_info_;
}
inline void TNVTerminalInfo::set_oem_info(const ::std::string& value) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(value);
}
inline void TNVTerminalInfo::set_oem_info(const char* value) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(value);
}
inline void TNVTerminalInfo::set_oem_info(const char* value, size_t size) {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  oem_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVTerminalInfo::mutable_oem_info() {
  set_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    oem_info_ = new ::std::string;
  }
  return oem_info_;
}
inline ::std::string* TNVTerminalInfo::release_oem_info() {
  clear_has_oem_info();
  if (oem_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oem_info_;
    oem_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVTerminalInfo::set_allocated_oem_info(::std::string* oem_info) {
  if (oem_info_ != &::google::protobuf::internal::kEmptyString) {
    delete oem_info_;
  }
  if (oem_info) {
    set_has_oem_info();
    oem_info_ = oem_info;
  } else {
    clear_has_oem_info();
    oem_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fpga1_ver = 6;
inline bool TNVTerminalInfo::has_fpga1_ver() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVTerminalInfo::set_has_fpga1_ver() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVTerminalInfo::clear_has_fpga1_ver() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVTerminalInfo::clear_fpga1_ver() {
  if (fpga1_ver_ != &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_->clear();
  }
  clear_has_fpga1_ver();
}
inline const ::std::string& TNVTerminalInfo::fpga1_ver() const {
  return *fpga1_ver_;
}
inline void TNVTerminalInfo::set_fpga1_ver(const ::std::string& value) {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  fpga1_ver_->assign(value);
}
inline void TNVTerminalInfo::set_fpga1_ver(const char* value) {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  fpga1_ver_->assign(value);
}
inline void TNVTerminalInfo::set_fpga1_ver(const char* value, size_t size) {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  fpga1_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVTerminalInfo::mutable_fpga1_ver() {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  return fpga1_ver_;
}
inline ::std::string* TNVTerminalInfo::release_fpga1_ver() {
  clear_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fpga1_ver_;
    fpga1_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVTerminalInfo::set_allocated_fpga1_ver(::std::string* fpga1_ver) {
  if (fpga1_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete fpga1_ver_;
  }
  if (fpga1_ver) {
    set_has_fpga1_ver();
    fpga1_ver_ = fpga1_ver;
  } else {
    clear_has_fpga1_ver();
    fpga1_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fpga2_ver = 7;
inline bool TNVTerminalInfo::has_fpga2_ver() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVTerminalInfo::set_has_fpga2_ver() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVTerminalInfo::clear_has_fpga2_ver() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVTerminalInfo::clear_fpga2_ver() {
  if (fpga2_ver_ != &::google::protobuf::internal::kEmptyString) {
    fpga2_ver_->clear();
  }
  clear_has_fpga2_ver();
}
inline const ::std::string& TNVTerminalInfo::fpga2_ver() const {
  return *fpga2_ver_;
}
inline void TNVTerminalInfo::set_fpga2_ver(const ::std::string& value) {
  set_has_fpga2_ver();
  if (fpga2_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga2_ver_ = new ::std::string;
  }
  fpga2_ver_->assign(value);
}
inline void TNVTerminalInfo::set_fpga2_ver(const char* value) {
  set_has_fpga2_ver();
  if (fpga2_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga2_ver_ = new ::std::string;
  }
  fpga2_ver_->assign(value);
}
inline void TNVTerminalInfo::set_fpga2_ver(const char* value, size_t size) {
  set_has_fpga2_ver();
  if (fpga2_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga2_ver_ = new ::std::string;
  }
  fpga2_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVTerminalInfo::mutable_fpga2_ver() {
  set_has_fpga2_ver();
  if (fpga2_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga2_ver_ = new ::std::string;
  }
  return fpga2_ver_;
}
inline ::std::string* TNVTerminalInfo::release_fpga2_ver() {
  clear_has_fpga2_ver();
  if (fpga2_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fpga2_ver_;
    fpga2_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVTerminalInfo::set_allocated_fpga2_ver(::std::string* fpga2_ver) {
  if (fpga2_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete fpga2_ver_;
  }
  if (fpga2_ver) {
    set_has_fpga2_ver();
    fpga2_ver_ = fpga2_ver;
  } else {
    clear_has_fpga2_ver();
    fpga2_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cpld_ver = 8;
inline bool TNVTerminalInfo::has_cpld_ver() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVTerminalInfo::set_has_cpld_ver() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVTerminalInfo::clear_has_cpld_ver() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVTerminalInfo::clear_cpld_ver() {
  if (cpld_ver_ != &::google::protobuf::internal::kEmptyString) {
    cpld_ver_->clear();
  }
  clear_has_cpld_ver();
}
inline const ::std::string& TNVTerminalInfo::cpld_ver() const {
  return *cpld_ver_;
}
inline void TNVTerminalInfo::set_cpld_ver(const ::std::string& value) {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  cpld_ver_->assign(value);
}
inline void TNVTerminalInfo::set_cpld_ver(const char* value) {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  cpld_ver_->assign(value);
}
inline void TNVTerminalInfo::set_cpld_ver(const char* value, size_t size) {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  cpld_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVTerminalInfo::mutable_cpld_ver() {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  return cpld_ver_;
}
inline ::std::string* TNVTerminalInfo::release_cpld_ver() {
  clear_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpld_ver_;
    cpld_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVTerminalInfo::set_allocated_cpld_ver(::std::string* cpld_ver) {
  if (cpld_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete cpld_ver_;
  }
  if (cpld_ver) {
    set_has_cpld_ver();
    cpld_ver_ = cpld_ver;
  } else {
    clear_has_cpld_ver();
    cpld_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string serial_num = 9;
inline bool TNVTerminalInfo::has_serial_num() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVTerminalInfo::set_has_serial_num() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVTerminalInfo::clear_has_serial_num() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVTerminalInfo::clear_serial_num() {
  if (serial_num_ != &::google::protobuf::internal::kEmptyString) {
    serial_num_->clear();
  }
  clear_has_serial_num();
}
inline const ::std::string& TNVTerminalInfo::serial_num() const {
  return *serial_num_;
}
inline void TNVTerminalInfo::set_serial_num(const ::std::string& value) {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  serial_num_->assign(value);
}
inline void TNVTerminalInfo::set_serial_num(const char* value) {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  serial_num_->assign(value);
}
inline void TNVTerminalInfo::set_serial_num(const char* value, size_t size) {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  serial_num_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVTerminalInfo::mutable_serial_num() {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  return serial_num_;
}
inline ::std::string* TNVTerminalInfo::release_serial_num() {
  clear_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_num_;
    serial_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVTerminalInfo::set_allocated_serial_num(::std::string* serial_num) {
  if (serial_num_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_num_;
  }
  if (serial_num) {
    set_has_serial_num();
    serial_num_ = serial_num;
  } else {
    clear_has_serial_num();
    serial_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string infrared_ver = 10;
inline bool TNVTerminalInfo::has_infrared_ver() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TNVTerminalInfo::set_has_infrared_ver() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TNVTerminalInfo::clear_has_infrared_ver() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TNVTerminalInfo::clear_infrared_ver() {
  if (infrared_ver_ != &::google::protobuf::internal::kEmptyString) {
    infrared_ver_->clear();
  }
  clear_has_infrared_ver();
}
inline const ::std::string& TNVTerminalInfo::infrared_ver() const {
  return *infrared_ver_;
}
inline void TNVTerminalInfo::set_infrared_ver(const ::std::string& value) {
  set_has_infrared_ver();
  if (infrared_ver_ == &::google::protobuf::internal::kEmptyString) {
    infrared_ver_ = new ::std::string;
  }
  infrared_ver_->assign(value);
}
inline void TNVTerminalInfo::set_infrared_ver(const char* value) {
  set_has_infrared_ver();
  if (infrared_ver_ == &::google::protobuf::internal::kEmptyString) {
    infrared_ver_ = new ::std::string;
  }
  infrared_ver_->assign(value);
}
inline void TNVTerminalInfo::set_infrared_ver(const char* value, size_t size) {
  set_has_infrared_ver();
  if (infrared_ver_ == &::google::protobuf::internal::kEmptyString) {
    infrared_ver_ = new ::std::string;
  }
  infrared_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVTerminalInfo::mutable_infrared_ver() {
  set_has_infrared_ver();
  if (infrared_ver_ == &::google::protobuf::internal::kEmptyString) {
    infrared_ver_ = new ::std::string;
  }
  return infrared_ver_;
}
inline ::std::string* TNVTerminalInfo::release_infrared_ver() {
  clear_has_infrared_ver();
  if (infrared_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = infrared_ver_;
    infrared_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVTerminalInfo::set_allocated_infrared_ver(::std::string* infrared_ver) {
  if (infrared_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete infrared_ver_;
  }
  if (infrared_ver) {
    set_has_infrared_ver();
    infrared_ver_ = infrared_ver;
  } else {
    clear_has_infrared_ver();
    infrared_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.EmNvSubModel submodel = 11;
inline bool TNVTerminalInfo::has_submodel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TNVTerminalInfo::set_has_submodel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TNVTerminalInfo::clear_has_submodel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TNVTerminalInfo::clear_submodel() {
  submodel_ = 0;
  clear_has_submodel();
}
inline ::nv::EmNvSubModel TNVTerminalInfo::submodel() const {
  return static_cast< ::nv::EmNvSubModel >(submodel_);
}
inline void TNVTerminalInfo::set_submodel(::nv::EmNvSubModel value) {
  assert(::nv::EmNvSubModel_IsValid(value));
  set_has_submodel();
  submodel_ = value;
}

// -------------------------------------------------------------------

// TNVOspSock5Proxy

// optional uint32 proxy_ip = 1;
inline bool TNVOspSock5Proxy::has_proxy_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVOspSock5Proxy::set_has_proxy_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVOspSock5Proxy::clear_has_proxy_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVOspSock5Proxy::clear_proxy_ip() {
  proxy_ip_ = 0u;
  clear_has_proxy_ip();
}
inline ::google::protobuf::uint32 TNVOspSock5Proxy::proxy_ip() const {
  return proxy_ip_;
}
inline void TNVOspSock5Proxy::set_proxy_ip(::google::protobuf::uint32 value) {
  set_has_proxy_ip();
  proxy_ip_ = value;
}

// optional uint32 proxy_port = 2;
inline bool TNVOspSock5Proxy::has_proxy_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVOspSock5Proxy::set_has_proxy_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVOspSock5Proxy::clear_has_proxy_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVOspSock5Proxy::clear_proxy_port() {
  proxy_port_ = 0u;
  clear_has_proxy_port();
}
inline ::google::protobuf::uint32 TNVOspSock5Proxy::proxy_port() const {
  return proxy_port_;
}
inline void TNVOspSock5Proxy::set_proxy_port(::google::protobuf::uint32 value) {
  set_has_proxy_port();
  proxy_port_ = value;
}

// optional uint32 authen_num = 3;
inline bool TNVOspSock5Proxy::has_authen_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVOspSock5Proxy::set_has_authen_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVOspSock5Proxy::clear_has_authen_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVOspSock5Proxy::clear_authen_num() {
  authen_num_ = 0u;
  clear_has_authen_num();
}
inline ::google::protobuf::uint32 TNVOspSock5Proxy::authen_num() const {
  return authen_num_;
}
inline void TNVOspSock5Proxy::set_authen_num(::google::protobuf::uint32 value) {
  set_has_authen_num();
  authen_num_ = value;
}

// optional string authen_method = 4;
inline bool TNVOspSock5Proxy::has_authen_method() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVOspSock5Proxy::set_has_authen_method() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVOspSock5Proxy::clear_has_authen_method() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVOspSock5Proxy::clear_authen_method() {
  if (authen_method_ != &::google::protobuf::internal::kEmptyString) {
    authen_method_->clear();
  }
  clear_has_authen_method();
}
inline const ::std::string& TNVOspSock5Proxy::authen_method() const {
  return *authen_method_;
}
inline void TNVOspSock5Proxy::set_authen_method(const ::std::string& value) {
  set_has_authen_method();
  if (authen_method_ == &::google::protobuf::internal::kEmptyString) {
    authen_method_ = new ::std::string;
  }
  authen_method_->assign(value);
}
inline void TNVOspSock5Proxy::set_authen_method(const char* value) {
  set_has_authen_method();
  if (authen_method_ == &::google::protobuf::internal::kEmptyString) {
    authen_method_ = new ::std::string;
  }
  authen_method_->assign(value);
}
inline void TNVOspSock5Proxy::set_authen_method(const char* value, size_t size) {
  set_has_authen_method();
  if (authen_method_ == &::google::protobuf::internal::kEmptyString) {
    authen_method_ = new ::std::string;
  }
  authen_method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVOspSock5Proxy::mutable_authen_method() {
  set_has_authen_method();
  if (authen_method_ == &::google::protobuf::internal::kEmptyString) {
    authen_method_ = new ::std::string;
  }
  return authen_method_;
}
inline ::std::string* TNVOspSock5Proxy::release_authen_method() {
  clear_has_authen_method();
  if (authen_method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authen_method_;
    authen_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVOspSock5Proxy::set_allocated_authen_method(::std::string* authen_method) {
  if (authen_method_ != &::google::protobuf::internal::kEmptyString) {
    delete authen_method_;
  }
  if (authen_method) {
    set_has_authen_method();
    authen_method_ = authen_method;
  } else {
    clear_has_authen_method();
    authen_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_name = 5;
inline bool TNVOspSock5Proxy::has_user_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVOspSock5Proxy::set_has_user_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVOspSock5Proxy::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVOspSock5Proxy::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TNVOspSock5Proxy::user_name() const {
  return *user_name_;
}
inline void TNVOspSock5Proxy::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVOspSock5Proxy::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVOspSock5Proxy::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVOspSock5Proxy::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TNVOspSock5Proxy::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVOspSock5Proxy::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 6;
inline bool TNVOspSock5Proxy::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVOspSock5Proxy::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVOspSock5Proxy::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVOspSock5Proxy::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TNVOspSock5Proxy::password() const {
  return *password_;
}
inline void TNVOspSock5Proxy::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVOspSock5Proxy::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVOspSock5Proxy::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVOspSock5Proxy::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TNVOspSock5Proxy::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVOspSock5Proxy::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVUpgradeNetParam

// optional string server_ip = 1;
inline bool TNVUpgradeNetParam::has_server_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUpgradeNetParam::set_has_server_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUpgradeNetParam::clear_has_server_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUpgradeNetParam::clear_server_ip() {
  if (server_ip_ != &::google::protobuf::internal::kEmptyString) {
    server_ip_->clear();
  }
  clear_has_server_ip();
}
inline const ::std::string& TNVUpgradeNetParam::server_ip() const {
  return *server_ip_;
}
inline void TNVUpgradeNetParam::set_server_ip(const ::std::string& value) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(value);
}
inline void TNVUpgradeNetParam::set_server_ip(const char* value) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(value);
}
inline void TNVUpgradeNetParam::set_server_ip(const char* value, size_t size) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeNetParam::mutable_server_ip() {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  return server_ip_;
}
inline ::std::string* TNVUpgradeNetParam::release_server_ip() {
  clear_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_ip_;
    server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeNetParam::set_allocated_server_ip(::std::string* server_ip) {
  if (server_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete server_ip_;
  }
  if (server_ip) {
    set_has_server_ip();
    server_ip_ = server_ip;
  } else {
    clear_has_server_ip();
    server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 2;
inline bool TNVUpgradeNetParam::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUpgradeNetParam::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUpgradeNetParam::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUpgradeNetParam::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TNVUpgradeNetParam::port() const {
  return port_;
}
inline void TNVUpgradeNetParam::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional bool is_proxy_used = 3;
inline bool TNVUpgradeNetParam::has_is_proxy_used() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVUpgradeNetParam::set_has_is_proxy_used() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVUpgradeNetParam::clear_has_is_proxy_used() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVUpgradeNetParam::clear_is_proxy_used() {
  is_proxy_used_ = false;
  clear_has_is_proxy_used();
}
inline bool TNVUpgradeNetParam::is_proxy_used() const {
  return is_proxy_used_;
}
inline void TNVUpgradeNetParam::set_is_proxy_used(bool value) {
  set_has_is_proxy_used();
  is_proxy_used_ = value;
}

// optional .nv.TNVOspSock5Proxy proxy_info = 4;
inline bool TNVUpgradeNetParam::has_proxy_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVUpgradeNetParam::set_has_proxy_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVUpgradeNetParam::clear_has_proxy_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVUpgradeNetParam::clear_proxy_info() {
  if (proxy_info_ != NULL) proxy_info_->::nv::TNVOspSock5Proxy::Clear();
  clear_has_proxy_info();
}
inline const ::nv::TNVOspSock5Proxy& TNVUpgradeNetParam::proxy_info() const {
  return proxy_info_ != NULL ? *proxy_info_ : *default_instance_->proxy_info_;
}
inline ::nv::TNVOspSock5Proxy* TNVUpgradeNetParam::mutable_proxy_info() {
  set_has_proxy_info();
  if (proxy_info_ == NULL) proxy_info_ = new ::nv::TNVOspSock5Proxy;
  return proxy_info_;
}
inline ::nv::TNVOspSock5Proxy* TNVUpgradeNetParam::release_proxy_info() {
  clear_has_proxy_info();
  ::nv::TNVOspSock5Proxy* temp = proxy_info_;
  proxy_info_ = NULL;
  return temp;
}
inline void TNVUpgradeNetParam::set_allocated_proxy_info(::nv::TNVOspSock5Proxy* proxy_info) {
  delete proxy_info_;
  proxy_info_ = proxy_info;
  if (proxy_info) {
    set_has_proxy_info();
  } else {
    clear_has_proxy_info();
  }
}

// optional string domain = 5;
inline bool TNVUpgradeNetParam::has_domain() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVUpgradeNetParam::set_has_domain() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVUpgradeNetParam::clear_has_domain() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVUpgradeNetParam::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TNVUpgradeNetParam::domain() const {
  return *domain_;
}
inline void TNVUpgradeNetParam::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVUpgradeNetParam::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVUpgradeNetParam::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeNetParam::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TNVUpgradeNetParam::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeNetParam::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVUpgradeDeviceInfo

// optional .nv.EmNvDevRegUpdateSer dev_type = 1;
inline bool TNVUpgradeDeviceInfo::has_dev_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUpgradeDeviceInfo::set_has_dev_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUpgradeDeviceInfo::clear_has_dev_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUpgradeDeviceInfo::clear_dev_type() {
  dev_type_ = 0;
  clear_has_dev_type();
}
inline ::nv::EmNvDevRegUpdateSer TNVUpgradeDeviceInfo::dev_type() const {
  return static_cast< ::nv::EmNvDevRegUpdateSer >(dev_type_);
}
inline void TNVUpgradeDeviceInfo::set_dev_type(::nv::EmNvDevRegUpdateSer value) {
  assert(::nv::EmNvDevRegUpdateSer_IsValid(value));
  set_has_dev_type();
  dev_type_ = value;
}

// optional string oem_mark = 2;
inline bool TNVUpgradeDeviceInfo::has_oem_mark() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUpgradeDeviceInfo::set_has_oem_mark() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUpgradeDeviceInfo::clear_has_oem_mark() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUpgradeDeviceInfo::clear_oem_mark() {
  if (oem_mark_ != &::google::protobuf::internal::kEmptyString) {
    oem_mark_->clear();
  }
  clear_has_oem_mark();
}
inline const ::std::string& TNVUpgradeDeviceInfo::oem_mark() const {
  return *oem_mark_;
}
inline void TNVUpgradeDeviceInfo::set_oem_mark(const ::std::string& value) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(value);
}
inline void TNVUpgradeDeviceInfo::set_oem_mark(const char* value) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(value);
}
inline void TNVUpgradeDeviceInfo::set_oem_mark(const char* value, size_t size) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeDeviceInfo::mutable_oem_mark() {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  return oem_mark_;
}
inline ::std::string* TNVUpgradeDeviceInfo::release_oem_mark() {
  clear_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oem_mark_;
    oem_mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeDeviceInfo::set_allocated_oem_mark(::std::string* oem_mark) {
  if (oem_mark_ != &::google::protobuf::internal::kEmptyString) {
    delete oem_mark_;
  }
  if (oem_mark) {
    set_has_oem_mark();
    oem_mark_ = oem_mark;
  } else {
    clear_has_oem_mark();
    oem_mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164 = 3;
inline bool TNVUpgradeDeviceInfo::has_e164() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVUpgradeDeviceInfo::set_has_e164() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVUpgradeDeviceInfo::clear_has_e164() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVUpgradeDeviceInfo::clear_e164() {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    e164_->clear();
  }
  clear_has_e164();
}
inline const ::std::string& TNVUpgradeDeviceInfo::e164() const {
  return *e164_;
}
inline void TNVUpgradeDeviceInfo::set_e164(const ::std::string& value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TNVUpgradeDeviceInfo::set_e164(const char* value) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(value);
}
inline void TNVUpgradeDeviceInfo::set_e164(const char* value, size_t size) {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeDeviceInfo::mutable_e164() {
  set_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    e164_ = new ::std::string;
  }
  return e164_;
}
inline ::std::string* TNVUpgradeDeviceInfo::release_e164() {
  clear_has_e164();
  if (e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_;
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeDeviceInfo::set_allocated_e164(::std::string* e164) {
  if (e164_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_;
  }
  if (e164) {
    set_has_e164();
    e164_ = e164;
  } else {
    clear_has_e164();
    e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cur_soft_ver = 4;
inline bool TNVUpgradeDeviceInfo::has_cur_soft_ver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVUpgradeDeviceInfo::set_has_cur_soft_ver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVUpgradeDeviceInfo::clear_has_cur_soft_ver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVUpgradeDeviceInfo::clear_cur_soft_ver() {
  if (cur_soft_ver_ != &::google::protobuf::internal::kEmptyString) {
    cur_soft_ver_->clear();
  }
  clear_has_cur_soft_ver();
}
inline const ::std::string& TNVUpgradeDeviceInfo::cur_soft_ver() const {
  return *cur_soft_ver_;
}
inline void TNVUpgradeDeviceInfo::set_cur_soft_ver(const ::std::string& value) {
  set_has_cur_soft_ver();
  if (cur_soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    cur_soft_ver_ = new ::std::string;
  }
  cur_soft_ver_->assign(value);
}
inline void TNVUpgradeDeviceInfo::set_cur_soft_ver(const char* value) {
  set_has_cur_soft_ver();
  if (cur_soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    cur_soft_ver_ = new ::std::string;
  }
  cur_soft_ver_->assign(value);
}
inline void TNVUpgradeDeviceInfo::set_cur_soft_ver(const char* value, size_t size) {
  set_has_cur_soft_ver();
  if (cur_soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    cur_soft_ver_ = new ::std::string;
  }
  cur_soft_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeDeviceInfo::mutable_cur_soft_ver() {
  set_has_cur_soft_ver();
  if (cur_soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    cur_soft_ver_ = new ::std::string;
  }
  return cur_soft_ver_;
}
inline ::std::string* TNVUpgradeDeviceInfo::release_cur_soft_ver() {
  clear_has_cur_soft_ver();
  if (cur_soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cur_soft_ver_;
    cur_soft_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeDeviceInfo::set_allocated_cur_soft_ver(::std::string* cur_soft_ver) {
  if (cur_soft_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete cur_soft_ver_;
  }
  if (cur_soft_ver) {
    set_has_cur_soft_ver();
    cur_soft_ver_ = cur_soft_ver;
  } else {
    clear_has_cur_soft_ver();
    cur_soft_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 dev_ip = 5;
inline bool TNVUpgradeDeviceInfo::has_dev_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVUpgradeDeviceInfo::set_has_dev_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVUpgradeDeviceInfo::clear_has_dev_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVUpgradeDeviceInfo::clear_dev_ip() {
  dev_ip_ = 0u;
  clear_has_dev_ip();
}
inline ::google::protobuf::uint32 TNVUpgradeDeviceInfo::dev_ip() const {
  return dev_ip_;
}
inline void TNVUpgradeDeviceInfo::set_dev_ip(::google::protobuf::uint32 value) {
  set_has_dev_ip();
  dev_ip_ = value;
}

// -------------------------------------------------------------------

// TNVUpgradeClientInfo

// optional .nv.TNVUpgradeNetParam server_info = 1;
inline bool TNVUpgradeClientInfo::has_server_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUpgradeClientInfo::set_has_server_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUpgradeClientInfo::clear_has_server_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUpgradeClientInfo::clear_server_info() {
  if (server_info_ != NULL) server_info_->::nv::TNVUpgradeNetParam::Clear();
  clear_has_server_info();
}
inline const ::nv::TNVUpgradeNetParam& TNVUpgradeClientInfo::server_info() const {
  return server_info_ != NULL ? *server_info_ : *default_instance_->server_info_;
}
inline ::nv::TNVUpgradeNetParam* TNVUpgradeClientInfo::mutable_server_info() {
  set_has_server_info();
  if (server_info_ == NULL) server_info_ = new ::nv::TNVUpgradeNetParam;
  return server_info_;
}
inline ::nv::TNVUpgradeNetParam* TNVUpgradeClientInfo::release_server_info() {
  clear_has_server_info();
  ::nv::TNVUpgradeNetParam* temp = server_info_;
  server_info_ = NULL;
  return temp;
}
inline void TNVUpgradeClientInfo::set_allocated_server_info(::nv::TNVUpgradeNetParam* server_info) {
  delete server_info_;
  server_info_ = server_info;
  if (server_info) {
    set_has_server_info();
  } else {
    clear_has_server_info();
  }
}

// optional .nv.TNVUpgradeDeviceInfo dev_info = 2;
inline bool TNVUpgradeClientInfo::has_dev_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUpgradeClientInfo::set_has_dev_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUpgradeClientInfo::clear_has_dev_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUpgradeClientInfo::clear_dev_info() {
  if (dev_info_ != NULL) dev_info_->::nv::TNVUpgradeDeviceInfo::Clear();
  clear_has_dev_info();
}
inline const ::nv::TNVUpgradeDeviceInfo& TNVUpgradeClientInfo::dev_info() const {
  return dev_info_ != NULL ? *dev_info_ : *default_instance_->dev_info_;
}
inline ::nv::TNVUpgradeDeviceInfo* TNVUpgradeClientInfo::mutable_dev_info() {
  set_has_dev_info();
  if (dev_info_ == NULL) dev_info_ = new ::nv::TNVUpgradeDeviceInfo;
  return dev_info_;
}
inline ::nv::TNVUpgradeDeviceInfo* TNVUpgradeClientInfo::release_dev_info() {
  clear_has_dev_info();
  ::nv::TNVUpgradeDeviceInfo* temp = dev_info_;
  dev_info_ = NULL;
  return temp;
}
inline void TNVUpgradeClientInfo::set_allocated_dev_info(::nv::TNVUpgradeDeviceInfo* dev_info) {
  delete dev_info_;
  dev_info_ = dev_info;
  if (dev_info) {
    set_has_dev_info();
  } else {
    clear_has_dev_info();
  }
}

// -------------------------------------------------------------------

// TNVUpgradeGrayRange

// optional string moid_list = 1;
inline bool TNVUpgradeGrayRange::has_moid_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUpgradeGrayRange::set_has_moid_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUpgradeGrayRange::clear_has_moid_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUpgradeGrayRange::clear_moid_list() {
  if (moid_list_ != &::google::protobuf::internal::kEmptyString) {
    moid_list_->clear();
  }
  clear_has_moid_list();
}
inline const ::std::string& TNVUpgradeGrayRange::moid_list() const {
  return *moid_list_;
}
inline void TNVUpgradeGrayRange::set_moid_list(const ::std::string& value) {
  set_has_moid_list();
  if (moid_list_ == &::google::protobuf::internal::kEmptyString) {
    moid_list_ = new ::std::string;
  }
  moid_list_->assign(value);
}
inline void TNVUpgradeGrayRange::set_moid_list(const char* value) {
  set_has_moid_list();
  if (moid_list_ == &::google::protobuf::internal::kEmptyString) {
    moid_list_ = new ::std::string;
  }
  moid_list_->assign(value);
}
inline void TNVUpgradeGrayRange::set_moid_list(const char* value, size_t size) {
  set_has_moid_list();
  if (moid_list_ == &::google::protobuf::internal::kEmptyString) {
    moid_list_ = new ::std::string;
  }
  moid_list_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeGrayRange::mutable_moid_list() {
  set_has_moid_list();
  if (moid_list_ == &::google::protobuf::internal::kEmptyString) {
    moid_list_ = new ::std::string;
  }
  return moid_list_;
}
inline ::std::string* TNVUpgradeGrayRange::release_moid_list() {
  clear_has_moid_list();
  if (moid_list_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moid_list_;
    moid_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeGrayRange::set_allocated_moid_list(::std::string* moid_list) {
  if (moid_list_ != &::google::protobuf::internal::kEmptyString) {
    delete moid_list_;
  }
  if (moid_list) {
    set_has_moid_list();
    moid_list_ = moid_list;
  } else {
    clear_has_moid_list();
    moid_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string e164_list = 2;
inline bool TNVUpgradeGrayRange::has_e164_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUpgradeGrayRange::set_has_e164_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUpgradeGrayRange::clear_has_e164_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUpgradeGrayRange::clear_e164_list() {
  if (e164_list_ != &::google::protobuf::internal::kEmptyString) {
    e164_list_->clear();
  }
  clear_has_e164_list();
}
inline const ::std::string& TNVUpgradeGrayRange::e164_list() const {
  return *e164_list_;
}
inline void TNVUpgradeGrayRange::set_e164_list(const ::std::string& value) {
  set_has_e164_list();
  if (e164_list_ == &::google::protobuf::internal::kEmptyString) {
    e164_list_ = new ::std::string;
  }
  e164_list_->assign(value);
}
inline void TNVUpgradeGrayRange::set_e164_list(const char* value) {
  set_has_e164_list();
  if (e164_list_ == &::google::protobuf::internal::kEmptyString) {
    e164_list_ = new ::std::string;
  }
  e164_list_->assign(value);
}
inline void TNVUpgradeGrayRange::set_e164_list(const char* value, size_t size) {
  set_has_e164_list();
  if (e164_list_ == &::google::protobuf::internal::kEmptyString) {
    e164_list_ = new ::std::string;
  }
  e164_list_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeGrayRange::mutable_e164_list() {
  set_has_e164_list();
  if (e164_list_ == &::google::protobuf::internal::kEmptyString) {
    e164_list_ = new ::std::string;
  }
  return e164_list_;
}
inline ::std::string* TNVUpgradeGrayRange::release_e164_list() {
  clear_has_e164_list();
  if (e164_list_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e164_list_;
    e164_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeGrayRange::set_allocated_e164_list(::std::string* e164_list) {
  if (e164_list_ != &::google::protobuf::internal::kEmptyString) {
    delete e164_list_;
  }
  if (e164_list) {
    set_has_e164_list();
    e164_list_ = e164_list;
  } else {
    clear_has_e164_list();
    e164_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVUpgradeVersionInfo

// optional uint32 ver_id = 1;
inline bool TNVUpgradeVersionInfo::has_ver_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUpgradeVersionInfo::set_has_ver_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUpgradeVersionInfo::clear_has_ver_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUpgradeVersionInfo::clear_ver_id() {
  ver_id_ = 0u;
  clear_has_ver_id();
}
inline ::google::protobuf::uint32 TNVUpgradeVersionInfo::ver_id() const {
  return ver_id_;
}
inline void TNVUpgradeVersionInfo::set_ver_id(::google::protobuf::uint32 value) {
  set_has_ver_id();
  ver_id_ = value;
}

// optional string oem_mark = 2;
inline bool TNVUpgradeVersionInfo::has_oem_mark() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUpgradeVersionInfo::set_has_oem_mark() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUpgradeVersionInfo::clear_has_oem_mark() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUpgradeVersionInfo::clear_oem_mark() {
  if (oem_mark_ != &::google::protobuf::internal::kEmptyString) {
    oem_mark_->clear();
  }
  clear_has_oem_mark();
}
inline const ::std::string& TNVUpgradeVersionInfo::oem_mark() const {
  return *oem_mark_;
}
inline void TNVUpgradeVersionInfo::set_oem_mark(const ::std::string& value) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(value);
}
inline void TNVUpgradeVersionInfo::set_oem_mark(const char* value) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(value);
}
inline void TNVUpgradeVersionInfo::set_oem_mark(const char* value, size_t size) {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  oem_mark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeVersionInfo::mutable_oem_mark() {
  set_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    oem_mark_ = new ::std::string;
  }
  return oem_mark_;
}
inline ::std::string* TNVUpgradeVersionInfo::release_oem_mark() {
  clear_has_oem_mark();
  if (oem_mark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oem_mark_;
    oem_mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeVersionInfo::set_allocated_oem_mark(::std::string* oem_mark) {
  if (oem_mark_ != &::google::protobuf::internal::kEmptyString) {
    delete oem_mark_;
  }
  if (oem_mark) {
    set_has_oem_mark();
    oem_mark_ = oem_mark;
  } else {
    clear_has_oem_mark();
    oem_mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dev_Type = 3;
inline bool TNVUpgradeVersionInfo::has_dev_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVUpgradeVersionInfo::set_has_dev_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVUpgradeVersionInfo::clear_has_dev_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVUpgradeVersionInfo::clear_dev_type() {
  if (dev_type_ != &::google::protobuf::internal::kEmptyString) {
    dev_type_->clear();
  }
  clear_has_dev_type();
}
inline const ::std::string& TNVUpgradeVersionInfo::dev_type() const {
  return *dev_type_;
}
inline void TNVUpgradeVersionInfo::set_dev_type(const ::std::string& value) {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  dev_type_->assign(value);
}
inline void TNVUpgradeVersionInfo::set_dev_type(const char* value) {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  dev_type_->assign(value);
}
inline void TNVUpgradeVersionInfo::set_dev_type(const char* value, size_t size) {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  dev_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeVersionInfo::mutable_dev_type() {
  set_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    dev_type_ = new ::std::string;
  }
  return dev_type_;
}
inline ::std::string* TNVUpgradeVersionInfo::release_dev_type() {
  clear_has_dev_type();
  if (dev_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dev_type_;
    dev_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeVersionInfo::set_allocated_dev_type(::std::string* dev_type) {
  if (dev_type_ != &::google::protobuf::internal::kEmptyString) {
    delete dev_type_;
  }
  if (dev_type) {
    set_has_dev_type();
    dev_type_ = dev_type;
  } else {
    clear_has_dev_type();
    dev_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.EmNvUpgradeVerLevel ver_level = 4;
inline bool TNVUpgradeVersionInfo::has_ver_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVUpgradeVersionInfo::set_has_ver_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVUpgradeVersionInfo::clear_has_ver_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVUpgradeVersionInfo::clear_ver_level() {
  ver_level_ = 0;
  clear_has_ver_level();
}
inline ::nv::EmNvUpgradeVerLevel TNVUpgradeVersionInfo::ver_level() const {
  return static_cast< ::nv::EmNvUpgradeVerLevel >(ver_level_);
}
inline void TNVUpgradeVersionInfo::set_ver_level(::nv::EmNvUpgradeVerLevel value) {
  assert(::nv::EmNvUpgradeVerLevel_IsValid(value));
  set_has_ver_level();
  ver_level_ = value;
}

// optional string soft_ver = 5;
inline bool TNVUpgradeVersionInfo::has_soft_ver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVUpgradeVersionInfo::set_has_soft_ver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVUpgradeVersionInfo::clear_has_soft_ver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVUpgradeVersionInfo::clear_soft_ver() {
  if (soft_ver_ != &::google::protobuf::internal::kEmptyString) {
    soft_ver_->clear();
  }
  clear_has_soft_ver();
}
inline const ::std::string& TNVUpgradeVersionInfo::soft_ver() const {
  return *soft_ver_;
}
inline void TNVUpgradeVersionInfo::set_soft_ver(const ::std::string& value) {
  set_has_soft_ver();
  if (soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    soft_ver_ = new ::std::string;
  }
  soft_ver_->assign(value);
}
inline void TNVUpgradeVersionInfo::set_soft_ver(const char* value) {
  set_has_soft_ver();
  if (soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    soft_ver_ = new ::std::string;
  }
  soft_ver_->assign(value);
}
inline void TNVUpgradeVersionInfo::set_soft_ver(const char* value, size_t size) {
  set_has_soft_ver();
  if (soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    soft_ver_ = new ::std::string;
  }
  soft_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeVersionInfo::mutable_soft_ver() {
  set_has_soft_ver();
  if (soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    soft_ver_ = new ::std::string;
  }
  return soft_ver_;
}
inline ::std::string* TNVUpgradeVersionInfo::release_soft_ver() {
  clear_has_soft_ver();
  if (soft_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soft_ver_;
    soft_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeVersionInfo::set_allocated_soft_ver(::std::string* soft_ver) {
  if (soft_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete soft_ver_;
  }
  if (soft_ver) {
    set_has_soft_ver();
    soft_ver_ = soft_ver;
  } else {
    clear_has_soft_ver();
    soft_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ver_notes = 6;
inline bool TNVUpgradeVersionInfo::has_ver_notes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVUpgradeVersionInfo::set_has_ver_notes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVUpgradeVersionInfo::clear_has_ver_notes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVUpgradeVersionInfo::clear_ver_notes() {
  if (ver_notes_ != &::google::protobuf::internal::kEmptyString) {
    ver_notes_->clear();
  }
  clear_has_ver_notes();
}
inline const ::std::string& TNVUpgradeVersionInfo::ver_notes() const {
  return *ver_notes_;
}
inline void TNVUpgradeVersionInfo::set_ver_notes(const ::std::string& value) {
  set_has_ver_notes();
  if (ver_notes_ == &::google::protobuf::internal::kEmptyString) {
    ver_notes_ = new ::std::string;
  }
  ver_notes_->assign(value);
}
inline void TNVUpgradeVersionInfo::set_ver_notes(const char* value) {
  set_has_ver_notes();
  if (ver_notes_ == &::google::protobuf::internal::kEmptyString) {
    ver_notes_ = new ::std::string;
  }
  ver_notes_->assign(value);
}
inline void TNVUpgradeVersionInfo::set_ver_notes(const char* value, size_t size) {
  set_has_ver_notes();
  if (ver_notes_ == &::google::protobuf::internal::kEmptyString) {
    ver_notes_ = new ::std::string;
  }
  ver_notes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeVersionInfo::mutable_ver_notes() {
  set_has_ver_notes();
  if (ver_notes_ == &::google::protobuf::internal::kEmptyString) {
    ver_notes_ = new ::std::string;
  }
  return ver_notes_;
}
inline ::std::string* TNVUpgradeVersionInfo::release_ver_notes() {
  clear_has_ver_notes();
  if (ver_notes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ver_notes_;
    ver_notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeVersionInfo::set_allocated_ver_notes(::std::string* ver_notes) {
  if (ver_notes_ != &::google::protobuf::internal::kEmptyString) {
    delete ver_notes_;
  }
  if (ver_notes) {
    set_has_ver_notes();
    ver_notes_ = ver_notes;
  } else {
    clear_has_ver_notes();
    ver_notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 size = 7;
inline bool TNVUpgradeVersionInfo::has_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVUpgradeVersionInfo::set_has_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVUpgradeVersionInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVUpgradeVersionInfo::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 TNVUpgradeVersionInfo::size() const {
  return size_;
}
inline void TNVUpgradeVersionInfo::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// optional .nv.EmNvUpgradeReleaseAttr ver_attr = 8;
inline bool TNVUpgradeVersionInfo::has_ver_attr() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVUpgradeVersionInfo::set_has_ver_attr() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVUpgradeVersionInfo::clear_has_ver_attr() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVUpgradeVersionInfo::clear_ver_attr() {
  ver_attr_ = 0;
  clear_has_ver_attr();
}
inline ::nv::EmNvUpgradeReleaseAttr TNVUpgradeVersionInfo::ver_attr() const {
  return static_cast< ::nv::EmNvUpgradeReleaseAttr >(ver_attr_);
}
inline void TNVUpgradeVersionInfo::set_ver_attr(::nv::EmNvUpgradeReleaseAttr value) {
  assert(::nv::EmNvUpgradeReleaseAttr_IsValid(value));
  set_has_ver_attr();
  ver_attr_ = value;
}

// optional string file_name = 9;
inline bool TNVUpgradeVersionInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVUpgradeVersionInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVUpgradeVersionInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVUpgradeVersionInfo::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& TNVUpgradeVersionInfo::file_name() const {
  return *file_name_;
}
inline void TNVUpgradeVersionInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TNVUpgradeVersionInfo::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void TNVUpgradeVersionInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeVersionInfo::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* TNVUpgradeVersionInfo::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeVersionInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.TNVUpgradeGrayRange gray_range = 10;
inline bool TNVUpgradeVersionInfo::has_gray_range() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TNVUpgradeVersionInfo::set_has_gray_range() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TNVUpgradeVersionInfo::clear_has_gray_range() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TNVUpgradeVersionInfo::clear_gray_range() {
  if (gray_range_ != NULL) gray_range_->::nv::TNVUpgradeGrayRange::Clear();
  clear_has_gray_range();
}
inline const ::nv::TNVUpgradeGrayRange& TNVUpgradeVersionInfo::gray_range() const {
  return gray_range_ != NULL ? *gray_range_ : *default_instance_->gray_range_;
}
inline ::nv::TNVUpgradeGrayRange* TNVUpgradeVersionInfo::mutable_gray_range() {
  set_has_gray_range();
  if (gray_range_ == NULL) gray_range_ = new ::nv::TNVUpgradeGrayRange;
  return gray_range_;
}
inline ::nv::TNVUpgradeGrayRange* TNVUpgradeVersionInfo::release_gray_range() {
  clear_has_gray_range();
  ::nv::TNVUpgradeGrayRange* temp = gray_range_;
  gray_range_ = NULL;
  return temp;
}
inline void TNVUpgradeVersionInfo::set_allocated_gray_range(::nv::TNVUpgradeGrayRange* gray_range) {
  delete gray_range_;
  gray_range_ = gray_range;
  if (gray_range) {
    set_has_gray_range();
  } else {
    clear_has_gray_range();
  }
}

// -------------------------------------------------------------------

// TNVUpgradeVersionInfoList

// optional bool is_get_recommend = 1;
inline bool TNVUpgradeVersionInfoList::has_is_get_recommend() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUpgradeVersionInfoList::set_has_is_get_recommend() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUpgradeVersionInfoList::clear_has_is_get_recommend() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUpgradeVersionInfoList::clear_is_get_recommend() {
  is_get_recommend_ = false;
  clear_has_is_get_recommend();
}
inline bool TNVUpgradeVersionInfoList::is_get_recommend() const {
  return is_get_recommend_;
}
inline void TNVUpgradeVersionInfoList::set_is_get_recommend(bool value) {
  set_has_is_get_recommend();
  is_get_recommend_ = value;
}

// repeated .nv.TNVUpgradeVersionInfo ver_list = 2;
inline int TNVUpgradeVersionInfoList::ver_list_size() const {
  return ver_list_.size();
}
inline void TNVUpgradeVersionInfoList::clear_ver_list() {
  ver_list_.Clear();
}
inline const ::nv::TNVUpgradeVersionInfo& TNVUpgradeVersionInfoList::ver_list(int index) const {
  return ver_list_.Get(index);
}
inline ::nv::TNVUpgradeVersionInfo* TNVUpgradeVersionInfoList::mutable_ver_list(int index) {
  return ver_list_.Mutable(index);
}
inline ::nv::TNVUpgradeVersionInfo* TNVUpgradeVersionInfoList::add_ver_list() {
  return ver_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVUpgradeVersionInfo >&
TNVUpgradeVersionInfoList::ver_list() const {
  return ver_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVUpgradeVersionInfo >*
TNVUpgradeVersionInfoList::mutable_ver_list() {
  return &ver_list_;
}

// -------------------------------------------------------------------

// TNVUpgradeDownloadInfo

// optional uint32 errcode = 1;
inline bool TNVUpgradeDownloadInfo::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUpgradeDownloadInfo::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUpgradeDownloadInfo::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUpgradeDownloadInfo::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 TNVUpgradeDownloadInfo::errcode() const {
  return errcode_;
}
inline void TNVUpgradeDownloadInfo::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
}

// optional uint32 total_percent = 2;
inline bool TNVUpgradeDownloadInfo::has_total_percent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUpgradeDownloadInfo::set_has_total_percent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUpgradeDownloadInfo::clear_has_total_percent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUpgradeDownloadInfo::clear_total_percent() {
  total_percent_ = 0u;
  clear_has_total_percent();
}
inline ::google::protobuf::uint32 TNVUpgradeDownloadInfo::total_percent() const {
  return total_percent_;
}
inline void TNVUpgradeDownloadInfo::set_total_percent(::google::protobuf::uint32 value) {
  set_has_total_percent();
  total_percent_ = value;
}

// optional uint32 cur_percent = 3;
inline bool TNVUpgradeDownloadInfo::has_cur_percent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVUpgradeDownloadInfo::set_has_cur_percent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVUpgradeDownloadInfo::clear_has_cur_percent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVUpgradeDownloadInfo::clear_cur_percent() {
  cur_percent_ = 0u;
  clear_has_cur_percent();
}
inline ::google::protobuf::uint32 TNVUpgradeDownloadInfo::cur_percent() const {
  return cur_percent_;
}
inline void TNVUpgradeDownloadInfo::set_cur_percent(::google::protobuf::uint32 value) {
  set_has_cur_percent();
  cur_percent_ = value;
}

// optional string cur_file_name = 4;
inline bool TNVUpgradeDownloadInfo::has_cur_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVUpgradeDownloadInfo::set_has_cur_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVUpgradeDownloadInfo::clear_has_cur_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVUpgradeDownloadInfo::clear_cur_file_name() {
  if (cur_file_name_ != &::google::protobuf::internal::kEmptyString) {
    cur_file_name_->clear();
  }
  clear_has_cur_file_name();
}
inline const ::std::string& TNVUpgradeDownloadInfo::cur_file_name() const {
  return *cur_file_name_;
}
inline void TNVUpgradeDownloadInfo::set_cur_file_name(const ::std::string& value) {
  set_has_cur_file_name();
  if (cur_file_name_ == &::google::protobuf::internal::kEmptyString) {
    cur_file_name_ = new ::std::string;
  }
  cur_file_name_->assign(value);
}
inline void TNVUpgradeDownloadInfo::set_cur_file_name(const char* value) {
  set_has_cur_file_name();
  if (cur_file_name_ == &::google::protobuf::internal::kEmptyString) {
    cur_file_name_ = new ::std::string;
  }
  cur_file_name_->assign(value);
}
inline void TNVUpgradeDownloadInfo::set_cur_file_name(const char* value, size_t size) {
  set_has_cur_file_name();
  if (cur_file_name_ == &::google::protobuf::internal::kEmptyString) {
    cur_file_name_ = new ::std::string;
  }
  cur_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpgradeDownloadInfo::mutable_cur_file_name() {
  set_has_cur_file_name();
  if (cur_file_name_ == &::google::protobuf::internal::kEmptyString) {
    cur_file_name_ = new ::std::string;
  }
  return cur_file_name_;
}
inline ::std::string* TNVUpgradeDownloadInfo::release_cur_file_name() {
  clear_has_cur_file_name();
  if (cur_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cur_file_name_;
    cur_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpgradeDownloadInfo::set_allocated_cur_file_name(::std::string* cur_file_name) {
  if (cur_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete cur_file_name_;
  }
  if (cur_file_name) {
    set_has_cur_file_name();
    cur_file_name_ = cur_file_name;
  } else {
    clear_has_cur_file_name();
    cur_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVSUSAddr

// optional string Domain = 1;
inline bool TNVSUSAddr::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVSUSAddr::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVSUSAddr::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVSUSAddr::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& TNVSUSAddr::domain() const {
  return *domain_;
}
inline void TNVSUSAddr::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVSUSAddr::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void TNVSUSAddr::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSUSAddr::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* TNVSUSAddr::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVSUSAddr::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ip = 2;
inline bool TNVSUSAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVSUSAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVSUSAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVSUSAddr::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TNVSUSAddr::ip() const {
  return ip_;
}
inline void TNVSUSAddr::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 3;
inline bool TNVSUSAddr::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVSUSAddr::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVSUSAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVSUSAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TNVSUSAddr::port() const {
  return port_;
}
inline void TNVSUSAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional bool use_default_addr = 4;
inline bool TNVSUSAddr::has_use_default_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVSUSAddr::set_has_use_default_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVSUSAddr::clear_has_use_default_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVSUSAddr::clear_use_default_addr() {
  use_default_addr_ = false;
  clear_has_use_default_addr();
}
inline bool TNVSUSAddr::use_default_addr() const {
  return use_default_addr_;
}
inline void TNVSUSAddr::set_use_default_addr(bool value) {
  set_has_use_default_addr();
  use_default_addr_ = value;
}

// optional string custom_domain = 5;
inline bool TNVSUSAddr::has_custom_domain() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVSUSAddr::set_has_custom_domain() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVSUSAddr::clear_has_custom_domain() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVSUSAddr::clear_custom_domain() {
  if (custom_domain_ != &::google::protobuf::internal::kEmptyString) {
    custom_domain_->clear();
  }
  clear_has_custom_domain();
}
inline const ::std::string& TNVSUSAddr::custom_domain() const {
  return *custom_domain_;
}
inline void TNVSUSAddr::set_custom_domain(const ::std::string& value) {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  custom_domain_->assign(value);
}
inline void TNVSUSAddr::set_custom_domain(const char* value) {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  custom_domain_->assign(value);
}
inline void TNVSUSAddr::set_custom_domain(const char* value, size_t size) {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  custom_domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVSUSAddr::mutable_custom_domain() {
  set_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    custom_domain_ = new ::std::string;
  }
  return custom_domain_;
}
inline ::std::string* TNVSUSAddr::release_custom_domain() {
  clear_has_custom_domain();
  if (custom_domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custom_domain_;
    custom_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVSUSAddr::set_allocated_custom_domain(::std::string* custom_domain) {
  if (custom_domain_ != &::google::protobuf::internal::kEmptyString) {
    delete custom_domain_;
  }
  if (custom_domain) {
    set_has_custom_domain();
    custom_domain_ = custom_domain;
  } else {
    clear_has_custom_domain();
    custom_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 custom_ip = 6;
inline bool TNVSUSAddr::has_custom_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVSUSAddr::set_has_custom_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVSUSAddr::clear_has_custom_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVSUSAddr::clear_custom_ip() {
  custom_ip_ = 0u;
  clear_has_custom_ip();
}
inline ::google::protobuf::uint32 TNVSUSAddr::custom_ip() const {
  return custom_ip_;
}
inline void TNVSUSAddr::set_custom_ip(::google::protobuf::uint32 value) {
  set_has_custom_ip();
  custom_ip_ = value;
}

// -------------------------------------------------------------------

// TNVUserFullInfo

// optional uint32 guid = 1;
inline bool TNVUserFullInfo::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUserFullInfo::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUserFullInfo::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUserFullInfo::clear_guid() {
  guid_ = 0u;
  clear_has_guid();
}
inline ::google::protobuf::uint32 TNVUserFullInfo::guid() const {
  return guid_;
}
inline void TNVUserFullInfo::set_guid(::google::protobuf::uint32 value) {
  set_has_guid();
  guid_ = value;
}

// optional .nv.EmNvNvcType nvc_type = 2;
inline bool TNVUserFullInfo::has_nvc_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUserFullInfo::set_has_nvc_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUserFullInfo::clear_has_nvc_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUserFullInfo::clear_nvc_type() {
  nvc_type_ = 0;
  clear_has_nvc_type();
}
inline ::nv::EmNvNvcType TNVUserFullInfo::nvc_type() const {
  return static_cast< ::nv::EmNvNvcType >(nvc_type_);
}
inline void TNVUserFullInfo::set_nvc_type(::nv::EmNvNvcType value) {
  assert(::nv::EmNvNvcType_IsValid(value));
  set_has_nvc_type();
  nvc_type_ = value;
}

// optional string user_name = 3;
inline bool TNVUserFullInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVUserFullInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVUserFullInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVUserFullInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TNVUserFullInfo::user_name() const {
  return *user_name_;
}
inline void TNVUserFullInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVUserFullInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVUserFullInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUserFullInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TNVUserFullInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUserFullInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 4;
inline bool TNVUserFullInfo::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVUserFullInfo::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVUserFullInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVUserFullInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TNVUserFullInfo::password() const {
  return *password_;
}
inline void TNVUserFullInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVUserFullInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVUserFullInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUserFullInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TNVUserFullInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUserFullInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 actor = 5;
inline bool TNVUserFullInfo::has_actor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVUserFullInfo::set_has_actor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVUserFullInfo::clear_has_actor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVUserFullInfo::clear_actor() {
  actor_ = 0u;
  clear_has_actor();
}
inline ::google::protobuf::uint32 TNVUserFullInfo::actor() const {
  return actor_;
}
inline void TNVUserFullInfo::set_actor(::google::protobuf::uint32 value) {
  set_has_actor();
  actor_ = value;
}

// optional string full_user_name = 6;
inline bool TNVUserFullInfo::has_full_user_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVUserFullInfo::set_has_full_user_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVUserFullInfo::clear_has_full_user_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVUserFullInfo::clear_full_user_name() {
  if (full_user_name_ != &::google::protobuf::internal::kEmptyString) {
    full_user_name_->clear();
  }
  clear_has_full_user_name();
}
inline const ::std::string& TNVUserFullInfo::full_user_name() const {
  return *full_user_name_;
}
inline void TNVUserFullInfo::set_full_user_name(const ::std::string& value) {
  set_has_full_user_name();
  if (full_user_name_ == &::google::protobuf::internal::kEmptyString) {
    full_user_name_ = new ::std::string;
  }
  full_user_name_->assign(value);
}
inline void TNVUserFullInfo::set_full_user_name(const char* value) {
  set_has_full_user_name();
  if (full_user_name_ == &::google::protobuf::internal::kEmptyString) {
    full_user_name_ = new ::std::string;
  }
  full_user_name_->assign(value);
}
inline void TNVUserFullInfo::set_full_user_name(const char* value, size_t size) {
  set_has_full_user_name();
  if (full_user_name_ == &::google::protobuf::internal::kEmptyString) {
    full_user_name_ = new ::std::string;
  }
  full_user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUserFullInfo::mutable_full_user_name() {
  set_has_full_user_name();
  if (full_user_name_ == &::google::protobuf::internal::kEmptyString) {
    full_user_name_ = new ::std::string;
  }
  return full_user_name_;
}
inline ::std::string* TNVUserFullInfo::release_full_user_name() {
  clear_has_full_user_name();
  if (full_user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = full_user_name_;
    full_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUserFullInfo::set_allocated_full_user_name(::std::string* full_user_name) {
  if (full_user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete full_user_name_;
  }
  if (full_user_name) {
    set_has_full_user_name();
    full_user_name_ = full_user_name;
  } else {
    clear_has_full_user_name();
    full_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_discription = 7;
inline bool TNVUserFullInfo::has_user_discription() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVUserFullInfo::set_has_user_discription() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVUserFullInfo::clear_has_user_discription() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVUserFullInfo::clear_user_discription() {
  if (user_discription_ != &::google::protobuf::internal::kEmptyString) {
    user_discription_->clear();
  }
  clear_has_user_discription();
}
inline const ::std::string& TNVUserFullInfo::user_discription() const {
  return *user_discription_;
}
inline void TNVUserFullInfo::set_user_discription(const ::std::string& value) {
  set_has_user_discription();
  if (user_discription_ == &::google::protobuf::internal::kEmptyString) {
    user_discription_ = new ::std::string;
  }
  user_discription_->assign(value);
}
inline void TNVUserFullInfo::set_user_discription(const char* value) {
  set_has_user_discription();
  if (user_discription_ == &::google::protobuf::internal::kEmptyString) {
    user_discription_ = new ::std::string;
  }
  user_discription_->assign(value);
}
inline void TNVUserFullInfo::set_user_discription(const char* value, size_t size) {
  set_has_user_discription();
  if (user_discription_ == &::google::protobuf::internal::kEmptyString) {
    user_discription_ = new ::std::string;
  }
  user_discription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUserFullInfo::mutable_user_discription() {
  set_has_user_discription();
  if (user_discription_ == &::google::protobuf::internal::kEmptyString) {
    user_discription_ = new ::std::string;
  }
  return user_discription_;
}
inline ::std::string* TNVUserFullInfo::release_user_discription() {
  clear_has_user_discription();
  if (user_discription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_discription_;
    user_discription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUserFullInfo::set_allocated_user_discription(::std::string* user_discription) {
  if (user_discription_ != &::google::protobuf::internal::kEmptyString) {
    delete user_discription_;
  }
  if (user_discription) {
    set_has_user_discription();
    user_discription_ = user_discription;
  } else {
    clear_has_user_discription();
    user_discription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVUserReqResult

// optional .nv.TNVUserFullInfo user_info = 1;
inline bool TNVUserReqResult::has_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUserReqResult::set_has_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUserReqResult::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUserReqResult::clear_user_info() {
  if (user_info_ != NULL) user_info_->::nv::TNVUserFullInfo::Clear();
  clear_has_user_info();
}
inline const ::nv::TNVUserFullInfo& TNVUserReqResult::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::nv::TNVUserFullInfo* TNVUserReqResult::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::nv::TNVUserFullInfo;
  return user_info_;
}
inline ::nv::TNVUserFullInfo* TNVUserReqResult::release_user_info() {
  clear_has_user_info();
  ::nv::TNVUserFullInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void TNVUserReqResult::set_allocated_user_info(::nv::TNVUserFullInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// optional uint32 user_req_result = 2;
inline bool TNVUserReqResult::has_user_req_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUserReqResult::set_has_user_req_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUserReqResult::clear_has_user_req_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUserReqResult::clear_user_req_result() {
  user_req_result_ = 0u;
  clear_has_user_req_result();
}
inline ::google::protobuf::uint32 TNVUserReqResult::user_req_result() const {
  return user_req_result_;
}
inline void TNVUserReqResult::set_user_req_result(::google::protobuf::uint32 value) {
  set_has_user_req_result();
  user_req_result_ = value;
}

// -------------------------------------------------------------------

// TNVMultiUserFullInfo

// repeated .nv.TNVUserFullInfo multi_user_info = 1;
inline int TNVMultiUserFullInfo::multi_user_info_size() const {
  return multi_user_info_.size();
}
inline void TNVMultiUserFullInfo::clear_multi_user_info() {
  multi_user_info_.Clear();
}
inline const ::nv::TNVUserFullInfo& TNVMultiUserFullInfo::multi_user_info(int index) const {
  return multi_user_info_.Get(index);
}
inline ::nv::TNVUserFullInfo* TNVMultiUserFullInfo::mutable_multi_user_info(int index) {
  return multi_user_info_.Mutable(index);
}
inline ::nv::TNVUserFullInfo* TNVMultiUserFullInfo::add_multi_user_info() {
  return multi_user_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVUserFullInfo >&
TNVMultiUserFullInfo::multi_user_info() const {
  return multi_user_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVUserFullInfo >*
TNVMultiUserFullInfo::mutable_multi_user_info() {
  return &multi_user_info_;
}

// -------------------------------------------------------------------

// TNVMultiUserReqResult

// repeated .nv.TNVUserReqResult multi_user_req_result = 1;
inline int TNVMultiUserReqResult::multi_user_req_result_size() const {
  return multi_user_req_result_.size();
}
inline void TNVMultiUserReqResult::clear_multi_user_req_result() {
  multi_user_req_result_.Clear();
}
inline const ::nv::TNVUserReqResult& TNVMultiUserReqResult::multi_user_req_result(int index) const {
  return multi_user_req_result_.Get(index);
}
inline ::nv::TNVUserReqResult* TNVMultiUserReqResult::mutable_multi_user_req_result(int index) {
  return multi_user_req_result_.Mutable(index);
}
inline ::nv::TNVUserReqResult* TNVMultiUserReqResult::add_multi_user_req_result() {
  return multi_user_req_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVUserReqResult >&
TNVMultiUserReqResult::multi_user_req_result() const {
  return multi_user_req_result_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVUserReqResult >*
TNVMultiUserReqResult::mutable_multi_user_req_result() {
  return &multi_user_req_result_;
}

// -------------------------------------------------------------------

// TNVUserConnectInfo

// optional string mt_ip = 1;
inline bool TNVUserConnectInfo::has_mt_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUserConnectInfo::set_has_mt_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUserConnectInfo::clear_has_mt_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUserConnectInfo::clear_mt_ip() {
  if (mt_ip_ != &::google::protobuf::internal::kEmptyString) {
    mt_ip_->clear();
  }
  clear_has_mt_ip();
}
inline const ::std::string& TNVUserConnectInfo::mt_ip() const {
  return *mt_ip_;
}
inline void TNVUserConnectInfo::set_mt_ip(const ::std::string& value) {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  mt_ip_->assign(value);
}
inline void TNVUserConnectInfo::set_mt_ip(const char* value) {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  mt_ip_->assign(value);
}
inline void TNVUserConnectInfo::set_mt_ip(const char* value, size_t size) {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  mt_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUserConnectInfo::mutable_mt_ip() {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  return mt_ip_;
}
inline ::std::string* TNVUserConnectInfo::release_mt_ip() {
  clear_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mt_ip_;
    mt_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUserConnectInfo::set_allocated_mt_ip(::std::string* mt_ip) {
  if (mt_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete mt_ip_;
  }
  if (mt_ip) {
    set_has_mt_ip();
    mt_ip_ = mt_ip;
  } else {
    clear_has_mt_ip();
    mt_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 listen_port = 2;
inline bool TNVUserConnectInfo::has_listen_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUserConnectInfo::set_has_listen_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUserConnectInfo::clear_has_listen_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUserConnectInfo::clear_listen_port() {
  listen_port_ = 0u;
  clear_has_listen_port();
}
inline ::google::protobuf::uint32 TNVUserConnectInfo::listen_port() const {
  return listen_port_;
}
inline void TNVUserConnectInfo::set_listen_port(::google::protobuf::uint32 value) {
  set_has_listen_port();
  listen_port_ = value;
}

// optional .nv.EmNvNvcType nvc_type = 3;
inline bool TNVUserConnectInfo::has_nvc_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVUserConnectInfo::set_has_nvc_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVUserConnectInfo::clear_has_nvc_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVUserConnectInfo::clear_nvc_type() {
  nvc_type_ = 0;
  clear_has_nvc_type();
}
inline ::nv::EmNvNvcType TNVUserConnectInfo::nvc_type() const {
  return static_cast< ::nv::EmNvNvcType >(nvc_type_);
}
inline void TNVUserConnectInfo::set_nvc_type(::nv::EmNvNvcType value) {
  assert(::nv::EmNvNvcType_IsValid(value));
  set_has_nvc_type();
  nvc_type_ = value;
}

// optional string user_name = 4;
inline bool TNVUserConnectInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVUserConnectInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVUserConnectInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVUserConnectInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TNVUserConnectInfo::user_name() const {
  return *user_name_;
}
inline void TNVUserConnectInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVUserConnectInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TNVUserConnectInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUserConnectInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TNVUserConnectInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUserConnectInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 5;
inline bool TNVUserConnectInfo::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVUserConnectInfo::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVUserConnectInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVUserConnectInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TNVUserConnectInfo::password() const {
  return *password_;
}
inline void TNVUserConnectInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVUserConnectInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVUserConnectInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUserConnectInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TNVUserConnectInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUserConnectInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVEthnetCardInfo

// optional bool enable_ip_dhcp = 1;
inline bool TNVEthnetCardInfo::has_enable_ip_dhcp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVEthnetCardInfo::set_has_enable_ip_dhcp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVEthnetCardInfo::clear_has_enable_ip_dhcp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVEthnetCardInfo::clear_enable_ip_dhcp() {
  enable_ip_dhcp_ = false;
  clear_has_enable_ip_dhcp();
}
inline bool TNVEthnetCardInfo::enable_ip_dhcp() const {
  return enable_ip_dhcp_;
}
inline void TNVEthnetCardInfo::set_enable_ip_dhcp(bool value) {
  set_has_enable_ip_dhcp();
  enable_ip_dhcp_ = value;
}

// optional uint32 static_ip = 2;
inline bool TNVEthnetCardInfo::has_static_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVEthnetCardInfo::set_has_static_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVEthnetCardInfo::clear_has_static_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVEthnetCardInfo::clear_static_ip() {
  static_ip_ = 0u;
  clear_has_static_ip();
}
inline ::google::protobuf::uint32 TNVEthnetCardInfo::static_ip() const {
  return static_ip_;
}
inline void TNVEthnetCardInfo::set_static_ip(::google::protobuf::uint32 value) {
  set_has_static_ip();
  static_ip_ = value;
}

// optional uint32 static_mask = 3;
inline bool TNVEthnetCardInfo::has_static_mask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVEthnetCardInfo::set_has_static_mask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVEthnetCardInfo::clear_has_static_mask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVEthnetCardInfo::clear_static_mask() {
  static_mask_ = 0u;
  clear_has_static_mask();
}
inline ::google::protobuf::uint32 TNVEthnetCardInfo::static_mask() const {
  return static_mask_;
}
inline void TNVEthnetCardInfo::set_static_mask(::google::protobuf::uint32 value) {
  set_has_static_mask();
  static_mask_ = value;
}

// optional uint32 static_gateway_ip = 4;
inline bool TNVEthnetCardInfo::has_static_gateway_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVEthnetCardInfo::set_has_static_gateway_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVEthnetCardInfo::clear_has_static_gateway_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVEthnetCardInfo::clear_static_gateway_ip() {
  static_gateway_ip_ = 0u;
  clear_has_static_gateway_ip();
}
inline ::google::protobuf::uint32 TNVEthnetCardInfo::static_gateway_ip() const {
  return static_gateway_ip_;
}
inline void TNVEthnetCardInfo::set_static_gateway_ip(::google::protobuf::uint32 value) {
  set_has_static_gateway_ip();
  static_gateway_ip_ = value;
}

// optional uint32 dhcp_ip = 5;
inline bool TNVEthnetCardInfo::has_dhcp_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVEthnetCardInfo::set_has_dhcp_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVEthnetCardInfo::clear_has_dhcp_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVEthnetCardInfo::clear_dhcp_ip() {
  dhcp_ip_ = 0u;
  clear_has_dhcp_ip();
}
inline ::google::protobuf::uint32 TNVEthnetCardInfo::dhcp_ip() const {
  return dhcp_ip_;
}
inline void TNVEthnetCardInfo::set_dhcp_ip(::google::protobuf::uint32 value) {
  set_has_dhcp_ip();
  dhcp_ip_ = value;
}

// optional uint32 dhcp_mask = 6;
inline bool TNVEthnetCardInfo::has_dhcp_mask() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVEthnetCardInfo::set_has_dhcp_mask() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVEthnetCardInfo::clear_has_dhcp_mask() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVEthnetCardInfo::clear_dhcp_mask() {
  dhcp_mask_ = 0u;
  clear_has_dhcp_mask();
}
inline ::google::protobuf::uint32 TNVEthnetCardInfo::dhcp_mask() const {
  return dhcp_mask_;
}
inline void TNVEthnetCardInfo::set_dhcp_mask(::google::protobuf::uint32 value) {
  set_has_dhcp_mask();
  dhcp_mask_ = value;
}

// optional uint32 dhcp_gateway = 7;
inline bool TNVEthnetCardInfo::has_dhcp_gateway() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVEthnetCardInfo::set_has_dhcp_gateway() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVEthnetCardInfo::clear_has_dhcp_gateway() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVEthnetCardInfo::clear_dhcp_gateway() {
  dhcp_gateway_ = 0u;
  clear_has_dhcp_gateway();
}
inline ::google::protobuf::uint32 TNVEthnetCardInfo::dhcp_gateway() const {
  return dhcp_gateway_;
}
inline void TNVEthnetCardInfo::set_dhcp_gateway(::google::protobuf::uint32 value) {
  set_has_dhcp_gateway();
  dhcp_gateway_ = value;
}

// optional bool enable_dns_dhcp = 8;
inline bool TNVEthnetCardInfo::has_enable_dns_dhcp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVEthnetCardInfo::set_has_enable_dns_dhcp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVEthnetCardInfo::clear_has_enable_dns_dhcp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVEthnetCardInfo::clear_enable_dns_dhcp() {
  enable_dns_dhcp_ = false;
  clear_has_enable_dns_dhcp();
}
inline bool TNVEthnetCardInfo::enable_dns_dhcp() const {
  return enable_dns_dhcp_;
}
inline void TNVEthnetCardInfo::set_enable_dns_dhcp(bool value) {
  set_has_enable_dns_dhcp();
  enable_dns_dhcp_ = value;
}

// optional uint32 static_dns = 9;
inline bool TNVEthnetCardInfo::has_static_dns() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVEthnetCardInfo::set_has_static_dns() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVEthnetCardInfo::clear_has_static_dns() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVEthnetCardInfo::clear_static_dns() {
  static_dns_ = 0u;
  clear_has_static_dns();
}
inline ::google::protobuf::uint32 TNVEthnetCardInfo::static_dns() const {
  return static_dns_;
}
inline void TNVEthnetCardInfo::set_static_dns(::google::protobuf::uint32 value) {
  set_has_static_dns();
  static_dns_ = value;
}

// optional uint32 static_dns_backup = 10;
inline bool TNVEthnetCardInfo::has_static_dns_backup() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TNVEthnetCardInfo::set_has_static_dns_backup() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TNVEthnetCardInfo::clear_has_static_dns_backup() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TNVEthnetCardInfo::clear_static_dns_backup() {
  static_dns_backup_ = 0u;
  clear_has_static_dns_backup();
}
inline ::google::protobuf::uint32 TNVEthnetCardInfo::static_dns_backup() const {
  return static_dns_backup_;
}
inline void TNVEthnetCardInfo::set_static_dns_backup(::google::protobuf::uint32 value) {
  set_has_static_dns_backup();
  static_dns_backup_ = value;
}

// optional uint32 dhcp_dns = 11;
inline bool TNVEthnetCardInfo::has_dhcp_dns() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TNVEthnetCardInfo::set_has_dhcp_dns() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TNVEthnetCardInfo::clear_has_dhcp_dns() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TNVEthnetCardInfo::clear_dhcp_dns() {
  dhcp_dns_ = 0u;
  clear_has_dhcp_dns();
}
inline ::google::protobuf::uint32 TNVEthnetCardInfo::dhcp_dns() const {
  return dhcp_dns_;
}
inline void TNVEthnetCardInfo::set_dhcp_dns(::google::protobuf::uint32 value) {
  set_has_dhcp_dns();
  dhcp_dns_ = value;
}

// optional uint32 dhcp_dns_backup = 12;
inline bool TNVEthnetCardInfo::has_dhcp_dns_backup() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TNVEthnetCardInfo::set_has_dhcp_dns_backup() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TNVEthnetCardInfo::clear_has_dhcp_dns_backup() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TNVEthnetCardInfo::clear_dhcp_dns_backup() {
  dhcp_dns_backup_ = 0u;
  clear_has_dhcp_dns_backup();
}
inline ::google::protobuf::uint32 TNVEthnetCardInfo::dhcp_dns_backup() const {
  return dhcp_dns_backup_;
}
inline void TNVEthnetCardInfo::set_dhcp_dns_backup(::google::protobuf::uint32 value) {
  set_has_dhcp_dns_backup();
  dhcp_dns_backup_ = value;
}

// -------------------------------------------------------------------

// TNVEthnetCfg

// optional .nv.EmNvEthInterfaceMode ethnet_backupmode = 1;
inline bool TNVEthnetCfg::has_ethnet_backupmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVEthnetCfg::set_has_ethnet_backupmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVEthnetCfg::clear_has_ethnet_backupmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVEthnetCfg::clear_ethnet_backupmode() {
  ethnet_backupmode_ = 0;
  clear_has_ethnet_backupmode();
}
inline ::nv::EmNvEthInterfaceMode TNVEthnetCfg::ethnet_backupmode() const {
  return static_cast< ::nv::EmNvEthInterfaceMode >(ethnet_backupmode_);
}
inline void TNVEthnetCfg::set_ethnet_backupmode(::nv::EmNvEthInterfaceMode value) {
  assert(::nv::EmNvEthInterfaceMode_IsValid(value));
  set_has_ethnet_backupmode();
  ethnet_backupmode_ = value;
}

// optional uint32 cur_cardid = 2;
inline bool TNVEthnetCfg::has_cur_cardid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVEthnetCfg::set_has_cur_cardid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVEthnetCfg::clear_has_cur_cardid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVEthnetCfg::clear_cur_cardid() {
  cur_cardid_ = 0u;
  clear_has_cur_cardid();
}
inline ::google::protobuf::uint32 TNVEthnetCfg::cur_cardid() const {
  return cur_cardid_;
}
inline void TNVEthnetCfg::set_cur_cardid(::google::protobuf::uint32 value) {
  set_has_cur_cardid();
  cur_cardid_ = value;
}

// optional .nv.TNVEthnetCardInfo eth1 = 3;
inline bool TNVEthnetCfg::has_eth1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVEthnetCfg::set_has_eth1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVEthnetCfg::clear_has_eth1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVEthnetCfg::clear_eth1() {
  if (eth1_ != NULL) eth1_->::nv::TNVEthnetCardInfo::Clear();
  clear_has_eth1();
}
inline const ::nv::TNVEthnetCardInfo& TNVEthnetCfg::eth1() const {
  return eth1_ != NULL ? *eth1_ : *default_instance_->eth1_;
}
inline ::nv::TNVEthnetCardInfo* TNVEthnetCfg::mutable_eth1() {
  set_has_eth1();
  if (eth1_ == NULL) eth1_ = new ::nv::TNVEthnetCardInfo;
  return eth1_;
}
inline ::nv::TNVEthnetCardInfo* TNVEthnetCfg::release_eth1() {
  clear_has_eth1();
  ::nv::TNVEthnetCardInfo* temp = eth1_;
  eth1_ = NULL;
  return temp;
}
inline void TNVEthnetCfg::set_allocated_eth1(::nv::TNVEthnetCardInfo* eth1) {
  delete eth1_;
  eth1_ = eth1;
  if (eth1) {
    set_has_eth1();
  } else {
    clear_has_eth1();
  }
}

// optional .nv.TNVEthnetCardInfo eth2 = 4;
inline bool TNVEthnetCfg::has_eth2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVEthnetCfg::set_has_eth2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVEthnetCfg::clear_has_eth2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVEthnetCfg::clear_eth2() {
  if (eth2_ != NULL) eth2_->::nv::TNVEthnetCardInfo::Clear();
  clear_has_eth2();
}
inline const ::nv::TNVEthnetCardInfo& TNVEthnetCfg::eth2() const {
  return eth2_ != NULL ? *eth2_ : *default_instance_->eth2_;
}
inline ::nv::TNVEthnetCardInfo* TNVEthnetCfg::mutable_eth2() {
  set_has_eth2();
  if (eth2_ == NULL) eth2_ = new ::nv::TNVEthnetCardInfo;
  return eth2_;
}
inline ::nv::TNVEthnetCardInfo* TNVEthnetCfg::release_eth2() {
  clear_has_eth2();
  ::nv::TNVEthnetCardInfo* temp = eth2_;
  eth2_ = NULL;
  return temp;
}
inline void TNVEthnetCfg::set_allocated_eth2(::nv::TNVEthnetCardInfo* eth2) {
  delete eth2_;
  eth2_ = eth2;
  if (eth2) {
    set_has_eth2();
  } else {
    clear_has_eth2();
  }
}

// -------------------------------------------------------------------

// TNVLastDisplay

// optional .nv.EmNvHDLastDisplay emLastDisplayType = 1;
inline bool TNVLastDisplay::has_emlastdisplaytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVLastDisplay::set_has_emlastdisplaytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVLastDisplay::clear_has_emlastdisplaytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVLastDisplay::clear_emlastdisplaytype() {
  emlastdisplaytype_ = 0;
  clear_has_emlastdisplaytype();
}
inline ::nv::EmNvHDLastDisplay TNVLastDisplay::emlastdisplaytype() const {
  return static_cast< ::nv::EmNvHDLastDisplay >(emlastdisplaytype_);
}
inline void TNVLastDisplay::set_emlastdisplaytype(::nv::EmNvHDLastDisplay value) {
  assert(::nv::EmNvHDLastDisplay_IsValid(value));
  set_has_emlastdisplaytype();
  emlastdisplaytype_ = value;
}

// optional uint32 wait_timer = 2;
inline bool TNVLastDisplay::has_wait_timer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVLastDisplay::set_has_wait_timer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVLastDisplay::clear_has_wait_timer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVLastDisplay::clear_wait_timer() {
  wait_timer_ = 0u;
  clear_has_wait_timer();
}
inline ::google::protobuf::uint32 TNVLastDisplay::wait_timer() const {
  return wait_timer_;
}
inline void TNVLastDisplay::set_wait_timer(::google::protobuf::uint32 value) {
  set_has_wait_timer();
  wait_timer_ = value;
}

// -------------------------------------------------------------------

// TNVResizeMode

// optional .nv.EmNvResizeMode emResizeMode = 1;
inline bool TNVResizeMode::has_emresizemode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVResizeMode::set_has_emresizemode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVResizeMode::clear_has_emresizemode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVResizeMode::clear_emresizemode() {
  emresizemode_ = 0;
  clear_has_emresizemode();
}
inline ::nv::EmNvResizeMode TNVResizeMode::emresizemode() const {
  return static_cast< ::nv::EmNvResizeMode >(emresizemode_);
}
inline void TNVResizeMode::set_emresizemode(::nv::EmNvResizeMode value) {
  assert(::nv::EmNvResizeMode_IsValid(value));
  set_has_emresizemode();
  emresizemode_ = value;
}

// -------------------------------------------------------------------

// TNVHDImageNoise

// optional .nv.EmNvHDImageNoise emNoiseLevel = 1;
inline bool TNVHDImageNoise::has_emnoiselevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVHDImageNoise::set_has_emnoiselevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVHDImageNoise::clear_has_emnoiselevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVHDImageNoise::clear_emnoiselevel() {
  emnoiselevel_ = 0;
  clear_has_emnoiselevel();
}
inline ::nv::EmNvHDImageNoise TNVHDImageNoise::emnoiselevel() const {
  return static_cast< ::nv::EmNvHDImageNoise >(emnoiselevel_);
}
inline void TNVHDImageNoise::set_emnoiselevel(::nv::EmNvHDImageNoise value) {
  assert(::nv::EmNvHDImageNoise_IsValid(value));
  set_has_emnoiselevel();
  emnoiselevel_ = value;
}

// -------------------------------------------------------------------

// TNVHDImageDeformationTensile

// optional .nv.EmNvCodecComponent CodecType = 1;
inline bool TNVHDImageDeformationTensile::has_codectype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVHDImageDeformationTensile::set_has_codectype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVHDImageDeformationTensile::clear_has_codectype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVHDImageDeformationTensile::clear_codectype() {
  codectype_ = 0;
  clear_has_codectype();
}
inline ::nv::EmNvCodecComponent TNVHDImageDeformationTensile::codectype() const {
  return static_cast< ::nv::EmNvCodecComponent >(codectype_);
}
inline void TNVHDImageDeformationTensile::set_codectype(::nv::EmNvCodecComponent value) {
  assert(::nv::EmNvCodecComponent_IsValid(value));
  set_has_codectype();
  codectype_ = value;
}

// optional .nv.EmNvCodecComponentIndex CodecIndex = 2;
inline bool TNVHDImageDeformationTensile::has_codecindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVHDImageDeformationTensile::set_has_codecindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVHDImageDeformationTensile::clear_has_codecindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVHDImageDeformationTensile::clear_codecindex() {
  codecindex_ = 0;
  clear_has_codecindex();
}
inline ::nv::EmNvCodecComponentIndex TNVHDImageDeformationTensile::codecindex() const {
  return static_cast< ::nv::EmNvCodecComponentIndex >(codecindex_);
}
inline void TNVHDImageDeformationTensile::set_codecindex(::nv::EmNvCodecComponentIndex value) {
  assert(::nv::EmNvCodecComponentIndex_IsValid(value));
  set_has_codecindex();
  codecindex_ = value;
}

// optional uint32 left_right_number = 3;
inline bool TNVHDImageDeformationTensile::has_left_right_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVHDImageDeformationTensile::set_has_left_right_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVHDImageDeformationTensile::clear_has_left_right_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVHDImageDeformationTensile::clear_left_right_number() {
  left_right_number_ = 0u;
  clear_has_left_right_number();
}
inline ::google::protobuf::uint32 TNVHDImageDeformationTensile::left_right_number() const {
  return left_right_number_;
}
inline void TNVHDImageDeformationTensile::set_left_right_number(::google::protobuf::uint32 value) {
  set_has_left_right_number();
  left_right_number_ = value;
}

// optional uint32 up_down_number = 4;
inline bool TNVHDImageDeformationTensile::has_up_down_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVHDImageDeformationTensile::set_has_up_down_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVHDImageDeformationTensile::clear_has_up_down_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVHDImageDeformationTensile::clear_up_down_number() {
  up_down_number_ = 0u;
  clear_has_up_down_number();
}
inline ::google::protobuf::uint32 TNVHDImageDeformationTensile::up_down_number() const {
  return up_down_number_;
}
inline void TNVHDImageDeformationTensile::set_up_down_number(::google::protobuf::uint32 value) {
  set_has_up_down_number();
  up_down_number_ = value;
}

// -------------------------------------------------------------------

// TNVImixVidSourceInfo

// optional .nv.EmNvImixVidSrcType emVidType = 1;
inline bool TNVImixVidSourceInfo::has_emvidtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVImixVidSourceInfo::set_has_emvidtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVImixVidSourceInfo::clear_has_emvidtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVImixVidSourceInfo::clear_emvidtype() {
  emvidtype_ = 0;
  clear_has_emvidtype();
}
inline ::nv::EmNvImixVidSrcType TNVImixVidSourceInfo::emvidtype() const {
  return static_cast< ::nv::EmNvImixVidSrcType >(emvidtype_);
}
inline void TNVImixVidSourceInfo::set_emvidtype(::nv::EmNvImixVidSrcType value) {
  assert(::nv::EmNvImixVidSrcType_IsValid(value));
  set_has_emvidtype();
  emvidtype_ = value;
}

// optional bool enable_have_src = 2;
inline bool TNVImixVidSourceInfo::has_enable_have_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVImixVidSourceInfo::set_has_enable_have_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVImixVidSourceInfo::clear_has_enable_have_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVImixVidSourceInfo::clear_enable_have_src() {
  enable_have_src_ = false;
  clear_has_enable_have_src();
}
inline bool TNVImixVidSourceInfo::enable_have_src() const {
  return enable_have_src_;
}
inline void TNVImixVidSourceInfo::set_enable_have_src(bool value) {
  set_has_enable_have_src();
  enable_have_src_ = value;
}

// -------------------------------------------------------------------

// TNVMultiImixVidSourceInfo

// repeated .nv.TNVImixVidSourceInfo multi_src_info = 1;
inline int TNVMultiImixVidSourceInfo::multi_src_info_size() const {
  return multi_src_info_.size();
}
inline void TNVMultiImixVidSourceInfo::clear_multi_src_info() {
  multi_src_info_.Clear();
}
inline const ::nv::TNVImixVidSourceInfo& TNVMultiImixVidSourceInfo::multi_src_info(int index) const {
  return multi_src_info_.Get(index);
}
inline ::nv::TNVImixVidSourceInfo* TNVMultiImixVidSourceInfo::mutable_multi_src_info(int index) {
  return multi_src_info_.Mutable(index);
}
inline ::nv::TNVImixVidSourceInfo* TNVMultiImixVidSourceInfo::add_multi_src_info() {
  return multi_src_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVImixVidSourceInfo >&
TNVMultiImixVidSourceInfo::multi_src_info() const {
  return multi_src_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVImixVidSourceInfo >*
TNVMultiImixVidSourceInfo::mutable_multi_src_info() {
  return &multi_src_info_;
}

// -------------------------------------------------------------------

// TNVApiStartInfo

// optional .nv.EmNvApiMode emApiMode = 1;
inline bool TNVApiStartInfo::has_emapimode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVApiStartInfo::set_has_emapimode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVApiStartInfo::clear_has_emapimode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVApiStartInfo::clear_emapimode() {
  emapimode_ = 0;
  clear_has_emapimode();
}
inline ::nv::EmNvApiMode TNVApiStartInfo::emapimode() const {
  return static_cast< ::nv::EmNvApiMode >(emapimode_);
}
inline void TNVApiStartInfo::set_emapimode(::nv::EmNvApiMode value) {
  assert(::nv::EmNvApiMode_IsValid(value));
  set_has_emapimode();
  emapimode_ = value;
}

// optional bool enable_UniqueLogFile = 2;
inline bool TNVApiStartInfo::has_enable_uniquelogfile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVApiStartInfo::set_has_enable_uniquelogfile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVApiStartInfo::clear_has_enable_uniquelogfile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVApiStartInfo::clear_enable_uniquelogfile() {
  enable_uniquelogfile_ = false;
  clear_has_enable_uniquelogfile();
}
inline bool TNVApiStartInfo::enable_uniquelogfile() const {
  return enable_uniquelogfile_;
}
inline void TNVApiStartInfo::set_enable_uniquelogfile(bool value) {
  set_has_enable_uniquelogfile();
  enable_uniquelogfile_ = value;
}

// optional string log_ip = 3;
inline bool TNVApiStartInfo::has_log_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVApiStartInfo::set_has_log_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVApiStartInfo::clear_has_log_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVApiStartInfo::clear_log_ip() {
  if (log_ip_ != &::google::protobuf::internal::kEmptyString) {
    log_ip_->clear();
  }
  clear_has_log_ip();
}
inline const ::std::string& TNVApiStartInfo::log_ip() const {
  return *log_ip_;
}
inline void TNVApiStartInfo::set_log_ip(const ::std::string& value) {
  set_has_log_ip();
  if (log_ip_ == &::google::protobuf::internal::kEmptyString) {
    log_ip_ = new ::std::string;
  }
  log_ip_->assign(value);
}
inline void TNVApiStartInfo::set_log_ip(const char* value) {
  set_has_log_ip();
  if (log_ip_ == &::google::protobuf::internal::kEmptyString) {
    log_ip_ = new ::std::string;
  }
  log_ip_->assign(value);
}
inline void TNVApiStartInfo::set_log_ip(const char* value, size_t size) {
  set_has_log_ip();
  if (log_ip_ == &::google::protobuf::internal::kEmptyString) {
    log_ip_ = new ::std::string;
  }
  log_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVApiStartInfo::mutable_log_ip() {
  set_has_log_ip();
  if (log_ip_ == &::google::protobuf::internal::kEmptyString) {
    log_ip_ = new ::std::string;
  }
  return log_ip_;
}
inline ::std::string* TNVApiStartInfo::release_log_ip() {
  clear_has_log_ip();
  if (log_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = log_ip_;
    log_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVApiStartInfo::set_allocated_log_ip(::std::string* log_ip) {
  if (log_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete log_ip_;
  }
  if (log_ip) {
    set_has_log_ip();
    log_ip_ = log_ip;
  } else {
    clear_has_log_ip();
    log_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string filepath = 4;
inline bool TNVApiStartInfo::has_filepath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVApiStartInfo::set_has_filepath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVApiStartInfo::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVApiStartInfo::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& TNVApiStartInfo::filepath() const {
  return *filepath_;
}
inline void TNVApiStartInfo::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void TNVApiStartInfo::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void TNVApiStartInfo::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVApiStartInfo::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  return filepath_;
}
inline ::std::string* TNVApiStartInfo::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVApiStartInfo::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool enable_ToFileLogServer = 5;
inline bool TNVApiStartInfo::has_enable_tofilelogserver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVApiStartInfo::set_has_enable_tofilelogserver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVApiStartInfo::clear_has_enable_tofilelogserver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVApiStartInfo::clear_enable_tofilelogserver() {
  enable_tofilelogserver_ = false;
  clear_has_enable_tofilelogserver();
}
inline bool TNVApiStartInfo::enable_tofilelogserver() const {
  return enable_tofilelogserver_;
}
inline void TNVApiStartInfo::set_enable_tofilelogserver(bool value) {
  set_has_enable_tofilelogserver();
  enable_tofilelogserver_ = value;
}

// optional string strCltTag = 6;
inline bool TNVApiStartInfo::has_strclttag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVApiStartInfo::set_has_strclttag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVApiStartInfo::clear_has_strclttag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVApiStartInfo::clear_strclttag() {
  if (strclttag_ != &::google::protobuf::internal::kEmptyString) {
    strclttag_->clear();
  }
  clear_has_strclttag();
}
inline const ::std::string& TNVApiStartInfo::strclttag() const {
  return *strclttag_;
}
inline void TNVApiStartInfo::set_strclttag(const ::std::string& value) {
  set_has_strclttag();
  if (strclttag_ == &::google::protobuf::internal::kEmptyString) {
    strclttag_ = new ::std::string;
  }
  strclttag_->assign(value);
}
inline void TNVApiStartInfo::set_strclttag(const char* value) {
  set_has_strclttag();
  if (strclttag_ == &::google::protobuf::internal::kEmptyString) {
    strclttag_ = new ::std::string;
  }
  strclttag_->assign(value);
}
inline void TNVApiStartInfo::set_strclttag(const char* value, size_t size) {
  set_has_strclttag();
  if (strclttag_ == &::google::protobuf::internal::kEmptyString) {
    strclttag_ = new ::std::string;
  }
  strclttag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVApiStartInfo::mutable_strclttag() {
  set_has_strclttag();
  if (strclttag_ == &::google::protobuf::internal::kEmptyString) {
    strclttag_ = new ::std::string;
  }
  return strclttag_;
}
inline ::std::string* TNVApiStartInfo::release_strclttag() {
  clear_has_strclttag();
  if (strclttag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strclttag_;
    strclttag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVApiStartInfo::set_allocated_strclttag(::std::string* strclttag) {
  if (strclttag_ != &::google::protobuf::internal::kEmptyString) {
    delete strclttag_;
  }
  if (strclttag) {
    set_has_strclttag();
    strclttag_ = strclttag;
  } else {
    clear_has_strclttag();
    strclttag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVLoginInfo

// optional uint32 node_id = 1;
inline bool TNVLoginInfo::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVLoginInfo::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVLoginInfo::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVLoginInfo::clear_node_id() {
  node_id_ = 0u;
  clear_has_node_id();
}
inline ::google::protobuf::uint32 TNVLoginInfo::node_id() const {
  return node_id_;
}
inline void TNVLoginInfo::set_node_id(::google::protobuf::uint32 value) {
  set_has_node_id();
  node_id_ = value;
}

// optional uint32 appinst_id = 2;
inline bool TNVLoginInfo::has_appinst_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVLoginInfo::set_has_appinst_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVLoginInfo::clear_has_appinst_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVLoginInfo::clear_appinst_id() {
  appinst_id_ = 0u;
  clear_has_appinst_id();
}
inline ::google::protobuf::uint32 TNVLoginInfo::appinst_id() const {
  return appinst_id_;
}
inline void TNVLoginInfo::set_appinst_id(::google::protobuf::uint32 value) {
  set_has_appinst_id();
  appinst_id_ = value;
}

// optional string pcname = 3;
inline bool TNVLoginInfo::has_pcname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVLoginInfo::set_has_pcname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVLoginInfo::clear_has_pcname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVLoginInfo::clear_pcname() {
  if (pcname_ != &::google::protobuf::internal::kEmptyString) {
    pcname_->clear();
  }
  clear_has_pcname();
}
inline const ::std::string& TNVLoginInfo::pcname() const {
  return *pcname_;
}
inline void TNVLoginInfo::set_pcname(const ::std::string& value) {
  set_has_pcname();
  if (pcname_ == &::google::protobuf::internal::kEmptyString) {
    pcname_ = new ::std::string;
  }
  pcname_->assign(value);
}
inline void TNVLoginInfo::set_pcname(const char* value) {
  set_has_pcname();
  if (pcname_ == &::google::protobuf::internal::kEmptyString) {
    pcname_ = new ::std::string;
  }
  pcname_->assign(value);
}
inline void TNVLoginInfo::set_pcname(const char* value, size_t size) {
  set_has_pcname();
  if (pcname_ == &::google::protobuf::internal::kEmptyString) {
    pcname_ = new ::std::string;
  }
  pcname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVLoginInfo::mutable_pcname() {
  set_has_pcname();
  if (pcname_ == &::google::protobuf::internal::kEmptyString) {
    pcname_ = new ::std::string;
  }
  return pcname_;
}
inline ::std::string* TNVLoginInfo::release_pcname() {
  clear_has_pcname();
  if (pcname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pcname_;
    pcname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVLoginInfo::set_allocated_pcname(::std::string* pcname) {
  if (pcname_ != &::google::protobuf::internal::kEmptyString) {
    delete pcname_;
  }
  if (pcname) {
    set_has_pcname();
    pcname_ = pcname;
  } else {
    clear_has_pcname();
    pcname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.EmNvImixVidSrcType empos = 4;
inline bool TNVLoginInfo::has_empos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVLoginInfo::set_has_empos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVLoginInfo::clear_has_empos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVLoginInfo::clear_empos() {
  empos_ = 0;
  clear_has_empos();
}
inline ::nv::EmNvImixVidSrcType TNVLoginInfo::empos() const {
  return static_cast< ::nv::EmNvImixVidSrcType >(empos_);
}
inline void TNVLoginInfo::set_empos(::nv::EmNvImixVidSrcType value) {
  assert(::nv::EmNvImixVidSrcType_IsValid(value));
  set_has_empos();
  empos_ = value;
}

// optional bool is_active = 5;
inline bool TNVLoginInfo::has_is_active() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVLoginInfo::set_has_is_active() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVLoginInfo::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVLoginInfo::clear_is_active() {
  is_active_ = false;
  clear_has_is_active();
}
inline bool TNVLoginInfo::is_active() const {
  return is_active_;
}
inline void TNVLoginInfo::set_is_active(bool value) {
  set_has_is_active();
  is_active_ = value;
}

// optional bool is_viewppt = 6;
inline bool TNVLoginInfo::has_is_viewppt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVLoginInfo::set_has_is_viewppt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVLoginInfo::clear_has_is_viewppt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVLoginInfo::clear_is_viewppt() {
  is_viewppt_ = false;
  clear_has_is_viewppt();
}
inline bool TNVLoginInfo::is_viewppt() const {
  return is_viewppt_;
}
inline void TNVLoginInfo::set_is_viewppt(bool value) {
  set_has_is_viewppt();
  is_viewppt_ = value;
}

// -------------------------------------------------------------------

// TNVLoginInfos

// repeated .nv.TNVLoginInfo login_info_list = 1;
inline int TNVLoginInfos::login_info_list_size() const {
  return login_info_list_.size();
}
inline void TNVLoginInfos::clear_login_info_list() {
  login_info_list_.Clear();
}
inline const ::nv::TNVLoginInfo& TNVLoginInfos::login_info_list(int index) const {
  return login_info_list_.Get(index);
}
inline ::nv::TNVLoginInfo* TNVLoginInfos::mutable_login_info_list(int index) {
  return login_info_list_.Mutable(index);
}
inline ::nv::TNVLoginInfo* TNVLoginInfos::add_login_info_list() {
  return login_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVLoginInfo >&
TNVLoginInfos::login_info_list() const {
  return login_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVLoginInfo >*
TNVLoginInfos::mutable_login_info_list() {
  return &login_info_list_;
}

// optional uint32 state = 2;
inline bool TNVLoginInfos::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVLoginInfos::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVLoginInfos::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVLoginInfos::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 TNVLoginInfos::state() const {
  return state_;
}
inline void TNVLoginInfos::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// TNVImixVidSrcSignal

// optional .nv.EmNvImixVidSrcType src_type = 1;
inline bool TNVImixVidSrcSignal::has_src_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVImixVidSrcSignal::set_has_src_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVImixVidSrcSignal::clear_has_src_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVImixVidSrcSignal::clear_src_type() {
  src_type_ = 0;
  clear_has_src_type();
}
inline ::nv::EmNvImixVidSrcType TNVImixVidSrcSignal::src_type() const {
  return static_cast< ::nv::EmNvImixVidSrcType >(src_type_);
}
inline void TNVImixVidSrcSignal::set_src_type(::nv::EmNvImixVidSrcType value) {
  assert(::nv::EmNvImixVidSrcType_IsValid(value));
  set_has_src_type();
  src_type_ = value;
}

// optional bool is_hassrc = 2;
inline bool TNVImixVidSrcSignal::has_is_hassrc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVImixVidSrcSignal::set_has_is_hassrc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVImixVidSrcSignal::clear_has_is_hassrc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVImixVidSrcSignal::clear_is_hassrc() {
  is_hassrc_ = false;
  clear_has_is_hassrc();
}
inline bool TNVImixVidSrcSignal::is_hassrc() const {
  return is_hassrc_;
}
inline void TNVImixVidSrcSignal::set_is_hassrc(bool value) {
  set_has_is_hassrc();
  is_hassrc_ = value;
}

// optional string vid_name = 3;
inline bool TNVImixVidSrcSignal::has_vid_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVImixVidSrcSignal::set_has_vid_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVImixVidSrcSignal::clear_has_vid_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVImixVidSrcSignal::clear_vid_name() {
  if (vid_name_ != &::google::protobuf::internal::kEmptyString) {
    vid_name_->clear();
  }
  clear_has_vid_name();
}
inline const ::std::string& TNVImixVidSrcSignal::vid_name() const {
  return *vid_name_;
}
inline void TNVImixVidSrcSignal::set_vid_name(const ::std::string& value) {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  vid_name_->assign(value);
}
inline void TNVImixVidSrcSignal::set_vid_name(const char* value) {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  vid_name_->assign(value);
}
inline void TNVImixVidSrcSignal::set_vid_name(const char* value, size_t size) {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  vid_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVImixVidSrcSignal::mutable_vid_name() {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  return vid_name_;
}
inline ::std::string* TNVImixVidSrcSignal::release_vid_name() {
  clear_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vid_name_;
    vid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVImixVidSrcSignal::set_allocated_vid_name(::std::string* vid_name) {
  if (vid_name_ != &::google::protobuf::internal::kEmptyString) {
    delete vid_name_;
  }
  if (vid_name) {
    set_has_vid_name();
    vid_name_ = vid_name;
  } else {
    clear_has_vid_name();
    vid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVImixVidSrcSignalList

// repeated .nv.TNVImixVidSrcSignal vid_list = 1;
inline int TNVImixVidSrcSignalList::vid_list_size() const {
  return vid_list_.size();
}
inline void TNVImixVidSrcSignalList::clear_vid_list() {
  vid_list_.Clear();
}
inline const ::nv::TNVImixVidSrcSignal& TNVImixVidSrcSignalList::vid_list(int index) const {
  return vid_list_.Get(index);
}
inline ::nv::TNVImixVidSrcSignal* TNVImixVidSrcSignalList::mutable_vid_list(int index) {
  return vid_list_.Mutable(index);
}
inline ::nv::TNVImixVidSrcSignal* TNVImixVidSrcSignalList::add_vid_list() {
  return vid_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVImixVidSrcSignal >&
TNVImixVidSrcSignalList::vid_list() const {
  return vid_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVImixVidSrcSignal >*
TNVImixVidSrcSignalList::mutable_vid_list() {
  return &vid_list_;
}

// -------------------------------------------------------------------

// TNVVidInPortMode

// optional .nv.EmNvVideoInPort video_inport = 1;
inline bool TNVVidInPortMode::has_video_inport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVVidInPortMode::set_has_video_inport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVVidInPortMode::clear_has_video_inport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVVidInPortMode::clear_video_inport() {
  video_inport_ = 0;
  clear_has_video_inport();
}
inline ::nv::EmNvVideoInPort TNVVidInPortMode::video_inport() const {
  return static_cast< ::nv::EmNvVideoInPort >(video_inport_);
}
inline void TNVVidInPortMode::set_video_inport(::nv::EmNvVideoInPort value) {
  assert(::nv::EmNvVideoInPort_IsValid(value));
  set_has_video_inport();
  video_inport_ = value;
}

// optional .nv.EmNvVideoOutPutMode inport_mode = 2;
inline bool TNVVidInPortMode::has_inport_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVVidInPortMode::set_has_inport_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVVidInPortMode::clear_has_inport_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVVidInPortMode::clear_inport_mode() {
  inport_mode_ = 0;
  clear_has_inport_mode();
}
inline ::nv::EmNvVideoOutPutMode TNVVidInPortMode::inport_mode() const {
  return static_cast< ::nv::EmNvVideoOutPutMode >(inport_mode_);
}
inline void TNVVidInPortMode::set_inport_mode(::nv::EmNvVideoOutPutMode value) {
  assert(::nv::EmNvVideoOutPutMode_IsValid(value));
  set_has_inport_mode();
  inport_mode_ = value;
}

// optional bool is_change = 3;
inline bool TNVVidInPortMode::has_is_change() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVVidInPortMode::set_has_is_change() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVVidInPortMode::clear_has_is_change() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVVidInPortMode::clear_is_change() {
  is_change_ = false;
  clear_has_is_change();
}
inline bool TNVVidInPortMode::is_change() const {
  return is_change_;
}
inline void TNVVidInPortMode::set_is_change(bool value) {
  set_has_is_change();
  is_change_ = value;
}

// -------------------------------------------------------------------

// TNVVidOutPortMode

// optional .nv.EmNvVideoOutPort video_outport = 1;
inline bool TNVVidOutPortMode::has_video_outport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVVidOutPortMode::set_has_video_outport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVVidOutPortMode::clear_has_video_outport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVVidOutPortMode::clear_video_outport() {
  video_outport_ = 0;
  clear_has_video_outport();
}
inline ::nv::EmNvVideoOutPort TNVVidOutPortMode::video_outport() const {
  return static_cast< ::nv::EmNvVideoOutPort >(video_outport_);
}
inline void TNVVidOutPortMode::set_video_outport(::nv::EmNvVideoOutPort value) {
  assert(::nv::EmNvVideoOutPort_IsValid(value));
  set_has_video_outport();
  video_outport_ = value;
}

// optional .nv.EmNvVideoOutPutMode outport_mode = 2;
inline bool TNVVidOutPortMode::has_outport_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVVidOutPortMode::set_has_outport_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVVidOutPortMode::clear_has_outport_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVVidOutPortMode::clear_outport_mode() {
  outport_mode_ = 0;
  clear_has_outport_mode();
}
inline ::nv::EmNvVideoOutPutMode TNVVidOutPortMode::outport_mode() const {
  return static_cast< ::nv::EmNvVideoOutPutMode >(outport_mode_);
}
inline void TNVVidOutPortMode::set_outport_mode(::nv::EmNvVideoOutPutMode value) {
  assert(::nv::EmNvVideoOutPutMode_IsValid(value));
  set_has_outport_mode();
  outport_mode_ = value;
}

// optional bool is_change = 3;
inline bool TNVVidOutPortMode::has_is_change() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVVidOutPortMode::set_has_is_change() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVVidOutPortMode::clear_has_is_change() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVVidOutPortMode::clear_is_change() {
  is_change_ = false;
  clear_has_is_change();
}
inline bool TNVVidOutPortMode::is_change() const {
  return is_change_;
}
inline void TNVVidOutPortMode::set_is_change(bool value) {
  set_has_is_change();
  is_change_ = value;
}

// -------------------------------------------------------------------

// TNVVideoOutPort2InPort

// optional .nv.EmNvVideoOutPort video_outport = 1;
inline bool TNVVideoOutPort2InPort::has_video_outport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVVideoOutPort2InPort::set_has_video_outport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVVideoOutPort2InPort::clear_has_video_outport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVVideoOutPort2InPort::clear_video_outport() {
  video_outport_ = 0;
  clear_has_video_outport();
}
inline ::nv::EmNvVideoOutPort TNVVideoOutPort2InPort::video_outport() const {
  return static_cast< ::nv::EmNvVideoOutPort >(video_outport_);
}
inline void TNVVideoOutPort2InPort::set_video_outport(::nv::EmNvVideoOutPort value) {
  assert(::nv::EmNvVideoOutPort_IsValid(value));
  set_has_video_outport();
  video_outport_ = value;
}

// optional .nv.EmNvVideoInPort video_inport = 2;
inline bool TNVVideoOutPort2InPort::has_video_inport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVVideoOutPort2InPort::set_has_video_inport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVVideoOutPort2InPort::clear_has_video_inport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVVideoOutPort2InPort::clear_video_inport() {
  video_inport_ = 0;
  clear_has_video_inport();
}
inline ::nv::EmNvVideoInPort TNVVideoOutPort2InPort::video_inport() const {
  return static_cast< ::nv::EmNvVideoInPort >(video_inport_);
}
inline void TNVVideoOutPort2InPort::set_video_inport(::nv::EmNvVideoInPort value) {
  assert(::nv::EmNvVideoInPort_IsValid(value));
  set_has_video_inport();
  video_inport_ = value;
}

// optional bool is_change = 3;
inline bool TNVVideoOutPort2InPort::has_is_change() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVVideoOutPort2InPort::set_has_is_change() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVVideoOutPort2InPort::clear_has_is_change() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVVideoOutPort2InPort::clear_is_change() {
  is_change_ = false;
  clear_has_is_change();
}
inline bool TNVVideoOutPort2InPort::is_change() const {
  return is_change_;
}
inline void TNVVideoOutPort2InPort::set_is_change(bool value) {
  set_has_is_change();
  is_change_ = value;
}

// -------------------------------------------------------------------

// TNVVideoMatrixScheme

// repeated .nv.TNVVidInPortMode inport_mode = 1;
inline int TNVVideoMatrixScheme::inport_mode_size() const {
  return inport_mode_.size();
}
inline void TNVVideoMatrixScheme::clear_inport_mode() {
  inport_mode_.Clear();
}
inline const ::nv::TNVVidInPortMode& TNVVideoMatrixScheme::inport_mode(int index) const {
  return inport_mode_.Get(index);
}
inline ::nv::TNVVidInPortMode* TNVVideoMatrixScheme::mutable_inport_mode(int index) {
  return inport_mode_.Mutable(index);
}
inline ::nv::TNVVidInPortMode* TNVVideoMatrixScheme::add_inport_mode() {
  return inport_mode_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidInPortMode >&
TNVVideoMatrixScheme::inport_mode() const {
  return inport_mode_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidInPortMode >*
TNVVideoMatrixScheme::mutable_inport_mode() {
  return &inport_mode_;
}

// repeated .nv.TNVVidOutPortMode outport_mode = 2;
inline int TNVVideoMatrixScheme::outport_mode_size() const {
  return outport_mode_.size();
}
inline void TNVVideoMatrixScheme::clear_outport_mode() {
  outport_mode_.Clear();
}
inline const ::nv::TNVVidOutPortMode& TNVVideoMatrixScheme::outport_mode(int index) const {
  return outport_mode_.Get(index);
}
inline ::nv::TNVVidOutPortMode* TNVVideoMatrixScheme::mutable_outport_mode(int index) {
  return outport_mode_.Mutable(index);
}
inline ::nv::TNVVidOutPortMode* TNVVideoMatrixScheme::add_outport_mode() {
  return outport_mode_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVidOutPortMode >&
TNVVideoMatrixScheme::outport_mode() const {
  return outport_mode_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVidOutPortMode >*
TNVVideoMatrixScheme::mutable_outport_mode() {
  return &outport_mode_;
}

// repeated .nv.TNVVideoOutPort2InPort outport_inport = 3;
inline int TNVVideoMatrixScheme::outport_inport_size() const {
  return outport_inport_.size();
}
inline void TNVVideoMatrixScheme::clear_outport_inport() {
  outport_inport_.Clear();
}
inline const ::nv::TNVVideoOutPort2InPort& TNVVideoMatrixScheme::outport_inport(int index) const {
  return outport_inport_.Get(index);
}
inline ::nv::TNVVideoOutPort2InPort* TNVVideoMatrixScheme::mutable_outport_inport(int index) {
  return outport_inport_.Mutable(index);
}
inline ::nv::TNVVideoOutPort2InPort* TNVVideoMatrixScheme::add_outport_inport() {
  return outport_inport_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVVideoOutPort2InPort >&
TNVVideoMatrixScheme::outport_inport() const {
  return outport_inport_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVVideoOutPort2InPort >*
TNVVideoMatrixScheme::mutable_outport_inport() {
  return &outport_inport_;
}

// -------------------------------------------------------------------

// TE1Unit

// optional uint32 e1_id = 1;
inline bool TE1Unit::has_e1_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TE1Unit::set_has_e1_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TE1Unit::clear_has_e1_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TE1Unit::clear_e1_id() {
  e1_id_ = 0u;
  clear_has_e1_id();
}
inline ::google::protobuf::uint32 TE1Unit::e1_id() const {
  return e1_id_;
}
inline void TE1Unit::set_e1_id(::google::protobuf::uint32 value) {
  set_has_e1_id();
  e1_id_ = value;
}

// optional uint32 used_flag = 2;
inline bool TE1Unit::has_used_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TE1Unit::set_has_used_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TE1Unit::clear_has_used_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TE1Unit::clear_used_flag() {
  used_flag_ = 0u;
  clear_has_used_flag();
}
inline ::google::protobuf::uint32 TE1Unit::used_flag() const {
  return used_flag_;
}
inline void TE1Unit::set_used_flag(::google::protobuf::uint32 value) {
  set_has_used_flag();
  used_flag_ = value;
}

// optional uint32 e1_ts_mask = 3;
inline bool TE1Unit::has_e1_ts_mask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TE1Unit::set_has_e1_ts_mask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TE1Unit::clear_has_e1_ts_mask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TE1Unit::clear_e1_ts_mask() {
  e1_ts_mask_ = 0u;
  clear_has_e1_ts_mask();
}
inline ::google::protobuf::uint32 TE1Unit::e1_ts_mask() const {
  return e1_ts_mask_;
}
inline void TE1Unit::set_e1_ts_mask(::google::protobuf::uint32 value) {
  set_has_e1_ts_mask();
  e1_ts_mask_ = value;
}

// optional uint32 protocol_type = 4;
inline bool TE1Unit::has_protocol_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TE1Unit::set_has_protocol_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TE1Unit::clear_has_protocol_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TE1Unit::clear_protocol_type() {
  protocol_type_ = 0u;
  clear_has_protocol_type();
}
inline ::google::protobuf::uint32 TE1Unit::protocol_type() const {
  return protocol_type_;
}
inline void TE1Unit::set_protocol_type(::google::protobuf::uint32 value) {
  set_has_protocol_type();
  protocol_type_ = value;
}

// optional uint32 echo_interval = 5;
inline bool TE1Unit::has_echo_interval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TE1Unit::set_has_echo_interval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TE1Unit::clear_has_echo_interval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TE1Unit::clear_echo_interval() {
  echo_interval_ = 0u;
  clear_has_echo_interval();
}
inline ::google::protobuf::uint32 TE1Unit::echo_interval() const {
  return echo_interval_;
}
inline void TE1Unit::set_echo_interval(::google::protobuf::uint32 value) {
  set_has_echo_interval();
  echo_interval_ = value;
}

// optional uint32 echo_maxretry = 6;
inline bool TE1Unit::has_echo_maxretry() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TE1Unit::set_has_echo_maxretry() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TE1Unit::clear_has_echo_maxretry() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TE1Unit::clear_echo_maxretry() {
  echo_maxretry_ = 0u;
  clear_has_echo_maxretry();
}
inline ::google::protobuf::uint32 TE1Unit::echo_maxretry() const {
  return echo_maxretry_;
}
inline void TE1Unit::set_echo_maxretry(::google::protobuf::uint32 value) {
  set_has_echo_maxretry();
  echo_maxretry_ = value;
}

// -------------------------------------------------------------------

// TE1Group

// optional bool enable = 1;
inline bool TE1Group::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TE1Group::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TE1Group::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TE1Group::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TE1Group::enable() const {
  return enable_;
}
inline void TE1Group::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional uint32 unit_num = 2;
inline bool TE1Group::has_unit_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TE1Group::set_has_unit_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TE1Group::clear_has_unit_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TE1Group::clear_unit_num() {
  unit_num_ = 0u;
  clear_has_unit_num();
}
inline ::google::protobuf::uint32 TE1Group::unit_num() const {
  return unit_num_;
}
inline void TE1Group::set_unit_num(::google::protobuf::uint32 value) {
  set_has_unit_num();
  unit_num_ = value;
}

// optional uint32 is_bind = 3;
inline bool TE1Group::has_is_bind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TE1Group::set_has_is_bind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TE1Group::clear_has_is_bind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TE1Group::clear_is_bind() {
  is_bind_ = 0u;
  clear_has_is_bind();
}
inline ::google::protobuf::uint32 TE1Group::is_bind() const {
  return is_bind_;
}
inline void TE1Group::set_is_bind(::google::protobuf::uint32 value) {
  set_has_is_bind();
  is_bind_ = value;
}

// optional uint32 group_id = 4;
inline bool TE1Group::has_group_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TE1Group::set_has_group_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TE1Group::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TE1Group::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 TE1Group::group_id() const {
  return group_id_;
}
inline void TE1Group::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional uint32 ip = 5;
inline bool TE1Group::has_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TE1Group::set_has_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TE1Group::clear_has_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TE1Group::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 TE1Group::ip() const {
  return ip_;
}
inline void TE1Group::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 mask = 6;
inline bool TE1Group::has_mask() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TE1Group::set_has_mask() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TE1Group::clear_has_mask() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TE1Group::clear_mask() {
  mask_ = 0u;
  clear_has_mask();
}
inline ::google::protobuf::uint32 TE1Group::mask() const {
  return mask_;
}
inline void TE1Group::set_mask(::google::protobuf::uint32 value) {
  set_has_mask();
  mask_ = value;
}

// optional uint32 auth_type = 7;
inline bool TE1Group::has_auth_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TE1Group::set_has_auth_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TE1Group::clear_has_auth_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TE1Group::clear_auth_type() {
  auth_type_ = 0u;
  clear_has_auth_type();
}
inline ::google::protobuf::uint32 TE1Group::auth_type() const {
  return auth_type_;
}
inline void TE1Group::set_auth_type(::google::protobuf::uint32 value) {
  set_has_auth_type();
  auth_type_ = value;
}

// optional uint32 frag_minpackage_len = 8;
inline bool TE1Group::has_frag_minpackage_len() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TE1Group::set_has_frag_minpackage_len() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TE1Group::clear_has_frag_minpackage_len() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TE1Group::clear_frag_minpackage_len() {
  frag_minpackage_len_ = 0u;
  clear_has_frag_minpackage_len();
}
inline ::google::protobuf::uint32 TE1Group::frag_minpackage_len() const {
  return frag_minpackage_len_;
}
inline void TE1Group::set_frag_minpackage_len(::google::protobuf::uint32 value) {
  set_has_frag_minpackage_len();
  frag_minpackage_len_ = value;
}

// optional string svr_usrname = 9;
inline bool TE1Group::has_svr_usrname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TE1Group::set_has_svr_usrname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TE1Group::clear_has_svr_usrname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TE1Group::clear_svr_usrname() {
  if (svr_usrname_ != &::google::protobuf::internal::kEmptyString) {
    svr_usrname_->clear();
  }
  clear_has_svr_usrname();
}
inline const ::std::string& TE1Group::svr_usrname() const {
  return *svr_usrname_;
}
inline void TE1Group::set_svr_usrname(const ::std::string& value) {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  svr_usrname_->assign(value);
}
inline void TE1Group::set_svr_usrname(const char* value) {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  svr_usrname_->assign(value);
}
inline void TE1Group::set_svr_usrname(const char* value, size_t size) {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  svr_usrname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1Group::mutable_svr_usrname() {
  set_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrname_ = new ::std::string;
  }
  return svr_usrname_;
}
inline ::std::string* TE1Group::release_svr_usrname() {
  clear_has_svr_usrname();
  if (svr_usrname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_usrname_;
    svr_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1Group::set_allocated_svr_usrname(::std::string* svr_usrname) {
  if (svr_usrname_ != &::google::protobuf::internal::kEmptyString) {
    delete svr_usrname_;
  }
  if (svr_usrname) {
    set_has_svr_usrname();
    svr_usrname_ = svr_usrname;
  } else {
    clear_has_svr_usrname();
    svr_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string svr_usrpwd = 10;
inline bool TE1Group::has_svr_usrpwd() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TE1Group::set_has_svr_usrpwd() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TE1Group::clear_has_svr_usrpwd() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TE1Group::clear_svr_usrpwd() {
  if (svr_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_->clear();
  }
  clear_has_svr_usrpwd();
}
inline const ::std::string& TE1Group::svr_usrpwd() const {
  return *svr_usrpwd_;
}
inline void TE1Group::set_svr_usrpwd(const ::std::string& value) {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  svr_usrpwd_->assign(value);
}
inline void TE1Group::set_svr_usrpwd(const char* value) {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  svr_usrpwd_->assign(value);
}
inline void TE1Group::set_svr_usrpwd(const char* value, size_t size) {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  svr_usrpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1Group::mutable_svr_usrpwd() {
  set_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    svr_usrpwd_ = new ::std::string;
  }
  return svr_usrpwd_;
}
inline ::std::string* TE1Group::release_svr_usrpwd() {
  clear_has_svr_usrpwd();
  if (svr_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_usrpwd_;
    svr_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1Group::set_allocated_svr_usrpwd(::std::string* svr_usrpwd) {
  if (svr_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete svr_usrpwd_;
  }
  if (svr_usrpwd) {
    set_has_svr_usrpwd();
    svr_usrpwd_ = svr_usrpwd;
  } else {
    clear_has_svr_usrpwd();
    svr_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sent_usrname = 11;
inline bool TE1Group::has_sent_usrname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TE1Group::set_has_sent_usrname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TE1Group::clear_has_sent_usrname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TE1Group::clear_sent_usrname() {
  if (sent_usrname_ != &::google::protobuf::internal::kEmptyString) {
    sent_usrname_->clear();
  }
  clear_has_sent_usrname();
}
inline const ::std::string& TE1Group::sent_usrname() const {
  return *sent_usrname_;
}
inline void TE1Group::set_sent_usrname(const ::std::string& value) {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  sent_usrname_->assign(value);
}
inline void TE1Group::set_sent_usrname(const char* value) {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  sent_usrname_->assign(value);
}
inline void TE1Group::set_sent_usrname(const char* value, size_t size) {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  sent_usrname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1Group::mutable_sent_usrname() {
  set_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrname_ = new ::std::string;
  }
  return sent_usrname_;
}
inline ::std::string* TE1Group::release_sent_usrname() {
  clear_has_sent_usrname();
  if (sent_usrname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sent_usrname_;
    sent_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1Group::set_allocated_sent_usrname(::std::string* sent_usrname) {
  if (sent_usrname_ != &::google::protobuf::internal::kEmptyString) {
    delete sent_usrname_;
  }
  if (sent_usrname) {
    set_has_sent_usrname();
    sent_usrname_ = sent_usrname;
  } else {
    clear_has_sent_usrname();
    sent_usrname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sent_usrpwd = 12;
inline bool TE1Group::has_sent_usrpwd() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TE1Group::set_has_sent_usrpwd() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TE1Group::clear_has_sent_usrpwd() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TE1Group::clear_sent_usrpwd() {
  if (sent_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_->clear();
  }
  clear_has_sent_usrpwd();
}
inline const ::std::string& TE1Group::sent_usrpwd() const {
  return *sent_usrpwd_;
}
inline void TE1Group::set_sent_usrpwd(const ::std::string& value) {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  sent_usrpwd_->assign(value);
}
inline void TE1Group::set_sent_usrpwd(const char* value) {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  sent_usrpwd_->assign(value);
}
inline void TE1Group::set_sent_usrpwd(const char* value, size_t size) {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  sent_usrpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TE1Group::mutable_sent_usrpwd() {
  set_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    sent_usrpwd_ = new ::std::string;
  }
  return sent_usrpwd_;
}
inline ::std::string* TE1Group::release_sent_usrpwd() {
  clear_has_sent_usrpwd();
  if (sent_usrpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sent_usrpwd_;
    sent_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TE1Group::set_allocated_sent_usrpwd(::std::string* sent_usrpwd) {
  if (sent_usrpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete sent_usrpwd_;
  }
  if (sent_usrpwd) {
    set_has_sent_usrpwd();
    sent_usrpwd_ = sent_usrpwd;
  } else {
    clear_has_sent_usrpwd();
    sent_usrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .nv.TE1Unit unit_list = 13;
inline int TE1Group::unit_list_size() const {
  return unit_list_.size();
}
inline void TE1Group::clear_unit_list() {
  unit_list_.Clear();
}
inline const ::nv::TE1Unit& TE1Group::unit_list(int index) const {
  return unit_list_.Get(index);
}
inline ::nv::TE1Unit* TE1Group::mutable_unit_list(int index) {
  return unit_list_.Mutable(index);
}
inline ::nv::TE1Unit* TE1Group::add_unit_list() {
  return unit_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TE1Unit >&
TE1Group::unit_list() const {
  return unit_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TE1Unit >*
TE1Group::mutable_unit_list() {
  return &unit_list_;
}

// -------------------------------------------------------------------

// TE1Cfg

// optional bool encrypt = 1;
inline bool TE1Cfg::has_encrypt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TE1Cfg::set_has_encrypt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TE1Cfg::clear_has_encrypt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TE1Cfg::clear_encrypt() {
  encrypt_ = false;
  clear_has_encrypt();
}
inline bool TE1Cfg::encrypt() const {
  return encrypt_;
}
inline void TE1Cfg::set_encrypt(bool value) {
  set_has_encrypt();
  encrypt_ = value;
}

// optional uint32 clock_type = 2;
inline bool TE1Cfg::has_clock_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TE1Cfg::set_has_clock_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TE1Cfg::clear_has_clock_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TE1Cfg::clear_clock_type() {
  clock_type_ = 0u;
  clear_has_clock_type();
}
inline ::google::protobuf::uint32 TE1Cfg::clock_type() const {
  return clock_type_;
}
inline void TE1Cfg::set_clock_type(::google::protobuf::uint32 value) {
  set_has_clock_type();
  clock_type_ = value;
}

// repeated .nv.TE1Group group_detail = 3;
inline int TE1Cfg::group_detail_size() const {
  return group_detail_.size();
}
inline void TE1Cfg::clear_group_detail() {
  group_detail_.Clear();
}
inline const ::nv::TE1Group& TE1Cfg::group_detail(int index) const {
  return group_detail_.Get(index);
}
inline ::nv::TE1Group* TE1Cfg::mutable_group_detail(int index) {
  return group_detail_.Mutable(index);
}
inline ::nv::TE1Group* TE1Cfg::add_group_detail() {
  return group_detail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TE1Group >&
TE1Cfg::group_detail() const {
  return group_detail_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TE1Group >*
TE1Cfg::mutable_group_detail() {
  return &group_detail_;
}

// -------------------------------------------------------------------

// TNVLocalDevInfo

// optional .nv.EmNvDevRegUpdateSer dev_type = 1;
inline bool TNVLocalDevInfo::has_dev_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVLocalDevInfo::set_has_dev_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVLocalDevInfo::clear_has_dev_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVLocalDevInfo::clear_dev_type() {
  dev_type_ = 0;
  clear_has_dev_type();
}
inline ::nv::EmNvDevRegUpdateSer TNVLocalDevInfo::dev_type() const {
  return static_cast< ::nv::EmNvDevRegUpdateSer >(dev_type_);
}
inline void TNVLocalDevInfo::set_dev_type(::nv::EmNvDevRegUpdateSer value) {
  assert(::nv::EmNvDevRegUpdateSer_IsValid(value));
  set_has_dev_type();
  dev_type_ = value;
}

// optional string dev_version = 2;
inline bool TNVLocalDevInfo::has_dev_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVLocalDevInfo::set_has_dev_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVLocalDevInfo::clear_has_dev_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVLocalDevInfo::clear_dev_version() {
  if (dev_version_ != &::google::protobuf::internal::kEmptyString) {
    dev_version_->clear();
  }
  clear_has_dev_version();
}
inline const ::std::string& TNVLocalDevInfo::dev_version() const {
  return *dev_version_;
}
inline void TNVLocalDevInfo::set_dev_version(const ::std::string& value) {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  dev_version_->assign(value);
}
inline void TNVLocalDevInfo::set_dev_version(const char* value) {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  dev_version_->assign(value);
}
inline void TNVLocalDevInfo::set_dev_version(const char* value, size_t size) {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  dev_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVLocalDevInfo::mutable_dev_version() {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  return dev_version_;
}
inline ::std::string* TNVLocalDevInfo::release_dev_version() {
  clear_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dev_version_;
    dev_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVLocalDevInfo::set_allocated_dev_version(::std::string* dev_version) {
  if (dev_version_ != &::google::protobuf::internal::kEmptyString) {
    delete dev_version_;
  }
  if (dev_version) {
    set_has_dev_version();
    dev_version_ = dev_version;
  } else {
    clear_has_dev_version();
    dev_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 instid = 3;
inline bool TNVLocalDevInfo::has_instid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVLocalDevInfo::set_has_instid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVLocalDevInfo::clear_has_instid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVLocalDevInfo::clear_instid() {
  instid_ = 0u;
  clear_has_instid();
}
inline ::google::protobuf::uint32 TNVLocalDevInfo::instid() const {
  return instid_;
}
inline void TNVLocalDevInfo::set_instid(::google::protobuf::uint32 value) {
  set_has_instid();
  instid_ = value;
}

// optional uint32 node = 4;
inline bool TNVLocalDevInfo::has_node() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVLocalDevInfo::set_has_node() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVLocalDevInfo::clear_has_node() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVLocalDevInfo::clear_node() {
  node_ = 0u;
  clear_has_node();
}
inline ::google::protobuf::uint32 TNVLocalDevInfo::node() const {
  return node_;
}
inline void TNVLocalDevInfo::set_node(::google::protobuf::uint32 value) {
  set_has_node();
  node_ = value;
}

// -------------------------------------------------------------------

// TNVDevUpdateCfg

// optional bool is_used = 1;
inline bool TNVDevUpdateCfg::has_is_used() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVDevUpdateCfg::set_has_is_used() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVDevUpdateCfg::clear_has_is_used() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVDevUpdateCfg::clear_is_used() {
  is_used_ = false;
  clear_has_is_used();
}
inline bool TNVDevUpdateCfg::is_used() const {
  return is_used_;
}
inline void TNVDevUpdateCfg::set_is_used(bool value) {
  set_has_is_used();
  is_used_ = value;
}

// optional .nv.EmNvDevRegUpdateSer dev_type = 2;
inline bool TNVDevUpdateCfg::has_dev_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVDevUpdateCfg::set_has_dev_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVDevUpdateCfg::clear_has_dev_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVDevUpdateCfg::clear_dev_type() {
  dev_type_ = 0;
  clear_has_dev_type();
}
inline ::nv::EmNvDevRegUpdateSer TNVDevUpdateCfg::dev_type() const {
  return static_cast< ::nv::EmNvDevRegUpdateSer >(dev_type_);
}
inline void TNVDevUpdateCfg::set_dev_type(::nv::EmNvDevRegUpdateSer value) {
  assert(::nv::EmNvDevRegUpdateSer_IsValid(value));
  set_has_dev_type();
  dev_type_ = value;
}

// optional .nv.EmNvUpdateType update_type = 3;
inline bool TNVDevUpdateCfg::has_update_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVDevUpdateCfg::set_has_update_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVDevUpdateCfg::clear_has_update_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVDevUpdateCfg::clear_update_type() {
  update_type_ = 0;
  clear_has_update_type();
}
inline ::nv::EmNvUpdateType TNVDevUpdateCfg::update_type() const {
  return static_cast< ::nv::EmNvUpdateType >(update_type_);
}
inline void TNVDevUpdateCfg::set_update_type(::nv::EmNvUpdateType value) {
  assert(::nv::EmNvUpdateType_IsValid(value));
  set_has_update_type();
  update_type_ = value;
}

// optional string dev_version = 4;
inline bool TNVDevUpdateCfg::has_dev_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVDevUpdateCfg::set_has_dev_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVDevUpdateCfg::clear_has_dev_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVDevUpdateCfg::clear_dev_version() {
  if (dev_version_ != &::google::protobuf::internal::kEmptyString) {
    dev_version_->clear();
  }
  clear_has_dev_version();
}
inline const ::std::string& TNVDevUpdateCfg::dev_version() const {
  return *dev_version_;
}
inline void TNVDevUpdateCfg::set_dev_version(const ::std::string& value) {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  dev_version_->assign(value);
}
inline void TNVDevUpdateCfg::set_dev_version(const char* value) {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  dev_version_->assign(value);
}
inline void TNVDevUpdateCfg::set_dev_version(const char* value, size_t size) {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  dev_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVDevUpdateCfg::mutable_dev_version() {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  return dev_version_;
}
inline ::std::string* TNVDevUpdateCfg::release_dev_version() {
  clear_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dev_version_;
    dev_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVDevUpdateCfg::set_allocated_dev_version(::std::string* dev_version) {
  if (dev_version_ != &::google::protobuf::internal::kEmptyString) {
    delete dev_version_;
  }
  if (dev_version) {
    set_has_dev_version();
    dev_version_ = dev_version;
  } else {
    clear_has_dev_version();
    dev_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string filename = 5;
inline bool TNVDevUpdateCfg::has_filename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVDevUpdateCfg::set_has_filename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVDevUpdateCfg::clear_has_filename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVDevUpdateCfg::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& TNVDevUpdateCfg::filename() const {
  return *filename_;
}
inline void TNVDevUpdateCfg::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TNVDevUpdateCfg::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TNVDevUpdateCfg::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVDevUpdateCfg::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* TNVDevUpdateCfg::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVDevUpdateCfg::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVDevCfgInfoList

// repeated .nv.TNVDevUpdateCfg tupdatecfg = 1;
inline int TNVDevCfgInfoList::tupdatecfg_size() const {
  return tupdatecfg_.size();
}
inline void TNVDevCfgInfoList::clear_tupdatecfg() {
  tupdatecfg_.Clear();
}
inline const ::nv::TNVDevUpdateCfg& TNVDevCfgInfoList::tupdatecfg(int index) const {
  return tupdatecfg_.Get(index);
}
inline ::nv::TNVDevUpdateCfg* TNVDevCfgInfoList::mutable_tupdatecfg(int index) {
  return tupdatecfg_.Mutable(index);
}
inline ::nv::TNVDevUpdateCfg* TNVDevCfgInfoList::add_tupdatecfg() {
  return tupdatecfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVDevUpdateCfg >&
TNVDevCfgInfoList::tupdatecfg() const {
  return tupdatecfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVDevUpdateCfg >*
TNVDevCfgInfoList::mutable_tupdatecfg() {
  return &tupdatecfg_;
}

// optional uint32 local_ip = 2;
inline bool TNVDevCfgInfoList::has_local_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVDevCfgInfoList::set_has_local_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVDevCfgInfoList::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVDevCfgInfoList::clear_local_ip() {
  local_ip_ = 0u;
  clear_has_local_ip();
}
inline ::google::protobuf::uint32 TNVDevCfgInfoList::local_ip() const {
  return local_ip_;
}
inline void TNVDevCfgInfoList::set_local_ip(::google::protobuf::uint32 value) {
  set_has_local_ip();
  local_ip_ = value;
}

// repeated .nv.TString imix_version = 3;
inline int TNVDevCfgInfoList::imix_version_size() const {
  return imix_version_.size();
}
inline void TNVDevCfgInfoList::clear_imix_version() {
  imix_version_.Clear();
}
inline const ::nv::TString& TNVDevCfgInfoList::imix_version(int index) const {
  return imix_version_.Get(index);
}
inline ::nv::TString* TNVDevCfgInfoList::mutable_imix_version(int index) {
  return imix_version_.Mutable(index);
}
inline ::nv::TString* TNVDevCfgInfoList::add_imix_version() {
  return imix_version_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TString >&
TNVDevCfgInfoList::imix_version() const {
  return imix_version_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TString >*
TNVDevCfgInfoList::mutable_imix_version() {
  return &imix_version_;
}

// repeated .nv.TString tpad_version = 4;
inline int TNVDevCfgInfoList::tpad_version_size() const {
  return tpad_version_.size();
}
inline void TNVDevCfgInfoList::clear_tpad_version() {
  tpad_version_.Clear();
}
inline const ::nv::TString& TNVDevCfgInfoList::tpad_version(int index) const {
  return tpad_version_.Get(index);
}
inline ::nv::TString* TNVDevCfgInfoList::mutable_tpad_version(int index) {
  return tpad_version_.Mutable(index);
}
inline ::nv::TString* TNVDevCfgInfoList::add_tpad_version() {
  return tpad_version_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TString >&
TNVDevCfgInfoList::tpad_version() const {
  return tpad_version_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TString >*
TNVDevCfgInfoList::mutable_tpad_version() {
  return &tpad_version_;
}

// -------------------------------------------------------------------

// TNVFTPFileInfo

// optional uint32 ser_ip = 1;
inline bool TNVFTPFileInfo::has_ser_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVFTPFileInfo::set_has_ser_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVFTPFileInfo::clear_has_ser_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVFTPFileInfo::clear_ser_ip() {
  ser_ip_ = 0u;
  clear_has_ser_ip();
}
inline ::google::protobuf::uint32 TNVFTPFileInfo::ser_ip() const {
  return ser_ip_;
}
inline void TNVFTPFileInfo::set_ser_ip(::google::protobuf::uint32 value) {
  set_has_ser_ip();
  ser_ip_ = value;
}

// optional uint32 ser_port = 2;
inline bool TNVFTPFileInfo::has_ser_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVFTPFileInfo::set_has_ser_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVFTPFileInfo::clear_has_ser_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVFTPFileInfo::clear_ser_port() {
  ser_port_ = 0u;
  clear_has_ser_port();
}
inline ::google::protobuf::uint32 TNVFTPFileInfo::ser_port() const {
  return ser_port_;
}
inline void TNVFTPFileInfo::set_ser_port(::google::protobuf::uint32 value) {
  set_has_ser_port();
  ser_port_ = value;
}

// optional string username = 3;
inline bool TNVFTPFileInfo::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVFTPFileInfo::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVFTPFileInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVFTPFileInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TNVFTPFileInfo::username() const {
  return *username_;
}
inline void TNVFTPFileInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TNVFTPFileInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TNVFTPFileInfo::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVFTPFileInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TNVFTPFileInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVFTPFileInfo::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 4;
inline bool TNVFTPFileInfo::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVFTPFileInfo::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVFTPFileInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVFTPFileInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& TNVFTPFileInfo::password() const {
  return *password_;
}
inline void TNVFTPFileInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVFTPFileInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void TNVFTPFileInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVFTPFileInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* TNVFTPFileInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVFTPFileInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string filepath = 5;
inline bool TNVFTPFileInfo::has_filepath() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVFTPFileInfo::set_has_filepath() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVFTPFileInfo::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVFTPFileInfo::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& TNVFTPFileInfo::filepath() const {
  return *filepath_;
}
inline void TNVFTPFileInfo::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void TNVFTPFileInfo::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void TNVFTPFileInfo::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVFTPFileInfo::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  return filepath_;
}
inline ::std::string* TNVFTPFileInfo::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVFTPFileInfo::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 filesize = 6;
inline bool TNVFTPFileInfo::has_filesize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVFTPFileInfo::set_has_filesize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVFTPFileInfo::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVFTPFileInfo::clear_filesize() {
  filesize_ = 0u;
  clear_has_filesize();
}
inline ::google::protobuf::uint32 TNVFTPFileInfo::filesize() const {
  return filesize_;
}
inline void TNVFTPFileInfo::set_filesize(::google::protobuf::uint32 value) {
  set_has_filesize();
  filesize_ = value;
}

// -------------------------------------------------------------------

// TNVDevUpgrade

// optional .nv.EmNvDevRegUpdateSer dev_type = 1;
inline bool TNVDevUpgrade::has_dev_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVDevUpgrade::set_has_dev_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVDevUpgrade::clear_has_dev_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVDevUpgrade::clear_dev_type() {
  dev_type_ = 0;
  clear_has_dev_type();
}
inline ::nv::EmNvDevRegUpdateSer TNVDevUpgrade::dev_type() const {
  return static_cast< ::nv::EmNvDevRegUpdateSer >(dev_type_);
}
inline void TNVDevUpgrade::set_dev_type(::nv::EmNvDevRegUpdateSer value) {
  assert(::nv::EmNvDevRegUpdateSer_IsValid(value));
  set_has_dev_type();
  dev_type_ = value;
}

// optional string dev_version = 2;
inline bool TNVDevUpgrade::has_dev_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVDevUpgrade::set_has_dev_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVDevUpgrade::clear_has_dev_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVDevUpgrade::clear_dev_version() {
  if (dev_version_ != &::google::protobuf::internal::kEmptyString) {
    dev_version_->clear();
  }
  clear_has_dev_version();
}
inline const ::std::string& TNVDevUpgrade::dev_version() const {
  return *dev_version_;
}
inline void TNVDevUpgrade::set_dev_version(const ::std::string& value) {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  dev_version_->assign(value);
}
inline void TNVDevUpgrade::set_dev_version(const char* value) {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  dev_version_->assign(value);
}
inline void TNVDevUpgrade::set_dev_version(const char* value, size_t size) {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  dev_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVDevUpgrade::mutable_dev_version() {
  set_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    dev_version_ = new ::std::string;
  }
  return dev_version_;
}
inline ::std::string* TNVDevUpgrade::release_dev_version() {
  clear_has_dev_version();
  if (dev_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dev_version_;
    dev_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVDevUpgrade::set_allocated_dev_version(::std::string* dev_version) {
  if (dev_version_ != &::google::protobuf::internal::kEmptyString) {
    delete dev_version_;
  }
  if (dev_version) {
    set_has_dev_version();
    dev_version_ = dev_version;
  } else {
    clear_has_dev_version();
    dev_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.TNVFTPFileInfo tftpinfo = 3;
inline bool TNVDevUpgrade::has_tftpinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVDevUpgrade::set_has_tftpinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVDevUpgrade::clear_has_tftpinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVDevUpgrade::clear_tftpinfo() {
  if (tftpinfo_ != NULL) tftpinfo_->::nv::TNVFTPFileInfo::Clear();
  clear_has_tftpinfo();
}
inline const ::nv::TNVFTPFileInfo& TNVDevUpgrade::tftpinfo() const {
  return tftpinfo_ != NULL ? *tftpinfo_ : *default_instance_->tftpinfo_;
}
inline ::nv::TNVFTPFileInfo* TNVDevUpgrade::mutable_tftpinfo() {
  set_has_tftpinfo();
  if (tftpinfo_ == NULL) tftpinfo_ = new ::nv::TNVFTPFileInfo;
  return tftpinfo_;
}
inline ::nv::TNVFTPFileInfo* TNVDevUpgrade::release_tftpinfo() {
  clear_has_tftpinfo();
  ::nv::TNVFTPFileInfo* temp = tftpinfo_;
  tftpinfo_ = NULL;
  return temp;
}
inline void TNVDevUpgrade::set_allocated_tftpinfo(::nv::TNVFTPFileInfo* tftpinfo) {
  delete tftpinfo_;
  tftpinfo_ = tftpinfo;
  if (tftpinfo) {
    set_has_tftpinfo();
  } else {
    clear_has_tftpinfo();
  }
}

// optional .nv.EmNvUpdateType update_type = 4;
inline bool TNVDevUpgrade::has_update_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVDevUpgrade::set_has_update_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVDevUpgrade::clear_has_update_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVDevUpgrade::clear_update_type() {
  update_type_ = 0;
  clear_has_update_type();
}
inline ::nv::EmNvUpdateType TNVDevUpgrade::update_type() const {
  return static_cast< ::nv::EmNvUpdateType >(update_type_);
}
inline void TNVDevUpgrade::set_update_type(::nv::EmNvUpdateType value) {
  assert(::nv::EmNvUpdateType_IsValid(value));
  set_has_update_type();
  update_type_ = value;
}

// repeated .nv.TString version_info = 5;
inline int TNVDevUpgrade::version_info_size() const {
  return version_info_.size();
}
inline void TNVDevUpgrade::clear_version_info() {
  version_info_.Clear();
}
inline const ::nv::TString& TNVDevUpgrade::version_info(int index) const {
  return version_info_.Get(index);
}
inline ::nv::TString* TNVDevUpgrade::mutable_version_info(int index) {
  return version_info_.Mutable(index);
}
inline ::nv::TString* TNVDevUpgrade::add_version_info() {
  return version_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TString >&
TNVDevUpgrade::version_info() const {
  return version_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TString >*
TNVDevUpgrade::mutable_version_info() {
  return &version_info_;
}

// -------------------------------------------------------------------

// TNVUpGradeConnectInfo

// optional string mt_ip = 1;
inline bool TNVUpGradeConnectInfo::has_mt_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUpGradeConnectInfo::set_has_mt_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUpGradeConnectInfo::clear_has_mt_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUpGradeConnectInfo::clear_mt_ip() {
  if (mt_ip_ != &::google::protobuf::internal::kEmptyString) {
    mt_ip_->clear();
  }
  clear_has_mt_ip();
}
inline const ::std::string& TNVUpGradeConnectInfo::mt_ip() const {
  return *mt_ip_;
}
inline void TNVUpGradeConnectInfo::set_mt_ip(const ::std::string& value) {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  mt_ip_->assign(value);
}
inline void TNVUpGradeConnectInfo::set_mt_ip(const char* value) {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  mt_ip_->assign(value);
}
inline void TNVUpGradeConnectInfo::set_mt_ip(const char* value, size_t size) {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  mt_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVUpGradeConnectInfo::mutable_mt_ip() {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  return mt_ip_;
}
inline ::std::string* TNVUpGradeConnectInfo::release_mt_ip() {
  clear_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mt_ip_;
    mt_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVUpGradeConnectInfo::set_allocated_mt_ip(::std::string* mt_ip) {
  if (mt_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete mt_ip_;
  }
  if (mt_ip) {
    set_has_mt_ip();
    mt_ip_ = mt_ip;
  } else {
    clear_has_mt_ip();
    mt_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 listen_port = 2;
inline bool TNVUpGradeConnectInfo::has_listen_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUpGradeConnectInfo::set_has_listen_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUpGradeConnectInfo::clear_has_listen_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUpGradeConnectInfo::clear_listen_port() {
  listen_port_ = 0u;
  clear_has_listen_port();
}
inline ::google::protobuf::uint32 TNVUpGradeConnectInfo::listen_port() const {
  return listen_port_;
}
inline void TNVUpGradeConnectInfo::set_listen_port(::google::protobuf::uint32 value) {
  set_has_listen_port();
  listen_port_ = value;
}

// -------------------------------------------------------------------

// TNVUpgradePackageContent

// optional bool is_has_app_package = 1;
inline bool TNVUpgradePackageContent::has_is_has_app_package() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVUpgradePackageContent::set_has_is_has_app_package() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVUpgradePackageContent::clear_has_is_has_app_package() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVUpgradePackageContent::clear_is_has_app_package() {
  is_has_app_package_ = false;
  clear_has_is_has_app_package();
}
inline bool TNVUpgradePackageContent::is_has_app_package() const {
  return is_has_app_package_;
}
inline void TNVUpgradePackageContent::set_is_has_app_package(bool value) {
  set_has_is_has_app_package();
  is_has_app_package_ = value;
}

// optional bool is_has_imix_package = 2;
inline bool TNVUpgradePackageContent::has_is_has_imix_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVUpgradePackageContent::set_has_is_has_imix_package() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVUpgradePackageContent::clear_has_is_has_imix_package() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVUpgradePackageContent::clear_is_has_imix_package() {
  is_has_imix_package_ = false;
  clear_has_is_has_imix_package();
}
inline bool TNVUpgradePackageContent::is_has_imix_package() const {
  return is_has_imix_package_;
}
inline void TNVUpgradePackageContent::set_is_has_imix_package(bool value) {
  set_has_is_has_imix_package();
  is_has_imix_package_ = value;
}

// -------------------------------------------------------------------

// TNVCfgMtSystemTime

// optional bool bSyncServer = 1;
inline bool TNVCfgMtSystemTime::has_bsyncserver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVCfgMtSystemTime::set_has_bsyncserver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVCfgMtSystemTime::clear_has_bsyncserver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVCfgMtSystemTime::clear_bsyncserver() {
  bsyncserver_ = false;
  clear_has_bsyncserver();
}
inline bool TNVCfgMtSystemTime::bsyncserver() const {
  return bsyncserver_;
}
inline void TNVCfgMtSystemTime::set_bsyncserver(bool value) {
  set_has_bsyncserver();
  bsyncserver_ = value;
}

// optional .nv.EmNvTimeZone emTimeZone = 2;
inline bool TNVCfgMtSystemTime::has_emtimezone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVCfgMtSystemTime::set_has_emtimezone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVCfgMtSystemTime::clear_has_emtimezone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVCfgMtSystemTime::clear_emtimezone() {
  emtimezone_ = 0;
  clear_has_emtimezone();
}
inline ::nv::EmNvTimeZone TNVCfgMtSystemTime::emtimezone() const {
  return static_cast< ::nv::EmNvTimeZone >(emtimezone_);
}
inline void TNVCfgMtSystemTime::set_emtimezone(::nv::EmNvTimeZone value) {
  assert(::nv::EmNvTimeZone_IsValid(value));
  set_has_emtimezone();
  emtimezone_ = value;
}

// -------------------------------------------------------------------

// TNVFtpLoginInfo

// optional .nv.TNVUserFullInfo login_info = 1;
inline bool TNVFtpLoginInfo::has_login_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVFtpLoginInfo::set_has_login_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVFtpLoginInfo::clear_has_login_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVFtpLoginInfo::clear_login_info() {
  if (login_info_ != NULL) login_info_->::nv::TNVUserFullInfo::Clear();
  clear_has_login_info();
}
inline const ::nv::TNVUserFullInfo& TNVFtpLoginInfo::login_info() const {
  return login_info_ != NULL ? *login_info_ : *default_instance_->login_info_;
}
inline ::nv::TNVUserFullInfo* TNVFtpLoginInfo::mutable_login_info() {
  set_has_login_info();
  if (login_info_ == NULL) login_info_ = new ::nv::TNVUserFullInfo;
  return login_info_;
}
inline ::nv::TNVUserFullInfo* TNVFtpLoginInfo::release_login_info() {
  clear_has_login_info();
  ::nv::TNVUserFullInfo* temp = login_info_;
  login_info_ = NULL;
  return temp;
}
inline void TNVFtpLoginInfo::set_allocated_login_info(::nv::TNVUserFullInfo* login_info) {
  delete login_info_;
  login_info_ = login_info;
  if (login_info) {
    set_has_login_info();
  } else {
    clear_has_login_info();
  }
}

// optional bool bopen_ftp = 2;
inline bool TNVFtpLoginInfo::has_bopen_ftp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVFtpLoginInfo::set_has_bopen_ftp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVFtpLoginInfo::clear_has_bopen_ftp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVFtpLoginInfo::clear_bopen_ftp() {
  bopen_ftp_ = false;
  clear_has_bopen_ftp();
}
inline bool TNVFtpLoginInfo::bopen_ftp() const {
  return bopen_ftp_;
}
inline void TNVFtpLoginInfo::set_bopen_ftp(bool value) {
  set_has_bopen_ftp();
  bopen_ftp_ = value;
}

// optional uint32 node = 3;
inline bool TNVFtpLoginInfo::has_node() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVFtpLoginInfo::set_has_node() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVFtpLoginInfo::clear_has_node() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVFtpLoginInfo::clear_node() {
  node_ = 0u;
  clear_has_node();
}
inline ::google::protobuf::uint32 TNVFtpLoginInfo::node() const {
  return node_;
}
inline void TNVFtpLoginInfo::set_node(::google::protobuf::uint32 value) {
  set_has_node();
  node_ = value;
}

// -------------------------------------------------------------------

// TNVFtpLoginInfos

// repeated .nv.TNVFtpLoginInfo login_info_list = 1;
inline int TNVFtpLoginInfos::login_info_list_size() const {
  return login_info_list_.size();
}
inline void TNVFtpLoginInfos::clear_login_info_list() {
  login_info_list_.Clear();
}
inline const ::nv::TNVFtpLoginInfo& TNVFtpLoginInfos::login_info_list(int index) const {
  return login_info_list_.Get(index);
}
inline ::nv::TNVFtpLoginInfo* TNVFtpLoginInfos::mutable_login_info_list(int index) {
  return login_info_list_.Mutable(index);
}
inline ::nv::TNVFtpLoginInfo* TNVFtpLoginInfos::add_login_info_list() {
  return login_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVFtpLoginInfo >&
TNVFtpLoginInfos::login_info_list() const {
  return login_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVFtpLoginInfo >*
TNVFtpLoginInfos::mutable_login_info_list() {
  return &login_info_list_;
}

// optional uint32 open_count = 2;
inline bool TNVFtpLoginInfos::has_open_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVFtpLoginInfos::set_has_open_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVFtpLoginInfos::clear_has_open_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVFtpLoginInfos::clear_open_count() {
  open_count_ = 0u;
  clear_has_open_count();
}
inline ::google::protobuf::uint32 TNVFtpLoginInfos::open_count() const {
  return open_count_;
}
inline void TNVFtpLoginInfos::set_open_count(::google::protobuf::uint32 value) {
  set_has_open_count();
  open_count_ = value;
}

// -------------------------------------------------------------------

// TNVTerminalName

// optional string ter_e164 = 1;
inline bool TNVTerminalName::has_ter_e164() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVTerminalName::set_has_ter_e164() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVTerminalName::clear_has_ter_e164() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVTerminalName::clear_ter_e164() {
  if (ter_e164_ != &::google::protobuf::internal::kEmptyString) {
    ter_e164_->clear();
  }
  clear_has_ter_e164();
}
inline const ::std::string& TNVTerminalName::ter_e164() const {
  return *ter_e164_;
}
inline void TNVTerminalName::set_ter_e164(const ::std::string& value) {
  set_has_ter_e164();
  if (ter_e164_ == &::google::protobuf::internal::kEmptyString) {
    ter_e164_ = new ::std::string;
  }
  ter_e164_->assign(value);
}
inline void TNVTerminalName::set_ter_e164(const char* value) {
  set_has_ter_e164();
  if (ter_e164_ == &::google::protobuf::internal::kEmptyString) {
    ter_e164_ = new ::std::string;
  }
  ter_e164_->assign(value);
}
inline void TNVTerminalName::set_ter_e164(const char* value, size_t size) {
  set_has_ter_e164();
  if (ter_e164_ == &::google::protobuf::internal::kEmptyString) {
    ter_e164_ = new ::std::string;
  }
  ter_e164_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVTerminalName::mutable_ter_e164() {
  set_has_ter_e164();
  if (ter_e164_ == &::google::protobuf::internal::kEmptyString) {
    ter_e164_ = new ::std::string;
  }
  return ter_e164_;
}
inline ::std::string* TNVTerminalName::release_ter_e164() {
  clear_has_ter_e164();
  if (ter_e164_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ter_e164_;
    ter_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVTerminalName::set_allocated_ter_e164(::std::string* ter_e164) {
  if (ter_e164_ != &::google::protobuf::internal::kEmptyString) {
    delete ter_e164_;
  }
  if (ter_e164) {
    set_has_ter_e164();
    ter_e164_ = ter_e164;
  } else {
    clear_has_ter_e164();
    ter_e164_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ter_alias = 2;
inline bool TNVTerminalName::has_ter_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVTerminalName::set_has_ter_alias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVTerminalName::clear_has_ter_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVTerminalName::clear_ter_alias() {
  if (ter_alias_ != &::google::protobuf::internal::kEmptyString) {
    ter_alias_->clear();
  }
  clear_has_ter_alias();
}
inline const ::std::string& TNVTerminalName::ter_alias() const {
  return *ter_alias_;
}
inline void TNVTerminalName::set_ter_alias(const ::std::string& value) {
  set_has_ter_alias();
  if (ter_alias_ == &::google::protobuf::internal::kEmptyString) {
    ter_alias_ = new ::std::string;
  }
  ter_alias_->assign(value);
}
inline void TNVTerminalName::set_ter_alias(const char* value) {
  set_has_ter_alias();
  if (ter_alias_ == &::google::protobuf::internal::kEmptyString) {
    ter_alias_ = new ::std::string;
  }
  ter_alias_->assign(value);
}
inline void TNVTerminalName::set_ter_alias(const char* value, size_t size) {
  set_has_ter_alias();
  if (ter_alias_ == &::google::protobuf::internal::kEmptyString) {
    ter_alias_ = new ::std::string;
  }
  ter_alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVTerminalName::mutable_ter_alias() {
  set_has_ter_alias();
  if (ter_alias_ == &::google::protobuf::internal::kEmptyString) {
    ter_alias_ = new ::std::string;
  }
  return ter_alias_;
}
inline ::std::string* TNVTerminalName::release_ter_alias() {
  clear_has_ter_alias();
  if (ter_alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ter_alias_;
    ter_alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVTerminalName::set_allocated_ter_alias(::std::string* ter_alias) {
  if (ter_alias_ != &::google::protobuf::internal::kEmptyString) {
    delete ter_alias_;
  }
  if (ter_alias) {
    set_has_ter_alias();
    ter_alias_ = ter_alias;
  } else {
    clear_has_ter_alias();
    ter_alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TNVMiniVidInfo

// optional bool open = 1;
inline bool TNVMiniVidInfo::has_open() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMiniVidInfo::set_has_open() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMiniVidInfo::clear_has_open() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMiniVidInfo::clear_open() {
  open_ = false;
  clear_has_open();
}
inline bool TNVMiniVidInfo::open() const {
  return open_;
}
inline void TNVMiniVidInfo::set_open(bool value) {
  set_has_open();
  open_ = value;
}

// optional bool full = 2;
inline bool TNVMiniVidInfo::has_full() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMiniVidInfo::set_has_full() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMiniVidInfo::clear_has_full() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMiniVidInfo::clear_full() {
  full_ = false;
  clear_has_full();
}
inline bool TNVMiniVidInfo::full() const {
  return full_;
}
inline void TNVMiniVidInfo::set_full(bool value) {
  set_has_full();
  full_ = value;
}

// optional .nv.EmNvMiniVidPos pos = 3;
inline bool TNVMiniVidInfo::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVMiniVidInfo::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVMiniVidInfo::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVMiniVidInfo::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::nv::EmNvMiniVidPos TNVMiniVidInfo::pos() const {
  return static_cast< ::nv::EmNvMiniVidPos >(pos_);
}
inline void TNVMiniVidInfo::set_pos(::nv::EmNvMiniVidPos value) {
  assert(::nv::EmNvMiniVidPos_IsValid(value));
  set_has_pos();
  pos_ = value;
}

// optional uint32 flag = 4;
inline bool TNVMiniVidInfo::has_flag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVMiniVidInfo::set_has_flag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVMiniVidInfo::clear_has_flag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVMiniVidInfo::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::flag() const {
  return flag_;
}
inline void TNVMiniVidInfo::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
}

// optional uint32 start_x = 5;
inline bool TNVMiniVidInfo::has_start_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVMiniVidInfo::set_has_start_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVMiniVidInfo::clear_has_start_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVMiniVidInfo::clear_start_x() {
  start_x_ = 0u;
  clear_has_start_x();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::start_x() const {
  return start_x_;
}
inline void TNVMiniVidInfo::set_start_x(::google::protobuf::uint32 value) {
  set_has_start_x();
  start_x_ = value;
}

// optional uint32 start_y = 6;
inline bool TNVMiniVidInfo::has_start_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVMiniVidInfo::set_has_start_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVMiniVidInfo::clear_has_start_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVMiniVidInfo::clear_start_y() {
  start_y_ = 0u;
  clear_has_start_y();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::start_y() const {
  return start_y_;
}
inline void TNVMiniVidInfo::set_start_y(::google::protobuf::uint32 value) {
  set_has_start_y();
  start_y_ = value;
}

// optional uint32 height = 7;
inline bool TNVMiniVidInfo::has_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVMiniVidInfo::set_has_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVMiniVidInfo::clear_has_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVMiniVidInfo::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::height() const {
  return height_;
}
inline void TNVMiniVidInfo::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// optional uint32 width = 8;
inline bool TNVMiniVidInfo::has_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVMiniVidInfo::set_has_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVMiniVidInfo::clear_has_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVMiniVidInfo::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::width() const {
  return width_;
}
inline void TNVMiniVidInfo::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional uint32 prohibit_start_x = 9;
inline bool TNVMiniVidInfo::has_prohibit_start_x() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_start_x() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_start_x() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TNVMiniVidInfo::clear_prohibit_start_x() {
  prohibit_start_x_ = 0u;
  clear_has_prohibit_start_x();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_start_x() const {
  return prohibit_start_x_;
}
inline void TNVMiniVidInfo::set_prohibit_start_x(::google::protobuf::uint32 value) {
  set_has_prohibit_start_x();
  prohibit_start_x_ = value;
}

// optional uint32 prohibit_start_y = 10;
inline bool TNVMiniVidInfo::has_prohibit_start_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_start_y() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_start_y() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TNVMiniVidInfo::clear_prohibit_start_y() {
  prohibit_start_y_ = 0u;
  clear_has_prohibit_start_y();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_start_y() const {
  return prohibit_start_y_;
}
inline void TNVMiniVidInfo::set_prohibit_start_y(::google::protobuf::uint32 value) {
  set_has_prohibit_start_y();
  prohibit_start_y_ = value;
}

// optional uint32 prohibit_end_x = 11;
inline bool TNVMiniVidInfo::has_prohibit_end_x() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_end_x() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_end_x() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TNVMiniVidInfo::clear_prohibit_end_x() {
  prohibit_end_x_ = 0u;
  clear_has_prohibit_end_x();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_end_x() const {
  return prohibit_end_x_;
}
inline void TNVMiniVidInfo::set_prohibit_end_x(::google::protobuf::uint32 value) {
  set_has_prohibit_end_x();
  prohibit_end_x_ = value;
}

// optional uint32 prohibit_end_y = 12;
inline bool TNVMiniVidInfo::has_prohibit_end_y() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_end_y() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_end_y() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TNVMiniVidInfo::clear_prohibit_end_y() {
  prohibit_end_y_ = 0u;
  clear_has_prohibit_end_y();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_end_y() const {
  return prohibit_end_y_;
}
inline void TNVMiniVidInfo::set_prohibit_end_y(::google::protobuf::uint32 value) {
  set_has_prohibit_end_y();
  prohibit_end_y_ = value;
}

// optional uint32 prohibit_start_x_2 = 13;
inline bool TNVMiniVidInfo::has_prohibit_start_x_2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_start_x_2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_start_x_2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TNVMiniVidInfo::clear_prohibit_start_x_2() {
  prohibit_start_x_2_ = 0u;
  clear_has_prohibit_start_x_2();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_start_x_2() const {
  return prohibit_start_x_2_;
}
inline void TNVMiniVidInfo::set_prohibit_start_x_2(::google::protobuf::uint32 value) {
  set_has_prohibit_start_x_2();
  prohibit_start_x_2_ = value;
}

// optional uint32 prohibit_start_y_2 = 14;
inline bool TNVMiniVidInfo::has_prohibit_start_y_2() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_start_y_2() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_start_y_2() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TNVMiniVidInfo::clear_prohibit_start_y_2() {
  prohibit_start_y_2_ = 0u;
  clear_has_prohibit_start_y_2();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_start_y_2() const {
  return prohibit_start_y_2_;
}
inline void TNVMiniVidInfo::set_prohibit_start_y_2(::google::protobuf::uint32 value) {
  set_has_prohibit_start_y_2();
  prohibit_start_y_2_ = value;
}

// optional uint32 prohibit_end_x_2 = 15;
inline bool TNVMiniVidInfo::has_prohibit_end_x_2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_end_x_2() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_end_x_2() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TNVMiniVidInfo::clear_prohibit_end_x_2() {
  prohibit_end_x_2_ = 0u;
  clear_has_prohibit_end_x_2();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_end_x_2() const {
  return prohibit_end_x_2_;
}
inline void TNVMiniVidInfo::set_prohibit_end_x_2(::google::protobuf::uint32 value) {
  set_has_prohibit_end_x_2();
  prohibit_end_x_2_ = value;
}

// optional uint32 prohibit_end_y_2 = 16;
inline bool TNVMiniVidInfo::has_prohibit_end_y_2() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_end_y_2() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_end_y_2() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TNVMiniVidInfo::clear_prohibit_end_y_2() {
  prohibit_end_y_2_ = 0u;
  clear_has_prohibit_end_y_2();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_end_y_2() const {
  return prohibit_end_y_2_;
}
inline void TNVMiniVidInfo::set_prohibit_end_y_2(::google::protobuf::uint32 value) {
  set_has_prohibit_end_y_2();
  prohibit_end_y_2_ = value;
}

// optional uint32 prohibit_start_x_3 = 17;
inline bool TNVMiniVidInfo::has_prohibit_start_x_3() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_start_x_3() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_start_x_3() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TNVMiniVidInfo::clear_prohibit_start_x_3() {
  prohibit_start_x_3_ = 0u;
  clear_has_prohibit_start_x_3();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_start_x_3() const {
  return prohibit_start_x_3_;
}
inline void TNVMiniVidInfo::set_prohibit_start_x_3(::google::protobuf::uint32 value) {
  set_has_prohibit_start_x_3();
  prohibit_start_x_3_ = value;
}

// optional uint32 prohibit_start_y_3 = 18;
inline bool TNVMiniVidInfo::has_prohibit_start_y_3() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_start_y_3() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_start_y_3() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TNVMiniVidInfo::clear_prohibit_start_y_3() {
  prohibit_start_y_3_ = 0u;
  clear_has_prohibit_start_y_3();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_start_y_3() const {
  return prohibit_start_y_3_;
}
inline void TNVMiniVidInfo::set_prohibit_start_y_3(::google::protobuf::uint32 value) {
  set_has_prohibit_start_y_3();
  prohibit_start_y_3_ = value;
}

// optional uint32 prohibit_end_x_3 = 19;
inline bool TNVMiniVidInfo::has_prohibit_end_x_3() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_end_x_3() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_end_x_3() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TNVMiniVidInfo::clear_prohibit_end_x_3() {
  prohibit_end_x_3_ = 0u;
  clear_has_prohibit_end_x_3();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_end_x_3() const {
  return prohibit_end_x_3_;
}
inline void TNVMiniVidInfo::set_prohibit_end_x_3(::google::protobuf::uint32 value) {
  set_has_prohibit_end_x_3();
  prohibit_end_x_3_ = value;
}

// optional uint32 prohibit_end_y_3 = 20;
inline bool TNVMiniVidInfo::has_prohibit_end_y_3() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_end_y_3() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_end_y_3() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TNVMiniVidInfo::clear_prohibit_end_y_3() {
  prohibit_end_y_3_ = 0u;
  clear_has_prohibit_end_y_3();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_end_y_3() const {
  return prohibit_end_y_3_;
}
inline void TNVMiniVidInfo::set_prohibit_end_y_3(::google::protobuf::uint32 value) {
  set_has_prohibit_end_y_3();
  prohibit_end_y_3_ = value;
}

// optional uint32 prohibit_start_x_4 = 21;
inline bool TNVMiniVidInfo::has_prohibit_start_x_4() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_start_x_4() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_start_x_4() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TNVMiniVidInfo::clear_prohibit_start_x_4() {
  prohibit_start_x_4_ = 0u;
  clear_has_prohibit_start_x_4();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_start_x_4() const {
  return prohibit_start_x_4_;
}
inline void TNVMiniVidInfo::set_prohibit_start_x_4(::google::protobuf::uint32 value) {
  set_has_prohibit_start_x_4();
  prohibit_start_x_4_ = value;
}

// optional uint32 prohibit_start_y_4 = 22;
inline bool TNVMiniVidInfo::has_prohibit_start_y_4() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_start_y_4() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_start_y_4() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TNVMiniVidInfo::clear_prohibit_start_y_4() {
  prohibit_start_y_4_ = 0u;
  clear_has_prohibit_start_y_4();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_start_y_4() const {
  return prohibit_start_y_4_;
}
inline void TNVMiniVidInfo::set_prohibit_start_y_4(::google::protobuf::uint32 value) {
  set_has_prohibit_start_y_4();
  prohibit_start_y_4_ = value;
}

// optional uint32 prohibit_end_x_4 = 23;
inline bool TNVMiniVidInfo::has_prohibit_end_x_4() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_end_x_4() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_end_x_4() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TNVMiniVidInfo::clear_prohibit_end_x_4() {
  prohibit_end_x_4_ = 0u;
  clear_has_prohibit_end_x_4();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_end_x_4() const {
  return prohibit_end_x_4_;
}
inline void TNVMiniVidInfo::set_prohibit_end_x_4(::google::protobuf::uint32 value) {
  set_has_prohibit_end_x_4();
  prohibit_end_x_4_ = value;
}

// optional uint32 prohibit_end_y_4 = 24;
inline bool TNVMiniVidInfo::has_prohibit_end_y_4() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TNVMiniVidInfo::set_has_prohibit_end_y_4() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TNVMiniVidInfo::clear_has_prohibit_end_y_4() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TNVMiniVidInfo::clear_prohibit_end_y_4() {
  prohibit_end_y_4_ = 0u;
  clear_has_prohibit_end_y_4();
}
inline ::google::protobuf::uint32 TNVMiniVidInfo::prohibit_end_y_4() const {
  return prohibit_end_y_4_;
}
inline void TNVMiniVidInfo::set_prohibit_end_y_4(::google::protobuf::uint32 value) {
  set_has_prohibit_end_y_4();
  prohibit_end_y_4_ = value;
}

// -------------------------------------------------------------------

// TNVImixVerInfo

// optional string mt_ver = 1;
inline bool TNVImixVerInfo::has_mt_ver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVImixVerInfo::set_has_mt_ver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVImixVerInfo::clear_has_mt_ver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVImixVerInfo::clear_mt_ver() {
  if (mt_ver_ != &::google::protobuf::internal::kEmptyString) {
    mt_ver_->clear();
  }
  clear_has_mt_ver();
}
inline const ::std::string& TNVImixVerInfo::mt_ver() const {
  return *mt_ver_;
}
inline void TNVImixVerInfo::set_mt_ver(const ::std::string& value) {
  set_has_mt_ver();
  if (mt_ver_ == &::google::protobuf::internal::kEmptyString) {
    mt_ver_ = new ::std::string;
  }
  mt_ver_->assign(value);
}
inline void TNVImixVerInfo::set_mt_ver(const char* value) {
  set_has_mt_ver();
  if (mt_ver_ == &::google::protobuf::internal::kEmptyString) {
    mt_ver_ = new ::std::string;
  }
  mt_ver_->assign(value);
}
inline void TNVImixVerInfo::set_mt_ver(const char* value, size_t size) {
  set_has_mt_ver();
  if (mt_ver_ == &::google::protobuf::internal::kEmptyString) {
    mt_ver_ = new ::std::string;
  }
  mt_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVImixVerInfo::mutable_mt_ver() {
  set_has_mt_ver();
  if (mt_ver_ == &::google::protobuf::internal::kEmptyString) {
    mt_ver_ = new ::std::string;
  }
  return mt_ver_;
}
inline ::std::string* TNVImixVerInfo::release_mt_ver() {
  clear_has_mt_ver();
  if (mt_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mt_ver_;
    mt_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVImixVerInfo::set_allocated_mt_ver(::std::string* mt_ver) {
  if (mt_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete mt_ver_;
  }
  if (mt_ver) {
    set_has_mt_ver();
    mt_ver_ = mt_ver;
  } else {
    clear_has_mt_ver();
    mt_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string power_ver = 2;
inline bool TNVImixVerInfo::has_power_ver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVImixVerInfo::set_has_power_ver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVImixVerInfo::clear_has_power_ver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVImixVerInfo::clear_power_ver() {
  if (power_ver_ != &::google::protobuf::internal::kEmptyString) {
    power_ver_->clear();
  }
  clear_has_power_ver();
}
inline const ::std::string& TNVImixVerInfo::power_ver() const {
  return *power_ver_;
}
inline void TNVImixVerInfo::set_power_ver(const ::std::string& value) {
  set_has_power_ver();
  if (power_ver_ == &::google::protobuf::internal::kEmptyString) {
    power_ver_ = new ::std::string;
  }
  power_ver_->assign(value);
}
inline void TNVImixVerInfo::set_power_ver(const char* value) {
  set_has_power_ver();
  if (power_ver_ == &::google::protobuf::internal::kEmptyString) {
    power_ver_ = new ::std::string;
  }
  power_ver_->assign(value);
}
inline void TNVImixVerInfo::set_power_ver(const char* value, size_t size) {
  set_has_power_ver();
  if (power_ver_ == &::google::protobuf::internal::kEmptyString) {
    power_ver_ = new ::std::string;
  }
  power_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVImixVerInfo::mutable_power_ver() {
  set_has_power_ver();
  if (power_ver_ == &::google::protobuf::internal::kEmptyString) {
    power_ver_ = new ::std::string;
  }
  return power_ver_;
}
inline ::std::string* TNVImixVerInfo::release_power_ver() {
  clear_has_power_ver();
  if (power_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = power_ver_;
    power_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVImixVerInfo::set_allocated_power_ver(::std::string* power_ver) {
  if (power_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete power_ver_;
  }
  if (power_ver) {
    set_has_power_ver();
    power_ver_ = power_ver;
  } else {
    clear_has_power_ver();
    power_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string imix_mode = 3;
inline bool TNVImixVerInfo::has_imix_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVImixVerInfo::set_has_imix_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVImixVerInfo::clear_has_imix_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVImixVerInfo::clear_imix_mode() {
  if (imix_mode_ != &::google::protobuf::internal::kEmptyString) {
    imix_mode_->clear();
  }
  clear_has_imix_mode();
}
inline const ::std::string& TNVImixVerInfo::imix_mode() const {
  return *imix_mode_;
}
inline void TNVImixVerInfo::set_imix_mode(const ::std::string& value) {
  set_has_imix_mode();
  if (imix_mode_ == &::google::protobuf::internal::kEmptyString) {
    imix_mode_ = new ::std::string;
  }
  imix_mode_->assign(value);
}
inline void TNVImixVerInfo::set_imix_mode(const char* value) {
  set_has_imix_mode();
  if (imix_mode_ == &::google::protobuf::internal::kEmptyString) {
    imix_mode_ = new ::std::string;
  }
  imix_mode_->assign(value);
}
inline void TNVImixVerInfo::set_imix_mode(const char* value, size_t size) {
  set_has_imix_mode();
  if (imix_mode_ == &::google::protobuf::internal::kEmptyString) {
    imix_mode_ = new ::std::string;
  }
  imix_mode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVImixVerInfo::mutable_imix_mode() {
  set_has_imix_mode();
  if (imix_mode_ == &::google::protobuf::internal::kEmptyString) {
    imix_mode_ = new ::std::string;
  }
  return imix_mode_;
}
inline ::std::string* TNVImixVerInfo::release_imix_mode() {
  clear_has_imix_mode();
  if (imix_mode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imix_mode_;
    imix_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVImixVerInfo::set_allocated_imix_mode(::std::string* imix_mode) {
  if (imix_mode_ != &::google::protobuf::internal::kEmptyString) {
    delete imix_mode_;
  }
  if (imix_mode) {
    set_has_imix_mode();
    imix_mode_ = imix_mode;
  } else {
    clear_has_imix_mode();
    imix_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .nv.TNVQkVer qk_ver = 4;
inline int TNVImixVerInfo::qk_ver_size() const {
  return qk_ver_.size();
}
inline void TNVImixVerInfo::clear_qk_ver() {
  qk_ver_.Clear();
}
inline const ::nv::TNVQkVer& TNVImixVerInfo::qk_ver(int index) const {
  return qk_ver_.Get(index);
}
inline ::nv::TNVQkVer* TNVImixVerInfo::mutable_qk_ver(int index) {
  return qk_ver_.Mutable(index);
}
inline ::nv::TNVQkVer* TNVImixVerInfo::add_qk_ver() {
  return qk_ver_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVQkVer >&
TNVImixVerInfo::qk_ver() const {
  return qk_ver_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVQkVer >*
TNVImixVerInfo::mutable_qk_ver() {
  return &qk_ver_;
}

// -------------------------------------------------------------------

// TNVHWInfo

// optional string mode_name = 1;
inline bool TNVHWInfo::has_mode_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVHWInfo::set_has_mode_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVHWInfo::clear_has_mode_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVHWInfo::clear_mode_name() {
  if (mode_name_ != &::google::protobuf::internal::kEmptyString) {
    mode_name_->clear();
  }
  clear_has_mode_name();
}
inline const ::std::string& TNVHWInfo::mode_name() const {
  return *mode_name_;
}
inline void TNVHWInfo::set_mode_name(const ::std::string& value) {
  set_has_mode_name();
  if (mode_name_ == &::google::protobuf::internal::kEmptyString) {
    mode_name_ = new ::std::string;
  }
  mode_name_->assign(value);
}
inline void TNVHWInfo::set_mode_name(const char* value) {
  set_has_mode_name();
  if (mode_name_ == &::google::protobuf::internal::kEmptyString) {
    mode_name_ = new ::std::string;
  }
  mode_name_->assign(value);
}
inline void TNVHWInfo::set_mode_name(const char* value, size_t size) {
  set_has_mode_name();
  if (mode_name_ == &::google::protobuf::internal::kEmptyString) {
    mode_name_ = new ::std::string;
  }
  mode_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVHWInfo::mutable_mode_name() {
  set_has_mode_name();
  if (mode_name_ == &::google::protobuf::internal::kEmptyString) {
    mode_name_ = new ::std::string;
  }
  return mode_name_;
}
inline ::std::string* TNVHWInfo::release_mode_name() {
  clear_has_mode_name();
  if (mode_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mode_name_;
    mode_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVHWInfo::set_allocated_mode_name(::std::string* mode_name) {
  if (mode_name_ != &::google::protobuf::internal::kEmptyString) {
    delete mode_name_;
  }
  if (mode_name) {
    set_has_mode_name();
    mode_name_ = mode_name;
  } else {
    clear_has_mode_name();
    mode_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fpga1_ver = 2;
inline bool TNVHWInfo::has_fpga1_ver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVHWInfo::set_has_fpga1_ver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVHWInfo::clear_has_fpga1_ver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVHWInfo::clear_fpga1_ver() {
  if (fpga1_ver_ != &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_->clear();
  }
  clear_has_fpga1_ver();
}
inline const ::std::string& TNVHWInfo::fpga1_ver() const {
  return *fpga1_ver_;
}
inline void TNVHWInfo::set_fpga1_ver(const ::std::string& value) {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  fpga1_ver_->assign(value);
}
inline void TNVHWInfo::set_fpga1_ver(const char* value) {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  fpga1_ver_->assign(value);
}
inline void TNVHWInfo::set_fpga1_ver(const char* value, size_t size) {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  fpga1_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVHWInfo::mutable_fpga1_ver() {
  set_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    fpga1_ver_ = new ::std::string;
  }
  return fpga1_ver_;
}
inline ::std::string* TNVHWInfo::release_fpga1_ver() {
  clear_has_fpga1_ver();
  if (fpga1_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fpga1_ver_;
    fpga1_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVHWInfo::set_allocated_fpga1_ver(::std::string* fpga1_ver) {
  if (fpga1_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete fpga1_ver_;
  }
  if (fpga1_ver) {
    set_has_fpga1_ver();
    fpga1_ver_ = fpga1_ver;
  } else {
    clear_has_fpga1_ver();
    fpga1_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cpld_ver = 3;
inline bool TNVHWInfo::has_cpld_ver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVHWInfo::set_has_cpld_ver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVHWInfo::clear_has_cpld_ver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVHWInfo::clear_cpld_ver() {
  if (cpld_ver_ != &::google::protobuf::internal::kEmptyString) {
    cpld_ver_->clear();
  }
  clear_has_cpld_ver();
}
inline const ::std::string& TNVHWInfo::cpld_ver() const {
  return *cpld_ver_;
}
inline void TNVHWInfo::set_cpld_ver(const ::std::string& value) {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  cpld_ver_->assign(value);
}
inline void TNVHWInfo::set_cpld_ver(const char* value) {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  cpld_ver_->assign(value);
}
inline void TNVHWInfo::set_cpld_ver(const char* value, size_t size) {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  cpld_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVHWInfo::mutable_cpld_ver() {
  set_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    cpld_ver_ = new ::std::string;
  }
  return cpld_ver_;
}
inline ::std::string* TNVHWInfo::release_cpld_ver() {
  clear_has_cpld_ver();
  if (cpld_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpld_ver_;
    cpld_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVHWInfo::set_allocated_cpld_ver(::std::string* cpld_ver) {
  if (cpld_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete cpld_ver_;
  }
  if (cpld_ver) {
    set_has_cpld_ver();
    cpld_ver_ = cpld_ver;
  } else {
    clear_has_cpld_ver();
    cpld_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string serial_num = 4;
inline bool TNVHWInfo::has_serial_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVHWInfo::set_has_serial_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVHWInfo::clear_has_serial_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVHWInfo::clear_serial_num() {
  if (serial_num_ != &::google::protobuf::internal::kEmptyString) {
    serial_num_->clear();
  }
  clear_has_serial_num();
}
inline const ::std::string& TNVHWInfo::serial_num() const {
  return *serial_num_;
}
inline void TNVHWInfo::set_serial_num(const ::std::string& value) {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  serial_num_->assign(value);
}
inline void TNVHWInfo::set_serial_num(const char* value) {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  serial_num_->assign(value);
}
inline void TNVHWInfo::set_serial_num(const char* value, size_t size) {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  serial_num_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVHWInfo::mutable_serial_num() {
  set_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    serial_num_ = new ::std::string;
  }
  return serial_num_;
}
inline ::std::string* TNVHWInfo::release_serial_num() {
  clear_has_serial_num();
  if (serial_num_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_num_;
    serial_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVHWInfo::set_allocated_serial_num(::std::string* serial_num) {
  if (serial_num_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_num_;
  }
  if (serial_num) {
    set_has_serial_num();
    serial_num_ = serial_num;
  } else {
    clear_has_serial_num();
    serial_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inf_ver = 5;
inline bool TNVHWInfo::has_inf_ver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVHWInfo::set_has_inf_ver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVHWInfo::clear_has_inf_ver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVHWInfo::clear_inf_ver() {
  if (inf_ver_ != &::google::protobuf::internal::kEmptyString) {
    inf_ver_->clear();
  }
  clear_has_inf_ver();
}
inline const ::std::string& TNVHWInfo::inf_ver() const {
  return *inf_ver_;
}
inline void TNVHWInfo::set_inf_ver(const ::std::string& value) {
  set_has_inf_ver();
  if (inf_ver_ == &::google::protobuf::internal::kEmptyString) {
    inf_ver_ = new ::std::string;
  }
  inf_ver_->assign(value);
}
inline void TNVHWInfo::set_inf_ver(const char* value) {
  set_has_inf_ver();
  if (inf_ver_ == &::google::protobuf::internal::kEmptyString) {
    inf_ver_ = new ::std::string;
  }
  inf_ver_->assign(value);
}
inline void TNVHWInfo::set_inf_ver(const char* value, size_t size) {
  set_has_inf_ver();
  if (inf_ver_ == &::google::protobuf::internal::kEmptyString) {
    inf_ver_ = new ::std::string;
  }
  inf_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVHWInfo::mutable_inf_ver() {
  set_has_inf_ver();
  if (inf_ver_ == &::google::protobuf::internal::kEmptyString) {
    inf_ver_ = new ::std::string;
  }
  return inf_ver_;
}
inline ::std::string* TNVHWInfo::release_inf_ver() {
  clear_has_inf_ver();
  if (inf_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inf_ver_;
    inf_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVHWInfo::set_allocated_inf_ver(::std::string* inf_ver) {
  if (inf_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete inf_ver_;
  }
  if (inf_ver) {
    set_has_inf_ver();
    inf_ver_ = inf_ver;
  } else {
    clear_has_inf_ver();
    inf_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hw_ver = 6;
inline bool TNVHWInfo::has_hw_ver() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVHWInfo::set_has_hw_ver() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVHWInfo::clear_has_hw_ver() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVHWInfo::clear_hw_ver() {
  if (hw_ver_ != &::google::protobuf::internal::kEmptyString) {
    hw_ver_->clear();
  }
  clear_has_hw_ver();
}
inline const ::std::string& TNVHWInfo::hw_ver() const {
  return *hw_ver_;
}
inline void TNVHWInfo::set_hw_ver(const ::std::string& value) {
  set_has_hw_ver();
  if (hw_ver_ == &::google::protobuf::internal::kEmptyString) {
    hw_ver_ = new ::std::string;
  }
  hw_ver_->assign(value);
}
inline void TNVHWInfo::set_hw_ver(const char* value) {
  set_has_hw_ver();
  if (hw_ver_ == &::google::protobuf::internal::kEmptyString) {
    hw_ver_ = new ::std::string;
  }
  hw_ver_->assign(value);
}
inline void TNVHWInfo::set_hw_ver(const char* value, size_t size) {
  set_has_hw_ver();
  if (hw_ver_ == &::google::protobuf::internal::kEmptyString) {
    hw_ver_ = new ::std::string;
  }
  hw_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVHWInfo::mutable_hw_ver() {
  set_has_hw_ver();
  if (hw_ver_ == &::google::protobuf::internal::kEmptyString) {
    hw_ver_ = new ::std::string;
  }
  return hw_ver_;
}
inline ::std::string* TNVHWInfo::release_hw_ver() {
  clear_has_hw_ver();
  if (hw_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hw_ver_;
    hw_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVHWInfo::set_allocated_hw_ver(::std::string* hw_ver) {
  if (hw_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete hw_ver_;
  }
  if (hw_ver) {
    set_has_hw_ver();
    hw_ver_ = hw_ver;
  } else {
    clear_has_hw_ver();
    hw_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sf_ver = 7;
inline bool TNVHWInfo::has_sf_ver() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVHWInfo::set_has_sf_ver() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVHWInfo::clear_has_sf_ver() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVHWInfo::clear_sf_ver() {
  if (sf_ver_ != &::google::protobuf::internal::kEmptyString) {
    sf_ver_->clear();
  }
  clear_has_sf_ver();
}
inline const ::std::string& TNVHWInfo::sf_ver() const {
  return *sf_ver_;
}
inline void TNVHWInfo::set_sf_ver(const ::std::string& value) {
  set_has_sf_ver();
  if (sf_ver_ == &::google::protobuf::internal::kEmptyString) {
    sf_ver_ = new ::std::string;
  }
  sf_ver_->assign(value);
}
inline void TNVHWInfo::set_sf_ver(const char* value) {
  set_has_sf_ver();
  if (sf_ver_ == &::google::protobuf::internal::kEmptyString) {
    sf_ver_ = new ::std::string;
  }
  sf_ver_->assign(value);
}
inline void TNVHWInfo::set_sf_ver(const char* value, size_t size) {
  set_has_sf_ver();
  if (sf_ver_ == &::google::protobuf::internal::kEmptyString) {
    sf_ver_ = new ::std::string;
  }
  sf_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVHWInfo::mutable_sf_ver() {
  set_has_sf_ver();
  if (sf_ver_ == &::google::protobuf::internal::kEmptyString) {
    sf_ver_ = new ::std::string;
  }
  return sf_ver_;
}
inline ::std::string* TNVHWInfo::release_sf_ver() {
  clear_has_sf_ver();
  if (sf_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sf_ver_;
    sf_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVHWInfo::set_allocated_sf_ver(::std::string* sf_ver) {
  if (sf_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete sf_ver_;
  }
  if (sf_ver) {
    set_has_sf_ver();
    sf_ver_ = sf_ver;
  } else {
    clear_has_sf_ver();
    sf_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.EmNvMtModel emMtMdodel = 8;
inline bool TNVHWInfo::has_emmtmdodel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVHWInfo::set_has_emmtmdodel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVHWInfo::clear_has_emmtmdodel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVHWInfo::clear_emmtmdodel() {
  emmtmdodel_ = 0;
  clear_has_emmtmdodel();
}
inline ::nv::EmNvMtModel TNVHWInfo::emmtmdodel() const {
  return static_cast< ::nv::EmNvMtModel >(emmtmdodel_);
}
inline void TNVHWInfo::set_emmtmdodel(::nv::EmNvMtModel value) {
  assert(::nv::EmNvMtModel_IsValid(value));
  set_has_emmtmdodel();
  emmtmdodel_ = value;
}

// -------------------------------------------------------------------

// TNVMtInfo

// optional .nv.EmNvCallState mt_conf = 1;
inline bool TNVMtInfo::has_mt_conf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtInfo::set_has_mt_conf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtInfo::clear_has_mt_conf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtInfo::clear_mt_conf() {
  mt_conf_ = 0;
  clear_has_mt_conf();
}
inline ::nv::EmNvCallState TNVMtInfo::mt_conf() const {
  return static_cast< ::nv::EmNvCallState >(mt_conf_);
}
inline void TNVMtInfo::set_mt_conf(::nv::EmNvCallState value) {
  assert(::nv::EmNvCallState_IsValid(value));
  set_has_mt_conf();
  mt_conf_ = value;
}

// optional bool send_dual = 2;
inline bool TNVMtInfo::has_send_dual() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtInfo::set_has_send_dual() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtInfo::clear_has_send_dual() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtInfo::clear_send_dual() {
  send_dual_ = false;
  clear_has_send_dual();
}
inline bool TNVMtInfo::send_dual() const {
  return send_dual_;
}
inline void TNVMtInfo::set_send_dual(bool value) {
  set_has_send_dual();
  send_dual_ = value;
}

// optional bool recv_dual = 3;
inline bool TNVMtInfo::has_recv_dual() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVMtInfo::set_has_recv_dual() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVMtInfo::clear_has_recv_dual() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVMtInfo::clear_recv_dual() {
  recv_dual_ = false;
  clear_has_recv_dual();
}
inline bool TNVMtInfo::recv_dual() const {
  return recv_dual_;
}
inline void TNVMtInfo::set_recv_dual(bool value) {
  set_has_recv_dual();
  recv_dual_ = value;
}

// optional uint32 answermode = 4;
inline bool TNVMtInfo::has_answermode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVMtInfo::set_has_answermode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVMtInfo::clear_has_answermode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVMtInfo::clear_answermode() {
  answermode_ = 0u;
  clear_has_answermode();
}
inline ::google::protobuf::uint32 TNVMtInfo::answermode() const {
  return answermode_;
}
inline void TNVMtInfo::set_answermode(::google::protobuf::uint32 value) {
  set_has_answermode();
  answermode_ = value;
}

// optional string mt_ip = 5;
inline bool TNVMtInfo::has_mt_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVMtInfo::set_has_mt_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVMtInfo::clear_has_mt_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVMtInfo::clear_mt_ip() {
  if (mt_ip_ != &::google::protobuf::internal::kEmptyString) {
    mt_ip_->clear();
  }
  clear_has_mt_ip();
}
inline const ::std::string& TNVMtInfo::mt_ip() const {
  return *mt_ip_;
}
inline void TNVMtInfo::set_mt_ip(const ::std::string& value) {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  mt_ip_->assign(value);
}
inline void TNVMtInfo::set_mt_ip(const char* value) {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  mt_ip_->assign(value);
}
inline void TNVMtInfo::set_mt_ip(const char* value, size_t size) {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  mt_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVMtInfo::mutable_mt_ip() {
  set_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    mt_ip_ = new ::std::string;
  }
  return mt_ip_;
}
inline ::std::string* TNVMtInfo::release_mt_ip() {
  clear_has_mt_ip();
  if (mt_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mt_ip_;
    mt_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVMtInfo::set_allocated_mt_ip(::std::string* mt_ip) {
  if (mt_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete mt_ip_;
  }
  if (mt_ip) {
    set_has_mt_ip();
    mt_ip_ = mt_ip;
  } else {
    clear_has_mt_ip();
    mt_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .nv.EmMtVer mt_mode = 6;
inline bool TNVMtInfo::has_mt_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TNVMtInfo::set_has_mt_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TNVMtInfo::clear_has_mt_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TNVMtInfo::clear_mt_mode() {
  mt_mode_ = 0;
  clear_has_mt_mode();
}
inline ::nv::EmMtVer TNVMtInfo::mt_mode() const {
  return static_cast< ::nv::EmMtVer >(mt_mode_);
}
inline void TNVMtInfo::set_mt_mode(::nv::EmMtVer value) {
  assert(::nv::EmMtVer_IsValid(value));
  set_has_mt_mode();
  mt_mode_ = value;
}

// optional bool sleep = 7;
inline bool TNVMtInfo::has_sleep() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TNVMtInfo::set_has_sleep() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TNVMtInfo::clear_has_sleep() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TNVMtInfo::clear_sleep() {
  sleep_ = false;
  clear_has_sleep();
}
inline bool TNVMtInfo::sleep() const {
  return sleep_;
}
inline void TNVMtInfo::set_sleep(bool value) {
  set_has_sleep();
  sleep_ = value;
}

// optional .nv.TNVHWInfo thwinfo = 8;
inline bool TNVMtInfo::has_thwinfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TNVMtInfo::set_has_thwinfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TNVMtInfo::clear_has_thwinfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TNVMtInfo::clear_thwinfo() {
  if (thwinfo_ != NULL) thwinfo_->::nv::TNVHWInfo::Clear();
  clear_has_thwinfo();
}
inline const ::nv::TNVHWInfo& TNVMtInfo::thwinfo() const {
  return thwinfo_ != NULL ? *thwinfo_ : *default_instance_->thwinfo_;
}
inline ::nv::TNVHWInfo* TNVMtInfo::mutable_thwinfo() {
  set_has_thwinfo();
  if (thwinfo_ == NULL) thwinfo_ = new ::nv::TNVHWInfo;
  return thwinfo_;
}
inline ::nv::TNVHWInfo* TNVMtInfo::release_thwinfo() {
  clear_has_thwinfo();
  ::nv::TNVHWInfo* temp = thwinfo_;
  thwinfo_ = NULL;
  return temp;
}
inline void TNVMtInfo::set_allocated_thwinfo(::nv::TNVHWInfo* thwinfo) {
  delete thwinfo_;
  thwinfo_ = thwinfo;
  if (thwinfo) {
    set_has_thwinfo();
  } else {
    clear_has_thwinfo();
  }
}

// -------------------------------------------------------------------

// TNVQkVer

// optional .nv.EmNvImixVidSrcType src_type = 1;
inline bool TNVQkVer::has_src_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVQkVer::set_has_src_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVQkVer::clear_has_src_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVQkVer::clear_src_type() {
  src_type_ = 0;
  clear_has_src_type();
}
inline ::nv::EmNvImixVidSrcType TNVQkVer::src_type() const {
  return static_cast< ::nv::EmNvImixVidSrcType >(src_type_);
}
inline void TNVQkVer::set_src_type(::nv::EmNvImixVidSrcType value) {
  assert(::nv::EmNvImixVidSrcType_IsValid(value));
  set_has_src_type();
  src_type_ = value;
}

// optional string ver = 2;
inline bool TNVQkVer::has_ver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVQkVer::set_has_ver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVQkVer::clear_has_ver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVQkVer::clear_ver() {
  if (ver_ != &::google::protobuf::internal::kEmptyString) {
    ver_->clear();
  }
  clear_has_ver();
}
inline const ::std::string& TNVQkVer::ver() const {
  return *ver_;
}
inline void TNVQkVer::set_ver(const ::std::string& value) {
  set_has_ver();
  if (ver_ == &::google::protobuf::internal::kEmptyString) {
    ver_ = new ::std::string;
  }
  ver_->assign(value);
}
inline void TNVQkVer::set_ver(const char* value) {
  set_has_ver();
  if (ver_ == &::google::protobuf::internal::kEmptyString) {
    ver_ = new ::std::string;
  }
  ver_->assign(value);
}
inline void TNVQkVer::set_ver(const char* value, size_t size) {
  set_has_ver();
  if (ver_ == &::google::protobuf::internal::kEmptyString) {
    ver_ = new ::std::string;
  }
  ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVQkVer::mutable_ver() {
  set_has_ver();
  if (ver_ == &::google::protobuf::internal::kEmptyString) {
    ver_ = new ::std::string;
  }
  return ver_;
}
inline ::std::string* TNVQkVer::release_ver() {
  clear_has_ver();
  if (ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ver_;
    ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVQkVer::set_allocated_ver(::std::string* ver) {
  if (ver_ != &::google::protobuf::internal::kEmptyString) {
    delete ver_;
  }
  if (ver) {
    set_has_ver();
    ver_ = ver;
  } else {
    clear_has_ver();
    ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string vid_name = 3;
inline bool TNVQkVer::has_vid_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVQkVer::set_has_vid_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVQkVer::clear_has_vid_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVQkVer::clear_vid_name() {
  if (vid_name_ != &::google::protobuf::internal::kEmptyString) {
    vid_name_->clear();
  }
  clear_has_vid_name();
}
inline const ::std::string& TNVQkVer::vid_name() const {
  return *vid_name_;
}
inline void TNVQkVer::set_vid_name(const ::std::string& value) {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  vid_name_->assign(value);
}
inline void TNVQkVer::set_vid_name(const char* value) {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  vid_name_->assign(value);
}
inline void TNVQkVer::set_vid_name(const char* value, size_t size) {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  vid_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TNVQkVer::mutable_vid_name() {
  set_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    vid_name_ = new ::std::string;
  }
  return vid_name_;
}
inline ::std::string* TNVQkVer::release_vid_name() {
  clear_has_vid_name();
  if (vid_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vid_name_;
    vid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TNVQkVer::set_allocated_vid_name(::std::string* vid_name) {
  if (vid_name_ != &::google::protobuf::internal::kEmptyString) {
    delete vid_name_;
  }
  if (vid_name) {
    set_has_vid_name();
    vid_name_ = vid_name;
  } else {
    clear_has_vid_name();
    vid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool use = 4;
inline bool TNVQkVer::has_use() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVQkVer::set_has_use() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVQkVer::clear_has_use() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVQkVer::clear_use() {
  use_ = false;
  clear_has_use();
}
inline bool TNVQkVer::use() const {
  return use_;
}
inline void TNVQkVer::set_use(bool value) {
  set_has_use();
  use_ = value;
}

// -------------------------------------------------------------------

// TNVMtAutoSleepCfg

// optional bool enable = 1;
inline bool TNVMtAutoSleepCfg::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVMtAutoSleepCfg::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVMtAutoSleepCfg::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVMtAutoSleepCfg::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool TNVMtAutoSleepCfg::enable() const {
  return enable_;
}
inline void TNVMtAutoSleepCfg::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional uint32 time = 2;
inline bool TNVMtAutoSleepCfg::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVMtAutoSleepCfg::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVMtAutoSleepCfg::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVMtAutoSleepCfg::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 TNVMtAutoSleepCfg::time() const {
  return time_;
}
inline void TNVMtAutoSleepCfg::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional bool allowcall = 3;
inline bool TNVMtAutoSleepCfg::has_allowcall() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVMtAutoSleepCfg::set_has_allowcall() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVMtAutoSleepCfg::clear_has_allowcall() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVMtAutoSleepCfg::clear_allowcall() {
  allowcall_ = false;
  clear_has_allowcall();
}
inline bool TNVMtAutoSleepCfg::allowcall() const {
  return allowcall_;
}
inline void TNVMtAutoSleepCfg::set_allowcall(bool value) {
  set_has_allowcall();
  allowcall_ = value;
}

// -------------------------------------------------------------------

// TNVClearSrcType

// repeated .nv.EmNvImixVidSrcType src_type = 1;
inline int TNVClearSrcType::src_type_size() const {
  return src_type_.size();
}
inline void TNVClearSrcType::clear_src_type() {
  src_type_.Clear();
}
inline ::nv::EmNvImixVidSrcType TNVClearSrcType::src_type(int index) const {
  return static_cast< ::nv::EmNvImixVidSrcType >(src_type_.Get(index));
}
inline void TNVClearSrcType::set_src_type(int index, ::nv::EmNvImixVidSrcType value) {
  assert(::nv::EmNvImixVidSrcType_IsValid(value));
  src_type_.Set(index, value);
}
inline void TNVClearSrcType::add_src_type(::nv::EmNvImixVidSrcType value) {
  assert(::nv::EmNvImixVidSrcType_IsValid(value));
  src_type_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TNVClearSrcType::src_type() const {
  return src_type_;
}
inline ::google::protobuf::RepeatedField<int>*
TNVClearSrcType::mutable_src_type() {
  return &src_type_;
}

// -------------------------------------------------------------------

// TNVAllUpgradePackageContent

// optional bool is_has_app_package = 1;
inline bool TNVAllUpgradePackageContent::has_is_has_app_package() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVAllUpgradePackageContent::set_has_is_has_app_package() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVAllUpgradePackageContent::clear_has_is_has_app_package() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVAllUpgradePackageContent::clear_is_has_app_package() {
  is_has_app_package_ = false;
  clear_has_is_has_app_package();
}
inline bool TNVAllUpgradePackageContent::is_has_app_package() const {
  return is_has_app_package_;
}
inline void TNVAllUpgradePackageContent::set_is_has_app_package(bool value) {
  set_has_is_has_app_package();
  is_has_app_package_ = value;
}

// optional bool is_has_imix_package = 2;
inline bool TNVAllUpgradePackageContent::has_is_has_imix_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVAllUpgradePackageContent::set_has_is_has_imix_package() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVAllUpgradePackageContent::clear_has_is_has_imix_package() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVAllUpgradePackageContent::clear_is_has_imix_package() {
  is_has_imix_package_ = false;
  clear_has_is_has_imix_package();
}
inline bool TNVAllUpgradePackageContent::is_has_imix_package() const {
  return is_has_imix_package_;
}
inline void TNVAllUpgradePackageContent::set_is_has_imix_package(bool value) {
  set_has_is_has_imix_package();
  is_has_imix_package_ = value;
}

// optional bool is_has_power_package = 3;
inline bool TNVAllUpgradePackageContent::has_is_has_power_package() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVAllUpgradePackageContent::set_has_is_has_power_package() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVAllUpgradePackageContent::clear_has_is_has_power_package() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVAllUpgradePackageContent::clear_is_has_power_package() {
  is_has_power_package_ = false;
  clear_has_is_has_power_package();
}
inline bool TNVAllUpgradePackageContent::is_has_power_package() const {
  return is_has_power_package_;
}
inline void TNVAllUpgradePackageContent::set_is_has_power_package(bool value) {
  set_has_is_has_power_package();
  is_has_power_package_ = value;
}

// optional bool is_has_openwrt_package = 4;
inline bool TNVAllUpgradePackageContent::has_is_has_openwrt_package() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TNVAllUpgradePackageContent::set_has_is_has_openwrt_package() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TNVAllUpgradePackageContent::clear_has_is_has_openwrt_package() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TNVAllUpgradePackageContent::clear_is_has_openwrt_package() {
  is_has_openwrt_package_ = false;
  clear_has_is_has_openwrt_package();
}
inline bool TNVAllUpgradePackageContent::is_has_openwrt_package() const {
  return is_has_openwrt_package_;
}
inline void TNVAllUpgradePackageContent::set_is_has_openwrt_package(bool value) {
  set_has_is_has_openwrt_package();
  is_has_openwrt_package_ = value;
}

// optional bool is_has_pad_package = 5;
inline bool TNVAllUpgradePackageContent::has_is_has_pad_package() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TNVAllUpgradePackageContent::set_has_is_has_pad_package() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TNVAllUpgradePackageContent::clear_has_is_has_pad_package() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TNVAllUpgradePackageContent::clear_is_has_pad_package() {
  is_has_pad_package_ = false;
  clear_has_is_has_pad_package();
}
inline bool TNVAllUpgradePackageContent::is_has_pad_package() const {
  return is_has_pad_package_;
}
inline void TNVAllUpgradePackageContent::set_is_has_pad_package(bool value) {
  set_has_is_has_pad_package();
  is_has_pad_package_ = value;
}

// -------------------------------------------------------------------

// TNVPadLoginInfo

// optional uint32 node_id = 1;
inline bool TNVPadLoginInfo::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TNVPadLoginInfo::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TNVPadLoginInfo::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TNVPadLoginInfo::clear_node_id() {
  node_id_ = 0u;
  clear_has_node_id();
}
inline ::google::protobuf::uint32 TNVPadLoginInfo::node_id() const {
  return node_id_;
}
inline void TNVPadLoginInfo::set_node_id(::google::protobuf::uint32 value) {
  set_has_node_id();
  node_id_ = value;
}

// optional uint32 appinst_id = 2;
inline bool TNVPadLoginInfo::has_appinst_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TNVPadLoginInfo::set_has_appinst_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TNVPadLoginInfo::clear_has_appinst_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TNVPadLoginInfo::clear_appinst_id() {
  appinst_id_ = 0u;
  clear_has_appinst_id();
}
inline ::google::protobuf::uint32 TNVPadLoginInfo::appinst_id() const {
  return appinst_id_;
}
inline void TNVPadLoginInfo::set_appinst_id(::google::protobuf::uint32 value) {
  set_has_appinst_id();
  appinst_id_ = value;
}

// optional bool download = 3;
inline bool TNVPadLoginInfo::has_download() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TNVPadLoginInfo::set_has_download() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TNVPadLoginInfo::clear_has_download() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TNVPadLoginInfo::clear_download() {
  download_ = false;
  clear_has_download();
}
inline bool TNVPadLoginInfo::download() const {
  return download_;
}
inline void TNVPadLoginInfo::set_download(bool value) {
  set_has_download();
  download_ = value;
}

// -------------------------------------------------------------------

// TNVPadLoginInfos

// repeated .nv.TNVPadLoginInfo login_info_list = 1;
inline int TNVPadLoginInfos::login_info_list_size() const {
  return login_info_list_.size();
}
inline void TNVPadLoginInfos::clear_login_info_list() {
  login_info_list_.Clear();
}
inline const ::nv::TNVPadLoginInfo& TNVPadLoginInfos::login_info_list(int index) const {
  return login_info_list_.Get(index);
}
inline ::nv::TNVPadLoginInfo* TNVPadLoginInfos::mutable_login_info_list(int index) {
  return login_info_list_.Mutable(index);
}
inline ::nv::TNVPadLoginInfo* TNVPadLoginInfos::add_login_info_list() {
  return login_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nv::TNVPadLoginInfo >&
TNVPadLoginInfos::login_info_list() const {
  return login_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::nv::TNVPadLoginInfo >*
TNVPadLoginInfos::mutable_login_info_list() {
  return &login_info_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nv

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nvstructcfg_2eproto__INCLUDED
